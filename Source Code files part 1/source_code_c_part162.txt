 also just to be tidy

  /* Fix up the driver load linked list */
  if (idFirstDriver == (int)hDriver-1)
    {
      idFirstDriver = lpdt[(int)hDriver-1].idNextDriver;
      if (idFirstDriver == -1)
        {
          /* No more drivers in the chain */
          idFirstDriver    = -1;
          idLastDriver     = -1;
          cInstalledDrivers= 0;
          goto Done;
        }
      else
        {
          /* Make prev entry of new first driver -1 */
          lpdt[idFirstDriver].idPrevDriver = -1;
        }
    }
  else if (idLastDriver == (int)hDriver-1)
    {
      /* We are freeing the last driver. So find a new last driver. */
      idLastDriver = lpdt[(int)hDriver-1].idPrevDriver;
      lpdt[idLastDriver].idNextDriver = -1;
    }
  else
    {
      /* We are freeing a driver in the middle of the list somewhere. */
      id = lpdt[(int)hDriver-1].idPrevDriver;
      lpdt[id].idNextDriver = lpdt[(int)hDriver-1].idNextDriver;

      id = lpdt[(int)hDriver-1].idNextDriver;
      lpdt[id].idPrevDriver = lpdt[(int)hDriver-1].idPrevDriver;
    }

Done:
  return(w-1);
}




LRESULT InternalOpenDriver(LPCSTR szDriverName,
                                   LPCSTR szSectionName,
                                   LPARAM lParam2,
                                   BOOL  fSendEnable)
{
  HDRVR         hDriver;
  LPDRIVERTABLE lpdt;
  LRESULT       result;
  char          sz[128];

  if (hDriver = (HDRVR)LOWORD(InternalLoadDriver(szDriverName, szSectionName,
                                          sz, sizeof(sz), fSendEnable)))
    {
      /* Set the driver identifier to the DRV_OPEN call to the driver
       * handle. This will let people build helper functions that the driver
       * can call with a unique identifier if they want to.
       */

      lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

      lpdt[(int)hDriver-1].dwDriverIdentifier = (DWORD)(WORD)hDriver;

      result = SendDriverMessage(hDriver,
                                 DRV_OPEN,
                                 (LPARAM)(LPSTR)sz,
                                 lParam2);
      if (!result)
          InternalFreeDriver(hDriver, fSendEnable);
      else
        {
          lpdt = (LPDRIVERTABLE)MAKELONG(0,hInstalledDriverList);

          lpdt[(int)hDriver-1].dwDriverIdentifier = (DWORD)result;

          result = (LRESULT)(DWORD)(WORD)hDriver;
        }
    }
  else
      result = 0L;

  return(result);
}


LRESULT InternalCloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2, BOOL fSendDisable)
{
  LPDRIVERTABLE lpdt;
  LRESULT       result;
  int           index;
  BOOL          f;
  HMODULE       hm;

  // check handle in valid range.

  if ((int)hDriver > cInstalledDrivers)
      return(FALSE);

  lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

  if (!lpdt[(int)hDriver-1].hModule)
      return(FALSE);

  result = SendDriverMessage(hDriver, DRV_CLOSE, lParam1, lParam2);

  if (result)
    {
      // Driver didn't abort close

      f  = lpdt[(int)hDriver-1].fFirstEntry;
      hm = lpdt[(int)hDriver-1].hModule;

      if (InternalFreeDriver(hDriver, fSendDisable) && f)
        {
          lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

          /* Only one entry for the driver in the driver list has the first
           * instance flag set. This is to make it easier to handle system
           * messages that only need to be sent to a driver once.
           *
           * To maintain the flag, we must set the flag in one of the other
           * entries if we remove the driver entry with the flag set.
           *
           * Note that InternalFreeDriver returns the new usage count of
           * the driver so if it is zero, we know that there are no other
           * entries for the driver in the list and so we don't have to
           * do this loop.
           */

          for (index=0;index<cInstalledDrivers;index++)
              if (lpdt[index].hModule == hm && !lpdt[index].fFirstEntry)
                {
                  lpdt[index].fFirstEntry = 1;
                  break;
                }
        }

    }

  return(result);
}


HDRVR API IOpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam)
{
  LRESULT result;

  /* The driver receives the following messages when it is opened. If it isn't
   * loaded, the library is loaded and the DRV_LOAD message is sent.  If
   * DRV_LOAD returns nonzero, the DRV_ENABLE message is sent.  Once the
   * driver is loaded or if it was previously loaded, the DRV_OPEN message is
   * sent.
   */
  result = InternalOpenDriver(szDriverName, szSectionName, lParam, TRUE);

  return((HDRVR)LOWORD(result));
}


LRESULT API ICloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2)
{
  /*  The driver will receive the following message sequence:
   *
   *      DRV_CLOSE
   *      if DRV_CLOSE returns non-zero
   *          if driver usage count = 1
   *              DRV_DISABLE
   *              DRV_FREE
   */

   return(InternalCloseDriver(hDriver, lParam1, lParam2, TRUE));
}


HINSTANCE API IGetDriverModuleHandle(HDRVR hDriver)
/* effects: Returns the module handle associated with the given driver ID.
 */
{
  LPDRIVERTABLE lpdt;
  HINSTANCE hModule = NULL;

  if (hDriver && ((int)hDriver <= cInstalledDrivers))
    {
      lpdt = (LPDRIVERTABLE)MAKELP(hInstalledDriverList,0);

      return lpdt[(int)hDriver-1].hModule;
    }
  else
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\helpcall.c ===
/*****************************************************************************
*                                                                            *
*  HELPCALL.C                                                                *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1989.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Program Description:  Sample interface to windows help                    *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created by RKB      11/30/88                           *
*                     Revised to new API  1/12/88  (RKB)                     *
*                     Added to USER       3/28/89  (BG)                      *
*                     Slight update       6/15/89  (BG)                      *
*                     Clean ugly code     10/30/89 (BG)                      *
*                     GlobalFree if QUIT  1/26/90  (CRC)                     *
*                                                                            *
******************************************************************************
*/

#define   NO_REDEF_SENDMESSAGE
#include  "user.h"
#define _WINGDIP_             // We need to define these to prevent 
#include  "wowcmpat.h"        // redefinition of the GACF flags

#define WM_WINHELP 0x38
DWORD API NotifyWow(WORD, LPBYTE);

BOOL API 
Win32WinHelp(
	HWND hwndMain, 
	LPCSTR lpszHelp, 
	UINT usCommand, 
	DWORD ulData
        );

DWORD WINAPI
GetWOWCompatFlagsEx(
        void
        );


/* This must match its counterpart in mvdm\inc\wowusr.h */
#define NW_WINHELP         6 // Internal

WORD      msgWinHelp = 0;
char CODESEG szMS_WINHELP[] = "MS_WINHELP";


/*

Communicating with WinHelp involves using Windows SendMessage() function
to pass blocks of information to WinHelp.  The call looks like.

     SendMessage(hwndHelp, msgWinHelp, hwndMain, (LONG)hHlp);

Where:

  hwndHelp - the window handle of the help application.  This
             is obtained by enumerating all the windows in the
             system and sending them HELP_FIND commands.  The
             application may have to load WinHelp.
  msgWinHelp - the value obtained from a RegisterWindowMessage()
             szWINHELP
  hwndMain - the handle to the main window of the application
             calling help
  hHlp     - a handle to a block of data with a HLP structure
             at it head.

The data in the handle will look like:

         +-------------------+
         |     cbData        |
         |    usCommand      |
         |     ulTopic       |
         |    ulReserved     |
         |   offszHelpFile   |\     - offsets measured from beginning
       / |     offaData      | \      of header.
      /  +-------------------| /
     /   |  Help file name   |/
     \   |    and path       |
      \  +-------------------+
       \ |    Other data     |
         |    (keyword)      |
         +-------------------+

The defined commands are:

    HELP_CONTEXT   0x0001    Display topic in ulTopic
    HELP_KEY       0x0101    Display topic for keyword in offabData
    HELP_QUIT      0x0002    Terminate help

*/


/*******************
**
** Name:       HFill
**
** Purpose:    Builds a data block for communicating with help
**
** Arguments:  lpszHelp  - pointer to the name of the help file to use
**             usCommand - command being set to help
**             ulData    - data for the command
**
** Returns:    a handle to the data block or hNIL if the the
**             block could not be created.
**
*******************/


HANDLE HFill(LPCSTR lpszHelp, WORD usCommand, DWORD ulData)
{
  WORD     cb;                          /* Size of the data block           */
  HANDLE   hHlp;                        /* Handle to return                 */
  BYTE     bHigh;                       /* High byte of usCommand           */
  LPHLP    qhlp;                        /* Pointer to data block            */
                                        /* Calculate size                   */
  if (lpszHelp)
      cb = sizeof(HLP) + lstrlen(lpszHelp) + 1;
  else
      cb = sizeof(HLP);

  bHigh = (BYTE)HIBYTE(usCommand);

  if (bHigh == 1)
      cb += lstrlen((LPSTR)ulData) + 1;
  else if (bHigh == 2)
      cb += *((int far *)ulData);

                                        /* Get data block                   */
  if (!(hHlp = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, (DWORD)cb)))
      return NULL;

  if (!(qhlp = (LPHLP)GlobalLock(hHlp)))
    {
      GlobalFree(hHlp);
      return NULL;
    }

  qhlp->cbData        = cb;             /* Fill in info                     */
  qhlp->usCommand     = usCommand;
  qhlp->ulReserved    = 0;
  if (lpszHelp)
    {
      qhlp->offszHelpFile = sizeof(HLP);
      lstrcpy((LPSTR)(qhlp+1), lpszHelp);
    }
  else
      qhlp->offszHelpFile = 0;

  switch(bHigh)
    {
    case 0:
      qhlp->offabData = 0;
      qhlp->ulTopic   = ulData;
      break;
    case 1:
      qhlp->offabData = sizeof(HLP) + lstrlen(lpszHelp) + 1;
      lstrcpy((LPSTR)qhlp + qhlp->offabData,  (LPSTR)ulData);
      break;
    case 2:
      qhlp->offabData = sizeof(HLP) + lstrlen(lpszHelp) + 1;
      LCopyStruct((LPSTR)ulData, (LPSTR)qhlp + qhlp->offabData, *((int far *)ulData));
      break;
    }

   GlobalUnlock(hHlp);
   return hHlp;
  }



char CODESEG szEXECHELP[] = "\\WINHELP -x";

BOOL _fastcall LaunchHelper(LPSTR lpfile)
{
  int len;

  len = lstrlen(lpfile);

  if (lpfile[len-1]=='\\')
      /* Are we at the root?? If so, skip over leading backslash in text
       * string. */
      lstrcat(lpfile, szEXECHELP+1);
  else
      lstrcat(lpfile, szEXECHELP);

  return ((HINSTANCE)WinExec(lpfile, SW_SHOW) > HINSTANCE_ERROR);
}


BOOL LaunchHelp(VOID)
{
  char szFile[128];

  /* Search in windows directory */
  GetWindowsDirectory(szFile, sizeof(szFile));
  if (LaunchHelper(szFile))
      return(TRUE);

  /* Search system directory */
  GetSystemDirectory(szFile, sizeof(szFile));
  if (LaunchHelper(szFile))
      return(TRUE);

  /* Last ditch: simply let dos do it */
  lstrcpy(szFile, szEXECHELP+1);
  return ((HINSTANCE)WinExec(szFile, SW_SHOW) > HINSTANCE_ERROR);
}


/*******************
**
** Name:       WinHelp
**
** Purpose:    Displays help
**
** Arguments:
**             hwndMain        handle to main window of application
**             lpszHelp        path (if not current directory) and file
**                             to use for help topic.
**             usCommand       Command to send to help
**             ulData          Data associated with command:
**                             HELP_QUIT     - no data (undefined)
**                             HELP_LAST     - no data (undefined)
**                             HELP_CONTEXT  - context number to display
**                             HELP_KEY      - string ('\0' terminated)
**                                             use as keyword to topic
**                                             to display
**                             HELP_FIND     - no data (undefined)
**
** Returns:    TRUE iff success
**
*******************/

BOOL API IWinHelp(hwndMain, lpszHelp, usCommand, ulData)
HWND               hwndMain;
LPCSTR         lpszHelp;
UINT               usCommand;
DWORD              ulData;
{
  register HANDLE  hHlp;
  DWORD            dwHelpPid;           /* loword is hwndHelp             */
                                        /* hiword TRUE if hwndHelp is of this process */
  DWORD  dwWOWCompatFlagsEx;
  

  /* RAID BUG 394455
     Some apps have problems loading their help files with 16 bit winhelp. Hard coded paths,
     32 bit helper dlls, etc. These issues can be fixed by redirecting the call to winhelp32. 
     Check to see if the compatibility bit has been set for this app. */
  dwWOWCompatFlagsEx = GetWOWCompatFlagsEx();
  
  if (dwWOWCompatFlagsEx & WOWCFEX_USEWINHELP32) {
      return Win32WinHelp(hwndMain, lpszHelp, usCommand, ulData);
      }
  
  if (msgWinHelp == 0) {

    /* Register private WinHelp message for communicating to WinHelp via
     * WinHelp api.
     */
    char static CODESEG szWM_WINHELP[] = "WM_WINHELP";
    msgWinHelp = RegisterWindowMessage(szWM_WINHELP);
  }

  /* Move Help file name to a handle */
  if (!(hHlp = HFill(lpszHelp, usCommand, ulData)))
      return(FALSE);

  if ((dwHelpPid = (DWORD)NotifyWow(NW_WINHELP, szMS_WINHELP)) == (DWORD)NULL)
    {
      if (usCommand == HELP_QUIT)    /* Don't bother to load HELP just to*/
        {
          GlobalFree(hHlp);
          return(TRUE);
        }

      /* Can't find it --> launch it  */
      if (!LaunchHelp() || ((dwHelpPid = (DWORD)NotifyWow(NW_WINHELP, szMS_WINHELP)) == (DWORD)NULL))
        {
          /* Can't find help, or not enough memory to load help.*/
          GlobalFree(hHlp);
          return(FALSE);
        }

    }

  // if winhelp.exe was launched from this process, normal sendmessage else
  // we need to thunk the data across WOWVDM processes and the format is
  //     msg = WM_WINHELP, a private msg
  //     wparam = 0 instead of hwndMain, (note 1)
  //     lparam = LPHLP
  //
  // note 1: winhelp, calls GetWindowWord(wParam, GWW_HINSTANCE) when it receives HELP_QUIT
  //         command. If this matches a value in its table and is the only registered instance
  //         winhelp will close - this is quite ok undernormal circumstances (just one WOWVDM)
  //         but under multiple WOWVDM, numeric value of hinstances could be same for different
  //         hwnds.
  //
  //         So we workaround this by passing a NULL hwnd in wParam and by not sending HELP_QUIT
  //         message - which effectively implies that WinHelp will close only if there are no
  //         references to it from the same WOWVDM (as itself).
  //
  // This is the best compromise I could comeup with for running "only one WinHelp for all
  // WOWVDMs".
  //
  //                                                               - nanduri

  if (HIWORD(dwHelpPid)) {
      SendMessage((HWND)LOWORD(dwHelpPid), msgWinHelp, (WPARAM)hwndMain, MAKELPARAM(hHlp, 0));
  }
  else {
      if (usCommand != HELP_QUIT) {
          SendMessage((HWND)LOWORD(dwHelpPid), WM_WINHELP, (WPARAM)0, (LPARAM)GlobalLock(hHlp));
          GlobalUnlock(hHlp);
      }
  }

  GlobalFree(hHlp);
  return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\init.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  INIT.C
 *  WOW16 user initialisation code
 *
 *  History:
 *
 *  Created 15-Apr-1991 by Nigel Thompson (nigelt)
 *
 *  Revised 19-May-1991 by Jeff Parsons (jeffpar)
 *  IFDEF'ed everything, since everything was only needed by RMLOAD.C,
 *  and that has been largely IFDEF'ed as well (see RMLOAD.C for details)
--*/

#define FIRST_CALL_MUST_BE_USER_BUG

#include "user.h"


/* These must match counterparts in mvdm\inc\wowusr.h */
#define NW_FINALUSERINIT       4 // Internal
#define NW_KRNL386SEGS         5 // Internal

DWORD API NotifyWow(WORD, LPBYTE);
VOID FAR PASCAL PatchUserStrRtnsToThunk(VOID);
/***************************************************************************

    global data items

***************************************************************************/


#ifdef NEEDED
HDC hdcBits;        // USER's general hdc
OEMINFO oemInfo;                // lots of interresting info
#endif
#ifdef FIRST_CALL_MUST_BE_USER_BUG
HWND    hwndDesktop;        // handle to the desktop window
#endif

BOOL fThunkStrRtns;         // if TRUE we thunk to Win32 (see winlang.asm)



FARPROC LPCHECKMETAFILE;

/***************************************************************************

    initialisation routine

***************************************************************************/

int FAR PASCAL LibMain(HANDLE hInstance)
{
#ifdef NEEDED
    HDC hDC;
#endif
    HANDLE   hLib;
    HANDLE   hInstKrnl;

    dprintf(3,"Initializing...");

    // Notify the hInstance of USER to wow32.
    //                                                     - Nanduri
    //
    // Overload this to return the ANSI code page from Win32 GetACP.
    //                                                     - DaveHart 5-May-94
    //

    {
#ifdef PMODE32
        extern _cdecl wow16gpsi(void);
        extern _cdecl wow16CsrFlag(void);
        extern _cdecl wow16gHighestUserAddress(void);
#endif
        WORD wCS;
        extern WORD MaxDWPMsg;
        extern BYTE DWPBits[1];
        extern WORD cbDWPBits;

// NOTE: these two structs are also in mvdm\inc\wowusr.h 
//       USERCLIENTGLOBALS  &  KRNL386SEGS
//       - they must be the same!!!
        struct {
            WORD       hInstance;
            LPSTR FAR *lpgpsi;
            LPSTR FAR *lpCallCsrFlag;
            DWORD      dwBldInfo;
            LPWORD     lpwMaxDWPMsg;
            LPSTR      lpDWPBits;
            WORD       cbDWPBits;
            WORD       wUnusedPadding;
            DWORD      pfnGetProcModule;
            LPSTR FAR *lpHighestAddress;
        } UserInit16;

        struct {
            WORD CodeSeg1;
            WORD CodeSeg2;
            WORD CodeSeg3;
            WORD DataSeg1;
        } Krnl386Segs;
            
        UserInit16.hInstance        = (WORD)hInstance;
#ifdef PMODE32
        UserInit16.lpgpsi           = (LPSTR *)wow16gpsi;
        UserInit16.lpCallCsrFlag    = (LPSTR *)wow16CsrFlag;
        UserInit16.lpHighestAddress = (LPSTR *)&wow16gHighestUserAddress;
#else
        UserInit16.lpgpsi           = (LPSTR *)0;
        UserInit16.lpCallCsrFlag    = (LPSTR *)0;
        UserInit16.lpHighestAddress = (LPSTR *)0;
#endif

#ifdef WOWDBG
        UserInit16.dwBldInfo        = (((DWORD)WOW) << 16) | 0x80000000;
#else
        UserInit16.dwBldInfo        = (((DWORD)WOW) << 16);
#endif

        _asm mov wCS, cs;
        UserInit16.lpwMaxDWPMsg = (LPWORD) MAKELONG((WORD)&MaxDWPMsg, wCS);
        UserInit16.lpDWPBits = (LPBYTE) MAKELONG((WORD)&DWPBits[0], wCS);
        UserInit16.cbDWPBits = *(LPWORD) MAKELONG((WORD)&cbDWPBits, wCS);
        UserInit16.pfnGetProcModule = (DWORD)(FARPROC) GetProcModule;

        fThunkStrRtns = NotifyWow(NW_FINALUSERINIT, (LPBYTE)&UserInit16);

        // now that wow32 knows pfnGetProcModule we can call GetProcAddress
        // to get the kernel code & data segs
        hInstKrnl = LoadLibrary("krnl386.exe");
        FreeLibrary(hInstKrnl);

        Krnl386Segs.CodeSeg1 = HIWORD(GetProcAddress(hInstKrnl, 
                                                     "LoadResource"));
        Krnl386Segs.CodeSeg2 = HIWORD(GetProcAddress(hInstKrnl, 
                                                     "LoadModule"));
        Krnl386Segs.CodeSeg3 = HIWORD(GetProcAddress(hInstKrnl, 
                                                     "FindResource"));
        Krnl386Segs.DataSeg1 = (WORD)hInstKrnl;

        NotifyWow(NW_KRNL386SEGS, (LPBYTE)&Krnl386Segs);

        //
        // fThunkStrRtns defaults to TRUE outside the U.S. English
        // locale and FALSE in the U.S. English locale.  If we are
        // thunking, patch the exported U.S. implementations to simply
        // near jmp to the equivalent thunk.
        //

        if (fThunkStrRtns) {
            PatchUserStrRtnsToThunk();
        }
    }

#ifdef FIRST_CALL_MUST_BE_USER_BUG
    // get the desktop window handle

    WinEval(hwndDesktop = GetDesktopWindow());
#endif


#ifdef NEEDED

    // create a compatible dc we can use for general bitmap stuff

    WinEval(hDC = GetDC(hwndDesktop));
    WinEval(hdcBits = CreateCompatibleDC(hDC));

    // fill in the oemInfo structure
    // NOTE: We only fill in the bits we need for WOW not all of it

    oemInfo.cxIcon          = GetSystemMetrics(SM_CXICON);
    oemInfo.cyIcon          = GetSystemMetrics(SM_CYICON);
    oemInfo.cxCursor        = GetSystemMetrics(SM_CXCURSOR);
    oemInfo.cyCursor        = GetSystemMetrics(SM_CYCURSOR);
    oemInfo.ScreenBitCount  = GetDeviceCaps(hDC, BITSPIXEL)
                            * GetDeviceCaps(hDC, PLANES);
    oemInfo.DispDrvExpWinVer= GetVersion();


    ReleaseDC(hwndDesktop, hDC);

#endif

    hLib = LoadLibrary( "gdi.exe" );
    LPCHECKMETAFILE = GetProcAddress( hLib, "CHECKMETAFILE" );

    LoadString(hInstanceWin, STR_SYSERR,   szSysError, 20);
    LoadString(hInstanceWin, STR_DIVBYZERO,szDivZero,  50);

    dprintf(3,"Initialisation complete");

    return TRUE;
}

/***************************************************************************

    debugging support

***************************************************************************/


#ifdef DEBUG

void cdecl dDbgOut(int iLevel, LPSTR lpszFormat, ...)
{
    char buf[256];
    int iLogLevel;
    char far *lpcLogLevel;

    // Get the external logging level from the emulated ROM

    iLogLevel = 0;
    (LONG)lpcLogLevel = 0x00400042;
    if (*lpcLogLevel >= '0' && *lpcLogLevel <= '9')
    iLogLevel = (*lpcLogLevel-'0')*10+(*(lpcLogLevel+1)-'0');

    if (iLevel==iLogLevel && (iLogLevel&1) || iLevel<=iLogLevel && !(iLogLevel&1)) {
        OutputDebugString("    W16USER:");
    wvsprintf(buf, lpszFormat, (LPSTR)(&lpszFormat + 1));
    OutputDebugString(buf);
    OutputDebugString("\r\n");
    }
}

void cdecl dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dDbgOut(0, "Assertion FAILED in file %s, line %d: %s\n",
        (LPSTR)file, line, (LPSTR)exp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\inuserds.c ===
/****************************************************************************/
/*                                      */
/*  INUSERDS -                                  */
/*                                      */
/*  User's DS Global Variables                      */
/*                                      */
/****************************************************************************/

#include "user.h"

//***** Initialization globals

HINSTANCE hInstanceWin = NULL;
HMODULE   hModuleWin = NULL;


//***** Comm driver globals

int (FAR PASCAL *lpCommWriteString)(int, LPCSTR, WORD);
                   /* Ptr to the comm driver's
                * commwritestring function. Only
                * exists in 3.1 drivers.
                */
int (FAR PASCAL *lpCommReadString)(int, LPSTR, WORD);
                   /* Ptr to the comm driver's
                * commreadstring function. Only
                * exists in 3.1 drivers.
                */
BOOL (FAR PASCAL *lpCommEnableNotification)(int, HWND, int, int);
                   /* Ptr to the comm driver's
                * commwritestring function. Only
                * exists in 3.1 drivers.
                */
//***** PenWindows globals

void (CALLBACK *lpRegisterPenAwareApp)(WORD i, BOOL fRegister) = NULL; /* Register dlg box as pen aware */

//***** Driver management globals

int	cInstalledDrivers =0;	    /* Count of installed driver structs allocated*/
HDRVR	hInstalledDriverList =NULL; /* List of installable drivers */
int     idFirstDriver=-1;           /* First driver in load order */
int     idLastDriver=-1;            /* Last driver in load order */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\ks386p.inc ===
; extracted from sdk\inc\ks386.inc
;
; Yes I know this is not the right thing to do, but the 16bit
; masm runs "out of memory" while assembling (for cairo builds
; it runs out of memory in ks386.inc itself, so splitting our
; source file wouldn't do the trick).
;
;                                               - nanduri


;
;   Defines for user shared data
;
MM_SHARED_USER_DATA_VA equ 07FFE0000H
UsTickCountLow equ 00H
UsTickCountMultiplier equ 04H


;
;  Gdt Descriptor Offset Definitions
;

KGDT_R3_DATA equ 020H
KGDT_R3_TEB equ 038H

;
;  constants for system irql and IDT vector conversion
;
RPL_MASK equ 03H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\layer.asm ===
title LAYER.ASM - Parameter validation layer

.xlist

include layer.inc

LAYER_INCLUDE=1 	; to suppress including most of the stuff in user.inc
include user.inc
;include usermenu.inc

.list


_GPFIX SEGMENT WORD PUBLIC 'CODE'
_GPFIX ENDS


LAYER_START

include user.api

LAYER_END

; Force menu validation subroutines to get generated in the TEXT
; segment for the message validation layer...
;
genVHMENUtext   = 1

LAYER_EXPAND	TEXT

;
; WOW USER has only one segment
;

; We (NT WOW) do not need these.
;

;LAYER_EXPAND	TEXTMOVE
;LAYER_EXPAND	WINCRTDST
;LAYER_EXPAND	WINUTIL
;LAYER_EXPAND	LANG
;LAYER_EXPAND	RUNAPP
;LAYER_EXPAND	SWITCH
;LAYER_EXPAND	WMGR
;LAYER_EXPAND	WINSWP
;LAYER_EXPAND	DLGBEGIN
;LAYER_EXPAND	DLGCORE
;LAYER_EXPAND	CLPBRD
;LAYER_EXPAND	MENUAPI
;LAYER_EXPAND	MENUCORE
;LAYER_EXPAND	MDKEY
;LAYER_EXPAND	RESOURCE
;LAYER_EXPAND	LBOXDIR
;LAYER_EXPAND	RARE
;LAYER_EXPAND	ICON
;LAYER_EXPAND	SCRLBAR
;LAYER_EXPAND	MDIWIN
;LAYER_EXPAND	WMGR2
;LAYER_EXPAND	SPRINTF
;LAYER_EXPAND	COMDEV
;LAYER_EXPAND	NET

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\iuser.inc ===
GetMessage		   equ	<IGetMessage>
TranslateMessage	   equ	<ITranslateMessage>
DispatchMessage 	   equ	<IDispatchMessage>
PeekMessage		   equ	<IPeekMessage>
lstrcmp 		   equ	<Ilstrcmp>
lstrcmpi		   equ	<Ilstrcmpi>
SetSysModalWindow	   equ	<ISetSysModalWindow>
SendMessage		   equ	<ISendMessage>
PostMessage		   equ	<IPostMessage>
PostAppMessage		   equ	<IPostAppMessage>
CallWindowProc		   equ	<ICallWindowProc>
;IsChild                    equ  <IIsChild>
;IsWindowVisible            equ  <IIsWindowVisible>
;IsIconic                   equ  <IIsIconic>
CallMsgFilter		   equ	<ICallMsgFilter>
GetKeyboardState	   equ	<IGetKeyboardState>
SetKeyboardState	   equ	<ISetKeyboardState>
SetCapture		   equ	<ISetCapture>
;GetQueueStatus             equ  <IGetQueueStatus>
SetTimer		   equ	<ISetTimer>
KillTimer		   equ	<IKillTimer>
;IsWindowEnabled            equ  <IIsWindowEnabled>
GetSystemMetrics	   equ	<IGetSystemMetrics>
GetMenu 		   equ	<IGetMenu>
GetMenuState		   equ	<IGetMenuState>
DrawMenuBar		   equ	<IDrawMenuBar>
DestroyMenu		   equ	<IDestroyMenu>
CheckMenuItem		   equ	<ICheckMenuItem>
EnableMenuItem		   equ	<IEnableMenuItem>
GetSubMenu		   equ	<IGetSubMenu>
GetMenuItemID		   equ	<IGetMenuItemID>
SetActiveWindow 	   equ	<ISetActiveWindow>
BeginPaint		   equ	<IBeginPaint>
InvalidateRect		   equ	<IInvalidateRect>
ValidateRect		   equ	<IValidateRect>
InvalidateRgn		   equ	<IInvalidateRgn>
ValidateRgn		   equ	<IValidateRgn>
SetWindowText		   equ	<ISetWindowText>
GetWindowText		   equ	<IGetWindowText>
GetWindowTextLength	   equ	<IGetWindowTextLength>
;GetClientRect              equ  <IGetClientRect>
;GetWindowRect              equ  <IGetWindowRect>
GetCursorPos		   equ	<IGetCursorPos>
ClipCursor		   equ	<IClipCursor>
GetClipCursor		   equ	<IGetClipCursor>
;ClientToScreen             equ  <IClientToScreen>
;ScreenToClient             equ  <IScreenToClient>
;GetSysColor                equ  <IGetSysColor>
DrawFocusRect		   equ	<IDrawFocusRect>
FillRect		   equ	<IFillRect>
FrameRect		   equ	<IFrameRect>
InvertRect		   equ	<IInvertRect>
;SetRect                   equ  <ISetRect>
;SetRectEmpty               equ  <ISetRectEmpty>
;CopyRect                   equ  <ICopyRect>
;InflateRect                equ  <IInflateRect>
;IntersectRect              equ  <IIntersectRect>
;UnionRect                  equ  <IUnionRect>
;SubtractRect               equ  <ISubtractRect>
;OffsetRect                 equ  <IOffsetRect>
;IsRectEmpty                equ  <IIsRectEmpty>
;EqualRect                  equ  <IEqualRect>
;PtInRect                   equ  <IPtInRect>
;GetWindowWord              equ  <IGetWindowWord>
SetWindowWord		   equ	<ISetWindowWord>
;GetWindowLong              equ  <IGetWindowLong>
SetWindowLong		   equ	<ISetWindowLong>
GetClassWord		   equ	<IGetClassWord>
SetClassWord		   equ	<ISetClassWord>
GetClassLong		   equ	<IGetClassLong>
SetClassLong		   equ	<ISetClassLong>
EnumTaskWindows 	   equ	<IEnumTaskWindows>
;MapWindowPoints            equ  <IMapWindowPoints>
GetWindowTask		   equ	<IGetWindowTask>
SetWindowsHook		   equ	<ISetWindowsHook>
UnhookWindowsHook	   equ	<IUnhookWindowsHook>
DefHookProc		   equ	<IDefHookProc>
SetWindowsHookEx	   equ	<ISetWindowsHookEx>
UnhookWindowsHookEx	   equ	<IUnhookWindowsHookEx>
CallNextHookEx		   equ	<ICallNextHookEx>

DrawText		   equ	<IDrawText>
GetTabbedTextExtent	   equ	<IGetTabbedTextExtent>
TabbedTextOut		   equ	<ITabbedTextOut>
DrawIcon		   equ	<IDrawIcon>
GetWindowDC		   equ	<IGetWindowDC>
GetDC			   equ	<IGetDC>
ReleaseDC		   equ	<IReleaseDC>
GetDCEx 		   equ	<IGetDCEx>
DefWindowProc		   equ	<IDefWindowProc>
RegisterClass		   equ	<IRegisterClass>
UnregisterClass 	   equ	<IUnregisterClass>
GetClassInfo		   equ	<IGetClassInfo>
GetClassName		   equ	<IGetClassName>
GetNextQueueWindow	   equ	<IGetNextQueueWindow>
CreateWindowEx		   equ	<ICreateWindowEx>
DestroyWindow		   equ	<IDestroyWindow>
ShowWindow		   equ	<IShowWindow>
FlashWindow		   equ	<IFlashWindow>
ShowOwnedPopups 	   equ	<IShowOwnedPopups>
OpenIcon		   equ	<IOpenIcon>
CloseWindow		   equ	<ICloseWindow>
MoveWindow		   equ	<IMoveWindow>
SetWindowPos		   equ	<ISetWindowPos>
DeferWindowPos		   equ	<IDeferWindowPos>
EndDeferWindowPos	   equ	<IEndDeferWindowPos>
CreateDialogParam	   equ	<ICreateDialogParam>
CreateDialogIndirectParam  equ	<ICreateDialogIndirectParam>
DialogBoxParam		   equ	<IDialogBoxParam>
DialogBoxIndirectParam	   equ	<IDialogBoxIndirectParam>
EndDialog		   equ	<IEndDialog>
GetDlgItem		   equ	<IGetDlgItem>
GetDlgItemInt		   equ	<IGetDlgItemInt>
SetDlgItemText		   equ	<ISetDlgItemText>
GetDlgItemText		   equ	<IGetDlgItemText>
CheckDlgButton		   equ	<ICheckDlgButton>
IsDlgButtonChecked	   equ	<IIsDlgButtonChecked>
SendDlgItemMessage	   equ	<ISendDlgItemMessage>
GetNextDlgGroupItem	   equ	<IGetNextDlgGroupItem>
GetNextDlgTabItem	   equ	<IGetNextDlgTabItem>
GetDlgCtrlID		   equ	<IGetDlgCtrlID>
DefDlgProc		   equ	<IDefDlgProc>
OpenClipboard		   equ	<IOpenClipboard>
SetClipboardViewer	   equ	<ISetClipboardViewer>
ChangeClipboardChain	   equ	<IChangeClipboardChain>
GetPriorityClipboardFormat equ	<IGetPriorityClipboardFormat>
SetFocus		   equ	<ISetFocus>
EnableWindow		   equ	<IEnableWindow>
TranslateAccelerator	   equ	<ITranslateAccelerator>
LoadAccelerators	   equ	<ILoadAccelerators>
LoadMenu		   equ	<ILoadMenu>
LoadMenuIndirect	   equ	<ILoadMenuIndirect>
SetMenu 		   equ	<ISetMenu>
ChangeMenu		   equ	<IChangeMenu>
HiliteMenuItem		   equ	<IHiliteMenuItem>
GetMenuString		   equ	<IGetMenuString>
GetSystemMenu		   equ	<IGetSystemMenu>
SetSystemMenu		   equ	<ISetSystemMenu>
GetMenuItemCount	   equ	<IGetMenuItemCount>
InsertMenu		   equ	<IInsertMenu>
AppendMenu		   equ	<IAppendMenu>
ModifyMenu		   equ	<IModifyMenu>
RemoveMenu		   equ	<IRemoveMenu>
DeleteMenu		   equ	<IDeleteMenu>
SetMenuItemBitmaps	   equ	<ISetMenuItemBitmaps>
TrackPopupMenu		   equ	<ITrackPopupMenu>
GrayString		   equ	<IGrayString>
UpdateWindow		   equ	<IUpdateWindow>
EndPaint		   equ	<IEndPaint>
GetUpdateRect		   equ	<IGetUpdateRect>
GetUpdateRgn		   equ	<IGetUpdateRgn>
ExcludeUpdateRgn	   equ	<IExcludeUpdateRgn>
RedrawWindow		   equ	<IRedrawWindow>
LockWindowUpdate	   equ	<ILockWindowUpdate>
ScrollDC		   equ	<IScrollDC>
ScrollWindowEx		   equ	<IScrollWindowEx>
SetScrollPos		   equ	<ISetScrollPos>
GetScrollPos		   equ	<IGetScrollPos>
SetScrollRange		   equ	<ISetScrollRange>
GetScrollRange		   equ	<IGetScrollRange>
ShowScrollBar		   equ	<IShowScrollBar>
EnableScrollBar 	   equ	<IEnableScrollBar>
SetProp 		   equ	<ISetProp>
;GetProp                    equ  <IGetProp>
RemoveProp		   equ	<IRemoveProp>
EnumProps		   equ	<IEnumProps>
AdjustWindowRectEx	   equ	<IAdjustWindowRectEx>
MessageBox		   equ	<IMessageBox>
SetCursor		   equ	<ISetCursor>
CreateCaret		   equ	<ICreateCaret>
HideCaret		   equ	<IHideCaret>
ShowCaret		   equ	<IShowCaret>
ChildWindowFromPoint	   equ	<IChildWindowFromPoint>
SetSysColors		   equ	<ISetSysColors>
GetParent		   equ	<IGetParent>
SetParent		   equ	<ISetParent>
EnumChildWindows	   equ	<IEnumChildWindows>
FindWindow		   equ	<IFindWindow>
EnumWindows		   equ	<IEnumWindows>
GetTopWindow		   equ	<IGetTopWindow>
GetLastActivePopup	   equ	<IGetLastActivePopup>
GetWindow		   equ	<IGetWindow>
;InvalidateDCCache          equ  <IInvalidateDCCache>
LoadBitmap		   equ	<ILoadBitmap>
LoadCursor		   equ	<ILoadCursor>
CreateCursor		   equ	<ICreateCursor>
DestroyCursor		   equ	<IDestroyCursor>
LoadIcon		   equ	<ILoadIcon>
CreateIcon		   equ	<ICreateIcon>
DestroyIcon		   equ	<IDestroyIcon>
LoadString		   equ	<ILoadString>
IsDialogMessage 	   equ	<IIsDialogMessage>
MapDialogRect		   equ	<IMapDialogRect>
DlgDirList		   equ	<IDlgDirList>
DlgDirSelect		   equ	<IDlgDirSelect>
DlgDirSelectEx             equ  <IDlgDirSelectEx>
DlgDirListComboBox	   equ	<IDlgDirListComboBox>
DlgDirSelectComboBox	   equ	<IDlgDirSelectComboBox>
DlgDirSelectComboBoxEx     equ  <IDlgDirSelectComboBoxEx>
DefFrameProc		   equ	<IDefFrameProc>
DefMDIChildProc 	   equ	<IDefMDIChildProc>
TranslateMDISysAccel	   equ	<ITranslateMDISysAccel>
ArrangeIconicWindows	   equ	<IArrangeIconicWindows>
SystemParametersInfo	   equ	<ISystemParametersInfo>
WinHelp 		   equ	<IWinHelp>
OpenDriver		   equ	<IOpenDriver>
CloseDriver		   equ	<ICloseDriver>
GetDriverModuleHandle	   equ	<IGetDriverModuleHandle>
SendDriverMessage	   equ	<ISendDriverMessage>
DefDriverProc		   equ	<IDefDriverProc>
GetNextDriver		   equ	<IGetNextDriver>
GetDriverInfo		   equ	<IGetDriverInfo>
SelectPalette		   equ	<ISelectPalette>
RealizePalette		   equ	<IRealizePalette>
;wsprintf                   equ  <Iwsprintf>  ; see user.api
wvsprintf		   equ	<Iwvsprintf>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\intds.asm ===
;****************************************************************************
;
;   This file contains all global data that must be modified at interrupt
;   level.  Everthing in this file is placed in a fixed data segment
;   named INTDATA.  Only things that must be accessed and modified at
;   interrupt level may be placed in this file.  All values here must be
;   referenced as FAR in the code.
;
;   The creation of this segment allowed USER to eliminate all code segment
;   variables.  This was needed for protect mode as well as moving USER's
;   text segment into HIMEM.
;****************************************************************************

NOEXTERNS = 1
.xlist
include user.inc
.list


createSeg _INTDS, INTDS, BYTE, PUBLIC, DATA

sBegin INTDS

GlobalW hqSysQueue,     00h

ifndef WOW

GlobalW fMouseMoved,    00h
;; GlobalB fAltKeyUp,	80h 	; no longer used

GlobalW fInt24          00h     ; used for INT24 detection in NCMOUSEDOWN

;
; For Asynchronous key state information.
;
public rgbAsyncKeyState
rgbAsyncKeyState db     64 DUP(0)   ; 512 bits of information, 2 per key.

GlobalW fEnableInput,   TRUE

endif ; !WOW

GlobalW hqSysModal,	0	    ; hq of system modal window

ifndef WOW

;
; These are for the code that always keeps enough room for KEYUP/MOUSEUP msgs.
;
GlobalW cMsgRsrv,	0
GlobalB vKeyDown,	0

;
; Mouse Code Variables
;
GlobalW x_mickey_rate,	0	    ; mickeys/pixel ratio for x
GlobalW y_mickey_rate,	0	    ; mickeys/pixel ratio for y
GlobalW cur_x_mickey,	0	    ; current mickey count in x
GlobalW cur_y_mickey,	0	    ; current mickey count in y
GlobalW fSwapButtons,	0	    ; TRUE if L/R are to be swapped.

public ptTrueCursor
ptTrueCursor	POINT	<0, 0>	    ; interrupt-level cursor position

public ptCursor
ptCursor	POINT	<0, 0>	    ; cursor position as of last SkipSysMsg

public          rcCursorClip
rcCursorClip	RECT	<0, 0, 0, 0>

GlobalD dwMouseMoveExtraInfo, 0 ; Extra info for deferred MOUSE MOVE msgs

;
; CS copies of cxScreen, cyScreen for abs mouse scaling
;
GlobalW cxScreenCS,	0
GlobalW cyScreenCS,	0

;
; These are CS copies of msInfo.msXThresh & msYThresh
;   (copied at initialization)
;
GlobalW MouseThresh1,0
GlobalW MouseThresh2,0
GlobalW MouseSpeed,   0       ;0 - no accel, 1 - singel accel, 2 - dual accel

ifndef PMODE
;
; Mouse interrupt stack
;
public lpMouseStack
public prevSSSP
public NestCount
endif

lpMouseStack    dd      ?
prevSSSP	dd	?	    ;Previous stack when inside our hook
NestCount	db	0

;
; Hardware level (interrupt) hook addresse.  Called from event proc's
;

GlobalW 	fJournalPlayback,   0	; != 0 if WH_JOURNALPLAYBACK hook installed

; Table of interrupt-level hotkey hooks

GlobalW cHotKeyHooks,	0

public	rghkhHotKeyHooks
rghkhHotKeyHooks    dw	CHOTKEYHOOKMAX * (size HOTKEYHOOK)/2 dup (0)

; Hardware event hook

GlobalD hwEventHook,	NULL

endif ; !WOW


;
; Q management.
;
GlobalW hqList, 	0	    ; list of allocated queues
GlobalW hqCursor,	0	    ; hq of window under cursor
GlobalW hqCapture,	0	    ; hq of capture
GlobalW hqActive,	0	    ; hq of active window
GlobalW hqMouse,	0	    ; hq last to get mouse msg
GlobalW hqKeyboard,	0	    ; hq last to get kbd msg
GlobalW cQEntries,	120	    ; System queue size
GlobalW hqSysLock	0	    ; HQ of guy looking at the current event
GlobalW idSysLock	0ffffh	    ; Msg ID of event that's locking sys queue


ifndef WOW

;
; Timer management
;
public	timerInfo
timerInfo	    STIMERINFO	<0>
;
; Timer related stuff
;
public TimerTable
TimerTable	dw	(size TIMER)/2 * CTIMERSMAX dup (0)

GlobalW hSysTimer,	0	    ; system timer handle
GlobalD tSysTimer,	0	    ; system timer time
GlobalW dtSysTimer,	0	    ; delta time before next timer goes off
GlobalB fInScanTimers,	0	    ; flag to prevent ScanTimers recursion
GlobalW TimerTableMax,	0	    ; end of active timer entries

;
; Journalling stuff
;
GlobalD dtJournal,	0	    ; dt till next event is ready
GlobalW msgJournal,	0	    ; next journal message.

;
; Used in SaveEvent()
;
GlobalB fDontMakeAltUpASysKey  0    ; whether any intervening chars have arrived


;*--------------------------------------------------------------------------*
;*  Internal Strings							    *
;*--------------------------------------------------------------------------*

; These strings reside in user.rc but are loaded at boot time.  They must
; remain in user.rc for localization reasons.

endif ; !WOW

public szSysError
public szDivZero
szSysError      db      20 DUP(0)   ; "System Error"
szDivZero       db      50 DUP(0)   ; "Divide By Zero or Overflow Error"

ifndef WOW

public szNull
szNull		db	0,13

endif ; !WOW

sEnd INTDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\msglayer.asm ===
title LAYER.ASM - Parameter validation layer

.xlist

include layer.inc

LAYER_INCLUDE=1 	; to suppress including most of the stuff in user.inc
include user.inc

.list
.xall

include msglayer.inc

MESSAGE_START	TEXT

include messages.api

MESSAGE_END

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\iuser.h ===
//--------------------
// Function prototypes

#define GetMessage		   IGetMessage
#define TranslateMessage	   ITranslateMessage
#define DispatchMessage 	   IDispatchMessage
#define PeekMessage		   IPeekMessage
#define lstrcmp 		   Ilstrcmp
#define lstrcmpi		   Ilstrcmpi
#define SetSysModalWindow	   ISetSysModalWindow
// #define SendMessage		   ISendMessage
#define PostMessage		   IPostMessage
#define PostAppMessage		   IPostAppMessage
#define CallWindowProc		   ICallWindowProc
#define IsChild 		   IIsChild
#define IsWindowVisible 	   IIsWindowVisible
#define IsIconic		   IIsIconic
#define CallMsgFilter		   ICallMsgFilter
#define GetKeyboardState	   IGetKeyboardState
#define SetKeyboardState	   ISetKeyboardState
// #define SetCapture		   ISetCapture
#define GetQueueStatus		   IGetQueueStatus
#define SetTimer		   ISetTimer
#define KillTimer		   IKillTimer
#define IsWindowEnabled 	   IIsWindowEnabled
#define GetSystemMetrics	   IGetSystemMetrics
#define GetMenu 		   IGetMenu
#define GetMenuState		   IGetMenuState
#define DrawMenuBar		   IDrawMenuBar
#define DestroyMenu		   IDestroyMenu
#define CheckMenuItem		   ICheckMenuItem
#define EnableMenuItem		   IEnableMenuItem
#define GetSubMenu		   IGetSubMenu
#define GetMenuItemID		   IGetMenuItemID
#define SetActiveWindow 	   ISetActiveWindow
#define BeginPaint		   IBeginPaint
#define InvalidateRect		   IInvalidateRect
#define ValidateRect		   IValidateRect
#define InvalidateRgn		   IInvalidateRgn
#define ValidateRgn		   IValidateRgn
#define SetWindowText		   ISetWindowText
#define GetWindowText		   IGetWindowText
#define GetWindowTextLength	   IGetWindowTextLength
#define GetClientRect		   IGetClientRect
#define GetWindowRect		   IGetWindowRect
#define GetCursorPos		   IGetCursorPos
#define ClipCursor		   IClipCursor
#define GetClipCursor		   IGetClipCursor
#define ClientToScreen		   IClientToScreen
#define ScreenToClient		   IScreenToClient
#define DefDlgProc		   IDefDlgProc
#define GetSysColor		   IGetSysColor
#define DrawFocusRect		   IDrawFocusRect
#define FillRect		   IFillRect
#define FrameRect		   IFrameRect
#define InvertRect		   IInvertRect
#define SetRect 		   ISetRect
#define SetRectEmpty		   ISetRectEmpty
#define CopyRect		   ICopyRect
#define InflateRect		   IInflateRect
#define IntersectRect		   IIntersectRect
#define UnionRect		   IUnionRect
#define SubtractRect		   ISubtractRect
#define OffsetRect		   IOffsetRect
#define IsRectEmpty		   IIsRectEmpty
#define EqualRect		   IEqualRect
#define PtInRect		   IPtInRect
#define GetWindowWord		   IGetWindowWord
#define SetWindowWord		   ISetWindowWord
#define GetWindowLong		   IGetWindowLong
#define SetWindowLong		   ISetWindowLong
#define GetClassWord		   IGetClassWord
#define SetClassWord		   ISetClassWord
#define GetClassLong		   IGetClassLong
#define SetClassLong		   ISetClassLong
#define EnumTaskWindows 	   IEnumTaskWindows
#define MapWindowPoints 	   IMapWindowPoints
#define GetWindowTask		   IGetWindowTask
#define SetWindowsHook		   ISetWindowsHook
#define UnhookWindowsHook	   IUnhookWindowsHook
#define DefHookProc		   IDefHookProc
#define SetWindowsHookEx	   ISetWindowsHookEx
#define UnhookWindowsHookEx	   IUnhookWindowsHookEx
#define CallNextHookEx		   ICallNextHookEx

#define DrawText		   IDrawText
#define GetTabbedTextExtent	   IGetTabbedTextExtent
#define TabbedTextOut		   ITabbedTextOut
#define DrawIcon		   IDrawIcon
#define GetWindowDC		   IGetWindowDC
#define GetDC			   IGetDC
#define ReleaseDC		   IReleaseDC
#define GetDCEx 		   IGetDCEx
#define DefWindowProc		   IDefWindowProc
#define RegisterClass		   IRegisterClass
#define UnregisterClass 	   IUnregisterClass
#define GetClassInfo		   IGetClassInfo
#define GetClassName		   IGetClassName
#define GetNextQueueWindow	   IGetNextQueueWindow
#define CreateWindowEx		   ICreateWindowEx
#define DestroyWindow		   IDestroyWindow
#define ShowWindow		   IShowWindow
#define FlashWindow		   IFlashWindow
#define ShowOwnedPopups 	   IShowOwnedPopups
#define OpenIcon		   IOpenIcon
#define CloseWindow		   ICloseWindow
#define MoveWindow		   IMoveWindow
#define SetWindowPos		   ISetWindowPos
#define DeferWindowPos		   IDeferWindowPos
#define EndDeferWindowPos	   IEndDeferWindowPos
#define CreateDialogParam	   ICreateDialogParam
#define CreateDialogIndirectParam  ICreateDialogIndirectParam
// #define DialogBoxParam             IDialogBoxParam
#define DialogBoxIndirectParam	   IDialogBoxIndirectParam
#define EndDialog		   IEndDialog
#define GetDlgItem		   IGetDlgItem
#define GetDlgItemInt		   IGetDlgItemInt
#define SetDlgItemText		   ISetDlgItemText
#define GetDlgItemText		   IGetDlgItemText
#define CheckDlgButton		   ICheckDlgButton
#define IsDlgButtonChecked	   IIsDlgButtonChecked
#define SendDlgItemMessage	   ISendDlgItemMessage
#define GetNextDlgGroupItem	   IGetNextDlgGroupItem
#define GetNextDlgTabItem	   IGetNextDlgTabItem
#define GetDlgCtrlID		   IGetDlgCtrlID
#define OpenClipboard		   IOpenClipboard
#define SetClipboardViewer	   ISetClipboardViewer
#define ChangeClipboardChain	   IChangeClipboardChain
#define GetPriorityClipboardFormat IGetPriorityClipboardFormat
#define SetFocus		   ISetFocus
#define EnableWindow		   IEnableWindow
#define TranslateAccelerator	   ITranslateAccelerator
#define LoadAccelerators	   ILoadAccelerators
#define LoadMenu		   ILoadMenu
#define LoadMenuIndirect	   ILoadMenuIndirect
#define SetMenu 		   ISetMenu
#define ChangeMenu		   IChangeMenu
#define HiliteMenuItem		   IHiliteMenuItem
#define GetMenuString		   IGetMenuString
#define GetSystemMenu		   IGetSystemMenu
#define SetSystemMenu		   ISetSystemMenu
#define GetMenuItemCount	   IGetMenuItemCount
#define InsertMenu		   IInsertMenu
#define AppendMenu		   IAppendMenu
#define ModifyMenu		   IModifyMenu
#define RemoveMenu		   IRemoveMenu
#define DeleteMenu		   IDeleteMenu
#define SetMenuItemBitmaps	   ISetMenuItemBitmaps
#define TrackPopupMenu		   ITrackPopupMenu
#define GrayString		   IGrayString
#define UpdateWindow		   IUpdateWindow
#define EndPaint		   IEndPaint
#define GetUpdateRect		   IGetUpdateRect
#define GetUpdateRgn		   IGetUpdateRgn
#define ExcludeUpdateRgn	   IExcludeUpdateRgn
#define RedrawWindow		   IRedrawWindow
#define LockWindowUpdate	   ILockWindowUpdate
#define ScrollDC		   IScrollDC
#define ScrollWindowEx		   IScrollWindowEx
#define SetScrollPos		   ISetScrollPos
#define GetScrollPos		   IGetScrollPos
#define SetScrollRange		   ISetScrollRange
#define GetScrollRange		   IGetScrollRange
#define ShowScrollBar		   IShowScrollBar
#define EnableScrollBar 	   IEnableScrollBar
#define SetProp 		   ISetProp
#define GetProp 		   IGetProp
#define RemoveProp		   IRemoveProp
#define EnumProps		   IEnumProps
#define AdjustWindowRectEx	   IAdjustWindowRectEx
#define MessageBox		   IMessageBox
#define SetCursor		   ISetCursor
#define CreateCaret		   ICreateCaret
#define HideCaret		   IHideCaret
#define ShowCaret		   IShowCaret
#define ChildWindowFromPoint	   IChildWindowFromPoint
#define SetSysColors		   ISetSysColors
#define GetParent		   IGetParent
#define SetParent		   ISetParent
#define EnumChildWindows	   IEnumChildWindows
#define FindWindow		   IFindWindow
#define EnumWindows		   IEnumWindows
#define GetTopWindow		   IGetTopWindow
#define GetLastActivePopup	   IGetLastActivePopup
#define GetWindow		   IGetWindow
#define InvalidateDCCache	   InvalidateDCCache
#define LoadBitmap		   ILoadBitmap
#define LoadCursor		   ILoadCursor
#define CreateCursor		   ICreateCursor
#define DestroyCursor		   IDestroyCursor
#define LoadIcon		   ILoadIcon
#define CreateIcon		   ICreateIcon
#define DestroyIcon		   IDestroyIcon
#define LoadString		   ILoadString
#define IsDialogMessage 	   IIsDialogMessage
#define MapDialogRect		   IMapDialogRect
#define DlgDirList		   IDlgDirList
#define DlgDirSelect		   IDlgDirSelect
#define DlgDirSelectEx             IDlgDirSelectEx
#define DlgDirListComboBox	   IDlgDirListComboBox
#define DlgDirSelectComboBox	   IDlgDirSelectComboBox
#define DlgDirSelectComboBoxEx     IDlgDirSelectComboBoxEx
#define DefFrameProc		   IDefFrameProc
#define DefMDIChildProc 	   IDefMDIChildProc
#define TranslateMDISysAccel	   ITranslateMDISysAccel
#define ArrangeIconicWindows	   IArrangeIconicWindows
#define SystemParametersInfo	   ISystemParametersInfo
#define WinHelp 		   IWinHelp
#define OpenDriver		   IOpenDriver
#define CloseDriver		   ICloseDriver
#define GetDriverModuleHandle	   IGetDriverModuleHandle
#define SendDriverMessage	   ISendDriverMessage
#define DefDriverProc		   IDefDriverProc
#define GetNextDriver		   IGetNextDriver
#define GetDriverInfo		   IGetDriverInfo
#define SelectPalette		   ISelectPalette
#define RealizePalette		   IRealizePalette
//#define wsprintf                   Iwsprintf // see user.api
#define wvsprintf		   Iwvsprintf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\netdlg.h ===
/* netdlg.h -
 *
 * constants for network dialogs
 */

#ifdef RC_INVOKED
#define IDD_CONNECTPROGRESS	100
#define IDD_PASSWORD		101
#else
#define IDD_CONNECTPROGRESS	((LPSTR)100L)
#define IDD_PASSWORD		((LPSTR)101L)
#endif

#define IDD_DEV 		100
#define IDD_PASS		101
#define IDD_PATH		102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\net.c ===
#include  "user.h"
#include "winnet.h"
#include "netdlg.h"

void FAR PASCAL WriteOutProfiles(void);

#define IFNRESTORECONNECTION	23
#define IERR_MustBeLoggedOnToConnect   5000

#define CFNNETDRIVER 22 	    /* number of winnet entrypoints */
#define CFNNETDRIVER2 35	    /* ... in Windows 3.1	    */

extern FARPROC NEAR* pNetInfo;	    /* pointer to list of WINNET entrypoints */
extern HANDLE hWinnetDriver;

extern void FAR PASCAL WNetEnable( void );
extern WORD FAR PASCAL WNetGetCaps2(WORD nIndex);	/* winnet.asm */

typedef struct _conntext
  {
    char szDevice[5];
    char szPath[64];
    char szPassword[32];
  } CONNTEXT;


char CODESEG szNet[] = "Network";
char CODESEG szDialogs[] = "DefaultDialogs";

HWND hwndTopNet = NULL;
CONNTEXT FAR * lpctDlg;

#ifdef WOW
typedef VOID (FAR *LPTELLKRNL) (HINSTANCE);
#endif


WORD API IWNetGetCaps(WORD nIndex)
{
    WORD wRet;

    if (nIndex == 0xFFFF)
	wRet = (WORD)hWinnetDriver;
    else {
    	wRet = WNetGetCaps2(nIndex);

	if (nIndex == WNNC_DIALOG) {
	    // turn off the drivers built in dialogs if
	    // win.ini [network] defaultdialogs=1
	    if (GetProfileInt(szNet, szDialogs, 0)) {
		wRet &= ~(WNNC_DLG_ConnectDialog |
			  WNNC_DLG_DisconnectDialog |
			  WNNC_DLG_ConnectionDialog);
	    }
	}
    }
    return wRet;
}


WORD API WNetErrorText(WORD wError,LPSTR lpsz, WORD cbMax)
{
    WORD wInternalError;
    WORD cb;
    char szT[40];

    if ((wError == WN_NET_ERROR)
	&& (WNetGetError(&wInternalError) == WN_SUCCESS)
	&& (WNetGetErrorText(wInternalError,lpsz,&cbMax) == WN_SUCCESS))
      {
	return cbMax;
      }
    else
      {
	cb = LoadString(hInstanceWin,STR_NETERRORS+wError,lpsz,cbMax);
	if (!cb)
	  {
	    LoadString(hInstanceWin,STR_NETERRORS,szT,sizeof(szT));
	    cb = wvsprintf(lpsz, szT, (LPSTR)&wError);
	  }
      }
    return cb;
}

#if 0

/* CenterDialog() -
 *
 *  Puts a dialog in an aesthetically pleasing place relative to its parent
 */

void near pascal CenterDialog(HWND hwnd)
{
    int x, y;

    /* center the dialog
     */
    if (hwnd->hwndOwner)
      {
	x = hwnd->hwndOwner->rcWindow.left;
	y = hwnd->hwndOwner->rcWindow.right;

	x += rgwSysMet[SM_CXSIZE] + rgwSysMet[SM_CXFRAME];
	y += rgwSysMet[SM_CYSIZE] + rgwSysMet[SM_CYFRAME];
      }
    else
      {
	x = (hwndDesktop->rcWindow.right
	  - (hwnd->rcWindow.right-hwnd->rcWindow.left)) / 2;

	y = (hwndDesktop->rcWindow.bottom
	  - (hwnd->rcWindow.bottom-hwnd->rcWindow.top)) / 2;
      }

    SetWindowPos(hwnd,NULL,x,y,0,0,SWP_NOSIZE);
}
#endif

/* stub dlg proc for status dialog
 */

BOOL CALLBACK ProgressDlgProc(HWND hwnd, WORD wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
      {
    case WM_INITDIALOG:
	// CenterDialog(hwnd);
	break;

    default:
	return FALSE;
      }
    return TRUE;
}

/* PasswordDlgProc() -
 *
 *  Get a password for a network resource
 */

BOOL CALLBACK PasswordDlgProc(HWND hwnd, WORD wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
      {
    case WM_INITDIALOG:
	// CenterDialog(hwnd);
        // Tell PenWin about this
        if (lpRegisterPenAwareApp)
            (*lpRegisterPenAwareApp)(1, TRUE);

//	SetDlgItemText(hwnd,IDD_DEV,lpctDlg->szDevice);
	SetDlgItemText(hwnd,IDD_PATH,lpctDlg->szPath);
	SendDlgItemMessage(hwnd, IDD_PASS, EM_LIMITTEXT, (WPARAM)(sizeof(lpctDlg->szPassword)-1), 0L);
	SetTimer(hwnd, 1, 30 * 1000, NULL);
	break;

    case WM_TIMER:
    	KillTimer(hwnd, 1);
	wParam = (WPARAM)IDCANCEL;
	goto TimeOut;

    case WM_COMMAND:
	switch ((WORD)wParam)
	  {
	case IDD_PASS:
	    if (HIWORD(lParam) == EN_CHANGE)
	        KillTimer(hwnd, 1);
	    break;

	case IDOK:
	    GetDlgItemText(hwnd,IDD_PASS,lpctDlg->szPassword, sizeof(lpctDlg->szPassword));
	    /*** FALL THRU ***/

	case IDCANCEL:
	case IDABORT:
TimeOut:
            if (lpRegisterPenAwareApp)
                (*lpRegisterPenAwareApp)(1, FALSE);
	    EndDialog(hwnd, (int)wParam);
	    break;
	  }
	break;

    default:
	return FALSE;
      }
    return TRUE;
}

/* RestoreDevice() -
 *
 *  Restores a single device.  If fStartup is true, a dialog box is
 *  posted to list the connections being made (this posting is deferred
 *  until here so that if no permanant connections exist, none are
 *  restored.
 */

WORD NEAR PASCAL RestoreDevice(HWND hwndParent, LPSTR lpDev, BOOL fStartup, CONNTEXT FAR *lpct)
{
    WORD wT;
    WORD err;
    WORD errorMode;
    WORD result;

    errorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    result = WN_BAD_VALUE;
    if (lstrlen(lpDev) > 4)
	goto Done;

    lstrcpy(lpct->szDevice,lpDev);

    // If it's a drive that already exists then don't try to connect
    // over it.
    if (fStartup && *(lpDev+1) == ':') {
        if (GetDriveType(*lpDev-'A')) {
            // Drive already exists - don't stomp on it.
            result = WN_CANCEL;   // Don't report error.
            goto Done;
        }
    }

    if (fStartup)
	goto GetFromINI;

    wT = sizeof(lpct->szPath);
    err = WNetGetConnection(lpct->szDevice,lpct->szPath,&wT);

    if (err == WN_SUCCESS) {
	result = WN_SUCCESS;
	goto Done;
    }

    if (err == WN_DEVICE_ERROR) {
	err = WNetCancelConnection(lpct->szDevice,FALSE);
	if (err == WN_OPEN_FILES) {
	    // report a warning error to the user
	    WNetCancelConnection(lpct->szDevice,TRUE);
	} else if (err != WN_SUCCESS) {
	    result = err;
	    goto Done;
	}
    } else if (err == WN_NOT_CONNECTED) {
GetFromINI:
	if (!GetProfileString(szNet,lpct->szDevice,"",lpct->szPath,sizeof(lpct->szPath))) {
	    result = WN_NOT_CONNECTED;
	    goto Done;
	}
    } else if (err != WN_CONNECTION_CLOSED) {
	result = err;
	goto Done;
    }

    // initially attempt with a blank password
    //
    lpct->szPassword[0] = 0;

    // if on startup, show the status dialog
    //
    if (fStartup) {
	if (!hwndTopNet) {
	    hwndTopNet = CreateDialog(hInstanceWin,IDD_CONNECTPROGRESS,NULL,ProgressDlgProc);
            if (!hwndTopNet)
                goto TryConnection;

	    ShowWindow(hwndTopNet,SW_SHOW);
	}
	SetDlgItemText(hwndTopNet,IDD_DEV,lpct->szDevice);
	SetDlgItemText(hwndTopNet,IDD_PATH,lpct->szPath);
	UpdateWindow(hwndTopNet);
	hwndParent = hwndTopNet;
    }

TryConnection:

    // lpct->szPath now contains the path
    // and lpct->szPassword the password...
    err = WNetAddConnection(lpct->szPath,lpct->szPassword,lpct->szDevice);

    // if we're booting and the thing is connected, ignore
    if (fStartup && err == WN_ALREADY_CONNECTED) {
	result = WN_SUCCESS;
	goto Done;
    }

    // if it was success or some other error, return
    if (err != WN_BAD_PASSWORD && err != WN_ACCESS_DENIED) {
	result = err;
	goto Done;
    }

    // it was bad password.  prompt the user for the correct password
    lpctDlg = lpct;

    switch (DialogBox(hInstanceWin,IDD_PASSWORD,hwndParent,PasswordDlgProc)) {
    case -1:
	result = WN_OUT_OF_MEMORY;
	break;

    case IDOK:
	goto TryConnection;
	break;

    case IDCANCEL:
	result = WN_CANCEL;
	break;

    case IDABORT:
	result = WN_NET_ERROR;
	break;
    }

Done:
    SetErrorMode(errorMode);

    return result;
}

/* ReportError() -
 *
 *  Tell the user why the network connection failed
 */

void NEAR PASCAL ReportError(HWND hwndParent, WORD err, CONNTEXT FAR *lpct)
{
    char szTitle[80];
    char szT[200];
    char szError[150];
    LPSTR rglp[2];

    switch (err)
      {
    case WN_SUCCESS:
    case WN_CANCEL:
    case WN_NOT_CONNECTED:
	return;
      }

    WNetErrorText(err,szT,sizeof(szT));
    LoadString(hInstanceWin,STR_NETCONNMSG,szTitle,sizeof(szTitle));
    rglp[0] = (LPSTR)lpct->szPath;
    rglp[1] = (LPSTR)szT;
    wvsprintf(szError,szTitle,(LPSTR)rglp);
    LoadString(hInstanceWin,STR_NETCONNTTL,szTitle,sizeof(szTitle));
    MessageBox(hwndParent,szError,szTitle,MB_OK|MB_ICONEXCLAMATION);
}

/* WNetRestoreConnection() -
 *
 *  This function implements the "standard" restore-connection process.
 *  If the function is supported by the network driver, the driver is
 *  called instead.  Otherwise, standard behaviour is supplied.
 */

typedef WORD (FAR PASCAL* PFN_NETRESTORECON)(HWND, LPSTR);

UINT API WNetRestoreConnection(HWND hwndParent, LPSTR lpszDevice)
{
    static char CODESEG szInRestore[]="InRestoreNetConnect";
    static char CODESEG szRestore[]="Restore";
    char szDevice[10];
    char szTitle[50];
    char szMsg[255];
    CONNTEXT ct;
    WORD i;
    WORD err;
    BOOL bLoggedIn;

    if (!pNetInfo)
	return(WN_NOT_SUPPORTED);


    if (WNetGetCaps(WNNC_CONNECTION) & WNNC_CON_RestoreConnection)
      {
	/* The device driver supports this call
	 */
	return (*(PFN_NETRESTORECON)(pNetInfo[IFNRESTORECONNECTION - 1]))(hwndParent, lpszDevice);
      }


    /* the network does not support restore connections.  do the default
     */
    if (HIWORD(lpszDevice))
	return RestoreDevice(hwndParent,lpszDevice,FALSE,&ct);

    // check to see if restoring net connects is enabled
    if (!GetProfileInt(szNet,szRestore,1))
	return(WN_SUCCESS);

    /* Check if we previously aborted in the middle of restoring net
     * connections.
     */
    if (GetProfileInt(szNet,szInRestore,0))
      {
        /* We died in the middle of restoring net connects. Inform user.
	 */
        LoadString(hInstanceWin, STR_NETCRASHEDTITLE, szTitle, sizeof(szTitle));
        LoadString(hInstanceWin, STR_NETCRASHEDMSG, szMsg, sizeof(szMsg));
        err = MessageBox(NULL, szMsg, szTitle,
                         MB_ICONEXCLAMATION | MB_RETRYCANCEL | MB_SYSTEMMODAL);

        if (err == IDCANCEL)
            goto ExitRestoreNet;

      }
    WriteProfileString(szNet,szInRestore,"1");
    /* Flush cache.
     */
    WriteOutProfiles();


    szDevice[1]=':';
    szDevice[2]=0;
    bLoggedIn = TRUE;
    for (i = 0; i < 26; i++)
      {
	szDevice[0] = (char)('A' + i);

        err = GetDriveType(i);
        if (err == DRIVE_FIXED || err == DRIVE_REMOVABLE)
          {
            /* Don't restore to system drives in case the user added a ram
	     * drive or new hard disk or something...
	     */
            continue;
          }
        else
          {
  	    err = RestoreDevice(hwndParent,szDevice,TRUE,&ct);
          }

	hwndParent = hwndTopNet;

	if ( (err == WN_NET_ERROR)			      &&
	     (WNetGetCaps (WNNC_NET_TYPE) == WNNC_NET_LanMan) &&
	     (WNetGetError (&err) == WN_SUCCESS)	      &&
	     (err == IERR_MustBeLoggedOnToConnect) )
	  {
	    bLoggedIn = FALSE;
	    break;    /* if not logged on to LanMan, skip rest #8361 RAID */
	  }
	else
	    // report error to user
	    ReportError(hwndParent,err,&ct);
      }

    /* Try to restore printer connections only if logged in. Fix for #8361
     * [lalithar] - 11/14/91
     */
    if (bLoggedIn)
      {
	szDevice[0] = 'L';
	szDevice[1] = 'P';
	szDevice[2] = 'T';
	szDevice[4] = 0;
	for (i = 0; i < 3; i++)
	  {
	    szDevice[3] = (char)('1' + i);
	    err = RestoreDevice(hwndParent,szDevice,TRUE,&ct);
	    hwndParent = hwndTopNet;

	    ReportError(hwndParent,err,&ct);
	  }
      }
    if (hwndTopNet)
      {
	DestroyWindow(hwndTopNet);
	hwndTopNet = NULL;
      }

ExitRestoreNet:
    /* Write out a 0 since we are no longer restoring net connections.
     */
    WriteProfileString(szNet,szInRestore,NULL);

    return(WN_SUCCESS);
}



/*--------------------------------------------------------------------------*/
/*									    */
/*  LW_InitNetInfo() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

void FAR PASCAL LW_InitNetInfo(void)
{
    int i;
    char szDriver[64];
    char szFile[32];
    char szSection[32];

#ifdef WOW
    HINSTANCE hInst;
    LPTELLKRNL lpTellKrnlWhoNetDrvIs;
#endif

    pNetInfo=NULL;

    if (!LoadString(hInstanceWin,STR_NETDRIVER,szDriver,sizeof(szDriver)))
	return;
    if (!LoadString(hInstanceWin,STR_BOOT,szSection,sizeof(szSection)))
	return;
    if (!LoadString(hInstanceWin,STR_SYSTEMINI,szFile,sizeof(szFile)))
	return;

    /*	look for in the tag NETWORK.DRV, with that as the output and the
     *	default string...
     */
    GetPrivateProfileString(szSection,szDriver,szDriver,szDriver,
	sizeof(szDriver),szFile);

    /* if entry present, but blank, punt
     */
    if (!*szDriver)
	return;

    hWinnetDriver = LoadLibrary(szDriver);
    if (hWinnetDriver < HINSTANCE_ERROR)
	return;

    pNetInfo = (FARPROC NEAR*)UserLocalAlloc(ST_STRING,LPTR,sizeof(FARPROC)*CFNNETDRIVER2);
    if (!pNetInfo)
      {
	FreeLibrary(hWinnetDriver);
	return;
      }

    for (i=0; i<CFNNETDRIVER; i++)
      {
	pNetInfo[i]=GetProcAddress(hWinnetDriver,MAKEINTRESOURCE(i+1));
      }

    if (WNetGetCaps(WNNC_SPEC_VERSION) >= 0x30D)
      {
	for (;i<CFNNETDRIVER2; i++)
	  {
	    pNetInfo[i]=GetProcAddress(hWinnetDriver,MAKEINTRESOURCE(i+1));
	  }
      }

#ifdef WOW
    // Sets up krnl robustness mechanism which allows us to prevent non-user.exe
    // modules from freeing the net driver (ie. causing ref count=0).  Otherwise
    // the proc addresses stored in pNetInfo would become invalid. bug #393078
    hInst = LoadLibrary("krnl386.exe");

    // if this fails, we just fly without robustness -- the way we used to...
    if(HINSTANCE_ERROR <= hInst) {
        lpTellKrnlWhoNetDrvIs =
                     (LPTELLKRNL) GetProcAddress(hInst, MAKEINTRESOURCE(545));
        if(lpTellKrnlWhoNetDrvIs) {
           lpTellKrnlWhoNetDrvIs(hWinnetDriver);
        }
    }
    FreeLibrary(hInst);
#endif

    WNetEnable();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\rmcreate.c ===
/****************************************************************************/
/*                                      */
/*  RMCREATE.C -                                */
/*                                      */
/*  Resource creating Routines.                     */
/*                                      */
/****************************************************************************/

#define RESOURCESTRINGS
#include "user.h"

#ifdef NOT_USED_ANYMORE
#define   NSMOVE   0x0010

HGLOBAL FAR PASCAL  DirectResAlloc(HGLOBAL, WORD, WORD);


/******************************************************************************
**
**  CreateCursorIconIndirect()
**
**      This is the common function called by CreateCursor and
**  CreateIcon()
**      DirectResAlloc() is called instead of GlobalAlloc() because
**  the Icons/Cursors created by one instance of the app can be used in
**  a WNDCLASS structure to Register a class which will be used by other
**  instances of the app and when the instance that created the icons/
**  cursors terminates, the resources SHOULD NOT BE FREED; If GlobalAlloc()
**  is used this is what will happen; At the same time, when the last
**  instance also dies, the memory SHOULD BE FREED; To achieve this,
**  DirectResAlloc() is used instead of GlobalAlloc();
**
******************************************************************************/

HGLOBAL CALLBACK CreateCursorIconIndirect(HINSTANCE hInstance,
                                             LPCURSORSHAPE lpHeader,
                         CONST VOID FAR* lpANDplane,
                         CONST VOID FAR* lpXORplane)
{
    register  WORD  ANDmaskSize;
    register  WORD  XORmaskSize;
    WORD  wTotalSize;
    HRSRC hResource;
    LPSTR lpRes;

    
    ANDmaskSize = lpHeader -> cbWidth * lpHeader -> cy;
    XORmaskSize = (((lpHeader -> cx * lpHeader -> BitsPixel + 0x0F) & ~0x0F)
                    >> 3) * lpHeader -> cy * lpHeader -> Planes;
    
    /* It is assumed that Cursor/Icon size won't be more than 64K */
    wTotalSize = sizeof(CURSORSHAPE) + ANDmaskSize + XORmaskSize;
    
#ifdef NEVER
    /* Allocate the required memory */
    if((hResource = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, 
                        (DWORD)wTotalSize)) == NULL)
    return(NULL);
#else
    /* Let us preserve the long pointers */
    SwapHandle(&lpANDplane);
    SwapHandle(&lpXORplane);

    hResource = DirectResAlloc(hInstance, NSMOVE, wTotalSize);

    /* Let us restore the long pointers */
    SwapHandle(&lpANDplane);
    SwapHandle(&lpXORplane);
    
    if(hResource == NULL)
    return(NULL);
#endif

    if(!(lpRes = GlobalLock(hResource)))
    {
    GlobalFree(hResource);
    return(NULL);
    }

    LCopyStruct((LPSTR)lpHeader, lpRes, sizeof(CURSORSHAPE));
    lpRes += sizeof(CURSORSHAPE);
    LCopyStruct(lpANDplane, lpRes, ANDmaskSize);
    lpRes += ANDmaskSize;
    LCopyStruct(lpXORplane, lpRes, XORmaskSize);

    GlobalUnlock(hResource);
    return(hResource);
}

/******************************************************************************
**
**  CreateCursor()
**
**  This is the API call to create a Cursor "on-the-fly";
**
*******************************************************************************/

HCURSOR API ICreateCursor(hInstance, iXhotspot, iYhotspot, iWidth,
                   iHeight, lpANDplane, lpXORplane)

HINSTANCE hInstance;
int iXhotspot;
int iYhotspot;
int iWidth;
int iHeight;
CONST VOID FAR* lpANDplane;
CONST VOID FAR* lpXORplane;
{
    CURSORSHAPE    Header;

    Header.xHotSpot = iXhotspot;
    Header.yHotSpot = iYhotspot;
    Header.cx = iWidth;
    Header.cy = iHeight;
    Header.Planes = 1;      /* Cursors are only monochrome */
    Header.BitsPixel = 1;
    Header.cbWidth = ((iWidth + 0x0F) & ~0x0F) >> 3;

    return(CreateCursorIconIndirect(hInstance, &Header,
                        lpANDplane, lpXORplane));
}

/******************************************************************************
**
**  CreateIcon()
**
**  This is the API call to create an Icon "on-the-fly";
**
*******************************************************************************/

HICON API ICreateIcon(hInstance, iWidth, iHeight, bPlanes,
                bBitsPixel, lpANDplane, lpXORplane)

HINSTANCE hInstance;
int iWidth;
int iHeight;
BYTE    bPlanes;
BYTE    bBitsPixel;
CONST VOID FAR* lpANDplane;
CONST VOID FAR* lpXORplane;
{
    CURSORSHAPE    Header;

    Header.xHotSpot = iWidth/2;
    Header.yHotSpot = iHeight/2;
    Header.cx = iWidth;
    Header.cy = iHeight;
    Header.Planes = bPlanes;        /* Icons can be in color */
    Header.BitsPixel = bBitsPixel;
    Header.cbWidth = ((iWidth + 0x0F) & ~0x0F) >> 3;

    return(CreateCursorIconIndirect(hInstance, (LPCURSORSHAPE)&Header, 
                        lpANDplane, lpXORplane));
}

/******************************************************************************
 *
 *   DestroyIcon(hIcon) 
 *       This can be called to delete only those icons created "on the fly"
 *   using the CreateIcon() function
 *   Returns:
 *  TRUE if successful, FALSE otherwise.
 *
 ******************************************************************************/

BOOL API IDestroyIcon(HICON hIcon)

{
    return(!FreeResource(hIcon));
}

/******************************************************************************
 *
 *   DestroyCursor(hIcon) 
 *       This can be called to delete only those icons created "on the fly"
 *   using the CreateIcon() function
 *   Returns:
 *      TRUE if successful, FALSE otherwise.
 *
 ******************************************************************************/

BOOL API IDestroyCursor(HCURSOR hCursor)

{
    if (hCursor == hCurCursor)
    {
    /* #12068: if currently selected cursor resore arrow cursor and RIP [lalithar] */
        SetCursor(hCursNormal);
        DebugErr(DBF_ERROR, "DestroyCursor: Destroying current cursor");
    }
    return(!FreeResource(hCursor));
}

#endif /* NOT_USED_ANYMORE */


/****************************************************************************
**
**   DumpIcon()
**  
**  This function is called to get the details of a given Icon;
**
**  The caller must lock hIcon using LockResource() and pass the pointer
**  thro lpIcon;  This is the pointer to the header structure; 
**  Thro lpHeaderSize, the size of header is returned;
**  Thro lplpANDplane and lplpXORplane pointers to actual bit info is
**  returned;
**  This function returns a DWORD with the size of AND plane in loword
**  and size of XOR plane in hiword;
**
****************************************************************************/

DWORD CALLBACK DumpIcon(LPSTR       lpIcon, 
                        WORD FAR *  lpHeaderSize, 
                        LPSTR FAR * lplpANDplane, 
                        LPSTR FAR * lplpXORplane)

{
    register  WORD  ANDmaskSize;
    register  WORD  XORmaskSize;
    LPCURSORSHAPE  lpHeader;

    *lpHeaderSize = sizeof(CURSORSHAPE);

    if(!lpIcon)
    return((DWORD)0);

    lpHeader = (LPCURSORSHAPE)lpIcon;

    ANDmaskSize = lpHeader -> cbWidth * lpHeader -> cy;
    XORmaskSize = (((lpHeader -> cx * lpHeader -> BitsPixel + 0x0F) & ~0x0F)
                    >> 3) * lpHeader -> cy * lpHeader -> Planes;
    
    *lplpANDplane = (lpIcon += sizeof(CURSORSHAPE));
    *lplpXORplane = (lpIcon + ANDmaskSize);

    return(MAKELONG(ANDmaskSize, XORmaskSize));
}

#ifdef NOT_USED_ANYMORE
/****************************************************************************
**
** GetInternalIconHeader(lpIcon, lpDestBuff)
**  
**    This function has been added to fix bug #6351 with cornerstone
** XTRA_LARGE display driver. (It uses 64 X 64 Icons; Internally we 
** keep the size as 32 X 32. Progman must  know this internal size sothat
** it can tell that to WinOldApp.
****************************************************************************/

void API IGetInternalIconHeader(LPSTR       lpIcon, LPSTR lpDestBuff)
{
    LCopyStruct(lpIcon, lpDestBuff, sizeof(CURSORSHAPE));
}
#endif /* NOT_USED_ANYMORE */

/* APIs to make a copy of an icon or cursor */

HICON API ICopyIcon(HINSTANCE hInstance, HICON hIcon)
{
  LPSTR     lpAND;
  LPSTR     lpXOR;
  LPSTR     lpIcon;
  WORD      wHeaderSize;
  HICON     hIconCopy;
  LPCURSORSHAPE  lpHeader;

  lpIcon = LockResource(hIcon);
  if (!lpIcon)
      return NULL;

  lpHeader = (LPCURSORSHAPE)lpIcon;

  DumpIcon(lpIcon, &wHeaderSize, &lpAND, &lpXOR);

    hIconCopy = CreateIcon(hInstance,
                            lpHeader->cx,
                            lpHeader->cy,
                            lpHeader->Planes,
                            lpHeader->BitsPixel,
                            lpAND, lpXOR);

  UnlockResource(hIcon);

  return(hIconCopy);
}

HCURSOR API ICopyCursor(HINSTANCE hInstance, HICON hCursor)
{
  LPSTR     lpAND;
  LPSTR     lpXOR;
  LPSTR     lpCursor;
  WORD      wHeaderSize;
  HCURSOR     hCursorCopy;
  LPCURSORSHAPE  lpHeader;

  lpCursor = LockResource(hCursor);
  if (!lpCursor)
      return NULL;

  lpHeader = (LPCURSORSHAPE)lpCursor;

  DumpIcon(lpCursor, &wHeaderSize, &lpAND, &lpXOR);

    hCursorCopy = CreateCursor(hInstance,
                            lpHeader->xHotSpot,
                            lpHeader->yHotSpot,
                            lpHeader->cx,
                            lpHeader->cy,
                            lpAND, lpXOR);

  UnlockResource(hCursor);

  return(hCursorCopy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   USER.ASM
;   Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;
;--

    TITLE   USER.ASM
    PAGE    ,132

        ; Some applications require that USER have a heap.  This means
        ; we must always have: LIBINIT equ 1
        LIBINIT equ 1

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1     ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

    __acrtused = 0
    public  __acrtused  ;satisfy external C ref.

ifdef LIBINIT
externFP LocalInit
endif
externFP  LW_InitNetInfo
ifndef WOW
externNP  LW_DriversInit
endif

externFP    GetModuleHandle
externFP    SetTaskSignalProc
externFP    NewSignalProc
externFP    IsWindow
externFP    CreateQueue
externFP    WOW16Call
externFP    TileWindows
externFP    CascadeWindows

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  DATA
DontMove    db  2 dup (0)   ; <<< WARNING 2 bytes *must* be reserved at the start
                ; users DS for compatability >>>>
Reserved    db  16 dup (0)  ;reserved for Windows
USER_Identifier db  'USER16 Data Segment'
fFirstApp   db  1

externD     LPCHECKMETAFILE;
ExternW  <hInstanceWin>
ExternW  <hWinnetDriver>

GlobalW     hwndSysModal,0

sEnd    DATA

;
; GP fault exception handler table definition
;
sBegin  GPFIX0
__GP    label   word
public __GP
sEnd    GPFIX0


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

ifdef LIBINIT
externFP LibMain
endif

ifdef WOW
externFP EnableSystemTimers
externFP SetDivZero
endif

cProc   USER16,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>

    cBegin <nogen>

ifdef WOW
    call EnableSystemTimers
endif

    IFDEF   LIBINIT
    ; push params and call user initialisation code

    push di         ;hModule
    mov  hInstanceWin, di

    ; if we have a local heap declared then initialize it

    jcxz no_heap

    push 0          ;segment
    push 0          ;start
    push cx         ;length
    call LocalInit

no_heap:
    call LibMain        ;return exit code from LibMain
    ELSE
    mov  ax,1       ;are we dressed for success or WHAT?!
    ENDIF
    push ax
    cmp  hInstanceWin, 0
    jne  hInstNotNull
    mov  hInstanceWin, di

hInstNotNull:
ifndef WOW
    call LW_DriversInit
endif
    pop  ax

    ret
    cEnd <nogen>

cProc   InitApp,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
    parmW   hInst       ; App's hInstance

    cBegin

    mov     ax,8               ; MAGIC Win3.1 default message queue size
    push    ax                 ; NOTE Win3.1 (and User32) read the size
    call    CreateQueue        ; from win.ini, we don't.
    cmp     ax,0               ; hq
    jne     IA_HaveQ
    mov     ax,0               ; return FALSE
    jmp     IA_Ret

IA_HaveQ:
    push    ds

    mov     ax, _DATA          ; set USER16's DS
    mov     ds,ax
assumes ds, DATA

    xor     dx,dx
    push    dx
    push    seg NewSignalProc
    push    offset NewSignalProc
    call    SetTaskSignalProc
;
; Init WNET apis.
;
    cmp     fFirstApp, 1
    jne     IA_notfirstapp
    mov     fFirstApp, 0
    call    LW_InitNetInfo

IA_notfirstapp:

;
;   Setup Divide By Zero handler
;
    call    SetDivZero

    mov     ax,1
    xor     dx,dx

    pop     ds
IA_Ret:
    cEnd


assumes DS,NOTHING

cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
    parmW   iExit       ;DLL exit code

    cBegin
    mov ax,1        ;always indicate success
    cEnd

;*--------------------------------------------------------------------------*
;*
;*  LFillStruct() -
;*
;*--------------------------------------------------------------------------*

cProc LFillStruct, <PUBLIC, FAR, NODATA, ATOMIC>,<di>
parmD lpStruct
parmW cb
parmW fillChar
cBegin
        les     di,lpStruct
        mov     cx,cb
        mov     ax,fillChar
        cld
    rep stosb
cEnd

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  GetSysModalWindow() -                                                   *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc GetSysModalWindow, <PUBLIC, FAR>
cBegin nogen
        mov     ax,_DATA
        nop
        mov     es,ax
        mov     ax,es:[hwndSysModal]
        or      ax,ax
        jz      GSMW_ItsZero

        push    es
        push    ax                      ; make sure we only return valid
        call    IsWindow                ; windows.
        pop     es
        or      ax,ax
        jnz     GSMW_ItsNotZero
        mov     es:[hwndSysModal], ax   ; zero out hwndSysModal

GSMW_ItsNotZero:
        mov     ax,es:[hwndSysModal]

GSMW_ItsZero:
        retf
cEnd nogen

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  SetSysModalWindow() -                                                   *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc ISetSysModalWindow, <PUBLIC, FAR>
ParmW hwnd
cBegin nogen
        mov     ax,_DATA
        nop
        mov     es,ax
        mov     bx,sp
        mov     ax,ss:[bx+4]
        xchg    ax,es:[hwndSysModal]
        retf    2
cEnd nogen

;
; The DWPBits table defines which messages have actual processing for
; DefWindowProc.  We get these bits from user32.  User32 assumes the
; buffer passed in is zero-initialized, hence the DUP(0) below.
;

DWPBits DB 101 DUP(0)   ; Room for bits for msgs 0 - 807 (decimal)
public DWPBits

cbDWPBits DW ($ - codeoffset DWPBits)
public cbDWPBits

MaxDWPMsg DW 0
public MaxDWPMsg

;*--------------------------------------------------------------------------*
;*
;*  CheckDefWindowProc()
;*
;*  Checks to see if the message gets processed by DefWindowProc.  If not,
;*  the API returns 0.
;*
;*--------------------------------------------------------------------------*

ALIGN 4

cProc CheckDefWindowProc, <PUBLIC, NEAR>
parmW hWnd
parmW wMsg
parmW wParam
parmD lParam
parmD lpReturn          ; Callers Return Address
;parmW wBP           ; Thunk saved BP
;parmW wDS           ; Thunk saved DS
cBegin
    mov  bx,wMsg
    cmp  bx,cs:MaxDWPMsg
    ja   @f         ; jump if above (return with 0)
    mov  cx,bx
    shr  bx,3       ; make byte index into table
    mov  al,cs:[bx+DWPBits] ; get proper 8-bits
    and  cx,0007H
    shr  al,cl      ; get proper bit into bit 0 of al
    test al,1
    jz   @f

    mov  sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop  bp
    ret
@@:
    pop  bp
    xor  ax,ax     ; return (ULONG)0 to flag no window processing
    add  sp,2      ; skip thunk IP
    xor  dx,dx     ; return (ULONG)0 to flag no window processing
    retf 10        ; 10 bytes to pop


cEnd <nogen>



    UserThunk   ADJUSTWINDOWRECT
    UserThunk   ADJUSTWINDOWRECTEX

    ; Hack to use original IDs.  These functions have local implementations
    ; that thunk to Win32 if the locale is other than U.S. English.

    FUN_WIN32ANSILOWER     equ FUN_ANSILOWER
    FUN_WIN32ANSILOWERBUFF equ FUN_ANSILOWERBUFF
    FUN_WIN32ANSINEXT      equ FUN_ANSINEXT
    FUN_WIN32ANSIPREV      equ FUN_ANSIPREV
    FUN_WIN32ANSIUPPER     equ FUN_ANSIUPPER
    FUN_WIN32ANSIUPPERBUFF equ FUN_ANSIUPPERBUFF

    DUserThunk  WIN32ANSILOWER,     %(size ANSILOWER16)
    DUserThunk  WIN32ANSILOWERBUFF, %(size ANSILOWERBUFF16)
    DUserThunk  WIN32ANSINEXT,      %(size ANSINEXT16)
    DUserThunk  WIN32ANSIPREV,      %(size ANSIPREV16)
    DUserThunk  WIN32ANSIUPPER,     %(size ANSIUPPER16)
    DUserThunk  WIN32ANSIUPPERBUFF, %(size ANSIUPPERBUFF16)

    DUserThunk  ANYPOPUP,0
    UserThunk   APPENDMENU
    UserThunk   ARRANGEICONICWINDOWS
    DUserThunk  BEGINDEFERWINDOWPOS
    UserThunk   BEGINPAINT
    UserThunk   BRINGWINDOWTOTOP
    UserThunk   BROADCASTMESSAGE
    UserThunk   BUILDCOMMDCB
;;; UserThunk   BUTTONWNDPROC           ;LOCALAPI in wsubcls.c
    DUserThunk  CALCCHILDSCROLL
    UserThunk   CALLMSGFILTER
    UserThunk   CALLWINDOWPROC
    UserThunk   CARETBLINKPROC
    UserThunk   CHANGECLIPBOARDCHAIN
    UserThunk   CHANGEMENU
    UserThunk   CHECKDLGBUTTON
    UserThunk   CHECKMENUITEM
    UserThunk   CHECKRADIOBUTTON
    UserThunk   CHILDWINDOWFROMPOINT
    UserThunk   CLEARCOMMBREAK
    UserThunk   CLIPCURSOR
    DUserThunk  CLOSECLIPBOARD,0

FUN_WOWCLOSECOMM EQU FUN_CLOSECOMM
    DUserThunk   WOWCLOSECOMM %(size CLOSECOMM16)

    UserThunk   CLOSEWINDOW
;;; UserThunk   COMBOBOXCTLWNDPROC      ;LOCALAPI in wsubcls.c
    UserThunk   COMPUPDATERECT
    UserThunk   COMPUPDATERGN
    DUserThunk  CONTROLPANELINFO
    UserThunk   CONTSCROLL
;;;   UserThunk   COPYRECT               ; LOCALAPI in winrect.asm
    DUserThunk  COUNTCLIPBOARDFORMATS,0
    UserThunk   CREATECARET
    UserThunk   CREATECURSOR
    DUserThunk  CREATECURSORICONINDIRECT
;   UserThunk   CREATEDIALOG                 ; defined in fastres.c
;   UserThunk   CREATEDIALOGINDIRECT
;   UserThunk   CREATEDIALOGINDIRECTPARAM

;FUN_WOWCREATEDIALOGPARAM EQU FUN_CREATEDIALOGPARAM
;    DUserThunk  WOWCREATEDIALOGPARAM, %(size CREATEDIALOGPARAM16)

    UserThunk   CREATEICON
    DUserThunk  CREATEMENU,0
    DUserThunk  CREATEPOPUPMENU,0
    UserThunk   CREATEWINDOW
    UserThunk   CREATEWINDOWEX
    DUserThunk  DCHOOK
    UserThunk   DEFDLGPROC
    UserThunk   DEFERWINDOWPOS
    UserThunk   DEFFRAMEPROC
    UserThunk   DEFMDICHILDPROC
    PUserThunk   DEFWINDOWPROC,CheckDefWindowProc

.386p
LabelFP <PUBLIC, CascadeChildWindows>
        xor     edx, edx
        pop     eax             ; save caller's return addr
        push    edx             ; lpRect == NULL
        push    dx              ; chwnd == 0
        push    edx             ; ahwnd == NULL
        push    eax
        jmp     CascadeWindows

LabelFP <PUBLIC, TileChildWindows>
        xor     edx, edx
        pop     eax             ; save caller's return addr
        push    edx             ; lpRect == NULL
        push    dx              ; chwnd == 0
        push    edx             ; ahwnd == NULL
        push    eax
        jmp     TileWindows
.286p


; From Win 3.1 final inentry.asm - mattfe
;=========================================================================
; OldExitWindows()
;
; This function is at the same ordinal value as the old 2.x ExitWindows.  This
; does nothing more than terminate the app.  If it is the only app running the
; system will go away too.

LabelFP <PUBLIC, OldExitWindows>
    mov ax,4c00h
    int 21h
    retf            ; just in case the int21 returns...

sEnd    CODE

end USER16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SYNCHRONIZE_DRAIN=1

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\msglayer.inc ===
;==========================================================================
;
; Message validation layer include file
;
;- Where applicable, i've specified a class id. as a param. to the MESSAGE
;  macro. For others (WM_ messages), i've specified the ID "COMMON".
;
;- For messages meaningful only to controls having a particular style, i've
;  added an option to the MESSAGE macro:
;
;  <MLCONLY>	     for messages applicable to ES_MULTILINE edit controls
;  <OWNERDRAWVARONLY> "     "	      "       " LBS_OWNERDRAWVARIABLE listboxes
;  <MULTISELONLY>     "     "	      "       " LBS_MULTIPLESEL listboxes
;  <MULTICOLONLY>     "     "	      "       " LBS_MULTICOLUMN listboxes
;
;
; Generic message IDs
;
WM_NULL 	    equ 0000h
WM_CREATE	    equ 0001h
WM_DESTROY	    equ 0002h
WM_MOVE 	    equ 0003h
WM_SIZEWAIT	    equ 0004h		   ;Internal
WM_SIZE 	    equ 0005h
WM_ACTIVATE	    equ 0006h
WM_SETFOCUS	    equ 0007h
WM_KILLFOCUS	    equ 0008h
WM_SETVISIBLE	    equ 0009h		   ;Internal
WM_ENABLE	    equ 000Ah
WM_SETREDRAW	    equ 000Bh
WM_SETTEXT	    equ 000Ch
WM_GETTEXT	    equ 000Dh
WM_GETTEXTLENGTH    equ 000Eh
WM_PAINT	    equ 000Fh
WM_CLOSE	    equ 0010h
WM_QUERYENDSESSION  equ 0011h
WM_QUIT 	    equ 0012h
WM_QUERYOPEN	    equ 0013h
WM_ERASEBKGND	    equ 0014h
WM_SYSCOLORCHANGE   equ 0015h
WM_ENDSESSION	    equ 0016h
WM_SYSTEMERROR	    equ 0017h		   ;Internal
WM_SHOWWINDOW	    equ 0018h
WM_CTLCOLOR	    equ 0019h
WM_WININICHANGE     equ 001Ah
WM_DEVMODECHANGE    equ 001Bh
WM_ACTIVATEAPP	    equ 001Ch
WM_FONTCHANGE	    equ 001Dh
WM_TIMECHANGE	    equ 001Eh
WM_CANCELMODE	    equ 001Fh
WM_SETCURSOR	    equ 0020h
WM_MOUSEACTIVATE    equ 0021h
WM_CHILDACTIVATE    equ 0022h
WM_QUEUESYNC	    equ 0023h
WM_GETMINMAXINFO    equ 0024h
WM_PAINTICON	    equ 0026h
WM_ICONERASEBKGND   equ 0027h
WM_NEXTDLGCTL	    equ 0028h
WM_ALTTABACTIVE     equ 0029h		   ;Internal
WM_SPOOLERSTATUS    equ 002Ah
WM_DRAWITEM	    equ 002Bh
WM_MEASUREITEM	    equ 002Ch
WM_DELETEITEM	    equ 002Dh
WM_VKEYTOITEM	    equ 002Eh
WM_CHARTOITEM	    equ 002Fh
WM_SETFONT	    equ 0030h
WM_GETFONT	    equ 0031h
WM_SETHOTKEY	    equ 0032h
WM_GETHOTKEY	    equ 0033h
WM_FILESYSCHANGE    equ 0034h		   ;Internal
WM_ISACTIVEICON     equ 0035h		   ;Internal
;WM_UNUSED0036      equ 0036h		   ;Internal
WM_QUERYDRAGICON    equ 0037h
WM_COMPAREITEM	    equ 0039h
WM_TESTING	    equ 0040h		   ;Internal
WM_COMPACTING	    equ 0041h
;WM_UNUSED          equ 0042h
;WM_UNUSED          equ 0043h
WM_COMMNOTIFY		equ 0044h
;WM_UNUSED		equ 0045h
WM_WINDOWPOSCHANGING	equ 0046h
WM_WINDOWPOSCHANGED	equ 0047h
WM_POWER		equ 0048h
WM_NCCREATE	    equ 0081h
WM_NCDESTROY	    equ 0082h
WM_NCCALCSIZE	    equ 0083h
WM_NCHITTEST	    equ 0084h
WM_NCPAINT	    equ 0085h
WM_NCACTIVATE	    equ 0086h
WM_GETDLGCODE	    equ 0087h
WM_SYNCPAINT	    equ 0088h		   ;Internal
WM_SYNCTASK	    equ 0089h		   ;Internal
WM_NCMOUSEMOVE	    equ 00A0h
WM_NCLBUTTONDOWN    equ 00A1h
WM_NCLBUTTONUP	    equ 00A2h
WM_NCLBUTTONDBLCLK  equ 00A3h
WM_NCRBUTTONDOWN    equ 00A4h
WM_NCRBUTTONUP	    equ 00A5h
WM_NCRBUTTONDBLCLK  equ 00A6h
WM_NCMBUTTONDOWN    equ 00A7h
WM_NCMBUTTONUP	    equ 00A8h
WM_NCMBUTTONDBLCLK  equ 00A9h
WM_KEYFIRST	    equ 0100h
WM_KEYDOWN	    equ 0100h
WM_KEYUP	    equ 0101h
WM_CHAR 	    equ 0102h
WM_DEADCHAR	    equ 0103h
WM_SYSKEYDOWN	    equ 0104h
WM_SYSKEYUP	    equ 0105h
WM_SYSCHAR	    equ 0106h
WM_SYSDEADCHAR	    equ 0107h
WM_YOMICHAR	    equ 0108h		   ;Internal
WM_KEYLAST	    equ 0108h
WM_CONVERTREQUEST   equ 010Ah		   ;Internal
WM_CONVERTRESULT    equ 010Bh		   ;Internal
WM_INITDIALOG	    equ 0110h
WM_COMMAND	    equ 0111h
WM_SYSCOMMAND	    equ 0112h
WM_TIMER	    equ 0113h
WM_HSCROLL	    equ 0114h
WM_VSCROLL	    equ 0115h
WM_INITMENU	    equ 0116h
WM_INITMENUPOPUP    equ 0117h
WM_SYSTIMER	    equ 0118h		   ;Internal
WM_MENUSELECT	    equ 011Fh
WM_MENUCHAR	    equ 0120h
WM_ENTERIDLE	    equ 0121h
WM_LBTRACKPOINT     equ 0131h		   ;Internal
WM_MOUSEFIRST	    equ 0200h
WM_MOUSEMOVE	    equ 0200h
WM_LBUTTONDOWN	    equ 0201h
WM_LBUTTONUP	    equ 0202h
WM_LBUTTONDBLCLK    equ 0203h
WM_RBUTTONDOWN	    equ 0204h
WM_RBUTTONUP	    equ 0205h
WM_RBUTTONDBLCLK    equ 0206h
WM_MBUTTONDOWN	    equ 0207h
WM_MBUTTONUP	    equ 0208h
WM_MBUTTONDBLCLK    equ 0209h
WM_MOUSELAST	    equ 0209h
WM_PARENTNOTIFY     equ 0210h
WM_ENTERMENULOOP    equ 0211h		   ;Internal
WM_EXITMENULOOP     equ 0212h		   ;Internal
WM_NEXTMENU	    equ 0213h		   ;Internal
WM_MDICREATE	    equ 0220h
WM_MDIDESTROY	    equ 0221h
WM_MDIACTIVATE	    equ 0222h
WM_MDIRESTORE	    equ 0223h
WM_MDINEXT	    equ 0224h
WM_MDIMAXIMIZE	    equ 0225h
WM_MDITILE	    equ 0226h
WM_MDICASCADE	    equ 0227h
WM_MDIICONARRANGE   equ 0228h
WM_MDIGETACTIVE     equ 0229h
WM_DROPOBJECT	    equ 022Ah		   ;Internal
WM_QUERYDROPOBJECT  equ 022Bh		   ;Internal
WM_BEGINDRAG	    equ 022Ch		   ;Internal
WM_DRAGLOOP	    equ 022Dh		   ;Internal
WM_DRAGSELECT	    equ 022Eh		   ;Internal
WM_DRAGMOVE	    equ 022Fh		   ;Internal
WM_MDISETMENU	    equ 0230h
WM_ENTERSIZEMOVE    equ 0231h		   ;Internal
WM_EXITSIZEMOVE     equ 0232h		   ;Internal
WM_DROPFILES	    equ 0233h
WM_KANJIFIRST	    equ 0280h		   ;Internal
WM_KANJILAST	    equ 029Fh		   ;Internal
WM_CUT		    equ 0300h
WM_COPY 	    equ 0301h
WM_PASTE	    equ 0302h
WM_CLEAR	    equ 0303h
WM_UNDO 	    equ 0304h
WM_RENDERFORMAT     equ 0305h
WM_RENDERALLFORMATS equ 0306h
WM_DESTROYCLIPBOARD equ 0307h
WM_DRAWCLIPBOARD    equ 0308h
WM_PAINTCLIPBOARD   equ 0309h
WM_VSCROLLCLIPBOARD equ 030Ah
WM_SIZECLIPBOARD    equ 030Bh
WM_ASKCBFORMATNAME  equ 030Ch
WM_CHANGECBCHAIN    equ 030Dh
WM_HSCROLLCLIPBOARD equ 030Eh
WM_QUERYNEWPALETTE  equ 030Fh
WM_PALETTEGONNACHANGE equ 0310h 	   ;Internal
WM_PALETTEISCHANGING equ 0310h
WM_CHANGEPALETTE    equ 0311h		   ;Internal
WM_PALETTECHANGED   equ 0311h
WM_PENWINFIRST	    equ 0380h
WM_PENWINLAST	    equ 038Fh
WM_INTERNAL_COALESCE_FIRST  equ 0390h	   ;Internal
WM_COALESCE_FIRST   equ 0390h
WM_COALESCE_LAST    equ 039Fh
WM_MM_RESERVED_FIRST equ 03A0h		   ;Internal
WM_MM_RESERVED_LAST  equ 03DFh		   ;Internal
WM_INTERNAL_COALESCE_LAST  equ (WM_MM_RESERVED_FIRST+16) ;Internal
WM_INTERNAL_DDE_FIRST equ 03E0h 	   ;Internal
WM_INTERNAL_DDE_LAST  equ 03EFh 	   ;Internal
WM_CBT_RESERVED_FIRST equ 03F0h 	   ;Internal
WM_CBT_RESERVED_LAST  equ 03FFh 	   ;Internal
WM_USER 	    equ 0400h

; Edit control messages

EM_GETSEL              equ (WM_USER+0)
EM_SETSEL              equ (WM_USER+1)
EM_GETRECT             equ (WM_USER+2)
EM_SETRECT             equ (WM_USER+3)
EM_SETRECTNP           equ (WM_USER+4)
EM_SCROLL              equ (WM_USER+5)
EM_LINESCROLL          equ (WM_USER+6)
EM_GETMODIFY           equ (WM_USER+8)
EM_SETMODIFY           equ (WM_USER+9)
EM_GETLINECOUNT        equ (WM_USER+10)
EM_LINEINDEX           equ (WM_USER+11)
EM_SETHANDLE           equ (WM_USER+12)
EM_GETHANDLE           equ (WM_USER+13)
EM_GETTHUMB            equ (WM_USER+14)
EM_LINELENGTH          equ (WM_USER+17)
EM_REPLACESEL          equ (WM_USER+18)
EM_SETFONT             equ (WM_USER+19)
EM_GETLINE             equ (WM_USER+20)
EM_LIMITTEXT           equ (WM_USER+21)
EM_CANUNDO             equ (WM_USER+22)
EM_UNDO                equ (WM_USER+23)
EM_FMTLINES            equ (WM_USER+24)
EM_LINEFROMCHAR        equ (WM_USER+25)
EM_SETWORDBREAK        equ (WM_USER+26)
EM_SETTABSTOPS         equ (WM_USER+27)
EM_SETPASSWORDCHAR     equ (WM_USER+28)
EM_EMPTYUNDOBUFFER     equ (WM_USER+29)
EM_GETFIRSTVISIBLELINE equ (WM_USER+30)
EM_SETREADONLY         equ (WM_USER+31)
EM_SETWORDBREAKPROC    equ (WM_USER+32)
EM_GETWORDBREAKPROC    equ (WM_USER+33)
EM_GETPASSWORDCHAR     equ (WM_USER+34)
EM_MSGMAX              equ (WM_USER+35)

; Button control messages

BM_GETCHECK	   equ (WM_USER+0)
BM_SETCHECK	   equ (WM_USER+1)
BM_GETSTATE	   equ (WM_USER+2)
BM_SETSTATE	   equ (WM_USER+3)
BM_SETSTYLE	   equ (WM_USER+4)

; Static control messages

STM_SETICON	   equ (WM_USER+0)
STM_GETICON	   equ (WM_USER+1)
STM_MSGMAX	   equ (WM_USER+2)

; Dialog box messages

DM_GETDEFID	    equ (WM_USER+0)
DM_SETDEFID	    equ (WM_USER+1)

; Listbox messages

LB_ADDSTRING	       equ (WM_USER+1)
LB_INSERTSTRING        equ (WM_USER+2)
LB_DELETESTRING        equ (WM_USER+3)
LB_RESETCONTENT        equ (WM_USER+5)
LB_SETSEL	       equ (WM_USER+6)
LB_SETCURSEL	       equ (WM_USER+7)
LB_GETSEL	       equ (WM_USER+8)
LB_GETCURSEL	       equ (WM_USER+9)
LB_GETTEXT	       equ (WM_USER+10)
LB_GETTEXTLEN	       equ (WM_USER+11)
LB_GETCOUNT	       equ (WM_USER+12)
LB_SELECTSTRING        equ (WM_USER+13)
LB_DIR		       equ (WM_USER+14)
LB_GETTOPINDEX	       equ (WM_USER+15)
LB_FINDSTRING	       equ (WM_USER+16)
LB_GETSELCOUNT	       equ (WM_USER+17)
LB_GETSELITEMS	       equ (WM_USER+18)
LB_SETTABSTOPS	       equ (WM_USER+19)
LB_GETHORIZONTALEXTENT equ (WM_USER+20)
LB_SETHORIZONTALEXTENT equ (WM_USER+21)
LB_SETCOLUMNWIDTH      equ (WM_USER+22)
LB_ADDFILE	       equ (WM_USER+23)     ;Internal
LB_SETTOPINDEX	       equ (WM_USER+24)
LB_GETITEMRECT	       equ (WM_USER+25)
LB_GETITEMDATA	       equ (WM_USER+26)
LB_SETITEMDATA	       equ (WM_USER+27)
LB_SELITEMRANGE        equ (WM_USER+28)
LB_SETANCHORINDEX      equ (WM_USER+29)     ;Internal
LB_GETANCHORINDEX      equ (WM_USER+30)     ;Internal
LB_SETCARETINDEX       equ (WM_USER+31)
LB_GETCARETINDEX       equ (WM_USER+32)
LB_SETITEMHEIGHT       equ (WM_USER+33)
LB_GETITEMHEIGHT       equ (WM_USER+34)
LB_FINDSTRINGEXACT     equ (WM_USER+35)
LBCB_CARETON           equ (WM_USER+36)     ;Internal
LBCB_CARETOFF          equ (WM_USER+37)     ;Internal
LB_MSGMAX	       equ (WM_USER+38)

; Combo box messages

CB_GETEDITSEL		 equ (WM_USER+0)
CB_LIMITTEXT		 equ (WM_USER+1)
CB_SETEDITSEL		 equ (WM_USER+2)
CB_ADDSTRING		 equ (WM_USER+3)
CB_DELETESTRING 	 equ (WM_USER+4)
CB_DIR			 equ (WM_USER+5)
CB_GETCOUNT		 equ (WM_USER+6)
CB_GETCURSEL		 equ (WM_USER+7)
CB_GETLBTEXT		 equ (WM_USER+8)
CB_GETLBTEXTLEN 	 equ (WM_USER+9)
CB_INSERTSTRING 	 equ (WM_USER+10)
CB_RESETCONTENT 	 equ (WM_USER+11)
CB_FINDSTRING		 equ (WM_USER+12)
CB_SELECTSTRING 	 equ (WM_USER+13)
CB_SETCURSEL		 equ (WM_USER+14)
CB_SHOWDROPDOWN 	 equ (WM_USER+15)
CB_GETITEMDATA		 equ (WM_USER+16)
CB_SETITEMDATA		 equ (WM_USER+17)
CB_GETDROPPEDCONTROLRECT equ (WM_USER+18)
CB_SETITEMHEIGHT	 equ (WM_USER+19)
CB_GETITEMHEIGHT	 equ (WM_USER+20)
CB_SETEXTENDEDUI	 equ (WM_USER+21)
CB_GETEXTENDEDUI	 equ (WM_USER+22)
CB_GETDROPPEDSTATE	 equ (WM_USER+23)
CB_FINDSTRINGEXACT       equ (WM_USER+24)
CB_MSGMAX		 equ (WM_USER+25)

; DDE messages

WM_DDE_FIRST	    equ 03E0h
WM_DDE_INITIATE     equ (WM_DDE_FIRST)
WM_DDE_TERMINATE    equ (WM_DDE_FIRST+1)
WM_DDE_ADVISE	    equ (WM_DDE_FIRST+2)
WM_DDE_UNADVISE     equ (WM_DDE_FIRST+3)
WM_DDE_ACK	    equ (WM_DDE_FIRST+4)
WM_DDE_DATA	    equ (WM_DDE_FIRST+5)
WM_DDE_REQUEST	    equ (WM_DDE_FIRST+6)
WM_DDE_POKE	    equ (WM_DDE_FIRST+7)
WM_DDE_EXECUTE	    equ (WM_DDE_FIRST+8)
WM_DDE_LAST	    equ (WM_DDE_FIRST+8)

;==================================================

VLmopen = 0
VLmpoff = 0
VLmname equ <>
VLmcont equ <>


DGROUP	group	_DATA
sBegin	DATA
assume	ds:_DATA
;extrn	atomSysClass:word
sEnd	DATA

ExternFP    IsMenu
IFNDEF	WOW
    ExternFP	IsGDIObject
ENDIF
ExternFP    IsWindow


MESSAGE_START	macro	    seg
    _SwitchSeg	<seg>,%VLseg

IFNDEF	WOW
    ExternNP	VHWND&seg
    ExternNP	VHWND0&seg
    ExternNP	VHMENU&seg
    ExternNP	VHMENU0&seg
    ExternNP	GHANDLE&seg
    ExternNP	GHANDLE0&seg
ENDIF

ExternNP    LP&seg
ExternNP    LP0&seg
ExternNP    CLP&seg
ExternNP    CLP0&seg
ExternNP    LPFN&seg
ExternNP    LPFN0&seg
ExternNP    CLPSZ&seg
ExternNP    CLPSZ0&seg
ExternNP    Inval_Param_&seg

hwnd	equ <[bp].0eh>
msg	equ <[bp].0ch>
wParam	equ <[bp].0ah>
lParam	equ <dword ptr [bp]+06h>

;cProc	 ValidateMessage,<FAR, PUBLIC>
;ParmW	 hwnd
;ParmW	 msg
;ParmW	 wParam
;ParmD	 lParam
;cBegin
public	ValidateMessage
ValidateMessage proc far

	push	bp
	mov	bp,sp

	push	offset VM_ERROR     ; push error handler address

	IFNDEF	WOW
	    mov	 bx,hwnd	     ; validate the window handle
	    lcall	VHWND
	ENDIF

	mov	ax,msg
	cmp	ax,WM_USER
	jb	VM_COMMON

	jmp	SHORT VM_VALID	    ;

	IFNDEF	WOW
	    mov	bx,_DATA
	    mov	es,bx
	    assume	es:_DATA
	    mov	bx,hwnd 	    ; ax = hwnd->pcls->atomClassName
	    mov	bx,es:[bx].wndPcls
	    mov	ax,es:[bx].uclsAtomClassName

	    mov	cx,ICLS_CTL_MAX     ; look up the class name
	    push	di		    ; in the atomSysClass array
	    mov	di,offset DGROUP:atomSysClass+(ICLS_CTL_MAX-1)*2
	    std
	    repnz	scasw
	    pop	di
	    cld
	    jnz	VM_VALID	    ; Not special window class: just return.
	    mov	bx,cx		    ; cx has ICLS index
	    add	bx,bx
	    mov	ax,msg
	    jmp	word ptr cs:vmjump[bx]

	ENDIF

VM_VALID:
	mov	ax,1		    ; return TRUE
VM_EXIT:
	pop	dx		    ; strip off error handler address
assume	es:NOTHING

	pop	bp

VM_ERROR:
	retf	2+2+2+4 	    ; error handler jmps here, with clean stack

ValidateMessage endp
;
; NOTE: The order of the following jump table is dependent
; on the order of the ICLS_* values defined in user.h
;

IFNDEF	WOW
vmjump:
	dw	VM_BUTTON
	errnz	<ICLS_BUTTON-0>

	dw	VM_EDIT
	errnz	<ICLS_EDIT-1>

	dw	VM_STATIC
	errnz	<ICLS_STATIC-2>

	dw	VM_LISTBOX
	errnz	<ICLS_LISTBOX-3>

	dw	VM_VALID	 ; No scrollbar messages
	errnz	<ICLS_SCROLLBAR-4>

	dw	VM_COMBOBOX
	errnz	<ICLS_COMBOBOX-5>

ENDIF

endm	; MESSAGE_START

MESSAGE_END	macro
    if VLmopen
	ENDMESSAGE
    endif
    sEnd    %VLseg
endm

;
; MESSAGE - begins a structure declaration
;
MESSAGE macro	name,opts

  if VLmopen
	ENDMESSAGE
  endif

  VLmopen=1
  VLmpoff = 4
  VLmjmp = 0

  _MOpts  <opts>

concat	VLmcont,<VLm>,name
concat	VLmname,name
VLcbstruct  =	0
endm

_MOpts	macro	opts
  VLnogen = 0
  VLnogenparm = 0
  irp	opt,<opts>
    ifidni  <opt>,<NOGEN>
      VLnogen = 1
    endif
    ifidni  <opt>,<DEBUGONLY>
      ifndef DEBUG
	VLnogen = 1
      endif
    endif
    ifidni  <opt>,<POSTED>
    endif
    ifidni  <opt>,<INTERNAL>
    endif
  endm
  VLgen = 0

endm
;
; ENDMESSAGE - Terminates a message declaration
;
ENDMESSAGE  macro
VLmopen = 0
  ife VLmjmp
    ;_print  <Nothing to validate for >,%VLmname
  else
    jmp VM_VALID
  endif
  irp label,<VLmcont>
label:
  endm
endm

;
; MESSAGE_CLASS - Announce
;
MESSAGE_CLASS	macro cls
VM_&cls:
endm

MESSAGE_CLASS_END   macro
  if VLmopen
    ENDMESSAGE
  endif

    jmp     VM_VALID
endm

_FlsMJmp2   macro   name
public PV_&name
PV_&name:
endm

_FlsMJmp    macro
ife VLmjmp
    _FlsMJmp2	%VLmname
    cmp     ax,VLmname
    jnz     VLmcont
    VLmjmp = 1
endif
endm

;
; Increment mpOff: 4 -> 0 -> 2
;
_IncMpOff   macro   size

ife VLmpoff-99
    _print  <Too many message parameters>
    errnz   1
else
 ife size-2

   ife VLmpoff-4
       VLmpoff = 0
   else
    ife VLmpoff-0
	VLmpoff = 2
    else
	VLmpoff = 99
    endif
   endif

 else

   ife VLmpoff-4
       _print  <First message parameter must be 16 bits>
       errnz 1
   else
    ife VLmpoff-0
       VLmpoff = 99
    else
       _print <Too many message parameters>
       errnz  1
    endif
   endif

 endif
endif

endm

;
;
;
_GenMP	macro	name,size,opts

    VLnogenparm = 0

    irp opt,<opts>
     ifidni opt,<NOGEN>
	VLnogenparm = 1
     endif
     ifidni opt,<DEBUGONLY>
      ifndef DEBUG
	VLnogenparm = 1
      endif
     endif
    endm

    VLgen = 1
    if VLnogenparm or VLnogen
	VLgen = 0
    endif

concat	_P_&name,<[bp]+2+4+>,%VLmpoff

_IncMpOff   size
endm

;
; Message parameter macros
;
MP_2	macro	name,opts
_GenMP	<name>,2,<opts>
endm

MP_4	macro	name,opts
_GenMP	<name>,4,<opts>
endm

MP_WMBZ macro	name,opts
_GenMP	<name>,2,<opts>
if VLgen
ifdef DEBUG
    _FlsMJmp
    mov     ax,_P_&name
    or	    ax,ax
    jz	    @F
    mov     bx,ERR_BAD_VALUE or ERR_WARNING
    lcall   Inval_Param_
@@:
endif
endif
endm

MP_LMBZ macro	name,opts
_GenMP	<name>,4,<opts>
if VLgen
ifdef DEBUG
    _FlsMJmp
    mov     bx,_P_&name
    mov     cx,_P_&name+2
    or	    bx,cx
    jz	    @F
    mov     ax,_P_&name
    mov     bx,ERR_BAD_DVALUE or ERR_WARNING
    lcall   Inval_Param_
@@:
endif	; DEBUG
endif
endm

; Simple types

MP_int	    equ <MP_2>
MP_BOOL     equ <MP_2>
MP_LONG     equ <MP_4>
MP_DWORD    equ <MP_4>
MP_WORD     equ <MP_2>

MP_POINT    equ <MP_4>

MP_RVALUE   macro   val, min, max, opts
    MP_2    <flags>,<opts>
endm

MP_VALUE    macro   val, max, opts
    MP_2    <flags>,<opts>
endm

MP_FLAGS    macro   flags, valid, opts
    MP_2    <flags>,<opts>
endm

; Handles
;
; Generate a GDI object validation macro.
;
; If nullok is 1, allow NULL.
; min & max are the allowed OBJ_* range.
; except, if specified, is an OBJ_* value within the range to reject.
;
_GenMPHGDI    macro   name,nullok,min,max,except
    name &macro   hObj,opts
	local	badobj
	local	objok
	_GenMP	  <hObj>,2,<opts>
	if VLgen
	    _FlsMJmp

	  IFNDEF    WOW

	  if nullok
	    mov     cx,_P_&&hObj
	    jcxz    objok
	    push    cx
	  else
	    push    _P_&&hObj
	  endif
	    call    IsGDIObject
	  ifnb <except>
	    cmp     al,except
	    jz	    badobj
	  endif
	  ife min-max
	    cmp     al,min
	    je	    objok
	  else
	    cmp     al,min
	    jb	    badobj
	    cmp     al,max
	    jbe     objok
	  endif
	badobj:
	    mov     ax,_P_&&hObj
            mov     bx,ERR_BAD_HANDLE
            lcall   Inval_Param_
	objok:

	ENDIF

	endif
    &endm
endm

OBJ_PEN 	equ	1
OBJ_BRUSH	equ	2
OBJ_FONT	equ	3
OBJ_PALETTE	equ	4
OBJ_BITMAP	equ	5
OBJ_RGN 	equ	6
OBJ_DC		equ	7
OBJ_IC		equ	8
OBJ_DISABLED_DC equ	9
OBJ_METADC	equ	10
OBJ_METAFILE	equ	11

_GenMPHGDI  <MP_HDC>,0,OBJ_DC,OBJ_METAFILE
_GenMPHGDI  <MP_HDC0>,1,OBJ_DC,OBJ_METAFILE

_GenMPHGDI  <MP_HPEN>,0,OBJ_PEN,OBJ_PEN
_GenMPHGDI  <MP_HPEN0>,1,OBJ_PEN,OBJ_PEN

_GenMPHGDI  <MP_HBRUSH>,0,OBJ_BRUSH,OBJ_BRUSH
_GenMPHGDI  <MP_HBRUSH0>,1,OBJ_BRUSH,OBJ_BRUSH

_GenMPHGDI  <MP_HFONT>,0,OBJ_FONT,OBJ_FONT
_GenMPHGDI  <MP_HFONT0>,1,OBJ_FONT,OBJ_FONT

_GenMPHGDI  <MP_HPALETTE>,0,OBJ_PALETTE,OBJ_PALETTE
_GenMPHGDI  <MP_HPALETTE0>,1,OBJ_PALETTE,OBJ_PALETTE

_GenMPHGDI  <MP_HBITMAP>,0,OBJ_BITMAP,OBJ_BITMAP
_GenMPHGDI  <MP_HBITMAP0>,1,OBJ_BITMAP,OBJ_BITMAP

_GenMPHGDI  <MP_HRGN>,0,OBJ_RGN,OBJ_RGN
_GenMPHGDI  <MP_HRGN0>,1,OBJ_RGN,OBJ_RGN

MP_HRGN01   equ <MP_2>	    ; hrgn, NULL, or (HRGN)1

MP_HMENU macro	 hMenu,opts
    _GenMP    <hMenu>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov	 bx,_P_&hMenu
	    lcall	 VHMENU
	ENDIF
        _gensub VHMENU
    @@:
    endif
endm

MP_HMENU0 macro   hMenu,opts
    _GenMP    <hMenu>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov	 bx,_P_&hMenu
	    lcall	 VHMENU0
	ENDIF
        _gensub VHMENU
    endif
endm

MP_HWND  macro	 hwnd,opts
    _GenMP    <hwnd>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov		 bx,_P_&hwnd
	    lcall	 VHWND
	ENDIF
        _gensub VHWND
    endif
endm

MP_HWND0 macro	 hwnd,opts
    _GenMP    <hwnd>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF WOW
	     mov	 bx,_P_&hwnd
	     lcall	 VHWND0
	ENDIF
        _gensub VHWND
    endif
endm

; Warn if the window handle is 0 or a bad window handle

MP_HWNDW macro   hwnd,opts
     Local    ZeroHandle
    _GenMP    <hwnd>,2,<opts>
ifdef DEBUG
    if VLgen
	_FlsMJmp
	mov	cx,_P_&hwnd
	mov	ax, cx		;; Error reporting expects window handle in AX
	jcxz	ZeroHandle

	jmp	@F

	IFNDEF	WOW
	push	cx		;; Save window handle
	push	cx
	call	IsWindow
	or	ax,ax
	pop	ax		;; Resore the window handle to AX
	jnz	@F
	ENDIF

ZeroHandle:
	;; AX must have the bad Window handle
        mov     bx,ERR_BAD_HWND or ERR_WARNING
	lcall	Inval_Param_
    @@:
    endif
endif
endm

; Warning only.

MP_HWNDW0 macro   hwnd,opts
    _GenMP    <hwnd>,2,<opts>
ifdef DEBUG
    if VLgen
	_FlsMJmp

	IFNDEF	WOW
	    mov	cx,_P_&hwnd
	    jcxz	@F
	    push	cx
	    push	cx
	    call	IsWindow
	    or	ax,ax
	    pop	ax
	    jnz	@F
	    mov	 bx,ERR_BAD_HWND or ERR_WARNING
	    lcall	Inval_Param_
	   @@:
	ENDIF

    endif
endif
endm

MP_HWND01 macro   hwnd,opts	 ; hwnd, 0, or 1
    _GenMP    <hwnd>,2,<opts>
    if VLgen
	_FlsMJmp
	IFNDEF	WOW
	    mov	 bx,_P_&hwnd
	    cmp	 bx,1
	    jbe	@F
	    lcall	 VHWND
	ENDIF
        _gensub VHWND
    @@:
    endif
endm

MP_HWNDCLIP equ <MP_HWND>

MP_LHANDLE  macro   name,opts
    _GenMP  <name>,2,<opts>
    if VLgen
        _FlsMJmp
	mov	ax,_P_&name
	or	ax,ax
	jnz	@F
        mov     bx,ERR_BAD_LOCAL_HANDLE
        lcall   Inval_Param_
    @@:
    endif
endm

MP_LHANDLE0 equ <MP_2>

MP_GHANDLE     macro   h,opts
_GenMP	<h>,2,<opts>
if VLgen
    _FlsMJmp
    IFNDEF  WOW
	mov	ax,_P_&h
	lcall	GHANDLE
    ENDIF
endif
endm

MP_GHANDLE0    macro   h,opts
_GenMP	<h>,2,<opts>
if VLgen
    _FlsMJmp
    IFNDEF  WOW
	mov	ax,_P_&h
	lcall	GHANDLE0
    ENDIF
endif
endm

MP_GHANDLEDDE	equ <MP_GHANDLE>
MP_GHANDLEDDE0	equ <MP_GHANDLE0>

MP_GHANDLEDDEW     macro   h,opts
local	GHexit
_GenMP	<h>,2,<opts>
ifdef DEBUG
   if VLgen
      _FlsMJmp
      mov       ax,_P_&h
      test	al,0100b	; Reject GDT selectors
      jz        @F
      cmp	ax,0ffffh	; special case: -1 -> DS
      jz	GHexit
      lar	dx,ax		; is it a valid selector?
      jz        GHexit
@@:
      mov       bx,ERR_BAD_GLOBAL_HANDLE or ERR_WARNING
      lcall	Inval_Param_
GHexit:
   endif
endif
endm

MP_HICON    equ <MP_GHANDLE>
MP_HICON0   equ <MP_GHANDLE0>

MP_HTASK    equ <MP_GHANDLE>
MP_HTASK0   equ <MP_GHANDLE0>

; Pointers

MP_LP	macro	lptr,opts
_GenMP	<lptr>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lptr
    mov     cx,_P_&lptr+2
    mov     bx,1
    lcall   LP
    _gensub LP
endif
endm

MP_CLP	macro	lp,opts
_GenMP	<lp>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lp
    mov     cx,_P_&lp+2
    mov     bx,1
    lcall   CLP
    _gensub LP
endif
endm

MP_LP0	macro	lp,opts
_GenMP	<lp>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lp
    mov     cx,_P_&lp+2
    mov     bx,1
    lcall   LP0
    _gensub LP
endif
endm

MP_CLP0 macro	lp,opts
_GenMP	<lp>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lp
    mov     cx,_P_&lp+2
    mov     bx,1
    lcall   CLP0
    _gensub LP
endif
endm

MP_LPBUFFERCNT	equ <MP_LP>

MP_CLPSTR	macro	lpsz,opts
_GenMP	<lpsz>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lpsz
    mov     cx,_P_&lpsz+2
    mov     bx,-1
    lcall   CLPSZ
    _gensub LPSZ
endif
endm

MP_CLPSTR0	macro	lpsz,opts
_GenMP	<lpsz>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&lpsz
    mov     cx,_P_&lpsz+2
    mov     bx,-1
    lcall   CLPSZ0
    _gensub LPSZ
endif
endm

MP_LPSTRCB	equ <MP_4>	; may be arbitrary 32-bit value
MP_CLPSTRCB	equ <MP_4>

MP_CLPSTRLB	equ <MP_4>	; may be arbitrary 32-bit value

MP_CLPMSG0	equ <MP_CLP0>

MP_LPRECT	equ <MP_LP>
MP_CLPRECT	equ <MP_LP>

MP_LPBUFFERX	macro	count, lpBuffer, opts
    MP_int	<count>,<opts>
    MP_LP	<lpBuffer>,<opts>
endm

MP_LPTSBUFFER0	macro	cTabs, lpTabs, opts
    MP_int	<cTabs>,<opts>
    MP_LP0	<lpTabs>,<opts>
endm

MP_LPWBUFFERX	macro	wCount, lpBuf, opts	;** lpBuf is int. buffer
    MP_int	<count>,<opts>
    MP_LP	<lpTabs>,<opts>
endm

MP_LPMEASUREITEMSTRUCT	equ <MP_LP>
MP_LPCREATESTRUCT	equ <MP_LP>

MP_CLPCOMPAREITEMSTRUCT equ <MP_CLP>
MP_CLPDELETEITEMSTRUCT	equ <MP_CLP>
MP_CLPDRAWITEMSTRUCT	equ <MP_CLP>
MP_CLPMDICREATESTRUCT	equ <MP_CLP>
MP_CLP5POINTBUFFER	equ <MP_CLP>	; array of 5 points

; Function pointers

MP_LPFNWORDBREAK0 macro   pfn,opts
_GenMP	<pfn>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&pfn
    mov     cx,_P_&pfn+2
    lcall   LPFN0
    _gensub LPFN
endif
endm

MP_LPFNTIMER0 macro   pfn,opts
_GenMP	<pfn>,4,<opts>
if VLgen
    _FlsMJmp
    mov     ax,_P_&pfn
    mov     cx,_P_&pfn+2
    lcall   LPFN0
    _gensub LPFN
endif
endm

; More types

MP_ATOM 	equ <MP_2>
MP_ATOM0	equ <MP_2>

MP_BIVALUE	macro	val,v1,v2,opts
    MP_2	<val>,<opts>
endm

MP_CBINDEX	equ <MP_2>
MP_CBINDEXFFFF	equ <MP_2>
MP_CBITEMHEIGHTFFFF equ <MP_2>
MP_CHARINDEXFFFF    equ <MP_2>
MP_CHARVALUE	    equ <MP_2>
MP_CID		equ <MP_2>

MP_CONST	macro	val, constant, opts		  ;** set to SMP_JOBSTATUS
    MP_2	<val>,<opts>
endm

MP_CTRLID	equ <MP_2>
MP_EDITPOS	equ <MP_2>
MP_EMCHARPOS	equ <MP_2>
MP_EMLINE	equ <MP_2>
MP_EMLINEFFFF	equ <MP_2>
MP_EMLINEFFFF	equ <MP_2>
MP_EMCLINE	equ <MP_2>

MP_LBINDEX	equ <MP_2>
MP_LBINDEXFFFF	equ <MP_2>

MP_LBLPBUFFERINDEX macro wIndex, lpBuf, opts
    MP_2    <wIndex>,<opts>
    MP_4    <lpBuf>,<opts>
endm

MP_SHOWVALUE	equ <MP_WORD>
MP_SYSCOMMAND	equ <MP_WORD>
MP_VKEY 	equ <MP_WORD>

MP_WMMENUSELECT macro	idOrHandle, flags, opts
    MP_2	idOrHMenu	    ; id or menu handle
    MP_2	flags		    ; may be -1
    MP_2	hMenu		    ; may be NULL
endm

MP_WMNEXTDLGCTL macro	hwndOrFPrev, fHandle, opts     ;** if lParam is 0 wParam is a flag
    MP_2	<hwndOrFPrev>,<opts>
    MP_BOOL	<fHandle>,<opts>
    MP_WMBZ	lParamH,<opts>
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\rmload.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  RMLOAD.C
 *  WOW16 user resource services
 *
 *  History:
 *
 *  Created 12-Apr-1991 by Nigel Thompson (nigelt)
 *  Much hacked about version of the Win 3.1 rmload.c source
 *  It doesn't attempt any device driver resource loading
 *  or do anything to support Win 2.x apps.
 *
 *  Revised 19-May-1991 by Jeff Parsons (jeffpar)
 *  IFDEF'ed everything except LoadString;  because of the client/server
 *  split in USER32, most resources are copied to the server's context and
 *  freed in the client's, meaning the client no longer gets a handle to
 *  a global memory object.  We could give it one, but it would be a separate
 *  object, which we would have to keep track of, and which would be difficult
 *  to keep in sync with the server's copy if changes were made.
--*/

/****************************************************************************/
/*                                      */
/*  RMLOAD.C -                                  */
/*                                      */
/*  Resource Loading Routines.                      */
/*                                      */
/****************************************************************************/

#define RESOURCESTRINGS
#include "user.h"
#include "multires.h"

//
// We define certain things here because including mvdm\inc\*.h files here
// will lead to endless mess.
//

DWORD API NotifyWow(WORD, LPBYTE);

typedef struct _LOADACCEL16 {    /* ldaccel */
    WORD   hInst;
    WORD   hAccel;
    LPBYTE pAccel;
    DWORD  cbAccel;
} LOADACCEL16, FAR *PLOADACCEL16;

/* This must match its counterpart in mvdm\inc\wowusr.h */
#define NW_LOADACCELERATORS        3 //


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadAccelerators() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

HACCEL API ILoadAccelerators(HINSTANCE hInstance, LPCSTR lpszAccName)
{
    HRSRC hrl;
    HACCEL hAccel = NULL;
    LOADACCEL16 loadaccel;

    hrl = FindResource(hInstance, lpszAccName, RT_ACCELERATOR);
#ifdef WOW
    if (hrl) {
        hAccel = (HACCEL)LoadResource(hInstance, hrl);
        if (hAccel) {

            // create 32bit accelerator and 16-32 alias.

            loadaccel.hInst = (WORD)hInstance;
            loadaccel.hAccel = (WORD)hAccel;
            loadaccel.pAccel = (LPBYTE)LockResource(hAccel);
            loadaccel.cbAccel = (DWORD)SizeofResource(hInstance, hrl);

            if (NotifyWow(NW_LOADACCELERATORS, (LPBYTE)&loadaccel)) {
                UnlockResource(hAccel);
            }
            else {
                UnlockResource(hAccel);
                hAccel = NULL;
            }
        }

    }

    return (hAccel);
#else
    if (!hrl)
    return NULL;

    return (HACCEL)LoadResource(hInstance, hrl);
#endif
}



int API ILoadString(
    HINSTANCE    h16Task,
    UINT         wID,
    LPSTR        lpBuffer,
    register int nBufferMax)
{
    HANDLE   hResInfo;
    HANDLE   hStringSeg;
    LPSTR    lpsz;
    register int cch, i;

    /* Make sure the parms are valid. */
    if (!lpBuffer || (nBufferMax-- == 0))
    return(0);

    cch = 0;

    /* String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FindResource(h16Task, (LPSTR)((LONG)((wID >> 4) + 1)), RT_STRING))
      {
    /* Load that segment. */
    hStringSeg = LoadResource(h16Task, hResInfo);

    /* Lock the resource. */
    if (lpsz = (LPSTR)LockResource(hStringSeg))
      {
        /* Move past the other strings in this segment. */
        wID &= 0x0F;
        while (TRUE)
          {
        cch = *((BYTE FAR *)lpsz++);
        if (wID-- == 0)
            break;
        lpsz += cch;
          }

        /* Don't copy more than the max allowed. */
        if (cch > nBufferMax)
        cch = nBufferMax;

        /* Copy the string into the buffer. */
        LCopyStruct(lpsz, lpBuffer, cch);

        GlobalUnlock(hStringSeg);

        /* BUG: If we free the resource here, we will have to reload it
         *      immediately for many apps with sequential strings.
         *      Force it to be discardable however because non-discardable
         *      string resources make no sense.   Chip
         */
        GlobalReAlloc(hStringSeg, 0L,
              GMEM_MODIFY | GMEM_MOVEABLE | GMEM_DISCARDABLE);
      }
      }

    /* Append a NULL. */
    lpBuffer[cch] = 0;

    return(cch);
}


#ifdef NEEDED

#define  DIB_RGB_COLORS  0

HBITMAP FAR  PASCAL ConvertBitmap(HBITMAP hBitmap);
HANDLE  NEAR PASCAL LoadDIBCursorIconHandler(HANDLE, HANDLE, HANDLE, BOOL);
WORD    FAR  PASCAL GetIconId(HANDLE, LPSTR);
HBITMAP FAR  PASCAL StretchBitmap(int, int, int, int, HBITMAP, BYTE, BYTE);
WORD    NEAR PASCAL StretchIcon(LPCURSORSHAPE, WORD, HBITMAP, BOOL);
WORD    NEAR PASCAL SizeReqd(BOOL, WORD, WORD, BOOL, int, int);
WORD    NEAR PASCAL CrunchAndResize(LPCURSORSHAPE, BOOL, BOOL, BOOL, BOOL);
HANDLE  FAR  PASCAL LoadCursorIconHandler2(HANDLE, LPCURSORSHAPE, WORD);
HANDLE  FAR  PASCAL LoadDIBCursorIconHandler2(HANDLE, LPCURSORSHAPE, WORD, BOOL);

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadIconHandler() -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

HICON FAR PASCAL LoadIconHandler(hIcon, fNewFormat)

HICON   hIcon;
BOOL    fNewFormat;

{
  LPCURSORSHAPE lpIcon;
  WORD      wSize;

    dprintf(7,"LoadIconHandler");
  wSize = (WORD)GlobalSize(hIcon);
  lpIcon = (LPCURSORSHAPE)(GlobalLock(hIcon));

  if (fNewFormat)
      return(LoadDIBCursorIconHandler2(hIcon, lpIcon, wSize, TRUE));
  else
      return(LoadCursorIconHandler2(hIcon, lpIcon, wSize));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  FindIndividualResource()                            */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL FindIndividualResource(register HANDLE hResFile,
                      LPSTR       lpszName,
                      LPSTR       lpszType)

{
  WORD        idIcon;
  register HANDLE h;

    dprintf(7,"FindIndividualResource");
  /* Check if the resource is to be taken from the display driver.
   * If so, check the driver version; If the resource is to be taken from
   * the application, check the app version.
   */

  if ((lpszType != RT_BITMAP) && ((LOWORD(GetExpWinVer(hResFile)) >= VER)))
    {
      /* Locate the directory resource */
      h = SplFindResource(hResFile, lpszName, (LPSTR)(lpszType + DIFFERENCE));
      if (h == NULL)
      return((HANDLE)0);

      /* Load the directory resource */
      h = LoadResource(hResFile, h);

      /* Get the name of the matching resource */
      idIcon = GetIconId(h, lpszType);

      /* NOTE: Don't free the (discardable) directory resource!!! - ChipA */
      /*
       * We should not call SplFindResource here, because idIcon is
       * internal to us and GetDriverResourceId won't know how tomap it.
       */
      return(FindResource(hResFile, MAKEINTRESOURCE(idIcon), lpszType));
    }
  else
      /* It is an Old app; The resource is in old format */
      return(SplFindResource(hResFile, lpszName, lpszType));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetBestFormIcon()                               */
/*                                      */
/*  Among the different forms of Icons present, choose the one that     */
/*  matches the PixelsPerInch values and the number of colors of the        */
/*  current display.                                    */
/*                                          */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL GetBestFormIcon(LPRESDIR  ResDirPtr,
                 WORD      ResCount)

{
  register WORD wIndex;
  register WORD ColorCount;
  WORD      MaxColorCount;
  WORD      MaxColorIndex;
  WORD      MoreColorCount;
  WORD      MoreColorIndex;
  WORD      LessColorCount;
  WORD      LessColorIndex;
  WORD      DevColorCount;

    dprintf(7,"GetBestFormIcon");
  /* Initialse all the values to zero */
  MaxColorCount = MaxColorIndex = MoreColorCount =
  MoreColorIndex = LessColorIndex = LessColorCount = 0;

  /* get number of colors on device.  if device is very colorful,
  ** set to a high number without doing meaningless 1<<X operation.
  */
  if (oemInfo.ScreenBitCount >= 16)
      DevColorCount = 32000;
  else
      DevColorCount = 1 << oemInfo.ScreenBitCount;

  for (wIndex=0; wIndex < ResCount; wIndex++, ResDirPtr++)
    {
      /* Check for the number of colors */
      if ((ColorCount = (ResDirPtr->ResInfo.Icon.ColorCount)) <= DevColorCount)
    {
      if (ColorCount > MaxColorCount)
        {
              MaxColorCount = ColorCount;
          MaxColorIndex = wIndex;
        }
    }

      /* Check for the size */
      /* Match the pixels per inch information */
      if ((ResDirPtr->ResInfo.Icon.Width == (BYTE)oemInfo.cxIcon) &&
          (ResDirPtr->ResInfo.Icon.Height == (BYTE)oemInfo.cyIcon))
    {
      /* Matching size found */
      /* Check if the color also matches */
          if (ColorCount == DevColorCount)
          return(wIndex);  /* Exact match found */

          if (ColorCount < DevColorCount)
        {
          /* Choose the one with max colors, but less than reqd */
              if (ColorCount > LessColorCount)
        {
                  LessColorCount = ColorCount;
          LessColorIndex = wIndex;
        }
        }
      else
        {
              if ((LessColorCount == 0) && (ColorCount < MoreColorCount))
        {
                  MoreColorCount = ColorCount;
          MoreColorIndex = wIndex;
        }
        }
    }
    }

  /* Check if we have a correct sized but with less colors than reqd */
  if (LessColorCount)
      return(LessColorIndex);

  /* Check if we have a correct sized but with more colors than reqd */
  if (MoreColorCount)
      return(MoreColorIndex);

  /* Check if we have one that has maximum colors but less than reqd */
  if (MaxColorCount)
      return(MaxColorIndex);

  return(0);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetBestFormCursor()                             */
/*                                      */
/*   Among the different forms of cursors present, choose the one that      */
/*   matches the width and height defined by the current display driver.    */
/*                                          */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL GetBestFormCursor(LPRESDIR  ResDirPtr,
                   WORD      ResCount)

{
  register WORD  wIndex;

    dprintf(7,"GetBestFormCursor");
  for (wIndex=0; wIndex < ResCount; wIndex++, ResDirPtr++)
    {
      /* Match the Width and Height of the cursor */
      if ((ResDirPtr->ResInfo.Cursor.Width  == oemInfo.cxCursor) &&
          ((ResDirPtr->ResInfo.Cursor.Height >> 1) == oemInfo.cyCursor))
      return(wIndex);
    }

  return(0);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetIconId()                                 */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD FAR PASCAL GetIconId(hRes, lpszType)

HANDLE   hRes;
LPSTR    lpszType;

{
  WORD        w;
  LPRESDIR    ResDirPtr;
  LPNEWHEADER     DataPtr;
  register WORD   RetIndex;
  register WORD   ResCount;

    dprintf(7,"GetIconId");
  if ((DataPtr = (LPNEWHEADER)LockResource(hRes)) == NULL)
      return(0);

  ResCount = DataPtr->ResCount;
  ResDirPtr = (LPRESDIR)(DataPtr + 1);

  switch (LOWORD((DWORD)lpszType))
    {
      case RT_ICON:
       RetIndex = GetBestFormIcon(ResDirPtr, ResCount);
       break;

      case RT_CURSOR:
       RetIndex = GetBestFormCursor(ResDirPtr, ResCount);
       break;
    }

  if (RetIndex == ResCount)
      RetIndex = 0;

  ResCount = ((LPRESDIR)(ResDirPtr+RetIndex))->idIcon;

  UnlockResource(hRes);

  return(ResCount);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  UT_LoadCursorIconBitmap() -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL UT_LoadCursorIconBitmap(register HANDLE hrf,
                       LPSTR       lpszName,
                       int         type)

{
  register HANDLE h;

    dprintf(7,"LoadCursorIconBitmap");
  if (hrf == NULL) return (HANDLE)0; // no 2.x support - NigelT

  h = FindIndividualResource(hrf, lpszName, MAKEINTRESOURCE(type));

  if (h != NULL)
      h = LoadResource(hrf, h);

  return(h);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  fCheckMono() -                                                          */
/*      Checks a DIB for being truely monochrome.  Only called if           */
/*      BitCount == 1.  This function checks the color table (address       */
/*      passed) for true black and white RGB's                              */
/*                                      */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL fCheckMono(LPVOID  lpColorTable,
                BOOL    fNewDIB)

{
  LPLONG   lpRGB;
  LPWORD   lpRGBw;

    dprintf(7,"fCheckMono");
  lpRGB = lpColorTable;
  if (fNewDIB)
    {
      if ((*lpRGB == 0 && *(lpRGB + 1) == 0x00FFFFFF) ||
      (*lpRGB == 0x00FFFFFF && *(lpRGB + 1) == 0))
      return(TRUE);
    }
  else
    {
      lpRGBw = lpColorTable;
      if (*(LPSTR)lpRGBw == 0)
        {
      if (*lpRGBw == 0 && *(lpRGBw+1) == 0xFF00 && *(lpRGBw+2) == 0xFFFF)
              return(TRUE);
        }
      else if (*lpRGBw == 0xFFFF && *(lpRGBw+1) == 0x00FF && *(lpRGBw+2) == 0)
      return(TRUE);
    }
  return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadNewBitmap() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Loads a 3.x format bitmap into the DIB structure. */

HBITMAP NEAR PASCAL LoadNewBitmap(HANDLE  hRes,
                  LPSTR   lpName)

{
  register HBITMAP hbmS;
  register HBITMAP hBitmap;

    dprintf(7,"LoadNewBitmap");

  if ((hbmS = hBitmap = UT_LoadCursorIconBitmap(hRes,lpName,(WORD)RT_BITMAP)))
    {
      /* Convert the DIB bitmap into a bitmap in the internal format */
      hbmS = ConvertBitmap(hBitmap);

      /* Converted bitmap is in hbmS; So, release the DIB */
      FreeResource(hBitmap);
    }
  return(hbmS);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  ConvertBitmap()                             */
/*                                      */
/*    This takes in a handle to data in PM 1.1 or 1.2 DIB format or     */
/*    Windows 3.0 DIB format and creates a bitmap in the internal       */
/*    bitmap format and returns the handle to it.               */
/*                                      */
/*    NOTE:                                 */
/*   This function is exported because it is called from CLIPBRD.EXE    */
/*                                      */
/*--------------------------------------------------------------------------*/

HBITMAP FAR PASCAL ConvertBitmap(HBITMAP hBitmap)

{
  int           Width;
  register int      Height;
  HDC           hDC;
  BOOL          fMono = FALSE;
  LPSTR         lpBits;
  register HBITMAP  hbmS;
  LPBITMAPINFOHEADER    lpBitmap1;
  LPBITMAPCOREHEADER    lpBitmap2;

    dprintf(7,"ConvertBitmap");
  lpBitmap1 = (LPBITMAPINFOHEADER)LockResource(hBitmap);

  if (!lpBitmap1)
      return(NULL);

  if ((WORD)lpBitmap1->biSize == sizeof(BITMAPCOREHEADER))
    {
      /* This is an "old form" DIB.  This matches the PM 1.1 format. */
      lpBitmap2 = (LPBITMAPCOREHEADER)lpBitmap1;
      Width = lpBitmap2->bcWidth;
      Height = lpBitmap2->bcHeight;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpBits = (LPSTR)(lpBitmap2 + 1);

      /* Skip the color table entries, if any */
      if (lpBitmap2->bcBitCount != 24)
    {
      if (lpBitmap2->bcBitCount == 1)
          fMono = fCheckMono(lpBits, FALSE);
      lpBits += (1 << (lpBitmap2->bcBitCount)) * sizeof(RGBTRIPLE);
    }
    }
  else
    {
      Width = (WORD)lpBitmap1->biWidth;
      Height = (WORD)lpBitmap1->biHeight;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpBits = (LPSTR)(lpBitmap1 + 1);

      /* Skip the color table entries, if any */
      if (lpBitmap1->biClrUsed != 0)
    {
      if (lpBitmap1->biClrUsed == 2)
          fMono = fCheckMono(lpBits, TRUE);
      lpBits += lpBitmap1->biClrUsed * sizeof(RGBQUAD);
    }
      else
    {
      if (lpBitmap1->biBitCount != 24)
        {
          if (lpBitmap1->biBitCount == 1)
          fMono = fCheckMono(lpBits, TRUE);
          lpBits += (1 << (lpBitmap1->biBitCount)) * sizeof(RGBQUAD);
        }
    }
    }

  /* Create a bitmap */
  if (fMono)
      hbmS = CreateBitmap(Width, Height, 1, 1, (LPSTR)NULL);
  else
    {
      /* Create a color bitmap compatible with the display device */
      hDC = GetScreenDC();
      hbmS = CreateCompatibleBitmap(hDC, Width, Height);
      InternalReleaseDC(hDC);
    }

  /* Initialize the new bitmap by converting from PM format */
  if (hbmS != NULL)
      SetDIBits(hdcBits, hbmS, 0, Height, lpBits,
                (LPBITMAPINFO)lpBitmap1, DIB_RGB_COLORS);

  GlobalUnlock(hBitmap);

  return(hbmS);
}


HANDLE NEAR PASCAL Helper_LoadCursorOrIcon(HANDLE  hRes,
                       LPSTR   lpName,
                       WORD    type)
{
  HANDLE h;

    dprintf(7,"Helper_LoadCursorOrIcon");

  /* If we can't find the cursor/icon in the app, and this is a 2.x app, we
   * need to search into the display driver to find it.
   */
  h = UT_LoadCursorIconBitmap(hRes, lpName, type);
  return(h);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadCursor() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

HCURSOR API LoadCursor(hRes, lpName)

HANDLE  hRes;
LPSTR   lpName;

{
    HCURSOR hcur;

    dprintf(5,"LoadCursor");

    if (hRes == NULL) {
    dprintf(9,"    Calling Win32 to load Cursor");
        hcur = WOWLoadCursor32(hRes, lpName);
    } else {
        hcur = ((HCURSOR)Helper_LoadCursorOrIcon(hRes, lpName, (WORD)RT_CURSOR));
    }
#ifdef DEBUG
    if (hcur == NULL) {
    dprintf(9,"    Failed, BUT returning 1 so app won't die (yet)");
        return (HCURSOR)1;
    }
#endif

    dprintf(5,"LoadCursor returning %4.4XH", hcur);

    return hcur;
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadIcon() -                                */
/*                                      */
/*--------------------------------------------------------------------------*/

HICON API LoadIcon(hRes, lpName)

HANDLE hRes;
LPSTR  lpName;

{
    HICON hicon;

    dprintf(5,"LoadIcon");

    if (hRes == NULL) {
    dprintf(9,"    Calling Win32 to load Icon");
        hicon = WOWLoadIcon32(hRes, lpName);
    } else {
        hicon = ((HICON)Helper_LoadCursorOrIcon(hRes, lpName, (WORD)RT_ICON));
    }
#ifdef DEBUG
    if (hicon == NULL) {
    dprintf(9,"    Failed, BUT returning 1 so app won't die (yet)");
        return (HICON)1;
    }
#endif
    dprintf(5,"LoadIcon returning %4.4XH", hicon);

    return hicon;
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  StretchBitmap() -                               */
/*                                      */
/*  This routine stretches a bitmap into another bitmap,            */
/*   and returns the stretched bitmap.                          */
/*--------------------------------------------------------------------------*/

HBITMAP FAR  PASCAL StretchBitmap(iOWidth, iOHeight, iNWidth, iNHeight, hbmS,
               byPlanes, byBitsPixel)

int     iOWidth;
int iOHeight;
int iNWidth;
int iNHeight;
HBITMAP hbmS;
BYTE    byPlanes;
BYTE    byBitsPixel;

{
    register HBITMAP  hbmD;
    HBITMAP  hbmDSave;
    register HDC         hdcSrc;




    dprintf(7,"StretchBitmap");
      if ((hdcSrc = CreateCompatibleDC(hdcBits)) != NULL)
    {
      if ((hbmD = (HBITMAP)CreateBitmap(iNWidth, iNHeight, byPlanes, byBitsPixel, (LPINT)NULL)) == NULL)
          goto GiveUp;

      if ((hbmDSave = SelectObject(hdcBits, hbmD)) == NULL)
          goto GiveUp;

      if (SelectObject(hdcSrc, hbmS) != NULL)
        {
          /* NOTE: We don't have to save the bitmap returned from
           * SelectObject(hdcSrc) and select it back in to hdcSrc,
           * because we delete hdcSrc.
           */
          SetStretchBltMode(hdcBits, COLORONCOLOR);

          StretchBlt(hdcBits, 0, 0, iNWidth, iNHeight, hdcSrc, 0, 0, iOWidth, iOHeight, SRCCOPY);

          SelectObject(hdcBits, hbmDSave);

          DeleteDC(hdcSrc);

          return(hbmD);
        }
      else
        {
GiveUp:
          if (hbmD != NULL)
          DeleteObject(hbmD);
          DeleteDC(hdcSrc);
          goto Step1;
        }

    }
      else
    {
Step1:
      return(NULL);
    }
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadOldBitmap() -                               */
/*                                      */
/*   This loads bitmaps in old formats( Version 2.10 and below)         */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL LoadOldBitmap(HANDLE  hRes,
                 LPSTR   lpName)

{
  int          oWidth;
  int          oHeight;
  BYTE         planes;
  BYTE         bitsPixel;
  WORD         wCount;
  DWORD        dwCount;
  LPBITMAP     lpBitmap;
  register HBITMAP hbmS;
  HBITMAP      hbmD;
  register  HBITMAP   hBitmap;
  BOOL         fCrunch;
  WORD         wDevDep;

    dprintf(7,"LoadOldBitmap");

  if (hbmS = hBitmap = UT_LoadCursorIconBitmap(hRes, lpName, BMR_BITMAP))
    {
      lpBitmap = (LPBITMAP)LockResource(hBitmap);

      fCrunch = ((*(((BYTE FAR *)lpBitmap) + 1) & 0x0F) != BMR_DEVDEP);
      lpBitmap = (LPBITMAP)((BYTE FAR *)lpBitmap + 2);

      oWidth = lpBitmap->bmWidth;
      oHeight = lpBitmap->bmHeight;
      planes = lpBitmap->bmPlanes;
      bitsPixel = lpBitmap->bmBitsPixel;

      if (!(*(((BYTE FAR *)lpBitmap) + 1) & 0x80))
    {
      hbmS = CreateBitmap(oWidth, oHeight, planes, bitsPixel,
          (LPSTR)(lpBitmap + 1));
    }
      else
    {
      hbmS = (HBITMAP)CreateDiscardableBitmap(hdcBits, oWidth, oHeight);
      wCount = (((oWidth * bitsPixel + 0x0F) & ~0x0F) >> 3);
      dwCount = wCount * oHeight * planes;
      SetBitmapBits(hbmS, dwCount, (LPSTR)(lpBitmap + 1));
    }

      GlobalUnlock(hBitmap);
      FreeResource(hBitmap);

      if (hbmS != NULL)
    {
      if (fCrunch && ((64/oemInfo.cxIcon + 64/oemInfo.cyIcon) > 2))
        {
          /* Stretch the Bitmap to suit the device */
              hbmD = StretchBitmap(oWidth, oHeight,
               (oWidth * oemInfo.cxIcon/64),
               (oHeight * oemInfo.cyIcon/64),
               hbmS, planes, bitsPixel);

          /* Delete the old bitmap */
          DeleteObject(hbmS);

          if (hbmD == NULL)
        return(NULL);    /* Some problem in stretching */
          else
            return(hbmD);    /* Return the stretched bitmap */
        }
    }
    }
  else
    {
       return (HANDLE)0;
    }
  return(hbmS);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadBitmap() -                              */
/*                                      */
/*  This routine decides whether the bitmap to be loaded is in old or       */
/*  new (DIB) format and calls appropriate handlers.                */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE API LoadBitmap(hRes, lpName)

HANDLE hRes;
LPSTR  lpName;

{
    HANDLE hbmp;

    dprintf(5,"LoadBitmap");
    if (hRes == NULL) {
    dprintf(9,"    Calling Win32 to load Bitmap");
        hbmp = WOWLoadBitmap32(hRes, lpName);
    } else {

        /* Check if the resource is to be taken from the display driver.  If so,
         * check the driver version; If the resource is to be taken from the
         * application, check the app version
         */
        if (((hRes == NULL) && (oemInfo.DispDrvExpWinVer >= VER)) ||
        ((hRes != NULL) && (LOWORD(GetExpWinVer(hRes)) >= VER))) {
            hbmp = (LoadNewBitmap(hRes, lpName));
        } else {
            hbmp = (LoadOldBitmap(hRes, lpName));
        }
    }
#ifdef DEBUG
    if (hbmp == NULL) {
    dprintf(9,"    Failed, BUT returning 1 so app won't die (yet)");
        return (HANDLE)1;
    }
#endif
    dprintf(5,"LoadBitmap returning %4.4XH", hbmp);

    return hbmp;
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  CrunchAndResize()  -                            */
/*  This Crunches the monochrome icons and cursors if required and      */
/*      returns the newsize of the resource after crunching.            */
/*      This routine is also called to resize the monochrome AND mask of a  */
/*  color icon.                             */
/*  Parameters:                                 */
/*  lpIcon: Ptr to the resource                     */
/*  fIcon : TRUE, if the resource is an icon. FALSE, if it is a cursor. */
/*  fCrunch : TRUE if resource is to be resized.                    */
/*  fSinglePlane: TRUE if only AND mask of a color icon is passed       */
/*                    through lpIcon                            */
/*  fUseSysMetrics: Whether to use the icon/cursor values found in      */
/*              oemInfo or not.                         */
/*  Returns:                                    */
/*  The new size of the resource is returned.               */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL CrunchAndResize(lpIcon, fIcon, fCrunch, fSinglePlane, fUseSysMetrics)

LPCURSORSHAPE   lpIcon;
BOOL        fIcon;
BOOL        fCrunch;
BOOL        fSinglePlane;
BOOL        fUseSysMetrics;


{
  WORD      size;
  register int  cx;
  register int  cy;
  int       oHeight;
  int       nHeight;
  int       iNewcbWidth;
  BOOL      bStretch;
  HBITMAP   hbmS;
  HBITMAP   hbmD;

    dprintf(7,"CrunhAndResize");
  if(fUseSysMetrics)
    {
      if(fIcon)
        {
      cx = oemInfo.cxIcon;
      cy = oemInfo.cyIcon;
    }
      else
        {
      cx = oemInfo.cxCursor;
      cy = oemInfo.cyCursor;
    }
    }
  else
    {
      cx = lpIcon->cx;
      cy = lpIcon->cy;
    }

  if (fIcon)
    {
      lpIcon->xHotSpot = cx >> 1;
      lpIcon->yHotSpot = cy >> 1;
      if (fSinglePlane)
    {
      /* Only the AND mask exists */
      oHeight = lpIcon->cy;
      nHeight = cy;
    }
      else
    {
      /* Both AND ans XOR masks exist; So, height must be twice */
      oHeight = lpIcon->cy << 1;
      nHeight = cy << 1;
    }
    }
  else
    {
      oHeight = lpIcon->cy << 1;
      nHeight = cy << 1;
    }

  iNewcbWidth = ((cx + 0x0F) & ~0x0F) >> 3;
  size = iNewcbWidth * nHeight;

  if (fCrunch && ((lpIcon->cx != cx) || (lpIcon->cy != cy)))
    {
      if (!fIcon)
    {
      lpIcon->xHotSpot = (lpIcon->xHotSpot * cx)/(lpIcon->cx);
      lpIcon->yHotSpot = (lpIcon->yHotSpot * cy)/(lpIcon->cy);
    }

      /* To begin with, assume that no stretching is required */
      bStretch = FALSE;

      /* Check if the width is to be reduced */
      if (lpIcon->cx != cx)
    {
        /* Stretching the Width is necessary */
        bStretch = TRUE;
    }

      /* Check if the Height is to be reduced */
      if (lpIcon->cy != cy)
    {
          /* Stretching in Y direction is necessary */
          bStretch = TRUE;
    }

      /* Check if stretching is necessary */
      if (bStretch)
    {
      /* Create a monochrome bitmap with the icon/cursor bits */
      if ((hbmS = CreateBitmap(lpIcon->cx, oHeight, 1, 1, (LPSTR)(lpIcon + 1))) == NULL)
          return(NULL);

      if ((hbmD = StretchBitmap(lpIcon->cx, oHeight, cx, nHeight, hbmS, 1, 1)) == NULL)
        {
          DeleteObject(hbmS);
          return(NULL);
        }

      DeleteObject(hbmS);

      lpIcon->cx = cx;
      lpIcon->cy = cy;
      lpIcon->cbWidth = iNewcbWidth;

      GetBitmapBits(hbmD, (DWORD)size, (LPSTR)(lpIcon + 1));
      DeleteObject(hbmD);
    }
    }

  return(size + sizeof(CURSORSHAPE));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadCursorIconHandler() -                           */
/*                                      */
/*  This handles 2.x (and less) Cursors and Icons               */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadCursorIconHandler(hRes, hResFile, hResIndex)

register HANDLE hRes;
HANDLE      hResFile;
HANDLE      hResIndex;

{
  register int    fh        = 0;
  BOOL        bNew      = FALSE;
  WORD        wMemSize;
  LPCURSORSHAPE   lpIcon;
  HANDLE      hTempRes;

    dprintf(7,"LoadCursorIconHandler");
  wMemSize = SizeofResource(hResFile, hResIndex);

#if 1 // was 0 - NigelT
  if (!hRes)
    {
      if (!(hRes = AllocResource(hResFile, hResIndex, 0L)))
      return(NULL);
      fh = -1;
      bNew = TRUE;
    }

  while (!(lpIcon = (LPCURSORSHAPE)GlobalLock(hRes)))
    {
      if (!GlobalReAlloc(hRes, (DWORD)wMemSize, 0))
      goto LoadCIFail;
      else
      fh = -1;
    }

  if (fh)
    {
      fh = AccessResource(hResFile, hResIndex);
      if (fh != -1 && _lread(fh, (LPSTR)lpIcon, wMemSize) != 0xFFFF)
      _lclose(fh);
      else
    {
      if (fh != -1)
          _lclose(fh);
      GlobalUnlock(hRes);
      goto LoadCIFail;
    }

    }
#else
  /* Call kernel's resource handler instead of doing the stuff ourselves
   * because we use cached file handles that way. davidds
   */
  // For resources which are not preloaded, hRes will be NULL at this point.
  // For such cases, the default resource handler does the memory allocation
  // and returns a valid handle.
  // Fix for Bug #4257 -- 01/21/91 -- SANKAR
  if (!(hTempRes = lpDefaultResourceHandler(hRes, hResFile, hResIndex)))
      goto LoadCIFail;
  // We must use the handle returned by lpDefaultResourceHandler.
  hRes = hTempRes;

  lpIcon = (LPCURSORSHAPE)GlobalLock(hRes);
#endif

  if (LoadCursorIconHandler2(hRes, lpIcon, wMemSize))
      return(hRes);

LoadCIFail:
  /* If the loading of the resource fails, we MUST discard the memory we
   * reallocated above, or kernel will simply globallock the thing on the
   * next call to LockResource(), leaving invalid data in the object.
   */
  if (bNew)
      GlobalFree(hRes);
  else
      GlobalDiscard(hRes);

  return(NULL);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadCursorIconHandler2() -                          */
/*                                      */
/*  This handles all 2.x Cursors and Icons                  */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadCursorIconHandler2(hRes, lpIcon, wMemSize)

register HANDLE hRes;
LPCURSORSHAPE   lpIcon;
register WORD   wMemSize;

{
  BOOL      fCrunch;
  BOOL      fIcon;
  WORD      wNewSize;
  BOOL      fStretchInXdirection;
  BOOL      fStretchInYdirection;

    dprintf(7,"LoadCursorIconHandler2");
  fIcon = (*(LPSTR)lpIcon == BMR_ICON);

  /* Is this a device dependant icon/cursor?. */
  fCrunch = (*((LPSTR)lpIcon+1) != BMR_DEVDEP);

  LCopyStruct((LPSTR)lpIcon+2, (LPSTR)lpIcon, wMemSize-2);

  fCrunch = fCrunch || (lpIcon->cx != GetSystemMetrics(SM_CXICON)) ||
                   (lpIcon->cy != GetSystemMetrics(SM_CYICON));

  /* Only support monochrome cursors. */
  lpIcon->Planes = lpIcon->BitsPixel = 1;

  fStretchInXdirection = fStretchInYdirection = TRUE;  // Assume we need stretching.

  if(fIcon)
    {
      if((oemInfo.cxIcon > STD_ICONWIDTH) && (lpIcon->cx <= oemInfo.cxIcon))
      fStretchInXdirection = FALSE; // No Need to stretch in X direction;
      if((oemInfo.cyIcon > STD_ICONHEIGHT) && (lpIcon->cy <= oemInfo.cyIcon))
          fStretchInYdirection = FALSE; // No need to stretch in Y direction;
    }
  else
    {
      if((oemInfo.cxCursor > STD_CURSORWIDTH) && (lpIcon->cx <= oemInfo.cxCursor))
      fStretchInXdirection = FALSE; // No need to stretch in X direction.
      if((oemInfo.cyCursor > STD_CURSORHEIGHT) && (lpIcon->cy <= oemInfo.cyCursor))
      fStretchInYdirection = FALSE; // No need to stretch in Y direction.
    }

  // Check if the Icon/Cursor needs to be stretched now or not
  if(!(fStretchInXdirection || fStretchInYdirection))
    {
      GlobalUnlock(hRes);
      return(hRes);
    }
  wNewSize = SizeReqd(fIcon, 1, 1, TRUE, 0, 0);

  /* Before we crunch, let us make sure we have a big enough resource. */
  if (fCrunch)
    {
      if (wNewSize > wMemSize)
        {
      GlobalUnlock(hRes);

          /* Make this non discardable so that kernel will try to move this
       * block when reallocing.  DavidDS
       */
          GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_NODISCARD);

      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
            {
              /* So it gets discarded. Note that since the above realloc is
           * less than 64K, the handle won't change.
           */
              GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);
          return(NULL);
            }

          /* So it gets discarded */
          GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);

      if (!(lpIcon = (LPCURSORSHAPE)GlobalLock(hRes)))
          return(NULL);
      wMemSize = wNewSize;
        }
    }

  wNewSize = CrunchAndResize(lpIcon, fIcon, fCrunch, FALSE, TRUE);

  GlobalUnlock(hRes);

  /* Has it already been resized? */
  if (wNewSize < wMemSize)
    {
      /* Make it an exact fit. */
      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
          return(NULL);
    }

  return(hRes);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBCursorHandler() -                            */
/*                                      */
/*  This is called when a Cursor in DIB format is loaded            */
/*      This converts the cursor into Old format and returns the handle     */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadDIBCursorHandler(hRes, hResFile, hResIndex)

HANDLE  hRes;
HANDLE  hResFile;
HANDLE  hResIndex;

{
    dprintf(7,"LoadDIBCursorIconHandler");
  return(LoadDIBCursorIconHandler(hRes, hResFile, hResIndex, FALSE));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBIconHandler() -                          */
/*                                      */
/*  This is called when an Icon in DIB format is loaded         */
/*      This converts the cursor into Old format and returns the handle     */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadDIBIconHandler(hRes, hResFile, hResIndex)

HANDLE  hRes;
HANDLE  hResFile;
HANDLE  hResIndex;

{
    dprintf(7,"LoadDIBIconHandler");
  return(LoadDIBCursorIconHandler(hRes, hResFile, hResIndex, TRUE));
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  StretchIcon() -                                 */
/*  When this routine is called, lpIcon already has the monochrome      */
/*  AND bitmap properly sized. This routine adds the color XOR bitmap at    */
/*  end of lpIcon and updates the header with the values of the color       */
/*  info(bitcount and Planes);                          */
/*  wOldSize : Contains the size of AND mask + CURSORSHAPE          */
/*                                      */
/*   Returns:  The new size ( Size of AND mask + XOR bitmap + CURSORSHAPE)  */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL StretchIcon(lpIcon, wOldSize, hXORbitmap, fStretchToSysMetrics)

LPCURSORSHAPE       lpIcon;
WORD            wOldSize;
register HBITMAP    hXORbitmap;
BOOL            fStretchToSysMetrics;

{
  WORD          wCount;
  BITMAP        bitmap;
  register HBITMAP  hNewBitmap;

    dprintf(7,"StretchIcon");
  GetObject(hXORbitmap, sizeof(BITMAP), (LPSTR)&bitmap);

  if(fStretchToSysMetrics)
    {
      /* Do we need to resize things? */
      if ((oemInfo.cxIcon != bitmap.bmWidth) || (oemInfo.cyIcon != bitmap.bmHeight))
    {
          hNewBitmap = StretchBitmap(bitmap.bmWidth, bitmap.bmHeight,
                 oemInfo.cxIcon, oemInfo.cyIcon, hXORbitmap,
                 bitmap.bmPlanes, bitmap.bmBitsPixel);
          DeleteObject(hXORbitmap);

          if (hNewBitmap == NULL)
          return(0);

          GetObject(hNewBitmap, sizeof(BITMAP), (LPSTR)&bitmap);
          hXORbitmap = hNewBitmap;
        }
    }

  /* Update the Planes and BitsPixels field with the color values */
  lpIcon->Planes = bitmap.bmPlanes;
  lpIcon->BitsPixel = bitmap.bmBitsPixel;

  wCount = bitmap.bmWidthBytes * bitmap.bmHeight * bitmap.bmPlanes;
  GetBitmapBits(hXORbitmap, (DWORD)wCount, (LPSTR)((LPSTR)lpIcon + wOldSize));
  DeleteObject(hXORbitmap);

  return(wCount + wOldSize);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBCursorIconHandler() -                        */
/*                                      */
/*  This is called when a Cursor/Icon in DIB format is loaded       */
/*      This converts the cursor/icon internal format and returns the       */
/*      handle                                  */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE NEAR PASCAL LoadDIBCursorIconHandler(hRes, hResFile, hResIndex, fIcon)

register HANDLE hRes;
HANDLE      hResFile;
HANDLE      hResIndex;
BOOL        fIcon;

{
  register int  fh  = 0;
  BOOL      bNew    = FALSE;
  WORD      wMemBlkSize;
  LPCURSORSHAPE lpCurSh;
  HANDLE    hTempRes;

    dprintf(7,"LoadDIBCursorIconHandler");
  wMemBlkSize = (WORD)SizeofResource(hResFile, hResIndex);

#if 1 // was 0 - NigelT
  if (!hRes)
    {
      if (!(hRes = AllocResource(hResFile, hResIndex, 0L)))
      goto LoadDIBFail;
      fh = -1;
      bNew = TRUE;
    }

  while (!(lpCurSh = (LPCURSORSHAPE)GlobalLock(hRes)))
    {
      if (!GlobalReAlloc(hRes, (DWORD)wMemBlkSize, 0))
      goto LoadDIBFail;
      else
      fh = -1;
    }

  if (fh)
    {
      fh = AccessResource(hResFile, hResIndex);
      if (fh != -1 && _lread(fh, (LPSTR)lpCurSh, wMemBlkSize) != 0xFFFF)
      _lclose(fh);
      else
    {
      if (fh != -1)
          _lclose(fh);
      GlobalUnlock(hRes);
      goto LoadDIBFail;
    }
    }
#else
  /* Call kernel's resource handler instead of doing the stuff ourselves
   * because we use cached file handles that way. davidds
   */
  // For resources which are not preloaded, hRes will be NULL at this point.
  // For such cases, the default resource handler does the memory allocation
  // and returns a valid handle.
  // Fix for Bug #4257 -- 01/21/91 -- SANKAR
  if (!(hTempRes = lpDefaultResourceHandler(hRes, hResFile, hResIndex)))
      goto LoadDIBFail;
  // We must use the handle returned by lpDefaultResourceHandler.
  hRes = hTempRes;

  lpCurSh = (LPCURSORSHAPE)GlobalLock(hRes);
#endif

  if (LoadDIBCursorIconHandler2(hRes, lpCurSh, wMemBlkSize, fIcon))
      return(hRes);

LoadDIBFail:
  /* if the loading of the resource fails, we MUST discard the memory we
   * reallocated above, or kernel will simply globallock the thing on the
   * next call to LockResource(), leaving invalid data in the object.
   */
  if (bNew)
      FreeResource(hRes);
  else
      GlobalDiscard(hRes);

  return(NULL);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  LoadDIBCursorIconHandler2() -                       */
/*                                      */
/*  This is called when a Cursor/Icon in DIB format is loaded       */
/*      This converts the cursor/icon into Old format and returns the       */
/*      handle                                  */
/*                                      */
/*  NOTE:  All cursors(always monochrome) and Monochrome Icons are treated  */
/*     alike by this routine. Color Icons are treated as special case   */
/*     determined by the local flag "fMono".                */
/*                                      */
/*--------------------------------------------------------------------------*/

HANDLE FAR PASCAL LoadDIBCursorIconHandler2(hRes, lpCurSh, wMemBlkSize, fIcon)

register HANDLE hRes;
WORD        wMemBlkSize;
LPCURSORSHAPE   lpCurSh;
register BOOL   fIcon;

{
  HDC           hDC;
  BOOL          fMono       = FALSE;
  WORD          Width;
  WORD          Height;
  WORD          wCount;
  WORD          BitCount;
  WORD          Planes;
  LPSTR         lpBits;
  BITMAP        bitmap;
  HBITMAP       hBitmap;
  WORD          wNewSize;
  HBITMAP       hANDbitmap;
  HBITMAP       hXORbitmap;
  LPWORD        lpColorTable;
  LPBITMAPINFOHEADER    lpHeader;
  LPBITMAPCOREHEADER    lpHeader1   = 0;
  BOOL          fStretchToSysMetrics;
  BOOL          fStretchInXdirection;
  BOOL          fStretchInYdirection;


    dprintf(7,"LoadDIBCursorIconHandler2");
  lpHeader = (LPBITMAPINFOHEADER)lpCurSh;

  if (!fIcon)
    {
      /* Skip over the cursor hotspot data in the first 2 words. */
      lpHeader = (LPBITMAPINFOHEADER)((LPSTR)lpHeader + 4);
    }

  if ((WORD)lpHeader->biSize == sizeof(BITMAPCOREHEADER))
    {
      /* This is an "old form" DIB.  This matches the PM 1.1 format. */
      lpHeader1 = (LPBITMAPCOREHEADER)lpHeader;

      Width = lpHeader1->bcWidth;
      Height = lpHeader1->bcHeight;
      BitCount = lpHeader1->bcBitCount;
      Planes = lpHeader1->bcPlanes;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpColorTable = (LPWORD)(lpBits = (LPSTR)(lpHeader1 + 1));

      /* Skip the color table entries, if any */
      if (lpHeader1->bcBitCount != 24)
    {
      if (lpHeader1->bcBitCount == 1)
          fMono = fCheckMono(lpBits, FALSE);
      lpBits += (1 << (lpHeader1->bcBitCount)) * sizeof(RGBTRIPLE);
    }
    }
  else
    {
      Width = (WORD)lpHeader->biWidth;
      Height = (WORD)lpHeader->biHeight;
      BitCount = lpHeader->biBitCount;
      Planes = lpHeader->biPlanes;

      /* Calcluate the pointer to the Bits information */
      /* First skip over the header structure */
      lpColorTable = (LPWORD)(lpBits = (LPSTR)(lpHeader + 1));

      /* Skip the color table entries, if any */
      if (lpHeader->biClrUsed != 0)
    {
      if (lpHeader->biClrUsed == 2)
          fMono = fCheckMono(lpBits, TRUE);
      lpBits += lpHeader->biClrUsed * sizeof(RGBQUAD);
    }
      else
    {
      if (lpHeader->biBitCount != 24)
        {
          if (lpHeader->biBitCount == 1)
          fMono = fCheckMono(lpBits, TRUE);
          lpBits += (1 << (lpHeader->biBitCount)) * sizeof(RGBQUAD);
        }
    }
    }

  // By default Stretch the icon/cursor to the dimensions in oemInfo;
  // If this is FALSE, then the stretching will take place during DrawIcon();
  fStretchInXdirection = TRUE;
  fStretchInYdirection = TRUE;

  // Check if the Icon/Cursor needs to be stretched to the dimensions in
  // oemInfo now or not.
  if(fIcon)
    {
      if((oemInfo.cxIcon > STD_ICONWIDTH) && (Width <= oemInfo.cxIcon))
      fStretchInXdirection = FALSE; // No Need to stretch in X direction;
      if((oemInfo.cyIcon > STD_ICONHEIGHT) && (Height <= oemInfo.cyIcon))
          fStretchInYdirection = FALSE; // No need to stretch in Y direction;
    }
  else
    {
      if((oemInfo.cxCursor > STD_CURSORWIDTH) && (Width <= oemInfo.cxCursor))
      fStretchInXdirection = FALSE; // No need to stretch in X direction.
      if((oemInfo.cyCursor > STD_CURSORHEIGHT) && (Height <= oemInfo.cyCursor))
      fStretchInYdirection = FALSE; // No need to stretch in Y direction.
    }

  fStretchToSysMetrics = fStretchInXdirection || fStretchInYdirection;

  if (fMono)
    {
      /* Create a bitmap */
      if (!(hBitmap = CreateBitmap(Width, Height, 1, 1, (LPSTR)NULL)))
    {
      GlobalUnlock(hRes);
      return(NULL);
    }

      /* Convert the DIBitmap format into internal format */
      SetDIBits(hdcBits, hBitmap, 0, Height, lpBits, (LPBITMAPINFO)lpHeader, DIB_RGB_COLORS);
      // Cursors/Icons in DIB format have a height twice the actual height.
      wNewSize = SizeReqd(fIcon, BitCount, Planes, fStretchToSysMetrics, Width, Height>>1);
    }
  else
    {
      /* The height is twice that of icons */
      Height >>= 1;
      if (lpHeader1)
      lpHeader1->bcHeight = Height;
      else
      lpHeader->biHeight = Height;

      /* Create the XOR bitmap Compatible with the current device */
      hDC = GetScreenDC();
      if (!(hXORbitmap = CreateCompatibleBitmap(hDC, Width, Height)))
    {
          InternalReleaseDC(hDC);
      GlobalUnlock(hRes);
      return(NULL);
    }
      InternalReleaseDC(hDC);

      /* Convert the DIBitmap into internal format */
      SetDIBits(hdcBits, hXORbitmap, 0, Height, lpBits,
                (LPBITMAPINFO)lpHeader, DIB_RGB_COLORS);

      GetObject(hXORbitmap, sizeof(BITMAP), (LPSTR)(&bitmap));
      wNewSize = SizeReqd(fIcon, bitmap.bmBitsPixel, bitmap.bmPlanes,
                  fStretchToSysMetrics, Width, Height);

      /* Create the monochrome AND bitmap */
      if (!(hANDbitmap = CreateBitmap(Width, Height, 1, 1, (LPSTR)NULL)))
    {
      GlobalUnlock(hRes);
      return(NULL);
    }

      /* Get the offset to the AND bitmap */
      lpBits += (((Width * BitCount + 0x1F) & ~0x1F) >> 3) * Height;

      /* Set the header with data for a monochrome bitmap */
      Planes = BitCount = 1;

      /* Set the color table for a monochrome bitmap */
      *lpColorTable++ = 0;
      *lpColorTable++ = 0xFF00;
      *lpColorTable   = 0xFFFF;

      if (lpHeader1)
    {
      lpHeader1->bcWidth = Width;
      lpHeader1->bcHeight = Height;
      lpHeader1->bcPlanes = Planes;
      lpHeader1->bcBitCount = BitCount;
    }
      else
    {
      lpHeader->biWidth = Width;
      lpHeader->biHeight = Height;
      lpHeader->biPlanes = Planes;
      lpHeader->biBitCount = BitCount;
    }

      SetDIBits(hdcBits, hANDbitmap, 0, Height, lpBits,
                (LPBITMAPINFO)lpHeader, DIB_RGB_COLORS);
      hBitmap = hANDbitmap;
    }

  GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bitmap);

  if (fIcon)
    {
      lpCurSh->xHotSpot = 0;
      lpCurSh->yHotSpot = 0;
    }

  /* The following lines are replaced by a single functon call
   *
   * lpCurSh->cx = bitmap.bmwidth;
   * lpCurSh->cy = bitmap.bmHeight;
   * lpCurSh->cbWidth = bitmap.bmWidthBytes;
   * lpCurSh->Planes = bitmap.bmPlanes;
   * lpCurSh->BitsPixel = bitmap.bmBitsPixel;
   */

  LCopyStruct((LPSTR)&(bitmap.bmWidth),
              (LPSTR)&(lpCurSh->cx), (sizeof(WORD)) << 2);

  /* Cursors in PM format have twice the actual height. */
  if (fMono)
      lpCurSh->cy = lpCurSh->cy >> 1;

  wCount = bitmap.bmWidthBytes * bitmap.bmHeight * bitmap.bmPlanes;

  lpBits = (LPSTR)(lpCurSh + 1);

  /* Copy the bits in Bitmap into the resource */
  GetBitmapBits(hBitmap, (DWORD)wCount, lpBits);

  /* Delete the bitmap */
  DeleteObject(hBitmap);


  /* Before crunching, let us make sure we have a big enough resource */
  if (wNewSize > wMemBlkSize)
    {
      GlobalUnlock(hRes);

      /* Make this non discardable so that kernel will try to move this block
       * when reallocing.  DavidDS
       */
      GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_NODISCARD);

      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
        {
          /* So it gets discarded. Note that since the above realloc is less
       * than 64K, the handle won't change.
       */
          GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);
      return(NULL);
        }

      GlobalReAlloc(hRes, 0L, GMEM_MODIFY | GMEM_DISCARDABLE);
      if (!(lpCurSh = (LPCURSORSHAPE)GlobalLock(hRes)))
      return(NULL);

      wMemBlkSize = wNewSize;
    }

  wNewSize = CrunchAndResize(lpCurSh, fIcon, TRUE, !fMono, fStretchToSysMetrics);

  if (!fMono)
    {
      if (!(wNewSize = StretchIcon(lpCurSh, wNewSize, hXORbitmap, fStretchToSysMetrics)))
    {
      GlobalUnlock(hRes);
      return(NULL);
    }
    }

  GlobalUnlock(hRes);

  /* Does it need to be resized? */
  if (wNewSize < wMemBlkSize)
    {
      if (!GlobalReAlloc(hRes, (DWORD)wNewSize, 0))
      return(NULL);
    }

  return(hRes);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  SizeReqd() -                                */
/*  This returns the size of an Icon or Cursor after it is stretched    */
/*  or crunched                                 */
/*                                      */
/*--------------------------------------------------------------------------*/

WORD NEAR PASCAL SizeReqd(fIcon, BitCount, Planes, fUseSysMetrics, iWidth, iHeight)

BOOL    fIcon;
WORD    BitCount;
WORD    Planes;
BOOL    fUseSysMetrics;
int iWidth;
int iHeight;

{
  WORD  size;

    dprintf(7,"SizeReqd");
  if(fUseSysMetrics)  //Use the dimensions in oemInfo; Else, use given dimensions
    {
      if(fIcon)
        {
          iWidth = oemInfo.cxIcon;
          iHeight = oemInfo.cyIcon;
    }
      else
        {
          iWidth = oemInfo.cxCursor;
          iHeight = oemInfo.cyCursor;
    }
    }

  size = (((iWidth*BitCount+0x0F) & ~0x0F) >> 3) *
             iHeight * Planes;

  if ((BitCount == 1) && (Planes == 1))
      size <<= 1;
  else
      size += (((iWidth+0x0F) & ~0x0F) >> 3)*iHeight;

  return(size + sizeof(CURSORSHAPE));
}

#endif  // NEEDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user1a.asm ===
;
;   USER1A.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER.ASM 9-Jun-92 by BobDay
;
;--

    TITLE   USER1A.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    GetModuleHandle
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

    UserThunk   DELETEMENU
    UserThunk   DESKTOPWNDPROC
    DUserThunk  DESTROYCARET,0
    UserThunk   DESTROYCURSOR
    UserThunk   DESTROYICON
    UserThunk   DESTROYMENU
    UserThunk   DESTROYWINDOW
;   UserThunk   DIALOGBOX                    ; defined in fastres.c
;   UserThunk   DIALOGBOXINDIRECT
;   UserThunk   DIALOGBOXINDIRECTPARAM

FUN_WOWDIALOGBOXPARAM EQU FUN_DIALOGBOXPARAM
    DUserThunk	WOWDIALOGBOXPARAM, %(size DIALOGBOXPARAM16)

    DUserThunk  DISABLEOEMLAYER
    UserThunk   DISPATCHMESSAGE
    UserThunk   DLGDIRLIST
    UserThunk   DLGDIRLISTCOMBOBOX
    UserThunk   DLGDIRSELECT
    UserThunk   DLGDIRSELECTCOMBOBOX
    UserThunk   DRAGDETECT
    UserThunk   DRAGOBJECT
    UserThunk   DRAWFOCUSRECT
    UserThunk   DRAWICON
    UserThunk   DRAWMENUBAR
        UserThunk   DRAWTEXT
;   DUserThunk  DUMPICON            ; LOCALAPI in rmload.c
;   UserThunk   EDITWNDPROC         ; LOCALAPI in wsubcls.c
    DUserThunk  EMPTYCLIPBOARD,0
    DUserThunk  ENABLEHARDWAREINPUT
    DUserThunk  ENABLEOEMLAYER
    UserThunk   ENABLEWINDOW
    UserThunk   ENDDEFERWINDOWPOS
    UserThunk   ENDDIALOG
    DUserThunk  ENDMENU
    UserThunk   ENDPAINT
    UserThunk   ENUMCHILDWINDOWS
    DUserThunk  ENUMCLIPBOARDFORMATS
    UserThunk   ENUMPROPS
    UserThunk   ENUMTASKWINDOWS
    UserThunk   ENUMWINDOWS
;;;    UserThunk   EQUALRECT	   ; LOCALAPI in winrect.asm
    UserThunk   ESCAPECOMMFUNCTION
    UserThunk   EXCLUDEUPDATERGN
    DUserThunk  EXITWINDOWS


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user.inc ===
;****************************************************************************
;*									    *
;*  USER.INC -								    *
;*									    *
;*	User Data Structures and Defines				    *
;*									    *
;****************************************************************************
;
; Conditional include #defines:
;
; LAYER_INCLUDE - Just define POINT, RECT, WND, and CLS structs, plus ICLS_*
; NOTEXT	- Blow off TEXTMETRICS and some other stuff
;

ifdef WOW
NOTEXT equ 1
endif

.286P

ifndef LAYER_INCLUDE

?DF=1		; Don't define _TEXT or _DATA
?WIN=0		; turn off Windows support (no default preserve DS in far calls)
include cmacros.inc
include vint.inc

createSeg _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp DGROUP,DATA

;createSeg _TEXT,TEXT,WORD,PUBLIC,CODE,IGROUP

createSeg _GPFIX0,GPFIX0,WORD,PUBLIC,CODE,IGROUP  ; GP fault trapping
createSeg _GPFIX, GPFIX, WORD,PUBLIC,CODE,IGROUP
createSeg _GPFIX1,GPFIX1,WORD,PUBLIC,CODE,IGROUP

;defGrp	IGROUP,TEXT

endif




include gpfix.inc	    ; GP fault handler stuff

VER20		    equ 0201h
VER300		    equ 0300h
VER310		    equ 0310h

FALSE		    equ 0
TRUE		    equ 1
NULL		    equ 0

; Debug fill constants

DBGFILL_ALLOC   equ     0fdh
DBGFILL_FREE    equ     0fbh
DBGFILL_BUFFER  equ     0f9h
DBGFILL_STACK   equ     0f7h

;*--------------------------------------------------------------------------*
;*									    *
;*  Window and internal class structures
;*									    *
;*--------------------------------------------------------------------------*

;
; POINT Structure
;
POINT   struc
    ptX 	dw ?
    ptY 	dw ?
POINT   ends

;
; RECT Structure
;
RECT    struc
    rcLeft	dw ?
    rcTop	dw ?
    rcRight	dw ?
    rcBottom	dw ?
RECT    ends

ifdef WOW
;
; RECTL Structure
;
RECTL    struc
    rclLeft	dd ?
    rclTop	dd ?
    rclRight	dd ?
    rclBottom	dd ?
RECTL    ends
endif

ifndef WOW
ifdef WORDEXSTYLE
WND	struc
    wndHwndNext     dw ?
    wndHwndChild    dw ?
    wndPwndParent   dw ?
    wndHwndOwner    dw ?
    wndRcWindow     db size RECT dup(?)
    wndRcClient     db size RECT dup(?)
    wndHq	    dw ?
    wndHRgnUpdate   dw ?
    wndPcls	    dw ?
    wndHInstance    dw ?
    wndLpfnWndProc  dd ?
    wndState	    dd ?
    wndStyle	    dd ?
    wndDwExStyle    dw ?
    wndHMenu	    dw ?
    wndHName	    dw ?
    wndRgwScroll    dw ?
    wndPproptab     dw ?
    wndHwndLastActive dw ?
    wndHSysMenu     dw ?
WND	ends

else

WND	struc
    wndHwndNext     dw ?
    wndHwndChild    dw ?
    wndPwndParent   dw ?
    wndHwndOwner    dw ?
    wndRcWindow     db size RECT dup(?)
    wndRcClient     db size RECT dup(?)
    wndHq	    dw ?
    wndHRgnUpdate   dw ?
    wndPcls	    dw ?
    wndHInstance    dw ?
    wndLpfnWndProc  dd ?
    wndState	    dd ?
    wndStyle	    dd ?
    wndDwExStyle    dd ?
    wndHMenu	    dw ?
    wndHName	    dw ?
    wndRgwScroll    dw ?
    wndPproptab     dw ?
    wndHwndLastActive dw ?
    wndHSysMenu     dw ?
WND	ends

endif   ; WORDEXSTYLE


;
; Internal window class structure
;
CLS	struc
    uclspclsNext	dw ?
    uclsMagic		dw ?
    uclsatomClassName	dw ?
    uclshdc		dw ?
    uclscWndReferenceCount  dw ?  ; Number of windows registered with this
				  ; Class

; NOTE: the remaining fields are in the same order as in the WNDCLASS struct

    uclsstyle		dw ?	; Class style
    uclslpfnWndProc	dd ?
    uclscbclsExtra	dw ?
    uclscbwndExtra	dw ?
    uclshModule 	dw ?	; Module handle
    uclshIcon		dw ?	; Class icon handle
    uclshCursor 	dw ?	; Class cursor handle
    uclshbrBackground	dw ?	; Class background brush
    uclslpszMenuName	dd ?	; Menu name
    uclslpszClassName	dd ?	; Far ptr to class name
CLS	ends

CLS_MAGIC   equ ('N' or ('K' * 256))

; System class ID constants
;
; See comments in USER.H
;
ICLS_BUTTON	    equ 0
ICLS_EDIT	    equ 1
ICLS_STATIC	    equ 2
ICLS_LISTBOX	    equ 3
ICLS_SCROLLBAR	    equ 4
ICLS_COMBOBOX	    equ 5	; End of special dlgmgr indices

ICLS_CTL_MAX	    equ 6	; Number of public control classes

ICLS_DESKTOP	    equ 6
ICLS_DIALOG	    equ 7
ICLS_MENU	    equ 8
ICLS_SWITCH	    equ 9
ICLS_ICONTITLE	    equ 10
ICLS_MDICLIENT	    equ 11
ICLS_COMBOLISTBOX   equ 12

ICLS_MAX	    equ 13	; Number of system classes
endif   ; !WOW

;
; SetWindowPos() SMWP structure header
;
SMWP struc
    SmwpCcvr        dw  ?
    SmwpCcvrAlloc   dw  ?
    SmwpFInUse      dw  ?
    SmwpSignature   dw  ?
;   SmwpRgcvr       db  1
SMWP ends

SMWP_SIG    equ     ('W' or ('P' * 256))

ifndef LAYER_INCLUDE	   ; If not included from layer.asm...

;
; Substitute API names with "I" internal names if RETAIL
;
ifndef DEBUG
include iuser.inc
endif

ifndef WOW
; Internal window class names
;
MENUCLASS       equ     8000h
DESKTOPCLASS    equ     8001h
DIALOGCLASS     equ     8002h
SWITCHWNDCLASS  equ     8003h
ICONTITLECLASS  equ     8004h

;
; Window flag Test, Set, and Clear macros
;
TSTWF	macro pwnd, flag
	LOCAL wlow, whigh
	wlow  = LOW flag
	whigh = HIGH flag
	test	byte ptr [pwnd+wndState+whigh], wlow
	endm

SETWF	macro pwnd, flag
	LOCAL wlow, whigh
	wlow  = LOW flag
	whigh = HIGH flag
	or	byte ptr [pwnd+wndState+whigh], wlow
	endm

CLRWF	macro pwnd, flag
	LOCAL nwlow, whigh
	nwlow = NOT(LOW flag)
	whigh = HIGH flag
	and	byte ptr [pwnd+wndState+whigh], nwlow
	endm

;
; Window Flags
;
; hwnd->state flags (offset 0, 1, 2, 3)
;
WFMPRESENT	    equ 0001h
WFVPRESENT	    equ 0002h
WFHPRESENT	    equ 0004h
WFCPRESENT	    equ 0008h
WFSENDSIZEMOVE	    equ 0010h
WFNOPAINT	    equ 0020h
WFFRAMEON	    equ 0040h
WFHASSPB	    equ 0080h
WFNONCPAINT	    equ 0101h
WFSENDERASEBKGND    equ 0102h
WFERASEBKGND	    equ 0104h
WFSENDNCPAINT	    equ 0108h
WFINTERNALPAINT     equ 0110h	     ; Internal paint required flag
WFUPDATEDIRTY	    equ 0120h
WFHIDDENPOPUP	    equ 0140h
WFMENUDRAW	    equ 0180h

WFHASPALETTE	    equ 0201h
WFPAINTNOTPROCESSED equ 0202h
WFWIN31COMPAT	    equ 0204h
WFALWAYSSENDNCPAINT equ 0208h
WFPIXIEHACK         equ 0210h
WFTOGGLETOPMOST     equ 0220h
;
; hwnd->style style bits (offsets 4, 5, 6, 7)
;
WFTYPEMASK	    equ 07C0h
WFTILED 	    equ 0700h
WFICONICPOPUP	    equ 07C0h
WFPOPUP 	    equ 0780h
WFCHILD 	    equ 0740h
WFMINIMIZED	    equ 0720h
WFVISIBLE	    equ 0710h
WFDISABLED	    equ 0708h
WFDISABLE	    equ WFDISABLED
WFCLIPSIBLINGS	    equ 0704h
WFCLIPCHILDREN	    equ 0702h
WFMAXIMIZED	    equ 0701h
WFICONIC	    equ WFMINIMIZED

WFMINBOX	    equ 0602h
WFMAXBOX	    equ 0601h

WFBORDERMASK	    equ 06C0h
WFBORDER	    equ 0680h
WFCAPTION	    equ 06C0h
WFDLGFRAME	    equ 0640h
WFTOPLEVEL	    equ 0640h

WFVSCROLL	    equ 0620h
WFHSCROLL	    equ 0610h
WFSYSMENU	    equ 0608h
WFSIZEBOX	    equ 0604h
WFGROUP 	    equ 0602h
WFTABSTOP	    equ 0601h

; If this dlg bit is set, WM_ENTERIDLE message will not be sent
WFNOIDLEMSG	    equ 0501h
;
; hwnd->dwExStyle extended style bits (offsets 8, 9)
;
WEFDLGMODALFRAME    equ 0801h
WEFDRAGOBJECT	    equ 0802h
WEFNOPARENTNOTIFY   equ 0804h
WEFTOPMOST	    equ 0808h
WEFACCEPTFILES	    equ 0810h
WEFTRANSPARENT	    equ 0820h	     ; "Transparent" child window

; Class styles
;
CFVREDRAW	    equ 0001h
CFHREDRAW	    equ 0002h
CFKANJIWINDOW	    equ 0004h
CFDBLCLKS	    equ 0008h
CFOEMCHARS	    equ 0010h
CFOWNDC 	    equ 0020h
CFCLASSDC	    equ 0040h
CFPARENTDC	    equ 0080h
CFNOKEYCVT	    equ 0101h
CFNOCLOSE	    equ 0102h
CFLVB		    equ 0104h
CFCLSDC 	    equ CFCLASSDC
CFSAVEBITS	    equ 0108h
CFSAVEPOPUPBITS     equ CFSAVEBITS
CFBYTEALIGNCLIENT   equ 0110h
CFBYTEALIGNWINDOW   equ 0120h

ST_CLASS	equ	1
ST_WND		equ 	2
ST_STRING	equ	3
ST_MENU		equ	4
ST_CLIP		equ	5
ST_CBOX		equ	6
ST_PALETTE	equ	7
ST_ED		equ	8
ST_BWL		equ	9
ST_OWNERDRAWMENU equ	10
ST_SPB		equ	11
ST_CHECKPOINT	equ	12
ST_DCE		equ	13
ST_MWP		equ	14
ST_PROP		equ	15
ST_LBIV		equ	16
ST_MISC		equ	17
ST_ATOMS	equ	18
ST_LOCKINPUTSTATE equ   19
ST_HOOKNODE	equ	20
ST_USERSEEUSERDOALLOC   equ 21
ST_HOTKEYLIST   equ     22
ST_POPUPMENU    equ     23
ST_HANDLETABLE  equ	32
ST_FREE		equ	0ffh
endif   ; !WOW

ifdef DEBUG
ifndef winmisc1
LocalAlloc	equ	<UserLocalAlloc>
LocalFree	equ	<UserLocalFree>
LocalLock	equ	<UserLocalLock>
LocalUnlock	equ	<UserLocalUnlock>
LocalReAlloc	equ	<UserLocalReAlloc>
LocalSize	equ	<UserLocalSize>

TAGSIZE         equ     4                  ; Size of a tag in debug USER
endif
endif

; The following is required to special-case the SetWindowWord(., GCW_HMODULE);
GCW_HMODULE       =  (-16)

; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.

ifndef NOTEXT
;
; TEXTMETRIC Structure
;
TEXTMETRIC struc
    tmHeight		dw ?
    tmAscent		dw ?
    tmDescent		dw ?
    tmInternalLeading	dw ?
    tmExternalLeading	dw ?
    tmAveCharWidth	dw ?
    tmMaxCharWidth	dw ?
    tmWeight		dw ?
    tmItalic		db ?
    tmUnderlined	db ?
    tmStruckOut 	db ?
    tmFirstChar 	db ?
    tmLastChar		db ?
    tmDefaultChar	db ?
    tmBreakChar 	db ?
    tmPitch		db ?
    tmOverhang		dw ?
    tmDigitizedAspectX	dw ?
    tmDigitizedAspectY	dw ?
    tmCharSet		db ?
TEXTMETRIC ends

;
; Text Drawing modes
;
TRANSPARENT	    equ 1
OPAQUE		    equ 2

;
; Stock Logical Objects
;
WHITE_BRUSH	    equ  0
LTGRAY_BRUSH	    equ  1
GRAY_BRUSH	    equ  2
DKGRAY_BRUSH	    equ  3
BLACK_BRUSH	    equ  4
HOLLOW_BRUSH	    equ  5
WHITE_PEN	    equ  6
BLACK_PEN	    equ  7
NULL_PEN	    equ  8
DOT_MARKER	    equ  9
OEM_FIXED_FONT	    equ 10
ANSI_FIXED_FONT     equ 11
ANSI_VAR_FONT	    equ 12

endif	; NOTEXT


ANSI_CHARSET	    equ 0
OEM_CHARSET	    equ 255

ifndef WOW
;
; Styles for CombineRgn
;
RGN_AND 	    equ 1
RGN_OR		    equ 2
RGN_XOR 	    equ 3
RGN_DIFF	    equ 4
RGN_COPY	    equ 5

;
; Predefined cursor & icon IDs
;
IDC_ARROW	    equ 1
IDC_IBEAM	    equ 2
IDC_WAIT	    equ 3
IDC_UPARROW	    equ 8
IDC_SIZE	    equ 9
IDC_ICON	    equ 10

IDI_APPLICATION     equ 1
IDI_NOTE	    equ 2
IDI_ERROR           equ 3
endif ; !WOW

;
; Memory manager flags
;
LMEM_FIXED	    equ 0000h
LMEM_MOVEABLE	    equ 0002h
LMEM_ZEROINIT	    equ 0040h
LMEM_DISCARDABLE    equ 0F00h
LHND		    equ LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR		    equ LMEM_FIXED+LMEM_ZEROINIT

GMEM_FIXED	    equ 0000h
GMEM_MOVEABLE	    equ 0002h
GMEM_ZEROINIT	    equ 0040h
GMEM_SHAREALL	    equ 2000h
GMEM_LOWER	    equ 1000h
GMEM_DISCARDABLE    equ 0F00h
GHND		    equ GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR		    equ GMEM_FIXED+GMEM_ZEROINIT


ifndef WOW
;*--------------------------------------------------------------------------*
;*									    *
;*  Miscellaneous structures & constants				    *
;*									    *
;*--------------------------------------------------------------------------*

BITMAP struc
    bmType	    dw ?
    bmWidth	    dw ?
    bmHeight	    dw ?
    bmWidthBytes    dw ?
    bmPlanes	    db ?
    bmBitsPixel     db ?
    bmBits	    dq ?
BITMAP ends

PAINTSTRUCT struc
    PShdc	    dw ?
    PSfErase	    dw ?
    PSrcPaint	    db size RECT dup(?)
    PSfRestore	    dw ?
    PSfIncUpdate    dw ?
    PSrgbReserved   db 16 dup(?)
PAINTSTRUCT ends

;
; Message structure
;
MSGSTRUCT struc
    msHWND	    dw ?
    msMESSAGE	    dw ?
    msWPARAM	    dw ?
    msLPARAM	    dd ?
    msTIME	    dd ?
    msPT	    dd ?
MSGSTRUCT ends

NEWPARMS struc
    nprmHwnd	    dw ?
    nprmCmd	    db ?
NEWPARMS ends

;
;  CreateStruct   structure
;
;  Note: This is used in WinUtil.ASM
;  Modify this definition when this struct is modified in WINDOWS.H
;

CREATESTRUCT   struc
    csLPCreateParams	dd  ?
    csHInstance		dw  ?
    csHMenu		dw  ?
    csHwndParent	dw  ?
    csCY		dw  ?
    csCX		dw  ?
    csY			dw  ?
    csX			dw  ?
    csStyle		dd  ?
    csLPszName		dd  ?
    csLPszClass		dd  ?
    csExStyle		dd  ?
CREATESTRUCT   ends

;
; ShowWindow commands
;
HIDE_WINDOW	equ 0
SHOW_OPENWINDOW equ 1
SHOW_ICONWINDOW equ 2

;
; PostError constants
;
WARNING 	equ 0		; command codes
MINOR_ERROR	equ 1
FATAL_ERROR	equ 2

IGNORE		equ 0		; response codes
RETRY		equ 1
ABORT		equ 2

;
; GDI-related constants & commands
;
ERRORREGION	equ 0
NULLREGION	equ 1
SIMPLEREGION	equ 2
COMPLEXREGION	equ 3

;
; StretchBlt modes
;
BLACKONWHITE	equ 1
WHITEONBLACK	equ 2
COLORONCOLOR	equ 3

;
; PolyFill modes
;
ALTERNATE	equ 1
WINDING 	equ 2

;
; Size message commands
;
SIZENORMAL	equ 0
SIZEICONIC	equ 1
SIZEFULLSCREEN	equ 2

;
; Key state masks for mouse messages
;
MK_LBUTTON	equ 0001h
MK_RBUTTON	equ 0002h
MK_SHIFT	equ 0004h
MK_ALTERNATE	equ 0008h
MK_CONTROL	equ 0010h

;
; Predefined clipboard formats
;
CF_TEXT 	equ 1
CF_BITMAP	equ 2
CF_METAFILEPICT equ 3
CF_SYLK 	equ 4
CF_DIF		equ 5
CF_TIFF 	equ 6
CF_OEMTEXT	equ 7
CF_DIB          equ 8
CF_PALETTE      equ 9
CF_PENDATA      equ 10

CF_OWNERDISPLAY equ 80h       ; owner display
CF_DSPTEXT	equ 81h       ; display text
CF_DSPBITMAP	equ 82h       ; display bitmap
CF_DSPMETAFILE	equ 83h       ; display metafile

;
; Private clipboard format range
;
CF_PRIVATEFIRST equ 200h      ; Anything in this range doesn't
CF_PRIVATELAST	equ 2FFh      ; get GlobalFree'd
CF_GDIOBJFIRST	equ 300h      ; Anything in this range gets
CF_GDIOBJLAST	equ 3FFh      ; DeleteObject'ed

MAKEINTRESOURCE macro a
	mov	ax,a
	cwd
	endm

;
; Predefined resource types
;
RT_CURSOR	equ 1		   ; must be passed through MAKEINTRESOURCE
RT_BITMAP	equ 2
RT_ICON 	equ 3
RT_MENU 	equ 4
RT_DIALOG	equ 5
RT_STRING	equ 6
RT_FONTDIR	equ 7
RT_FONT 	equ 8

;
; Virtual Key definitions
;
VK_MOUSE	    equ 00H
VK_LBUTTON	    equ 01h
VK_RBUTTON	    equ 02h
VK_CANCEL	    equ 03h
VK_MBUTTON	    equ 04h
VK_BACK 	    equ 08h
VK_TAB		    equ 09h
VK_CLEAR	    equ 0Ch
VK_RETURN	    equ 0Dh
VK_SHIFT	    equ 10h
VK_CONTROL	    equ 11h
VK_MENU 	    equ 12h
VK_PAUSE	    equ 13h
VK_CAPITAL	    equ 14h
VK_ESCAPE	    equ 1Bh
VK_SPACE	    equ 20h
VK_PRIOR	    equ 21h
VK_NEXT 	    equ 22h
VK_END		    equ 23h
VK_HOME 	    equ 24h
VK_LEFT 	    equ 25h
VK_UP		    equ 26h
VK_RIGHT	    equ 27h
VK_DOWN 	    equ 28h
VK_SELECT	    equ 29h
VK_PRINT	    equ 2Ah
VK_EXECUTE	    equ 2Bh
VK_SNAPSHOT	    equ 2Ch
VK_INSERT	    equ 2Dh
VK_DELETE	    equ 2Eh
VK_HELP 	    equ 2Fh
VK_NUMPAD0	    equ 60h
VK_NUMPAD1	    equ 61h
VK_NUMPAD2	    equ 62h
VK_NUMPAD3	    equ 63h
VK_NUMPAD4	    equ 64h
VK_NUMPAD5	    equ 65h
VK_NUMPAD6	    equ 66h
VK_NUMPAD7	    equ 67h
VK_NUMPAD8	    equ 68h
VK_NUMPAD9	    equ 69h
VK_MULTIPLY	    equ 6Ah
VK_ADD		    equ 6Bh
VK_SEPARATOR	    equ 6Ch
VK_SUBTRACT	    equ 6Dh
VK_DECIMAL	    equ 6Eh
VK_DIVIDE	    equ 6Fh
VK_F1		    equ 70h
VK_F2		    equ 71h
VK_F3		    equ 72h
VK_F4		    equ 73h
VK_F5		    equ 74h
VK_F6		    equ 75h
VK_F7		    equ 76h
VK_F8		    equ 77h
VK_F9		    equ 78h
VK_F10		    equ 79h
VK_F11		    equ 7Ah
VK_F12		    equ 7Bh
VK_F13		    equ 7Ch
VK_F14		    equ 7Dh
VK_F15		    equ 7Eh
VK_F16		    equ 7Fh

;
; Menu flags for Change/Check/Enable MenuItem
;
MF_CHANGE	    equ 0080h
MF_INSERT	    equ 0000h
MF_APPEND	    equ 0100h
MF_DELETE	    equ 0200h
MF_BYPOSITION	    equ 0400h
MF_BYCOMMAND	    equ 0000h
MF_GRAYED	    equ 0001h
MF_DISABLED	    equ 0002h
MF_ENABLED	    equ 0000h
MF_CHECKED	    equ 0008h
MF_BITMAP	    equ 0004h
MF_STRING	    equ 0000h
MF_POPUP	    equ 0010h
MF_DIVIDER	    equ 0020h
MF_BREAK	    equ 0040h

;
; Window Procedure Messages
;
WM_NULL 	    equ 0000h
WM_CREATE	    equ 0001h
WM_DESTROY	    equ 0002h
WM_BRUSHALIGN	    equ 0003h
WM_SIZEWAIT	    equ 0004h
WM_SIZE 	    equ 0005h
WM_ACTIVATE	    equ 0006h
WM_SETFOCUS	    equ 0007h
WM_KILLFOCUS	    equ 0008h
WM_SETVISIBLE	    equ 0009h
WM_ENABLE	    equ 000Ah
WM_SETREDRAW	    equ 000Bh
WM_SETTEXT	    equ 000Ch
WM_GETTEXT	    equ 000Dh
WM_GETTEXTLENGTH    equ 000Eh
WM_PAINT	    equ 000Fh
WM_CLOSE	    equ 0010h
WM_QUERYQUIT	    equ 0011h
WM_QUIT 	    equ 0012h
WM_QUERYOPEN	    equ 0013h
WM_ERASEBKGND	    equ 0014h
WM_SYSCOLORCHANGE   equ 0015h
WM_ENDSESSION	    equ 0016h
WM_SYSTEMERROR	    equ 0017h
WM_SHOWWINDOW	    equ 0018h
WM_CTLCOLOR	    equ 0019h
WM_WININICHANGE     equ 001Ah
WM_DEVMODECHANGE    equ 001Bh
WM_ACTIVATEAPP	    equ 001Ch

WM_QUEUESYNC	    equ 0023h
WM_SETFONT          equ 0030h
WM_GETFONT          equ 0031h

WM_WINDOWPOSCHANGING equ 0046h
WM_WINDOWPOSCHANGED equ 0047h

WM_NCCREATE	    equ 0081h
WM_NCDESTROY	    equ 0082h
WM_NCCALCSIZE	    equ 0083h
WM_NCHITTEST	    equ 0084h
WM_NCPAINT	    equ 0085h
WM_NCACTIVATE	    equ 0086h
WM_GETDLGCODE	    equ 0087h
WM_ENDDIALOG	    equ 0088h

WM_NCMOUSEMOVE	    equ 00A0h
WM_NCLBUTTONDOWN    equ 00A1h
WM_NCLBUTTONUP	    equ 00A2h
WM_NCLBUTTONDBLCLK  equ 00A3h
WM_NCRBUTTONDOWN    equ 00A4h
WM_NCRBUTTONUP	    equ 00A5h
WM_NCRBUTTONDBLCLK  equ 00A6h
WM_NCMBUTTONDOWN    equ 00A7h
WM_NCMBUTTONUP	    equ 00A8h
WM_NCMBUTTONDBLCLK  equ 00A9h

WM_KEYFIRST	    equ 0100h
WM_KEYLAST	    equ 0107h

WM_KEYDOWN	    equ 0100h
WM_KEYUP	    equ 0101h
WM_CHAR 	    equ 0102h
WM_DEADCHAR	    equ 0103h
WM_SYSKEYDOWN	    equ 0104h
WM_SYSKEYUP	    equ 0105h
WM_SYSCHAR	    equ 0106h
WM_SYSDEADCHAR	    equ 0107h

WM_INITDIALOG	    equ 0110h
WM_COMMAND	    equ 0111h
WM_SYSCOMMAND	    equ 0112h
WM_TIMER	    equ 0113h
WM_HSCROLL	    equ 0114h
WM_VSCROLL	    equ 0115h
WM_INITMENU	    equ 0116h
WM_INITMENUPOPUP    equ 0117h
WM_SYSTIMER	    equ 0118h

WM_MOUSEFIRST	    equ 0200h
WM_MOUSELAST	    equ 0209h

WM_MOUSEMOVE	    equ 0200h
WM_LBUTTONDOWN	    equ 0201h
WM_LBUTTONUP	    equ 0202h
WM_LBUTTONDBLCLK    equ 0203h
WM_RBUTTONDOWN	    equ 0204h
WM_RBUTTONUP	    equ 0205h
WM_RBUTTONDBLCLK    equ 0206h
WM_MBUTTONDOWN	    equ 0207h
WM_MBUTTONUP	    equ 0208h
WM_MBUTTONDBLCLK    equ 0209h
WM_DROPOBJECT       equ 022Ah
WM_QUERYDROPOBJECT  equ 022Bh
WM_BEGINDRAG	    equ 022Ch
WM_DRAGLOOP	    equ 022Dh
WM_DRAGSELECT	    equ 022Eh
WM_DRAGMOVE	    equ 022Fh
WM_DROPFILES	    equ 0233h

WM_CUT		    equ 0300h
WM_COPY 	    equ 0301h
WM_PASTE	    equ 0302h
WM_CLEAR	    equ 0303h
WM_UNDO 	    equ 0304h
WM_RENDERFORMAT     equ 0305h
WM_RENDERALLFORMATS equ 0306h
WM_DESTROYCLIPBOARD equ 0307h
WM_DRAWCLIPBOARD    equ 0308h
WM_PAINTCLIPBOARD   equ 0309h
WM_VSCROLLCLIPBOARD equ 030Ah
WM_SIZECLIPBOARD    equ 030Bh
WM_ASKCBFORMATNAME  equ 030Ch

WM_INTERNAL_COALESCE_FIRST equ 0390h	 ; internal

WM_COALESCE_FIRST  equ 0390h
WM_COALESCE_LAST   equ 039Fh

; The following message range reserved   ;Internal
; for multi-media                        ;Internal

WM_MM_RESERVED_FIRST  equ 03A0h    ;Internal
WM_MM_RESERVED_LAST   equ 03DFh    ;Internal

WM_INTERNAL_COALESCE_LAST equ (WM_MM_RESERVED_FIRST+16)	;internal

WM_INTERNAL_DDE_FIRST equ 03E0h    ;Internal
WM_INTERNAL_DDE_LAST  equ 03EFh    ;Internal

; The following messages are reserved for CBT ;Internal
WM_CBT_RESERVED_FIRST equ 03F0h    ;Internal
WM_CBT_RESERVED_LAST  equ 03FFh    ;Internal


WM_USER 	    equ 0400h

;
; System Menu Command Values
;
SC_SIZE 	    equ 0F000h
SC_MOVE 	    equ 0F010h
SC_ICON 	    equ 0F020h
SC_ZOOM 	    equ 0F030h
SC_NEXTWINDOW	    equ 0F040h
SC_PREVWINDOW	    equ 0F050h
SC_CLOSE	    equ 0F060h

;******** RedrawWindow() flags

RDW_INVALIDATE		equ 0001h   ; Invalidate
RDW_INTERNALPAINT	equ 0002h   ; Set WFINTERNALPAINT
RDW_ERASE		equ 0004h   ; Set WFSENDERASEBKGND

RDW_VALIDATE		equ 0008h   ; Validate
RDW_NOINTERNALPAINT	equ 0010h   ; Clear WFINTERNALPAINT
RDW_NOERASE		equ 0020h   ; Clear WFSENDERASEBKGND

RDW_NOCHILDREN		equ 0040h   ; Don't include children
RDW_ALLCHILDREN 	equ 0080h   ; Include all children

RDW_UPDATENOW		equ 0100h   ; Update the window now if needed
RDW_ERASENOW		equ 0200h   ; Erase the background now (implied by UPDATENOW)

; Internal-only RedrawWindow() flags
;
RDW_FRAME		equ 0400h   ; Set WFSENDNCPAINT
RDW_NOFRAME		equ 0800h   ; Clear WFSENDNCPAINT

RDW_REDRAWWINDOW	equ 1000h   ; Called from RedrawWindow()
RDW_SUBTRACTSELF	equ 2000h   ; Subtract self from hrgn

RDW_COPYRGN		equ 4000h   ; Copy the passed-in region

; WM_HOTKEYEVENT stuff

WM_HOTKEYEVENT          equ 0045h

endif ; !WOW

;
; SetWindowsHook() definitions
;
WH_MSGFILTER	    equ -1
WH_JOURNALRECORD    equ  0
WH_JOURNALPLAYBACK  equ  1
WH_KEYBOARD	    equ  2
WH_GETMESSAGE	    equ  3
WH_CALLWNDPROC	    equ  4
WH_CBT		    equ  5
WH_SYSMSGFILTER     equ  6
WH_MOUSE	    equ  7
WH_HARDWARE	    equ  8
WH_DEBUG	    equ  9
WH_SHELL            equ 10

ifndef WOW

;
; Standard hook code values
;
HC_GETLPLPFN	    equ -3
HC_LPLPFNNEXT	    equ -2
HC_LPFNNEXT	    equ -1
HC_ACTION	    equ  0
HC_GETNEXT	    equ  1
HC_SKIP 	    equ  2
HC_SYSMODALON	    equ  4
HC_SYSMODALOFF      equ  5

endif ; !WOW

; Lowest and highest valued windows hook IDs

WH_MINHOOK	    equ -1
WH_MAXHOOK	    equ 10
WH_CHOOKS	    equ (WH_MAXHOOK - WH_MINHOOK + 1)

HOOKNODE struc
    hkPhkNext	    dw ?
    hkLpfn	    dd ?
    hkIdHook	    dw ?
    hkHq	    dw ?
    hkHmodOwner     dw ?
    hkFCalled	    dw ?
HOOKNODE ends

HHOOK_MAGIC	    equ ('H' or ('K' * 256))

; SetHotKeyHook() definitions

HOTKEYHOOK  struc
    hkhPfn     dd  ?
    hkhHmodule dw  ?
HOTKEYHOOK  ends

CHOTKEYHOOKMAX	 equ 16

ifndef NOEXTERNS
sBegin	DATA

ifndef WOW
ExternW rgphkSysHooks
endif

sEnd    DATA
endif ;NOEXTERNS

MAX_SEB_STYLES equ 8  ; number of SEB_* values

SEB_OK         equ 1  ; Button with "OK".
SEB_CANCEL     equ 2  ; Button with "Cancel"
SEB_YES        equ 3  ; Button with "&Yes"
SEB_NO         equ 4  ; Button with "&No"
SEB_RETRY      equ 5  ; Button with "&Retry"
SEB_ABORT      equ 6  ; Button with "&Abort"
SEB_IGNORE     equ 7  ; Button with "&Ignore"
SEB_CLOSE      equ 8  ; Button with "Close"

SEB_DEFBUTTON  equ 8000h  ;Mask to make this button default

SEB_BTN1       equ 1  ; Button 1 was selected
SEB_BTN2       equ 2  ; Button 1 was selected
SEB_BTN3       equ 3  ; Button 1 was selected

;
; InvalidateDCCache() flags
;
IDC_DEFAULT         equ 0001h
IDC_CHILDRENONLY    equ 0002h
IDC_CLIENTONLY      equ 0004h

;
; Window field offsets for GetWindowLong() and GetWindowWord()
;
GWL_WNDPROC       =  (-4)
GWW_HINSTANCE     =  (-6)
GWW_HWNDPARENT    =  (-8)
GWW_ID            =  (-12)
GWL_STYLE         =  (-16)
GWL_EXSTYLE       =  (-20)

;
; Class field offsets for GetClassLong() and GetClassWord()
;
GCL_MENUNAME      =  (-8)
GCW_HBRBACKGROUND =  (-10)
GCW_HCURSOR       =  (-12)
GCW_HICON         =  (-14)
GCW_HMODULE       =  (-16)
GCW_CBWNDEXTRA    =  (-18)
GCW_CBCLSEXTRA    =  (-20)
GCL_WNDPROC       =  (-24)
GCW_STYLE         =  (-26)
GCW_ATOM          =  (-32)

;
; CTLCOLOR_* for the message WM_CTLCOLOR.
;
CTLCOLOR_MSGBOX     equ 0
CTLCOLOR_EDIT	    equ 1
CTLCOLOR_LISTBOX    equ 2
CTLCOLOR_BTN	    equ 3
CTLCOLOR_DLG	    equ 4
CTLCOLOR_SCROLLBAR  equ 5
CTLCOLOR_MAX	    equ 8	  ; 3 bits max

DLGC_WANTARROWS     equ 01h
DLGC_HASSETSEL	    equ 08h
DLGC_WANTCHARS	    equ 80h

SUENUMCHILDREN	    equ 0001h
SUPAINTFRAME	    equ 0002h
SUSTOPCLIPCHILDREN  equ 0004h
SUVALIDATE	    equ 8000h

MB_OKCANCEL         equ 00001h
MB_ICONHAND	    equ 00010h
MB_SYSTEMMODAL	    equ 01000h



ASMSYSCLROBJECTS  struc
    syshbrScrollbar         dw ?
    syshbrDesktop           dw ?
    syshbrActiveCaption     dw ?
    syshbrInactiveCaption   dw ?
    syshbrMenu              dw ?
    syshbrWindow            dw ?
    syshbrWindowFrame       dw ?
    syshbrMenuText          dw ?
    syshbrWindowText        dw ?
    syshbrCaptionText       dw ?
    syshbrActiveBorder      dw ?
    syshbrInactiveBorder    dw ?
    syshbrAppWorkspace      dw ?
    syshbrHiliteBk          dw ?
    syshbrHiliteText        dw ?
    syshbrBtnFace           dw ?
    syshbrBtnShadow         dw ?
    syshbrGrayText          dw ?
ASMSYSCLROBJECTS  ends


ASMSYSCOLORS   struc
    sysclrScrollbar         dd ?
    sysclrDesktop           dd ?
    sysclrActiveCaption     dd ?
    sysclrInactiveCaption   dd ?
    sysclrMenu              dd ?
    sysclrWindow            dd ?
    sysclrWindowFrame       dd ?
    sysclrMenuText          dd ?
    sysclrWindowText        dd ?
    sysclrCaptionText       dd ?
    sysclrActiveBorder      dd ?
    sysclrInactiveBorder    dd ?
    sysclrAppWorkspace      dd ?
    sysclrHiliteBk          dd ?
    sysclrHiliteText        dd ?
    sysclrBtnFace           dd ?
    sysclrBtnShadow         dd ?
    sysclrGrayText          dd ?
ASMSYSCOLORS   ends

SCREEN	struc
    scrncy		dw ?
    scrncx		dw ?
    scrnrc		db size RECT dup(?)
    scrncLock		dw ?
    scrncclm		dw ?
    scrncclmSave	dw ?
    scrncwnd		dw ?
SCREEN	ends

;
; Property List structures
;
PROP    struc
    propAtom        dw  0
    propValue       dw  0
PROP    ends

PROPTABLE struc
    proptabCprop    dw  0
    proptabRgprop   db size PROP dup(?)
PROPTABLE ends

;*--------------------------------------------------------------------------*
;*									    *
;*  Window Class Structures and Defines 				    *
;*									    *
;*--------------------------------------------------------------------------*

WNDCLASS struc
    clsStyle		dw ?	   ; Class style
    clsLpfnWndProc	dd ?
    clsCbClsExtra	dw ?
    clsCbWndExtra	dw ?
    clsHInstance	dw ?	   ; Instance handle
    clsHIcon		dw ?	   ; Class icon handle
    clsHCursor		dw ?	   ; Class cursor handle
    clsHbrBackground	dw ?	   ; Class background brush
    clsLpszMenuName	dd ?	   ; Menu name
    clsLpszClassName	dd ?	   ; Far ptr to class name
WNDCLASS ends

WNDSTRUC struc
    WSwndStyle		dd ?
    WSwndID		dw ?
    WSwndText		dw ?
    WSwndParent 	dw ?
    WSwndInstance	dw ?
    WSwndClassProc	dd ?
WNDSTRUC ends

;
; Window Styles (high words only)
;
WS_TILED		equ 0000h
WS_POPUP		equ 8000h
WS_CHILD		equ 4000h
WS_ICONIC		equ 2000h
WS_VISIBLE		equ 1000h
WS_DISABLED		equ 0800h
WS_CLIPSIBLINGS 	equ 0400h
WS_CLIPCHILDREN 	equ 0200h
WS_COLUMN		equ 0100h

WS_BORDER		equ 0080h
WS_CAPTION		equ 0040h
WS_VSCROLL		equ 0020h
WS_HSCROLL		equ 0010h
WS_SYSMENU		equ 0008h
WS_SIZEBOX		equ 0004h
WS_GROUP		equ 0002h
WS_TABSTOP		equ 0001h

;
; Class Styles
;
CS_VREDRAW		equ 0001h
CS_HREDRAW		equ 0002h
CS_KEYCVTWINDOW 	equ 0004h
CS_DBLCLKS		equ 0008h
CS_OEMCHARS		equ 0010h
CS_OWNDC		equ 0020h
CS_CLASSDC		equ 0040h
CS_PARENTDC		equ 0080h
CS_NOKEYCVT		equ 0100h
CS_LVB			equ 0400h
CS_SAVEPOPUPBITS	equ 0800h
CS_GLOBALCLASS		equ 4000h


;
; WinWhere Area Codes
;
HTTRANSPARENT		equ -1
HTNOWHERE		equ 0
HTCLIENT		equ 1
HTCAPTION		equ 2
HTCLOSEBOX		equ 3
HTGROWBOX		equ 4
HTMENU			equ 5
HTHSCROLL		equ 6
HTVSCROLL		equ 7

;*--------------------------------------------------------------------------*
;*  Message Structures and Defines					    *
;*--------------------------------------------------------------------------*

;
; Message Structure
;
MSG	struc
    msgHwnd	    dw ?
    msgMessage	    dw ?
    msgWParam	    dw ?
    msgLParam	    dd ?
    msgTime	    dd ?
    msgPt	    dd ?
MSG	ends

INTERNALMSG  struc
    imExtraMsgInfo  dd   ?
    imMsg           db   size MSG  dup (?)
INTERNALMSG  ends

;
; System Queue Message Structure
;
SYSMSG	struc
    smParamL	    dw ?
    smMessage	    dw ?
    smParamH	    dw ?
    smTime	    dd ?
SYSMSG	ends

INTERNALSYSMSG	struc
    ismExtraMsgInfo dd ?
    ismMsg	    db  size SYSMSG dup (?)
INTERNALSYSMSG  ends

; GetQueueStatus bits.

QS_KEY		  equ 0001h	; WM_KEY/SYSKEYUP/DOWN
QS_MOUSEMOVE	  equ 0002h	; WM_MOUSEMOVE
QS_MOUSEBUTTON	  equ 0004h	; WM_NC/L/R/MBUTTONUP/DOWN/DBLCLK
QS_MOUSE	  equ (QS_MOUSEMOVE or QS_MOUSEBUTTON)	  ; Any mouse event
QS_POSTMESSAGE	  equ 0008h	; Message posted with PostMessage()
QS_TIMER	  equ 0010h	; WM_TIMER
QS_PAINT	  equ 0020h	; WM_PAINT
QS_SENDMESSAGE	  equ 0040h	; Pending SendMessage() calls from other app
ifdef DISABLE
QS_HOTKEYEVENT	  equ 0080h	; WM_HOTKEYEVENT (WIN 3.1 ONLY)
endif

; Internal values

QS_SMRESULT	  equ 8000h
QS_SMPARAMSFREE   equ 4000h

QS_INPUT	  equ (QS_MOUSEMOVE or QS_MOUSEBUTTON or QS_KEY)

ifdef DISABLE
QS_ALLINPUT	  equ (QS_INPUT or QS_POSTMESSAGE or QS_TIMER or QS_PAINT or QS_HOTKEYEVENT)
else
QS_ALLINPUT	  equ (QS_INPUT or QS_POSTMESSAGE or QS_TIMER or QS_PAINT)
endif

; Q flags field values

QF_SEMWAIT	    equ 01h
QF_INIT 	    equ 02h
QF_PALETTEAPP       equ 04h

;
; Queue Structure
;
Q	struc
    qHqNext	    dw ?
    qHTask	    dw ?
    qCbEntry	    dw ?
    qCMsgs	    dw ?
    qPmsgRead	    dw ?
    qPmsgWrite	    dw ?
    qPmsgMax	    dw ?
    qTimeLast	    dd ?
    qPtLast	    dd ?
    qIdLast	    dw ?
    qdwExtraInfoLast dd ?
    qUnused	    dw ?
    qMsgLParam	    dd ?
    qMsgWParam	    dw ?
    qMsgMessage     dw ?
    qMsgHwnd	    dw ?
    qResult	    dd ?

    qCQuit	    dw ?
    qExitCode	    dw ?
    qFlags	    dw ?
    qpMsgFilterChain  dw ?	; Near Ptr to the head of the hook chain
    qHDS	    dw ?
    qWVersion	    dw ?
    qHqSender	    dw ?	; New Input Stuff starts here
    qHqSendList     dw ?
    qHqSendNext     dw ?
    qCPaintsReady   dw ?
    qCTimersReady   dw ?
    qChangeBits     dw ?
    qWakeBits	    dw ?
    qWakeMask	    dw ?
    qPResult	    dw ?
    qPResultSend    dw ?
    qPResultReceive dw ?
    qPhkCurrent     dw ?
    qRgphkHooks     dw WH_CHOOKS dup (?)
    qSemInput	    dd ?
    qHqSemNext	    dw ?
    qRgmsg	    db size INTERNALMSG dup (?)
Q	ends

;
; Timer Structure
;
TIMER	struc
    tmrHq	    dw ?
    tmrHwnd	    dw ?
    tmrID	    dw ?
    tmrCount	    dw ?
    tmrRate	    dw ?
    tmrFSys	    db ?
    tmrReady	    db ?
    tmrLpfn	    dd ?
TIMER	ends

CPUBLICTIMERS	    equ 32
CSYSTEMTIMERS	    equ 2
CTIMERSMAX	    equ CPUBLICTIMERS + CSYSTEMTIMERS

ifndef WOW

; GetSystemMetrics() codes.
SM_CXSCREEN	     equ 0
SM_CYSCREEN	     equ 1
SM_CXVSCROLL	     equ 2
SM_CYHSCROLL	     equ 3
SM_CYCAPTION	     equ 4
SM_CXBORDER	     equ 5
SM_CYBORDER	     equ 6
SM_CXDLGFRAME	     equ 7
SM_CYDLGFRAME	     equ 8
SM_CYVTHUMB	     equ 9
SM_CXHTHUMB	     equ 10
SM_CXICON	     equ 11
SM_CYICON	     equ 12
SM_CXCURSOR	     equ 13
SM_CYCURSOR	     equ 14
SM_CYMENU	     equ 15
SM_CXFULLSCREEN      equ 16
SM_CYFULLSCREEN      equ 17
SM_CYKANJIWINDOW     equ 18
SM_MOUSEPRESENT      equ 19
SM_CYVSCROLL	     equ 20
SM_CXHSCROLL	     equ 21
SM_DEBUG	     equ 22
SM_SWAPBUTTON	     equ 23
SM_RESERVED1	     equ 24
SM_RESERVED2	     equ 25
SM_RESERVED3	     equ 26
SM_RESERVED4	     equ 27
SM_CXMIN	     equ 28
SM_CYMIN	     equ 29
SM_CXSIZE	     equ 30
SM_CYSIZE	     equ 31
SM_CXFRAME	     equ 32
SM_CYFRAME	     equ 33
SM_CXMINTRACK	     equ 34
SM_CYMINTRACK	     equ 35
SM_CXDOUBLECLK       equ 36
SM_CYDOUBLECLK       equ 37
SM_CXICONSPACING     equ 38
SM_CYICONSPACING     equ 39
SM_MENUDROPALIGNMENT equ 40
SM_PENWINDOWS        equ 41
SM_DBCSENABLED       equ 42
SM_CMETRICSMAX	     equ 43

IFNDEF  NOCOLOR
; System colors
COLOR_SCROLLBAR           = 0
COLOR_BACKGROUND          = 1
COLOR_ACTIVECAPTION       = 2
COLOR_INACTIVECAPTION     = 3
COLOR_MENU                = 4
COLOR_WINDOW              = 5
COLOR_WINDOWFRAME         = 6
COLOR_MENUTEXT            = 7
COLOR_WINDOWTEXT          = 8
COLOR_CAPTIONTEXT         = 9
COLOR_ACTIVEBORDER        = 10
COLOR_INACTIVEBORDER      = 11
COLOR_APPWORKSPACE        = 12
COLOR_HIGHLIGHT           = 13
COLOR_HIGHLIGHTTEXT       = 14
COLOR_BTNFACE             = 15
COLOR_BTNSHADOW           = 16
COLOR_GRAYTEXT            = 17
COLOR_BTNTEXT             = 18
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHILIGHT          = 20
COLOR_MAX                 = 20

ENDIF   ;NOCOLOR

; DrawFrame commands
DF_SHIFT0           equ 0000h
DF_SHIFT1           equ 0001h
DF_SHIFT2           equ 0002h
DF_SHIFT3           equ 0003h
DF_PATCOPY          equ 0000h
DF_PATINVERT        equ 0004h

DF_SCROLLBAR	    equ (COLOR_SCROLLBAR * 8)
DF_BACKGROUND	    equ (COLOR_BACKGROUND * 8)
DF_ACTIVECAPTION    equ (COLOR_ACTIVECAPTION * 8)
DF_INACTIVECAPTION  equ (COLOR_INACTIVECAPTION * 8)
DF_MENU		    equ (COLOR_MENU * 8)
DF_WINDOW	    equ (COLOR_WINDOW * 8)
DF_WINDOWFRAME	    equ (COLOR_WINDOWFRAME * 8)
DF_MENUTEXT	    equ (COLOR_MENUTEXT * 8)
DF_WINDOWTEXT	    equ (COLOR_WINDOWTEXT * 8)
DF_CAPTIONTEXT	    equ (COLOR_CAPTIONTEXT * 8)
DF_ACTIVEBORDER	    equ (COLOR_ACTIVEBORDER * 8)
DF_INACTIVEBORDER   equ (COLOR_INACTIVEBORDER * 8)
DF_APPWORKSPACE	    equ (COLOR_APPWORKSPACE * 8)
DF_GRAY             equ (DF_APPWORKSPACE + (1 * 8))
endif ; !WOW

ifndef NOEXTERNS
;*--------------------------------------------------------------------------*
;*  Externs for the Interrupt Level Global Variables                        *
;*--------------------------------------------------------------------------*

; This file is included to access intrerrupt variables. It declares them in
; the right segment, externs [csds], the variable that has the segment
; that these variables will be in, and assumes ds to the CODE segment

createSeg _INTDS, INTDS, BYTE, PUBLIC, DATA

sBegin INTDS

ifndef WOW
ExternB fDontMakeAltUpASysKey
ExternD hwEventHook
ifdef userhimem
ExternW fffedelta
endif
ExternW msgJournal
ExternD dtJournal
ExternD ptTrueCursor
ExternD dwMouseMoveExtraInfo
ExternD ptCursor
ifdef DOS30
ExternD lpSysProc
endif
ExternW hqActive
ExternW hqCapture
ExternW hqMouse
ExternW hqKeyboard
endif ; !WOW
ExternW hqList
ExternW hqSysQueue
ExternW hqSysModal
ExternW cQEntries
ifndef WOW
ExternW fMouseMoved
;; ExternB fAltKeyUp
ExternB rgbAsyncKeyState
ExternW fEnableInput
ExternW fSwapButtons
endif ; !WOW
ExternW hqCursor
ifndef WOW
ExternW cMsgRsrv
ExternB vKeyDown
ExternD timerInfo
ExternB TimerTable
ExternW TimerTableMax
ExternW hSysTimer
ExternD tSysTimer
ExternW dtSysTimer
ExternB fInScanTimers
endif ; !WOW
ExternW szDivZero
ExternW szSysError
ifndef WOW
ExternW x_mickey_rate
ExternW y_mickey_rate
ExternW cur_x_mickey
ExternW cur_y_mickey
ExternW rcCursorClip
ExternW cxScreenCS
ExternW cyScreenCS
ExternW MouseThresh1
ExternW MouseThresh2
ExternW MouseSpeed
ifndef PMODE
ExternD lpMouseStack
ExternD prevSSSP
ExternB NestCount
endif
ExternW hqSysLock
ExternW idSysLock

ExternW fJournalPlayback
endif ; !WOW

sEnd INTDS

endif


ifndef WOW
;*--------------------------------------------------------------------------*
;*  OEM Inquire Structures for Timer, Keyboard, Mouse, and Cursor modules   *
;*--------------------------------------------------------------------------*

STIMERINFO  struc
    tiResolution    dd 0    ; #microseconds each timer tick
STIMERINFO  ends

SKBINFO     struc
    kbBegin1	    db 0    ; some range values for the East Asia
    kbEnd1	    db 0
    kbBegin2	    db 0
    kbEnd2	    db 0
    kbStateSize     dw 0    ; #bytes of state info maintained by TOASCII
SKBINFO     ends

SMOUSEINFO  struc
    msExists	    db 0    ; true => mouse exists
    msRelative	    db 0    ; true => relative coordinate
    msNumButtons    dw 0    ; number of buttons on the mouse
    msRate	    dw 0    ; maximum rate of mouse input events
    msXThresh	    dw 0    ; threshold before acceleration
    msYThresh	    dw 0    ;
    msXRes	    dw 0    ; x resolution
    msYRes	    dw 0    ; y resolution
SMOUSEINFO  ends

SCURSORINFO struc
    dpXRate	    dw 0    ; horizontal mickey/pixel ratio
    dpYRate	    dw 0    ; vertical mickey/pixel ratio
    dpXMask	    dw 0
    dpYMask	    dw 0
    dpXCurSize	    dw 0
    dpYCurSize	    dw 0
    dpXIcoSize	    dw 0
    dpYIcoSize	    dw 0
SCURSORINFO ends

;
; OEM Info Structures
;

OEMBITMAPINFO struc
    oemhBitmap	    dw ?
    oemwidth	    dw ?
    oemheight	    dw ?
OEMBITMAPINFO ends

OEMSINFO    struc
    oembmFull	    	db size OEMBITMAPINFO dup(?)
    oembmUpArrow    	db size OEMBITMAPINFO dup(?)
    oembmDnArrow    	db size OEMBITMAPINFO dup(?)
    oembmRgArrow    	db size OEMBITMAPINFO dup(?)
    oembmLfArrow    	db size OEMBITMAPINFO dup(?)
    oembmReduce	    	db size OEMBITMAPINFO dup(?)
    oembmZoom	    	db size OEMBITMAPINFO dup(?)
    oembmRestore    	db size OEMBITMAPINFO dup(?)
    oembmMenuArrow  	db size OEMBITMAPINFO dup(?)
    oembmComboArrow 	db size OEMBITMAPINFO dup(?)
    oembmReduceD    	db size OEMBITMAPINFO dup(?)
    oembmZoomD	    	db size OEMBITMAPINFO dup(?)
    oembmRestoreD   	db size OEMBITMAPINFO dup(?)
    oembmUpArrowD   	db size OEMBITMAPINFO dup(?)
    oembmDnArrowD   	db size OEMBITMAPINFO dup(?)
    oembmRgArrowD   	db size OEMBITMAPINFO dup(?)
    oembmLfArrowD   	db size OEMBITMAPINFO dup(?)
    oemcxHThumb     	dw ?
    oemcyVVThumb    	dw ?
    oemcxMin	    	dw ?
    oemcyMin	    	dw ?
    oemcxIconSlot   	dw ?
    oemcyIconSlot   	dw ?
    oemcxIcon	    	dw ?
    oemcyIcon	    	dw ?
    oemcxPixelsPerInc   dw ?
    oemcyPixelsPerInch  dw ?
    oemcxCursor     	dw ?
    oemcyCursor     	dw ?
    oemDispDrvExpWinVer dw ?
    oemScreenBitCount   dw ?
    oemcSKanji	    	dw ?
    oemfMouse	    	dw ?
OEMSINFO    ends

OEMSINFOMONO	struc
    oembmAdjust     db size OEMBITMAPINFO dup(?)
    oembmSize	    db size OEMBITMAPINFO dup(?)
    oembmCheck	    db size OEMBITMAPINFO dup(?)
    oembmbtnbmp     db size OEMBITMAPINFO dup(?)
    oembmCorner	    db size OEMBITMAPINFO dup(?)
    oemcxbmpChk     dw ?
    oemcybmpChk     dw ?
OEMSINFOMONO	ends
endif ; !WOW


;*--------------------------------------------------------------------------*
;*  Debugging Defines							    *
;*--------------------------------------------------------------------------*

;
; RIP codes
;
RIP_CHECKDC		equ 0FFF2h    ; decimal -14
RIP_WLSINSEM		equ 0FFF3h    ; decimal -13
RIP_CHECKSEM		equ 0FFF4h    ; decimal -12
RIP_SENDMESSAGEINSEM	equ 0FFF5h    ; decimal -11
RIP_SEMNOTINORDER	equ 0FFF6h    ; decimal -10
RIP_RWLEAVEUNDERFLOW	equ 0FFF7h    ; decimal -9

RIP_WINDOWLEFTLOCKED	equ 0FFF9h    ; decimal -7 ; hq->cLock !equ 0 in GetMessage.
RIP_BADLOCKWINDOW	equ 0FFFAh    ; decimal -6 ; Window passed was NULL.
RIP_LOCKUNDERFLOW	equ 0FFFBh    ; decimal -5 ; Too many UnlockWindows.
RIP_INSEMAPHORE 	equ 0FFFCh    ; decimal -4
RIP_BADSEMCLEAR 	equ 0FFFDh    ; decimal -3
RIP_BADLOCKCOUNT	equ 0FFFEh    ; decimal -2
RIP_MEMALLOC		equ 1
RIP_MEMREALLOC		equ 2
RIP_MEMFREE		equ 3
RIP_MEMLOCK		equ 4
RIP_MEMUNLOCK		equ 5
RIP_SENDMESSAGELOCK	equ 6
RIP_BADWINDOWHANDLE	equ 7
RIP_DCBUSY		equ 8
RIP_NODEFWINDOWPROC	equ 9
RIP_CLIPBOARDOPEN	equ 000Ah
RIP_DCCAHCHEFULL        equ 000Bh
RIP_INVALKEYBOARD	equ 000Ch
RIP_INVALMOUSE		equ 000Dh
RIP_INVALCURSOR 	equ 000Eh
RIP_DSUNLOCKED		equ 000Fh
RIP_INVALLOCKSYSQ	equ 0010h
RIP_CARETBUSY		equ 0011h
RIP_GETCWRANGE		equ 0012h
RIP_HWNDOWNSDCS 	equ 0013h	      ; One hwnd owns all the DCs.
RIP_BADHQ		equ 0014h	      ; Operation on something of wrong task
RIP_NOQUEUE		equ 0019h	      ; GetAppVer() is called before queues are
				      	      ; created.
RIP_BADHOOKHANDLE	equ 001Bh
RIP_BADHOOKID		equ 001Ch
RIP_BADHOOKPROC 	equ 001Dh
RIP_BADHOOKMODULE	equ 001Eh
RIP_BADHOOKCODE 	equ 001Fh
RIP_HOOKNOTALLOWED	equ 0020h
RIP_UNREMOVEDPROP	equ 0021h
RIP_BADPROPNAME 	equ 0022h

RIP_BADTASKHANDLE	equ 0025h

RIP_GETSETINFOERR1	equ 0027h	      ; Bad negative index for Get/Set/Window etc.,
RIP_GETSETINFOERR2      equ 0028h        ; Bad Positive index for Get/Set/Window etc.,

RIP_WINDOWIDNOTFOUND    equ 002Ah        ; Dialog control ID not found
RIP_SYSTEMERRORBOXFAILED equ 002Bh       ; Hard sys error box failed due to no hq
RIP_INVALIDMENUHANDLE   equ 002Ch         ; Invalid menu handle

RIP_MESSAGEBOXWITHNOQUEUE equ 002Eh      ; Message box called with no message queue initialized
RIP_DLGWINDOWEXTRANOTALLOCATED equ 002Fh ; DLGWINDOWEXTRA bytes not allocated for dlg box
RIP_INTERTASKSENDMSGHANG       equ 0030h ; Intertask send message with tasks locked
RIP_INVALIDPARAM               equ 0031h
RIP_ASSERTFAILED               equ 0032h
RIP_INVALIDFUNCTIONCALLED      equ 0033h
RIP_LOCKINPUTERROR             equ 0034h
RIP_NULLWNDPROC		       equ 0035h ; SetWindowLong uses a NULL wnd proc
RIP_BAD_UNHOOK		       equ 0036h ; SetWindowsHook is called to unhook.
RIP_QUEUE_FULL                 equ 0037h ; PostMessage failed due to full queue.

;
; DebugErr() macro
;
ifdef DEBUG

ifndef winmisc1
externFP    DebugOutput,<C>
endif

DebugErr    macro   flags,msg
        local   a,b
        push    cs
        push    offset a
        push    flags or DBF_USER
        cCall   DebugOutput
        add     sp,2+4      ; DebugOutput is cdecl!
        jmp     short b
a:
        db      "USER: "
        db      msg
        db      0
b:
endm

else    ; DEBUG

DebugErr    macro   flags,msg
endm

endif   ; DEBUG

externFP	LogError

include		LogError.inc

UserLogError    macro flags,errcode,msg
        DebugErr <flags>,<msg>
        push    errcode
	push	0
	push	0
        call    LogError
endm

;
; Fast, inline check for valid window.
; NOTE: MUST BE USED INSIDE beg_fault_trap/end_fault_trap
;
FastIsWindow    macro   seg,reg
        mov     reg,seg:[reg].wndPcls
        cmp     seg:[reg].uclsMagic,CLS_MAGIC
        endm

;*--------------------------------------------------------------------------*
;*  Utility Macros							    *
;*--------------------------------------------------------------------------*

; Similar to LabelFP, except used for "validate in debug only" entry points.
; Declares Iname if debug, name if
;
LabelVDO macro  name
  ifdef DEBUG
        LabelFP <PUBLIC, I&name>
  else
        LabelFP <PUBLIC, I&name>
        LabelFP <PUBLIC, name>
  endif
endm

; Same as cProc, except used for "Validate in Debug Only" entry points.
; Declares Iname if debug, name if retail.
;
cProcVDO macro  name,opts,savelist
  ifdef DEBUG
        cProc   <I&name>,<opts>,<savelist>
  else
        LabelFP <PUBLIC, I&name>
        cProc   <name>,<opts>,<savelist>
  endif
endm

;
; EatTwoBytes macro
;
EatTwoBytes macro
	db	0A9h	;; Opcode for CMP AX,(immediate word)
	endm

;
; Push DWORD macro
;
pushd   macro   d
        push    word ptr (d)+2
        push    word ptr (d)
	endm
;
; Call an internal far entry point
;
wcall   macro   adr
        push    cs
        call    near ptr (adr)
	endm

;
; Short jump macro
;
jmps    macro   adr
        jmp     short (adr)
	endm

;
; XMOV macro
;
;   Use instead of MOV ax,reg.	Saves a byte.
;
xmov	macro	a,b
	xchg	a,b
	endm

ifndef WOW
;----------------------------------------------------------------------------
; New set of Critical Region Macros
;     The necessity for new set of macros is
;     1. We need to avoid "cli" if it is already disabled (saves 300 cycles
;        under 386pmode because "cli" and "sti" are simulated by Windows).
;     2. PostMessage() might be called with interrupts already disabled; so,
;        we should not blindly do a "sti" when we do LeaveCrit
;  WARNINGS:
;     1. These two macros must be properly nested.
;----------------------------------------------------------------------------
;  WARNINGS for NewEnterCrit:
;     (1) This trashes the zero flag.
;     (2) This trashes the register that is passed as the parameter; 
;     (3) It pushes flags onto stack which will be popped up by NewLeaveCrit
;----------------------------------------------------------------------------
NewEnterCrit   macro   Reg
	LOCAL	SkipCli	   ;; Declare symbol for macro
	pushf		   ;; Save flags on stack for the use of NewLeaveCrit
	pushf	
	pop	Reg	   ;; Load flags into BX register
	test    Reg, 0200h ;; see if interrupts are already disabled
	jz	SkipCli	   ;; Skip doing a "cli" and save 300 cycles!!!
        FCLI                ;; We have to clear the interrupts
SkipCli:
	endm
;----------------------------------------------------------------------------
; WARNINGS for NewLeaveCrit:
;    (1) This preserves the Z flag.
;    (2) This trashes the registers that are passed as the parameters;
;    (3) It pops the flags pushed by NewEnterCrit.
;   NOTE: It is much easier to use pushf and popf combination to preserve
;         the Z flag, but 286 processors have a bug which results in the 
;         interrupts enabled irrespect of the state of the flag before and
;         after the popf; That is why we do not use popf anywhere in this
;         macro;
;----------------------------------------------------------------------------
NewLeaveCrit    macro   Reg, ZFlagReg
	LOCAL	SkipSti    ;; Declare symbol for Macro
	pushf  		   ;; To save the Z flag
	pop	ZFlagReg   ;; Save the Z flag
	pop	Reg	   ;; pop flags pushed by NewEnterCrit
	test	Reg, 0200h ;; see if interrupts were disabled even 
			   ;; before entering the critical region
	jz	SkipSti	   ;; Skip doing a "sti".
        FSTI
SkipSti:
	not	ZFlagReg
	test    ZFlagReg, 0040h  ;; Restore Z flag to the value before
				 ;; entering NewLeaveCrit
	endm

endif ; !WOW

;
; Old Critical Region macros
;
EnterCrit   macro
        FCLI
	endm

LeaveCrit   macro
        FSTI
	endm


ifndef WOW
;
;   AllocP	Macro
;
;   Caution: You can not use ax regiter as a parameter for this Macro!
;

AllocP	macro	wType, cb
ifdef  DEBUG
ifndef winmisc1
	mov	ax, wType
	push	ax
endif
endif
	push	LPTR
	push	cb
	call	LocalAlloc
	endm


;
; AllocH Macro
;
; CAUTION:  You can NOT use ax register as a parameter for this MACRO!
;
AllocH	macro	wType, cb
ifdef DEBUG
ifndef winmisc1
	push	wType
endif
endif
	push	LHND
	push	cb
	call	LocalAlloc
	endm

FreeP	macro	Ptr
	push	Ptr
	call	LocalFree
	endm

;
; ReAllocH Macro
;
ReAllocH macro	h, cb
	push	h
	push	cb
	push	LMEM_ZEROINIT
	call	LocalReAlloc
	endm

;
; FreeH Macro
;
FreeH	macro	h
	push	h
	call	LocalFree
	endm

;
; LockH is assumed to preserve all registers (except flags)
;
LockH	macro	h, p
	inc	byte ptr [h+3]
        mov     p,[h]
	endm

;
; UnlockH is assumed to preserve all registers (except flags)
;
UnlockH macro   h
	dec	byte ptr [h+3]
        endm
endif ; !WOW


ifndef WOW
;----------------------------------------------------------------------------
;  GetES
;	This macro gets the current value of USER's data segment and loads it
;	into ES register.
;  NOTE: This Macro might destroy the AX register.
;----------------------------------------------------------------------------

UserDStoES  macro
	mov	ax,_DATA
	mov	es,ax
	    endm

UserDStoDS  macro
	mov	ax,_DATA
	mov	ds,ax
	    endm

WF_PMODE        =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_WIN286       =    0010h
WF_WIN386       =    0020h
WF_LARGEFRAME   =    0100h
WF_SMALLFRAME   =    0200h
endif ; !WOW

endif	; LAYER_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user.h ===
/***************************************************************************/
/*                                                                         */
/*  USER.H -                                   */
/*                                                                         */
/*     User's main include file.                                           */
/*                                                                         */
/***************************************************************************/

#ifdef WOW
#define NO_LOCALOBJ_TAGS
#endif

// If #defined, only 16 bits of the window extended style will be stored
// in the window instance.
//
//#define WORDEXSTYLE


// This magic definition ensures that HWND is declared as a near
// pointer to our internal window data structure.  See
// the DECLARE_HANDLE macro in windows.h.
//
#define tagWND HWND__

// substitute API names with the "I" internal names
//
#ifndef DEBUG
#include "iuser.h"
#endif

#ifdef DEBUG
#ifndef NO_REDEF_SENDMESSAGE
#define SendMessage RevalSendMessage
#endif
#endif

//***** Include standard headers...

#define NOSOUND
#define NOFONT
#define NOKANJI
#define LSTRING
#define LFILEIO
#define WIN31

#define STRICT

#include <windows.h>

/* Structure types that occupy the USER Data Segment */
#define ST_CLASS        1
#define ST_WND          2
#define ST_STRING       3
#define ST_MENU         4
#define ST_CLIP         5
#define ST_CBOX         6
#define ST_PALETTE      7
#define ST_ED           8
#define ST_BWL          9
#define ST_OWNERDRAWMENU    10
#define ST_SPB          11
#define ST_CHECKPOINT       12
#define ST_DCE          13
#define ST_MWP          14
#define ST_PROP         15
#define ST_LBIV         16
#define ST_MISC         17
#define ST_ATOMS        18
#define ST_LOCKINPUTSTATE       19
#define ST_HOOKNODE     20
#define ST_USERSEEUSERDOALLOC   21
#define ST_HOTKEYLIST           22
#define ST_POPUPMENU            23
#define ST_HANDLETABLE      32 /* Defined by Kernel; We have no control */
#define ST_FREE         0xFF

#define CODESEG     _based(_segname("_CODE"))
#define INTDSSEG    _based(_segname("_INTDS"))

// Returns TRUE if currently executing app is 3.10 compatible
//
#define Is310Compat(hInstance)   (LOWORD(GetExpWinVer(hInstance)) >= 0x30a)
#define Is300Compat(hInstance)   (LOWORD(GetExpWinVer(hInstance)) >= 0x300)

#define VER     0x0300
#define VER31           0x0310
#define VER30       0x0300
#define VER20       0x0201

#define CR_CHAR     13
#define ESC_CHAR    27
#define SPACE_CHAR  32

typedef HANDLE      HQ;

struct tagDCE;

/* Window class structure */
typedef struct tagCLS
{
    /* NOTE: The order of the following fields is assumed. */
    struct tagCLS*  pclsNext;
    WORD        clsMagic;
    ATOM        atomClassName;
    struct tagDCE*  pdce;          /* DCE * to DC associated with class */
    int         cWndReferenceCount;   /* The number of windows registered
                         with this class */
    WORD        style;
    WNDPROC     lpfnWndProc;
    int         cbclsExtra;
    int         cbwndExtra;
    HMODULE         hModule;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPSTR       lpszMenuName;
    LPSTR       lpszClassName;
} CLS;
typedef CLS *PCLS;
typedef CLS far *LPCLS;
typedef PCLS  *PPCLS;

#define CLS_MAGIC   ('N' | ('K' << 8))

struct tagPROPTABLE;

/* Window instance structure */
typedef struct tagWND
{
    struct tagWND* hwndNext;   /* 0x0000 Handle to the next window      */
    struct tagWND* hwndChild;  /* 0x0002 Handle to child            */
    struct tagWND* hwndParent; /* 0x0004 Backpointer to the parent window.  */
    struct tagWND* hwndOwner;  /* 0x0006 Popup window owner field       */
    RECT      rcWindow;    /* 0x0008 Window outer rectangle         */
    RECT      rcClient;    /* 0x0010 Client rectangle           */
    HQ        hq;          /* 0x0018 Queue handle               */
    HRGN      hrgnUpdate;  /* 0x001a Accumulated paint region       */
    struct tagCLS*  pcls;      /* 0x001c Pointer to window class        */
    HINSTANCE     hInstance;   /* 0x001e Handle to module instance data.    */
    WNDPROC   lpfnWndProc; /* 0x0020 Far pointer to window proc.        */
    DWORD     state;       /* 0x0024 Internal state flags           */
    DWORD     style;       /* 0x0028 Style flags                */
#ifdef WORDEXSTYLE
    WORD          dwExStyle;   /* 0x002c Extended Style (ONLY LOW 16 BITS STORED) */
#else
    DWORD         dwExStyle;   /* 0x002c Extended Style                     */
#endif
    HMENU     hMenu;       /* 0x0030 Menu handle or ID          */
    HLOCAL    hName;       /* 0x0032 Alt DS handle of the window text   */
    int*      rgwScroll;   /* 0x0034 Words used for scroll bar state    */
    struct tagPROPTABLE* pproptab; /* 0x0036 Handle to the start of the property list */
    struct tagWND* hwndLastActive; /* 0x0038 Last active in owner/ownee list */
    HMENU     hSysMenu;    /* 0x003a Handle to system menu          */
} WND;

#undef API
#define API _loadds _far _pascal

#undef CALLBACK
#define CALLBACK _loadds _far _pascal

#ifndef MSDWP

#include <winexp.h>
#include "strtable.h"
#include "wmsyserr.h"

#endif   /* MSDWP */

/*** AWESOME HACK ALERT!
 *
 *  Window Style and State Masks -
 *
 *  High byte of word is byte index from the start of the state field
 *  in the WND structure, low byte is the mask to use on the byte.
 *  These masks assume the order of the state and style fields of a
 *  window instance structure.
 */

// hwnd->state flags (offset 0, 1, 2, 3)
#define WFMPRESENT    0x0001
#define WFVPRESENT    0x0002
#define WFHPRESENT    0x0004
#define WFCPRESENT    0x0008
#define WFSENDSIZEMOVE    0x0010
#define WFNOPAINT         0x0020
#define WFFRAMEON         0x0040
#define WFHASSPB          0x0080
#define WFNONCPAINT       0x0101
#define WFSENDERASEBKGND  0x0102
#define WFERASEBKGND      0x0104
#define WFSENDNCPAINT     0x0108
#define WFINTERNALPAINT   0x0110    // Internal paint required flag
#define WFUPDATEDIRTY     0x0120
#define WFHIDDENPOPUP     0x0140
#define WFMENUDRAW        0x0180

#define WFHASPALETTE      0x0201
#define WFPAINTNOTPROCESSED 0x0202  // WM_PAINT message not processed
#define WFWIN31COMPAT     0x0204    // Win 3.1 compatible window
#define WFALWAYSSENDNCPAINT 0x0208  // Always send WM_NCPAINT to children
#define WFPIXIEHACK       0x0210    // Send (HRGN)1 to WM_NCPAINT (see PixieHack)
#define WFTOGGLETOPMOST   0x0220    // Toggle the WS_EX_TOPMOST bit ChangeStates

// hwnd->style style bits (offsets 4, 5, 6, 7)
#define WFTYPEMASK    0x07C0
#define WFTILED       0x0700
#define WFICONICPOPUP     0x07C0
#define WFPOPUP       0x0780
#define WFCHILD       0x0740
#define WFMINIMIZED   0x0720
#define WFVISIBLE     0x0710
#define WFDISABLED    0x0708
#define WFDISABLE     WFDISABLED
#define WFCLIPSIBLINGS    0x0704
#define WFCLIPCHILDREN    0x0702
#define WFMAXIMIZED   0x0701
#define WFICONIC      WFMINIMIZED

#define WFMINBOX      0x0602
#define WFMAXBOX      0x0601

#define WFBORDERMASK      0x06C0
#define WFBORDER      0x0680
#define WFCAPTION     0x06C0
#define WFDLGFRAME    0x0640
#define WFTOPLEVEL    0x0640

#define WFVSCROLL     0x0620
#define WFHSCROLL     0x0610
#define WFSYSMENU     0x0608
#define WFSIZEBOX     0x0604
#define WFGROUP       0x0602
#define WFTABSTOP     0x0601

// If this dlg bit is set, WM_ENTERIDLE message will not be sent
#define WFNOIDLEMSG   0x0501

// hwnd->dwExStyle extended style bits (offsets 8, 9)
#define WEFDLGMODALFRAME  0x0801
#define WEFDRAGOBJECT     0x0802
#define WEFNOPARENTNOTIFY 0x0804
#define WEFTOPMOST    0x0808
#define WEFACCEPTFILES    0x0810
#define WEFTRANSPARENT    0x0820    // "Transparent" child window

// Class styles
#define CFVREDRAW         0x0001
#define CFHREDRAW         0x0002
#define CFKANJIWINDOW     0x0004
#define CFDBLCLKS         0x0008
#define CFOEMCHARS        0x0010
#define CFOWNDC           0x0020
#define CFCLASSDC         0x0040
#define CFPARENTDC        0x0080
#define CFNOKEYCVT        0x0101
#define CFNOCLOSE         0x0102
#define CFLVB             0x0104
#define CFCLSDC           CFCLASSDC
#define CFSAVEBITS    0x0108
#define CFSAVEPOPUPBITS   CFSAVEBITS
#define CFBYTEALIGNCLIENT 0x0110
#define CFBYTEALIGNWINDOW 0x0120


/*** AWESOME HACK ALERT!!!
 *
 * The low byte of the WF?PRESENT state flags must NOT be the
 * same as the low byte of the WFBORDER and WFCAPTION flags,
 * since these are used as paint hint masks.  The masks are calculated
 * with the MaskWF macro below.
 *
 * The magnitute of this hack compares favorably with that of the national debt.
 */
#define TestWF(hwnd, flag)   ((BYTE)*((BYTE *)(&(hwnd)->state) + HIBYTE(flag)) & (BYTE)LOBYTE(flag))
#define SetWF(hwnd, flag)    ((BYTE)*((BYTE *)(&(hwnd)->state) + HIBYTE(flag)) |= (BYTE)LOBYTE(flag))
#define ClrWF(hwnd, flag)    ((BYTE)*((BYTE *)(&(hwnd)->state) + HIBYTE(flag)) &= ~(BYTE)LOBYTE(flag))
#define MaskWF(flag)         ((WORD)( (HIBYTE(flag) & 1) ? LOBYTE(flag) << 8 : LOBYTE(flag)) )

#define TestCF(hwnd, flag)   (*((BYTE *)(&(hwnd)->pcls->style) + HIBYTE(flag)) & LOBYTE(flag))
#define SetCF(hwnd, flag)    (*((BYTE *)(&(hwnd)->pcls->style) + HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF(hwnd, flag)    (*((BYTE *)(&(hwnd)->pcls->style) + HIBYTE(flag)) &= ~LOBYTE(flag))
#define TestCF2(pcls, flag)  (*((BYTE *)(&pcls->style) + HIBYTE(flag)) & LOBYTE(flag))
#define SetCF2(pcls, flag)   (*((BYTE *)(&pcls->style) + HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF2(pcls, flag)   (*((BYTE *)(&pcls->style) + HIBYTE(flag)) &= ~LOBYTE(flag))

#define TestwndChild(hwnd)   (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFCHILD))
#define TestwndTiled(hwnd)   (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFTILED))
#define TestwndIPopup(hwnd)  (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFICONICPOPUP))
#define TestwndNIPopup(hwnd) (TestWF(hwnd, WFTYPEMASK) == (BYTE)LOBYTE(WFPOPUP))
#define TestwndPopup(hwnd)   (TestwndNIPopup(hwnd) || TestwndIPopup(hwnd))
#define TestwndHI(hwnd)      (TestwndTiled(hwnd) || TestwndIPopup(hwnd))

/* Special macro to test if WM_PAINT is needed */

#define NEEDSPAINT(hwnd)    (hwnd->hrgnUpdate != NULL || TestWF(hwnd, WFINTERNALPAINT))

/* Areas to be painted during activation and inactivation */
#define NC_DRAWNONE    0x00
#define NC_DRAWCAPTION 0x01
#define NC_DRAWFRAME   0x02
#define NC_DRAWBOTH    (NC_DRAWCAPTION | NC_DRAWFRAME)

void FAR DrawCaption(HWND hwnd, HDC hdc, WORD flags, BOOL fActive);

/* ActivateWindow() commands */
#define AW_USE       1
#define AW_TRY       2
#define AW_SKIP      3
#define AW_TRY2      4
#define AW_SKIP2     5      /* used internally in ActivateWindow() */
#define AW_USE2      6      /* nc mouse activation added by craigc */

/* These numbers serve as indices into the atomSysClass[] array
 * so that we can get the atoms for the various classes.
 * The order of the control classes is assumed to be
 * the same as the class XXXCODE constants defined in dlgmgr.h.
 */
#define ICLS_BUTTON     0
#define ICLS_EDIT       1
#define ICLS_STATIC     2
#define ICLS_LISTBOX        3
#define ICLS_SCROLLBAR      4
#define ICLS_COMBOBOX       5       // End of special dlgmgr indices

#define ICLS_CTL_MAX        6       // Number of public control classes

#define ICLS_DESKTOP        6
#define ICLS_DIALOG     7
#define ICLS_MENU       8
#define ICLS_SWITCH     9
#define ICLS_ICONTITLE      10
#define ICLS_MDICLIENT      11
#define ICLS_COMBOLISTBOX   12

#define ICLS_MAX        13      // Number of system classes

// The following are the atom values for the atom-named public classes
// NOTE: DIALOGCLASS at least should be in windows.h
//
#define MENUCLASS   0x8000      /* Public Knowledge */
#define DESKTOPCLASS    0x8001
#define DIALOGCLASS     0x8002
#define SWITCHWNDCLASS  0x8003
#define ICONTITLECLASS  0x8004

/* Z Ordering() return values */
#define ZO_ERROR        (-1)
#define ZO_EQUAL        0
#define ZO_DISJOINT     1
#define ZO_ABOVE        2
#define ZO_BELOW        3

#ifdef DEBUG
#ifndef  NO_LOCALOBJ_TAGS
HANDLE  FAR UserLocalAlloc(WORD, WORD, WORD);
HANDLE  FAR UserLocalFree(HANDLE);
char*   FAR UserLocalLock(HANDLE);
BOOL    FAR UserLocalUnlock(HANDLE);
HANDLE  FAR UserLocalReAlloc(HANDLE, WORD, WORD);
WORD    FAR UserLocalSize(HANDLE);

#define LocalAlloc(A,B) UserLocalAlloc(ST_MISC,A,B)
#define LocalFree   UserLocalFree
#define LocalLock   UserLocalLock
#define LocalUnlock UserLocalUnlock
#define LocalReAlloc    UserLocalReAlloc
#define LocalSize   UserLocalSize
#endif
#endif

#ifndef DEBUG
#define  UserLocalAlloc(TagType,MemType,Size)   LocalAlloc(MemType,Size)
#else
#ifdef NO_LOCALOBJ_TAGS
#define  UserLocalAlloc(TagType,MemType,Size)   LocalAlloc(MemType,Size)
#endif
#endif

#define XCOORD(l)   ((int)LOWORD(l))
#define YCOORD(l)   ((int)HIWORD(l))
#define abs(A)  ((A < 0)? -A : A)

/* CheckPoint structure */
typedef struct tagCHECKPOINT
  {
    RECT  rcNormal;
    POINT ptMin;
    POINT ptMax;
    HWND  hwndTitle;
    WORD  fDragged:1;
    WORD  fWasMaximizedBeforeMinimized:1;
    WORD  fWasMinimizedBeforeMaximized:1;
    WORD  fParkAtTop:1;
  } CHECKPOINT;

// Internal property name definitions

#define CHECKPOINT_PROP_NAME    "SysCP"
extern ATOM atomCheckpointProp;
#define WINDOWLIST_PROP_NAME    "SysBW"
extern ATOM atomBwlProp;

#define InternalSetProp(hwnd, key, value, fInternal)    SetProp(hwnd, key, value)
#define InternalGetProp(hwnd, key, fInternal)       GetProp(hwnd, key)
#define InternalRemoveProp(hwnd, key, fInternal)    RemoveProp(hwnd, key)
#define InternalEnumProps(hwnd, pfn, fInternal)     EnumProps(hwnd, pfn)

/* Window List Structure */
typedef struct tagBWL
  {
    struct tagBWL *pbwlNext;
    HWND          *phwndMax;
    HWND          rghwnd[1];
  } BWL;
typedef BWL *PBWL;

#define CHWND_BWLCREATE     32      // Initial BWL size
#define CHWND_BWLGROW       16      // Amt to grow BWL by when it needs to grow.

// BuildHwndList() commands
#define BWL_ENUMCHILDREN    1
#define BWL_ENUMLIST        2


/* DOS Semaphore Structure */
typedef struct tagSEMAPHORE
  {
    DWORD semaphore;
    HQ    hqOwner;
    BYTE  cBusy;
    BYTE  bOrder;
  } SEMAPHORE;
typedef SEMAPHORE FAR *LPSEM;

#define CheckHwnd(hwnd)         TRUE
#define CheckHwndNull(hwnd)     TRUE
#define ValidateWindow(hwnd)        TRUE
#define ValidateWindowNull(hwnd)    TRUE

#define AllocP(wType,cb)    UserLocalAlloc(wType,LPTR, cb)
#define FreeP(h)            LocalFree(h)

#ifndef DEBUG
#define     LMHtoP(handle)  (*((char**)(handle)))
#else
#ifdef NO_LOCALOBJ_TAGS
#define     LMHtoP(handle)  (*((char**)(handle)))
#else
#define     LMHtoP(handle)  (*((char**)(handle))+sizeof(long))
#endif
#endif

/* Evil nasty macros to work with movable local objects */
#define     LLock(handle)   ((*(((BYTE *)(handle))+3))++)
#define     LUnlock(handle) ((*(((BYTE *)(handle))+3))--)


#define dpHorzRes       HORZRES
#define dpVertRes       VERTRES


HWND WindowHitTest(HWND hwnd, POINT pt, int FAR* ppart);

/*
 * If the handle for CF_TEXT/CF_OEMTEXT is a dummy handle then this implies
 * that data is available in the other format (as CF_OEMTEXT/CF_TEXT)
 */
#define DUMMY_TEXT_HANDLE   ((HANDLE)0xFFFF)
#define DATA_NOT_BANKED     ((HANDLE)0xFFFF)

typedef struct tagCLIP
  {
    WORD    fmt;
    HANDLE  hData;
  } CLIP;
typedef CLIP *PCLIP;

extern CLIP* pClipboard;

typedef struct tagSYSMSG
  {
    WORD     message;
    WORD     paramL;
    WORD     paramH;
    DWORD    time;
  } SYSMSG;

typedef struct tagINTERNALSYSMSG
  {
    DWORD    ismExtraInfo;  /* Additional Info */
    SYSMSG   ismOldMsg;     /* External System Msg structure */
  } INTERNALSYSMSG;

typedef struct tagINTERNALMSG
  {
    DWORD    imExtraInfo;   /* Additional Info */
    MSG      imOldMsg;      /* External App Msg structure */
  } INTERNALMSG;


typedef struct tagTIMERINFO
  {
    LONG resolution;
  } TIMERINFO;


typedef struct tagKBINFO
  {
    BYTE  Begin_First_range;    /* Values used for Far East systems */
    BYTE  End_First_range;
    BYTE  Begin_Second_range;
    BYTE  End_Second_range;
    int   stateSize;        /* size of ToAscii()'s state block */
  } KBINFO;


typedef struct tagMOUSEINFO
  {
    char  fExist;
    char  fRelative;
    int   cButton;
    int   cmsRate;
    int   xThreshold;
    int   yThreshold;
    int   cxResolution;  /* resolution needed for absolute mouse coordinate */
    int   cyResolution;
    int   mouseCommPort; /* comm port # to reserve since mouse is using it */
  } MOUSEINFO;


typedef struct tagCURSORINFO
  {
    int   csXRate;
    int   csYRate;
  } CURSORINFO;


typedef struct tagCURSORSHAPE
  {
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;  /* Bytes per row, accounting for word alignment. */
    BYTE Planes;
    BYTE BitsPixel;
  } CURSORSHAPE;
typedef CURSORSHAPE *PCURSORSHAPE;
typedef CURSORSHAPE FAR * LPCURSORSHAPE;

// Standard ICON dimensions;
#define  STD_ICONWIDTH    32
#define  STD_ICONHEIGHT   32
#define  STD_CURSORWIDTH  32
#define  STD_CURSORHEIGHT 32

typedef struct tagICONINFO
  {
    int iIconCurrent;
    int fHeightChange;
    int crw;            /* current nunber of rows. */
    int cIconInRow;     /* maximum icons in a row. */
    int cIcon;
    int wEvent;
  } ICONINFO;


/* Height and Width of the desktop pattern bitmap. */
#define CXYDESKPATTERN      16

/* System object colors. */
#define CSYSCOLORS          21

typedef struct tagSYSCLROBJECTS
  {
    HBRUSH  hbrScrollbar;
    HBRUSH  hbrDesktop;
    HBRUSH  hbrActiveCaption;
    HBRUSH  hbrInactiveCaption;
    HBRUSH  hbrMenu;
    HBRUSH  hbrWindow;
    HBRUSH  hbrWindowFrame;
    HBRUSH  hbrMenuText;
    HBRUSH  hbrWindowText;
    HBRUSH  hbrCaptionText;
    HBRUSH  hbrActiveBorder;
    HBRUSH  hbrInactiveBorder;
    HBRUSH  hbrAppWorkspace;
    HBRUSH  hbrHiliteBk;
    HBRUSH  hbrHiliteText;
    HBRUSH  hbrBtnFace;
    HBRUSH  hbrBtnShadow;
    HBRUSH  hbrGrayText;
    HBRUSH  hbrBtnText;
    HBRUSH  hbrInactiveCaptionText;
    HBRUSH  hbrBtnHilite;
  } SYSCLROBJECTS;

typedef struct tagSYSCOLORS
  {
    LONG    clrScrollbar;
    LONG    clrDesktop;
    LONG    clrActiveCaption;
    LONG    clrInactiveCaption;
    LONG    clrMenu;
    LONG    clrWindow;
    LONG    clrWindowFrame;
    LONG    clrMenuText;
    LONG    clrWindowText;
    LONG    clrCaptionText;
    LONG    clrActiveBorder;
    LONG    clrInactiveBorder;
    LONG    clrAppWorkspace;
    LONG    clrHiliteBk;
    LONG    clrHiliteText;
    LONG    clrBtnFace;
    LONG    clrBtnShadow;
    LONG    clrGrayText;
    LONG    clrBtnText;
    LONG    clrInactiveCaptionText;
    LONG    clrBtnHilite;
  } SYSCOLORS;

typedef struct tagCARET
  {
    HWND    hwnd;
    BOOL    fVisible;
    BOOL    fOn;
    int     iHideLevel;
    int     x;
    int     y;
    int     cy;
    int     cx;
    HBITMAP hBitmap;
    WORD    cmsBlink;       /* Blink time in milliseconds. */
    WORD    hTimer;
  } CARET;

/* Resource ID of system menus. */
#define ID_SYSMENU   MAKEINTRESOURCE(1)
#define ID_CLOSEMENU MAKEINTRESOURCE(2)

/* Menu Item Structure */
typedef struct tagITEM
  {
    WORD    fFlags;                 /* Item Flags. Must be first in this
                                         * structure.
                     */
    HMENU   cmdMenu;                /* Handle to a popup */
    int     xItem;
    int     yItem;
    int     cxItem;
    int     cyItem;
    int     dxTab;
    HBITMAP hbmpCheckMarkOn;    /* Bitmap for an on  check */
    HBITMAP hbmpCheckMarkOff;   /* Bitmap for an off check */
    HBITMAP hItem;          /* Handle to a bitmap or string */
    int         ulX;                    /* String: Underline start */
    int         ulWidth;                /* String: underline width */
    int         cch;                    /* String: character count */
  } ITEM;
typedef ITEM        *PITEM;
typedef ITEM FAR *LPITEM;

#define SIG_MENU    ('M' | ('U' << 8))

/* Menu Structure */
typedef struct tagMENU
  {
    struct tagMENU* pMenuNext;
    WORD    fFlags;     /* Menu Flags.*/
    WORD    signature;  // signature
    HQ      hqOwner;    // owner queue
    int         cxMenu;
    int         cyMenu;
    int     cItems;     /* Number of items in rgItems */
    HWND        hwndNotify; /* The owner hwnd of this menu */
    ITEM*   rgItems;    /* The list of items in this menu */
#ifdef JAPAN
    int     MenuMode;   /* Kanji menu mode flag */
#endif
  } MENU;
typedef MENU    *PMENU;

// Layout of first part of menu heap structure.
//
typedef struct
{
    WORD    rgwReserved[8]; // reserve 8 words for standard DS stuff.
    MENU*   pMenuList;
} MENUHEAPHEADER;

// Head of menu list (USE ONLY WITH DS == MENUHEAP)
#define PMENULIST   (((MENUHEAPHEADER*)NULL)->pMenuList)

void FAR SetMenuDS(void);
void FAR SetMenuStringDS(void);

#define MENUSYSMENU     SPACE_CHAR      /* Space character */
#define MENUCHILDSYSMENU    '-'         /* Hyphen */


/* Defines for the fVirt field of the Accelerator table structure. */
#define FVIRTKEY  TRUE      /* Assumed to be == TRUE */
#define FLASTKEY  0x80      /* Indicates last key in the table */
#define FNOINVERT 0x02
#define FSHIFT    0x04
#define FCONTROL  0x08
#define FALT      0x10

/* Accelerator Table structure */
typedef struct tagACCEL
  {
    BYTE   fVirt;       /* Also called the flags field */
    WORD   key;
    WORD   cmd;
  } ACCEL;
typedef ACCEL FAR *LPACCEL;

/* OEM Bitmap Information Structure */
typedef struct tagOEMBITMAPINFO
  {
    HBITMAP hBitmap;
    int     cx;
    int     cy;
  } OEMBITMAPINFO;

/* OEM Information Structure */
typedef struct tagOEMINFO
  {
    OEMBITMAPINFO bmFull;
    OEMBITMAPINFO bmUpArrow;
    OEMBITMAPINFO bmDnArrow;
    OEMBITMAPINFO bmRgArrow;
    OEMBITMAPINFO bmLfArrow;
    OEMBITMAPINFO bmReduce;
    OEMBITMAPINFO bmZoom;
    OEMBITMAPINFO bmRestore;
    OEMBITMAPINFO bmMenuArrow;
    OEMBITMAPINFO bmComboArrow;
    OEMBITMAPINFO bmReduceD;
    OEMBITMAPINFO bmZoomD;
    OEMBITMAPINFO bmRestoreD;
    OEMBITMAPINFO bmUpArrowD;
    OEMBITMAPINFO bmDnArrowD;
    OEMBITMAPINFO bmRgArrowD;
    OEMBITMAPINFO bmLfArrowD;
    OEMBITMAPINFO bmUpArrowI;   //  Up Arrow Inactive
    OEMBITMAPINFO bmDnArrowI;   //  Down Arrow Inactive
    OEMBITMAPINFO bmRgArrowI;   //  Right Arrow Inactive
    OEMBITMAPINFO bmLfArrowI;   //  Left Arrow Inactive
    int       cxbmpHThumb;
    int       cybmpVThumb;
    int       cxMin;
    int       cyMin;
    int       cxIconSlot;
    int       cyIconSlot;
    int       cxIcon;
    int       cyIcon;
    WORD      cxPixelsPerInch;  /* logical pixels per inch in X direction */
    WORD      cyPixelsPerInch;  /* logical pixels per inch in Y direction */
    int       cxCursor;
    int       cyCursor;
    WORD      DispDrvExpWinVer; /* Display driver expected win version no */
    WORD      ScreenBitCount; /* (BitCount * No of planes) for display */
    int       cSKanji;
    int       fMouse;
  } OEMINFO;

/* OEMINFO structure for the monochrome bitmaps */
typedef struct tagOEMINFOMONO
  {
    OEMBITMAPINFO bmAdjust;
    OEMBITMAPINFO bmSize;
    OEMBITMAPINFO bmCheck;  /* Check mark */
    OEMBITMAPINFO bmbtnbmp; /* Check boxes */
    OEMBITMAPINFO bmCorner; /* Corner of buttons */
    int       cxbmpChk;
    int       cybmpChk;
  } OEMINFOMONO;

typedef struct  tagBMPDIMENSION
  {
    int     cxBits; /* Width of the Bitmap */
    int     cyBits;     /* Height of the huge bitmap */
  } BMPDIMENSION;

/* Holds the offsets of all bitmaps in bmBits (of hdcBits). */
typedef struct tagRESINFO
  {
    /* The next 9 match resInfo */
    int     dxClose;
    int     dxUpArrow;
    int     dxDnArrow;
    int     dxRgArrow;
    int     dxLfArrow;
    int     dxReduce;
    int     dxZoom;
    int     dxRestore;
    int     dxMenuArrow;
    int     dxComboArrow;
    int     dxReduceD;
    int     dxZoomD;
    int     dxRestoreD;
    int     dxUpArrowD;
    int     dxDnArrowD;
    int     dxRgArrowD;
    int     dxLfArrowD;
    int     dxUpArrowI;     // Up Arrow Inactive.
    int     dxDnArrowI;     // Down Arrow Inactive.
    int     dxRgArrowI;     // Right Arrow Inactive.
    int     dxLfArrowI;     // Left Arrow Inactive.
    HBITMAP hbmBits;
    BMPDIMENSION  bmpDimension;
  } RESINFO;

typedef struct tagRESINFOMONO
  {
    int     dxSize;
    int     dxBtSize;
    int     dxCheck;
    int     dxCheckBoxes;
    int     dxBtnCorners;
    HBITMAP   hbmBits;
    BMPDIMENSION  bmpDimensionMono;
  } RESINFOMONO;

typedef struct tagTASK
  {
    HQ      hq;
    HWND    hwnd;
    int     ID;
    WORD    count;
    WORD    freq;
    WORD    ready;
    FARPROC lpfnTask;
  } TASK;

//**** SetWindowsHook() related definitions

typedef struct tagHOOKNODE
{
    struct tagHOOKNODE* phkNext;// Next in chain
    HOOKPROC    lpfn;       // function ptr to call (NULL if deleted during call)
    int     idHook;     // hook ID for this node
    HQ      hq;     // hq for which this hook applies
    HMODULE hmodOwner;  // Module handle that contains this hook
    BOOL    fCalled;    // Whether inside call or not
} HOOKNODE;

#define HHOOK_MAGIC  ('H' | ('K' << 8))

extern HOOKNODE* rgphkSysHooks[];
extern HOOKNODE* phkDeleted;
extern BYTE rgbHookFlags[];

LRESULT FAR CallHook(int code, WPARAM wParam, LPARAM lParam, int idHook);

BOOL FAR IsHooked(WORD idHook);
BOOL      CallKbdHook(int code, WPARAM wParam, LPARAM lParam);
BOOL      CallMouseHook(int code, WPARAM wParam, LPARAM lParam);

void      UnhookHooks(HANDLE h, BOOL fQueue);

HMODULE FAR PASCAL GetProcModule(FARPROC lpfn);
HQ    HqFromTask(HTASK htask);

void UnhookHotKeyHooks(HMODULE hmodule);

#ifdef DISABLE
#define CallVisRgnHook(pparams) (int)CallHook(0, 0, (LONG)(VOID FAR*)pparams, WH_VISRGN) // ;Internal
#endif

// DC cache related declarations

// DC Cache Entry structure (DCE)
#define CACHESIZE 5

typedef struct tagDCE
{
    struct tagDCE *pdceNext;
    HDC       hdc;
    HWND      hwnd;
    HWND      hwndOrg;
    HWND      hwndClip;
    HRGN      hrgnClip;
    DWORD     flags;
} DCE;

extern DCE  *pdceFirst;     // Pointer to first element of cache

extern HRGN hrgnGDC;        // Temp used by GetCacheDC et al
extern HRGN hrgnEWL;        // Temp used by ExcludeWindowList()
extern HRGN hrgnDCH;        // Temp used by DCHook()
extern BOOL fSiblingsTouched;

#define InternalReleaseDC(hdc)  ReleaseCacheDC(hdc, FALSE)

/* InvalidateDCCache() flag values */
#define IDC_DEFAULT     0x0001
#define IDC_CHILDRENONLY    0x0002
#define IDC_CLIENTONLY      0x0004

#define IDC_VALID       0x0007  /* ;Internal */

BOOL FAR InvalidateDCCache(HWND hwnd, WORD flags);

int CalcWindowRgn(HWND hwnd, HRGN hrgn, BOOL fClient);

BOOL FAR CalcVisRgn(HRGN hrgn, HWND hwndOrg, HWND hwndClip, DWORD flags);
BOOL FAR ReleaseCacheDC(HDC hdc, BOOL fEndPaint);
HDC  FAR GetCacheDC(HWND hwndOrg, HWND hwndClip, HRGN hrgnClip, HDC hdcMatch, DWORD flags);
HDC  FAR CreateCacheDC(HWND hwndOrg, DWORD flags);
BOOL FAR DestroyCacheDC(HDC hdc);
HWND FAR WindowFromCacheDC(HDC hdc);

BOOL FAR IntersectWithParents(HWND hwnd, LPRECT lprc);


//**************************************************************************
//
// void SetVisible(hwnd, fSet)
//
// This routine must be used to set or clear the WS_VISIBLE style bit.
// It also handles the setting or clearing of the WF_TRUEVIS bit.
//
#define SetVisible(hwnd, fSet)      \
    if (fSet)                       \
    {                               \
        SetWF((hwnd), WFVISIBLE);   \
    }                               \
    else                            \
    {                               \
        ClrWF((hwnd), WFVISIBLE);   \
        ClrFTrueVis(hwnd);          \
    }

void FAR ClrFTrueVis(HWND hwnd);

/* Saved Popup Bits structure */
typedef struct tagSPB
  {
    struct tagSPB *pspbNext;
    HWND          hwnd;
    HBITMAP       hbm;
    RECT          rc;
    HRGN          hrgn;
    WORD      flags;
  } SPB;

#define SPB_SAVESCREENBITS  0x0001  // (*lpSaveScreenBits) was called
#define SPB_LOCKUPDATE      0x0002  // LockWindowUpdate() SPB
#ifdef DISABLE
#define SPB_DRAWBUFFER      0x0004  // BeginDrawBuffer() SPB
#endif

// SPB related functions

extern SPB* pspbFirst;

extern HRGN hrgnSCR;        // Temp rgn used by SpbCheckRect() */

extern HRGN hrgnSPB1;       // More temp regions

extern HRGN hrgnSPB2;

// This macro can be used to quickly avoid far calls to the SPB code.
// In some cases it can prevent pulling in the segment that contains
// all the code.
//
#define AnySpbs()   (pspbFirst != NULL)     // TRUE if there are any SPBs

BOOL SpbValidate(SPB* pspb, HWND hwnd, BOOL fChildren);
void SpbCheckDce(DCE* pdce);
BOOL FBitsTouch(HWND hwndInval, LPRECT lprcDirty, SPB* pspb, DWORD flagsDcx);
void FAR DeleteHrgnClip(DCE* pdce);

void FAR CreateSpb(HWND hwnd, WORD flags, HDC hdcScreen);
void FAR FreeSpb(SPB* pspb);
SPB* FAR FindSpb(HWND hwnd);
void FAR SpbCheckRect(HWND hwnd, LPRECT lprc, DWORD flagsDcx);
void FAR SpbCheckHwnd(HWND hwnd);
BOOL FAR RestoreSpb(HWND hwnd, HRGN hrgnUncovered, HDC FAR* phdcScreen);
void FAR SpbCheck(void);
BOOL FAR SpbCheckRect2(SPB* pspb, HWND hwnd, LPRECT lprc, DWORD flagsDcx);

// LockWindowUpdate related stuff

extern HWND hwndLockUpdate;
extern HQ   hqLockUpdate;

void FAR InternalInvalidate(register HWND hwnd, HRGN hrgnUpdate, WORD flags);
BOOL InternalInvalidate2(HWND hwnd, HRGN hrgn, HRGN hrgnSubtract, LPRECT prcParents, WORD flags);
void _fastcall DeleteUpdateRgn(HWND hwnd);

// SmartRectInRegion return codes
//
#define RIR_OUTSIDE 0
#define RIR_INTERSECT   1
#define RIR_INSIDE  2

WORD FAR SmartRectInRegion(HRGN hrgn, LPRECT lprc);

// Function used to redraw the screen

#define RedrawScreen()              \
    InternalInvalidate(hwndDesktop, (HRGN)1,   \
        RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN)

extern HRGN hrgnInv1;       // Temp used by RedrawWindow()
extern HRGN hrgnInv2;       // Temp used by InternalInvalidate()

HDC CALLBACK InternalBeginPaint(HWND hwnd, PAINTSTRUCT FAR *lpps, BOOL fWindowDC);

// Background and frame drawing related stuff

// WM_SYNCPAINT wParam and DoSyncPaint flags

void FAR DoSyncPaint(HWND hwnd, HRGN hrgn, WORD flags);

// NOTE: the first 4 values must be as defined for backward compatibility
// reasons.  They are sent as parameters to the WM_SYNCPAINT message.
// They used to be hard-coded constants.
//
// Only ENUMCLIPPEDCHILDREN, ALLCHILDREN, and NOCHECKPARENTS are passed on
// during recursion.  The other bits reflect the current window only.
//
#define DSP_ERASE       0x0001      // Send WM_ERASEBKGND
#define DSP_FRAME       0x0002      // Send WM_NCPAINT
#define DSP_ENUMCLIPPEDCHILDREN 0x0004      // Enum children if WS_CLIPCHILDREN
#define DSP_WM_SYNCPAINT    0x0008      // Called from WM_SYNCPAINT handler
#define DSP_NOCHECKPARENTS  0x0010      // Don't check parents for update region
#define DSP_ALLCHILDREN     0x0020      // Enumerate all children.

BOOL FAR SendEraseBkgnd(HWND hwnd, HDC hdcBeginPaint, HRGN hrgnUpdate);
void SendNCPaint(HWND hwnd, HRGN hrgnUpdate);
HWND _fastcall ParentNeedsPaint(HWND hwnd);

// UpdateWindow definitions

#define UW_ENUMCHILDREN     0x0001
#define UW_VALIDATEPARENTS  0x0002

void InternalUpdateWindow(HWND hwnd, WORD flags);
void UpdateWindow2(register HWND hwnd, WORD flags);
void ValidateParents(register HWND hwnd);

// Used for UpdateWindow() calls that really shouldn't be there...
#define UpdateWindow31(hwnd)

// ScrollWindow() definitions

extern HRGN hrgnSW;
extern HRGN hrgnScrl1;
extern HRGN hrgnScrl2;
extern HRGN hrgnScrlVis;
extern HRGN hrgnScrlSrc;
extern HRGN hrgnScrlDst;
extern HRGN hrgnScrlValid;
extern HRGN hrgnScrlUpdate;

// Scroll bar definitions

typedef struct tagSBINFO
{
   int   pos;
   int   posMin;
   int   posMax;
   int   cpxThumb;
   int   cpxArrow;
   int   cpx;
   int   pxMin;
   int   cxBorder;
   int   cyBorder;
   int   nBar;
   HWND  calcHwnd; /* used to identify the window described by this info */
} SBINFO;

// The following masks can be used along with the wDisableFlags field of SB
// to find if the Up/Left or Down/Right arrow or Both are disabled;
// Now it is possible to selectively Enable/Disable just one or both the
// arrows in a scroll bar control;
#define LTUPFLAG    0x0001  // Left/Up arrow disable flag.
#define RTDNFLAG    0x0002  // Right/Down arrow disable flag.
#define SBFLAGSINDEX  6      // Index of Scroll bar flags in Wnd->rgwScroll[]

typedef struct tagSB
  {
    WND  wnd;
    int  pos;
    int  min;
    int  max;
    BOOL fVert;
    WORD wDisableFlags; // Indicates which arrow is disabled;
#ifdef DBCS_IME
    BOOL bImeStatus;    // IME status save
#endif
  } SB;

typedef SB *PSB;
typedef SB FAR *LPSB;

/* Structure for list of drivers installed by USER and opened by applications.
 */

typedef struct tagDRIVERTABLE
{
  WORD   fBusy:1;
  WORD   fFirstEntry:1;
  int    idNextDriver;      /* Next driver in load chain -1 if end */
  int    idPrevDriver;      /* Prev driver in load chain -1 if begin */
  HANDLE hModule;
  DWORD  dwDriverIdentifier;
  char   szAliasName[128];
  LRESULT (FAR * lpDriverEntryPoint)(DWORD, HDRVR, WORD, LPARAM, LPARAM);
} DRIVERTABLE;
typedef DRIVERTABLE FAR *LPDRIVERTABLE;

LRESULT FAR InternalLoadDriver(LPCSTR szDriverName,
                             LPCSTR szSectionName,
                             LPCSTR lpstrTail,
                             WORD  cbTail,
                             BOOL  fSendEnable);
WORD FAR InternalFreeDriver(HDRVR hDriver, BOOL fSendDisable);

/* Defines for InternalBroadcastDriverMessage flags */
#define IBDM_SENDMESSAGE       0x00000001
#define IBDM_REVERSE           0x00000002
#define IBDM_FIRSTINSTANCEONLY 0x00000004

LRESULT FAR InternalBroadcastDriverMessage(HDRVR, WORD, LPARAM, LPARAM, LONG);

/* Application queue structure */

#define MSGQSIZE    10

typedef struct tagQ
  {
    HQ          hqNext;
    HTASK   hTask;
    int         cbEntry;
    int         cMsgs;
    WORD        pmsgRead;
    WORD        pmsgWrite;
    WORD        pmsgMax;
    LONG        timeLast;    /* Time, position, and ID of last message */
    POINT       ptLast;
    int         idLast;
    DWORD   dwExtraInfoLast;  /* Additional info */
    WORD    unused;
    LPARAM  lParam;
    WPARAM  wParam;
    int         message;
    HWND        hwnd;
    LRESULT result;
    int         cQuit;
    int         exitCode;
    WORD        flags;
    WORD    pMsgFilterChain;
    HGLOBAL hDS;
    int         wVersion;
    HQ          hqSender;
    HQ          hqSendList;
    HQ          hqSendNext;
    WORD    cPaintsReady;
    WORD    cTimersReady;
    WORD        changebits;
    WORD        wakebits;
    WORD        wakemask;
    WORD        pResult;
    WORD        pResultSend;
    WORD        pResultReceive;
    HOOKNODE*   phkCurrent;
    HOOKNODE*   rgphkHooks[WH_CHOOKS];
    DWORD       semInput;
    HQ          hqSemNext;
    INTERNALMSG rgmsg[MSGQSIZE];
  } Q;
typedef Q FAR *LPQ;

// NOTE: These macros can be recoded to be much faster if
// hqCurrent and lpqCurrent are defined as globals that are set
// at task switch time.
//
#define Lpq(hq)     ((LPQ)MAKELP((hq), 0))
#define LpqFromHq(hq)   Lpq(hq)
#define LpqCurrent()    ((LPQ)(MAKELP(HqCurrent(), 0)))

typedef WORD ICH;

// Q flags field bits

#define QF_SEMWAIT        0x01
#define QF_INIT           0x02
#define QF_PALETTEAPP     0x04  /* This app used the palette */

// Internal GetQueueStatus() flags

#define QS_SMRESULT   0x8000
#define QS_SMPARAMSFREE   0x4000

/* Capture codes */
#define NO_CAP_CLIENT   0   /* no capture; in client area */
#define NO_CAP_SYS  1   /* no capture; in sys area */
#define CLIENT_CAPTURE  2   /* client-relative capture */
#define WINDOW_CAPTURE  3   /* window-relative capture */
#define SCREEN_CAPTURE  4   /* screen-relative capture */

// Extra bytes needed for specific window classes
//
#define CBEDITEXTRA     6
#define CBSTATICEXTRA   6
#ifdef DBCS_IME
#define CBBUTTONEXTRA   4   /* need one byte for IME status save */
#else
#define CBBUTTONEXTRA   3
#endif
#define CBMENUEXTRA 2

/* DrawBtnText codes */
#define DBT_TEXT    0x0001
#define DBT_FOCUS   0x0002

/* RIP error codes */
#define RIP_SEMCHECK        0xFFF4  /* Decimal -12 */
#define RIP_SWP             0xFFF1  /* Decimal -15 */ /* SetMultipleWindowPos */
#define RIP_MEMALLOC        0x0001   /* Insufficient memory for allocation */
#define RIP_MEMREALLOC      0x0002   /* Error realloc memory */
#define RIP_MEMFREE         0x0003   /* Memory cannot be freed */
#define RIP_MEMLOCK         0x0004   /* Memory cannot be locked */
#define RIP_MEMUNLOCK       0x0005   /* Memory cannot be unlocked */
#define RIP_BADGDIOBJECT    0x0006   /* Invalid GDI object */
#define RIP_BADWINDOWHANDLE 0x0007   /* Invalid Window handle */
#define RIP_DCBUSY          0x0008   /* Cached display contexts are busy */
#define RIP_NODEFWINDOWPROC 0x0009
#define RIP_CLIPBOARDOPEN   0x000A
#define RIP_GETDCWITHOUTRELEASE 0x000B /* App did a GetDC and destroyed window without release*/
#define RIP_INVALKEYBOARD   0x000C
#define RIP_INVALMOUSE      0x000D
#define RIP_INVALCURSOR     0x000E
#define RIP_DSUNLOCKED      0x000F
#define RIP_INVALLOCKSYSQ   0x0010
#define RIP_CARETBUSY       0x0011
#define RIP_GETCWRANGE      0x0012
#define RIP_HWNDOWNSDCS     0x0013  /* One hwnd owns all the DCs */
#define RIP_BADHQ           0x0014  /* operation on something of wrong task */
#define RIP_BADDCGRAY       0x0015  /* bad dc gray               */
#define RIP_REFCOUNTOVERFLOW  0x0016  /* Ref Count in CLS overflows */
#define RIP_REFCOUNTUNDERFLOW 0x0017  /* Ref Count in CLS becomes negative */
#define RIP_COUNTBAD          0x0018  /* Ref Count should be zero; But not so */
#define RIP_INVALIDWINDOWSTYLE 0x0019 /* Illegal window style bits were set */
#define RIP_GLOBALCLASS       0x001A /* An application that registered a global
                  * class is terminating, but the reference
                  * count is non-zero(somebody else is using
                                  * it). */
#define RIP_BADHOOKHANDLE   0x001B
#define RIP_BADHOOKID       0x001C
#define RIP_BADHOOKPROC     0x001D
#define RIP_BADHOOKMODULE   0x001E
#define RIP_BADHOOKCODE     0x001F
#define RIP_HOOKNOTALLOWED  0x0020

#define RIP_UNREMOVEDPROP   0x0021
#define RIP_BADPROPNAME     0x0022
#define RIP_BADTASKHANDLE   0x0023

#define RIP_GETSETINFOERR1    0x0027   /* Bad negative index for Get/Set/Window etc., */
#define RIP_GETSETINFOERR2    0x0028   /* Bad Positive index for Get/Set/Window etc., */

#define RIP_DIALOGBOXDESTROYWINDOWED 0x0029 /* App called DestroyWindow on a DialogBox window */
#define RIP_WINDOWIDNOTFOUND     0x002A /* Dialog control ID not found */
#define RIP_SYSTEMERRORBOXFAILED 0x002B /* Hard sys error box failed due to no hq */
#define RIP_INVALIDMENUHANDLE    0x002C /* Invalid hMenu */
#define RIP_INVALIDMETAFILEINCLPBRD 0x002D /* Invalid meta file pasted into clipboard */
#define RIP_MESSAGEBOXWITHNOQUEUE      0x002E  /* MessageBox called with no message queue initialized */
#define RIP_DLGWINDOWEXTRANOTALLOCATED 0x002F  /* DLGWINDOWEXTRA bytes not allocated for dlg box */
#define RIP_INTERTASKSENDMSGHANG       0x0030  /* Intertask send message with tasks locked */

#define RIP_INVALIDPARAM          0x0031   /* Invalid parameter passed to a function */
#define RIP_ASSERTFAILED          0x0032
#define RIP_INVALIDFUNCTIONCALLED 0x0033  /* Invalid function was called */
#define RIP_LOCKINPUTERROR        0x0034   /* LockInput called when input was already locked or when never locked.*/
#define RIP_NULLWNDPROC           0x0035   /* SetWindowLong uses a NULL wnd proc */
#define RIP_BAD_UNHOOK        0x0036   /* SetWindowsHook is used to unhook.     */
#define RIP_QUEUE_FULL            0x0037   /* PostMessage failed due to full queue. */

#ifdef DEBUG

#define DebugFillStruct DebugFillBuffer

#define DebugErr(flags, sz) \
    { static char CODESEG rgch[] = "USER: "sz; DebugOutput((flags) | DBF_USER, rgch); }

extern char CODESEG ErrAssertFailed[];

#define Assert(f)       ((f) ? TRUE : (DebugOutput(DBF_ERROR, ErrAssertFailed), FALSE))

extern BOOL fRevalidate;

#define DONTREVALIDATE() fRevalidate = FALSE;

VOID FAR CheckCbDlgExtra(HWND hwnd);

#else

#define DebugErr(flags, sz)

#define Assert(f)       FALSE

#define DONTREVALIDATE()

#define CheckCbDlgExtra(hwnd)

#endif

#define UserLogError(flags, errcode, sz)    \
        { DebugErr((flags), sz); \
          LogError(errcode, NULL); }

#define BM_CLICK        WM_USER+99
#define CH_PREFIX       '&'
#define CH_HELPPREFIX   0x08

#if defined(JAPAN) || defined(KOREA)
// Japan and Korea support both Kanji and English mnemonic characters,
// toggled from control panel.  Both mnemonics are embedded in menu
// resource templates.  The following prefixes guide their parsing.
//
#define CH_ENGLISHPREFIX    0x1E
#define CH_KANJIPREFIX      0x1F

#define KMM_ENGLISH     2       // English/Romaji menu mode
#define KMM_KANJI       3       // Kanji/Hangeul menu mode
extern int  KanjiMenuMode;
#endif

/* The total number of strings used as Button strings in MessageBoxes */
#define  MAX_MB_STRINGS    8

/* Dialog box activation border width factor. */
#define CLDLGFRAME          4
#define CLDLGFRAMEWHITE     0

/* Constants for onboard bitmap save. */
#define ONBOARD_SAVE    0x0000
#define ONBOARD_RESTORE 0x0001
#define ONBOARD_CLEAR   0x0002

/* Bitmap resource IDs */
#define BMR_ICON    1
#define BMR_BITMAP  2
#define BMR_CURSOR  3
#define BMR_DEVDEP  0
#define BMR_DEVIND  1
#define BMR_DEPIND  2

/* PID definitions */
#define get_PID               0
#define get_EMSSave_area      1
#define dont_free_banks       2
#define free_PIDs_banks       3
#define free_handle           4
#define memory_sizes          5
#define DDE_shared            6

// SetWindowPos() related structures and definitions
//
extern HRGN hrgnInvalidSum;
extern HRGN hrgnVisNew;
extern HRGN hrgnSWP1;
extern HRGN hrgnValid;
extern HRGN hrgnValidSum;
extern HRGN hrgnInvalid;

// CalcValidRects() "Region Empty" flag values
// A set bit indicates the corresponding region is empty.
//
#define RE_VISNEW   0x0001  // CVR "Region Empty" flag values
#define RE_VISOLD   0x0002  // A set bit indicates the
#define RE_VALID    0x0004  // corresponding region is empty.
#define RE_INVALID      0x0008
#define RE_SPB          0x0010
#define RE_VALIDSUM     0x0020
#define RE_INVALIDSUM   0x0040

typedef struct tagCVR       // cvr
{
    WINDOWPOS   pos;        // MUST be first field of CVR!
    int     xClientNew; // New client rectangle
    int     yClientNew;
    int     cxClientNew;
    int     cyClientNew;
    RECT    rcBlt;
    int     dxBlt;      // Distance blt rectangle is moving
    int     dyBlt;
    WORD    fsRE;       // RE_ flags: whether hrgnVisOld is empty or not
    HRGN    hrgnVisOld; // Previous visrgn
} CVR;

typedef struct tagSMWP      // smwp
{
    int     ccvr;       // Number of CVRs in the SWMP
    int     ccvrAlloc;  // Number of actual CVRs allocated in the SMWP
    BOOL    fInUse;
    WORD    signature;  // signature word for handle validation
    CVR     rgcvr[1];
} SMWP;

#define SMWP_SIG    ('W' | ('P' << 8))

#define PEMWP   HDWP

#define NEAR_SWP_PTRS
#ifdef  NEAR_SWP_PTRS

typedef SMWP* PSMWP;
typedef CVR*  PCVR;
#else

typedef SMWP FAR* PSMWP;
typedef CVR  FAR* PCVR;
#endif

BOOL  ValidateSmwp(PSMWP psmwp, BOOL FAR* pfSyncPaint);
HWND  SmwpFindActive(PSMWP psmwp);
void  SendChangedMsgs(PSMWP psmwp);
BOOL  ValidateWindowPos(WINDOWPOS FAR *ppos);
BOOL  BltValidBits(PSMWP psmwp);
BOOL  SwpCalcVisRgn(HWND hwnd, HRGN hrgn);
BOOL  CombineOldNewVis(HRGN hrgn, HRGN hrgnVisOld, HRGN hrgnVisNew, WORD crgn, WORD fsRgnEmpty);
void  CalcValidRects(PSMWP psmwp, HWND FAR* phwndNewActive);
BOOL  ValidateZorder(PCVR pcvr);
PSMWP ZOrderByOwner(PSMWP psmwp);
PSMWP AddCvr(PSMWP psmwp, HWND hwnd, HWND hwndInsertAfter, WORD flags);
BOOL  SwpActivate(HWND hwndNewActive);

void FAR HandleWindowPosChanged(HWND hwnd, WINDOWPOS FAR *lppos);
void FAR OffsetChildren(HWND hwnd, int dx, int dy, LPRECT prcHitTest);
BOOL FAR IntersectWithParents(HWND hwnd, LPRECT lprcParents);

// Preallocated buffers for use during SetWindowPos to prevent memory
// allocation failures.
//
#define CCVR_WORKSPACE      4
#define CCVR_MSG_WORKSPACE  2

#define CB_WORKSPACE     ((sizeof(SMWP) - sizeof(CVR)) + CCVR_WORKSPACE * sizeof(CVR))
#define CB_MSG_WORKSPACE ((sizeof(SMWP) - sizeof(CVR)) + CCVR_MSG_WORKSPACE * sizeof(CVR))

extern BYTE workspace[];
extern BYTE msg_workspace[];

typedef struct tagSTAT
  {
    WND wnd;
    HFONT  hFont;
    HBRUSH hBrush;
    HICON  hIcon;
  } STAT;
typedef STAT *PSTAT;

#define IsCrlf(x)       ((char)(x)==0x0D)

/* Help Engine stuff  */

typedef struct
  {
   unsigned short cbData;               /* Size of data                     */
   unsigned short usCommand;            /* Command to execute               */
   unsigned long  ulTopic;              /* Topic/context number (if needed) */
   unsigned long  ulReserved;           /* Reserved (internal use)          */
   unsigned short offszHelpFile;        /* Offset to help file in block     */
   unsigned short offabData;            /* Offset to other data in block    */
   } HLP;

typedef HLP FAR *LPHLP;

typedef HANDLE HDCS;

/* DrawFrame() Commands */
#define DF_SHIFT0       0x0000
#define DF_SHIFT1       0x0001
#define DF_SHIFT2       0x0002
#define DF_SHIFT3       0x0003
#define DF_PATCOPY      0x0000
#define DF_PATINVERT        0x0004

#define DF_SCROLLBAR        (COLOR_SCROLLBAR << 3)
#define DF_BACKGROUND       (COLOR_BACKGROUND << 3)
#define DF_ACTIVECAPTION    (COLOR_ACTIVECAPTION << 3)
#define DF_INACTIVECAPTION  (COLOR_INACTIVECAPTION << 3)
#define DF_MENU         (COLOR_MENU << 3)
#define DF_WINDOW       (COLOR_WINDOW << 3)
#define DF_WINDOWFRAME      (COLOR_WINDOWFRAME << 3)
#define DF_MENUTEXT     (COLOR_MENUTEXT << 3)
#define DF_WINDOWTEXT       (COLOR_WINDOWTEXT << 3)
#define DF_CAPTIONTEXT      (COLOR_CAPTIONTEXT << 3)
#define DF_ACTIVEBORDER     (COLOR_ACTIVEBORDER << 3)
#define DF_INACTIVEBORDER   (COLOR_INACTIVEBORDER << 3)
#define DF_APPWORKSPACE     (COLOR_APPWORKSPACE << 3)
#define DF_GRAY         (DF_APPWORKSPACE + (1 << 3))


#ifdef FASTFRAME

typedef struct   tagFRAMEBITMAP
{
    int     x;  /* Top Left co-ordinates */
    int     y;
    int     dx; /* Width of the bitmap  */
    int     dy; /* Height of the bitmap */
}   FRAMEBITMAP;

#define  FB_THICKFRAME    FALSE
#define  FB_DLGFRAME      TRUE

#define  FB_ACTIVE  0
#define  FB_INACTIVE    1

#define  FB_HORZ    0
#define  FB_VERT    1
#define  FB_DLG_HORZ    2
#define  FB_DLG_VERT    3
#define  FB_CAPTION 4

typedef struct   tagFRAMEDETAILS
{
    HBITMAP     hFrameBitmap[5][2];  /* indices explained above */
    FRAMEBITMAP ActBorderH[4];    /* Four parts of Thick frame Horz bitmap */
    FRAMEBITMAP ActBorderV[4];
    FRAMEBITMAP DlgFrameH[4];     /* Four parts of Dlg Frame Horz bitmap */
    FRAMEBITMAP DlgFrameV[4];
    FRAMEBITMAP CaptionInfo[7];
    int         clBorderWidth;
}   FRAMEDETAILS;

typedef  FRAMEBITMAP *PFRAMEBITMAP;

// Fast frame related macros
#define  FC_ACTIVEBORDER    0x01
#define  FC_INACTIVEBORDER  0x02
#define  FC_ACTIVECAPTION   0x04
#define  FC_INACTIVECAPTION 0x08
#define  FC_WINDOWFRAME     0x10

#define  FC_ACTIVEBIT       0x01
#define  FC_INACTIVEBIT         0x02
#define  FC_STATUSBITS      (FC_ACTIVEBIT | FC_INACTIVEBIT)

#endif  /* FASTFRAME */

// The following defines the components of nKeyboardSpeed
#define KSPEED_MASK 0x001F      // Defines the key repeat speed.
#define KDELAY_MASK     0x0060      // Defines the keyboard delay.
#define KDELAY_SHIFT    5


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Secret Imports -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

#ifndef   MSDWP

/* Imported from Kernel. */
HQ     FAR GetTaskQueue(HTASK);
HQ     FAR SetTaskQueue(HTASK, HQ);
void   FAR LockCurrentTask(BOOL);
HANDLE FAR emscopy();
//void   FAR ExitKernel(int);
int    FAR LocalCountFree(void);
int    FAR LocalHeapSize(void);
BOOL   FAR IsWinoldapTask(HTASK);
WORD   FAR GetExeVersion(void);
DWORD  FAR GetTaskDS(void);
void   FAR SetTaskSignalProc(WORD, FARPROC);
DWORD  FAR GetHeapSpaces(HMODULE hModule);
int    FAR IsScreenGrab(void);

/* Imported from GDI. */
int API IntersectVisRect(HDC, int, int, int, int);
int API ExcludeVisRect(HDC, int, int, int, int);
int API SelectVisRgn(HDC, HRGN);
int API SaveVisRgn(HDC);
int API RestoreVisRgn(HDC);
HRGN    API InquireVisRgn(HDC);
HDCS    API GetDCState(HDC);
BOOL    API SetDCState(HDC, HDCS);
HFONT   API GetCurLogFont(HDC);       // From GDI
#define     SwapHandle(foo)

HANDLE  FAR GDIInit2(HANDLE, HANDLE);
HRGN    API GetClipRgn(HDC);
HBITMAP FAR CreateUserBitmap(int, int, int, int, LONG);
void    FAR UnRealizeObject(HBRUSH);
void    FAR LRCCFrame(HDC, LPRECT, HBRUSH, DWORD);
void    FAR Death(HDC);
void    FAR Resurrection(HDC, LONG, LONG, LONG);
void    FAR DeleteAboveLineFonts(void);
BOOL    FAR GDIInitApp(void);
HBITMAP FAR CreateUserDiscardableBitmap(HDC, int, int);
void    FAR FinalGDIInit(HBRUSH);
void    FAR GDIMoveBitmap(HBITMAP);
BOOL    FAR IsValidMetaFile(HMETAFILE);
#define     GDIMoveBitmap(d1)

#endif      /*  MSDWP  */


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DS Global Variables (from WINDS.C)                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

//***** Initialization globals

extern HINSTANCE hInstanceWin;
extern HMODULE hModuleWin;

//WORD rgwSysMet[]; // Defined in winmisc2.asm

//***** System mode globals

extern BOOL    fDialog;            // Dialog box is active
extern BOOL    fEndSession;        // Shutting down system
extern BOOL    fTaskIsLocked;          // LockTask() called

extern BOOL    fMessageBox;        // hard message box active
extern HWND    hwndSysModal;

extern HQ      hqAppExit;              // hq of app in app termination code

//***** System option settings globals

extern int     nKeyboardSpeed;         // keyboard repeat rate

extern int     iScreenSaveTimeOut;     // screen saver timeout

extern BOOL    fHires;             /* VERTRES > 300?               */
extern BOOL    fPaletteDisplay;        /* Are we on a palette display driver?      */
extern BOOL    fEdsunChipSet;          /* Edsun vga chip set?              */

//***** Window manager globals

extern HWND    hwndDesktop;        // Desktop window

extern PCLS    pclsList;           // List of registered classes

extern PBWL    pbwlCache;          // BuildWindowList() globals
extern PBWL    pbwlList;

//***** Input globals

extern BOOL    fThunklstrcmp;      // if TRUE we thunk to Win32

extern WORD    idSysPeek;          /* ID in sys queue of msg being looked at   */

extern DWORD   timeLastInputMessage;     // Time of the last keyboard, mouse, or
                  // other input message.

extern HWND    hwndCursor;

extern HWND    hwndDblClk;         // doubleclick parsing
extern RECT    rcDblClk;
extern WORD    dtDblClk;
extern WORD    msgDblClk;
extern DWORD   timeDblClk;

extern int     defQueueSize;           // Default msg queue size

extern HTASK   hTaskLockInput;         /* Task which has called LockInput() */

extern KBINFO  keybdInfo;
extern BYTE    *pState;            // Pointer to buffer for ToAscii

extern BOOL    fShrinkGDI;         /* Does GDI's heap needs shrinking?         */
extern BOOL    fLockNorem;         /* PeekMsg NOREMOVE flag            */

//***** Activation/Focus/Capture related globals

extern HWND    hwndActive;
extern HWND    hwndActivePrev;

extern HWND    hwndFocus;

extern int     codeCapture;
extern HWND    hwndCapture;

//***** SetWindowPos() related globals

extern HRGN hrgnInvalidSum;        // Temps used by SetWindowPos()
extern HRGN hrgnVisNew;
extern HRGN hrgnSWP1;
extern HRGN hrgnValid;
extern HRGN hrgnValidSum;
extern HRGN hrgnInvalid;

#ifdef LATER
// Are these still needed now that SysErrorBox() is working?
#endif

extern BYTE workspace[];           // Buffers used to prevent mem alloc
extern BYTE msg_workspace[];           // failures in messagebox

//***** General graphics globals

extern HDC     hdcBits;            /* DC with User's bitmaps                   */
extern HDC     hdcMonoBits;        /* DC with User's MONO bitmaps              */

extern OEMINFO         oemInfo;
extern OEMINFOMONO     oemInfoMono;

extern RESINFO         resInfo;
extern RESINFOMONO     resInfoMono;

extern SYSCLROBJECTS   sysClrObjects;
extern SYSCOLORS       sysColors;

extern HFONT   hFontSys;        // alias for GetStockObject(SYSTEM_FONT);
extern HFONT   hFontSysFixed;       // alias for GetStockObject(SYSTEM_FIXED_FONT);
extern HBRUSH  hbrWhite;        // alias for GetStockObject(WHITE_BRUSH);
extern HBRUSH  hbrBlack;        // alias for GetStockObject(BLACK_BRUSH);
extern HPALETTE hPalDefaultPalette; // alias for GetStockObject(DEFAULT_PALETTE);

//***** DC Cache related globals

extern DCE*    pdceFirst;       /* Ptr to first entry in cache */

extern HRGN    hrgnEWL;            // Temp used by ExcludeWindowList()
extern HRGN    hrgnGDC;          // Temp used by GetCacheDC() et al
extern HRGN    hrgnDCH;          // Temp used by DCHook()

extern HRGN    hrgnNull;           // empty rgn
extern HRGN    hrgnScreen;         // rcScreen-sized rgn

extern HDCS    hdcsReset;

extern HDC     hdcScreen;

//***** Begin/EndDrawBuffer() globals

#ifdef DISABLE
extern HWND    hwndBuffer;
extern HBITMAP hbmBuffer;
extern HBITMAP hbmBufferSave;
extern int     cxBuffer;
extern int     cyBuffer;
extern int     dxBuffer;
extern DCE*    pdceBuffer;
extern int     dxBufferVisRgn;
extern int     dyBufferVisRgn;
extern BOOL    fBufferFlushed;
extern RECT    rcBuffer;

extern HDCS    hdcsMemReset;
#endif

//***** LockWindowUpdate related globals

extern HQ      hqLockUpdate;
extern HWND    hwndLockUpdate;

//***** SPB related globals

extern SPB     *pspbFirst;

extern HRGN    hrgnSCR;          // Temp used by SpbCheckRect()
extern HRGN    hrgnSPB1;
extern HRGN    hrgnSPB2;

extern HRGN    hrgnInv0;                 // Temps used by InternalInvalidate()
extern HRGN    hrgnInv1;
extern HRGN    hrgnInv2;

//***** General Metrics

extern RECT    rcScreen;        // Screen rectangle
extern int     cxScreen;        // Screen height/width
extern int     cyScreen;

extern BOOL    fBeep;             /* Warning beeps allowed?           */

extern int     cxSysFontChar;       // System font metrics
extern int     cxSysFontOverhang;
extern int     cySysFontAscent;
extern int     cySysFontChar;
extern int     cySysFontExternLeading;

extern int     cxBorder;        // Nominal border width/height
extern int     cyBorder;

extern int     cyCaption;       // height of caption

extern int     cxSize;          // dimensions of system menu bitmap
extern int     cySize;

extern int     cyHScroll;       // scroll bar dimensions
extern int     cxVScroll;

extern int     cxSlot;          // icon slot dimensions
extern int     cySlot;

//***** ScrollWindow/ScrollDC related globals

extern HRGN    hrgnSW;           // Temps used by ScrollDC/ScrollWindow
extern HRGN    hrgnScrl1;
extern HRGN    hrgnScrl2;
extern HRGN    hrgnScrlVis;
extern HRGN    hrgnScrlSrc;
extern HRGN    hrgnScrlDst;
extern HRGN    hrgnScrlValid;
extern HRGN    hrgnScrlUpdate;

//***** Clipboard globals

extern int     cNumClipFormats;      // Number of formats in clipboard
extern CLIP    *pClipboard;      // Clipboard data
extern HQ      hqClipLock;       // hq of app accessing clipboard
extern HWND    hwndClipOwner;        // clipboard owner
extern HWND    hwndClipViewer;       // clipboard viewer
extern BOOL    fClipboardChanged;    // TRUE if DrawClipboard needs to be called
extern BOOL    fDrawingClipboard;    // TRUE if inside DrawClipboard()
extern HWND    hwndClipOpen;         // hwnd of app accessing clipboard
extern BOOL    fCBLocked;        /* Is clibboard locked? */

//***** Fast frame drawing globals

#ifdef FASTFRAME
extern BOOL    fFastFrame;
extern FRAMEDETAILS   Frame;
#endif  /* FASTFRAME */

//***** WinOldAppHackoMaticFlags

extern WORD    winOldAppHackoMaticFlags;   /* Flags for doing special things for
                                       winold app */
//***** TaskManager exec globals

extern PSTR    pTaskManName;           // Task manager file name

//***** atom management globals

extern HANDLE  hWinAtom;           // global atom manager heap

//***** WM_HOTKEY globals

extern PSTR    pHotKeyList;  /* Pointer to list of hot keys in system. */
extern int     cHotKeyCount;       /* Count of hot keys in list. */

//***** WinHelp() globals

extern WORD    msgWinHelp;

//***** SetWindowsHook() system hook table

extern HOOKNODE*  rgphkSysHooks[];
extern HOOKNODE*  phkDeleted;

//***** Driver management globals

extern int     cInstalledDrivers;      /* Count of installed driver structs allocated*/
extern HDRVR  hInstalledDriverList;   /* List of installable drivers */
extern int     idFirstDriver;              /* First driver in load chain */
extern int     idLastDriver;               /* Last driver in load chain */

//***** Display driver globals

extern HINSTANCE hInstanceDisplay;

extern BOOL    fOnBoardBitmap;         /* Can display save bitmaps onboard?    */
extern BOOL    (CALLBACK *lpSaveBitmap)(LPRECT lprc, WORD flags);
extern VOID    (CALLBACK *lpDisplayCriticalSection)(BOOL fLock);
extern VOID    (CALLBACK *lpWin386ShellCritSection)(VOID);
typedef int   (FAR *FARGETDRIVERPROC)(int, LPCSTR);
extern FARGETDRIVERPROC      lpfnGetDriverResourceId;

//***** Comm driver definitions and globals

// Comm driver constants
//
#define LPTx     0x80   /* Mask to indicate cid is for LPT device   */
#define LPTxMask 0x7F   /* Mask to get      cid    for LPT device   */

#define PIOMAX  3   /* Max number of LPTx devices in high level */
#define CDEVMAX 10  /* Max number of COMx devices in high level */
#define DEVMAX  (CDEVMAX+PIOMAX) /* Max number of devices in high level */

// qdb - queue definition block
//
typedef struct {
    char far    *pqRx;                  /* pointer to rx queue          */
    int         cbqRx;                  /* size of RX Queue in bytes    */
    char far    *pqTx;                  /* Pointer to TX Queue          */
    int         cbqTx;                  /* Size of TX Queue in bytes    */
} qdb;

// cinfo - Communications Device Information
//
typedef struct
{
    WORD   fOpen    : 1;       /* Device open flag         */
    WORD   fchUnget : 1;       /* Flag for backed-up character */
    WORD   fReservedHardware:1;    /* Reserved for hardware (mouse etc) */
    HTASK  hTask;          /* Handle to task who opened us */
    char   chUnget;        /* Backed-up character      */
    qdb    qdbCur;         /* Queue information        */
} cinfo;

extern cinfo rgcinfo[];

extern int (FAR PASCAL *lpCommWriteString)(int, LPCSTR, WORD);
                   /* Ptr to the comm driver's
                * commwritestring function. Only
                * exists in 3.1 drivers.
                */
extern int (FAR PASCAL *lpCommReadString)(int, LPSTR, WORD);
                   /* Ptr to the comm driver's
                * commreadstring function. Only
                * exists in 3.1 drivers.
                */
extern BOOL (FAR PASCAL *lpCommEnableNotification)(int, HWND, int, int);
                  /* Ptr to the comm driver's
                   * EnableNotification function.
                   * Only exists in 3.1 drivers.
                   */

//***** PenWinProc globals
/* Ptr to register us as pen aware dlg box
 */
extern VOID (CALLBACK *lpRegisterPenAwareApp)(WORD i, BOOL fRegister);


//***** Resource handler globals

extern RSRCHDLRPROC lpDefaultResourceHandler;

//***** NLS related globals

extern HINSTANCE hLangDrv;    /* The module handle of the language driver */
extern FARPROC  fpLangProc;  /* The entry point into the language driver */

#ifdef DBCS_IME
extern HINSTANCE hWinnls;     /* WINNLS.DLL module handle */
#endif

//***** Caret globals

extern CARET   caret;
extern HQ      hqCaret;

//***** Cursor globals

extern CURSORINFO cursInfo;

#ifdef LATER
// Is this array big enough?
#endif

extern HCURSOR rghCursor[];

extern HBITMAP hbmCursorBitmap;        /* Pre created bitmap for SetCursor */
extern HGLOBAL hPermanentCursor;       /* Precreated permanent cursor resource */

extern HCURSOR hCurCursor;

extern HCURSOR hCursNormal;
extern HCURSOR hCursUpArrow;
extern HCURSOR hCursIBeam;
extern HCURSOR hCursSizeAll;

//INT iLevelCursor; NOTE: overlays sys metrics array (winmisc2.asm)

//***** Icon globals

extern HICON   hIconBang;
extern HICON   hIconHand;
extern HICON   hIconNote;
extern HICON   hIconQues;
extern HICON   hIconSample;
extern HICON   hIconWarn;
extern HICON   hIconErr;

extern HBITMAP hbmDrawIconMono;        /* Pre created bitmaps for drawicon */
extern HBITMAP hbmDrawIconColor;       /* Pre created bitmaps for drawicon */

extern HTASK   hTaskGrayString;      /* Task in graystring */

//***** Desktop/Wallpaper globals

extern HBITMAP hbmDesktop;         /* Monochrome Desktop pattern */
extern HBITMAP hbmWallpaper;           /* Bitmap that will be drawn on the desktop */

//***** Window move/size tracking globals

extern RECT    rcDrag;
extern RECT    rcWindow;
extern RECT    rcParent;
extern WORD    cmd;
extern HICON   hdragIcon;
extern BOOL    fTrack;
extern int     dxMouse;
extern int     dyMouse;
extern int     impx;
extern int     impy;
extern HWND    hwndTrack;
extern BOOL    fInitSize;
extern POINT   ptMinTrack;
extern POINT   ptMaxTrack;
extern BOOL    fmsKbd;
extern POINT   ptRestore;
extern HCURSOR hIconWindows;           /* Cool windows icon */
extern BOOL    fDragFullWindows;       /* Drag xor rect or full windows */

/* Added flag to stop anyone from setting the cursor while
 * we are moving the hDragIcon.  This was done to fix a bug in micrografix
 * Draw (They are doing a Setcursor() whenever they get a paint message).
 */
extern BOOL    fdragIcon;        // Prevent SetCursor while dragging icon

/* When an iconic window is moved around with a mouse, IsWindowVisible() call
 * returns FALSE! This is because, the window is internally hidden and what is
 * visible is only a mouse cursor! But how will the Tracer guys know this?
 * They won't! So, when an Icon window is moved around, its hwnd is preserved
 * in this global and IsWindowVisible() will return a true for
 * this window!
 */
extern HWND    hwndDragIcon;

//***** MessageBox globals

extern int     cntMBox;            // Nesting level for overlap tiling of mboxes
extern WORD    wDefButton;         // index of current default button
extern WORD    wMaxBtnSize;        // width of biggest button in any message box

//***** Size border metric globals

extern int     clBorder;           /* # of logical units in window frame       */
extern int     cxSzBorder;         /* Window border width (cxBorder*clBorder)  */
extern int     cySzBorder;         /* Window border height (cyBorder*clBorder) */
extern int     cxSzBorderPlus1;        /* cxBorder*(clBorder+1). We overlap a line */
extern int     cySzBorderPlus1;        /* cyBorder*(clBorder+1). We overlap a line */

//***** Window tiling/cascading globals

extern int     cxyGranularity; /* Top-level window grid granularity */
extern int     cyCWMargin;     /* Space on top of toplevel window 'stack'  */
extern int     cxCWMargin;     /* Space on right of toplevel window 'stack'*/
extern int     iwndStack;

extern int     cxHalfIcon;         // rounding helpers for icon positioning
extern int     cyHalfIcon;

//***** Alt-tab switching globals

extern HWND    hwndAltTab;
extern HWND    hwndSwitch;
extern HWND    hwndKbd;
extern BOOL    fFastAltTab;        /* Don't use Tandy's switcher? */
extern BOOL    fInAltTab;

//***** Icon title globals

extern int     cyTitleSpace;
extern BOOL    fIconTitleWrap;         /* Wrap icon titles or just use single line? */
extern LOGFONT iconTitleLogFont;       /* LogFont struct for icon title font */
extern HFONT   hIconTitleFont;       /* Font used in icon titles */

//***** GrayString globals

extern HBRUSH  hbrGray;          // GrayString globals.
extern HBITMAP hbmGray;
extern HDC     hdcGray;
extern int     cxGray;           // current dimensions of hbmGray
extern int     cyGray;

//***** WM_GETMINMAXINFO globals

extern POINT   rgptMinMaxWnd[];
extern POINT   rgptMinMax[];

//***** Menu globals

extern int     menuSelect;
extern int     mnFocus;

extern HANDLE  hMenuHeap;        /* Menu heap */
extern _segment menuBase;
extern HANDLE  hMenuStringHeap;
extern _segment menuStringBase;


//PPOPUPMENU pGlobalPopupMenu;        // mnloop.c

extern HWND    hwndRealPopup;

extern BOOL    fMenu;            /* Using a menu?                */
extern BOOL    fSysMenu;
extern BOOL    fInsideMenuLoop;      /* MenuLoop capture?            */

extern BOOL    fMenuStatus;
extern int     iActivatedWindow;/* This global is examined in the menu loop
                 * code so that we exit from menu mode if
                 * another window was activated while we were
                 * tracking menus.  This global is incremented
                 * whenever we activate a new window.
                 */
extern WORD    iDelayMenuShow;         /* Delay till the hierarchical menu is shown*/
extern WORD    iDelayMenuHide;         /* Delay till the hierarchical menu is hidden
                   when user drags outside of it */
extern HMENU   hSysMenu;

extern HBITMAP hbmSysMenu;
extern RECT    rcSysMenuInvert;

//***** Scroll bar globals

extern ATOM    atomScrollBar;          /* Atom for the scrollbar control wnd class */
extern HWND    hwndSB;
extern HWND    hwndSBNotify;
extern HWND    hwndSBTrack;
extern int     dpxThumb;
extern int     posOld;
extern int     posStart;
extern int     pxBottom;
extern int     pxDownArrow;
extern int     pxLeft;
extern int     pxOld;
extern int     pxRight;
extern int     pxStart;
extern int     pxThumbBottom;
extern int     pxThumbTop;
extern int     pxTop;
extern int     pxUpArrow;
extern BOOL    fHitOld;
extern int     cmdSB;
extern VOID (*pfnSB)(HWND, WORD, WPARAM, LPARAM);
extern RECT    rcSB;
extern RECT    rcThumb;
extern RECT    rcTrack;
extern BOOL    fTrackVert;
extern BOOL    fCtlSB;
extern WORD    hTimerSB;
extern BOOL    fVertSB;
extern SBINFO  *psbiSB;
extern SBINFO  sbiHorz;
extern SBINFO  sbiVert;
extern int     cmsTimerInterval;

//***** Control globals

extern ATOM atomSysClass[];

//***** Constant strings

extern char    szUNTITLED[];
extern char    szERROR[];
extern char    szOK[];
extern char    szCANCEL[];
extern char    szABORT[];
extern char    szRETRY[];
extern char    szIGNORE[];
extern char    szYYES[];
extern char    szCLOSE[];
extern char    szNO[];

extern char    szAM[];
extern char    szPM[];
extern PSTR    pTimeTagArray[];

extern char    szAttr[];
extern char    szOEMBIN[];
extern char    szDISPLAY[];
extern char    szOneChar[];
extern char    szSLASHSTARDOTSTAR[];
extern char    szYes[];
extern char    szNullString[];

#ifdef DEBUG

extern char CODESEG ErrAssertFailed[];
extern char CODESEG ErrInvalParam[];

#endif

#ifdef JAPAN
extern char    szJWordBreak[];      // Japanese word breaking char table
#endif

#ifdef KOREA
void   FAR SetLevel(HWND);
BOOL   FAR RequestHanjaMode(HWND, LPSTR);
WORD   FAR PASCAL TranslateHangeul(WORD);
#endif

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Global Variables from ASM files                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

extern BYTE rgbKeyState[];
extern int  iLevelCursor;
extern WORD rgwSysMet[];

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  INTDS interrupt-accessible globals
/*                                                                          */
/*--------------------------------------------------------------------------*/

extern BOOL INTDSSEG fInt24;
extern BOOL INTDSSEG fMouseMoved;
extern BOOL INTDSSEG fEnableInput;
extern BOOL INTDSSEG fSwapButtons;
extern BOOL INTDSSEG fQueueDirty;
extern BOOL INTDSSEG fInScanTimers;

extern BYTE INTDSSEG vKeyDown;
extern BYTE INTDSSEG TimerTable[];
extern BYTE INTDSSEG rgbAsyncKeyState[];

extern BYTE* INTDSSEG TimerTableMax;

extern char INTDSSEG szDivZero[];
extern char INTDSSEG szNull[];
extern char INTDSSEG szSysError[];


extern DWORD   INTDSSEG tSysTimer;

#ifdef DOS30
extern INTDSSEGPROC INTDSSEG lpSysProc;
#endif

extern HANDLE INTDSSEG hSysTimer;

extern TIMERINFO INTDSSEG timerInfo;

extern  WORD __WinFlags;
#define WinFlags    ((WORD)(&__WinFlags))

// Input globals

#ifdef DISABLE
extern WORD modeInput;
#endif

extern HQ   INTDSSEG hqSysLock;      /* HQ of guy who is looking at current event */
extern WORD INTDSSEG idSysLock;   /* Msg ID of event that is locking sys queue */
extern POINT INTDSSEG ptTrueCursor;
extern POINT INTDSSEG ptCursor;
extern RECT  INTDSSEG rcCursorClip;

extern WORD INTDSSEG MouseSpeed;
extern WORD INTDSSEG MouseThresh1;
extern WORD INTDSSEG MouseThresh2;
extern WORD INTDSSEG cMsgRsrv;
extern WORD INTDSSEG x_mickey_rate;
extern WORD INTDSSEG y_mickey_rate;
extern WORD INTDSSEG cur_x_mickey;
extern WORD INTDSSEG cur_y_mickey;
extern WORD INTDSSEG cxScreenCS;
extern WORD INTDSSEG cyScreenCS;
extern WORD INTDSSEG cQEntries;
extern WORD INTDSSEG dtSysTimer;

extern DWORD INTDSSEG dtJournal;
extern WORD INTDSSEG msgJournal;
extern BOOL INTDSSEG fJournalPlayback;

extern WORD INTDSSEG rgMsgUpDowns[];
extern DWORD INTDSSEG lpMouseStack;
extern LPVOID INTDSSEG prevSSSP;
extern BYTE  INTDSSEG nestCount;

extern WORD INTDSSEG cHotKeyHooks;

extern HQ   INTDSSEG hqActive;
extern HQ   INTDSSEG hqList;
extern HQ   INTDSSEG hqCursor;
extern HQ   INTDSSEG hqSysQueue;
extern HQ   INTDSSEG hqSysModal;
extern HQ   INTDSSEG hqMouse;
extern HQ   INTDSSEG hqKeyboard;
extern HQ   INTDSSEG hqCapture;

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Assembly Function Declarations                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

#ifdef WOWEDIT
void FAR LCopyStruct(CONST VOID FAR* lpSrc, LPVOID lpDest, WORD cb);
#else
/*
 why is this required? Its here for the intrinsic pragma
 to recognize memcpy ... jonle on a saturday!
*/
#ifndef WOWDBG
LPVOID	memcpy(LPVOID lpDst, LPVOID lpSrc, int cb);
#endif

#pragma intrinsic(memcpy)
#define LCopyStruct(s,d,n) memcpy((LPVOID)(d),(LPVOID)(s),(int)(n))
#endif
WORD FAR GetAppVer(void);

#ifndef MSDWP

/* Suppport routines for separate segment stuff. */
#undef min
#undef max
#define min(a, b)   ((int)(a) < (int)(b) ? (int)(a) : (int)(b))
#define max(a, b)   ((int)(a) > (int)(b) ? (int)(a) : (int)(b))
#define umin(a, b)  ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define umax(a, b)  ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

int    FAR MultDiv(WORD a, WORD b, WORD c);
void   FAR LFillStruct(LPVOID, WORD, WORD);
HDC    FAR GetClientDc(void);
HQ     FAR HqCurrent(void);
BOOL   FAR ActivateWindow(HWND, WORD);

BOOL  CheckHwndFilter(HWND, HWND);
BOOL  CheckMsgFilter(WORD, WORD, WORD);
BOOL  WriteMessage(HQ, LONG, WORD, WORD, HWND, DWORD);
BOOL  ReceiveMessage(VOID);
VOID  FlushSentMessages(VOID);
LPSTR  WINAPI lstrcpyn(LPSTR, LPCSTR, int);

#define PSTextOut(a, b, c, d, e)  TextOut(a, b, c, d, e)
#define PSGetTextExtent(a, b, c) GetTextExtent(a, b, c)
#define PSFillRect(a, b, c) FillRect(a, b, c)
#define PSInvertRect(a, b)  InvertRect(a, b)
WORD   FAR GetNextSysMsg(WORD, INTERNALSYSMSG FAR *);
void   FAR SkipSysMsg(SYSMSG FAR *, BOOL);

void       TransferWakeBit(WORD);
void       ClearWakeBit(WORD, BOOL);
void       SetWakeBit(HQ, WORD);
void   FAR FarSetWakeBit(HQ, WORD);
void   FAR InitSysQueue(void);
BOOL   FAR CreateQueue(int);
void       DeleteQueue(void);
void       SuspendTask(void);
void       ReleaseTask(void);

void   FAR GlobalInitAtom(void);

void       MoveRect(LONG);
void       SizeRect(LONG);

BOOL   FAR SysHasKanji(void);

void   FAR SetDivZero(void);

int    FAR FindCharPosition(LPCSTR, char);

void   FAR OEMSetCursor(LPSTR);
void   FAR SetFMouseMoved(void);
BOOL       AttachDC(HWND);
BOOL       LastApplication(void);
void       CheckCursor(HWND);
void   FAR IncPaintCount(HWND);
void   FAR DecPaintCount(HWND);
void   FAR DeleteProperties(HWND);
void   FAR DestroyTimers(HQ, HWND);

int    FAR InquireSystem(int, int);
int    FAR EnableKeyboard(FARPROC, LPSTR);
int    FAR InquireKeyboard(LPSTR);
void   FAR DisableKeyboard(void);
int    FAR EnableMouse(FARPROC);
int    FAR InquireMouse(LPSTR);
void   FAR DisableMouse(void);
int    FAR InquireCursor(LPSTR);
void   FAR EnableSystemTimers(void);
void   FAR DisableSystemTimers(void);
void   FAR CreateSystemTimer(int, TIMERPROC);
WORD   FAR SetSystemTimer(HWND, int, int, TIMERPROC);
BOOL   FAR KillSystemTimer(HWND, int);

void   FAR CrunchX2(CURSORSHAPE FAR *, CURSORSHAPE FAR *, int, int);
void   FAR CrunchY(CURSORSHAPE FAR *, CURSORSHAPE FAR *, int, int, int);

void   FAR MenuBarDraw(HWND hwnd, HDC hdc, int cxFrame, int cyFrame);

BOOL   FAR ReadMessage(HQ, LPMSG, HWND, WORD, WORD, BOOL);

int    GetCurrentDrive(void);
int    GetCurrentDirectory(LPSTR, int);
int    SetCurrentDrive(int);
int    SetCurrentDirectory(LPCSTR);
BOOL       FFirst(LPSTR, LPSTR, WORD);
BOOL       FNext(LPSTR, WORD);

FAR    DestroyAllWindows(void);

BOOL   FAR LockWindowVerChk(HWND);

#ifndef  NOFASTFRAME
void  FAR SplitRectangle(LPRECT, LPRECT, int, int); /* WinRect.asm */
#endif

#endif  /* MSDWP */

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Internal Function Declarations                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

#ifndef MSDWP

LRESULT CALLBACK ButtonWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK StaticWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK TitleWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK SwitchWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK DesktopWndProc(HWND hwndIcon, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MenuWindowProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT FAR  EditWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK LBoxCtlWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK ComboBoxCtlWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK SBWndProc(PSB psb, WORD message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MDIClientWndProc(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);

void FAR SkipSM2(void);
HWND FAR GetFirstTab(HWND hwnd);
CONST BYTE FAR* SkipSz(CONST BYTE FAR *lpsz);
void FAR DlgSetFocus(HWND hwnd);
HWND FAR PrevChild(HWND hwndDlg, HWND hwnd);
HWND FAR NextChild(HWND hwndDlg, HWND hwnd);
HWND FAR GetFirstLevelChild(HWND hwndDlg, HWND hwndLevel);
void FAR CheckDefPushButton(HWND hwndDlg, HWND hwndOldFocus, HWND hwndNewFocus);
HWND FAR GotoNextMnem(HWND hwndDlg, HWND hwndStart, char ch);
int  FAR FindMnemChar(LPSTR lpstr, char ch, BOOL fFirst, BOOL fPrefix);
int  FAR FindNextValidMenuItem(PMENU pMenu, int i, int dir, BOOL fHelp);
BOOL CALLBACK MenuPrint(HDC hdc, LPARAM lParam, int cch);
int  FAR MenuBarCompute(HMENU hMenu, HWND hwndNotify, int yMenuTop, int xMenuLeft, int cxMax);
HMENU CALLBACK LookupMenuHandle(HMENU hMenu, WORD cmd);
BOOL CALLBACK StaticPrint(HDC hdc, LPRECT lprc, HWND hwnd);

HICON FAR ColorToMonoIcon(HICON);
HGLOBAL CALLBACK LoadCursorIconHandler(HGLOBAL hRes, HINSTANCE hResFile, HRSRC hResIndex);
HGLOBAL CALLBACK LoadDIBCursorHandler(HGLOBAL hRes, HINSTANCE hResFile, HRSRC hResIndex);
HGLOBAL CALLBACK LoadDIBIconHandler(HGLOBAL hRes, HINSTANCE hResFile, HRSRC hResIndex);
void CallOEMCursor(void);
void FAR DestroyClipBoardData(void);
BOOL FAR SendClipboardMessage(int message);
void FAR DrawClipboard(void);
PCLIP FAR FindClipFormat(WORD format);
BOOL         IsDummyTextHandle(PCLIP pClip);
HANDLE       InternalSetClipboardData(WORD format, HANDLE hData);

PPCLS FAR GetClassPtr(LPCSTR lpszClassName, HINSTANCE hInstance, BOOL fUserModule);
PPCLS     GetClassPtrASM(ATOM, HMODULE, BOOL);
void FAR DelWinClass(PPCLS  ppcls);

VOID CALLBACK CaretBlinkProc(HWND hwnd, WORD message, WORD id, DWORD time);
void FAR InternalHideCaret(void);
void FAR InternalShowCaret(void);
void FAR InternalDestroyCaret(void);
HDC  FAR GetScreenDC(void);
PBWL FAR BuildHwndList(HWND hwnd, int flags);
void FAR FreeHwndList(PBWL pbwl);
void CALLBACK  DrawFrame(HDC hdc, LPRECT lprect, int clFrame, int cmd);
void FAR RedrawFrame(HWND hwnd);
void FAR BltColor(HDC, HBRUSH, HDC, int, int, int, int, int, int, BOOL);
void FAR EnableInput(void);
void FAR DisableInput(void);
void FAR CopyKeyState(void);
void CALLBACK  EnableOEMLayer(void);
void CALLBACK  DisableOEMLayer(void);
void FAR ColorInit(void);
BOOL FAR SetKeyboardSpeed(BOOL fInquire);
void FAR InitBorderSysMetrics(void);
void FAR InitSizeBorderDimensions(void);
void FAR SetMinMaxInfo(void);

// Returns TRUE if a GetDC() will return an empty visrgn or not
// (doesn't take into account being clipped away; just checks WFVISIBE
// and WFMINIMIZED)
//
BOOL FAR IsVisible(HWND hwnd, BOOL fClient);

// Returns TRUE if hwndChild == hwndParent or is one of its children.
//
BOOL FAR IsDescendant(HWND hwndParent, HWND hwndChild);

void FAR SetRedraw(HWND hwnd, BOOL fRedraw);
HBRUSH CALLBACK GetControlColor(HWND hwndParent, HWND hwndCtl, HDC hdc, WORD type);
HBRUSH CALLBACK GetControlBrush(HWND hwnd, HDC hdc, WORD type);
void FAR StoreMessage(LPMSG lpMsg, HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam, DWORD time);
LONG FAR GetPrefixCount(LPCSTR lpstr, int cch, LPSTR lpstrCopy, int copycount);
void FAR PSMTextOut(HDC hdc, int xLeft, int yTop, LPCSTR lpsz, int cch);
DWORD FAR PSMGetTextExtent(HDC hdc, LPCSTR lpstr, int cch);
HWND FAR GetTopLevelTiled(HWND hwnd);
BOOL FAR TrueIconic(HWND hwnd);
void FAR ChangeToCurrentTask(HWND hwnd1, HWND hwnd2);

HWND FAR GetLastTopMostWindow(void);
void FAR SendSizeMessage(HWND hwnd, WORD cmdSize);
HWND FAR NextTopWindow(HWND hwnd, HWND hwndSkip, BOOL fPrev, BOOL fDisabled);

void FAR DisableVKD(BOOL fDisable);
void FAR CheckFocus(HWND hwnd);
BOOL CALLBACK FChildVisible(HWND hwnd);
#define InternalGetClientRect(hwnd, lprc)   CopyRect(lprc, &hwnd->rcClient)
void FAR CheckByteAlign(HWND hwnd, LPRECT lprc);
void FAR CancelMode(HWND hwnd);
void FAR RedrawIconTitle(HWND hwnd);
void FAR DisplayIconicWindow(HWND hwnd, BOOL fActivate, BOOL fShow);
DWORD FAR GetIconTitleSize(HWND hwnd);
BOOL FAR SendZoom(HWND hwnd, LPARAM lParam);
BOOL CALLBACK  DestroyTaskWindowsEnum(HWND hwnd, LPARAM lParam);
void CALLBACK  LockMyTask(BOOL fLock);
void CALLBACK RepaintScreen(void);
HANDLE FAR BcastCopyString(LPARAM lParam);
BOOL CALLBACK SignalProc(HTASK hTask, WORD message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK NewSignalProc(HTASK hTask, WORD message, WPARAM wParam, LPARAM lParam);
HWND FAR GetWindowCreator(HWND hwnd);

void FAR InitSendValidateMinMaxInfo(HWND hwnd);
void FAR DrawDragRect(LPRECT lprc, WORD flags);
void FAR MoveSize(HWND hwnd, WORD cmdMove);
BYTE FAR SetClrWindowFlag(HWND hwnd, WORD style, BYTE cmd);
void FAR ParkIcon(HWND hwnd, CHECKPOINT * pcp);
void FAR ShowOwnedWindows(HWND hwndOwner, WORD cmdShow);
HWND FAR MinMaximize(HWND hwnd, WORD cmd, BOOL fKeepHidden);
void FAR SetTiledRect(HWND hwnd, LPRECT lprc);
#endif  // MSDWP
void FAR AdjustSize(HWND hwnd, LPINT lpcx, LPINT lpcy);
#ifndef MSDWP

void FAR NextWindow(WORD flags);
void FAR DoScroll(HWND hwnd, HWND hwndNotify, int cmd, int pos, BOOL fVert);
void CALLBACK ContScroll(HWND hwnd, WORD message, WORD id, DWORD time);
void FAR MoveThumb(HWND hwnd, int px, BOOL fCancel);
void FAR SBTrackInit(HWND hwnd, LPARAM lParam, int curArea);
void FAR DrawSize(HWND hwnd, HDC hdc, int cxFrame, int cyFrame, BOOL fBorder);
void FAR CalcSBStuff(HWND hwnd, BOOL fVert);
WORD     GetWndSBDisableFlags(HWND, BOOL);
void     FreeWindow(HWND hwnd);
void FAR DestroyTaskWindows(HQ hq);
BOOL FAR TrackInitSize(HWND hwnd, WORD message, WPARAM wParam, LPARAM lParam);
void FAR DrawPushButton(HDC hdc, LPRECT lprc, WORD style, BOOL fInvert, HBRUSH hbrBtn, HWND hwnd);
void FAR DrawBtnText(HDC hdc, HWND hwnd, BOOL dbt, BOOL fDepress);
void FAR Capture(HWND hwnd, int code);
int  FAR SystoChar(WORD message, LPARAM lParam);
void FAR LinkWindow(HWND, HWND, HWND *);
void FAR UnlinkWindow(HWND, HWND *);
void FAR DrawScrollBar(HWND hwnd, HDC hdc, BOOL fVert);
void CALLBACK  PaintRect(HWND hwndBrush, HWND hwndPaint, HDC hdc, HBRUSH hbr, LPRECT lprc);

BOOL FAR SetDeskPattern(LPSTR);
BOOL FAR SetDeskWallpaper(LPSTR);
void FAR SetGridGranularity(WORD);

int  FAR GetAveCharWidth(HDC);
#ifndef NOTEXTMETRIC
int  FAR GetCharDimensions(HDC, TEXTMETRIC FAR *);
#endif

BOOL FAR LW_ReloadLangDriver(LPSTR);
HBRUSH FAR GetSysClrObject(int);
int  API SysErrorBox(LPCSTR lpszText, LPCSTR lpszCaption, unsigned int btn1, unsigned int btn2, unsigned int btn3);
BOOL FAR SnapWindow(HWND hwnd);
WORD  FAR MB_FindLongestString(void);
#ifdef FASTFRAME
HBITMAP FAR CreateCaptionBitmaps(void);
HBITMAP FAR CreateBorderVertBitmaps(BOOL fDlgFrame);
HBITMAP FAR CreateBorderHorzBitmaps(BOOL fDlgFrame);
void FAR GetCaptionBitmapsInfo(FRAMEBITMAP Caption[], HBITMAP hBitmap);
void FAR GetHorzBitmapsInfo(FRAMEBITMAP Bitmap[], BOOL fDlgFrame, HBITMAP hBitmap);
void FAR GetVertBitmapsInfo(FRAMEBITMAP Bitmap[], BOOL fDlgFrame, HBITMAP hBitmap);
BOOL FAR DrawIntoCaptionBitmaps(HDC   hdc,HBITMAP hBitmap, FRAMEBITMAP FrameInfo[], BOOL fActive);
BOOL FAR DrawIntoHorzBitmaps(HDC hdc, HBITMAP hBitmap, FRAMEBITMAP FrameInfoH[], BOOL fActive, BOOL fDlgFrame);
BOOL FAR DrawIntoVertBitmaps(HDC hdc, HBITMAP hBitmap, FRAMEBITMAP FrameInfoH[], FRAMEBITMAP FrameInfoV[], BOOL fActive, BOOL fDlgFrame);
BOOL FAR RecreateFrameBitmaps(void);
void FAR DeleteFrameBitmaps(int, int);
BOOL FAR PASCAL UpdateFrameBitmaps(WORD  wColorFlags);
BOOL FAR PASCAL RecolorFrameBitmaps(WORD wColorFlags);
#endif  /* FASTFRAME */

void PostButtonUp(WORD msg);

#endif  /*  MSDWP  */


void CALLBACK EndMenu(void);
void CALLBACK FillWindow(HWND hwndBrush, HWND hwndPaint, HDC hdc, HBRUSH hbr);
void FAR SysCommand(HWND hwnd, int cmd, LPARAM lParam);
void FAR HandleNCMouseGuys(HWND hwnd, WORD message, int htArea, LPARAM lParam);
void FAR EndScroll(HWND hwnd, BOOL fCancel);
HWND FAR GetTopLevelWindow(HWND hwnd);
void FAR RedrawIconTitle(HWND hwnd);
int  FAR FindNCHit(HWND hwnd, LONG lPt);
void FAR CalcClientRect(HWND hwnd, LPRECT lprc);
BOOL FAR DepressTitleButton(HWND hwnd, RECT rcCapt, RECT rcInvert, WORD hit);
void FAR SetSysMenu(HWND hwnd);
HMENU FAR GetSysMenuHandle(HWND hwnd);
int *FAR InitPwSB(HWND hwnd);
BOOL FAR DefSetText(HWND hwnd, LPCSTR lpsz);
void FAR DrawWindowFrame(HWND hwnd, HRGN hrgnClip);
void FAR ShowIconTitle(HWND hwnd, BOOL fShow);
HBRUSH FAR GetBackBrush(HWND hwnd);
BOOL FAR IsSystemFont(HDC);
BOOL FAR IsSysFontAndDefaultMode(HDC);
VOID FAR DiagOutput(LPCSTR);
VOID FAR UserDiagOutput(int, LPCSTR);
#define UDO_INIT     0
#define UDO_INITDONE 1
#define UDO_STATUS   2


HANDLE FAR TextAlloc(LPCSTR);
HANDLE FAR TextFree(HANDLE);
WORD   FAR TextCopy(HANDLE, LPSTR, WORD);
#define TextPointer(h)  (LPSTR)MAKELP(hWinAtom, h)

BOOL CALLBACK FARValidatePointer(LPVOID);

// GDI exports
#ifdef DEBUG
VOID CALLBACK SetObjectOwner(HGDIOBJ, HINSTANCE);
#else
#define SetObjectOwner(d1, d2)
#endif
BOOL CALLBACK MakeObjectPrivate(HGDIOBJ, BOOL);
VOID CALLBACK GDITaskTermination(HTASK);
VOID CALLBACK RealizeDefaultPalette(HDC);

// Internal functions called directly by debug version to
// prevent validation errors
//
#ifdef DEBUG
HDC  API IGetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);
BOOL API IGrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);
BOOL API IRedrawWindow(HWND hwnd, CONST RECT FAR* lprcUpdate, HRGN hrgnUpdate, WORD flags);
int  API IScrollWindowEx(HWND hwnd, int dx, int dy,
        CONST RECT FAR* prcScroll, CONST RECT FAR* prcClip,
        HRGN hrgnUpdate, RECT FAR* prcUpdate, WORD flags);
#endif

#ifdef DBCS_IME
#define WM_IMECONTROL   WM_USER
void FAR InitIME(void);                 // wmcaret.c
BOOL _loadds FAR EnableIME( HWND, BOOL );       // wmcaret.c
VOID API SetImeBoundingRect(HWND, DWORD, LPRECT);   // wmcaret.c
BOOL API ControlIME(HWND, BOOL);            // wmcaret.c
HANDLE API SetFontForIME(HWND, HANDLE);         // wmcaret.c
VOID API ControlCaretIme(BOOL);             // wmcaret.c
BOOL API EatString(HWND, LPSTR, WORD);          // editec.c
VOID API CheckKatanaInstalled(HWND);            // wmcaret.c
#endif

#ifdef JAPAN
// Save time of WM_LBUTTONDOWN and WM_LBUTTONUP, used to decided
// whether to lock large popup menus that cover the static portion
// of the menu...
extern int     fLongPMenu;
extern DWORD   lbuttondown_time;
#endif

/****************************************************************************

    debugging support

****************************************************************************/

#ifdef DEBUG

    extern void cdecl dDbgOut(int iLevel, LPSTR lpszFormat, ...);
    extern void cdecl dDbgAssert(LPSTR exp, LPSTR file, int line);

    DWORD __dwEval;

    #define dprintf                          dDbgOut

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))
    #define WinEval(exp) \
        ((__dwEval=(DWORD)(LPVOID)(exp)) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

#else

    #define dprintf /##/
//  #define dprintf  if (0) ((int (*)(char *, ...)) 0)

    #define WinAssert(exp) 0
    #define WinEval(exp) (exp)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user2.asm ===
;
;   USER2.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER.ASM 9-Jun-92 by BobDay
;
;--

    TITLE   USER2.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    GetModuleHandle
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING


;*--------------------------------------------------------------------------*
;*
;*  CheckDisplayHandle()
;*
;*  Checks to see if the handle passed in is the handle for the DISPLAY
;*  driver.   If that is the case then we change the parameter to NULL.
;*  This is to make applications like Winword 1.1a able to load cursors,icons
;*  and bitmaps from the 32 bit display driver.
;*
;*--------------------------------------------------------------------------*

display DB  'DISPLAY',0

cProc CheckDisplayHandle, <PUBLIC, NEAR>
parmW hInstance         ; Callers Parameters
parmD lpName            ; Callers
parmD lpReturn          ; Callers Return Address
cBegin
    pusha

    push    cs
    push    offset display
    Call    GetModuleHandle
    cmp ax,hInstance
    jnz @f

    mov hInstance,0h    ; Change Callers parameter to NULL
@@:
    popa

    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>



    UserThunk   FARCALLNETDRIVER
    UserThunk   FILEPORTDLGPROC
    UserThunk   FILLRECT
    DUserThunk  FILLWINDOW,8        ;Needs to be exposed in WIN32
    DUserThunk  FINALUSERINIT
    UserThunk   FINDWINDOW
    UserThunk   FLASHWINDOW
    UserThunk   FLUSHCOMM
    UserThunk   FRAMERECT
    DUserThunk  GETACTIVEWINDOW,0
    DUserThunk  GETASYNCKEYSTATE
    DUserThunk  GETCAPTURE,0
    DUserThunk  GETCARETBLINKTIME,0
    DUserThunk  GETCARETPOS
    UserThunk   GETCLASSINFO
    UserThunk   GETCLASSLONG
    UserThunk   GETCLASSWORD
    DUserThunk  GETCLIPBOARDDATA
    UserThunk   GETCLIPBOARDFORMATNAME
    DUserThunk  GETCLIPBOARDOWNER,0
    DUserThunk  GETCLIPBOARDVIEWER,0
    UserThunk   GETCOMMERROR
    UserThunk   GETCOMMEVENTMASK
    UserThunk   GETCOMMSTATE
    DUserThunk  GETCONTROLBRUSH
    UserThunk   GETDC
    DUserThunk  GETDIALOGBASEUNITS,0
    UserThunk   GETDLGCTRLID
    UserThunk   GETDLGITEMINT
    UserThunk   GETDLGITEMTEXT
    DUserThunk  GETDOUBLECLICKTIME,0
    DUserThunk  GETFILEPORTNAME
    DUserThunk  GETFOCUS,0
    DUserThunk  GETICONID
    DUserThunk  GETINPUTSTATE,0
    DUserThunk  GETINTERNALWINDOWPOS
    UserThunk   GETLASTACTIVEPOPUP
    DUserThunk  GETMENUCHECKMARKDIMENSIONS,0
    UserThunk   GETMENUSTRING
    UserThunk   GETMESSAGE
    DUserThunk  GETMESSAGE2
    DUserThunk  GETMESSAGEPOS,0
    DUserThunk  GETMESSAGETIME,0
;;;    DUserThunk  GETMOUSEEVENTPROC   ; local api in winmisc2.asm
    UserThunk   GETNEXTDLGGROUPITEM
    UserThunk   GETNEXTDLGTABITEM
    UserThunk   GETNEXTQUEUEWINDOW
    UserThunk   GETPRIORITYCLIPBOARDFORMAT
    UserThunk   GETPROP
    UserThunk   GETQUEUESTATUS
    UserThunk   GETSCROLLPOS
    UserThunk   GETSCROLLRANGE
;;;    DUserThunk  GETSYSMODALWINDOW,0 ; local api in winmisc1.asm
    UserThunk   GETSYSTEMMENU
    UserThunk   GETTABBEDTEXTEXTENT
;;;    UserThunk   GETTASKFROMHWND  ; No longer exported in Win95
    DUserThunk  GETTIMERRESOLUTION

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user2a.asm ===
;
;   USER2A.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER.ASM 9-Jun-92 by BobDay
;
;--

    TITLE   USER2A.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    GetModuleHandle
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

    UserThunk   GETUPDATERECT
    UserThunk   GETUPDATERGN
    UserThunk   GETWC2
    UserThunk   GETWINDOWDC
    DUserThunk  GETWINDOWLONG
    UserThunk   GETWINDOWTASK
    EUserThunk  GETWINDOWTEXT       ;Use the empty buffer user thunk.
    UserThunk   GETWINDOWTEXTLENGTH
    DUserThunk  GETWINDOWWORD
    DUserThunk  GLOBALADDATOM
    DUserThunk  GLOBALDELETEATOM
    UserThunk   GLOBALFINDATOM
    DUserThunk  GLOBALGETATOMNAME
    UserThunk   GRAYSTRING
    UserThunk   HIDECARET
    UserThunk   HILITEMENUITEM
    DUserThunk  ICONSIZE            ;;;;;;
;;; UserThunk   INFLATERECT      ; LOCALAPI in winrect.asm
;;; DUserThunk  INITAPP           ;LOCALAPI in user.asm
    DUserThunk  INSENDMESSAGE,0
    UserThunk   INSERTMENU
;;; UserThunk   INTERSECTRECT  ; LOCALAPI in winrect.asm
    UserThunk   INVALIDATERECT
    UserThunk   INVALIDATERGN
    UserThunk   INVERTRECT

    ; Hack to use original IDs.  These functions have local implementations
    ; that thunk to Win32 if the locale is other than U.S. English.

    FUN_WIN32ISCHARALPHA        equ FUN_ISCHARALPHA
    FUN_WIN32ISCHARALPHANUMERIC equ FUN_ISCHARALPHANUMERIC
    FUN_WIN32ISCHARLOWER        equ FUN_ISCHARLOWER
    FUN_WIN32ISCHARUPPER        equ FUN_ISCHARUPPER

    DUserThunk  WIN32ISCHARALPHA,        %(size ISCHARALPHA16)
    DUserThunk  WIN32ISCHARALPHANUMERIC, %(size ISCHARALPHANUMERIC16)
    DUserThunk  WIN32ISCHARLOWER,        %(size ISCHARLOWER16)
    DUserThunk  WIN32ISCHARUPPER,        %(size ISCHARUPPER16)

    DUserThunk  ISCLIPBOARDFORMATAVAILABLE
    UserThunk   ISDIALOGMESSAGE
    UserThunk   ISDLGBUTTONCHECKED
;;; UserThunk   ISRECTEMPTY         ; LOCALAPI in winrect.asm
    DUserThunk  ISTWOBYTECHARPREFIX        ;;;;;;
    DUserThunk  ISUSERIDLE
    DUserThunk  KILLSYSTEMTIMER        ;;;;;
    UserThunk   KILLTIMER
    UserThunk   KILLTIMER2
    UserThunk   LBOXCARETBLINKER
;;; UserThunk   LBOXCTLWNDPROC          ;LOCALAPI in wsubcls.c
;;; UserThunk   LOADACCELERATORS        ; localapi in rmload.c

FUN_WOWLOADBITMAP EQU FUN_LOADBITMAP
    DUserThunk	WOWLOADBITMAP, %(size LOADBITMAP16)

FUN_WOWLOADCURSORICON EQU FUN_LOADCURSOR
    DUserThunk	WOWLOADCURSORICON, %(size LOADCURSOR16)

;FUN_WOWLOADICON EQU FUN_LOADICON
;   DUserThunk	WOWLOADICON, %(size LOADICON16)

    DUserThunk  LOADICONHANDLER

FUN_WOWLOADMENU EQU FUN_LOADMENU
    DUserThunk	WOWLOADMENU, %(size LOADMENU16)

    UserThunk   LOADMENUINDIRECT
;;; UserThunk   LOADSTRING          ;LOCALAPI in rmload.c
    DUserThunk  LOCKMYTASK
    DUserThunk  LOOKUPMENUHANDLE

    ; Hack to use original IDs.  These functions have local implementations
    ; that thunk to Win32 if the locale is other than U.S. English.
    FUN_WIN32LSTRCMP equ FUN_LSTRCMP
    FUN_WIN32LSTRCMPI equ FUN_LSTRCMPI

    DUserThunk  WIN32LSTRCMP,  %(size LSTRCMP16)
    DUserThunk  WIN32LSTRCMPI, %(size LSTRCMPI16)

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user3.asm ===
;
;   USER3.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER2.ASM 4-Dec-92 by barryb
;
;--

    TITLE   USER3.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING


cProc TouchNotPresentSel, <PUBLIC, NEAR>
parmD  lpsz  ; Callers parameter
parmD lpReturn          ; Callers Return Address
cBegin
    mov ax,es
    mov es,word ptr lpsz+2      ; makes NP sel P
    mov es,ax

    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

    UserThunk   MAPDIALOGRECT
    UserThunk   MB_DLGPROC
;;; UserThunk   MDICLIENTWNDPROC        ;LOCALAPI in wsubcls.c
    UserThunk   MENUITEMSTATE
    DUserThunk  MESSAGEBEEP
    UserThunk   MESSAGEBOX
    UserThunk   MODIFYMENU
    UserThunk   MOVEWINDOW
;;;  UserThunk   OFFSETRECT         ; LOCALAPI in winrect.asm
;;; DUserThunk  OLDEXITWINDOWS      ; LOCALAPI in winutil.asm
    UserThunk   OPENCLIPBOARD

FUN_WOWOPENCOMM EQU FUN_OPENCOMM
    DUserThunk   WOWOPENCOMM %(size OPENCOMM16)

    UserThunk   OPENICON
    DUserThunk  PAINTRECT
    UserThunk   PEEKMESSAGE
    UserThunk   POSTAPPMESSAGE
    UserThunk   POSTMESSAGE
    UserThunk   POSTMESSAGE2
    DUserThunk  POSTQUITMESSAGE
;;;    UserThunk   PTINRECT          ; LOCALAPI in winrect.asm

    UserThunk   READCOMM
    UserThunk   REALIZEPALETTE
    UserThunk   REGISTERCLASS
    UserThunk   REGISTERCLIPBOARDFORMAT
    PDUserThunk REGISTERWINDOWMESSAGE, TouchNotPresentSel
    DUserThunk  RELEASECAPTURE,0
    UserThunk   RELEASEDC
    UserThunk   REMOVEMENU
    UserThunk   REMOVEPROP
    DUserThunk  REPAINTSCREEN
    DUserThunk  REPLYMESSAGE
;;; UserThunk   SBWNDPROC           ;LOCALAPI in wsubcls.c
    DUserThunk  SCROLLCHILDREN
    UserThunk   SCROLLDC
    UserThunk   SCROLLWINDOW
        UserThunk   SELECTPALETTE
    UserThunk   SENDDLGITEMMESSAGE
    UserThunk   SENDMESSAGE
    UserThunk   SENDMESSAGE2
    UserThunk   SETACTIVEWINDOW
    UserThunk   SETCAPTURE
    DUserThunk  SETCARETBLINKTIME
    DUserThunk  SETCARETPOS
    UserThunk   SETCLASSLONG
    UserThunk   SETCLASSWORD

FUN_WOWSETCLIPBOARDDATA EQU FUN_SETCLIPBOARDDATA
    DUserThunk  WOWSETCLIPBOARDDATA, %(size SETCLIPBOARDDATA16)

    UserThunk   SETCLIPBOARDVIEWER

sEnd    CODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user3a.asm ===
;
;   USER3A.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER2.ASM 4-Dec-92 by barryb
;   Split off user3a.asm from user3.asm 2-May-95 davehart
;
;--

    TITLE   USER3A.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

;*--------------------------------------------------------------------------*
;*
;*  CheckMsgForTranslate, CheckAccMsgForTranslate, CheckMDIAccMsgForTranslate
;*
;*  Checks to see if the message number in the message is one of those
;*  that the system actually uses.  If not, then the API just returns with
;*  a 0 in AX.  This saves the 16-32-16 bit transition for most messages.
;*
;*--------------------------------------------------------------------------*

ALIGN 16
cProc CheckMsgForTranslate, <PUBLIC, NEAR>
parmD  lpMsg    ; Callers parameter
parmD lpReturn          ; Callers Return Address
;parmW wBP           ; Thunk saved BP
;parmW wDS           ; Thunk saved DS
cBegin
    les bx,lpMsg    ; load msg address into es:bx
    mov ax,es:[bx+2]    ; load message number
; we are looking for ,WM_KEYDOWN, KEYUP, SYSKEYDOWN, SYSKEYUP
;  in other words, 100, 101, 104, amd 105 hex

     and ax,0fffah   ; wipe out 2 bits that are variable
     xor ax, 0100h   ; compensate for bit that must be on
     jz  @f

;    cmp ax,WM_KEYDOWN
;    jz  @f
;    cmp ax,WM_KEYUP
;    jz  @f
;    cmp ax,WM_SYSKEYDOWN
;    jz  @f
;    cmp ax,WM_SYSKEYUP
;    jz  @f


    sub ax,ax     ; flag not translated
    pop  bp
    add  sp,2      ; skip thunk IP
    retf 4        ; lpMsg -- 4 bytes to pop

@@:
    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

ALIGN 16
cProc CheckAccMsgForTranslate, <PUBLIC, NEAR>
parmW hWnd
parmW hAccTbl
parmD  lpMsg    ; Callers parameter
parmD lpReturn          ; Callers Return Address
cBegin

    test hWnd,0ffffh
    jz   SHORT t_not

    les bx,lpMsg    ; load msg address into es:bx
    mov ax,es:[bx+2]    ; load message number
; we are looking for ,WM_KEYDOWN, CHAR, SYSKEYDOWN, SYSCHAR
;  in other words, 100, 102, 104, amd 106 hex

     and ax,0fff9h   ; wipe out 2 bits that are variable
     xor ax, 0100h   ; compensate for bit that must be on
     jz  @f

;    cmp ax,WM_KEYDOWN
;    jz  @f
;    cmp ax,WM_CHAR
;    jz  @f
;    cmp ax,WM_SYSKEYDOWN
;    jz  @f
;    cmp ax,WM_SYSCHAR
;    jz  @f

t_not:
    sub ax,ax     ; flag not translated
    pop  bp
    add  sp,2      ; skip thunk IP
    retf 8        ; 8 bytes to pop

@@:
    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

ALIGN 16
cProc CheckMDIAccMsgForTranslate, <PUBLIC, NEAR>
parmD  lpMsg    ; Callers parameter
parmD lpReturn          ; Callers Return Address
cBegin
    les bx,lpMsg    ; load msg address into es:bx
    mov ax,es:[bx+2]    ; load message number
; we are looking for ,WM_KEYDOWN, SYSKEYDOWN
;  in other words, 100, 104

     and ax,0fffbh   ; wipe out 1 bit that is variable
     xor ax, 0100h   ; compensate for bit that must be on
     jz  @f

;    cmp ax,WM_KEYDOWN
;    jz  @f
;    cmp ax,WM_KEYUP
;    jz  @f
;    cmp ax,WM_SYSKEYDOWN
;    jz  @f
;    cmp ax,WM_SYSKEYUP
;    jz  @f
    sub ax,ax     ; flag not translated
    pop  bp
    add  sp,2      ; skip thunk IP
    retf 6        ; 6 bytes to pop

@@:
    mov sp,bp       ; Do cEnd without Ret count (leave parameters there)
    pop bp
    ret
cEnd <nogen>

;
; Our message queues resize automagically, so just say YES
; to whatever they ask for.
;

cProc SetMessageQueue,<PUBLIC,FAR,PASCAL,NODATA,WIN>
        ParmW qSize
cBegin
        mov   ax,1      ; just say we did it
cEnd

ExternFP        <GetCurrentTask>
ExternFP        <HqCurrent>

externA __MOD_DUSER

cProc SysErrorBox,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin <nogen>
        ; we check whether the queue exists for this process

        call GetCurrentTask
        or ax, ax
        jz i_SysErrorBox

        call HqCurrent ; flags are set on exit
        jz i_SysErrorBox

        push size SysErrorBox16

        t_SysErrorBox:
                push word ptr HI_WCALLID
                push __MOD_DUSER + FUN_SYSERRORBOX
                call WOW16Call
        .erre (($ - t_SysErrorBox) EQ (05h + 03h + 03h))

i_SysErrorBox:
       retf 0eh
cEnd <nogen>



    UserThunk   SETCOMMBREAK
    UserThunk   SETCOMMEVENTMASK
    UserThunk   SETCOMMSTATE
    UserThunk   SETCURSOR
    DUserThunk  SETCURSORPOS
    UserThunk   SETDESKPATTERN
    UserThunk   SETDESKWALLPAPER
    UserThunk   SETDLGITEMINT
    UserThunk   SETDLGITEMTEXT
    DUserThunk  SETDOUBLECLICKTIME
    UserThunk   SETEVENTHOOK
    UserThunk   SETFOCUS
    UserThunk   SETGETKBDSTATE
    UserThunk   SETGRIDGRANULARITY
    DUserThunk  SETINTERNALWINDOWPOS
    UserThunk   SETKEYBOARDSTATE
    UserThunk   SETMENU
    UserThunk   SETMENUITEMBITMAPS
    UserThunk   SETPARENT
    UserThunk   SETPROP
;;;    UserThunk   SETRECT         ; LOCALAPI in winrect.asm
;;;    UserThunk   SETRECTEMPTY    ; LOCALAPI in winrect.asm
    UserThunk   SETSCROLLPOS
    UserThunk   SETSCROLLRANGE
    UserThunk   SETSYSCOLORS
;;;    UserThunk   SETSYSMODALWINDOW ; local api in winmisc1.asm
    UserThunk   SETSYSTEMMENU
    DUserThunk  SETSYSTEMTIMER      ;;;;;;;
    UserThunk   SETTIMER
    UserThunk   SETTIMER2
    UserThunk   SETWC2
    UserThunk   SETWINDOWLONG
    UserThunk   SETWINDOWPOS
    DUserThunk  SETWINDOWSHOOKINTERNAL
    UserThunk   SETWINDOWTEXT
    UserThunk   SETWINDOWWORD
    UserThunk   SHOWCARET
    DUserThunk  SHOWCURSOR
    UserThunk   SHOWOWNEDPOPUPS
    UserThunk   SHOWSCROLLBAR
    UserThunk   SHOWWINDOW
    DUserThunk  SIGNALPROC
    UserThunk   SNAPWINDOW
;;; UserThunk   STATICWNDPROC           ;LOCALAPI in wsubcls.c
;;; UserThunk   STRINGFUNC          ;LOCALAPI in winlang.asm
    DUserThunk  SWAPMOUSEBUTTON
    DUserThunk  SWITCHTOTHISWINDOW
    UserThunk   SWITCHWNDPROC
;;;    DUserThunk  SYSERRORBOX  ; LOCALAPI in this file
    UserThunk   TABBEDTEXTOUT
    UserThunk   TABTHETEXTOUTFORWIMPS
    UserThunk   TRACKPOPUPMENU
    PUserThunk   TRANSLATEACCELERATOR,CheckAccMsgForTranslate
    PUserThunk   TRANSLATEMDISYSACCEL,CheckMDIAccMsgForTranslate
    PUserThunk   TRANSLATEMESSAGE,CheckMsgForTranslate
    UserThunk   TRANSMITCOMMCHAR
    UserThunk   UNGETCOMMCHAR
    UserThunk   UNHOOKWINDOWSHOOK
;;;    UserThunk   UNIONRECT        ; LOCALAPI in winrect.asm
    UserThunk   UNREGISTERCLASS
    UserThunk   UPDATEWINDOW
    DUserThunk  USERYIELD

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\wclass.asm ===
TITLE   wsubcls.asm

_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS

_DATA   SEGMENT  WORD PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP _DATA

EXTRN	CALLWINDOWPROC:FAR
EXTRN   DEFDLGPROC:FAR

_TEXT   SEGMENT

        ASSUME  CS: _TEXT


PUBLIC  BUTTONWNDPROC
PUBLIC  COMBOBOXCTLWNDPROC
PUBLIC  EDITWNDPROC
PUBLIC  LBOXCTLWNDPROC
PUBLIC  SBWNDPROC
PUBLIC  STATICWNDPROC
PUBLIC  MDICLIENTWNDPROC
PUBLIC  TITLEWNDPROC
PUBLIC  MENUWINDOWPROC
PUBLIC  DEFDLGPROCTHUNK
PUBLIC  DESKTOPWNDPROC

SUBCLASS_MAGIC  equ 0534C4353h          ; "SCLS" Sub-Class magic value */

align 16

        dd  SUBCLASS_MAGIC
        dd  2
        dd  0

BUTTONWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET BUTTONWNDPROC
        mov     dx,SEG BUTTONWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

BUTTONWNDPROC	ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  3
        dd  0

COMBOBOXCTLWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET COMBOBOXCTLWNDPROC
        mov     dx,SEG COMBOBOXCTLWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

COMBOBOXCTLWNDPROC	ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  4
        dd  0


EDITWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET EDITWNDPROC
        mov     dx,SEG EDITWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

EDITWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  5
        dd  0

LBOXCTLWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET LBOXCTLWNDPROC
        mov     dx,SEG LBOXCTLWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

LBOXCTLWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  7
        dd  0

SBWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET SBWNDPROC
        mov     dx,SEG SBWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

SBWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  8
        dd  0

STATICWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET STATICWNDPROC
        mov     dx,SEG STATICWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

STATICWNDPROC	ENDP


align 16

        dd  SUBCLASS_MAGIC
        dd  6
        dd  0

MDICLIENTWNDPROC	PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET MDICLIENTWNDPROC
        mov     dx,SEG MDICLIENTWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

MDICLIENTWNDPROC	ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  0bh     ; 11 decimal
        dd  0

TITLEWNDPROC    PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET TITLEWNDPROC
        mov     dx,SEG TITLEWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

TITLEWNDPROC    ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  0ch    ; 12 decimal
        dd  0

MENUWINDOWPROC    PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET MENUWINDOWPROC
        mov     dx,SEG MENUWINDOWPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

MENUWINDOWPROC    ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  0ah     ; 10 decimal
        dd  0


DEFDLGPROCTHUNK     PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR DEFDLGPROC
        mov     sp,bp
        pop     bp
        dec     bp
        ret     10

DEFDLGPROCTHUNK     ENDP

align 16

        dd  SUBCLASS_MAGIC
        dd  9
        dd  0


DESKTOPWNDPROC     PROC FAR
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        mov     ax,OFFSET DESKTOPWNDPROC
        mov     dx,SEG DESKTOPWNDPROC
        push    dx
        push    ax
        push    WORD PTR [bp+14]        ;hwnd
        push    WORD PTR [bp+12]        ;message
        push    WORD PTR [bp+10]        ;wParam
        push    WORD PTR [bp+8]
        push    WORD PTR [bp+6]         ;lParam
        call    FAR PTR CALLWINDOWPROC
        dec     bp
        dec     bp
        mov     sp,bp
        pop     ds
        pop     bp
        dec     bp
        ret     10

DESKTOPWNDPROC     ENDP


_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user4.asm ===
;
;   USER4.ASM
;   More Win16 USER thunks
;
;   History:
;
;   Created 25-Jan-1991 by Jeff Parsons (jeffpar)
;   Added Win 31 thunks 22nd-March-1992 by Chandan S. Chauhan (ChandanC)
;   Split off from USER2.ASM 4-Dec-92 by barryb
;   Split off from USER3.ASM 26-May-93 by bobday
;
;--

    TITLE   USER4.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

    UserThunk   VALIDATERECT
    UserThunk   VALIDATERGN
    DUserThunk  WAITMESSAGE,0
    DUserThunk  WINDOWFROMPOINT
;;; UserThunk   WINFARFRAME         ;LOCALAPI in winstack.asm
;;; UserThunk   WINHELP
    DUserThunk  WINOLDAPPHACKOMATIC
    DUserThunk  WOWWORDBREAKPROC
;;; UserThunk   WNETADDCONNECTION
;;; UserThunk   WNETBROWSEDIALOG
;;; UserThunk   WNETCANCELCONNECTION
;;; UserThunk   WNETCANCELJOB
;;; UserThunk   WNETCLOSEJOB
;;; UserThunk   WNETDEVICEMODE
;;; UserThunk   WNETGETCAPS
;;; UserThunk   WNETGETCONNECTION
;;; UserThunk   WNETGETERROR
;;; UserThunk   WNETGETERRORTEXT
;;; UserThunk   WNETGETUSER
;;; UserThunk   WNETHOLDJOB
;;; UserThunk   WNETLOCKQUEUEDATA
;;; UserThunk   WNETOPENJOB
;;; UserThunk   WNETRELEASEJOB
;;; UserThunk   WNETSETJOBCOPIES
;;; UserThunk   WNETUNLOCKQUEUEDATA
;;; UserThunk   WNETUNWATCHQUEUE
;;; UserThunk   WNETWATCHQUEUE
    UserThunk   WRITECOMM
;;; UserThunk   WVSPRINTF           ;LOCALAPI in wsprintf.c
    UserThunk   XCSTODS
    DUserThunk  _FFFE_FARFRAME
;;; UserThunk   _WSPRINTF           ;LOCALAPI in wsprintf.c
    UserThunk   SETWINDOWSHOOKEX
    UserThunk   UNHOOKWINDOWSHOOKEX
    UserThunk   CALLNEXTHOOKEX

;;;;;
;;;;;   Win 3.1 Thunks
;;;;;

    DUserThunk  QUERYSENDMESSAGE
    DUserThunk  USERSEEUSERDO
    DUserThunk  LOCKINPUT
;   DUserThunk  GETSYSTEMDEBUGSTATE, 0
    UserThunk   ENABLECOMMNOTIFICATION
    UserThunk   EXITWINDOWSEXEC
    DUserThunk  GETCURSOR, 0
    DUserThunk  GETOPENCLIPBOARDWINDOW, 0
;   UserThunk   SENDDRIVERMESSAGE
;   UserThunk   OPENDRIVER
;   UserThunk   CLOSEDRIVER
;   UserThunk   GETDRIVERMODULEHANDLE
;   UserThunk   DEFDRIVERPROC
;   UserThunk   GETDRIVERINFO
;   UserThunk   GETNEXTDRIVER
    UserThunk   MAPWINDOWPOINTS
    DUserThunk  OLDSETDESKPATTERN
    DUserThunk  GETFREESYSTEMRESOURCES
    DUserThunk  OLDSETDESKWALLPAPER      ;;;;;;
    DUserThunk  GETMESSAGEEXTRAINFO, 0
;;;    DUserThunk  KEYBD_EVENT         ; local API in winmisc2.asm
    DUserThunk  KEYBDEVENT
    UserThunk   REDRAWWINDOW
    UserThunk   LOCKWINDOWUPDATE
;;    DUserThunk  MOUSE_EVENT          ;; in winmisc2.asm
    DUserThunk  MOUSEEVENT
;;    DUserThunk  MENUWINDOWPROC       ;;;;;; in wclass.asm
    UserThunk   GETCLIPCURSOR
    UserThunk   SCROLLWINDOWEX
    DUserThunk  ISMENU
    UserThunk   GETDCEX
;;    UserThunk   COPYICON              ;;;; in rmcreate.c
;;    UserThunk   COPYCURSOR            ;;;; in rmcreate.c
    UserThunk   GETWINDOWPLACEMENT
    UserThunk   SETWINDOWPLACEMENT
    UserThunk   GETINTERNALICONHEADER
;;;    UserThunk   SUBTRACTRECT        ; LOCALAPI in winrect.asm
    UserThunk   DLGDIRSELECTEX
    UserThunk   DLGDIRSELECTCOMBOBOXEX
    DUserThunk  GETUSERLOCALOBJTYPE
    DUserThunk  HARDWARE_EVENT
    UserThunk   ENABLESCROLLBAR
    UserThunk   SYSTEMPARAMETERSINFO
;   UserThunk   GP
;;; DUserThunk  WNETERRORTEXT
;;; UserThunk   WNETABORTJOB
;;; DUserThunk  WNETENABLE
;;; DUserThunk  WNETDISABLE
;;; DUserThunk  WNETRESTORECONNECTION
;;; DUserThunk  WNETWRITEJOB
;;; DUserThunk  WNETCONNECTDIALOG
;;; DUserThunk  WNETDISCONNECTDIALOG
;;; DUserThunk  WNETCONNECTIONDIALOG
;;; DUserThunk  WNETVIEWQUEUEDIALOG
;;; DUserThunk  WNETPROPERTYDIALOG
;;; DUserThunk  WNETGETDIRECTORYTYPE
;;; DUserThunk  WNETDIRECTORYNOTIFY
;;; DUserThunk  WNETGETPROPERTYTEXT
    DUserThunk  NOTIFYWOW
    DUserThunk  Win32WinHelp          
sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\user95.asm ===
;
;   USER95.ASM
;   Win16 USER thunks new for Win95
;
;   History:
;
;   Created 7-Oct-97 by Dave Hart (davehart)
;
;--

    TITLE   USER5.ASM
    PAGE    ,132

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING


    DUserThunk  ACTIVATEKEYBOARDLAYOUT
    DUserThunk  BROADCASTSYSTEMMESSAGE
    DUserThunk  CALLMSGFILTER32
    DUserThunk  CASCADEWINDOWS
    DUserThunk  CHANGEDISPLAYSETTINGS
    DUserThunk  CHECKMENURADIOITEM
    DUserThunk  CHILDWINDOWFROMPOINTEX
    DUserThunk  CHOOSECOLOR_CALLBACK16
    DUserThunk  CHOOSEFONT_CALLBACK16
    DUserThunk  COPYIMAGE
    DUserThunk  CREATEICONFROMRESOURCEEX
    DUserThunk  DESTROYICON32
    DUserThunk  DISPATCHINPUT, 0
    DUserThunk  DISPATCHMESSAGE32
    DUserThunk  DLLENTRYPOINT
    DUserThunk  DOHOTKEYSTUFF
    DUserThunk  DRAWANIMATEDRECTS
    DUserThunk  DRAWCAPTION
    DUserThunk  DRAWCAPTIONTEMP
    DUserThunk  DRAWEDGE
    DUserThunk  DRAWFRAMECONTROL
    DUserThunk  DRAWICONEX
    DUserThunk  DRAWMENUBARTEMP
    DUserThunk  DRAWSTATE
    DUserThunk  DRAWTEXTEX
    DUserThunk  ENUMDISPLAYSETTINGS
    DUserThunk  FINDREPLACE_CALLBACK16
    DUserThunk  FINDWINDOWEX
    DUserThunk  GETAPPVER, 0
    DUserThunk  GETCLASSINFOEX
    DUserThunk  GETFOREGROUNDWINDOW, 0
    DUserThunk  GETICONINFO
    DUserThunk  GETKEYBOARDLAYOUT
    DUserThunk  GETKEYBOARDLAYOUTLIST
    DUserThunk  GETKEYBOARDLAYOUTNAME
    DUserThunk  GETMENUCONTEXTHELPID
    DUserThunk  GETMENUDEFAULTITEM
    DUserThunk  GETMENUITEMINFO
    DUserThunk  GETMENUITEMRECT
    DUserThunk  GETMESSAGE32
    DUserThunk  GETPROPEX
    DUserThunk  GETSCROLLINFO
    DUserThunk  GETSHELLWINDOW, 0
    DUserThunk  GETSYSCOLORBRUSH
    DUserThunk  GETWINDOWCONTEXTHELPID
    DUserThunk  GETWINDOWRGN
    DUserThunk  HACKTASKMONITOR
    DUserThunk  INITTHREADINPUT
    DUserThunk  INSERTMENUITEM
    DUserThunk  INSTALLIMT
    DUserThunk  ISDIALOGMESSAGE32
    DUserThunk  LOADIMAGE
    DUserThunk  LOADKEYBOARDLAYOUT
    DUserThunk  LOOKUPICONIDFROMDIRECTORYEX
    DUserThunk  MENUITEMFROMPOINT
    DUserThunk  MESSAGEBOXINDIRECT
    DUserThunk  MSGWAITFORMULTIPLEOBJECTS
    DUserThunk  OPENFILENAME_CALLBACK16
    DUserThunk  PEEKMESSAGE32
    DUserThunk  PLAYSOUNDEVENT
    DUserThunk  POSTMESSAGE32
    DUserThunk  POSTPOSTEDMESSAGES, 0
    DUserThunk  POSTTHREADMESSAGE32
    DUserThunk  PRINTDLG_CALLBACK16
    DUserThunk  REGISTERCLASSEX
    DUserThunk  REMOVEPROPEX
    DUserThunk  SETCHECKCURSORTIMER
    DUserThunk  SETFOREGROUNDWINDOW
    DUserThunk  SETMENUCONTEXTHELPID
    DUserThunk  SETMENUDEFAULTITEM
    DUserThunk  SETMENUITEMINFO
    DUserThunk  SETMESSAGEEXTRAINFO
    DUserThunk  SETPROPEX
    DUserThunk  SETSCROLLINFO
    DUserThunk  SETSYSCOLORSTEMP
    DUserThunk  SETWINDOWCONTEXTHELPID
    DUserThunk  SETWINDOWRGN
    DUserThunk  SIGNALPROC32
    DUserThunk  TILEWINDOWS
    DUserThunk  TRACKPOPUPMENUEX
    DUserThunk  TRANSLATEMESSAGE32
    DUserThunk  UNINSTALLIMT
    DUserThunk  UNLOADINSTALLABLEDRIVERS
    DUserThunk  UNLOADKEYBOARDLAYOUT
    DUserThunk  WINDOWFROMDC
    DUserThunk  WNETINITIALIZE, 0
    DUserThunk  WNETLOGON

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winhook.asm ===
title   WINHOOK.ASM - SetWindowsHook() and friends

ifdef WOW
NOEXTERNS equ 1
SEGNAME equ <TEXT>
endif

        .xlist
        include user.inc
        .list

	swappro  = 0

; include NEW_SEG1 struc used in GetProcModule

	include newexe.inc

ExternFP <GetCodeInfo>
ExternFP <GetExePtr>
ExternFP <GetCurrentTask>
ExternFP <SetWindowsHookInternal>

createSeg   _%SEGNAME,%SEGNAME,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

;===========================================================================

sBegin  %SEGNAME

assumes CS,%SEGNAME
assumes DS,DATA
assumes ES,NOTHING

;============================================================================
;
;  HANDLE FAR PASCAL GetProcModule(FARPROC lpfn);
;
;  This function returns the module handle corresponding to a given
;  hook proc address.
;
;  CAUTION: This uses the undocumented feature of "GetCodeInfo()" that it
;	returns the module handle in ES register.
;
cProc   GetProcModule, <PUBLIC, FAR>
ParmD	lpfn
LocalV  seginfofromkernel, %size NEW_SEG1+2
cBegin
; Turns out GetCodeInfo
;
	pushd	lpfn		; GetCodeInfo(lpfn, &seginfo)
        lea     ax,seginfofromkernel
        push    ss
        push    ax
        call    GetCodeInfo
        or      ax,ax           ; AX is BOOL fSuccess (even though windows.h says void)
	mov	ax,es		; ES contains the module handle according
				; to David Weise...
	jnz	gpmexit		; We're ok

        ; hack. Excel global allocs some memory, puts
        ; code into it and passes it to us. The GetCodeInfo fails in this
        ; case so we need to get the module handle for a globalalloced
        ; chunk of memory.

        push    word ptr lpfn+2
        call    GetExePtr
gpmexit:

ifdef DEBUG
	or	ax,ax
	jnz	gpm900
        DebugErr DBF_ERROR, "Invalid Hook Proc Addr"
	xor	ax,ax
gpm900:
endif
cEnd


;==============================================================================
;
;   FARPROC FAR PASCAL SetWindowsHook(int idHook, FARPROC lpfn)
;   {
;	SetWindowsHookEx2(idHook,
;		(HOOKPROC)lpfn,
;		GetProcModule(lpfn),
;		(idHook == WH_MSGFILTER ? GetCurrentTask() : NULL));
;   }
;
cProc	ISetWindowsHook,<FAR, PUBLIC, LOADDS>
ParmW	idHook
ParmD	lpfn
LocalW	hmodule
LocalW	htask
cBegin
        ; Check if some apps are trying to unhook a hook using SetWindowsHook()
        mov     bx, seg_lpfn
	cmp	bx, HHOOK_MAGIC
	jz	swhHookMagic

	cmp	idHook,WH_MSGFILTER
        jnz     swh10

	call	GetCurrentTask
        jmp     swhMakeCall

swhHookMagic:
	; Now, it is clear that this app wants to unhook by calling SetWindowsHook()
	; All Micrographix apps do this trick to unhook their keyboard hooks.
	; Fix for Bug #7972 -- SANKAR -- 05/30/91 --
	; Let us unhook the node passed in thro lpfn;
ifdef DEBUG
        DebugErr <DBF_WARNING>, "SetWindowsHook called to unhook: use UnhookWindowsHook"
endif
        xor     ax,ax
        jmps    swhMakeCall

swh10:
        pushd   lpfn
        call    GetProcModule

swhMakeCall:
        push    ax
        push    idHook
        pushd   lpfn

        call    SetWindowsHookInternal

swhExit:
cEnd

sEnd    %SEGNAME

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\usercli.asm ===
;---------------------------------------------------------------------------
;   Optimzed Code Path - on x86 builds effectively excecutes USER32 code.
;
;   Created:
;     16-DEC-93 nandurir
;---------------------------------------------------------------------------
    TITLE   USER5.ASM
    PAGE    ,132

    .286p

    .xlist
    include ks386p.inc
    .286p
NOEXTERNS=1         ; to suppress including most of the stuff in user.inc
    include wow.inc
    include wowusr.inc
    ;;;;;include cmacros.inc
    include user.inc

    .list

externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

externFP WowSetCompatHandle
;---------------------------------------------------------------------------
; Optimized thunks for x86 only
;
;
;---------------------------------------------------------------------------

ifndef PMODE32

      USER16CLIENTTHUNK  macro Iapi, api, argtypeslist, returntype, api32, apispecificcode, callserver
          sBegin CODE

              index = 0
              IRP argtype, <argtypeslist>
                  index = index + 1
              ENDM

              IFE index
                  &Iapi &api, 0
              ELSE
                  &Iapi &api
              ENDIF
          sEnd CODE
      endm

else

externFP OutputDebugString
LOGARGS macro apiname
       push dx
       push ax
       push cs
       push OFFSET afterlog_&apiname
       call OutputDebugString
       pop  ax
       pop  dx
       jmp  short afterlogname_&apiname
afterlog_&apiname: DB 'USER: ','&apiname','()', 0dh, 0ah, 0
afterlogname_&apiname:


endm
; flat selector values
;

FLATDS equ KGDT_R3_DATA OR RPL_MASK
FLATFS equ KGDT_R3_TEB OR RPL_MASK

; set flat ds and fs
;

SETFLATDSANDFS macro
.386p
     mov   ax, FLATDS
     mov   ds, ax
     mov   ax, FLATFS
     mov   fs, ax
endm

externFP  GetSelectorBase
GETFLATADDRESS macro farpointer
     ; check for null
     xor   dx, dx
     mov   ax, word ptr &farpointer+2
     or    ax, ax
     jz    @F
     cCall GetSelectorBase, <ax>

     ; check for base address 0

     mov   cx, ax
     or    cx, dx
     jz    @F

     ; now its ok

     add   ax, word ptr &farpointer
     adc   dx, 0
@@:
endm

; generates code like: parmW arg1
;

GENPARAM  macro argtype, argname
    parm&argtype &argname
endm


pushWORD_DWORD  macro argname
    movzx  eax, &argname
    push   eax
endm

pushINT_LONG   macro argname
    movsx  eax, &argname
    push   eax
endm

pushDWORD_DWORD   macro argname
    push  dword ptr &argname
endm

pushPSZ_DWORD   macro argname, apiname, argnumber

    GETFLATADDRESS &argname
    push  dx
    push  ax

    IFNB <apiname>
        or    ax, dx
        jnz   @F
        add   sp, argnumber * 4
        xor   eax, eax
        jmp   short FailCall_&apiname
    @@:
    ENDIF

endm

pushHHOOK_DWORD macro argname
    push dword ptr -1                  ; unreferenced parameter
                                       ; effectively an assertion
endm

pushARG16 macro argname
    push  &argname
endm

CALLORDECLARE macro  typestring, api32, totalbytes
    &typestring api32&@&totalbytes
endm

TESTCALLSERVERCONDITION macro
    mov   edx, DWORD PTR _wow16CsrFlag
    test  BYTE PTR [edx], 1
endm

; assumes eax is pointer to the flag
CLEARCALLSERVERCONDITION macro
    mov   BYTE PTR [edx], 0
endm

;--------------------------------------------------------------------------
; Iapi = either DUserThunk or UserThunk
; api  = actual name
; argtypeslist = list of argument 'types' like <WORD, INT, HWND>
; api32 = this function is called instead of _Api
; apispecificcode = flag indicating additional code needed for this api.
;                   This is intended for handling 'compatibility'.
;
;                   If this argument is not blank, then there must exist a macro
;                   APISPECIFICCODE_api, which expands to the desired code.
;                   At present it is included just before the 'return' to
;                   the app.
;
; callserver =  flag indication that it may be necessary to actually call
;               USER32.
;
;               If this argument is not blank, then there must exist a macro
;               CALLSERVERCONDITION_api which expands to the desired code and
;               clears or sets the zero flag. If ZF is clear, the actual
;               thunk gets called, else nop.
;
;
; generates code similar to:
;
;   externFP _Api OR Api32
;   sBegin CODE
;      if necessary
;           FUN_WOWApi equ FUN_Api
;           DUserThunk WOWApi, %(size Api16)
;      endif
;
;   cProc Api, <PUBLIC, FAR, PASCAL>, <ds>
;      parmW arg1
;   cBegin
;      movzx, eax, arg1
;      push   eax
;      call far ptr _Api OR Api32 (decorates the names)
;
;      if necessary checks the callservercondtion
;           resets the callservercondition
;           push arg1
;           call WOWApi ; the actual thunk to wow32/server
;        @@:
;      endif
;
;      if exists, includes code in apispecificcode_api
;      endif
;   cEnd
;   sEnd CODE
;
;                                                          - nanduri
;--------------------------------------------------------------------------


USER16CLIENTTHUNK  macro Iapi, api, argtypeslist, returntype, api32, apispecificcode, callserver

    ;*** declare api
    ;

    index = 0
    IRP argtype, <argtypeslist>
       index = index + 1
    ENDM

    IFB <api32>
        CALLORDECLARE <externFP>, _&api, %(index*4)
    ELSE
        CALLORDECLARE <externFP>, _&api32, %(index*4)
    ENDIF

    sBegin CODE                       ; _&api

    ;*** create thunk to wow32
    ;

    IFNB <callserver>
        FUN_WOW&api equ FUN_&api
        DUserThunk WOW&api, %(size api&16)
    ENDIF

    ;*** create thea Api label
    ;

    IFNB <api>
        IFIDNI <Iapi>, <DUSERTHUNK>
            cProc &api, <PUBLIC, FAR, PASCAL>, <ds>
        ELSE
            cProc I&api, <PUBLIC, FAR, PASCAL>, <ds>
        ENDIF
    ENDIF
    
    ;*** declare args
    ;

    nargcount = 0
    IRP argtype, <argtypeslist>
        nargcount = nargcount + 1
        IFIDNI <argtype>, <WORD>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <INT>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <SHORT>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <DWORD>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <LONG>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <ULONG>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <PSZ>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <NONOPTPSZ>
            genparam D, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <HWND>
            genparam W, arg%(nargcount)
        ENDIF
        IFIDNI <argtype>, <HHOOK>
            genparam D, arg%(nargcount)
        ENDIF
    ENDM

    ;*** begin body
    ;

    cBegin
    
       ;*** set 32bit registers
       ;

       SETFLATDSANDFS

       ;*** push args in reverse
       ;

       FailCall = 0
       argtopush = nargcount
       REPT nargcount
           inputargindex = 0
           IRP argtype, <argtypeslist>
               inputargindex = inputargindex + 1
               IFE argtopush - inputargindex
                   IFIDNI <argtype>, <WORD>
                       pushWORD_DWORD arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <INT>
                       pushINT_LONG   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <SHORT>
                       pushINT_LONG   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <DWORD>
                       pushDWORD_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <LONG>
                       pushDWORD_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <ULONG>
                       pushDWORD_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <PSZ>
                       pushPSZ_DWORD   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <NONOPTPSZ>
                       FailCall = argtopush ; fails call if null
                       pushPSZ_DWORD   arg%argtopush, &api, %argtopush
                   ENDIF
                   IFIDNI <argtype>, <HWND>
                       pushINT_LONG   arg%argtopush
                   ENDIF
                   IFIDNI <argtype>, <HHOOK>
                       pushHHOOK_DWORD  arg%argtopush
                   ENDIF
               ENDIF
           ENDM
           argtopush = argtopush - 1
       ENDM

       ;*** called user32/client api
       ;

       IFB <api32>
          CALLORDECLARE <call>, _&api, %(nargcount*4)
       ELSE
          CALLORDECLARE <call>, _&api32, %(nargcount*4)
       ENDIF

       ;*** check if we ever need to call server
       ;*** calls the real wow thunk

       IFNB <callserver>
           TESTCALLSERVERCONDITION
           jz @F
           CLEARCALLSERVERCONDITION
           index = 0;
           IRP argtype, <argtypeslist>
              index = index + 1
              pushARG16 arg%index
           ENDM
           call WOW&api
       @@:
       ENDIF

       ;*** check for any api specific compatibility code to execute
       ;

       IFNB <apispecificcode>
           APISPECIFICCODE_&api
       ENDIF

       IF FailCall
       FailCall_&api:
       ENDIF

       IFNB <returntype>
          IRP argtype, <dword, long, ulong>
             IFIDNI <returntype>, <argtype>
                 mov edx, eax
                 shr edx, 16
                 EXITM
             ENDIF
          ENDM

          IFIDNI <returntype>, <boolzero>
              xor ax, ax
          ENDIF

       ENDIF

ifdef DEBUG
       ;LOGARGS &api
endif

    cEnd
    ; end body

    sEnd CODE                            ; _&api
endm

endif ; PMODE32

assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

;;;;;;;;;;sBegin  CODE              ; macro will generate this

APISPECIFICCODE_GETCLIENTRECT macro
    xor eax, eax
endm

APISPECIFICCODE_GETKEYSTATE macro
    mov cl, ah
    and cl, 080h
    or  al, cl
endm

APISPECIFICCODE_GETWINDOWRECT macro
    xor eax, eax
endm

; The following call is only for a dBase for Windows 5.0 bug. Notice however, that this
; means that the internal KERNEL api WowSetCompatHandle will be called for every
; single invocation of GetDlgItem, no matter what app is running. This is bad, but
; on X86 platforms we don't transition to WOW32, and the cost of testing for it
; is just about as expensive as just saving it. Still, this should be removed as
; soon as we are convinced that the dBase bug has been fixed. -NeilSa
APISPECIFICCODE_GETDLGITEM macro
     push ax
     call WowSetCompatHandle
endm

public _wow16gpsi
public _wow16CsrFlag
public _wow16gHighestUserAddress

sBegin CODE
_wow16gpsi            DD 0
_wow16CsrFlag         DD 0
_wow16gHighestUserAddress  DD 0
sEnd   CODE

    ; the following may end up calling wow32

    USER16CLIENTTHUNK UserThunk,   DEFHOOKPROC,      <int, word, dword, hhook>, dword, WOW16DefHookProc,,srvcond
    USER16CLIENTTHUNK UserThunk,   ENABLEMENUITEM,   <hwnd, word, word>, word,,,srvcond
    USER16CLIENTTHUNK DUserThunk,  GETKEYSTATE,      <int>, int,, compatcode, srvcond
    USER16CLIENTTHUNK UserThunk,   GETKEYBOARDSTATE, <nonoptpsz>, boolzero,,,srvcond

    ; the following are all thunked locally

    USER16CLIENTTHUNK UserThunk,   CLIENTTOSCREEN,   <hwnd, psz>,boolzero
    USER16CLIENTTHUNK UserThunk,   GETCLASSNAME,     <hwnd, psz, word>, word, GETCLASSNAMEA
    USER16CLIENTTHUNK UserThunk,   GETCLIENTRECT,    <hwnd, psz>, bool,,compatcode
    USER16CLIENTTHUNK UserThunk,   GETCURSORPOS,     <psz>, boolzero
    USER16CLIENTTHUNK DUserThunk,  GETDESKTOPHWND,   <>, hwnd, GETDESKTOPWINDOW
    USER16CLIENTTHUNK DUserThunk,  GETDESKTOPWINDOW, <>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETDLGITEM,       <hwnd, word>, hwnd,,compatcode
    USER16CLIENTTHUNK UserThunk,   GETMENU,          <hwnd>, hmenu
    USER16CLIENTTHUNK UserThunk,   GETMENUITEMCOUNT, <hwnd>, int
    USER16CLIENTTHUNK UserThunk,   GETMENUITEMID,    <hwnd, int>, uint
    USER16CLIENTTHUNK UserThunk,   GETMENUSTATE,     <hwnd, word, word>, uint
    USER16CLIENTTHUNK DUserThunk,  GETNEXTWINDOW,    <hwnd, word>, hwnd, GETWINDOW
    USER16CLIENTTHUNK UserThunk,   GETPARENT,        <hwnd>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETSUBMENU,       <hwnd, int>, hmenu
    USER16CLIENTTHUNK UserThunk,   GETSYSCOLOR,      <int>, dword
    USER16CLIENTTHUNK UserThunk,   GETSYSTEMMETRICS, <int>, int
    USER16CLIENTTHUNK UserThunk,   GETTOPWINDOW,     <hwnd>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETWINDOW,        <hwnd, word>, hwnd
    USER16CLIENTTHUNK UserThunk,   GETWINDOWRECT,    <hwnd, psz>, bool,,compatcode
    USER16CLIENTTHUNK DUserThunk,  ISWINDOW,         <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   SCREENTOCLIENT,   <hwnd, psz>, boolzero
ifdef DEBUG
    USER16CLIENTTHUNK UserThunk,   ISCHILD,          <hwnd, hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISICONIC,         <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISWINDOWENABLED,  <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISWINDOWVISIBLE,  <hwnd>, bool
    USER16CLIENTTHUNK UserThunk,   ISZOOMED,         <hwnd>, bool
else
    USER16CLIENTTHUNK DUserThunk,  ISCHILD,          <hwnd, hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISICONIC,         <hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISWINDOWENABLED,  <hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISWINDOWVISIBLE,  <hwnd>, bool
    USER16CLIENTTHUNK DUserThunk,  ISZOOMED,         <hwnd>, bool
endif


;;;;;;;;;sEnd    CODE              ; macro will generate this

sBegin CODE

ifndef PMODE32

    DUserThunk  GETTICKCOUNT, 0
    DUserThunk  GETCURRENTTIME, 0

else

labelFP  <PUBLIC, GETTICKCOUNT>
labelFP  <PUBLIC, GETCURRENTTIME>

    ; the TickCount is accessible from client address space.
    ; refer sdk\inc\ntexapi.h
    ;                                                 - nanduri

.386p
    ; set 32bit ds

    push  ds
    mov   ax, FLATDS
    mov   ds, ax

    ; from  sdk\inc\ntexapi.h  NtGetTickCount - equivalent code

    mov   edx, MM_SHARED_USER_DATA_VA
    mov   eax, [edx].UsTickCountLow
    mul   dword ptr [edx].UsTickCountMultiplier
    shrd  eax,edx,24

    mov   edx, eax
    shr   edx, 010h
    and   ax, NOT GRAINYTIC_RES   ; round off to lower 64 boundary
                ;this is a cheap implemention of WOWCF_GRAINYTICS flag
    pop ds
    retf
.286p

endif

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winlang.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINLANG.ASM
;   Win16 language-dependent string services
;
;   History:
;
;   Created 18-Jun-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--


;****************************************************************************
;*                                                                          *
;*  WinLang.ASM -                                                           *
;*                                                                          *
;*      API calls to support different lanuages                             *
;*                                                                          *
;****************************************************************************

NOTEXT = 1

.xlist
include user.inc
.list

ExternFP       AllocSelector
ExternFP       FreeSelector
ExternFP       PrestoChangoSelector

ExternNP       IAnsiPrev
ExternNP       IAnsiNext

;****************************************************************************
;*                                                                          *
;*  WOW note:  The implementations in this file are the US implementations  *
;*             with all the language driver and DBCS stuff ripped out.      *
;*             PatchUserStrRtnsToThunk, at the bottom of this file, is      *
;*             called during startup of user16 if the locale is other       *
;*             than U.S. English, or if forced to thunk by a registry key.  *
;*             This routine patches each of the APIs implemented here to    *
;*             simply jump to the thunk, with a name beginning "Win32".     *
;*                                                                          *
;*             The StrRtnsPatchTable defined below controls the patching.   *
;*                                                                          *
;****************************************************************************

ExternNP        Win32lstrcmp
ExternNP        Win32lstrcmpi
ExternNP        Win32AnsiPrev
ExternNP        Win32AnsiNext
ExternNP        Win32AnsiUpper
ExternNP        Win32AnsiLower
ExternNP        Win32AnsiUpperBuff
ExternNP        Win32AnsiLowerBuff
ExternNP        Win32IsCharAlpha
ExternNP        Win32IsCharAlphaNumeric
ExternNP        Win32IsCharUpper
ExternNP        Win32IsCharLower

sBegin   DATA
LabelW  StrRtnsPatchTable

;       Location of patch                  Target of jmp patched in
;       -----------------                  ------------------------
        dw codeOffset Ilstrcmp,            codeOffset Win32lstrcmp
        dw codeOffset Ilstrcmpi,           codeOffset Win32lstrcmpi
;
; These two functions need to be thunked only for DBCS builds
;
ifdef   FE_SB
        dw codeOffset IAnsiPrev,           codeOffset Win32AnsiPrev
        dw codeOffset IAnsiNext,           codeOffset Win32AnsiNext
endif ; FE_SB

        dw codeOffset IAnsiUpper,          codeOffset Win32AnsiUpper
        dw codeOffset IAnsiLower,          codeOffset Win32AnsiLower
        dw codeOffset IAnsiUpperBuff,      codeOffset Win32AnsiUpperBuff
        dw codeOffset IAnsiLowerBuff,      codeOffset Win32AnsiLowerBuff
        dw codeOffset IsCharAlpha,         codeOffset Win32IsCharAlpha
        dw codeOffset IsCharAlphaNumeric,  codeOffset Win32IsCharAlphaNumeric
        dw codeOffset IsCharUpper,         codeOffset Win32IsCharUpper
        dw codeOffset IsCharLower,         codeOffset Win32IsCharLower
LabelW  StrRtnsPatchTableEnd
sEnd


createSeg _TEXT, CODE, WORD, PUBLIC, CODE


sBegin  CODE
assumes  CS, CODE
assumes  DS, DATA

ExternNP        MyUpper
ExternNP        MyLower
ExternNP        MyAnsiUpper
ExternNP        MyAnsiLower



;--------------------------------------------------------------------------
;
; The following table contains the primary and secondary weight info.
;
; For alphanumeric characters primary weight is equal to (Ascii + PrimeWt)
; Secondary weight is either 0 or 1 (For all upper case letters zero and
; lower case letters 1);
;
; For non-alphanumeric characters, primary weight is their ASCII value and
; the secondary weight is zero.
;
; Note that the primary weight calculated with this table for the smallest
; of the alpha-numeric character('0') is 100h (30h+D0h), which is more than
; the primary weight of the highest non-alpha-numeric character FFh;
; Thus all non-alpha-numeric characters will sort before any alpha-numeric
; characters;
;
;       Note that 'PrimeWt' field for lowercase letters is B0h instead of
;       D0h because when added with their ascii, it should become exactly
;       equal to the primary weights of their upper-case counterparts;
;
; IMPORTANT NOTE: On 01-17-90, we came across a bug in lstrcmpi() due to
;   the fact that we are not treating characters C0h to FEh as upper and
;   lower case alphas; So, I added some more ranges to the SortStruc table
;   to map the range C0h to D6h onto the range E0h to F6 and to map the
;   range D8h to DEh onto the range F8h to FEh. A value of 20h in the PrimeWt
;   field automatically takes care of this mapping because that is the diff
;   to be added to the uppercase letter to make it lowercase; The secondary
;   weights are as usual 0 for uppercase and 1 for lowercase;
;   --Fix for Bug #8222  --01-17-90-- SANKAR --
;--------------------------------------------------------------------------
SortStruct      STRUC

    StartAscii  db      ?
    EndAscii    db      ?
    PrimeWt     db      ?
    SecondWt    db      ?

SortStruct      ENDS


public SortTable
LabelB  SortTable

        SortStruct      <'0', '9', 0D0h, 0>
        SortStruct      <'A', 'Z', 0D0h, 0>
        SortStruct      <'a', 'z', 0B0h, 1>
        SortStruct      <0C0h, 0D6h, 20h, 0>
        SortStruct      <0D8h, 0DEh, 20h, 0>
        SortStruct      <0E0h, 0F6h,   0, 1>
        SortStruct      <0F8h, 0FEh,   0, 1>
LabelB  SortTableEnd

;*----------------------------------------------------------------------*
;*                                                                      *
;*      GetWeightValues()                                               *
;*         Input:                                                       *
;*              AL = character whose weight values are asked for        *
;*         Output:                                                      *
;*              AX = Primary weight of the character                    *
;*              BL = Secondary weight of the character                  *
;*----------------------------------------------------------------------*

public GetWeightValues
GetWeightValues PROC    NEAR

        xor     ah, ah
        xor     bx, bx  ; Index into the table
        ; Enter the number of entries in the sort table.
        mov     cx, (SortTableEnd - SortTable)/(SIZE SortStruct)
gwv_loop:
        cmp     al, byte ptr SortTable[bx].StartAscii
        jb      gwv_end
        cmp     al, byte ptr SortTable[bx].EndAscii
        jbe     gwv_GetWeights
        add     bx, SIZE  SortStruct
        loop    gwv_loop
        jmps    gwv_end

gwv_GetWeights:
        add     al, byte ptr SortTable[bx].PrimeWt
        adc     ah, 0
        mov     bl, byte ptr SortTable[bx].SecondWt

gwv_end:
        ret

GetWeightValues ENDP


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  lstrcmp(String1, String2) -                                             *
;*                                                                          *
;*    String1 and String2 are LPSTR's to null terminated strings.           *
;*                                                                          *
;*    This function returns -1 if String1 sorts before String2, 0 if String1*
;*    and String2 have the same sorting and 1 if String2 sorts before       *
;*    String1.                                                              *
;*   NOTE: This is case sensitive compare.                                  *
;*                                                                          *
;*   Outside the U.S. English locale, this function is patched to be a      *
;*   near jump to Win32lstrcmp, aka WU32lstrcmp.                            *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc Ilstrcmp, <FAR, PUBLIC>, <SI, DI>
;                              ^^^^^^^^ US_lstrcmp assumes SI, DI saved!

ParmD  lpStr1
ParmD  lpStr2
LocalB SecWeight1       ; Locals used by US_lstrcmp
LocalB SecWeight2
LocalB LocSecWeight
LocalB fCaseSensitive   ; Flag indicating whether it is case sensitive or not.

cBegin
        mov     byte ptr fCaseSensitive, 1    ; Yup! It is case sensitive
        call    US_lstrcmp
cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*      US_lstrcmp                                                      *
;*         US version of string sort(Case sensitive);                   *
;*         Uses locals defined by Ilstrcmp above.
;*      To understand the algorithm, read the comments for SortStruct   *
;*                                                                      *
;*----------------------------------------------------------------------*

public  US_lstrcmp
US_lstrcmp      PROC    NEAR

        push    ds      ; Save ds
        ;Initialise the secondary wt values
        mov     byte ptr SecWeight1, 0
        mov     byte ptr SecWeight2, 0

        ; Load both the strings
        lds     si, lpStr1
        les     di, lpStr2

ss_loop:
        ; Take one char from both the strings.
        mov     al, byte ptr ds:[si]
        xor     ah, ah  ; make secondary wts zero
        mov     dl, byte ptr es:[di]
        xor     dh, dh

        inc     si      ; Move to next character
        inc     di

        cmp     al, 0
        jz      ss_chkprimary   ; Check if lpStr1 has ended

        cmp     dl, 0
        jz      ss_chkprimary   ; Check if lpStr2 has ended

        ; Let us compare the ASCII vaues
        ; If the asciis are equal, then weights are equal
        cmp     al, dl
        je      ss_loop         ; Goto next character

        ; Now, the asciis differ. So, let us find the weights

        ; Let us get the weights for the character of lpStr1 (in ax )

        call    GetWeightValues

        ; ax contains the primary weight of char of lpStr1
        ; bl contains the secondary weight of ditto
        mov     LocSecWeight, bl
        xchg    ax, dx
        call    GetWeightValues

        ; compare primary weights
        ; Primary weight of Str1 in DX and Str2 in AX
        cmp     ax, dx
        jb      CompareRetGT
        ja      CompareRetLT

        ; Check if it is Case-Insensitive compare
        mov     bh, fCaseSensitive
        or      bh, bh
        jz      ss_loop    ; It is case-insensitive; So, no need to consider
                           ; the secondary weightages. Goto next character.

        ; Control comes here only if it is a case sensitive compare.
        ; Now, primaries are equal. Compare secondaries
        mov     bh, LocSecWeight
        cmp     bh, bl
        je      ss_loop         ; Secondaries are equal, Continue

        ; Secondaries are not equal. Check if they are stored already
        mov     cl, SecWeight1
        or      cl, SecWeight2
        jnz     ss_loop         ; Secondaries already exist, continue

        ; Secondaries haven't been saved sofar.Save the secondaries
        mov     SecWeight1, bh
        mov     SecWeight2, bl
        jmps    ss_loop         ; Process the next character

ss_chkprimary:
        ; al, dl contain the primary weights and at least one of them is
        ; zero.
        cmp     al, 0
        ja      CompareRetGT
        cmp     dl, 0
        ja      CompareRetLT

        ; both are zero; they are equal; So, check the secondary values
        mov     bl, SecWeight1
        cmp     bl, SecWeight2
        ja      CompareRetGT
        jb      CompareRetLT

        ; They are identical with equal weightages
        xor     ax, ax
        jmps    CompareRet

CompareRetGT:
        mov     ax, 1
        jmps    CompareRet

CompareRetLT:
        mov     ax, -1

CompareRet:
        pop     ds
        ret

US_lstrcmp      ENDP


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  lstrcmpi(String1, String2) -                                            *
;*    (Case Insensitive compare)                                            *
;*    String1 and String2 are LPSTR's to null terminated strings.           *
;*                                                                          *
;*    This function returns -1 if String1 sorts before String2, 0 if String1*
;*    and String2 have the same sorting and 1 if String2 sorts before       *
;*    String1.                                                              *
;*                                                                          *
;*   Outside the U.S. English locale, this function is patched to be a      *
;*   near jump to Win32lstrcmpi, aka WU32lstrcmpi.                          *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc Ilstrcmpi, <FAR, PUBLIC>, <SI, DI>
;                               ^^^^^^^^ US_lstrcmp assumes SI, DI saved!

ParmD  lpStr1
ParmD  lpStr2
LocalB SecWeight1       ; Locals used by US_lstrcmp
LocalB SecWeight2
LocalB LocSecWeight
LocalB fCaseSensitive   ; Flag indicating whether it is case sensitive or not.

cBegin
        mov     byte ptr fCaseSensitive, 0 ; FALSE => Case-Insensitive.
        call    US_lstrcmp
cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*  AnsiUpper implementation is from Win3.1 US_AnsiUpper()              *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiUpper, aka WU32AnsiUpper.                     *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc    IAnsiUpper, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr

cBegin

        les     di,lpStr
        mov     cx,es
        mov     ax,di
        call    MyUpper         ; if passed a char, just upper case it.
        jcxz    au1
        inc     cx              ; take care of the case of sign propagation
        jz      au1
        dec     cx
        call    MyAnsiUpper     ; otherwise upper case the whole string
        mov     ax, word ptr lpStr ; Now, dx:ax points at original string
au1:    mov     dx,es

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*  AnsiLower implementation is from Win3.1 US_AnsiLower()              *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiLower, aka WU32AnsiLower.                     *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc    IAnsiLower, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr

cBegin
        les     di,lpStr
        mov     cx,es
        mov     ax,di
        call    MyLower         ; if passed a char, just lower case it.
        jcxz    al1
        inc     cx              ; take care of the case of sign propagation
        jz      al1
        dec     cx
        call    MyAnsiLower     ; otherwise lower case the whole string
        mov     ax, word ptr lpStr ; dx:ax points at original string
al1:    mov     dx,es

cEnd



;*----------------------------------------------------------------------*
;*                                                                      *
;*   AnsiUpperBuff implemented from Win3.1 US_AnsiUpperBuff             *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiUpperBuff, aka WU32AnsiUpperBuff.             *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IAnsiUpperBuff, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr
ParmW   iCount

cBegin

        cld
        les     di, lpStr
        mov     si, di
        mov     cx, iCount      ; if iCount=0, the Buff size is 64K.
        mov     dx, iCount      ; Preserve the length of Buffer
su_begin:
        lods    byte ptr es:[si]
        call    MyUpper
        stosb
        loop    su_begin
su_over:
        mov     ax, dx  ; Move the result to ax

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   AnsiLowerBuff implemented from Win3.1 US_AnsiLowerBuff             *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32AnsiLowerBuff, aka WU32AnsiLowerBuff.             *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IAnsiLowerBuff, <FAR, PUBLIC, PASCAL>, <SI, DI>

ParmD   lpStr
ParmW   iCount

cBegin

        cld
        les     di, lpStr
        mov     si, di
        mov     cx, iCount      ; If cx=0, the buff size is 64K
        mov     dx, cx          ; Preserve the length in DX
sl_begin:
        lods    byte ptr es:[si]
        call    MyLower
        stosb
        loop    sl_begin
sl_over:
        mov     ax, dx  ; Move the result to ax

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharLower implemented with Win3.1 US_IsCharLower                 *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharLower, aka WU32IsCharLower.                 *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharLower, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
        call    Loc_Lower
        jc      icl_end

        xor     ax, ax          ; Not lower. So, false
icl_end:

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharUpper implemented with Win3.1 US_IsCharUpper                 *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharUpper, aka WU32IsCharUpper.                 *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharUpper, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
        call    Loc_Upper
        jc      icu_end

        xor     ax, ax
icu_end:

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharAlphaNumeric implemented with Win3.1 US_IsCharAlphaNumeric   *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharAlphaNumeric, aka WU32IsCharAlphaNumeric.   *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharAlphaNumeric, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
        call    Loc_Numeric
        jc      ica_end

        jmps    ica_begin

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   IsCharAlpha implemented with Win3.1 US_IsCharAlpha                 *
;*                                                                      *
;*  Outside the U.S. English locale, this function is patched to be a   *
;*  near jump to Win32IsCharAlpha, aka WU32IsCharAlpha.                 *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   IsCharAlpha, <FAR, PUBLIC, PASCAL>

ParmB   bChar

cBegin

        mov     al, bChar
ica_begin:
        call    Loc_Lower
        jc      ica_end

        call    Loc_Upper
        jc      ica_end

        xor     ax, ax
ica_end:

cEnd


;*----------------------------------------------------------------------*
;*                                                                      *
;*   Loc_Upper, LocLower, Loc_Numeric                                   *
;*                                                                      *
;*   Used by IsCharXxx US implementations                               *
;*                                                                      *
;*      Input:                                                          *
;*         AL = character being tested                                  *
;*      Output:                                                         *
;*         Carry flag set if TRUE                                       *
;*         Carry flag cleared if FALSE                                  *
;*----------------------------------------------------------------------*

public  Loc_Upper
LabelNP    <Loc_Upper>

        cmp     al, 'A'
        jb      Loc_False

        cmp     al, 'Z'
        jbe     Loc_True

        cmp     al, 0C0h
        jb      Loc_False

        cmp     al, 0D7h        ; This is multiply sign in Microsoft fonts, So, ignore;
        je      Loc_False       ; Fix for Bug #1356; SANKAR --08-28-89--;

        cmp     al, 0DEh
        jbe     Loc_True
        jmps    Loc_False

public  Loc_Lower
LabelNP    <Loc_Lower>
        ; 0xDF and 0xFF are Lower case. But they don't have an equivalent
        ; upper case letters;
        ; So, they are treated as special case chars here
        ; Fix for  Bug # 9799 --SANKAR-- 02-21-90 --
        cmp     al, 0DFh
        je      Loc_True

        cmp     al, 0FFh
        je      Loc_True

        ; Fall thro to the next function
        errnz   ($-Loc_IsConvertibleToUpperCase)
public  Loc_IsConvertibleToUpperCase
LabelNP    <Loc_IsConvertibleToUpperCase>

        cmp     al, 'a'
        jb      Loc_False

        cmp     al, 'z'
        jbe     Loc_True

        cmp     al, 0E0h
        jb      Loc_False

        cmp     al, 0F7h        ; This is divide sign in Microsoft fonts; So, ignore
        je      Loc_False;      ; Fix for Bug #1356; SANKAR --08-28-89--;

        cmp     al, 0FEh
        jbe     Loc_True
        jmps    Loc_False

LabelNP    <Loc_Numeric>

        cmp     al, '0'
        jb      Loc_False

        cmp     al, '9'
        ja      Loc_False

Loc_True:
        stc             ; Set carry to indicate true
        jmps    Loc_End

Loc_False:
        clc             ; Clear carry to indicate false

Loc_End:
        ret

;*----------------------------------------------------------------------*
;*                                                                      *
;*   PatchUserStrRtnsToThunk --     *
;*                                                                      *
;*----------------------------------------------------------------------*

cProc   PatchUserStrRtnsToThunk, <PUBLIC, FAR, PASCAL>, <SI,DI>

cBegin
        cCall   AllocSelector, <0>
        cCall   PrestoChangoSelector, <cs, ax>
        push    ax
        pop     es

        mov     si, dataOffset StrRtnsPatchTable ; ds:si = StrRtnsPatchTable
PatchLoop:
        lodsw
        mov     di, ax                           ; di = offset of code to be patched
        mov     ax, 0E9h                         ; opcode for near jump w/2 byte diff.
        stosb                                    ; store jmp opcode
        lodsw
        sub     ax, di                           ; difference between src and target
        sub     ax, 2                            ; encoded difference is based on
                                                 ; address of next instruction
        stosw                                    ; store difference
        cmp     si, dataOffset StrRtnsPatchTableEnd
        jb      PatchLoop

        xor     ax, ax
        push    es                               ; for FreeSelector
        push    ax
        pop     es

        call    FreeSelector
cEnd

sEnd CODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winmisc2.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINMISC2.ASM
;   Win16 misc. user services
;
;   History:
;
;   Created 28-May-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--

;****************************************************************************
;*									    *
;*  WINMISC2.ASM -							    *
;*									    *
;*      Random stuff                                                        *
;*									    *
;****************************************************************************

ifdef WOW
SEGNAME equ <TEXT>
endif

.xlist
include user.inc
include vint.inc
.list

ExternFP <GlobalHandleNorip>
ExternFP <MessageBox>
ExternFP <SysErrorBox>


ifndef WOW
ExternFP <DoBeep>
ExternFP <XCSTODS>
ExternNP <rgbKeyState>
ExternW  <hwndCapture>
ExternW  <fBeep>
ExternW  <fMessageBox>
ExternW  <hwndDragIcon>

ExternA <__WinFlags>

ATOMTABLE   STRUC
at_prime        DW  ?
at_hashTable    DW  ?
ATOMTABLE   ENDS

ATOM    STRUC
a_chain DW  ?
a_usage DW  ?
a_len   DB  ?
a_name  DB  ?
ATOM    ENDS

LocalArena  STRUC
la_prev		DW  ?	; previous arena entry (first entry points to self)
la_next		DW  ?	; next arena entry	(last entry points to self)
la_handle	DW  ?	; back link to handle table entry
LocalArena  ENDS

sBegin DATA

;
; For GetSysMetrics - don't move this stuff. DS positioning is assumed.
;
SM_CMETRICS1 equ 24
SM_CMETRICS2 equ 16

public rgwSysMet
rgwSysMet      dw (SM_CMETRICS1) DUP(0)

; These are 'variable metrics', conviently located the system metrics array.
GlobalW hwndFullScrn, 0
GlobalW iLevelCursor, 0

; These are additions since 2.0
	dw SM_CMETRICS2 DUP(0)


sEnd DATA
endif ;WOW

createSeg _%SEGNAME, %SEGNAME, WORD, PUBLIC, CODE

assumes cs,%SEGNAME
assumes ds,DATA

sBegin %SEGNAME

ifndef WOW
;*--------------------------------------------------------------------------*
;*									    *
;*  GetSystemMetrics() -						    *
;*									    *
;*--------------------------------------------------------------------------*

; int far GetSystemMetrics(iMetric)
; int iMetric;

LabelFP <PUBLIC, GetSystemMetrics>
	    
	    pop     ax			    ; Pop the FAR return
	    pop     dx
	    pop     bx			    ; BX = iMetric
	    push    dx			    ; Restore the FAR return
	    push    ax

	    xor     ax,ax
	    cmp     bx,SM_CMETRICSMAX	    ; Bigger than max?
	    jge	    gsmExit		    ; Yes, exit
	    shl     bx,1		    ; Convert to a byte index

ifndef userhimem
            mov     es,WORD PTR cs:[cstods]
else
            push    ax
            push    ds
            call    XCSTODS
            mov     es,ax
            pop     ds
            pop     ax
endif

assumes es,DATA
	    mov     ax,es:[rgwSysMet+bx]    ; Return the SysMetric value
assumes es,NOTHING
gsmExit:
	    retf


;*--------------------------------------------------------------------------*
;*									    *
;*  MessageBeep() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc MessageBeep, <FAR, PUBLIC>

ParmW beep

cBegin
	    cmp     fBeep,0
	    je	    mbout		; No beeps today....
            mov     ax,beep
            cmp     fMessageBox,0       ; if we are in an INT24 box, let
            je      noint24             ; the sound driver know not to load
            mov     ax,-1               ; anything by passing -1.
noint24:
            push    ax
	    call    DoBeep		; Just call the sound driver guy
mbout:

cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  IsChild() - 							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelFP <PUBLIC, IsChild>
;
;ParmW hwnd
;ParmW hwndChild
;
	    pop     ax			; pop return address
	    pop     dx
	    pop     bx			; bx = hwndChild
	    pop     cx			; cx = hwnd
	    push    dx			; push return address
	    push    ax

	    push    ds
	    UserDStoDS			; es = USER's DS

	    CheckHwnd cx		; checkhwnd will zero ax if failure
	    jz	    icexit
ifdef DEBUG
	    CheckHwndNull bx 		; only do check if debug since 
	    jz	    icexit              ; we never access anything off this
                                        ; pointer
endif
	    xor     ax,ax		; Assume FALSE
icloop:
	    or	    bx,bx		; while (hwndChild == NULL &&
	    jz	    icexit
	    mov     dl,byte ptr [bx+WSTATE+WFTYPEMASK/256]
	    and     dl,LOW(WFTYPEMASK)	; TestwndChild(hwndChild))
	    cmp     dl,LOW(WFCHILD)
	    jne     icexit
	    mov     bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
	    cmp     bx,cx		; if (hwnd == hwndChild)
	    jne     icloop
	    inc     al			; return(TRUE);
icexit:
	    pop     ds
	    retf

; BOOL IsDescendant(hwndParent, hwndChild);
;
; Internal version of IsChild that is a bit faster and ignores the
; WFCHILD business.  MUST be called with DS == USER DS.
;
; Returns TRUE if hwndChild == hwndParent (IsChild doesn't)
;
;   while (hwndChild != NULL)
;   {
;	if (hwndParent == hwndChild)
;	    return TRUE;
;	hwndChild = hwndChild->hwndParent;
;   }
;
LabelFP     <PUBLIC, IsDescendant>
	    pop     ax			; pop off return address
	    pop     dx
	    pop     bx			; bx = hwndChild
	    pop     cx			; cx = hwndParent
	    push    dx			; replace return address
	    push    ax

	    xor     ax,ax		; assume FALSE
idloop:
	    or	    bx,bx		; if at end, return FALSE
	    jz	    idexit
	    cmp     bx,cx		; hwndChild == hwndParent?
	    mov     bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
	    jnz     idloop		; keep looping if we didn't find it...

	    inc     al			; ax = TRUE
idexit:
	    retf

;--------------------------------------------------------------------------
;
; IsWindowVisible() -
;
;--------------------------------------------------------------------------
;
; BOOL FAR PASCAL IsWindowVisible(register HWND hwnd)
; {
;     if (!CheckHwnd(hwnd))
;	  return(FALSE);
;
;     if (hwnd == hwndDragIcon)
;	  return(TRUE);
;
;     for ( ; hwnd != NULL; hwnd = hwnd->hwndParent)
;     {
;	  if (!TestWF(hwnd, WFVISIBLE))
;	      return FALSE;
;     }
;     return TRUE;
; }
;
LabelFP <PUBLIC, IsWindowVisible>
;ParmW hwnd
	    pop     ax			; pop return address
	    pop     dx
	    pop     bx			; bx = hwnd
	    push    dx			; push return address
	    push    ax

	    push    ds
	    UserDStoDS			; es = USER's DS

	    CheckHwnd bx		; checkhwnd will zero ax if failure
	    jz	    ivwexit

	    mov     ax,TRUE		; assume TRUE

; Check if this is the iconic window being moved around with a mouse */
; If so, return a TRUE, though, strictly speaking, it is hidden.     */
; This helps the Tracer guys from going crazy!			     */
; Fix for Bug #57 -- SANKAR -- 08-08-89 --			     */
;
	    cmp     bx,hwndDragIcon	; hwnd == hwndDragIcon?
	    jz	    ivwexit		; yes: return TRUE.
ivwloop:
	    or	    bx,bx		; while (hwndChild == NULL &&
	    jz	    ivwexit
	    TSTWF   bx,WFVISIBLE
	    mov     bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
	    jnz     ivwloop		; if visible bit set, keep looping

	    xor     ax,ax		; visible bit clear: return FALSE
ivwexit:
	    pop     ds
	    retf


;=======================================================================
;
; Return whether or not a given window can be drawn in or not.
;
; BOOL FAR IsVisible(HWND hwnd, BOOL fClient)
; {
;     HWND hwndT;
;
;     for (hwndT = hwnd; hwndT != NULL; hwndT = hwndT->hwndParent)
;     {
;	  // Invisible windows are always invisible
;	  //
;	  if (!TestWF(hwndT, WFVISIBLE))
;	      return FALSE;
;
;	  if (TestWF(hwndT, WFICONIC))
;	  {
;	      // Children of icons are always invisible.
;	      //
;	      if (hwndT != hwnd)
;		  return FALSE;
;
;	      // Client areas with class icons are always invisible.
;	      //
;	      if (fClient && hwndT->pcls->hIcon)
;		  return FALSE;
;	  }
;     }
;     return TRUE;
; }
;
LabelFP <PUBLIC, IsVisible>
	pop	ax
	pop	dx
	pop	cx	    ; cx = fClient
	pop	bx	    ; bx = hwnd
	push	dx
	push	ax

	mov	dx,bx	    ; hwnd = dx, bx = hwndT
	xor	ax,ax	    ; assume FALSE return
	jmps	iv100	    ; fall into loop...
ivloop:
	mov	bx,[bx].wndPwndParent ; hwndChild = hwndChild->hwndParent
iv100:
	or	bx,bx
	jz	ivtrue	    ; Reached the top: return TRUE

	TSTWF	bx,WFVISIBLE ; if not visible, get out of here.
	jz	ivfalse

	TSTWF	bx,WFMINIMIZED ; if not minimized, keep looping
	jz	ivloop

	cmp	bx,dx	    ; if (hwnd != hwndT)
	jnz	ivfalse     ;	return FALSE

	jcxz	ivloop	    ; if fClient == FALSE, keep going.

	mov	bx,[bx].wndPcls
	mov	bx,[bx].uclshIcon
	or	bx,bx
	jnz	ivfalse
	mov	bx,dx	    ; resume enumeration at bx
	jmps	ivloop	    ; keep looping...
ivtrue:
	inc	al	    ; ax = TRUE
ivfalse:
	retf

;*--------------------------------------------------------------------------*
;*									    *
;*  GetMenu() - 							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetMenu, <FAR, PUBLIC>,<si>

ParmW hwnd

cBegin
	    mov     si,hwnd
	    CheckHwnd si
	    jz	    gmexit
	    mov     ax,[si].wndhMenu
gmexit:

cEnd
endif ;WOW

;*--------------------------------------------------------------------------*
;*									    *
;*  SwapHandle() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Takes a far pointer to a word on the stack and converts it from a handle
; into a segment address or vice-versa.  Note that this function is a NO OP 
; in protect mode.

ifndef PMODE
cProc SwapHandle, <PUBLIC, FAR, NODATA, ATOMIC>

ParmD lpHandle

cBegin
ifndef WOW
            mov     ax,__WinFlags
            test    ax,1
            jnz     sh200            ; SwapHandle is a no op in pmode.
endif
	    ; Save the parameter.
	    mov     bx,off_lpHandle
	    push    bx

	    ; Get the handle/segment
	    mov     ax,word ptr ss:[bx]+2
	    push    ax			    ; Save it

	    ; Call GlobalHandleNorip which puts the proper handle in AX
	    ;  and the corresponding segment address in DX.
	    push    ax
	    call    GlobalHandleNorip

	    ; Restore the original word.
	    pop     bx

	    ; If DX==CS then we know we've converted a handle into a segment.
	    ;	This prevents problems with the FFFE segment.
	    mov     cx,cs
	    cmp     dx,cx
	    je	    sh50

	    ; Was the original word a segment address?
	    test    bl,1
	    jnz     sh100		    ; Yes, AX = handle, DX = segment

sh50:	    xchg    ax,dx		    ; Nope, AX = segment, DX = handle

	    ; Restore the pointer to the original word.
sh100:	    pop     bx

	    ; Skip if zero.
	    or	    ax,ax
	    jz	    sh200

	    ; Move the result into the original word pointed to.
	    mov     word ptr ss:[bx]+2,ax
sh200:
cEnd
endif ;PMODE

ifndef WOW
;*--------------------------------------------------------------------------*
;*									    *
;*  SwapMouseButton() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

; BOOL SwapMouseButton(fSwap)
; BOOL fSwap;

LabelFP <PUBLIC, SwapMouseButton>
            mov     ax,_INTDS
            mov     es,ax
assumes es,INTDS
	    mov     ax,es:fSwapButtons	; Return fSwapButtons' old value
	    pop     cx			; Pop off the FAR return
	    pop     dx
	    pop     es:[fSwapButtons]	; fSwapButtons = fSwap

            mov     bx,es:[fSwapButtons]
assumes es,NOTHING

            mov     es,WORD PTR cs:[cstods] ; Get user's ds
assumes es,DATA
            mov     es:[rgwSysMet+SM_SWAPBUTTON*2],bx
assumes es,NOTHING

	    push    dx			; Restore the FAR return
	    push    cx
	    retf
assumes es,NOTHING

endif; Not WOW


;*--------------------------------------------------------------------------*
;*									    *
;*  SetDivZero() -							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelFP <PUBLIC, SetDivZero>
	    push    ds
	    push    cs			; Set DS == CS
	    pop     ds
ifndef userhimem
            mov     dx,Offset DivideByZero
else
            push    ds
            mov	    ax, _INTDS
            mov     ds,ax
assumes ds,INTDS
            mov     ax,fffedelta
            pop     ds
assumes ds,DATA
            add     ax,Offset DivideByZero
            mov     dx,ax
endif
sdzvector:
	    mov     ax,2500h		; Use DOS to set interrupt zero
	    int     21h
	    pop     ds
	    retf



;*--------------------------------------------------------------------------*
;*									    *
;*  DivideByZero() -							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelFP <PUBLIC, DivideByZero>
            FSTI
ifdef DEBUG
            pusha
            push    es
endif

	    ; Put up the system modal message box.
            mov     cx,_INTDS
ifdef WOW
            ; Put up the SysErrorBox Directly
            push    cx
            lea     ax,szDivZero
            push    ax

            push    cx
            lea     ax,szSysError
            push    ax

ifdef DEBUGlater

            push    SEB_CLOSE
            push    0
            push    SEB_CANCEL
            call    SysErrorBox
            cmp     ax,SEB_BTN1
            jz      DBZ_Terminate

            pop     es
            popa
            DebugErr DBF_FATAL, "Divide by zero or divide overflow error: break and trace till IRET"
            iret

DBZ_Terminate:
            pop     es
            popa
else ; FREE Build
            push    0                       ; no button 1
            push    SEB_CLOSE               ; only allow close
            push    0                       ; no button 3
            call    SysErrorBox
endif; FREE Build
	    mov     ax,4C00h		    ; Abort the task with a 0
            int     21h

else; Not WOW
	    xor     ax,ax
	    push    ax			    ; NULL hwnd
	    lea     ax,szDivZero
	    push    cx
	    push    ax			    ; Message Text
	    lea     ax,szSysError
	    push    cx
	    push    ax			    ; Caption Text
ifdef DEBUG
	    mov     ax,MB_SYSTEMMODAL OR MB_ICONHAND OR MB_OKCANCEL
else
	    mov     ax,MB_SYSTEMMODAL OR MB_ICONHAND
endif
	    push    ax
            call    MessageBox
ifdef DEBUG
            cmp     ax,1                 ; If OK Button clicked, terminate app
            jz      DBZ_Terminate

            pop     es
            popa
            DebugErr DBF_FATAL, "Divide by zero or divide overflow error: break and trace till IRET"
            iret

DBZ_Terminate:
            pop     es
            popa
endif
endif; Not WOW
	    mov     ax,4C00h		    ; Abort the task with a 0
            int     21h

ifndef WOW

;-------------------------------------------------------------------------
;
;   word FAR PASCAL GetUserLocalObjType(pObj)
;     Given a near pointer to an object in USER's local heap, this function
;     determines the type of the object and returns it;
;   It finds out if the given object is a non-tagged belonging to the atom
;   table; If not, it looks at the tag and returns the object type.
;
;   WARNING:  Because this function determines the type of the object by
;   the process of elimination, the results will be unpredictable if the 
;   input in incorrect. i.e., no validation is done on the input value;
;   To validate if the input value is indeed an object in USER's heap would
;   warant a walk down the heap; This will be very costly, if done for
;   every call; Apps like HeapWalker are expected to walk down the USER's
;   local heap and make calls to this function for every object thay come
;   accross; So, a validation done here is duplication of effort and affect
;   the performance unnecessarily
;
;
;-------------------------------------------------------------------------

ifndef DEBUG
; The following is in the RETAIL version of USER
LabelFP	<PUBLIC, GetUserLocalObjType>
	xor   ax, ax	; Return Unknown struct type
	retf  2		; Compensate for the WORD parameter
else
; The following is in the DEBUG version of USER

cProc	GetUserLocalObjType, <PUBLIC, FAR>, <si, di>

ParmW	pObj	; Near pointer to an OBJ in USER's heap

cBegin
	; Now DS register is pointing to USER's DS
	;
	; Check if the object is a moveable object
	mov	bx, pObj
	mov	ax, [bx].la_prev
	test	ax, 01   ; is it a free object
	jz	FoundFreeObj
	test	ax, 02	 ; Is it a moveable object
	jz      FoundFixedObj
	; Now, it is a moveable obj; So, we have the tags
	mov	al, byte ptr [bx + SIZE LocalArena]
	xor     ah, ah
	jmps	FoundObjType

FoundFreeObj:
	mov	ax, ST_FREE
	jmps	FoundObjType

FoundFixedObj:
	; Assume that the object belongs to atom table
	mov	ax, ST_ATOMS

	; Check if this object is the atom table itself
	add	bx, SIZE LocalArena - 2
	cmp	bx, ds:[8]	; pAtomTable  is at this offset.
	je	FoundObjType

	; Check if this is possibly an atom string. If so, the first word
	; stored in this object is a ptr to the next string or NULL;
	; Check if the last two bits are zero; If they are not zero, then
	; this can not be an atom; If they are zero, this may or may not be
	; an atom;

	mov	cx, [bx]
	and	cx, 03h
	jnz	NotAnAtom

	; Now walk down the atom table and check each entry against the 
	; given object

	mov	dx, bx	; save the near pointer to the object
	mov	bx, ds:[8]	; Get the pointer to the atom table pAtomTable
	mov	cx, [bx].at_prime	; Get the number of entries
	; Skip to the first entry in the atom table
	errnz   <at_hashtable - 2>
AtomLoop2:
	errnz	<SIZE at_hashtable - 2>
	add	bx, 2			; 
	errnz   <a_chain>
	mov	si, [bx]	; Pointer to the next string
AtomLoop:
	or	si, si
	jz	NextBucket	; Goto NextBucket

	;Check the new atom matches the given object
	cmp	si, dx
	jz	FoundObjType	; AX already has ST_ATOMS in it
	mov	si, [si].a_chain
	jmps	AtomLoop

NextBucket:
	loop	AtomLoop2
	mov	bx, dx 	       ; Make bx point to the first byte of the object

NotAnAtom:
	; bx points to the tag byte of the object
	xor	ah, ah
	mov	al, byte ptr [bx]
FoundObjType:
	; ax already contains the proper return value 
cEnd
endif

endif ;WOW


;*--------------------------------------------------------------------------*
;*									    *
;*  mouse_event() -                                                         *
;*									    *
;*--------------------------------------------------------------------------*

;       Mouse interrupt event routine
;
;       Entry:  (ax) = flags:
;                 01h = mouse move
;                 02h = left button down
;                 04h = left button up
;                 08h = right button down
;                 10h = right button up
;		  20h = middle button down
;		  40h = middle button up
;               8000h = absolute move
;               (bx) = dX
;               (cx) = dY
;               (dx) = # of buttons, which is assumed to be 2.
;               (si) = extra info loword (should be null if none)
;		(di) = extra info hiword (should be null if none)
;
;       Exit:   None
;
;       Uses:   All registers
;

ExternFP <MouseEvent> ; Thunk in user4.asm

LabelFP <PUBLIC, mouse_event>
        push    si                          ; Preserve the same regs as Win3.1
        regptr  disi,di,si
        cCall   <FAR PTR MouseEvent>, <ax,bx,cx,dx,disi>
        pop     si
        retf

LabelFP <PUBLIC, GetMouseEventProc>
        mov     dx,cs
        mov     ax,offset mouse_event
        retf


;*--------------------------------------------------------------------------*
;*									    *
;*  keybd_event() -                                                         *
;*									    *
;*--------------------------------------------------------------------------*

; Keyboard interrupt handler.
;
; ENTRY: AL = Virtual Key Code, AH = 80 (up), 00 (down)
;	 BL = Scan Code
;	 BH = 0th bit is set if it is an enhanced key(Additional return etc.,).
;        SI = LOWORD of ExtraInfo for the message
;	 DI = HIWORD of ExtraInfo for the message
;
; NOTES: This routine must preserve all registers.

ExternFP <KeybdEvent> ; Thunk in user4.asm

LabelFP <PUBLIC, keybd_event>
	    push    es			    ; Preserve the registers
	    push    dx
	    push    cx
	    push    bx
            push    ax
            regptr  disi,di,si
            cCall   <FAR PTR KeybdEvent>, <ax,bx,disi>
            pop     ax
            pop     bx
            pop     cx
            pop     dx
            pop     es
            retf

sEnd %SEGNAME

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winnet.asm ===
;
;   WINNET.ASM
;
;   Access to WINNET calls via user
;
;

memS=1
?WIN=1
?PLM=1

.xlist
include cmacros.inc
.list

WN_SUCCESS      equ 0
WN_NOT_SUPPORTED    equ 1       ; returned if no function exported

;
;   Network information structure, containing the
;   list of driver entrypoints
;
netinfo struc

    lpfnOpenJob     dd  ?       ; @1
    lpfnCloseJob    dd  ?       ; @2
    lpfnAbortJob    dd  ?       ; @3
    lpfnHoldJob     dd  ?       ; @4
    lpfnReleaseJob  dd  ?       ; @5
    lpfnCancelJob   dd  ?       ; @6
    lpfnSetJobCopies    dd  ?       ; @7
    lpfnWatchQueue  dd  ?       ; @8
    lpfnUnwatchQueue    dd  ?       ; @9
    lpfnLockQueueData   dd  ?       ; @10
    lpfnUnlockQueueData dd  ?       ; @11
    lpfnGetConnection   dd  ?       ; @12
    lpfnGetCaps     dd  ?       ; @13
    lpfnDeviceMode  dd  ?       ; @14
    lpfnBrowseDialog    dd  ?       ; @15
    lpfnGetUser     dd  ?       ; @16
    lpfnAddConnection   dd  ?       ; @17
    lpfnCancelConnection dd ?       ; @18
    lpfnGetError    dd  ?       ; @19
    lpfnGetErrorText    dd  ?       ; @20
    lpfnEnable      dd  ?       ; @21
    lpfnDisable     dd  ?       ; @22
    lpfnRestoreConnection dd ?      ; @23
    lpfnWriteJob    dd  ?       ; @24
    lpfnConnectDialog   dd  ?       ; @25
    lpfnDisconnectDialog dd ?       ; @26
    lpfnConnectionDialog dd ?       ; @27
    lpfnViewQueueDialog dd  ?       ; @28
    lpfnPropertyDialog  dd  ?       ; @29
    lpfnGetDirectoryType dd ?       ; @30
    lpfnDirectoryNotify dd  ?       ; @31
    lpfnGetPropertyText dd  ?       ; @32

netinfo  ends

createSeg   _%SEGNAME,cd,word,public,CODE

sBegin data

pNetInfo    dw     0       ; near pointer to network information
public pNetInfo

hWinnetDriver  dw  0       ; handle to driver module
public hWinnetDriver

sEnd data


sBegin cd
assumes cs,cd
assumes es,data

;-----------------------
;   NetCall
;
;   Move the offset of the function pointer in the net info structure, and
;   call the function which does the bulk of the work (near call).  If the
;   call runs into an error, it will return, otherwise, it will not return,
;   it will pop the return address and jump to the net driver.  No prologue
;   or epilogue needs to be generated.  If CallNetDriver returns, though,
;   we need to pop the parameters off the stack.  In cMacros, the size of
;   these parameters is stored in the ?po variable.
;
;   ?po gets set to zero in order to avoid a WHOLE LOT of "possible invalid
;   use of nogen" warning messages.
;
;   Realize that this is, after all, a hack, the purpose of which is to
;   reduce code.
;
NetCall macro   lpfn

__pop   =   ?po
?po =   0

&cBegin <nogen>

    mov     bx,lpfn
    call    CallNetDriver
    ret     __pop

&cEnd <nogen>

endm

;--------------------------------------------------------------------------
;   CallNetDriver
;
;   This function does all the work.  For each entry point there is a small
;   piece of code which loads the offset of the function pointer in the net
;   info structure into SI and calls this function.  This function verifies
;   that the net driver is loaded and calls the appropriate function
;

LabelFP <PUBLIC, FarCallNetDriver>
CallNetDriver   proc    near

    mov     ax,_DATA
    mov     es,ax

    cmp     es:pNetInfo,0      ; net driver loaded?
    jz      cnd_error           ; return error code

    add     bx,es:pNetInfo     ; add the base of the table
    cmp     word ptr es:[bx+2],0    ; is there a segment there?
    jz      cnd_error           ; NULL, return error code

    pop     ax              ; remove near return address

    jmp     dword ptr es:[bx]       ; jump into net driver

cnd_error:
    mov     ax,WN_NOT_SUPPORTED     ; return error code
    ret                 ; return to entry point code

CallNetDriver   endp

;--------------
;   WNetGetCaps
;
;   This function returns a bitfield of supported functions rather than an
;   error code, so we return 0 (no functions supported) instead of an error
;   code if there is no driver GetCaps function to call.  Also, hack to get
;   handle for index -1.
;

cProc WNetGetCaps2, <FAR,PUBLIC>

    parmW   nIndex

cBegin  <nogen>

    mov     bx,lpfnGetCaps
    call    CallNetDriver
    xor     ax,ax
    ret     ?po

cEnd    <nogen>

if 0
; this is now in C (net.c)
assumes ds,data

cProc IWNetGetCaps, <FAR,PUBLIC, NODATA>

    parmW   nIndex

cBegin
    cmp     nIndex, 0FFFFh
    jz      gc_gethandle
    cCall   WNetGetCaps2, <nIndex>
    jmp     short gc_exit

gc_gethandle:
    mov     ax, _DATA
    mov     es, ax
assumes es, DATA
    mov     ax, es:hWinnetDriver
assumes es, NOTHING

gc_exit:
cEnd

assumes ds,nothing
endif


;--------------
;   IWNetGetUser
;
cProc IWNetGetUser, <FAR,PUBLIC, NODATA>

    parmD   szUser
    parmD   lpBufferSize

NetCall lpfnGetUser


;--------------------
;   IWNetAddConnection
;
cProc IWNetAddConnection , <FAR, PUBLIC, NODATA>

    parmD szNetPath
    parmD szPassword
    parmD szLocalName

NetCall lpfnAddConnection

;-----------------------
;   IWNetCancelConnection
;
cProc IWNetCancelConnection , <FAR, PUBLIC, NODATA>

    parmD szName
    parmW fForce

NetCall lpfnCancelConnection

;---------------------
;   IWNetGetConnection
;
cProc IWNetGetConnection , <FAR, PUBLIC, NODATA>

    parmD lpszLocalName
    parmD lpszRemoteName
    parmD lpcbBuffer

NetCall lpfnGetConnection


;--------------------
;   IWNetOpenJob
;
cProc IWNetOpenJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmD szJobTitle
    parmW nCopies
    parmD lpfh

NetCall lpfnOpenJob

;--------------------
;   IWNetCloseJob
;
cProc IWNetCloseJob , <FAR, PUBLIC, NODATA>

    parmW fh
    parmD lpidJob
    parmD szQueue

NetCall lpfnCloseJob

;-----------------
;   IWNetHoldJob
;
cProc IWNetHoldJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob

NetCall lpfnHoldJob

;--------------------
;   IWNetReleaseJob
;
cProc IWNetReleaseJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob

NetCall lpfnReleaseJob

;---------------------
;   IWNetCancelJob
;
cProc IWNetCancelJob , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob

NetCall lpfnCancelJob

;--------------------
;   IWNetSetJobCopies
;
cProc IWNetSetJobCopies , <FAR, PUBLIC, NODATA>

    parmD szQueue
    parmW idJob
    parmW nCopies

NetCall lpfnSetJobCopies

;--------------------
;   IWNetDeviceMode
;
cProc IWNetDeviceMode , <FAR, PUBLIC, NODATA>

    parmW   hwnd

NetCall lpfnDeviceMode

;--------------------
;   IWNetBrowseDialog
;
cProc IWNetBrowseDialog , <FAR, PUBLIC, NODATA>

    parmW   hwnd
    parmW   nFunction
    parmD   szPath
    parmD   lpnSize

NetCall lpfnBrowseDialog

;--------------------
;   IWNetWatchQueue
;
cProc IWNetWatchQueue , <FAR, PUBLIC, NODATA>

    parmW   hwnd
    parmD   szLocal
    parmD   szUsername
    parmW   wIndex

NetCall lpfnWatchQueue

;--------------------
;   IWNetUnwatchQueue
;
cProc IWNetUnwatchQueue , <FAR,PUBLIC, NODATA>

    parmD   szQueue

NetCall lpfnUnwatchQueue

;---------------------
;   IWNetLockQueueData
;
cProc IWNetLockQueueData , <FAR, PUBLIC, NODATA>

    parmD   szQueue
    parmD   szUsername
    parmD   lplpQueue

NetCall lpfnLockQueueData

;------------------------
;   IWNetUnlockQueueData
;
cProc IWNetUnlockQueueData , <FAR, PUBLIC, NODATA>

    parmD   szQueue

NetCall lpfnUnlockQueueData

;------------------------
;   IWNetGetError
;
cProc IWNetGetError , <FAR, PUBLIC, NODATA>

    parmD   lpnError

NetCall lpfnGetError

;------------------------
;   IWNetGetErrorText
;
cProc IWNetGetErrorText , <FAR, PUBLIC, NODATA>

    parmW   nError
    parmD   lpBuffer
    parmD   lpnSize

NetCall lpfnGetErrorText

;----------------------
;   IWNetAbortJob
;
cProc IWNetAbortJob , <FAR, PUBLIC, NODATA>

    parmD   lpszQueue
    parmW   fh

NetCall lpfnAbortJob

;-----------------------
;   WNetEnable
;
cProc   WNetEnable, <FAR, PUBLIC, EXPORTED>

NetCall lpfnEnable

;------------------------
;   WNetDisable
;
cProc   WNetDisable, <FAR, PUBLIC, EXPORTED>

NetCall lpfnDisable

;-----------------------
;   WNetWriteJob
;
cProc   WNetWriteJob , <FAR, PUBLIC, EXPORTED>

    parmW   hJob
    parmD   lpData
    parmD   lpcb

NetCall lpfnWriteJob

;-----------------------
;   WNetConnectDialog
;
cProc   WNetConnectDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iType

NetCall lpfnConnectDialog

;-----------------------
;   WNetDisconnectDialog
;
cProc   WNetDisconnectDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iType

NetCall lpfnDisconnectDialog

;-------------------------
;   WNetConnectionDialog
;
cProc   WNetConnectionDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iType

NetCall lpfnConnectionDialog

;---------------------------
;   WNetViewQueueDialog
;
cProc   WNetViewQueueDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmD   lpdev

NetCall lpfnViewQueueDialog

;--------------------------
;   WNetGetPropertyText
;
cProc   WNetGetPropertyText, <FAR, PUBLIC, EXPORTED>

    parmW   iDlg
    parmD   lpName
    parmW   cb

NetCall lpfnGetPropertyText

;--------------------------
;   WNetPropertyDialog
;
cProc   WNetPropertyDialog, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmW   iDlg
    parmD   lpfile

NetCall lpfnPropertyDialog

;---------------------------
;   WNetGetDirectoryType
;
cProc   WNetGetDirectoryType, <FAR, PUBLIC, EXPORTED>

    parmD   lpdir
    parmD   lptype

NetCall lpfnGetDirectoryType

;--------------------------
;   WNetDirectoryNotify
;
cProc   WNetDirectoryNotify, <FAR, PUBLIC, EXPORTED>

    parmW   hwnd
    parmD   lpdir
    parmW   wOper

NetCall lpfnDirectoryNotify

sEnd cd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\wowcomm.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCOMM.C
 *  WOW16 user resource services
 *
 *  History:
 *
 *  Created 28-Apr-1993 by Craig Jones (v-cjones)
 *
 *  This file provides support for the Win 3.1 SetCommEventMask() API.
 *  SetCommEventMask() returns a 16:16 ptr to the app so it can monitor
 *  the event word & shadow MSR.
 *
--*/

#include <windows.h>
#include <wowcomm.h>

int WINAPI WOWCloseComm(int idComDev, LPDWORD lpdwEvts);
int WINAPI WOWOpenComm(LPCSTR lpszPort, UINT cbInQ, UINT cbOutQ, DWORD dwEvts);


int WINAPI ICloseComm(int idComDev)
{
    int    ret;
    DWORD  dwEvts = 0;

    // we're really calling wu32CloseComm() here
    ret = WOWCloseComm(idComDev, (LPDWORD)&dwEvts);

    // free this 16:16 memory if it was alloc'd in IOpenComm()
    if(dwEvts) {
        GlobalDosFree((UINT)LOWORD(dwEvts));
    }

    return(ret);
}


int WINAPI IOpenComm(LPCSTR lpszPort, UINT cbInQ, UINT cbOutQ)
{
    int    ret;
    DWORD  dwEvts;

    dwEvts = GlobalDosAlloc((DWORD)sizeof(COMDEB16));

    // we're really calling wu32OpenComm() here
    ret = WOWOpenComm(lpszPort, cbInQ, cbOutQ, dwEvts);

    // if OpenComm() failed - free the 16:16 memory
    if((ret < 0) && (dwEvts)) {
        GlobalDosFree((UINT)LOWORD(dwEvts));
    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\wsphelp.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WSPHELP.ASM
;   Win16 wsprintf/wvsprintf helper services
;
;   History:
;
;   Created 28-May-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--

;
;   WSPHELP.ASM
;
;   Assembly language helper functions for wvsprintf(), primarily for
;   space optimization.
;
;   History:
;	2/15/89     craigc	    Initial
;

memS=1
?PLM=1
?WIN=1
ifdef WOW
SEGNAME equ <TEXT>
endif

.xlist
include cmacros.inc
.list

createSeg   _%SEGNAME,%SEGNAME,WORD,public,CODE

sBegin %SEGNAME

assumes cs,%SEGNAME

;
;   SP_PutNumber
;
;   Takes an unsigned long integer and places it into a buffer, respecting
;   a buffer limit, a radix, and a case select (upper or lower, for hex).
;

cProc	SP_PutNumber, <NEAR,PUBLIC>, <si,di>

    parmD   lpb
    parmD   n
    parmW   limit
    parmW   radix
    parmW   case

cBegin
    mov     al,'a'-'0'-10	    ; figure out conversion offset
    cmp     case,0
    jz	    pn_lower
    mov     al,'A'-'0'-10
pn_lower:
    mov     byte ptr case,al

    mov     bx,word ptr n[0]	    ; bx:dx=number
    mov     dx,word ptr n[2]
    mov     cx,radix		    ; cx=radix
    les     di,lpb		    ; es:di->string
    mov     si,limit		    ; cchLimit
;
;   following adapted from fultoa.asm
;
;   dx:bx = unsigned number, cx = radix, es:di->output
;

divdown:
    xchg    ax,dx		    ; divide hi
    xor     dx,dx
    or	    ax,ax
    jz	    nohigh		    ; save a divide
    div     cx			    ; dx = rem, ax = hi div

nohigh:
    xchg    ax,bx		    ; ax = lo, bx = hi div
    div     cx			    ; dx = rem, bx:ax = div
    xchg    ax,dx		    ; ax = rem, bx:dx = div
    xchg    dx,bx		    ; ax = rem, dx:bx = div (tight!!!!)
    add     al,'0'
    cmp     al,'9'
    jbe     isadig		    ; is a digit already
    add     al,byte ptr case	    ; convert to letter

isadig:
    dec     si			    ; decrement cchLimit
    jz	    pn_exit		    ; go away if end of string
    stosb			    ; stick it in
    mov     ax,dx
    or	    ax,bx
    jnz     divdown		    ; crack out next digit

pn_exit:
    mov     ax,di
    sub     ax,word ptr lpb[0]	    ; find number of chars output

cEnd

;
;   SP_Reverse
;
;   Reverses a string in place
;
cProc  SP_Reverse,<NEAR,PUBLIC>,<si,di>
    parmD   lpFirst
    parmD   lpLast
cBegin
    push    ds
    lds     si,lpFirst
    les     di,lpLast
    mov     cx,di	    ; number of character difference
    sub     cx,si
    inc     cx
    shr     cx,1	    ; number of swaps required
    jcxz    spr_boring	    ; nuthin' to do
spr100:
    mov     ah,es:[di]
    mov     al,[si]	    ; load the two characters
    mov     [si],ah
    mov     es:[di],al	    ; swap them
    inc     si
    dec     di		    ; adjust the pointers
    loop    spr100	    ; ...until we've done 'em all
spr_boring:
    pop     ds
cEnd


sEnd %SEGNAME

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winrect.asm ===
TITLE -  Converted Winrect.c to Assembler

    .286p

    .xlist
    include wow.inc
    include wowusr.inc
    include cmacros.inc
NOEXTERNS=1     ; to suppress including most of the stuff in user.inc
    include user.inc
    .list

sBegin	CODE

assumes cs, CODE
assumes ds, DATA

;******************************************************************************
;                  ORIGINAL C SOURCE
;
;*void FAR SetRect(pRect,left,top,right,bottom)
;*LPRECT  pRect;
;*int     top,left,bottom,right;
;*{
;*        pRect->top    = top;
;*        pRect->left   = left;
;*        pRect->bottom = bottom;
;*        pRect->right  = right;
;*}
;******************************************************************************

cProcVDO   SetRect,<FAR, PUBLIC, NODATA>
;ParmD	lprc
;ParmW	left
;ParmW	top
;ParmW	right
;ParmW	bottom
cBegin	nogen

	mov	bx,sp
	mov	cx,di
beg_fault_trap  sr_trap
        cld
	les	di,ss:[bx]+4+2+2+2+2
	mov	ax,ss:[bx]+4+2+2+2
	stosw
	mov	ax,ss:[bx]+4+2+2
        stosw
	mov	ax,ss:[bx]+4+2
        stosw
	mov	ax,ss:[bx]+4
        stosw
end_fault_trap
sr_cont:
	mov	di,cx
	retf	4+2+2+2+2

cEnd	nogen

sr_trap:
        fault_fix_stack
        jmp     short sr_cont

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*int FAR SetRectEmpty(pRect)
;*LPRECT pRect;
;*{
;*        LFillStruct(pRect,sizeof(RECT),0);
;*}
;*
;******************************************************************************

LabelVDO SetRectEmpty
	pop	ax
	pop	dx

	pop	bx
        pop     cx

	push	dx
	push	ax

	xchg	di,bx

beg_fault_trap  sre_trap
        mov     es,cx

        xor     ax,ax
        cld
        stosw
        stosw
        stosw
        stosw
end_fault_trap

sre_cont:
	mov	di,bx
	retf

sre_trap:
        fault_fix_stack
        jmp     short sre_cont

;******************************************************************************
;*                        ORIGINAL C SOURCE
;*
;*int FAR CopyRect(pDstRect,pSrcRect)
;*LPRECT   pSrcRect;                 /*ptr to source rect                    */
;*LPRECT   pDstRect;                 /*Ptr to dest rect                      */
;*{
;*        LCopyStruct(pSrcRect,pDstRect,sizeof(RECT));
;*                                /*copy from source to dest              */
;*}
;*
;******************************************************************************

cProcVDO CopyRect, <FAR, PUBLIC, NODATA>, <ds, si, di>
        parmD   lpDstRect               ;long pointer to DstRect
        parmD   lpSrcRect               ;long pointer to SrcRect
cBegin
beg_fault_trap  cr_trap
        lds     si, lpSrcRect           ;mov into ds:si a far pointer to SrcRect
        les     di, lpDstRect           ;mov into es:di far pointer to DstRect
        cld                             ;clear direction flag for increment stuff
        movsw
        movsw
        movsw
        movsw
end_fault_trap
cr_cont:
cEnd

cr_trap:
        fault_fix_stack
        jmp     short   cr_cont

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*BOOL FAR IsRectEmpty(pRect)
;*LPRECT pRect;
;*{
;*        return(((pRect->right-pRect->left<=0)||(pRect->bottom-pRect->top<=0)) ? TRUE : FALSE);
;*}
;*
;******************************************************************************

LabelVDO IsRectEmpty
        pop     ax
        pop     dx

        pop     bx                  ; get lprc
        pop     cx

        push    dx
        push    ax

beg_fault_trap  ire_trap
        mov     es,cx
	mov	ax,TRUE
        mov     cx,es:[bx].rcRight
        cmp     cx,es:[bx].rcLeft
	jle	empty0
        mov     cx,es:[bx].rcBottom
        cmp     cx,es:[bx].rcTop
	jle	empty0
	xor	ax,ax
end_fault_trap
empty0:
        retf

ire_trap:
        fault_fix_stack
        jmp     short empty0

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*BOOL FAR PtInRect(lprc, pt)
;*LPRECT lprc;
;*POINT pt;
;*{
;*    return(pt.x >= lprc->left && pt.x < lprc->right &&
;*           pt.y >= lprc->top && pt.y < lprc->bottom);
;*}
;*
;******************************************************************************

cProcVDO PtInRect,<PUBLIC,FAR,NODATA>,<DS,SI>
;   parmD   lpRect
;   parmD   lpPoint
cBegin  nogen

        mov     bx,sp
        push    ds
        push    si

        mov     cx,ss:[bx+4]    ; cx = pt.x
        mov     dx,ss:[bx+6]    ; dx = pt.y

beg_fault_trap  pir_trap
        lds     si,ss:[bx+8]    ; lpRect
        cld
        xor     bx,bx           ; Result = FALSE

        lodsw                   ; AX = lpRect->left
        cmp     cx,ax           ; xcoord < left?
        jl      PtNotInRect     ; Yes, not in rectangle

        lodsw                   ; AX = lpRect->top
        cmp     dx,ax           ; ycoord < top?
        jl      PtNotInRect     ; Yes, not in rectangle

        lodsw                   ; AX = lpRect->right
        cmp     cx,ax           ; xcoord >= right?
        jge     PtNotInRect     ; Yes, not in rectangle

        lodsw                   ; AX = lpRect->bottom
        cmp     dx,ax           ; ycoord >= bottom?
        jge     PtNotInRect     ; Yes, not in rectangle

        inc     bx              ; Point in rectangle, result = TRUE
end_fault_trap
PtNotInRect:
        mov     ax,bx
        pop     si
        pop     ds
        retf    8

cEnd    nogen

pir_trap:
        fault_fix_stack
        jmp     short PtNotInRect

;******************************************************************************
;*                         ORIGINAL C SOURCE
;*
;*int FAR OffsetRect(pRect, x, y)
;*LPRECT  pRect;
;*int     x;
;*int     y;
;*{
;*        pRect->left   += x;
;*        pRect->right  += x;
;*        pRect->top    += y;
;*        pRect->bottom += y;
;*}
;*
;******************************************************************************

cProcVDO   OffsetRect,<FAR, PUBLIC, NODATA>,<DS>
;       parmD   lpRect                  ;far pointer to struct type rect
;       parmW   xDelta                  ;X delta
;       parmW   yDelta                  ;Y Delta
cBegin nogen
        mov     bx,sp
        push    ds
beg_fault_trap  or_trap
        mov     dx,ss:[bx+6]            ; dx = dx
        mov     cx,ss:[bx+4]            ; CX = dy
        lds     bx,ss:[bx+8]            ; ds:bx = lprc
        add     [bx].rcLeft,dx
        add     [bx].rcTop,cx
        add     [bx].rcRight,dx
        add     [bx].rcBottom,cx
end_fault_trap
or_cont:
        pop     ds
        retf    8
cEnd
or_trap:
        fault_fix_stack
        jmp     short or_cont

;******************************************************************************
;*                          ORIGINAL C SOURCE
;*
;*int FAR InflateRect(pRect, x, y)
;*LPRECT  pRect;
;*int     x;
;*int     y;
;*{
;*        pRect->left   -= x;
;*        pRect->right  += x;
;*        pRect->top    -= y;
;*        pRect->bottom += y;
;*}
;*
;******************************************************************************

cProcVDO InflateRect,<FAR, PUBLIC, NODATA>,<DS>
;       parmD   lpRect                  ;far pointer to struct type rect
;       parmW   xOffset
;       parmW   yOffset
cBegin nogen
        mov     bx,sp
        push    ds

beg_fault_trap  ir_trap
        mov     dx,ss:[bx+6]            ; dx = dx
        mov     cx,ss:[bx+4]            ; CX = dy
        lds     bx,ss:[bx+8]            ; ds:bx = lprc
        sub     [bx].rcLeft,dx
        sub     [bx].rcTop,cx
        add     [bx].rcRight,dx
        add     [bx].rcBottom,cx

end_fault_trap
ir_cont:
        pop     ds
        retf    8
cEnd

ir_trap:
        fault_fix_stack
        jmp     short ir_cont

;-----------------------------------------------------------------
;
; IntersectRect(lprcDst, lprcSrc1, lprcSrc2);
;
cProcVDO IntersectRect,<PUBLIC, FAR, NODATA>,<SI, DI, DS>
ParmD   lprcDst
ParmD   lprcSrc1
ParmD   lprcSrc2
cBegin
beg_fault_trap  irc_trap
        lds     si,lprcSrc1       ; point at source rects
        les     di,lprcSrc2

        mov     ax,[si].rcLeft    ; new left = cx = max(rc1.left, rc2.left)
        mov     cx,es:[di].rcLeft
        cmp     ax,cx
        jl      ir100
        xchg    ax,cx
ir100:
        mov     ax,[si].rcRight   ; new right = dx = min(rc1.right, rc2.right)
        mov     dx,es:[di].rcRight
        cmp     ax,dx
        jg      ir200
        xchg    ax,dx
ir200:
        cmp     cx,dx           ; is left >= right?
        jge     irempty         ; yes - return empty rect

        mov     ax,[si].rcTop     ; new top = cx = max(rc1.top, rc2.top)
        mov     bx,es:[di].rcTop
        cmp     ax,bx
        jl      ir300
        xchg    ax,bx
ir300:
        mov     ax,[si].rcBottom  ; new bottom = dx = min(rc1.bottom, rc2.bottom)
        mov     di,es:[di].rcBottom
        cmp     ax,di
        jg      ir400
        xchg    ax,di
ir400:
        cmp     bx,di           ; is top >= bottom?
        jge     irempty         ; no: store result

        lds     si,lprcDst      ; store away new right & left
        mov     [si].rcLeft,cx
        mov     [si].rcTop,bx
        mov     [si].rcRight,dx
        mov     [si].rcBottom,di

        mov     al,TRUE         ; return TRUE
end_fault_trap
irexit:

cEnd

irc_trap:
        fault_fix_stack
irempty:
        les     di,lprcDst      ; point at dst rect
        xor     ax,ax           ; set to (0, 0, 0, 0)
        cld
        stosw
        stosw
        stosw
        stosw                   ; return FALSE
        jmps    irexit

;=============================================================================
;
; BOOL UnionRect(lprcDest, lprcSrc1, lprcSrc2)
; LPRECT lprcDest;
; LPRECT lprcSrc1;
; LPRECT lprcSrc2;
;
; Calculates *lprcDest as the minimum rectangle that bounds both
; *lprcSrc1 and *lprcSrc2.  If either rectangle is empty, lprcDest
; is set to the other rectangle. Returns TRUE if the result is a non-empty
; rectangle, FALSE otherwise.
;
;
cProcVDO UnionRect,<FAR, PUBLIC, NODATA>,<SI, DI, DS>
ParmD   lprcDest
ParmD   lprcSrc1
ParmD   lprcSrc2
LocalW  wTemp
cBegin
beg_fault_trap  ur_trap
        lds     si,lprcSrc1
        les     di,lprcSrc2

        push    es
        push    di
        wcall   IIsRectEmpty
        push    ax                  ; save result

        ; IsRectEmpty trashes es....
        push    es

        push    ds
        push    si
        wcall   IIsRectEmpty

        pop     es                  ; restore it
        pop     cx

    ;ax = IsRectEmpty(1), cx = IsRectEmpty(2)

        or      ax,ax
        jnz     URrc1empty
        mov     ax,TRUE             ; return true, not both empty
        or      cx,cx
        jz      URnormalcase
        jmps    URrc2empty

URrc1empty:
        lds     si,lprcSrc2
        jcxz    URrc2empty          ; rc2 not empty, ax has true for return
        xor     ax,ax               ; return false, both empty

URrc2empty:
        les     di,lprcDest
        cld
        movsw
        movsw
        movsw
        movsw
        jmps    URexit

    ; src1 and src2 not empty

URnormalcase:
        mov     ax,[si].rcLeft      ; bx = min(Src1.left, Src2.left)
        mov     cx,es:[di].rcLeft
        cmp     ax,cx
        jl      URleft
        xchg    ax,cx
URleft:
        mov     bx,ax

        mov     ax,[si].rcTop       ; dx = min(Src1.top, Src2.top)
        mov     cx,es:[di].rcTop
        cmp     ax,cx
        jl      URtop
        xchg    ax,cx
URtop:
        mov     dx,ax

        mov     ax,[si].rcRight     ; wTemp = max(Src1.right, Src2.right)
        mov     cx,es:[di].rcRight
        cmp     ax,cx
        jg      URright
        xchg    ax,cx
URright:
        mov     wTemp,ax

        mov     ax,[si].rcBottom    ; ax = max(Src1.bottom, Src2.bottom)
        mov     cx,es:[di].rcBottom
        cmp     ax,cx
        jg      URbottom
        xchg    ax,cx
URbottom:

        les     di,lprcDest         ; fill into lprcDest
        mov     es:[di].rcLeft,bx
        mov     es:[di].rcTop,dx
        mov     es:[di].rcBottom,ax
        mov     ax,wTemp
        mov     es:[di].rcRight,ax
end_fault_trap

ur_true:
        mov     ax,TRUE             ; return true, not both empty
URexit:
cEnd

ur_trap:
        fault_fix_stack
        jmp     ur_true


;******************************************************************************
;*                        ORIGINAL C SOURCE
;*
;*BOOL FAR EqualRect(lpRect1, lpRect2)
;*LPRECT  lpRect1;
;*LPRECT  lpRect2;
;*{
;*        return lpRect1->left == lpRect2->left && lpRect1->top == lpRect2->top
;*          && lpRect1->right == lpRect1->right && lpRect1->bottom ==
;*          lpRect2->bottom;
;*}
;*
;******************************************************************************

cProcVDO EqualRect, <FAR, PUBLIC, NODATA>, <SI, DI, DS>
        parmD   lpRect1
        parmD   lpRect2
cBegin
        xor     ax,ax           ; assume FALSE
beg_fault_trap  er_trap
        lds     si,lpRect1
        les     di,lpRect2
        mov     cx,4
        cld
        repz    cmpsw
        jnz     er10
        inc     al
end_fault_trap
er10:
cEnd

er_trap:
        fault_fix_stack
        jmp     er10

;****************************************************************************
;  The following Routine to subtract one rectangle from another is lifted
; from PM and Modified by Sankar.
;
;****************************************************************************

;** Public Routine ****************************************************-;
; BOOL far SubtractRect(lprcDest, lprc1, lprc2)
; LPRECT lprcDest;
; LPRECT lprcSrc1;
; LPRECT lprcSrc2;
;
; This function subtracts *lprc2 from *lprc1, returning the result
; in *lprcDest.  Returns TRUE if *lprcDest is non-empty, FALSE otherwise.
;
; Warning:  Subtracting one rectangle from another may not
;           always result in a rectangular area; in this case
;           WinSubtractRect will return *lprc1 in *lprcDest.
;           For this reason, WinSubtractRect provides only an
;           approximation of subtraction.  However, the area
;           described by *lprcDest will always be greater
;           than or equal to the "true" result of the
;           subtraction.
;
; History :
;  	  Added by Sankar on July 27, 1988
;**********************************************************************-;

cProcVDO SubtractRect, <PUBLIC, FAR, NODATA>, <SI, DI, DS>
	ParmD lprcDest
	ParmD lprc1
	ParmD lprc2
	LocalV rc,%size RECT
cBegin
;
; First copy lprc1 into lprcDest.
;
beg_fault_trap  sbr_trap
	lds	si,lprc1
	les	di,lprcDest
        cld
        movsw
        movsw
        movsw
        movsw

        lds     si,lprcDest             ; ds:[si] = lprcDest.
	lea	di,rc			; ss:[di] = &rc
;
; We're subtracting lprc2 from lprc1. Make sure they at least
; intersect each other. If not, return TRUE.
;
	push	ss			; pushd &rc
        push    di
        push    ds                      ; pushd lprcDest
        push    si
        push    seg_lprc2               ; pushd lprc2
        push    off_lprc2
        wcall   IIntersectRect

        or      ax,ax                   ; Did we intersect?
        jz      sr700                   ; If no, skip to check empty rect
;
; Now make sure that we can subtract lprc2 from lprc1 and get a rect.
;
        errnz   <rcLeft   - 0>
        errnz   <rcTop    - 2>
        errnz   <rcRight  - 4>
        errnz   <rcBottom - 6>
;
; We make a loop that iterates twice - once for the x's and once for the
; y's. We want at least 3 sides of lprc2 to be outside of 3 sides of lprc1.
;
        xor     cx,cx
        xor     dx,dx
        dec     cx
;
; ds:si points to lprc1 (actually lprcDest)
; ss:di points to rc on stack
;
sr100:
        inc     cx

        mov     bx,cx
        shl     bx,1                    ; bx is a Word pointer

        mov     ax,ss:[di+bx].rcLeft ; if lprc2 left/top is > lprc1 l/t,
        cmp     ax,ds:[si+bx].rcLeft
        jg      sr200                   ; then inside the rect.
        inc     dx
sr200:
        mov     ax,ss:[di+bx].rcRight ; if lprc2 right/bottom is > lprc1 r/b,
        cmp     ax,ds:[si+bx].rcRight
        jl      sr300                   ; then inside the rect.
        inc     dx
sr300:
        jcxz    sr100                   ; loop one more time...

        cmp     dx,3                    ; Are 3 sides outside? If not,
        jb      sr700                   ; skip to check empty rect code

	cmp	dx,4			; Is rc1 completely inside rc2? If so,
        jne     sr350                   ; empty lprcDest and return TRUE
        
	pushd	lprcDest		; empty that puppy
        wcall   ISetRectEmpty

	xor	ax,ax			; Go return FALSE.
	jmps	srExit
        
sr350:
;
; Now we know that we can take lprc2 from lprc1 and leave a rect, so
; now we perform the 'subtract rect'. Interate twice, again once for the
; x's and once for the y's.
;
        xor     cx,cx
        dec     cx

sr400:
        inc     cx
        mov     bx,cx
        shl     bx,1    ; Make bx a Word pointer

        mov     dx,ss:[di+bx].rcLeft      ; New right/Bottom border?
        cmp     dx,ds:[si+bx].rcLeft
        jle     sr500

        mov     ds:[si+bx].rcRight,dx
        jmps    sr600

sr500:
        mov     dx,ss:[di+bx].rcRight     ; New left/top border?
        cmp     dx,ds:[si+bx].rcRight
        jge     sr600

        mov     ds:[si+bx].rcLeft,dx

sr600:
        jcxz    sr400

sr700:
	xor	ax,ax			; Assume it is empty: FALSE

        mov     cx,ds:[si].rcRight
        cmp     cx,ds:[si].rcLeft
        jle     SrExit

        mov     cx,ds:[si].rcBottom
        cmp     cx,ds:[si].rcTop
        jle     SrExit

	inc	al			; Non-empty: return TRUE.
end_fault_trap
srExit:
cEnd

sbr_trap:
        fault_fix_stack
        xor     ax,ax                   ; return FALSE
        jmp     srExit

;****************************************************************************
;
;  void  FAR  SplitRectangle(lprcRect, lprcRectArray, wcx, wcy)
;  LPRECT  lprcRect
;  RECT    lprcRectArray[4]
;
;  This splits the given rectangular frame into four segments and stores
;  them in the given array
;
;  Pseudo code:
;  -----------
;
;  cxWidth = lprcRect -> rcRight - lprcRect -> rcLeft - wcx;
;  cyWidth = lprcRect -> rcBottom - lprcRect -> rcTop - wcy;
;
;  A = -cyWidth;
;  B = -cxWidth;
;
;  for (i = 0; i < 4; i++)
;  {
;	lprcRectArray[i][i]       = lprcRect[i];
;	lprcRectArray[i][(i+1)&3] = lprcRect[(i+3)&3] + A;
;	lprcRectArray[i][(i+2)&3] = lprcRect[(i+2)&3] + B;
;	lprcRectArray[i][(i+3)&3] = lprcRect[(i+3)];
;	
;	TMP = A;
;	A   = -B;
;	B   = TMP;
;  }
; 
;  Note:
;		Value of i	Value of A	Value of B
;		----------	----------	----------
;		    0		  -cyWidth	-cxWidth
;		    1		  +cxWidth	-cyWidth
;		    2		  +cyWidth      +cxWidth
;		    3             -cxWidth      +cyWidth
;
;			  
;***************************************************************************



cProc SplitRectangle, <FAR, PUBLIC, NODATA>, <SI, DI, DS>
	
	ParmD	<lprcRect, lprcRectArray>	; Rect and Array
	Parmw	<wcx, wcy>			; Border widths

cBegin

	les	di, lprcRectArray		; es:di => lprcRectArray
	lds	si, lprcRect			; ds:si => given rectangle

; Calculate the value of -cxWidth

	mov	ax, [si].rcLeft
	sub	ax, [si].rcRight
	add	ax, wcx

	push	ax			; Save B on stack.

; Calculate the value of -cyWidth

	mov	ax, [si].rcTop
	sub	ax, [si].rcBottom
	add	ax, wcy

	push	ax			; Save A on stack

; Initialise the loop related variables

	xor	cx, cx			; Loop count
	xor	bx, bx			; Index into Rect Structure.

LoopSt:
;	lprcRectArray[i][i]       = lprcRect[i];

	mov	ax, [si+bx]
	mov	es:[di+bx], ax

;	lprcRectArray[i][(i+1)&3] = lprcRect[(i+3)&3] + A;

	inc	bx
	inc	bx	; Make it a word pointer
	and	bx, 6
	push	bx	; Save (i+1) tempoarily
	add	bx, 4   ; Calculate (i+3)
	and	bx, 6
	
	mov	ax, [si+bx]  ;  lprcRect[(i+3)] is taken
	pop	bx	     ;  (i+1) is returned to bx

	pop	dx	     ;  Value "A" is taken from stack
	add	ax, dx
	mov	es:[di+bx], ax  

	; Swap A and B on stack. A is in DX

	pop	ax		; Value B from Stack.
	push	dx		; B = A;
	Push	ax		; A = B;
	
	; Now B is on top of stack and A is below it.


	; lprcRectArray[i][(i+2)&3] = lprcRect[(i+2)&3] + B;
	
	inc	bx
	inc	bx		; (i+2) is calculated
	and	bx, 6
	
	mov	ax, [si+bx]
	pop	dx		; pop B
	add	ax, dx

	mov	es:[di+bx], ax
	neg	dx		; make -B
	push	dx		

	; lprcRectArray[i][(i+3)&3] = lprcRect[(i+3)];
	
	inc	bx
	inc	bx
	and	bx, 6		; make [(i+3)&3]
	
	mov	ax, [si+bx]
	mov	es:[di+bx], ax

	inc	cx
	cmp	cx, 4
	jge	exit

	mov	bx, cx
	shl	bx, 1		; Make it a word pointer
	add	di, size RECT	; Make it point to next rect in the array
	jmp	LoopSt
exit:
	; A and B exist on stack. So,Pop them
	add 	sp, 4

cEnd

	 
sEnd	TEXT
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\wsprintf.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WSPRINTF.C
 *  Win16 wsprintf/wvsprintf code
 *
 *  History:
 *
 *  Created 28-May-1991 by Jeff Parsons (jeffpar)
 *  Copied from WIN31 and edited (as little as possible) for WOW16.
--*/

/*
 *
 *  sprintf.c
 *
 *  Implements Windows friendly versions of sprintf and vsprintf
 *
 *  History:
 *  2/15/89     craigc  Initial
 */

#include "windows.h"
#include "winexp.h"

#define WSPRINTF_LIMIT 1024

extern int near pascal SP_PutNumber(LPSTR, long, int, int, int);
extern void near pascal SP_Reverse(LPSTR lp1, LPSTR lp2);

#define out(c) if (--cchLimit) *lpOut++=(c); else goto errorout

/*
 *  GetFmtValue
 *
 *  reads a width or precision value from the format string
 */

LPCSTR near pascal SP_GetFmtValue(LPCSTR lpch,int FAR *lpw)
{
    register int i=0;

    while (*lpch>='0' && *lpch<='9')
    {
    i *= 10;
    i += (WORD)(*lpch-'0');
    lpch++;
    }

    *lpw=i;

    /* return the address of the first non-digit character */
    return lpch;
}

/*
 *  wvsprintf()
 *
 *  Windows version of vsprintf().  Does not support floating point or
 *  pointer types, and all strings are assumed to be FAR.  Supports only
 *  the left alignment flag.
 *
 *  Takes pointers to an output buffer, where the string is built, a
 *  pointer to an input buffer, and a pointer to a list of parameters.
 *
 *  The cdecl function wsprintf() calls this function.
 */

int API Iwvsprintf(LPSTR lpOut, LPCSTR lpFmt, LPSTR lpParms)
{
    int left;
    char prefix;
    register int width;
    register int prec;
    char fillch;
    int size;
    int sign;
    int radix;
    int upper;
    int cchLimit=WSPRINTF_LIMIT;
    int cch;
    LPSTR lpT;
    union {
    long l;
    unsigned long ul;
    char sz[sizeof(long)];
    } val;

    while (*lpFmt)
    {
    if (*lpFmt=='%')
        {

        /* read the flags.  These can be in any order */
        left=0;
        prefix=0;
        while (*++lpFmt)
        {
        if (*lpFmt=='-')
            left++;
        else if (*lpFmt=='#')
            prefix++;
        else
            break;
        }

        /* find fill character */
        if (*lpFmt=='0')
        {
        fillch='0';
        lpFmt++;
        }
        else
        fillch=' ';

        /* read the width specification */
        lpFmt=SP_GetFmtValue(lpFmt,&cch);
        width=cch;

        /* read the precision */
        if (*lpFmt=='.')
        {
        lpFmt=SP_GetFmtValue(++lpFmt,&cch);
        prec=cch;
        }
        else
        prec=-1;

        /* get the operand size */
        if (*lpFmt=='l')
        {
        size=1;
        lpFmt++;
        }
        else
        {
        size=0;
        if (*lpFmt=='h')
            lpFmt++;
        }

        upper=0;
        sign=0;
        radix=10;
        switch (*lpFmt)
        {
        case 0:
        goto errorout;

        case 'i':
        case 'd':
        sign++;

        case 'u':
        /* turn off prefix if decimal */
        prefix=0;
donumeric:
        /* special cases to act like MSC v5.10 */
        if (left || prec>=0)
            fillch=' ';

        if (size)
            val.l=*((long far *)lpParms)++;
        else
            if (sign)
            val.l=(long)*((short far *)lpParms)++;
            else
            val.ul=(unsigned long)*((unsigned far *)lpParms)++;

        if (sign && val.l<0L)
            val.l=-val.l;
        else
            sign=0;

        lpT=lpOut;

        /* blast the number backwards into the user buffer */
        cch=SP_PutNumber(lpOut,val.l,cchLimit,radix,upper);
        if (!(cchLimit-=cch))
            goto errorout;

        lpOut+=cch;
        width-=cch;
        prec-=cch;
        if (prec>0)
            width-=prec;

        /* fill to the field precision */
        while (prec-->0)
            out('0');

        if (width>0 && !left)
            {
            /* if we're filling with spaces, put sign first */
            if (fillch!='0')
            {
            if (sign)
                {
                sign=0;
                out('-');
                width--;
                }

            if (prefix)
                {
                out(prefix);
                out('0');
                prefix=0;
                }
            }

            if (sign)
            width--;

            /* fill to the field width */
            while (width-->0)
            out(fillch);

            /* still have a sign? */
            if (sign)
            out('-');

            if (prefix)
            {
            out(prefix);
            out('0');
            }

            /* now reverse the string in place */
            SP_Reverse(lpT,lpOut-1);
            }
        else
            {
            /* add the sign character */
            if (sign)
            {
            out('-');
            width--;
            }

            if (prefix)
            {
            out(prefix);
            out('0');
            }

            /* reverse the string in place */
            SP_Reverse(lpT,lpOut-1);

            /* pad to the right of the string in case left aligned */
            while (width-->0)
            out(fillch);
            }
        break;

        case 'X':
        upper++;
        case 'x':
        radix=16;
        if (prefix)
            if (upper)
            prefix='X';
            else
            prefix='x';
        goto donumeric;

        case 'c':
        val.sz[0]=*lpParms;
        val.sz[1]=0;
        lpT=val.sz;
        cch = 1;  // Length is one character.
              // Fix for Bug #1862 --01/10/91-- SANKAR --
        /* stack aligned to larger size */
        lpParms+=sizeof(int);

        goto putstring;

        case 's':
        lpT=*((LPSTR FAR *)lpParms)++;
        cch=lstrlen(lpT);
putstring:
        if (prec>=0 && cch>prec)
            cch=prec;
        width -= cch;
        if (left)
            {
            while (cch--)
            out(*lpT++);
            while (width-->0)
            out(fillch);
            }
        else
            {
            while (width-->0)
            out(fillch);
            while (cch--)
            out(*lpT++);
            }
        break;

        default:
normalch:
#ifdef FE_SB             /* masas : 90-4-26 */
        // If last char is a high ansi char, that may cause infinite loop
        // In case of Taiwan version(PRC and Korea), this char is treated
        // as DBCS lead byte. So we expect trail byte by default. But this
        // is not correct.

        // if( IsDBCSLeadByte(*lpFmt) )  This is original code
        //    out(*lpFmt++);

        if( IsDBCSLeadByte(*lpFmt) ) {
            if( *(lpFmt+1) == '\0' ) {
                out('?');
                lpFmt++;
                continue;
            }
            else
                out(*lpFmt++);
        }
#endif
        out(*lpFmt);
        break;

        }           /* END OF SWITCH(*lpFmt) */
        }           /* END OF IF(%) */
    else
        goto normalch;  /* character not a '%', just do it */

    /* advance to next format string character */
    lpFmt++;
    }       /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut=0;

    return WSPRINTF_LIMIT-cchLimit;
}


/*
 *  wsprintf
 *
 *  Windows version of sprintf
 *
 */

int FAR cdecl wsprintf(LPSTR lpOut, LPCSTR lpFmt, LPSTR lpParms, ...)
{
    return wvsprintf(lpOut,lpFmt,(LPSTR)&lpParms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winstack.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINSTACK.ASM
;   Win16 stack munging routines
;
;   History:
;
;   Created 18-Jun-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--

;****************************************************************************
;*                                                                          *
;*  WINSTACK.ASM -                                                          *
;*                                                                          *
;*      Stack Frame setup routines                                          *
;*                                                                          *
;****************************************************************************

ifdef WOW
NOEXTERNS equ 1
endif
.xlist
include user.inc
.list

;
; Short jump macro
;
jmps    macro   adr
        jmp     short (adr)
	endm

;
; XMOV macro
;
;   Use instead of MOV ax,reg.	Saves a byte.
;
xmov	macro	a,b
	xchg	a,b
	endm

ifdef WOWDEBUG
sBegin DATA

externW <pStackTop>
externW <pStackMin>
externW <pStackBot>

sEnd

ifdef DEBUG

sBegin TEXT
ExternFP    <DivideByZero>
sEnd

endif
endif ;WOWDEBUG

createSeg _TEXT, TEXT, WORD, PUBLIC, CODE

assumes CS,TEXT
assumes SS,DATA

sBegin TEXT

	    org     0			; MUST be at the start of each segment
                                        ;  so that WinFarFrame can jump back
                                        ;  to the proper location.

;*--------------------------------------------------------------------------*
;*									    *
;*  _TEXT_NEARFRAME() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

; Call to _segname_NEARFRAME should be in following format:
;
;	    call    _segname_NEARFRAME
;	    db	    cbLocals	 (count of local words to be allocated)
;	    db	    cbParams	 (count of argument words)

LabelNP     <PUBLIC, _TEXT_NEARFRAME>
	    push    cs			; Save the current segment
            jmps    WinNearFrame        ; Jump to the (only) NEARFRAME routine
	    nop
	    nop
	    nop

nf2:	    push    cs			; Save the CS (it may have changed!)
            jmps    WinNearFrame2       ; Jump to the second half of NEARFRAME
	    nop
	    nop
	    nop


;*--------------------------------------------------------------------------*
;*									    *
;*  _TEXT_FARFRAME() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Call to _segname_FARFRAME should be in following format:
;
;	    call    _segname_FARFRAME
;	    db	    cbLocals	 (count of local words to be allocated)
;	    db	    cbParams	 (count of argument words)

LabelNP <PUBLIC, _TEXT_FARFRAME>
	    push    cs			; Save the current segment
            jmps    WinFarFrame         ; Jump to the (only) FARFRAME routine
	    nop
	    nop
	    nop

ifdef WOWDEBUG
ff2:	    jmp     near ptr WinFarFrame2   ; Jump to the second half of FARFRAME
else
ff2:	    jmp     short near ptr WinFarFrame2
endif


ifdef WOWDEBUG
;*--------------------------------------------------------------------------*
;*									    *
;*  __astkovr1() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Stack Overflow checking routine

;externFP <__astkovr>

;__astkovr1: jmp     __astkovr

endif


;*--------------------------------------------------------------------------*
;*									    *
;*  WinNearFrame() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Sets up and dismantles the frame for a NEAR routine.	This routine
; is FAR JMPed to by _segname_NEARFRAME.  It munges the stack so that a
; NEAR RET returns to a JMP to WinNearFrame2 which dismantles the frame.
;
; CX must be is preserved in the first portion.

LabelFP <PUBLIC, WinNearFrame>
	    pop     es			; Get the caller's Code Segment
	    pop     bx			; Get pointer to sizes of args and locals

	    push    bp			; Update the BP chain
	    mov     bp,sp

	    mov     dx,word ptr es:[bx] ; Move the 2 parms in DX

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
	    sub     ax,sp
;	    jae     __astkovr1		; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __astkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     nf100
	    mov     ss:[pStackMin],ax
nf100:	    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

	    mov     ax,offset nf2	; Push the offset of the JMP to
	    push    ax			;  WinNearFrame2 for function's RET

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    es			; Jump back to the function via RETF
	    push    bx

            xor     bx,bx               ; insure ES is 0
            mov     es,bx

	    retf

LabelFP <PUBLIC,WinNearFrame2>
	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value.
	    pop     es			; Get the caller's CS
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

	    mov     sp,bp		; Free the local variables
	    pop     bp			; Restore BP

	    pop     bx			; Get the caller's return address

	    add     sp,cx		; Remove paramters from stack

	    push    es			; Return to caller via RETF
	    push    bx

            xor     bx,bx               ; insure ES is 0
            mov     es,bx

	    retf


;*--------------------------------------------------------------------------*
;*									    *
;*  WinFarFrame() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Sets up and dismantles the frame for a FAR routine.  This routine
; is FAR JMPed to by _segname_NEARFRAME.  It munges the stack so that a
; NEAR RET returns to a JMP to WinFarFrame2 which dismantles the frame.
;
; CX must be is preserved in the first portion.

LabelFP <PUBLIC, WinFarFrame>
	    mov     ax,ds		; This is patched by the loader to become
	    nop 			;   mov ax,DSVAL

	    pop     es			; Get the caller's CS

	    pop     bx			; Get pointer to sizes of args and locals

	    inc     bp			; Make BP odd to mark far frame
	    push    bp			; Update the BP chain
	    mov     bp,sp

	    push    ds			; Save DS
	    mov     dx,word ptr es:[bx] ; Move the 2 parms into DX

	    mov     ds,ax		; Get the new DS from the loader patch

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
           sub     ax,sp
;	    jae     __astkovr1		; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __astkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     ff100
	    mov     ss:[pStackMin],ax
ff100:	    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

	    mov     ax,offset ff2	; Push the offset of the JMP to
	    push    ax			;  WinFarFrame2 for function's RET

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    es			; Jump back to the function via RETF
	    push    bx

            xor     bx,bx		; Ensure es is 0
            mov     es,bx
	    retf

LabelFP <PUBLIC,WinFarFrame2>
	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value.
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

if 0
	    sub     bp,2		; Point BP at the DS value
	    mov     sp,bp		; Free the local variables
	    pop     ds			; Restore DS
	    pop     bp			; Restore BP
	    dec     bp			; Make BP even again

	    pop     bx			; Get the caller's return address
	    pop     es

	    add     sp,cx		; Remove paramters from stack

	    push    es			; Return to caller via RETF
	    push    bx

            xor     bx,bx		; Ensure es is 0
            mov     es,bx
endif

            mov     ds,[bp-2]           ; Restore DS
            lea     bx,[bp+2]           ; get caller's return address
            add     bx,cx               ; Where we want to put the old CS:IP
            mov     cx,[bp+4]           ; get old CS
            mov     ss:[bx+2],cx        ; move it up
            mov     cx,[bp+2]           ; Get old IP
            mov     ss:[bx],cx          ; move it up
            mov     bp,[bp]             ; restore the old BP
            dec     bp                  ; make it even again
            mov     sp,bx               ; point to the moved CS:IP
            retf                        ; later dude

ifdef WOWDEBUG

            ORG     0cch
            jmp     far ptr DivideByZero
endif

sEnd TEXT

ifndef WOW
;==============================================================================
;   FFFE SEGMENT
;==============================================================================

createSeg _FFFE, FFFE, BYTE, PUBLIC, CODE

assumes CS,_FFFE
assumes SS,DATA

sBegin FFFE

	    ORG     0			; This segment must have a magic header
					;  so that we know to move it up into
					;  segment FFFE:0000 if possible
;	    db	    16 DUP ("AC")
;	    db	    16 DUP (0)		; Tony's sleazy zeros


ifdef WOWDEBUG
;*--------------------------------------------------------------------------*
;*									    *
;*  __ffastkovr1() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Stack Overflow checking routine

;__ffastkovr1: jmp   __astkovr

endif


;*--------------------------------------------------------------------------*
;*									    *
;*  _FFFE_NEARFRAME() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

LabelNP <PUBLIC, _FFFE_NEARFRAME>
	    pop     bx			; Get pointer to sizes of args and locals

	    push    bp			; Update the BP chain
	    mov     bp,sp

	    mov     dx,word ptr cs:[bx] ; Move the 2 parms in DX

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
	    sub     ax,sp
;	    jae     __ffastkovr1	; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __ffastkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     ffnf100
	    mov     ss:[pStackMin],ax
ffnf100:    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

ifndef userhimem
	    mov     ax,offset FFFE_nf2	; Munge the stack so the function
else
            push    ds
            mov     ax, _INTDS
            mov     ds,ax
assumes ds,INTDS
            mov     ax,fffedelta
            pop     ds
assumes ds,DATA
            add     ax, OFFSET FFFE_nf2
endif
	    push    ax			;  "returns" to FFFE_nf2

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    bx			; Jump back to the function
	    ret

LabelFP <PUBLIC,FFFE_nf2>
	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

	    mov     sp,bp		; Free the local variables
	    pop     bp			; Restore BP

	    pop     bx			; Get the caller's return address

	    add     sp,cx		; Remove paramters from stack

	    push    bx			; Return to caller
	    ret


;*--------------------------------------------------------------------------*
;*									    *
;*  _FFFE_FARFRAME() -							    *
;*									    *
;*--------------------------------------------------------------------------*

LabelNP <PUBLIC, _FFFE_FARFRAME>
	    mov     ax,ds		; This is patched by the loader to become
	    nop 			;   mov ax,DSVAL

	    pop     bx			; Get pointer to sizes of args and locals

	    inc     bp			; Make BP odd to mark far frame
	    push    bp			; Update the BP chain
	    mov     bp,sp

	    push    ds			; Save DS
	    mov     ds,ax		; Get the new DS from the loader patch

	    mov     dx,word ptr cs:[bx] ; Move the 2 parms into DX

	    xor     ax,ax
	    mov     al,dl		; Move the # of local words into AL
	    shl     ax,1		; Convert # of words into # of bytes

ifdef WOWDEBUG
	    sub     ax,sp
;	    jae     __ffastkovr1	; Check for stack overflow in
	    neg     ax			;  debugging versions
	    cmp     ss:[pStackTop],ax
;	    ja	    __ffastkovr1
	    cmp     ss:[pStackMin],ax
	    jbe     ffff100
	    mov     ss:[pStackMin],ax
ffff100:    xmov    sp,ax

else
	    sub     sp,ax		; Reserve room for locals on stack
endif

	    push    si			; Save SI and DI
	    push    di

	    xor     ax,ax
	    mov     al,dh		; Move the # of func args into AL
	    shl     ax,1		; Convert words to bytes
	    push    ax			; Save on the stack

ifndef userhimem
	    mov     ax,offset FFFE_ff2	; Munge the stack so the function
else
            push    ds
            mov	    ax, _INTDS
            mov     ds,ax
assumes ds,INTDS
            mov     ax,fffedelta
            pop     ds
assumes ds,DATA
	    add     ax,offset FFFE_ff2	; Munge the stack so the function
endif
	    push    ax			;  "returns" to FFFE_nf2

	    inc     bx			; Move pointer past the parms to the
	    inc     bx			;  actual function code

	    push    bx			; Jump back to the function
	    ret

	    ; NOTE: AX and DX must be preserved now since they contain the C
	    ;	    return value

LabelFP     <PUBLIC,FFFE_ff2>
	    pop     cx			; Get # of func args in CX

	    pop     di			; Restore SI and DI
	    pop     si

	    sub     bp,2		; Point BP at the DS value
	    mov     sp,bp		; Free the local variables
	    pop     ds			; Restore DS
	    pop     bp			; Restore BP
	    dec     bp			; Make BP even again

	    pop     bx			; Get the caller's return address
	    pop     es

	    add     sp,cx		; Remove paramters from stack

	    push    es			; Return to caller via RETF
	    push    bx

            xor     bx,bx		; Ensure es is 0
            mov     es,bx
	    retf

sEnd FFFE


;*--------------------------------------------------------------------------*
;*									    *
;*  CreateFrame Macro - 						    *
;*									    *
;*--------------------------------------------------------------------------*

CreateFrame macro SegName

createSeg _&SegName, SegName, BYTE, PUBLIC, CODE

assumes CS,_&SegName
assumes SS,DATA

sBegin SegName

	    org     0			; MUST be at the start of each segment
                                        ;  so that WinFarFrame can jump back
                                        ;  to the proper location.

LabelNP <PUBLIC, _&SegName&_NEARFRAME>
	    push    cs			; Save the current segment
	    jmp     WinNearFrame	; Jump to the (only) NEARFRAME routine
	    push    cs			; Save the CS (it may have changed!)
	    jmp     WinNearFrame2	; Jump to the second half of NEARFRAME

LabelNP <PUBLIC, _&SegName&_FARFRAME>
	    push    cs			; Save the current segment
	    jmp     WinFarFrame 	; Jump to the (only) FARFRAME routine
	    jmp     WinFarFrame2	; Jump to the second half of FARFRAME

sEnd SegName

	    endm


;==============================================================================
;   SEGMENT FRAMES
;==============================================================================

;CreateFrame INIT
;CreateFrame MDKEY
;CreateFrame MENUCORE
;CreateFrame MENUAPI
;CreateFrame MENUSTART
;CreateFrame RUNAPP
;CreateFrame DLGBEGIN
;CreateFrame DLGCORE
;CreateFrame SCRLBAR
CreateFrame WMGR
CreateFrame WMGR2
;CreateFrame RARE
;CreateFrame LBOX
;CreateFrame LBOXAPI
;CreateFrame LBOXDIR
;CreateFrame LBOXMULTI
;CreateFrame LBOXRARE
;CreateFrame CLPBRD
;CreateFrame COMDEV
;CreateFrame ICON
;CreateFrame SWITCH
;CreateFrame MSGBOX
;CreateFrame MDIWIN
;CreateFrame MDIMENU
;CreateFrame EDECRARE
;CreateFrame EDSLRARE
;CreateFrame EDMLONCE
;CreateFrame EDMLRARE
;CreateFrame WINCRTDST
;CreateFrame WINUTIL
;CreateFrame RESOURCE
;CreateFrame WALLPAPER
;CreateFrame WINSWP
CreateFrame LANG

endif ;WOW

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winq.asm ===
;;;;;;;;;;;;;;;;;;;;;; START OF SOURCE FILE SPECIFICATION ;;;;;;;;;;;;;;;;;;;;
COMMENT $  HEADER

SOURCE FILE NAME:   winq

DESCRIPTIVE NAME:   queue management module

FUNCTION:       This module contains routines for creating and
                deleting queues and reading and writing messages
                to queues.  The circular queue data structure (struct Q
                defined in user.h) consists of a header followed by a
                sequence of messages

ENTRY POINTS:   InitSysQ, CreateQueue, DeleteQueue, WriteMessage, ReadMessage,
		FQueueNotFull, DelQEntry, UnlinkQ
$
;;;;;;;;;;;;;;;;;;;;;; END OF SOURCE FILE SPECIFICATION ;;;;;;;;;;;;;;;;;;;;


;% MOVEDS - NK (no change)

norasterops     =       1
notext          =       1
        .xlist
        include user.inc
        .list

ExternFP	<LocalAlloc, LocalFree>

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

assumes cs,CODE
assumes ds,DATA

;============================================================================

sBegin  DATA

ifndef WOW
ExternW         idSysPeek       ; id in sys queue of message being looked at.
endif

sEnd    DATA

;============================================================================

ExternFP	<GetSystemMsecCount>
ExternFP        <GetCurrentTask>
ExternFP        <SetTaskQueue>
ExternFP        <GlobalAlloc, GlobalFree>
ExternFP        <PostEvent>
ExternFP        <PostMessage>
ExternFP        <GetExeVersion>

sBegin  CODE

; CS variables:
ifndef WOW      ; WOW doesn't use these
ExternNP        <CheckMsgFilter2>
ExternNP        <CheckHwndFilter2>
ExternNP        <SetWakeBit>
ExternNP        <WakeSomeone>
ExternNP        <SetWakeBit2>
ExternNP        <SkipSysMsg>
ExternNP        <PostMove>
ExternNP        <HqCur2ES, HqCur2DS>
ExternFP        <HqCurrent>
else
ExternFP        <GetTaskQueueES>
endif           ; WOW doesn't use these

ifdef WOW       ; These functions stolen from winloop3.asm

;*--------------------------------------------------------------------------*
;*									    *
;*  HqCur2ES() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Get hqCurrent in ES.

LabelNP <PUBLIC, HqCur2ES>
	    call    GetTaskQueueES	; Another wonderful KERNEL routine
	    ret

;*--------------------------------------------------------------------------*
;*									    *
;*  HqCurrent() -							    *
;*									    *
;*--------------------------------------------------------------------------*

; Get handle of current queue and return in AX.

LabelFP <PUBLIC, HqCurrent>
	    call    HqCur2ES		; Code depends on both ES and AX
	    mov     ax,es
	    or	    ax,ax		; Set flags
            retf

endif           ; WOW These functions stolen from winloop3.asm


ifndef WOW      ; No InitSysQueue for WOW
;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
InitSysQueue () - Create and initialize the system queue.

LINKAGE:    FAR PLM

ENTRY:      WORD cQEntries - number of entries in system queue

EXIT:       hSysQueue contains handle for system queue (Shared global object.)

EFFECTS:    all registers modified.

INTERNAL:   CreateQueue2

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Set up register linkage for CreateQueue2 and let it do the work.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	InitSysQueue,<PUBLIC,FAR>,<DS>
cBegin
        mov     ax,_INTDS
        mov     ds,ax
assumes ds,INTDS
        mov     ax,ds:[cQEntries]       ; number of entries
        push    ax
        mov     ax,size INTERNALSYSMSG          ; size of entry
        push    ax
        call    CreateQueue2            ; create system queue
        mov     ds:[hqSysQueue],ax
assumes ds,NOTHING
cEnd
endif           ; No InitSysQueue for WOW

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
CreateQueue (cMsgs) - Create a queue.

Create a queue for the currently executing task and stick its handle
in the task header and the queue list.

LINKAGE:    FAR PLM

ENTRY:      WORD cMsgs(parm1) - count of messages that can be stored in
                                queue

EXIT:       ax - handle to queue (shared global object.)

            Newly created queue is linked to list of queues pointed
            to by hqList.

EXIT - ERROR: ax hqCurrent, hqCurrentShadow contain 0.

EFFECTS:    all registers modified.

INTERNAL:   CreateQueue2

EXTERNAL:   SetTaskQueue

WARNINGS:   Running out of memory when trying to CreateQueue will
            init current queue to 0.

REVISION HISTORY:

IMPLEMENTATION:
    Set up register linkage for CreateQueue2 and let it create the queue.
    Then add to linked list and then SetTaskQueue(NULL, hqCreated).
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	CreateQueue,<PUBLIC, FAR>,<DS>
        ParmW   cMsgs
cBegin
        push    cMsgs
        mov     ax,size INTERNALMSG
        push    ax
        call    CreateQueue2
	or	ax,ax
	jz	errexit 		; CreateQueue2 failed

        EnterCrit

        mov     es,ax
        push    ax
        mov     ax,_INTDS
        mov     ds,ax
        pop     ax
assumes ds,INTDS
        xchg    ds:[hqList],ax          ; Link us in and get old head of list
        mov     es:[qHqNext],ax         ; store ptr to next queue
        push    es                      ; save hq for return

        xor     ax,ax                   ; SetTaskQueue(NULL, es)
        push    ax
        push    es                      ; push queue handle
        call    SetTaskQueue            ; and ram it in there
        pop     ax                      ; return queue handle

        LeaveCrit
assumes ds,DATA
errexit:
cEnd


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ PRIVATE
CreateQueue2 (cMsgs, cbEntry) - Create a queue.

Allocate a shared global object and initialize the header for the Q
Data structure.

LINKAGE:    NEAR PLM

ENTRY:      WORD cMsgs(parm1) - count of messages that can be stored in
                                queue

            WORD cbEntry(parm2) - count of bytes in single message entry.

EXIT:       ax - handle to queue (shared global object.)


EXIT - ERROR: ax contains 0

EFFECTS:    all registers except DI modified.
            wAppVersion gets current exe version.

INTERNAL:

EXTERNAL:   GlobalAlloc

WARNINGS:   cbEntry better not be less than 5.

REVISION HISTORY:

IMPLEMENTATION:
    Allocate a shared global object, initialize header with following
    fields: Current Task, cbEntry, cMsgs,pmsgRead, pmsgWrite,
            pmsgRead = pmsgWrite = rgMsg,
            pmsgMax = queue size
            wVersion = GetExeVersion
	    WakeBits = QS_SMPARAMSFREE | (SYSQ empty ? QS_INPUT : 0).
            lpfnMsgFilter = cs:OldMsgFilter
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	CreateQueue2,<PUBLIC, NEAR>,<DI>
        ParmW   cMsgs
        ParmW   cbEntry

cBegin
        call    GetCurrentTask          ; get current task
        push    ax                      ; and save it

        mov     ax,cMsgs
        mov     cx,cbEntry
        mul     cx
        add     ax,size Q - size INTERNALMSG
        push    ax                      ; save size of queue

        ; Alloc(GPTR, cMsgs * size INTERNALMSG + size Q)
	push    GPTR+GMEM_SHAREALL 
        push    0                       ; hi word == 0
        push    ax
        call    GlobalAlloc
        mov     es,ax                   ; stick hq in es

        pop     cx                      ; pop queue size
        pop     bx                      ; and task handle

        or      ax,ax                   ; error on alloc?
        jz      cqexit                  ; yes, quit
        xchg    bx,ax                   ; get task handle into ax

        cld
        mov     di,qHTask               ; point at hTask
        stosw                           ; store task handle
        errnz   qHTask-2
        mov     ax,cbEntry              ; store size of entry
        stosw
        errnz   qCbEntry-4
        inc     di                      ; cMsgs = 0 (cleared by alloc)
        inc     di
        errnz   qCMsgs-6
        mov     ax,qRgmsg
        stosw                           ; init read/write pointers
        errnz   qPmsgRead-8
        stosw
        errnz   qPmsgWrite-10
        mov     ax,cx                   ; get size of queue (ptr to end)
        stosw                           ; and store it
        errnz   qPmsgMax-12

        push    es                      ; save hq
        call    GetExeVersion           ; returns sys version in dx, app in ax
        pop     es

        mov     es:[qWVersion],ax       ; set up app version number
        mov     es:[qWakeBits],QS_SMPARAMSFREE ; default ON flags.
        mov     es:[qFlags],QF_INIT     ; indicate initialization is in progress

        mov     ax,es                   ; Save hq in ax.
        push    ax
        mov     ax,_INTDS
        mov     es,ax
        pop     ax
assumes es,INTDS
        cmp     es:[hqList],0           ; If we are the first queue and
        jnz     cq100                   ; there is input waiting for us,

        mov     es:[hqCursor],ax        ; Initialize this guy for WakeSomeone.
        cmp     es:[hqSysQueue],0       ; System queue set yet???
        jz      cq100                   ; Nope, don't touch it
	mov	bx,es:[hqSysQueue]      ; set the input flag.
	or	bx,bx
	jz	cq100
        mov     es,bx
        cmp     es:[qCMsgs],0           ; Any messages in the system queue?
        mov     es,ax
        jz      cq100                   ; No messages.
	or	es:[qWakeBits],QS_INPUT ; Yes - tell the guy he has input.

cq100:
;
; Return queue handle in ax.
;
cqexit:
cEnd

;============================================================================


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
DeleteQueue() - Remove current queue from queue list

Unlink Queue from all lists, Delete the Q global object, then wake
someone else.

LINKAGE:    NEAR PLM

ENTRY:

EFFECTS:    current queue is removed from queue list and object is deleted.
            New task wakes up.

            hqSysLock = 0

            all registers modified.

INTERNAL:   UnlinkQ, SetWakeBit, WakeSomeone

EXTERNAL:   GlobalFree,

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Unlink the queue from list of queues then unlink from all send lists.
    Then set the result bit for every queue with sendmessage waiting on
    this guy.  Then free queue global object, and wakesomeone.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc   DeleteQueue,<PUBLIC, NEAR>, <SI>
cBegin
        call    HqCurrent
        mov     si,ax                   ; si = hqCurrent.

        mov     dx,_INTDS
        push    dx                      ; Save for later
        mov     ax,OFFSET hqList
        push    dx
        push    ax
        push    si
        mov     ax,qHqNext
        push    ax
        call    UnlinkQ                 ; UnlinkQ(lphqStart, hqCurrent, cbHqNext)
        pop     es                      ; get INTDS
        jz      dqexit                  ; if bad unlink, exit.
ifndef WOW      ; WOW doesn't have most USER16 structures to worry about.
assumes es,INTDS
        EnterCrit
        xor     bx,bx                   ; zero hqSysLock.
        mov     es:[hqSysLock],bx
        mov     es:[hqMouse],bx         ; zero hqMouse.
        mov     es:[hqKeyboard],bx      ; zero hqKeyboard.
        mov     bx,es:[hqList]          ; Get the first guy in the list for
        mov     es:[hqCursor],bx        ; hqCursor.
        LeaveCrit
;
; Unlink this guy from everyone's hqSendList.
;
        mov     cx,es:[hqList]
assumes es,NOTHING
dq100:
        mov     es,cx
        jcxz    dq200

        push    es:[qHqNext]
        push    cx                      ; Unlink this queue from all send
        mov     ax,qHqSendList          ; lists.
        push    ax
        push    si
        mov     ax,qHqSendNext
        push    ax                      ; UnlinkQ(lphqStart, hqUnlink, cbLink)
        call    UnlinkQ

        pop     cx                      ; Get the next hq.
        jmps    dq100

dq200:
;
; Now set the result bit of everyone waiting on a SendMsg response from
; this guy.
;
        mov     es,si                   ; es = hqCurrent.
        mov     cx,es:[qHqSendList]
dq300:
        mov     es,cx
        jcxz    dq400                   ; Are we at the end of the list?

        push    es:[qHqSendNext]

        xor     bx,bx
        mov     word ptr es:[qResult],bx ; Zero out the result.
        mov     word ptr es:[qResult+2],bx

	mov	ax,QS_SMRESULT		; Tell this guy to wake up and
        call    SetWakeBit2             ; get the result.

        pop     cx
        jmps    dq300

endif           ; WOW doesn't have most USER16 structures to worry about.

dq400:
        xor     ax,ax
        push    ax
        push    ax			; Set NULL queue
        call    SetTaskQueue		; SetTaskQueue(NULL, NULL)

        push    si
        call    GlobalFree              ; throw away the queue

        xor     cx,cx
ifndef WOW      ; No need - user32 takes care of this for WOW
        call    WakeSomeone             ; wake someone up to process events
endif ;WOW
; if anyone jumps here, he better do it with ints enabled!
dqexit:
cEnd


ifndef WOW      ; WOW doesn't ever put anything in the 16-bit Queue

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
WriteMessage (hq, lParam, wParam, message, hwnd, dwExtra) - Write a message
                                                   to hq.

If queue not full, Write message record at pmsgWrite, then advance pmsgWrite.
SetWakeBit(hq) to tell him he has input.

LINKAGE:    NEAR PLM

ENTRY:      WORD    hq          handle to queue that gets message
            DWORD   lParam      lParam of message
            WORD    wParam      wParam of message
            WORD    message     message
            WORD    hwnd        associated window
	    DWORD   dwExtra     dwExtraMsgInfo of the message


EXIT:       zero flag not set
            AX = pmsgWrite

EXIT ERROR: zero flag set

EFFECTS:    Write pointer (pmsgWrite) to hq advanced to next message.
	    QS_POSTMESSAGE set for hq.

            All registers changed

INTERNAL:   FQueueNotFull, SetWakeBit2

EXTERNAL:   none

WARNINGS:   the order of params on stack is assumed so we can do
            a rep movsb

REVISION HISTORY:

IMPLEMENTATION:
    Call FQueueNotFull which sets di = pmsgwrite if queue not full.
    Blt message bytes to queue at di, advance the write pointer,
    then SetWakeBit(hq, QS_POSTMESSAGE).
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cProc	WriteMessage,<PUBLIC, NEAR>, <SI,DI,DS>
ParmW   hq
ParmD   lParam
ParmW   wParam
ParmW   message
ParmW   hwnd
ParmD   dwExtraInfo
cBegin  WriteMessage

        NewEnterCrit    ax		; This trashes ax register

        push    ds                      ; See if queue is full.
        mov     ax,hq
        mov     ds,ax
        mov     es,ax
assumes ds,NOTHING
assumes es,NOTHING
        call    FQueueNotFull           ; Z flag set if FULL.
        jz      pmexit
        push    di                      ; Save Message pointer.

pm30:
        mov     cx,ds:[qCbEntry]        ; Copy message into queue.
        shr     cx,1

        push    ds

        lea     si,dwExtraInfo
        push    ss
        pop     ds
        cld
	errnz	<size INTERNALSYSMSG - 7*2>
	errnz   msgTime-10
	errnz   imMsg-4
        movsw
        movsw
        movsw
        movsw
        movsw                           ; Store away the message.
	movsw
	movsw

	errnz	<size INTERNALSYSMSG - 7*2>
	errnz   msgTime-10
	errnz   imMsg-4
        sub     cx,7
        jcxz    pm40                    ; If have room, store time.

        push    es
	call	GetSystemMsecCount	; Tick count in dx:ax.
        pop     es

        push    ax
        mov     ax,_INTDS
        mov     ds,ax
        pop     ax
assumes ds,INTDS
        stosw
        mov     ax,dx
        stosw

        sub     cx,2
        jcxz    pm40

        mov     ax,word ptr ds:[ptCursor] ; If have room, store pt.
        stosw
        mov     ax,word ptr ds:[ptCursor+2]
        stosw

pm40:
        pop     ds
assumes ds,DATA

        pop     bx                      ; reget ptr to msg
        push    bx
        call    rtestwrap               ; advance pointer

        mov     ds:[qPmsgWrite],bx
        inc     ds:[qCMsgs]             ; advance count

	mov	ax,QS_POSTMESSAGE
        call    SetWakeBit2             ; Tell this guy he has input.
pm75:
        pop     ax                      ; get back message ID
pmexit:
        pop     ds

	NewLeaveCrit   dx, cx  ; This trashes dx and cx registers

cEnd    WriteMessage


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
FQueueNotFull - IsQueueFull?

If queue not full, get pmsgWrite and return TRUE.
otherwise return FALSE.

LINKAGE:    register

ENTRY:      WORD ax - hq

EXIT:       ax - non zero.  zero flag clear
            di - pmsgWrite (pointer to next write record.)

EXIT ERROR: ax - 0; zero flag set

EFFECTS:    no other registers

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Advance write pointer.  Error condition occurs only if
    pmsgWrite == pmsgRead && cMsg != 0.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; FQueueNotFull - zero in ax and Z flag if FULL, else cMsgLeft in ax, NZ
;                 flag set. Returns write pointer in di.
;                 AX has DS on entry.
;
LabelNP <PUBLIC, FQueueNotFull>
        push    ds
assumes ds,NOTHING
        mov     ds,ax
        mov     di,ds:[qPmsgWrite]      ; get write pointer and advance
        cmp     di,ds:[qPmsgRead]       ; if read == write, then we're either
        jnz     qfNotFull
        xor     ax,ax
        cmp     ax,ds:[qCMsgs]          ; cMsgs != 0 if empty
        jnz     qfexit                  ; Jump if Full.
qfNotFull:
        push    es
        mov     ax,_INTDS
        mov     es,ax
assumes es,INTDS
        mov     ax,es:[cQEntries]       ; See how many messages are left.
assumes es,NOTHING
        pop     es
        sub     ax,ds:[qCMsgs]          ; number of messages left
qfexit:
        or      ax,ax
        pop     ds
assumes ds,DATA
        ret


;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
ReadMessage (hq, lpMsg, hwndFilter, msgMinFilter, msgMaxFilter, fRemoveMsg)
            Read a message from hq.

If queue not empty, read message satisfying filter conditions from hq to *lpMsg.

LINKAGE:    FAR PLM

ENTRY:      WORD    hq          handle to queue to read from
            MSG     *lpMsg      far pointer to message buffer
	    	           NOTE: This points to  MSG struct and not INTERNALMSG.
            WORD    hwndFilter  Window filter
            WORD    msgMinFilter    min filter spec for message number
            WORD    msgMaxFilter    max filter spec for message number
            WORD    fRemoveMsg  Remove message if non-zero

EXIT:       zero flag not set
            ax = Non-Zero - we have a message.
            ax = 0 - we don't have a message.

EXIT ERROR: zero flag set

EFFECTS:    All registers trashed
	    QS_POSTMESSAGE wakebit cleared if no msgs left in app queue.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:

REVISION HISTORY:
    SRL - 4/12 Fixed bug where if system queue was locked by someone else,
               it was being unlocked.
    SRL - 4/18 Fixed journalling.
    SRL - 5/4  Changed system queue journalling to call ScanSysQueue.
               (which used to be called FindMsgHq. It now does all the
               message enumeration).

IMPLEMENTATION:
    If not quitting, look through the specified queue starting at pmsgRead
    for message that matches filters.  Blt message to lpmsg, advance the read
    pointer.  If out of queue messages, clear the input bit.
    Message matches hwndFilter if hwndFilter == 0 or hwndFilter == msgHwnd.
    Message matches msgMinFilter, msgMaxFilter if both are zero or
    msgMinFilter <= msg <= msgMaxFilter.

$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ReadMessage(hq, lpMsg, hwndFilter, msgMinFilter, msgMaxFilter, fRemoveMsg)
;
;  NOTE: lpMsg points to MSG structure and not INTERNALMSG.
;
cProc	ReadMessage, <PUBLIC, FAR>, <SI, DI,DS>
ParmW   hq
ParmD   lpMsg
ParmW   hwndFilter
ParmW   msgMinFilter
ParmW   msgMaxFilter
ParmW   fRemoveMsg
cBegin
        push    hq                      ; set ds to queue pointer
        pop     ds
assumes ds,NOTHING

	mov	bx,fRemoveMsg		; pass this to rmquit
        call    rmquit                  ; Must we quit?
        jnz     rmexit                  ; Exit and be sure to leave the
					; QS_POSTMESSAGE bit still set.
;
; Run through the queue and find a message that matches the filters.
;
rm150:
        xor     ax,ax
        cmp     ds:[qCMsgs],ax
        jz      rm500                   ; nothing in queue: exit

        mov     si,ds:[qPmsgRead]       ; Get current read pointer.

rm200:
        call    rmcheckappqueue         ; Check the app queue for a message
        jnz     rm500                   ; fitting the filters.

rm400:
        call    rtestwrap               ; increment pointer in bx and copy to si
        mov     si,bx
        jnz     rm200                   ; at end of queue if Z set
        xor     ax,ax                   ; return FALSE
rm500:
        EnterCrit
        cmp     ds:[qCMsgs],0           ; If no messages left, and out the
        jnz     rm600                   ; input bit.
	cmp	ds:[qCQuit],0		; But only if not quitting
	jnz	rm600
	and	ds:[qWakeBits],NOT QS_POSTMESSAGE
rm600:
        LeaveCrit
rmexit:
assumes es,NOTHING
assumes ds,DATA
cEnd

assumes ds,NOTHING

    ; bx = fRemoveMsg
rmquit:
	mov	ax,ds:[qCQuit]		; Are we in the middle of quiting?
	or	ax,ax			; if cQuit == 0, then continue
        jz      rmq200                  ; return Z.

;	dec	al			; if al == 2, then send quit msg
;	jnz	rmq100
	cmp	ds:[qCMsgs],0		; if queue not empty, don't send quit
        jnz     rmq200
;	inc	ds:[qCQuit]		; set sticky quit & send quit msg
	or	bx,bx
	jz	rmq100			; if PM_NOREMOVE, multiple WM_QUIT's
	mov	ds:[qCQuit],0		; give only one WM_QUIT(raor)
rmq100:
        les     bx,lpMsg
        mov     es:[bx].msgMessage,WM_QUIT ; send a WM_QUIT
        mov     es:[bx].msgHwnd,NULL       ; null window handle
        mov     ax,ds:[qExitCode]       ; stick the exit code in wParam
        mov     es:[bx].msgWParam,ax
        or      al,TRUE
        ret
rmq200:
        xor     ax,ax
        ret
;
; If the hq is an app queue, we can filter immediately.
;
rmcheckappqueue:
        mov     bx,ds:[si].ismMsg.msgHwnd      ; see if hwnd satisfies hwndFilter
        mov     cx,hwndFilter
        call    CheckHwndFilter2
        mov     bx,si                   ; copy read ptr into bx
        jz      rmc200                  ; bad luck - try next one
        mov     ax,ds:[si].ismMsg.msgMessage   ; see if msgMinFilter <= msg <= msgMaxFilter
        mov     cx,msgMinFilter         ; cx = msgMinFilter
        mov     dx,msgMaxFilter         ; dx = msgMaxFilter
        call    CheckMsgFilter2         ; Z if no message.
        jz      rmc200
;
; We've found a message -- read it into lpMsg
;
        les     di,lpMsg                ; get pointer to event block
        mov     cx,ds:[qCbEntry]
	sub	cx, size INTERNALMSG - size MSG
	push    si			; preserve ptr to ExtraMsgInfo
	add     si, size INTERNALMSG - size MSG
        cld
        rep movsb                       ; copy message structure & advance rd ptr
;
; save away time, id, and position of this event in queue header
;
; NOTE: this code doesn't work for the system queue, but that's ok since we
; don't use the queue's time anyway.
;
        sub     si,size MSG - msgTime   ; point at saved time
        mov     di,qTimeLast            ;
        push    ds                      ; copy into ES too
        pop     es
        movsw                           ; copy time and position
        movsw
        errnz   qPtLast-qTimeLast-4
        movsw
        movsw
        mov     ax,bx                   ; store position of msg in q header
        stosw
        errnz   qIdLast-qPtLast-4
	pop	si			; Restore ptr to ExtraMsgInfo
	errnz   qdwExtraInfoLast-qIdLast-2
	errnz   <size INTERNALMSG - size MSG - 4>
	movsw
	movsw
      
        cmp     fRemoveMsg,0            ; are we supposed to yank the message?
        jnz     rmc100                  ; yes: take it out
        mov     ds:[qIdLast],1          ; stick something random in qidLast
        jmps    rmc150                  ; so we don't reply until it's yanked
rmc100:
        call    DelQEntry               ; delete queue entry & update ptrs
rmc150:
        mov     ax,bx                   ; return ID value, TRUE, NZ.
        or      ax,ax
rmc200:
        ret

assumes ds,DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ PRIVATE
DelQEntry - Delete a queue message entry.

Delete message entry from queue.  Adjust pmsgRead, pmsgWrite
and cMsgs.

LINKAGE:    register

ENTRY:      WORD    bx - pointer to entry to delete
            WORD    ds - hq

EXIT:       void

EFFECTS:    pmsgRead and pmsgWrite are adjusted, and part of rgMsg
            is blt'ed to fill hole left by deleted message.

            Trashes es, si, di

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    disable interrupts, change cMsgs, pmsgRead, pmsgWrite, then
    rep movsb from bottom up.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LabelNP <PUBLIC, DelQEntry>

assumes DS,NOTHING

        EnterCrit
        push    ds
        pop     es
        dec     ds:[qCMsgs]             ; decrement count
        mov     ax,ds:[qCbEntry]
        mov     si,ds:[qPmsgRead]
        mov     di,ds:[qPmsgWrite]
        cmp     si,bx                   ; compare sptr to dptr
        ja      de500
;
; rptr < dptr: blt stuff below up
;       move(rptr, rptr+1, dptr-rptr)
;       rptr++;
;
        std                             ; blt backwards
        mov     cx,bx                   ; cb = dptr-rptr
        sub     cx,si
        mov     si,bx                   ; src = dptr
        dec     si                      ; point at first byte to copy
        mov     di,si                   ; dest = src + size(entry)
        add     di,ax
        rep movsb                       ; copy those bytes
        inc     di                      ; readjust DI
        cmp     di,ds:[qPmsgMax]        ; update read pointer
        jb      de200                   ; checking for wraparound
        mov     di,qRgmsg
de200:
        mov     ds:[qPmsgRead],di
        cld
        LeaveCrit
        ret
;
; rptr > dptr: blt stuff above down
;       wptr--;
;       move(dptr + 1, dptr, wptr - dptr)
;
de500:
        cld
        mov     si,bx                   ; src = dptr + size(entry)
        add     si,ax
        mov     cx,di                   ; cb = (wptr - (dptr + size(entry)))
        sub     cx,si
        mov     di,bx                   ; dest = dptr
        rep movsb                       ; copy those bytes
        mov     ds:[qPmsgWrite],di      ; update write pointer
        LeaveCrit
        ret
;
; increment read ptr in bx, testing for wraparound
;
LabelNP <PUBLIC, rtestwrap>
        add     bx,ds:[qCbEntry]        ; advance pointer
        cmp     bx,ds:[qPmsgMax]        ; wrap around if needed
        jb      tw50
        mov     bx,qRgmsg
tw50:
        cmp     bx,ds:[qPmsgWrite]      ; set CC's if end of queue
        ret

assumes ds,DATA

endif           ; WOW doesn't ever put anything in the 16-bit Queue

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
LinkQ (lphqStart, hqLink, ibLink) - Add Q to linked list.

Add new queue entry to END of linked list starting at lphqStart and
linked by ibLink.  ibLink can be qHqNext or qHqSendNext.

LINKAGE:    NEAR PLM

ENTRY:      DWORD lphqStart (parm1) - far pointer to start of queue list
            WORD  hqLink (parm2)    - handle of queue to be linked
            WORD  ibLink (parm3)    - byte index to link to be used in
                                      Q structure.

EXIT:       ax contains hqLink

EFFECTS:    all registers modified.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Walk the linked list starting at lphqStart till hqNext is NULL indicating
    end of list. Add new entry to list there.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LabelNP <PUBLIC, LinkQ>
; ret = 0+2 (saved si)
; ibLink = 2+2
; hqLink = 4+2
; lpHqStart = 6+2
;
        push    si
        mov     si,sp

        EnterCrit

        les     bx,ss:[si+8]            ; Get lpHqStart

lnk100:
        mov     cx,word ptr es:[bx]     ; Check for end of the list.
        jcxz    lnk200

        mov     es,cx                   ; Get Next Link.
        mov     bx,ss:[si+4]            ; BX = ibLink.
        jmps    lnk100

lnk200:
        mov     ax,ss:[si+6]            ; Store hqLink at end of list.
        mov     word ptr es:[bx],ax

        mov     es,ax                   ; AX = hqLink.
        mov     bx,ss:[si+4]
        mov     word ptr es:[bx],cx     ; CX = 0. Zero out pNext.

        LeaveCrit
        pop     si
        ret     8

;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
UnlinkQ (lphqStart, hqLink, ibLink) - Unlink Q from list.

Unlink queue specified by hqLink from linked list starting at lphqStart and
linked by ibLink.  ibLink can be qHqNext or qHqSendNext.

LINKAGE:    NEAR PLM


ENTRY:      DWORD lphqStart (parm1) - far pointer to start of queue list
            WORD  hqLink (parm2)    - handle of queue to be unlinked
            WORD  ibLink (parm3)    - byte index to link to be used in
                                      Q structure.

EXIT:       ax contains handle of unlinked queue, zero flag clear

EXIT ERROR - zero flag is set

EFFECTS:    all registers modified.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Walk the linked list starting at lphqStart till hqLink is found and
    unlink.
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LabelNP <PUBLIC, UnlinkQ>
;
;
; ret = 0+2+ (pushed si)
; cbLink = 2+2
; hq = 4+2
; lpHqStart = 6+2
;
assumes ds,NOTHING
        push    si
        mov     si,sp
        push    di
        push    ds

        EnterCrit

        les     di,ss:[si+8]            ; Get lpHqStart.
        mov     bx,ss:[si+6]            ; Get hqUnlink.

ulq100:
        mov     cx,es:[di]              ; Exit with zero if at end of list.
        jcxz    ulqExit

        cmp     cx,bx                   ; Have we found the guy that points
        jz      ulq200                  ; to hqUnlink?

        mov     es,cx                   ; Point to the next guy and continue.
        mov     di,ss:[si+4]
        jmps    ulq100

ulq200:
        mov     ds,bx                   ; Get the hq that hqUnlink points to.
        mov     bx,ss:[si+4]
        mov     bx,ds:[bx]

        mov     es:[di],bx              ; Store in hqLinkNext of the guy
                                        ; previous to hqUnlink.
ulqExit:
        LeaveCrit

        or      cx,cx
        pop     ds
        pop     di
        pop     si
        ret     8
assumes DS,DATA

ifndef WOW      ; WOW thunks SetMessageQueue
;;;;;;;;;;;;;;;;;;;;;;;;;;  START OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $ LOCAL
BOOL SetMessageQueue(cMsg)

 This function is available to the task that desires a larger message
 queue than the default.  This routine must be called from the
 applications' WinMain routine as soon as possible.  It must not be
 called after any operation that could generate messages (such as
 a CreateWindow).  Any messages currently in the queue will be
 destroyed.  By default, the system creates a default queue with room
 for 8 messages.

LINKAGE:    FAR PLM


ENTRY:	    WORD  cMsg - The size of the new queue in messages.

EXIT:	    ax contains:
	TRUE:	If new queue is sucessfully created.
	FALSE:	If there was an error creating the new queue.  In this case,
		the application has no queue associated with it (since the
		origional queue is deleted first).  The application MUST
		call SetMessageQueue with a smaller size until a TRUE is
		returned (or the application may terminate itself).

EFFECTS:    SI, DI preserved.

INTERNAL:   none

EXTERNAL:   none

WARNINGS:   none

REVISION HISTORY:

IMPLEMENTATION:
    Call DeleteQueue()
    Call CreateQueue(cMsg)
$
;;;;;;;;;;;;;;;;;;;;;;;;;;  END OF SPECIFICATION  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


cProc	SetMessageQueue, <PUBLIC, FAR, EXPORTED>, <SI, DI>
ParmW	cMsg
cBegin
    call    DeleteQueue
    mov     ax,cMsg
    push    ax
    call    CreateQueue
cEnd

endif           ; WOW thunks SetMessageQueue

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\winstr.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINSTR.ASM
;   Win16 string services
;
;   History:
;
;   Created 18-Jun-1991 by Jeff Parsons (jeffpar)
;   Copied from WIN31 and edited (as little as possible) for WOW16
;--


;****************************************************************************
;*									    *
;*  WinStr.ASM -							    *
;*									    *
;*	String related API calls to support different lanuages	 	    *
;*									    *
;****************************************************************************

        TITLE   WinStr.ASM

ifdef WOW
NOEXTERNS equ 1
endif
NOTEXT = 1
.xlist
include user.inc
.list

sBegin	DATA
sEnd

createSeg _TEXT, CODE, WORD, PUBLIC, CODE

sBegin	CODE

assumes CS,CODE
assumes DS,DATA

ExternNP	Loc_IsConvertibleToUpperCase
ExternNP	Loc_Upper
ExternFP	IAnsiUpper
ExternFP	IAnsiLower
ExternFP	Ilstrcmpi
ifdef FE_SB
ExternFP	IsDBCSLeadByte
endif

; Function codes for all the string functions in USER
;
ANSINEXT_ID	equ	1
ANSIPREV_ID	equ	2
ANSIUPPER_ID	equ	3
ANSILOWER_ID	equ	4

;--------------------------------------------------------------------------
;    The order of entries in the following table can not be changed 
;    unless the *_ID codes are also changed in KERNEL also.
;    ((FunctionCode - 1) << 1) is used as the index into this table
;
;	Function Codes:
;
;    NOTE: If you change the entries in this table, kindly update the
;    *_ID statements above and also lString.asm of KERNEL.
;
;--------------------------------------------------------------------------
LabelW	StringFuncTable
	dw	codeOFFSET	IAnsiNext
	dw	codeOFFSET	IAnsiPrev
	dw	codeOFFSET	IAnsiUpper
	dw	codeOFFSET	IAnsiLower

;*----------------------------------------------------------------------*
;*    StringFunc()							*
;*	The string manipulation functions in kernel have been moved 	*
;*	into USER.							*
;*	This is the common entry point in USER for all the string 	*
;*	manipulation functions Kernel wants to call. Kernel jumps to 	*
;*      this function with the function code in CX                      *
;*									*
;*    Input Parameters:							*
;*      [CX] contains the Function code.                                *
;*      [sp] contains the FAR return address of the original caller of  *
;*		the string manipulation functions in Kernel		*
;*----------------------------------------------------------------------*

cProc	StringFunc, <FAR, PUBLIC>
cBegin	nogen
        xchg    bx,cx   ; move function code to BX
	dec	bx
	shl	bx, 1
	jmp	StringFuncTable[bx]
			; Control does not comeback here. It returns directly
			; to the caller
cEnd	nogen

;*----------------------------------------------------------------------*
;*									*
;*  AnsiPrev()								*
;*									*
;*----------------------------------------------------------------------*

ifdef	FE_SB

cProc	IAnsiPrev,<PUBLIC,FAR>
;       parmD   pFirst                  ; [bx+10] es:di
;       parmD   pStr                    ; [bx+6] ds:si

cBegin  nogen
	push	bp
	mov	bp,sp

	push    ds
        push    si
        push    di

        lds     si,[bp+6]
        les     di,[bp+10]
        regptr  dssi,ds,si
        regptr  esdi,es,di
        cld

        cmp     si,di           ; pointer to first char?
        jz      ap5             ; yes, just quit

	dec	si		; backup once
	cmp	si,di		; pointer to first char?
	jz	ap5		; yse, just quit

ap1:
	dec	si		; backup once
	mov	al, [si]	; fetch a character
        cCall   IsDBCSLeadByte,<ax>  ; DBCS lead byte candidate?
	test	ax,ax		;
	jz	ap2		; jump if not.
	cmp	si,di		; backword exhausted?
	jz	ap3		; jump if so
	jmp	ap1		; repeat if not
ap2:
	inc	si		; adjust pointer correctly
ap3:
	mov	bx, [bp+6]	;
	mov	di, bx		; result in DI
	dec	di		;
	sub	bx, si		; how many characters backworded
	test	bx, 1		; see even or odd...
	jnz	ap4		; odd - previous char is SBCS
	dec	di		; make DI for DBCS
ap4:
	mov	si, di		; final result in SI
ap5:
	mov	ax,si
	mov	dx,ds

	pop     di
        pop     si
        pop     ds

	pop	bp
        ret     8
cEnd    nogen

else

cProc	IAnsiPrev,<PUBLIC,FAR>
;       parmD   pFirst                  ; [bx+8] es:di
;       parmD   pStr                    ; [bx+4] ds:si

cBegin  nogen
        mov     bx,sp

	push    ds
        push    si
        push    di

        lds     si,ss:[bx+4]
        les     di,ss:[bx+8]
        regptr  dssi,ds,si
        regptr  esdi,es,di
        cld

        cmp     si,di           ; pointer to first char?
        jz      ap3             ; yes, just quit
;;ifdef FE_SB
;;	xchg	si,di
;;ap1:    mov     dx,si
;;        lodsb                   ; get a char
;;        cCall   IsDBCSLeadByte,<ax>  ; is it kanji?
;;	cmp	al,0
;;        je      ap2             ; no, get next char
;;        inc     si              ; yes, inc past second part
;;ap2:    cmp     si,di           ; have we at or past end?
;;        jb      ap1             ; no, keep going
;;        mov     si,dx           ; return previous pointer
;;else
        dec     si              ; assume easy case...
;;endif ; FE_SB
ap3:    mov     ax,si
        mov     dx,ds

	pop     di
        pop     si
        pop     ds
        ret     8
cEnd    nogen

endif

;*----------------------------------------------------------------------*
;*									*
;*   AnsiNext()								*
;*									*
;*----------------------------------------------------------------------*

cProc	IAnsiNext,<PUBLIC,FAR>
;       parmD   pStr
cBegin  nogen
        mov     bx,sp
        push    di
        les     di,ss:[bx+4]
        mov     al,es:[di]
        or      al,al
        jz      an1
        inc     di
ifdef FE_SB
        cCall	IsDBCSLeadByte,<ax>
        cmp	al,0
        je      an1
        inc     di
endif ; FE_SB
an1:    mov     ax,di
        mov     dx,es
        pop     di
        ret     4
cEnd    nogen

;-----------------------------------------------------------------------
;   MyAnsiUpper()
; 	convert string at es:di to upper case
;-----------------------------------------------------------------------
        public  MyAnsiUpper
MyAnsiUpper:
        cld
        mov     si,di
mau1:   lods    byte ptr es:[si]

ifdef FE_SB
	push	ax
        cCall   IsDBCSLeadByte,<ax>
	cmp	ax,0
	pop	ax
	je	mau2
        inc     si
        inc     di
        inc     di
        jmp     short mau1
endif

mau2:   call    MyUpper
        stosb
        or      al,al
        jnz     mau1
        ret

;-----------------------------------------------------------------------
;    MyAnsiLower()
; 	convert string at es:di to lower case
;-----------------------------------------------------------------------
        public  MyAnsiLower
MyAnsiLower:
        cld
        mov     si,di
mal1:   lods    byte ptr es:[si]

ifdef FE_SB
	push	ax
        cCall   IsDBCSLeadByte,<ax>     ; first byte of double byte?
	cmp	ax,0
	pop	ax
        je      mal2                    ; no just do normal stuff
        inc     si                      ; skip the two bytes
        inc     di
        inc     di
        jmp     short mal1
endif

mal2:   call    MyLower
        stosb
        or      al,al
        jnz     mal1
        ret

;-------------------------------------------------------------------------
;   MyUpper()
; 	convert lower case to upper, must preserve es,di,cx
;-------------------------------------------------------------------------
        public  MyUpper
MyUpper:
	call	Loc_IsConvertibleToUpperCase ; Check if it is a lower case char
				           ; that has an uppercase equivalent
	jnc	myu1		; 
	sub     al,'a'-'A'
myu1:   ret

ifdef KANJI
####################  KANJI  ###############################################
        ; convert upper case to lower, must preserve es,di,cx
        public  MyLower
MyLower:
        cmp     al,'A'
        jb      myl2
        cmp     al,'Z'
        jbe     myl1

	push	ds
	SetKernelDS
	cmp	[fFarEast],1	; this is a far east kbd 1/12/87 linsh
	pop	ds
	UnSetKernelDS
	jge	myl2		; yes do nothing to the 0C0H - 0DEH range

        cmp     al,0C0H         ; this is lower case a with a back slash
        jb      myl2
        cmp     al,0DEH
        ja      myl2
myl1:   add     al,'a'-'A'
myl2:   ret
####################  KANJI  ###############################################
endif

;--------------------------------------------------------------------------
;   MyLower()
; 	convert upper case to lower, must preserve es,di,cx
;--------------------------------------------------------------------------
        public  MyLower
MyLower:
	call	Loc_Upper
	jnc	myl1
	add	al, 'a'-'A'
myl1:	
	ret

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"      
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\lfn.c ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    lfn.c

Abstract:

    Provides entry points for the Long Name Functions from Win3.1
    Network provider design. 

    All functions return WN_NOT_SUPPORTED

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/

#include <windows.h>
#include <locals.h>


WORD API LFNFindFirst(LPSTR p1,
                      WORD p2,
                      LPINT p3,
                      LPINT p4,
                      WORD p5,
                      PFILEFINDBUF2 p6)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    UNREFERENCED(p5) ;
    UNREFERENCED(p6) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNFindNext(HANDLE p1,
                     LPINT p2,
                     WORD p3,
                     PFILEFINDBUF2 p4)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNFindClose(HANDLE p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNGetAttributes(LPSTR p1,
                          LPINT p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNSetAttributes(LPSTR p1,
                          WORD p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNCopy(LPSTR p1,
                 LPSTR p2,
                 PQUERYPROC p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNMove(LPSTR p1,
                 LPSTR p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNDelete(LPSTR p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNMKDir(LPSTR p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNRMDir(LPSTR p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNGetVolumeLabel(WORD p1,
                           LPSTR p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNSetVolumeLabel(WORD p1,
                           LPSTR p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNParse(LPSTR p1,
                  LPSTR p2,
                  LPSTR p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API LFNVolumeType(WORD p1,
                       LPINT p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\bseerr.h ===
/****************************** Module Header ******************************\
*
* Module Name: BSEERR.H
*       
*      Copy of the Lanman BSEERR.H used for their base error codes.
*      Not used by anyone else.
*
\***************************************************************************/

#ifndef BSEERR_INCLUDED
#define BSEERR_INCLUDED

#define NO_ERROR			0
#define ERROR_INVALID_FUNCTION		1
#define ERROR_FILE_NOT_FOUND		2
#define ERROR_PATH_NOT_FOUND		3
#define ERROR_TOO_MANY_OPEN_FILES	4
#define ERROR_ACCESS_DENIED		5
#define ERROR_INVALID_HANDLE		6
#define ERROR_ARENA_TRASHED		7
#define ERROR_NOT_ENOUGH_MEMORY 	8
#define ERROR_INVALID_BLOCK		9
#define ERROR_BAD_ENVIRONMENT		10
#define ERROR_BAD_FORMAT		11
#define ERROR_INVALID_ACCESS		12
#define ERROR_INVALID_DATA		13
/* 14 is reserved			 */
#define ERROR_INVALID_DRIVE		15
#define ERROR_CURRENT_DIRECTORY 	16
#define ERROR_NOT_SAME_DEVICE		17
#define ERROR_NO_MORE_FILES		18
#define ERROR_WRITE_PROTECT		19
#define ERROR_BAD_UNIT			20
#define ERROR_NOT_READY 		21
#define ERROR_BAD_COMMAND		22
#define ERROR_CRC			23
#define ERROR_BAD_LENGTH		24
#define ERROR_SEEK			25
#define ERROR_NOT_DOS_DISK		26
#define ERROR_SECTOR_NOT_FOUND		27
#define ERROR_OUT_OF_PAPER		28
#define ERROR_WRITE_FAULT		29
#define ERROR_READ_FAULT		30
#define ERROR_GEN_FAILURE		31
#define ERROR_SHARING_VIOLATION 	32
#define ERROR_LOCK_VIOLATION		33
#define ERROR_WRONG_DISK		34
#define ERROR_FCB_UNAVAILABLE		35
#define ERROR_SHARING_BUFFER_EXCEEDED	36
#define ERROR_NOT_SUPPORTED		50
#define ERROR_REM_NOT_LIST		51 /* Remote computer not listening   */
#define ERROR_DUP_NAME			52 /* Duplicate name on network       */
#define ERROR_BAD_NETPATH		53 /* Network path not found	      */
#define ERROR_NETWORK_BUSY		54 /* Network busy		      */
#define ERROR_DEV_NOT_EXIST		55 /* Network device no longer exists */
#define ERROR_TOO_MANY_CMDS		56 /* Net BIOS command limit exceeded */
#define ERROR_ADAP_HDW_ERR		57 /* Network adapter hardware error  */
#define ERROR_BAD_NET_RESP		58 /* Incorrect response from network */
#define ERROR_UNEXP_NET_ERR		59 /* Unexpected network error	      */
#define ERROR_BAD_REM_ADAP		60 /* Incompatible remote adapter     */
#define ERROR_PRINTQ_FULL		61 /* Print queue full		      */
#define ERROR_NO_SPOOL_SPACE		62 /* Not enough space for print file */
#define ERROR_PRINT_CANCELLED		63 /* Print file was cancelled	      */
#define ERROR_NETNAME_DELETED		64 /* Network name was deleted	      */
#define ERROR_NETWORK_ACCESS_DENIED	65 /* Access denied		      */
#define ERROR_BAD_DEV_TYPE		66 /* Network device type incorrect   */
#define ERROR_BAD_NET_NAME		67 /* Network name not found	      */
#define ERROR_TOO_MANY_NAMES		68 /* Network name limit exceeded     */
#define ERROR_TOO_MANY_SESS		69 /* Net BIOS session limit exceeded */
#define ERROR_SHARING_PAUSED		70 /* Sharing temporarily paused      */
#define ERROR_REQ_NOT_ACCEP		71 /* Network request not accepted    */
#define ERROR_REDIR_PAUSED		72 /* Print|disk redirection is paused*/
#define ERROR_FILE_EXISTS		80
#define ERROR_DUP_FCB			81
#define ERROR_CANNOT_MAKE		82
#define ERROR_FAIL_I24			83
#define ERROR_OUT_OF_STRUCTURES 	84
#define ERROR_ALREADY_ASSIGNED		85
#define ERROR_INVALID_PASSWORD		86
#define ERROR_INVALID_PARAMETER 	87
#define ERROR_NET_WRITE_FAULT		88
#define ERROR_NO_PROC_SLOTS		89 /* no process slots available      */
#define ERROR_NOT_FROZEN		90
#define ERR_TSTOVFL			91 /* timer service table overflow    */
#define ERR_TSTDUP			92 /* timer service table duplicate   */
#define ERROR_NO_ITEMS			93 /* no items to operate upon	      */
#define ERROR_INTERRUPT 		95 /* interrupted system call	      */
#define ERROR_DEVICE_IN_USE		99 /* Device in use by another thread */
#define ERROR_TOO_MANY_SEMAPHORES	100
#define ERROR_EXCL_SEM_ALREADY_OWNED	101
#define ERROR_SEM_IS_SET		102
#define ERROR_TOO_MANY_SEM_REQUESTS	103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED		105 /* waitsem found owner died       */
#define ERROR_SEM_USER_LIMIT		106 /* too many procs have this sem   */
#define ERROR_DISK_CHANGE		107
#define ERROR_DRIVE_LOCKED		108 /* drive locked by another process*/
#define ERROR_BROKEN_PIPE		109 /* write on pipe with no reader   */
#define ERROR_OPEN_FAILED		110 /* open/created failed due to     */
                                            /* explicit fail command          */
#define ERROR_BUFFER_OVERFLOW		111 /* buffer passed to system call   */
                                            /* is too small to hold return    */
                                            /* data.                          */
#define ERROR_DISK_FULL 		112 /* not enough space on the disk   */
                                            /* (DOSNEWSIZE/w_NewSize)         */
#define ERROR_NO_MORE_SEARCH_HANDLES	113 /* can't allocate another search  */
                                            /* structure and handle.          */
                                            /* (DOSFINDFIRST/w_FindFirst)     */
#define ERROR_INVALID_TARGET_HANDLE	114 /* Target handle in DOSDUPHANDLE  */
                                            /* is invalid                     */
#define ERROR_PROTECTION_VIOLATION	115 /* Bad user virtual address       */
#define ERROR_VIOKBD_REQUEST		116
#define ERROR_INVALID_CATEGORY		117 /* Category for DEVIOCTL in not   */
                                            /* defined                        */
#define ERROR_INVALID_VERIFY_SWITCH	118 /* invalid value passed for       */
                                            /* verify flag                    */
#define ERROR_BAD_DRIVER_LEVEL		119 /* DosDevIOCTL looks for a level  */
                                            /* four driver. If the driver     */
                                            /* is not level four we return    */
                                            /* this code                      */
#define ERROR_CALL_NOT_IMPLEMENTED	120 /* returned from stub api calls.  */
                                            /* This call will disappear when  */
                                            /* all the api's are implemented. */
#define ERROR_SEM_TIMEOUT		121 /* Time out happened from the     */
                                            /* semaphore api functions.       */
#define ERROR_INSUFFICIENT_BUFFER	122 /* Some calls require the	      */
                                       /* application to pass in a buffer     */
                                       /* filled with data.  This error is    */
                                       /* returned if the data buffer is too  */
                                       /* small.  For example: DosSetFileInfo */
                                       /* requires 4 bytes of data.  If a     */
                                       /* two byte buffer is passed in then   */
                                       /* this error is returned.             */
                                       /* error_buffer_overflow is used when  */
                                       /* the output buffer in not big enough.*/
#define ERROR_INVALID_NAME		123 /* illegal character or malformed */
                                            /* file system name               */
#define ERROR_INVALID_LEVEL		124 /* unimplemented level for info   */
                                            /* retrieval or setting           */
#define ERROR_NO_VOLUME_LABEL		125 /* no volume label found with     */
                                            /* DosQFSInfo command             */
#define ERROR_MOD_NOT_FOUND		126 /* w_getprocaddr,w_getmodhandle   */
#define ERROR_PROC_NOT_FOUND		127 /* w_getprocaddr		      */
#define ERROR_WAIT_NO_CHILDREN		128 /* CWait finds to children	      */
#define ERROR_CHILD_NOT_COMPLETE	129 /* CWait children not dead yet    */
#define ERROR_DIRECT_ACCESS_HANDLE	130 /* handle operation is invalid    */
                                            /* for direct disk access         */
                                            /* handles                        */
#define ERROR_NEGATIVE_SEEK		131 /* application tried to seek      */
                                            /* with negitive offset           */
#define ERROR_SEEK_ON_DEVICE		132 /* application tried to seek      */
                                            /* on device or pipe              */
#define ERROR_IS_JOIN_TARGET		133
#define ERROR_IS_JOINED 		134
#define ERROR_IS_SUBSTED		135
#define ERROR_NOT_JOINED		136
#define ERROR_NOT_SUBSTED		137
#define ERROR_JOIN_TO_JOIN		138
#define ERROR_SUBST_TO_SUBST		139
#define ERROR_JOIN_TO_SUBST		140
#define ERROR_SUBST_TO_JOIN		141
#define ERROR_BUSY_DRIVE		142
#define ERROR_SAME_DRIVE		143
#define ERROR_DIR_NOT_ROOT		144
#define ERROR_DIR_NOT_EMPTY		145
#define ERROR_IS_SUBST_PATH		146
#define ERROR_IS_JOIN_PATH		147
#define ERROR_PATH_BUSY 		148
#define ERROR_IS_SUBST_TARGET		149
#define ERROR_SYSTEM_TRACE		150 /* system trace error	      */
#define ERROR_INVALID_EVENT_COUNT	151 /* DosMuxSemWait errors	      */
#define ERROR_TOO_MANY_MUXWAITERS	152
#define ERROR_INVALID_LIST_FORMAT	153
#define ERROR_LABEL_TOO_LONG		154
#define ERROR_TOO_MANY_TCBS		155
#define ERROR_SIGNAL_REFUSED		156
#define ERROR_DISCARDED 		157
#define ERROR_NOT_LOCKED		158
#define ERROR_BAD_THREADID_ADDR 	159
#define ERROR_BAD_ARGUMENTS		160
#define ERROR_BAD_PATHNAME		161
#define ERROR_SIGNAL_PENDING		162
#define ERROR_UNCERTAIN_MEDIA		163
#define ERROR_MAX_THRDS_REACHED 	164
#define ERROR_MONITORS_NOT_SUPPORTED	165
#define ERROR_UNC_DRIVER_NOT_INSTALLED	166

/*	The following error codes refer to demand loading segments     */
#define ERROR_LOCK_FAILED		167
#define ERROR_SWAPIO_FAILED		168
#define ERROR_SWAPIN_FAILED		169
#define ERROR_BUSY			170

#define ERROR_INVALID_SEGMENT_NUMBER	180
#define ERROR_INVALID_CALLGATE		181
#define ERROR_INVALID_ORDINAL		182
#define ERROR_ALREADY_EXISTS		183
#define ERROR_NO_CHILD_PROCESS		184
#define ERROR_CHILD_ALIVE_NOWAIT	185
#define ERROR_INVALID_FLAG_NUMBER	186
#define ERROR_SEM_NOT_FOUND		187

/* following error codes make loader error messages distinct  */
#define ERROR_INVALID_STARTING_CODESEG	188
#define ERROR_INVALID_STACKSEG		189
#define ERROR_INVALID_MODULETYPE	190
#define ERROR_INVALID_EXE_SIGNATURE	191
#define ERROR_EXE_MARKED_INVALID	192
#define ERROR_BAD_EXE_FORMAT		193
#define ERROR_ITERATED_DATA_EXCEEDS_64K 194
#define ERROR_INVALID_MINALLOCSIZE	195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED		197
#define ERROR_INVALID_SEGDPL		198
#define ERROR_AUTODATASEG_EXCEEDS_64k	199
#define ERROR_RING2SEG_MUST_BE_MOVABLE	200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM	201
#define ERROR_INFLOOP_IN_RELOC_CHAIN	202
#define ERROR_ENVVAR_NOT_FOUND		203
#define ERROR_NOT_CURRENT_CTRY		204
#define ERROR_NO_SIGNAL_SENT		205
#define ERROR_FILENAME_EXCED_RANGE	206 /* if filename > 8.3 */
#define ERROR_RING2_STACK_IN_USE	207 /* for FAPI 	 */
#define ERROR_META_EXPANSION_TOO_LONG	208 /* if "*a" > 8.3	 */
#define ERROR_INVALID_SIGNAL_NUMBER	209
#define ERROR_THREAD_1_INACTIVE 	210
#define ERROR_INFO_NOT_AVAIL		211
#define ERROR_LOCKED			212
#define ERROR_BAD_DYNALINK		213
#define ERROR_TOO_MANY_MODULES		214
#define ERROR_NESTING_NOT_ALLOWED	215
#define ERROR_CANNOT_SHRINK		216 /* attempt to shrink ring 2 stack */
#define ERROR_ZOMBIE_PROCESS		217
#define ERROR_STACK_IN_HIGH_MEMORY	218
#define ERROR_INVALID_EXITROUTINE_RING	219
#define ERROR_GETBUF_FAILED		220
#define ERROR_FLUSHBUF_FAILED		221
#define ERROR_TRANSFER_TOO_LONG 	222
#define ERROR_NO_CHILDREN		228
#define ERROR_INVALID_SCREEN_GROUP	229
/*
 * Error codes 230 - 249 are reserved
 */
#define ERROR_BAD_PIPE			230 /* Non-existant pipe or bad operation */
#define ERROR_PIPE_BUSY 		231 /* Pipe is busy		      */
#define ERROR_NO_DATA			232 /* No data on non-blocking read   */
#define ERROR_PIPE_NOT_CONNECTED	233 /* Pipe was disconnected by server*/
#define ERROR_MORE_DATA 		234 /* More data is available	      */

#define ERROR_VC_DISCONNECTED		240
#define ERROR_CIRCULARITY_REQUESTED	250 /* When renaming a dir which      */
                                            /* would cause a circularity      */
#define ERROR_DIRECTORY_IN_CDS		251 /* When renaming a dir	      */
                                            /* which is "in use"              */
#define ERROR_INVALID_FSD_NAME		252 /* when trying to access	      */
                                            /* nonexistent FSD                */
#define ERROR_INVALID_PATH		253 /* bad pseudo device	      */
#define ERROR_INVALID_EA_NAME		254 /* Illegal chars in name	      */
#define ERROR_EA_LIST_INCONSISTENT	255 /* Size or some field bad	      */
#define ERROR_EA_LIST_TOO_LONG		256 /* FEAlist > 64K-1 bytes	      */
#define ERROR_NO_META_MATCH		257 /* string doesn't match expression*/
#define ERROR_FINDNOTIFY_TIMEOUT	258 /* FindNotify request timeout     */
#define ERROR_NO_MORE_ITEMS		259 /* QFSAttach ordinal query	      */
#define ERROR_SEARCH_STRUC_REUSED	260 /* 3xbox findfirst/next
                                               search structure reused        */
#define ERROR_CHAR_NOT_FOUND		261 /* can not find character	      */
#define ERROR_TOO_MUCH_STACK		262 /* Stack request exceeds sys limit*/
#define ERROR_INVALID_ATTR		263 /* invalid FS_ATTRIBUTE	      */
#define ERROR_INVALID_STARTING_RING	264
#define ERROR_INVALID_DLL_INIT_RING	265
#define ERROR_CANNOT_COPY		266 /* doscopy */
#define ERROR_DIRECTORY 		267 /* doscopy */
#define ERROR_OPLOCKED_FILE		268
#define ERROR_OPLOCK_THREAD_EXISTS	269

/* error codes for DosFindNotify */
#define ERROR_VOLUME_CHANGED		270
#define ERROR_FINDNOTIFY_HANDLE_IN_USE	271
#define ERROR_FINDNOTIFY_HANDLE_CLOSED	272
#define ERROR_NOTIFY_OBJECT_REMOVED	273

/* Error to indicate that ShutDown already done */
#define ERROR_ALREADY_SHUTDOWN		274

/* error code for DOSFINDFIRST2/NEXT */
#define ERROR_EAS_DIDNT_FIT		275

/* error codes for EA file format change */
#define ERROR_EA_FILE_CORRUPT		276
#define ERROR_EA_TABLE_FULL		277
#define ERROR_INVALID_EA_HANDLE 	278
#define ERROR_NO_CLUSTER		279
#define ERROR_CREATE_EA_FILE		280
#define ERROR_CANNOT_OPEN_EA_FILE	281

#define ERROR_INVALID_PROCID		303
#define ERROR_INVALID_PDELTA		304
#define ERROR_NOT_DESCENDANT		305
#define ERROR_NOT_SESSION_MANAGER	306
#define ERROR_INVALID_PCLASS		307
#define ERROR_INVALID_SCOPE		308
#define ERROR_INVALID_THREADID		309
#define ERROR_DOSSUB_SHRINK		310
#define ERROR_DOSSUB_NOMEM		311
#define ERROR_DOSSUB_OVERLAP		312
#define ERROR_DOSSUB_BADSIZE		313
#define ERROR_DOSSUB_BADFLAG		314
#define ERROR_DOSSUB_BADSELECTOR	315
#define ERROR_MR_MSG_TOO_LONG		316
#define ERROR_MR_MID_NOT_FOUND		317
#define ERROR_MR_UN_ACC_MSGF		318
#define ERROR_MR_INV_MSGF_FORMAT	319
#define ERROR_MR_INV_IVCOUNT		320
#define ERROR_MR_UN_PERFORM		321
#define ERROR_TS_WAKEUP 		322
#define ERROR_TS_SEMHANDLE		323
#define ERROR_TS_NOTIMER		324
#define ERROR_TS_HANDLE 		326
#define ERROR_TS_DATETIME		327
#define ERROR_SYS_INTERNAL		328
#define ERROR_QUE_CURRENT_NAME		329
#define ERROR_QUE_PROC_NOT_OWNED	330
#define ERROR_QUE_PROC_OWNED		331
#define ERROR_QUE_DUPLICATE		332
#define ERROR_QUE_ELEMENT_NOT_EXIST	333
#define ERROR_QUE_NO_MEMORY		334
#define ERROR_QUE_INVALID_NAME		335
#define ERROR_QUE_INVALID_PRIORITY	336
#define ERROR_QUE_INVALID_HANDLE	337
#define ERROR_QUE_LINK_NOT_FOUND	338
#define ERROR_QUE_MEMORY_ERROR		339
#define ERROR_QUE_PREV_AT_END		340
#define ERROR_QUE_PROC_NO_ACCESS	341
#define ERROR_QUE_EMPTY 		342
#define ERROR_QUE_NAME_NOT_EXIST	343
#define ERROR_QUE_NOT_INITIALIZED	344
#define ERROR_QUE_UNABLE_TO_ACCESS	345
#define ERROR_QUE_UNABLE_TO_ADD 	346
#define ERROR_QUE_UNABLE_TO_INIT	347
#define ERROR_VIO_INVALID_MASK		349
#define ERROR_VIO_PTR			350
#define ERROR_VIO_APTR			351
#define ERROR_VIO_RPTR			352
#define ERROR_VIO_CPTR			353
#define ERROR_VIO_LPTR			354
#define ERROR_VIO_MODE			355
#define ERROR_VIO_WIDTH 		356
#define ERROR_VIO_ATTR			357
#define ERROR_VIO_ROW			358
#define ERROR_VIO_COL			359
#define ERROR_VIO_TOPROW		360
#define ERROR_VIO_BOTROW		361
#define ERROR_VIO_RIGHTCOL		362
#define ERROR_VIO_LEFTCOL		363
#define ERROR_SCS_CALL			364
#define ERROR_SCS_VALUE 		365
#define ERROR_VIO_WAIT_FLAG		366
#define ERROR_VIO_UNLOCK		367
#define ERROR_SGS_NOT_SESSION_MGR	368
#define ERROR_SMG_INVALID_SGID		369
#define ERROR_SMG_INVALID_SESSION_ID	369
#define ERROR_SMG_NOSG			370
#define ERROR_SMG_NO_SESSIONS		370
#define ERROR_SMG_GRP_NOT_FOUND 	371
#define ERROR_SMG_SESSION_NOT_FOUND	371
#define ERROR_SMG_SET_TITLE		372
#define ERROR_KBD_PARAMETER		373
#define ERROR_KBD_NO_DEVICE		374
#define ERROR_KBD_INVALID_IOWAIT	375
#define ERROR_KBD_INVALID_LENGTH	376
#define ERROR_KBD_INVALID_ECHO_MASK	377
#define ERROR_KBD_INVALID_INPUT_MASK	378
#define ERROR_MON_INVALID_PARMS 	379
#define ERROR_MON_INVALID_DEVNAME	380
#define ERROR_MON_INVALID_HANDLE	381
#define ERROR_MON_BUFFER_TOO_SMALL	382
#define ERROR_MON_BUFFER_EMPTY		383
#define ERROR_MON_DATA_TOO_LARGE	384
#define ERROR_MOUSE_NO_DEVICE		385
#define ERROR_MOUSE_INV_HANDLE		386
#define ERROR_MOUSE_INV_PARMS		387
#define ERROR_MOUSE_CANT_RESET		388
#define ERROR_MOUSE_DISPLAY_PARMS	389
#define ERROR_MOUSE_INV_MODULE		390
#define ERROR_MOUSE_INV_ENTRY_PT	391
#define ERROR_MOUSE_INV_MASK		392
#define NO_ERROR_MOUSE_NO_DATA		393
#define NO_ERROR_MOUSE_PTR_DRAWN	394
#define ERROR_INVALID_FREQUENCY 	395
#define ERROR_NLS_NO_COUNTRY_FILE	396
#define ERROR_NLS_OPEN_FAILED		397
#define ERROR_NLS_NO_CTRY_CODE		398
#define ERROR_NO_COUNTRY_OR_CODEPAGE	398
#define ERROR_NLS_TABLE_TRUNCATED	399
#define ERROR_NLS_BAD_TYPE		400
#define ERROR_NLS_TYPE_NOT_FOUND	401
#define ERROR_VIO_SMG_ONLY		402
#define ERROR_VIO_INVALID_ASCIIZ	403
#define ERROR_VIO_DEREGISTER		404
#define ERROR_VIO_NO_POPUP		405
#define ERROR_VIO_EXISTING_POPUP	406
#define ERROR_KBD_SMG_ONLY		407
#define ERROR_KBD_INVALID_ASCIIZ	408
#define ERROR_KBD_INVALID_MASK		409
#define ERROR_KBD_REGISTER		410
#define ERROR_KBD_DEREGISTER		411
#define ERROR_MOUSE_SMG_ONLY		412
#define ERROR_MOUSE_INVALID_ASCIIZ	413
#define ERROR_MOUSE_INVALID_MASK	414
#define ERROR_MOUSE_REGISTER		415
#define ERROR_MOUSE_DEREGISTER		416
#define ERROR_SMG_BAD_ACTION		417
#define ERROR_SMG_INVALID_CALL		418
#define ERROR_SCS_SG_NOTFOUND		419
#define ERROR_SCS_NOT_SHELL		420
#define ERROR_VIO_INVALID_PARMS 	421
#define ERROR_VIO_FUNCTION_OWNED	422
#define ERROR_VIO_RETURN		423
#define ERROR_SCS_INVALID_FUNCTION	424
#define ERROR_SCS_NOT_SESSION_MGR	425
#define ERROR_VIO_REGISTER		426
#define ERROR_VIO_NO_MODE_THREAD	427
#define ERROR_VIO_NO_SAVE_RESTORE_THD	428
#define ERROR_VIO_IN_BG 		429
#define ERROR_VIO_ILLEGAL_DURING_POPUP	430
#define ERROR_SMG_NOT_BASESHELL 	431
#define ERROR_SMG_BAD_STATUSREQ 	432
#define ERROR_QUE_INVALID_WAIT		433
#define ERROR_VIO_LOCK			434
#define ERROR_MOUSE_INVALID_IOWAIT	435
#define ERROR_VIO_INVALID_HANDLE	436
#define ERROR_VIO_ILLEGAL_DURING_LOCK	437
#define ERROR_VIO_INVALID_LENGTH	438
#define ERROR_KBD_INVALID_HANDLE	439
#define ERROR_KBD_NO_MORE_HANDLE	440
#define ERROR_KBD_CANNOT_CREATE_KCB	441
#define ERROR_KBD_CODEPAGE_LOAD_INCOMPL 442
#define ERROR_KBD_INVALID_CODEPAGE_ID	443
#define ERROR_KBD_NO_CODEPAGE_SUPPORT	444
#define ERROR_KBD_FOCUS_REQUIRED	445
#define ERROR_KBD_FOCUS_ALREADY_ACTIVE	446
#define ERROR_KBD_KEYBOARD_BUSY 	447
#define ERROR_KBD_INVALID_CODEPAGE	448
#define ERROR_KBD_UNABLE_TO_FOCUS	449
#define ERROR_SMG_SESSION_NON_SELECT	450
#define ERROR_SMG_SESSION_NOT_FOREGRND	451
#define ERROR_SMG_SESSION_NOT_PARENT	452
#define ERROR_SMG_INVALID_START_MODE	453
#define ERROR_SMG_INVALID_RELATED_OPT	454
#define ERROR_SMG_INVALID_BOND_OPTION	455
#define ERROR_SMG_INVALID_SELECT_OPT	456
#define ERROR_SMG_START_IN_BACKGROUND	457
#define ERROR_SMG_INVALID_STOP_OPTION	458
#define ERROR_SMG_BAD_RESERVE		459
#define ERROR_SMG_PROCESS_NOT_PARENT	460
#define ERROR_SMG_INVALID_DATA_LENGTH	461
#define ERROR_SMG_NOT_BOUND		462
#define ERROR_SMG_RETRY_SUB_ALLOC	463
#define ERROR_KBD_DETACHED		464
#define ERROR_VIO_DETACHED		465
#define ERROR_MOU_DETACHED		466
#define ERROR_VIO_FONT			467
#define ERROR_VIO_USER_FONT		468
#define ERROR_VIO_BAD_CP		469
#define ERROR_VIO_NO_CP 		470
#define ERROR_VIO_NA_CP 		471
#define ERROR_INVALID_CODE_PAGE 	472
#define ERROR_CPLIST_TOO_SMALL		473
#define ERROR_CP_NOT_MOVED		474
#define ERROR_MODE_SWITCH_INIT		475
#define ERROR_CODE_PAGE_NOT_FOUND	476
#define ERROR_UNEXPECTED_SLOT_RETURNED	477
#define ERROR_SMG_INVALID_TRACE_OPTION	478
#define ERROR_VIO_INTERNAL_RESOURCE	479
#define ERROR_VIO_SHELL_INIT		480
#define ERROR_SMG_NO_HARD_ERRORS	481
#define ERROR_CP_SWITCH_INCOMPLETE	482
#define ERROR_VIO_TRANSPARENT_POPUP	483
#define ERROR_CRITSEC_OVERFLOW		484
#define ERROR_CRITSEC_UNDERFLOW 	485
#define ERROR_VIO_BAD_RESERVE		486
#define ERROR_INVALID_ADDRESS		487
#define ERROR_ZERO_SELECTORS_REQUESTED	488
#define ERROR_NOT_ENOUGH_SELECTORS_AVA	489
#define ERROR_INVALID_SELECTOR		490
#define ERROR_SMG_INVALID_PROGRAM_TYPE	491
#define ERROR_SMG_INVALID_PGM_CONTROL	492
#define ERROR_SMG_INVALID_INHERIT_OPT	493
#define ERROR_VIO_EXTENDED_SG		494
#define ERROR_VIO_NOT_PRES_MGR_SG	495
#define ERROR_VIO_SHIELD_OWNED		496
#define ERROR_VIO_NO_MORE_HANDLES	497
#define ERROR_VIO_SEE_ERROR_LOG 	498
#define ERROR_VIO_ASSOCIATED_DC 	499
#define ERROR_KBD_NO_CONSOLE		500
#define ERROR_MOUSE_NO_CONSOLE		501
#define ERROR_MOUSE_INVALID_HANDLE	502
#define ERROR_SMG_INVALID_DEBUG_PARMS	503
#define ERROR_KBD_EXTENDED_SG		504
#define ERROR_MOU_EXTENDED_SG		505
#define ERROR_SMG_INVALID_ICON_FILE	506


#define ERROR_USER_DEFINED_BASE 	0xFF00

#define ERROR_I24_WRITE_PROTECT 	0
#define ERROR_I24_BAD_UNIT		1
#define ERROR_I24_NOT_READY		2
#define ERROR_I24_BAD_COMMAND		3
#define ERROR_I24_CRC			4
#define ERROR_I24_BAD_LENGTH		5
#define ERROR_I24_SEEK			6
#define ERROR_I24_NOT_DOS_DISK		7
#define ERROR_I24_SECTOR_NOT_FOUND	8
#define ERROR_I24_OUT_OF_PAPER		9
#define ERROR_I24_WRITE_FAULT		10
#define ERROR_I24_READ_FAULT		11
#define ERROR_I24_GEN_FAILURE		12
#define ERROR_I24_DISK_CHANGE		13
#define ERROR_I24_WRONG_DISK		15
#define ERROR_I24_UNCERTAIN_MEDIA	16
#define ERROR_I24_CHAR_CALL_INTERRUPTED 17
#define ERROR_I24_NO_MONITOR_SUPPORT	18
#define ERROR_I24_INVALID_PARAMETER	19
#define ERROR_I24_DEVICE_IN_USE 	20

#define ALLOWED_FAIL			0x0001
#define ALLOWED_ABORT			0x0002
#define ALLOWED_RETRY			0x0004
#define ALLOWED_IGNORE			0x0008
#define ALLOWED_ACKNOWLEDGE		0x0010
#define ALLOWED_DISPATCH		0x8000

#define I24_OPERATION			0x01
#define I24_AREA			0x06
#define I24_CLASS			0x80

/* Values for error CLASS */
#define ERRCLASS_OUTRES 		1   /* Out of Resource		      */
#define ERRCLASS_TEMPSIT		2   /* Temporary Situation	      */
#define ERRCLASS_AUTH			3   /* Permission problem	      */
#define ERRCLASS_INTRN			4   /* Internal System Error	      */
#define ERRCLASS_HRDFAIL		5   /* Hardware Failure 	      */
#define ERRCLASS_SYSFAIL		6   /* System Failure		      */
#define ERRCLASS_APPERR 		7   /* Application Error	      */
#define ERRCLASS_NOTFND 		8   /* Not Found		      */
#define ERRCLASS_BADFMT 		9   /* Bad Format		      */
#define ERRCLASS_LOCKED 		10  /* Locked			      */
#define ERRCLASS_MEDIA			11  /* Media Failure		      */
#define ERRCLASS_ALREADY		12  /* Collision with Existing Item   */
#define ERRCLASS_UNK			13  /* Unknown/other		      */
#define ERRCLASS_CANT			14
#define ERRCLASS_TIME			15

/* Values for error ACTION */
#define ERRACT_RETRY			1   /* Retry			      */
#define ERRACT_DLYRET			2   /* Delay Retry, retry after pause */
#define ERRACT_USER			3   /* Ask user to regive information */
#define ERRACT_ABORT			4   /* abort with clean up	      */
#define ERRACT_PANIC			5   /* abort immediately	      */
#define ERRACT_IGNORE			6   /* ignore			      */
#define ERRACT_INTRET			7   /* Retry after User Intervention  */

/* Values for error LOCUS */
#define ERRLOC_UNK			1   /* No appropriate value	      */
#define ERRLOC_DISK			2   /* Random Access Mass Storage     */
#define ERRLOC_NET			3   /* Network			      */
#define ERRLOC_SERDEV			4   /* Serial Device		      */
#define ERRLOC_MEM			5   /* Memory			      */

/* Abnormal termination codes */
#define TC_NORMAL		0
#define TC_HARDERR		1
#define TC_GP_TRAP		2
#define TC_SIGNAL		3

#define ERROR_SWAPPER_NOT_ACTIVE	32768
#define ERROR_INVALID_SWAPID		32769
#define ERROR_IOERR_SWAP_FILE		32770
#define ERROR_SWAP_TABLE_FULL		32771
#define ERROR_SWAP_FILE_FULL		32772
#define ERROR_CANT_INIT_SWAPPER 	32773
#define ERROR_SWAPPER_ALREADY_INIT	32774
#define ERROR_PMM_INSUFFICIENT_MEMORY	32775
#define ERROR_PMM_INVALID_FLAGS 	32776
#define ERROR_PMM_INVALID_ADDRESS	32777
#define ERROR_PMM_LOCK_FAILED		32778
#define ERROR_PMM_UNLOCK_FAILED 	32779
#define ERROR_PMM_MOVE_INCOMPLETE	32780
#define ERROR_UCOM_DRIVE_RENAMED	32781
#define ERROR_UCOM_FILENAME_TRUNCATED	32782
#define ERROR_UCOM_BUFFER_LENGTH	32783
#define ERROR_MON_CHAIN_HANDLE		32784
#define ERROR_MON_NOT_REGISTERED	32785
#define ERROR_SMG_ALREADY_TOP		32786
#define ERROR_PMM_ARENA_MODIFIED	32787
#define ERROR_SMG_PRINTER_OPEN		32788
#define ERROR_PMM_SET_FLAGS_FAILED	32789
#define ERROR_INVALID_DOS_DD		32790
#define ERROR_CPSIO_CODE_PAGE_INVALID	65026
#define ERROR_CPSIO_NO_SPOOLER		65027
#define ERROR_CPSIO_FONT_ID_INVALID	65028
#define ERROR_CPSIO_INTERNAL_ERROR	65033
#define ERROR_CPSIO_INVALID_PTR_NAME	65034
#define ERROR_CPSIO_NOT_ACTIVE		65037
#define ERROR_CPSIO_PID_FULL		65039
#define ERROR_CPSIO_PID_NOT_FOUND	65040
#define ERROR_CPSIO_READ_CTL_SEQ	65043
#define ERROR_CPSIO_READ_FNT_DEF	65045
#define ERROR_CPSIO_WRITE_ERROR 	65047
#define ERROR_CPSIO_WRITE_FULL_ERROR	65048
#define ERROR_CPSIO_WRITE_HANDLE_BAD	65049
#define ERROR_CPSIO_SWIT_LOAD		65074
#define ERROR_CPSIO_INV_COMMAND 	65077
#define ERROR_CPSIO_NO_FONT_SWIT	65078

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\ints.asm ===
include isvbop.inc

.286
.model medium,pascal

_DATA segment word public 'DATA'

Old2fHandler    dd      ?
Old73Handler    dd      ?
VddHandle       dw      -1

DllName         db      "VWIPXSPX.DLL",0
InitFunc        db      "VwInitialize",0
DispFunc        db      "VwDispatcher",0

_DATA ends

INIT_TEXT segment byte public 'CODE'

        assume  cs:INIT_TEXT

GrabInterrupts proc far
        pusha
        push    ds
        push    es
        push    _DATA
        pop     ds
        assume  ds:_DATA
        push    ds
        pop     es
        mov     si,offset DllName       ; ds:si = library name
        mov     di,offset InitFunc      ; es:di = init function name
        mov     bx,offset DispFunc      ; ds:bx = dispatcher function name
        RegisterModule                  ; returns carry if problem
        jc      @f
        mov     VddHandle,ax
        mov     ax,352fh
        int     21h
        mov     word ptr Old2fHandler,bx
        mov     word ptr Old2fHandler+2,es
ifdef   NEC_98
        mov     ax,3513h
else    ; NEC_98
        mov     ax,3573h
endif   ; NEC_98
        int     21h
        mov     word ptr Old73Handler,bx
        mov     word ptr Old73Handler+2,es
        push    seg PmIpx2fHandler
        pop     ds
        assume  ds:nothing
        mov     dx,offset PmIpx2fHandler
        mov     ax,252fh
        int     21h
        mov     dx,offset PmIpx73Handler
ifdef   NEC_98
        mov     ax,2513h
else    ; NEC_98
        mov     ax,2573h
endif   ; NEC_98
        int     21h
@@:     pop     es
        pop     ds
        popa
        ret
GrabInterrupts endp

INIT_TEXT ends

_TEXT segment byte public 'CODE'

        assume  cs:_TEXT

        public  PmIpx2fHandler
PmIpx2fHandler proc
        cmp     ax,1684h
        jne     @f
        cmp     bx,200h
        jne     @f
        push    cs
        pop     es
        mov     di,offset PmIpxEntryPoint
        iret
@@:     push    bp
        mov     bp,sp
        push    ax
        push    ds
        mov     ax,_DATA
        mov     ds,ax
        assume  ds:_DATA
        push    word ptr Old2fHandler+2
        push    word ptr Old2fHandler
        mov     ds,[bp-4]
        mov     ax,[bp-2]
        mov     bp,[bp]
        retf    6
PmIpx2fHandler endp

        public  PmIpx73Handler
PmIpx73Handler proc
        push    ds
        push    es
        pusha
        mov     bx,_DATA
        mov     ds,bx
        assume  ds:_DATA
        mov     ax,VddHandle
        mov     bx,-2
        DispatchCall                    ; get ECB
        jc      @f
        call    dword ptr es:[si][4]    ; branch to the ESR
        mov     al,20h
ifdef   NEC_98
        out     08h,al                  ; clear slave pic
        out     00h,al                  ;   "   master "
else    ; NEC_98
        out     0a0h,al                 ; clear slave pic
        out     20h,al                  ;   "   master "
endif   ; NEC_98
        popa
        pop     es
        pop     ds
        assume  ds:nothing
        iret
@@:     popa
        pop     es
        push    bp
        mov     bp,sp
        push    _DATA
        pop     ds
        assume  ds:_DATA
        push    word ptr Old73Handler+2
        push    word ptr Old73Handler
        mov     ds,[bp+2]
        assume  ds:nothing
        mov     bp,[bp]
        retf    4
PmIpx73Handler endp

        public PmIpxEntryPoint
PmIpxEntryPoint proc
        push    bp
        push    ds
        push    _DATA
        pop     ds
        assume  ds:_DATA
        mov     bp,ax
        mov     ax,VddHandle
        pop     ds
        assume  ds:nothing
        DispatchCall
        pop     bp
        ret
PmIpxEntryPoint endp

_TEXT ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\locals.h ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    locals.h

Abstract:

    Provides the common definitions for this project.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:

    

--*/

#define LFN 1
#include <winnet.h>
#include <wfwnet.h>
#include <spl_wnt.h>
#include <bseerr.h>

/*
 * global manifests 
 */

//
// used to figure out how to get the last error.
//
#define LAST_CALL_IS_LOCAL        (0)
#define LAST_CALL_IS_LANMAN_DRV   (1)
#define LAST_CALL_IS_WIN32        (2)

//
// the various DLLs we rely on to do the real work.
//
#define LANMAN_DRV       "LANMAN.DRV" 
#define MPR_DLL          "MPR.DLL"
#define MPRUI_DLL        "MPRUI.DLL"
#define NTLANMAN_DLL     "NTLANMAN.DLL"
#define KERNEL32_DLL     "KERNEL32.DLL"
#define WINSPOOL_DRV     "WINSPOOL.DRV"

//
// some convenient manifests for above so we dont need to
// do strcmp()s all the time.
//
#define USE_MPR_DLL      (0)
#define USE_MPRUI_DLL    (1)
#define USE_NTLANMAN_DLL (2)
#define USE_KERNEL32_DLL (3)
#define USE_WINSPOOL_DRV (4)

//
// resource type expected by Win32 APIs
//
#define RESOURCETYPE_ANY        0x00000000
#define RESOURCETYPE_DISK       0x00000001
#define RESOURCETYPE_PRINT      0x00000002
#define RESOURCETYPE_ERROR      0xFFFFFFFF

//
// errors unknown in 16bit world.
//
#define WIN32_EXTENDED_ERROR    1208L
#define WIN32_WN_CANCEL         1223L

//
// misc convenient macros
//
#define UNREFERENCED(x)  (void)x
#define TO_HWND32(x)     (0xFFFF0000 | (DWORD)x)


/*
 * various typedefs for the 16 bit functions we dynamically load
 */
typedef void (API *LPFN)();
typedef WORD (API *LPWNETOPENJOB)(LPSTR,LPSTR,WORD,LPINT);
typedef WORD (API *LPWNETCLOSEJOB)(WORD,LPINT,LPSTR);
typedef WORD (API *LPWNETWRITEJOB)(HANDLE,LPSTR,LPINT);
typedef WORD (API *LPWNETABORTJOB)(WORD,LPSTR);
typedef WORD (API *LPWNETHOLDJOB)(LPSTR,WORD);
typedef WORD (API *LPWNETRELEASEJOB)(LPSTR,WORD);
typedef WORD (API *LPWNETCANCELJOB)(LPSTR,WORD);
typedef WORD (API *LPWNETSETJOBCOPIES)(LPSTR,WORD,WORD);
typedef WORD (API *LPWNETWATCHQUEUE)(HWND,LPSTR,LPSTR,WORD);
typedef WORD (API *LPWNETUNWATCHQUEUE)(LPSTR);
typedef WORD (API *LPWNETLOCKQUEUEDATA)(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
typedef WORD (API *LPWNETUNLOCKQUEUEDATA)(LPSTR);
typedef WORD (API *LPWNETQPOLL)(HWND,WORD,WORD,LONG);
typedef WORD (API *LPWNETDEVICEMODE)(HWND);
typedef WORD (API *LPWNETVIEWQUEUEDIALOG)(HWND,LPSTR);
typedef WORD (API *LPWNETGETCAPS)(WORD);
typedef WORD (API *LPWNETGETERROR)(LPINT);
typedef WORD (API *LPWNETGETERRORTEXT)(WORD,LPSTR,LPINT);

typedef WORD (API *LPLFNFINDFIRST)(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
typedef WORD (API *LPLFNFINDNEXT)(HANDLE,LPINT,WORD,PFILEFINDBUF2);
typedef WORD (API *LPLFNFINDCLOSE)(HANDLE);
typedef WORD (API *LPLFNGETATTRIBUTES)(LPSTR,LPINT);
typedef WORD (API *LPLFNSETATTRIBUTES)(LPSTR,WORD);
typedef WORD (API *LPLFNCOPY)(LPSTR,LPSTR,PQUERYPROC);
typedef WORD (API *LPLFNMOVE)(LPSTR,LPSTR);
typedef WORD (API *LPLFNDELETE)(LPSTR);
typedef WORD (API *LPLFNMKDIR)(LPSTR);
typedef WORD (API *LPLFNRMDIR)(LPSTR);
typedef WORD (API *LPLFNGETVOLUMELABEL)(WORD,LPSTR);
typedef WORD (API *LPLFNSETVOLUMELABEL)(WORD,LPSTR);
typedef WORD (API *LPLFNPARSE)(LPSTR,LPSTR,LPSTR);
typedef WORD (API *LPLFNVOLUMETYPE)(WORD,LPINT);

/*
 * other misc global data/functions
 */
extern WORD    vLastCall ;
extern WORD    vLastError ;
extern WORD    wNetTypeCaps ;           
extern WORD    wUserCaps ;
extern WORD    wConnectionCaps ;
extern WORD    wErrorCaps ;
extern WORD    wDialogCaps ;
extern WORD    wAdminCaps ;
extern WORD    wSpecVersion;
extern WORD    wDriverVersion;

WORD API WNetGetCaps16(WORD p1) ;
WORD API WNetGetError16(LPINT p1) ;
WORD API WNetGetErrorText16(WORD p1, LPSTR p2, LPINT p3) ;

DWORD API GetLastError32(VOID) ;

WORD SetLastError(WORD err) ;

DWORD MapWNType16To32(WORD nType) ;
WORD MapWin32ErrorToWN16(DWORD err) ;
WORD GetLanmanDrvEntryPoints(LPFN *lplpfn,
                             LPSTR lpName) ;
//
// we define this because the compiler chokes if we add yet
// more to the include path to get to lmerr.h. 
//
// this is not that bad since the value below will never change.
//

#define NERR_BASE               2100
#define NERR_UseNotFound        (NERR_BASE+150)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\print.c ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Provides entry points for the Print Functions from Win3.1
    Network provider design. 

    All functions are obsolete. They either return WN_NOT_SUPPORTED
    or FALSE.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>


void API WNetPrintMgrSelNotify (BYTE p1,
                                LPQS2 p2,
                                LPQS2 p3,
	                        LPJOBSTRUCT2 p4,
                                LPJOBSTRUCT2 p5,
                                LPWORD p6,
                                LPSTR p7,
                                WORD p8)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    UNREFERENCED(p5) ;
    UNREFERENCED(p6) ;
    UNREFERENCED(p7) ;
    UNREFERENCED(p8) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return ;
}

WNETERR API WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	                             LPSTR lpBuffer, 
                                     LPWORD pcbBuffer, 
                                     LPWORD cAvail, 
                                     WORD usLevel)
{
    UNREFERENCED(lpszQueueName) ;
    UNREFERENCED(lpBuffer) ;
    UNREFERENCED(pcbBuffer) ;
    UNREFERENCED(cAvail) ;
    UNREFERENCED(usLevel) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WNETERR API WNetPrintMgrChangeMenus(HWND p1,
                                    HANDLE FAR *p2,
                                    BOOL FAR *p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WNETERR API WNetPrintMgrCommand (HWND p1,
                                 WORD p2)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

void API WNetPrintMgrExiting (void)
{
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return ;
}

BOOL API WNetPrintMgrExtHelp (DWORD p1)
{
    UNREFERENCED(p1) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return FALSE ;
}

WORD API WNetPrintMgrMoveJob (HWND p1,
                              LPSTR p2,
                              WORD p3, 
                              int p4)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    UNREFERENCED(p4) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return 0 ;
}

void API WNetPrintMgrStatusChange (LPSTR lpszQueueName,
	                           LPSTR lpszPortName, 
                                   WORD wQueueStatus, 
                                   WORD cJobsLeft, 
                                   HANDLE hJCB,
	                           BOOL fDeleted)
{
    UNREFERENCED(lpszQueueName) ;
    UNREFERENCED(lpszPortName) ;
    UNREFERENCED(wQueueStatus) ;
    UNREFERENCED(cJobsLeft) ; 
    UNREFERENCED(hJCB) ;
    UNREFERENCED(fDeleted) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\libentry.asm ===
PAGE,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           DWORD  ignore);     /* Always NULL - ignore */
;        
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;   Note - The last parameter to LibMain is included for compatibility
;   reasons.  Applications that wish to modify this file and remove the
;   parameter from LibMain may do so by simply removing the two
;   "push" instructions below marked with "****".
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include cmacros.inc

externFP <LibMain>               ; the C routine to be called

createSeg INIT_TEXT, INIT_TEXT, BYTE, PUBLIC, CODE
sBegin	INIT_TEXT
assumes CS,INIT_TEXT

?PLM=0                           ; 'C'naming
;externA  <_acrtused>             ; ensures that Win DLL startup code is linked

?PLM=1                           ; 'PASCAL' naming
externFP <LocalInit>             ; Windows heap init routine

cProc   LibEntry, <PUBLIC,FAR>   ; entry point into DLL

include CONVDLL.INC

cBegin
        push    di               ; handle of the module instance
        push    ds               ; library data segment
        push    cx               ; heap size
        push    es               ; Always NULL  ****  May remove (see above)
        push    si               ; Always NULL  ****  May remove (see above)

        ; if we have some heap then initialize it
        jcxz    callc            ; jump if no heap specified

        ; call the Windows function LocalInit() to set up the heap
        ; LocalInit((LPSTR)start, WORD cbHeap);
        
        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax            ; did it do it ok ?
        jz      error            ; quit if it failed

        ; invoke the C routine to do any special initialization

callc:
        call    LibMain          ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

error:
	pop	si		 ; clean up stack on a LocalInit error
        pop     es               
        pop     cx               
        pop     ds
        pop     di

exit:

cEnd

sEnd	INIT_TEXT

end LibEntry

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\misc.c ===
/*++ 

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    Provides entry points for miscellaneous functions to match the WFW3.1
    Network provider, 

    The majority of the functions are either no longer supported, or
    call thru to other functions. 

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>


WORD API WNetExitConfirm(HWND hwndOwner, 
                         WORD iExitType)
{
    UNREFERENCED(hwndOwner) ;
    UNREFERENCED(hwndOwner) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

BOOL API I_AutoLogon(HWND hwndOwner, 
                     LPSTR lpszReserved,
                     BOOL fPrompt,  
                     BOOL FAR *lpfLoggedOn)
{
    UNREFERENCED(hwndOwner) ;
    UNREFERENCED(lpszReserved) ;
    UNREFERENCED(fPrompt) ;
    UNREFERENCED(lpfLoggedOn) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return FALSE ;
}

BOOL API I_Logoff(HWND hwndOwner, 
                  LPSTR lpszReserved)
{
    UNREFERENCED(hwndOwner) ;
    UNREFERENCED(lpszReserved) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
    return FALSE ;
}

VOID API I_ChangePassword(HWND hwndOwner)
{
    UNREFERENCED(hwndOwner) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
}

VOID API I_ChangeCachePassword(HWND hwndOwner)
{
    UNREFERENCED(hwndOwner) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    SetLastError(WN_NOT_SUPPORTED) ;
}

WORD API I_ConnectDialog(HWND hwndParent, 
                         WORD iType)
{
    return WNetConnectDialog(hwndParent, iType) ;
}

WORD API I_ConnectionDialog(HWND hwndParent,
                            WORD iType)
{
    return WNetConnectDialog(hwndParent, iType) ;
}

WORD API WNetCachePassword(LPSTR pbResource, 
                           WORD cbResource,
                           LPSTR pbPassword,  
                           WORD cbPassword,
                           BYTE nType)
{
    UNREFERENCED(pbResource) ;
    UNREFERENCED(cbResource) ;
    UNREFERENCED(pbPassword) ;
    UNREFERENCED(cbPassword) ;
    UNREFERENCED(nType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetCachedPassword(LPSTR pbResource, 
                               WORD cbResource,
                               LPSTR pbPassword, 
                               LPWORD pcbPassword,
                               BYTE nType)
{
    UNREFERENCED(pbResource) ;
    UNREFERENCED(cbResource) ;
    UNREFERENCED(pbPassword) ;
    UNREFERENCED(pcbPassword) ;
    UNREFERENCED(nType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}


WORD API WNetRemoveCachedPassword(LPSTR pbResource,
                                  WORD cbResource,
                                  BYTE nType)
{
    UNREFERENCED(pbResource) ;
    UNREFERENCED(cbResource) ;
    UNREFERENCED(nType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetEnumCachedPasswords(LPSTR pbPrefix, 
                                 WORD cbPrefix,
                                 BYTE nType,
                                 CACHECALLBACK pfnCallback)
{
    UNREFERENCED(pbPrefix) ;
    UNREFERENCED(cbPrefix) ;
    UNREFERENCED(nType) ;
    UNREFERENCED(pfnCallback) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetSharesDialog(HWND hwndParent, 
                          WORD iType)
{
    UNREFERENCED(hwndParent) ;
    UNREFERENCED(iType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetSetDefaultDrive(WORD idriveDefault)
{
    UNREFERENCED(idriveDefault) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetShareCount(WORD iType)
{
    UNREFERENCED(iType) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetShareName(LPSTR lpszPath, 
                          LPSTR lpszBuf,
                          WORD cbBuf)
{
    UNREFERENCED(lpszPath) ;
    UNREFERENCED(lpszBuf) ;
    UNREFERENCED(cbBuf) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetSharePath(LPSTR lpszName, 
                          LPSTR lpszBuf,
                          WORD cbBuf)
{
    UNREFERENCED(lpszName) ;
    UNREFERENCED(lpszBuf) ;
    UNREFERENCED(cbBuf) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetLastConnection(WORD iType, 
                               LPWORD lpwConnIndex)
{
    UNREFERENCED(iType) ;
    UNREFERENCED(lpwConnIndex) ;
    vLastCall = LAST_CALL_IS_LOCAL ;
    return (SetLastError(WN_NOT_SUPPORTED)) ;
}

WORD API WNetGetError(LPINT p1)
{
    WORD err ;
    WORD wLastErr ;

    /*
     * fake the last error capabilty. if last thing we talked to was Win32,
     * the get the information from 32 bit system. ditto if it was a Win16
     * call.
     */
    if (vLastCall == LAST_CALL_IS_WIN32)
    {
        err = (WORD) GetLastError32() ; 
        return err ;
    }
    else if (vLastCall == LAST_CALL_IS_LANMAN_DRV)
    {
        err = WNetGetError16(&wLastErr) ;
        if (err != WN_SUCCESS)
            return err ;
        else
            return wLastErr ;
    }
    else  
    {
        return(vLastError) ;
    }
}

WORD API WNetGetErrorText(WORD p1,LPSTR p2,LPINT p3)
{
    if (vLastCall == LAST_CALL_IS_WIN32)
    {
        *p2 = 0 ;
        *p3 = 0 ;
        return WN_NOT_SUPPORTED ;
    }
    else  // use whatever lanman.drv gives us
    {
        return (WNetGetErrorText16(p1, p2, p3)) ;
    }
}

WORD API WNetErrorText(WORD p1,LPSTR p2,WORD p3)
{
    WORD cbBuffer = p3 ;

    return (WNetGetErrorText(p1, p2, &cbBuffer) == 0) ;
}

/*
 * misc startup/shutdown routines. nothing interesting
 */

VOID FAR PASCAL Enable(VOID) 
{
    return ;
}

VOID FAR PASCAL Disable(VOID) 
{
    return ;
}

int far pascal WEP()
{
    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\to32.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    to32.c

Abstract:

    Provides entry points for the Functions from WFW3.1
    Network provider design which are niw thunked to some
    32 bit equivalent.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>

//
// addresses to 32 bit entry points. note these cannot be
// called directly. CallProc32W must be used,
//
LPVOID lpfnWNetAddConnection = NULL ;
LPVOID lpfnWNetCancelConnection = NULL ;
LPVOID lpfnWNetGetConnection = NULL ;
LPVOID lpfnWNetRestoreConnection = NULL ;
LPVOID lpfnWNetGetUser = NULL ;
LPVOID lpfnWNetBrowseDialog = NULL ;
LPVOID lpfnWNetConnectDialog = NULL ;
LPVOID lpfnWNetDisconnectDialog = NULL ;
LPVOID lpfnWNetConnectionDialog = NULL ;
LPVOID lpfnWNetPropertyDialog = NULL ;
LPVOID lpfnWNetGetPropertyText = NULL ;
LPVOID lpfnWNetShareAsDialog = NULL ;
LPVOID lpfnWNetStopShareDialog = NULL ;
LPVOID lpfnWNetServerBrowseDialog = NULL ;
LPVOID lpfnWNetGetDirectoryType = NULL ;
LPVOID lpfnWNetDirectoryNotify = NULL ;
LPVOID lpfnGetLastError32 = NULL ;
LPVOID lpfnClosePrinter = NULL ;
LPVOID lpfnConnectToPrinter = NULL ;

//
// forward declare
//
WORD Get32BitEntryPoints( LPVOID *lplpfn, DWORD dwDll, LPSTR lpProcName ) ;
WORD API PrintConnectDialog(HWND p1) ;
WORD GetAlignedMemory(LPVOID FAR *pAligned, HANDLE FAR *pHandle, WORD wSize) ;
void FreeAlignedMemory(HANDLE handle) ;

//
// WNetAddConnection thunk to Win32
//
UINT API WNetAddConnection(LPSTR p1,LPSTR p2,LPSTR p3)
{
    WORD err ;
    LPSTR  aligned_p1 = NULL, aligned_p2 = NULL, aligned_p3 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL, handle_p3 = NULL;

    if (p1 == NULL || p3 == NULL)
        return WN_BAD_POINTER ;

    if (p2 && (*p2 == '\0'))
        p2 = NULL ;

    if (!lpfnWNetAddConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetAddConnection,
                                   USE_MPR_DLL,
                                   "WNetAddConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // make copy of parameters so that we are aligned (p1 & p3 wont be NULL)
    //
    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    if (err = GetAlignedMemory(&aligned_p3, &handle_p3, lstrlen(p3)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p3, p3) ;

    if (p2)
    {
        if (err = GetAlignedMemory(&aligned_p2, &handle_p2, lstrlen(p2)+1))
            goto ExitPoint ;
        lstrcpy(aligned_p2, p2) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)aligned_p2,
                                              (DWORD)aligned_p3,
                                              lpfnWNetAddConnection,
                                              (DWORD)7,
                                              (DWORD)3) ) ;
ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    FreeAlignedMemory(handle_p3) ;
    return err ;
}


//
// WNetCancelConnection thunk to Win32
//
UINT API WNetCancelConnection(LPSTR p1,BOOL p2)
{
    WORD err ;
    LPSTR  aligned_p1 = NULL ;
    HANDLE  handle_p1 = NULL ;

    if (p1 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetCancelConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetCancelConnection,
                                   USE_MPR_DLL,
                                   "WNetCancelConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // make copy of parameters so that we are aligned
    //
    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)p2,
                                              (DWORD)lpfnWNetCancelConnection,
                                              (DWORD)2,
                                              (DWORD)2) )  ;
ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    return err ;
}

//
// WNetGetConnection thunk to Win32
//
UINT API WNetGetConnection(LPSTR p1,LPSTR p2, UINT FAR *p3)
{
    WORD err ;
    LPSTR  aligned_p1 = NULL, aligned_p2 = NULL ;
    LPDWORD  aligned_p3 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL, handle_p3 = NULL;

    if (p1 == NULL || p2 == NULL || p3 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetConnection,
                                   USE_MPR_DLL,
                                   "WNetGetConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // make copy of parameters so that we are aligned
    //
    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    if (err = GetAlignedMemory(&aligned_p2, &handle_p2, *p3 ? *p3 : 1))
        goto ExitPoint ;

    if (err = GetAlignedMemory(&aligned_p3, &handle_p3, sizeof(DWORD)))
        goto ExitPoint ;
    *aligned_p3 = *p3 ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)aligned_p2,
                                              (DWORD)aligned_p3,
                                              lpfnWNetGetConnection,
                                              (DWORD)7,
                                              (DWORD)3) ) ;
    lstrcpy(p2, aligned_p2) ;

    if (err == WN_SUCCESS)
        *p3 = lstrlen(p2) + 1;
    else
        *p3 = (UINT)*aligned_p3 ;

ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    FreeAlignedMemory(handle_p3) ;
    return err ;
}

UINT API WNetRestoreConnection(HWND p1,LPSTR p2)
{
    WORD err ;
    LPSTR  aligned_p2 = NULL ;
    HANDLE  handle_p2 = NULL ;

    if (p2 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetRestoreConnection)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetRestoreConnection,
                                   USE_MPRUI_DLL,
                                   "WNetRestoreConnectionA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // guard against this weird case from Win3.0 days where -1
    // means something special. NULL is close approximation -> ie all.
    //
    if (p2 == (LPSTR)-1)
        p2 = NULL ;

    if (p2)
    {
        if (err = GetAlignedMemory(&aligned_p2, &handle_p2, lstrlen(p2)+1))
            goto ExitPoint ;
        lstrcpy(aligned_p2, p2) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W((LPVOID)TO_HWND32(p1),
                                              (DWORD)aligned_p2,
                                              (DWORD)lpfnWNetRestoreConnection,
                                              (DWORD)1,
                                              (DWORD)2) ) ;

ExitPoint:

    FreeAlignedMemory(handle_p2) ;
    return err ;
}

WORD API WNetGetUser(LPSTR p1,LPINT p2)
{
    WORD err ;
    LONG lTmp = *p2 ;
    LPSTR  aligned_p1 = NULL ;
    LPINT  aligned_p2 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL ;

    if (p1 == NULL || p2 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetUser)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetUser,
                                   USE_MPR_DLL,
                                   "WNetGetUserA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, *p2))
        goto ExitPoint ;

    if (err = GetAlignedMemory(&aligned_p2, &handle_p2, sizeof(DWORD)))
        goto ExitPoint ;
    *aligned_p2 = *p2 ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(NULL,
                                              (DWORD)aligned_p1,
                                              (DWORD)aligned_p2,
                                              lpfnWNetGetUser,
                                              (DWORD)7,
                                              (DWORD)3) );
    *p2 = (int) *aligned_p2 ;
    lstrcpy(p1, aligned_p1) ;

ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    return err ;
}

WORD API WNetBrowseDialog(HWND p1,WORD p2,LPSTR p3)
{
    WORD err ;
    DWORD dwErr ;
    LPSTR  aligned_p3 = NULL ;
    HANDLE  handle_p3 = NULL ;

    if (p3 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetBrowseDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetBrowseDialog,
                                   USE_MPRUI_DLL,
                                   "BrowseDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note that the WFW API does not let user specify buffer size.
    // we have a tmp buffer, and then copy over. this takes care
    // data alignment, also make sure we dont fault on 32 bit side.
    //
    // the 128 is consistent with what their docs specs the buffer
    // size should be.
    //
    if (err = GetAlignedMemory(&aligned_p3, &handle_p3, 128))
        goto ExitPoint ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = CallProc32W((LPVOID)TO_HWND32(p1),
                        (DWORD)MapWNType16To32(p2),
                        (DWORD)aligned_p3,
                        (DWORD)128,
                        lpfnWNetBrowseDialog,
                        (DWORD)2,
                        (DWORD)4)  ;
    if (dwErr == 0xFFFFFFFF)
        err = WN_CANCEL ;
    else
        err =  MapWin32ErrorToWN16( dwErr ) ;

    if (!err)
        lstrcpy(p3,aligned_p3) ;

ExitPoint:

    FreeAlignedMemory(handle_p3) ;
    return err ;
}

WORD API WNetConnectDialog(HWND p1,WORD p2)
{
    WORD err ;
    DWORD dwErr ;

    if (p2 == WNTYPE_PRINTER)
    {
        err = PrintConnectDialog(p1) ;
        return err ;
    }

    if (!lpfnWNetConnectDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetConnectDialog,
                                   USE_MPR_DLL,
                                   "WNetConnectionDialog" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = CallProc32W( (LPVOID)TO_HWND32(p1),
                         (DWORD)MapWNType16To32(p2),
                         (DWORD)lpfnWNetConnectDialog,
                         (DWORD) 0,
                         (DWORD) 2 )  ;
    if (dwErr == 0xFFFFFFFF)
        err = WN_CANCEL ;
    else
        err =  MapWin32ErrorToWN16( dwErr ) ;
    return err ;
}


WORD API WNetDisconnectDialog(HWND p1,WORD p2)
{
    WORD err ;
    DWORD dwErr ;

    if (!lpfnWNetDisconnectDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetDisconnectDialog,
                                   USE_MPR_DLL,
                                   "WNetDisconnectDialog" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = CallProc32W( (LPVOID)TO_HWND32(p1),
                         (DWORD)MapWNType16To32(p2),
                         (DWORD)lpfnWNetDisconnectDialog,
                         (DWORD) 0,
                         (DWORD) 2 ) ;
    if (dwErr == 0xFFFFFFFF)
        err = WN_CANCEL ;
    else
        err =  MapWin32ErrorToWN16( dwErr ) ;
    return err ;
}

WORD API WNetConnectionDialog(HWND p1,WORD p2)
{
    return (WNetConnectDialog(p1,p2)) ;
}

WORD API PrintConnectDialog(HWND p1)
{
    WORD err ;
    DWORD dwErr ;
    DWORD handle ;

    if (!lpfnClosePrinter)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnClosePrinter,
                                   USE_WINSPOOL_DRV,
                                   "ClosePrinter" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (!lpfnConnectToPrinter)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnConnectToPrinter,
                                   USE_WINSPOOL_DRV,
                                   "ConnectToPrinterDlg" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    err = WN_SUCCESS ;
    vLastCall = LAST_CALL_IS_WIN32 ;
    handle = CallProc32W( (LPVOID)TO_HWND32(p1),
                          (DWORD) 0,
                          (DWORD)lpfnConnectToPrinter,
                          (DWORD) 0,
                          (DWORD) 2 )  ;
    if (handle == 0)
        err = WN_CANCEL ;  // most likely reason
    else
    {
        dwErr = MapWin32ErrorToWN16( CallProc32W((LPVOID)handle,
                                                 (DWORD)lpfnClosePrinter,
                                                 (DWORD)0,
                                                 (DWORD)1) );
        // but ignore the error
    }
    return err ;
}

WORD API WNetPropertyDialog(HWND hwndParent,
                            WORD iButton,
                            WORD nPropSel,
                            LPSTR lpszName,
                            WORD nType)
{
    WORD err ;
    LPSTR  aligned_name = NULL ;
    HANDLE  handle_name = NULL ;

    if (!lpfnWNetPropertyDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetPropertyDialog,
                                   USE_MPR_DLL,
                                   "WNetPropertyDialogA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszName)
    {
        if (err = GetAlignedMemory(&aligned_name,
                                   &handle_name,
                                   lstrlen(lpszName)+1))
            goto ExitPoint ;
        lstrcpy(aligned_name, lpszName) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) iButton,
                                               (DWORD) nPropSel,
                                               (DWORD) aligned_name,
                                               (DWORD) nType,
                                               lpfnWNetPropertyDialog,
                                               (DWORD)2,
                                               (DWORD)5) ) ;
ExitPoint:

    FreeAlignedMemory(handle_name) ;
    return err ;
}

WORD API WNetGetPropertyText(WORD iButton,
                             WORD nPropSel,
                             LPSTR lpszName,
                             LPSTR lpszButtonName,
                             WORD cbButtonName,
                             WORD nType)
{
    WORD err ;
    LPSTR  aligned_name = NULL, aligned_button_name = NULL ;
    HANDLE  handle_name = NULL, handle_button_name = NULL ;

    if (lpszButtonName == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetPropertyText)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetPropertyText,
                                   USE_MPR_DLL,
                                   "WNetGetPropertyTextA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszName)
    {
        if (err = GetAlignedMemory(&aligned_name,
                                   &handle_name,
                                   lstrlen(lpszName)+1))
            goto ExitPoint ;
        lstrcpy(aligned_name, lpszName) ;
    }

    if (err = GetAlignedMemory(&aligned_button_name,
                               &handle_button_name,
                               cbButtonName))
        goto ExitPoint ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)iButton,
                                               (DWORD) nPropSel,
                                               (DWORD) aligned_name,
                                               (DWORD) aligned_button_name,
                                               (DWORD) cbButtonName,
                                               (DWORD) nType,
                                               lpfnWNetGetPropertyText,
                                               (DWORD)12,
                                               (DWORD)6) ) ;
    if (err == WN_SUCCESS)
        lstrcpy(lpszButtonName, aligned_button_name) ;

ExitPoint:

    FreeAlignedMemory(handle_name) ;
    FreeAlignedMemory(handle_button_name) ;
    return err ;
}

WORD API WNetShareAsDialog(HWND hwndParent,
                           WORD iType,
                           LPSTR lpszPath)
{
    WORD err ;
    LPSTR  aligned_path = NULL ;
    HANDLE  handle_path = NULL ;

    if (!lpfnWNetShareAsDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetShareAsDialog,
                                   USE_NTLANMAN_DLL,
                                   "ShareAsDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszPath)
    {
        if (err = GetAlignedMemory(&aligned_path,
                                   &handle_path,
                                   lstrlen(lpszPath)+1))
            goto ExitPoint ;
        lstrcpy(aligned_path, lpszPath) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) MapWNType16To32(iType),
                                               (DWORD) aligned_path,
                                               lpfnWNetShareAsDialog,
                                               (DWORD)1,
                                               (DWORD)3) ) ;
ExitPoint:

    FreeAlignedMemory(handle_path) ;
    return err ;
}

WORD API WNetStopShareDialog(HWND hwndParent,
                             WORD iType,
                             LPSTR lpszPath)
{
    WORD err ;
    LPSTR  aligned_path = NULL ;
    HANDLE  handle_path = NULL ;

    if (!lpfnWNetStopShareDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetStopShareDialog,
                                   USE_NTLANMAN_DLL,
                                   "StopShareDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszPath)
    {
        if (err = GetAlignedMemory(&aligned_path,
                                   &handle_path,
                                   lstrlen(lpszPath)+1))
            goto ExitPoint ;
        lstrcpy(aligned_path, lpszPath) ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) MapWNType16To32(iType),
                                               (DWORD) aligned_path,
                                               lpfnWNetStopShareDialog,
                                               (DWORD)1,
                                               (DWORD)3) ) ;
ExitPoint:

    FreeAlignedMemory(handle_path) ;
    return err ;
}

WORD API WNetServerBrowseDialog(HWND hwndParent,
                                LPSTR lpszSectionName,
                                LPSTR lpszBuffer,
                                WORD cbBuffer,
                                DWORD flFlags)
{
    WORD err ;
    LPSTR  aligned_buffer = NULL ;
    HANDLE  handle_buffer = NULL ;

    UNREFERENCED(lpszSectionName) ;
    UNREFERENCED(flFlags) ;

    if (!lpfnWNetServerBrowseDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetServerBrowseDialog,
                                   USE_NTLANMAN_DLL,
                                   "ServerBrowseDialogA0" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (lpszBuffer)
    {
        if (err = GetAlignedMemory(&aligned_buffer, &handle_buffer, cbBuffer))
            goto ExitPoint ;
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W( (LPVOID)TO_HWND32(hwndParent),
                                               (DWORD) aligned_buffer,
                                               (DWORD) cbBuffer,
                                               lpfnWNetServerBrowseDialog,
                                               (DWORD)2,
                                               (DWORD)3) ) ;
    if (err == WN_SUCCESS)
        lstrcpy(lpszBuffer, aligned_buffer) ;

ExitPoint:

    FreeAlignedMemory(handle_buffer) ;
    return err ;
}

WORD API WNetGetDirectoryType(LPSTR p1,LPINT p2)
{
    WORD err ;
    LPSTR   aligned_p1 = NULL ;
    LPDWORD aligned_p2 = NULL ;
    HANDLE  handle_p1 = NULL, handle_p2 = NULL ;

    if (p1 == NULL || p2 == NULL)
        return WN_BAD_POINTER ;

    if (!lpfnWNetGetDirectoryType)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnWNetGetDirectoryType,
                                   USE_MPR_DLL,
                                   "WNetGetDirectoryTypeA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    if (err = GetAlignedMemory(&aligned_p1, &handle_p1, lstrlen(p1)+1))
        goto ExitPoint ;
    lstrcpy(aligned_p1, p1) ;

    if (err = GetAlignedMemory(&aligned_p2, &handle_p2, sizeof(DWORD)))
        goto ExitPoint ;

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    err =    MapWin32ErrorToWN16( CallProc32W(aligned_p1,
                                              (DWORD)aligned_p2,
                                              (DWORD)TRUE,
                                              lpfnWNetGetDirectoryType,
                                              (DWORD)6,
                                              (DWORD)3) ) ;
    *p2 = (int) *aligned_p2 ;

ExitPoint:

    FreeAlignedMemory(handle_p1) ;
    FreeAlignedMemory(handle_p2) ;
    return err ;
}

WORD API WNetDirectoryNotify(HWND p1,LPSTR p2,WORD p3)
{
    UNREFERENCED(p1) ;
    UNREFERENCED(p2) ;
    UNREFERENCED(p3) ;
    return WN_SUCCESS ;
}

DWORD API GetLastError32(VOID)
{
    WORD err ;
    DWORD dwErr ;

    if (!lpfnGetLastError32)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from 32 bit side
        //
        err = Get32BitEntryPoints( &lpfnGetLastError32,
                                   USE_KERNEL32_DLL,
                                   "GetLastError" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_WIN32 ;
    dwErr = (UINT) CallProc32W((LPVOID)lpfnGetLastError32,
                               (DWORD)0,
                               (DWORD)0) ;
    return (MapWin32ErrorToWN16(dwErr)) ;
}

/*
 * Misc support routines
 */

/*******************************************************************

    NAME:       Get32BitEntryPoints

    SYNOPSIS:   Get the address of a 32 bit entry point that can
                then be passed to CallProv32W. Will load the library
                if it has not already been loaded.

    ENTRY:      lplpfn     - used to return the address
                dwDll      - which dll to use (see locals.h defintions)
                lpProcName - proc to load

    EXIT:

    RETURNS:    error code

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD Get32BitEntryPoints( LPVOID *lplpfn, DWORD dwDll, LPSTR lpProcName )
{
    static DWORD hmodKernel32 = NULL ;
    static DWORD hmodNTLanman = NULL ;
    static DWORD hmodMpr = NULL ;
    static DWORD hmodMprUI = NULL ;
    static DWORD hmodWinSpool = NULL ;
    DWORD hmod = NULL ;

    //
    // if we havent loaded it appropriate DLL, load it now
    //
    switch (dwDll)
    {
        case USE_MPR_DLL:
            if (hmodMpr == NULL)
            {
                hmodMpr = LoadLibraryEx32W(MPR_DLL, NULL, 0) ;
                if (hmodMpr == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodMpr ;
            break ;

        case USE_MPRUI_DLL:
            if (hmodMprUI == NULL)
            {
                hmodMprUI = LoadLibraryEx32W(MPRUI_DLL, NULL, 0) ;
                if (hmodMprUI == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodMprUI ;
            break ;

        case USE_NTLANMAN_DLL:
            if (hmodNTLanman == NULL)
            {
                hmodNTLanman = LoadLibraryEx32W(NTLANMAN_DLL, NULL, 0) ;
                if (hmodNTLanman == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodNTLanman ;
            break ;

        case USE_KERNEL32_DLL:
            if (hmodKernel32 == NULL)
            {
                hmodKernel32 = LoadLibraryEx32W(KERNEL32_DLL, NULL, 0) ;
                if (hmodKernel32 == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodKernel32 ;
            break ;

        case USE_WINSPOOL_DRV:
            if (hmodWinSpool == NULL)
            {
                hmodWinSpool = LoadLibraryEx32W(WINSPOOL_DRV, NULL, 0) ;
                if (hmodWinSpool == NULL)
                    return WN_NOT_SUPPORTED ;
            }
            hmod = hmodWinSpool ;
            break ;

        default:
            return ERROR_GEN_FAILURE ;
    }

    //
    // get the procedure
    //
    *lplpfn = (LPVOID) GetProcAddress32W(hmod, lpProcName) ;
    if (! *lplpfn )
            return WN_NOT_SUPPORTED ;

    return WN_SUCCESS ;
}

/*******************************************************************

    NAME:       MapWNType16To32

    SYNOPSIS:   map the 16 WNet types for DISK/PRINT, etc
                to their 32 bit equivalents

    ENTRY:      nType - 16 bit type

    EXIT:

    RETURNS:    the 32 bit type

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
DWORD MapWNType16To32(WORD nType)
{
    switch (nType)
    {
        case WNTYPE_DRIVE :
        case WNTYPE_FILE :
            return RESOURCETYPE_DISK ;
        case WNTYPE_PRINTER :
            return RESOURCETYPE_PRINT ;
        case WNTYPE_COMM :
        default :
            return RESOURCETYPE_ERROR ;
    }
}

/*******************************************************************

    NAME:       MapWin32ErrorToWN16

    SYNOPSIS:   maps a Win 32 error the old style WN_ 16 bit error.

    ENTRY:      err - Win32 error

    EXIT:

    RETURNS:    Win 16 error

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD MapWin32ErrorToWN16(DWORD err)
{
    switch (err)
    {
        case ERROR_NOT_SUPPORTED:
            return WN_NOT_SUPPORTED ;

        case WIN32_WN_CANCEL:
            return WN_CANCEL ;

        case WIN32_EXTENDED_ERROR :
        case ERROR_UNEXP_NET_ERR:
            return WN_NET_ERROR ;

        case ERROR_MORE_DATA:
            return WN_MORE_DATA ;

        case ERROR_INVALID_PARAMETER:
            return WN_BAD_VALUE ;

        case ERROR_INVALID_PASSWORD:
            return WN_BAD_PASSWORD ;

        case ERROR_ACCESS_DENIED:
            return WN_ACCESS_DENIED ;

        case ERROR_NETWORK_BUSY:
            return WN_FUNCTION_BUSY ;

        case ERROR_NOT_ENOUGH_MEMORY:
            return WN_OUT_OF_MEMORY ;

        case ERROR_BAD_NET_NAME:
        case ERROR_BAD_NETPATH:
            return WN_BAD_NETNAME ;

        case ERROR_INVALID_DRIVE:
            return WN_BAD_LOCALNAME ;

        case ERROR_ALREADY_ASSIGNED:
            return WN_ALREADY_CONNECTED ;

        case ERROR_GEN_FAILURE:
            return WN_DEVICE_ERROR ;

        case NERR_UseNotFound:
            return WN_NOT_CONNECTED ;

        default:
            return ( (WORD) err ) ;
    }
}

/*******************************************************************

    NAME:       GetAlignedMemory

    SYNOPSIS:   global alloc some mem to make sure we have DWORD
                aligned data. non x86 platforms may need this.

    ENTRY:      pAligned : used to return pointer to aligned memory allocated
                pHandle  : used to return handle of aligned memory allocated
                wSize    : bytes required

    EXIT:

    RETURNS:    WN_SUCCESS or WN_OUT_OF_MEMORY

    NOTES:

    HISTORY:
        ChuckC          27-Feb-94   Created

********************************************************************/
WORD GetAlignedMemory(LPVOID FAR *pAligned, HANDLE FAR *pHandle, WORD wSize)
{
    *pAligned = NULL ;
    *pHandle = NULL ;

    if (!(*pHandle = GlobalAlloc(GMEM_ZEROINIT|GMEM_FIXED,wSize)))
    {
        return WN_OUT_OF_MEMORY ;
    }

    if (!(*pAligned = (LPVOID)GlobalLock(*pHandle)))
    {
        (void) GlobalFree(*pHandle) ;
        *pHandle = NULL ;
        return WN_OUT_OF_MEMORY ;
    }

    return WN_SUCCESS ;
}

/*******************************************************************

    NAME:       FreeAlignedMemory

    SYNOPSIS:   free global memory allocated by GetAlignedMemory.

    ENTRY:      Handle  : handle of aligned memory to be freed

    EXIT:

    RETURNS:    none

    NOTES:

    HISTORY:
        ChuckC          27-Feb-94   Created

********************************************************************/
void FreeAlignedMemory(HANDLE handle)
{
    if (handle)
    {
        (void) GlobalUnlock(handle) ;
        (void) GlobalFree(handle) ;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\libentry.asm ===
; LIBENTRY.ASM -- Entry point for library modules (small model)
; -------------------------------------------------------------

        Extrn   LibMain:Near

_TEXT   SEGMENT BYTE PUBLIC 'CODE'
        ASSUME  CS:_TEXT
        PUBLIC  LibEntry

LibEntry        proc    far
        push    di
        push    ds
        push    cx
        push    es
        push    si

        call    LibMain

        ret
LibEntry        endp

_TEXT   ENDS

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wfwnet\wfwnet.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    wfwnet.c

Abstract:

    Provides entry points for the functions that will be mapped
    to LANMAN.DRV.

Author:

    Chuck Y Chan (ChuckC) 25-Mar-1993

Revision History:


--*/
#include <windows.h>
#include <locals.h>

#define MAX_PATH                260

WORD vLastCall = LAST_CALL_IS_LOCAL ;
WORD vLastError = 0 ;

WORD    wNetTypeCaps ;           /* Current capabilities */
WORD    wUserCaps ;
WORD    wConnectionCaps ;
WORD    wErrorCaps ;
WORD    wDialogCaps ;
WORD    wAdminCaps ;
WORD    wSpecVersion = 0x0310 ;
WORD    wDriverVersion = 0x0300 ;
WORD _acrtused=0;

void I_SetCapBits(void) ;

//
// global pointers to functions
//
LPWNETOPENJOB                lpfnWNetOpenJob = NULL ;
LPWNETCLOSEJOB               lpfnWNetCloseJob = NULL ;
LPWNETWRITEJOB               lpfnWNetWriteJob = NULL ;
LPWNETABORTJOB               lpfnWNetAbortJob = NULL ;
LPWNETHOLDJOB                lpfnWNetHoldJob = NULL ;
LPWNETRELEASEJOB             lpfnWNetReleaseJob = NULL ;
LPWNETCANCELJOB              lpfnWNetCancelJob = NULL ;
LPWNETSETJOBCOPIES           lpfnWNetSetJobCopies = NULL ;
LPWNETWATCHQUEUE             lpfnWNetWatchQueue = NULL ;
LPWNETUNWATCHQUEUE           lpfnWNetUnwatchQueue = NULL ;
LPWNETLOCKQUEUEDATA          lpfnWNetLockQueueData = NULL ;
LPWNETUNLOCKQUEUEDATA        lpfnWNetUnlockQueueData = NULL ;
LPWNETQPOLL                  lpfnWNetQPoll = NULL ;
LPWNETDEVICEMODE             lpfnWNetDeviceMode = NULL ;
LPWNETVIEWQUEUEDIALOG        lpfnWNetViewQueueDialog = NULL ;
LPWNETGETCAPS                lpfnWNetGetCaps16 = NULL ;
LPWNETGETERROR               lpfnWNetGetError16 = NULL ;
LPWNETGETERRORTEXT           lpfnWNetGetErrorText16 = NULL ;

extern VOID FAR PASCAL GrabInterrupts(void);

int FAR PASCAL LibMain(HINSTANCE hInstance,
                       WORD      wDataSeg,
                       WORD      cbHeapSize,
                       LPSTR     lpszCmdLine) ;

/*
 * functions passed to LANMAN.DRV
 */

WORD API WNetOpenJob(LPSTR p1,LPSTR p2,WORD p3,LPINT p4)
{
    WORD err ;

    if (!lpfnWNetOpenJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetOpenJob,
                                       "WNETOPENJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetOpenJob)(p1,p2,p3,p4) ) ;
}

WORD API WNetCloseJob(WORD p1,LPINT p2,LPSTR p3)
{
    WORD err ;

    if (!lpfnWNetCloseJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetCloseJob,
                                       "WNETCLOSEJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetCloseJob)(p1,p2,p3) ) ;
}

WORD API WNetWriteJob(HANDLE p1,LPSTR p2,LPINT p3)
{
    WORD err ;

    if (!lpfnWNetWriteJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetWriteJob,
                                       "WNETWRITEJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetWriteJob)(p1,p2,p3) ) ;
}

WORD API WNetAbortJob(WORD p1,LPSTR p2)
{
    WORD err ;

    if (!lpfnWNetAbortJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetAbortJob,
                                       "WNETABORTJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetAbortJob)(p1,p2) ) ;
}

WORD API WNetHoldJob(LPSTR p1,WORD p2)
{
    WORD err ;

    if (!lpfnWNetHoldJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetHoldJob,
                                       "WNETHOLDJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetHoldJob)(p1,p2) ) ;
}

WORD API WNetReleaseJob(LPSTR p1,WORD p2)
{
    WORD err ;

    if (!lpfnWNetReleaseJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetReleaseJob,
                                       "WNETRELEASEJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetReleaseJob)(p1,p2) ) ;
}

WORD API WNetCancelJob(LPSTR p1,WORD p2)
{
    WORD err ;

    if (!lpfnWNetCancelJob)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetCancelJob,
                                       "WNETCANCELJOB" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetCancelJob)(p1,p2) ) ;
}

WORD API WNetSetJobCopies(LPSTR p1,WORD p2,WORD p3)
{
    WORD err ;

    if (!lpfnWNetSetJobCopies)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetSetJobCopies,
                                       "WNETSETJOBCOPIES" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetSetJobCopies)(p1,p2,p3) ) ;
}

WORD API WNetWatchQueue(HWND p1,LPSTR p2,LPSTR p3,WORD p4)
{
    WORD err ;

    if (!lpfnWNetWatchQueue)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetWatchQueue,
                                       "WNETWATCHQUEUE" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetWatchQueue)(p1,p2,p3,p4) ) ;
}

WORD API WNetUnwatchQueue(LPSTR p1)
{
    WORD err ;

    if (!lpfnWNetUnwatchQueue)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetUnwatchQueue,
                                       "WNETUNWATCHQUEUE" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetUnwatchQueue)(p1) ) ;
}

WORD API WNetLockQueueData(LPSTR p1,LPSTR p2,LPQUEUESTRUCT FAR *p3)
{
    WORD err ;

    if (!lpfnWNetLockQueueData)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetLockQueueData,
                                       "WNETLOCKQUEUEDATA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetLockQueueData)(p1,p2,p3) ) ;
}

WORD API WNetUnlockQueueData(LPSTR p1)
{
    WORD err ;

    if (!lpfnWNetUnlockQueueData)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetUnlockQueueData,
                                       "WNETUNLOCKQUEUEDATA" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetUnlockQueueData)(p1) ) ;
}

void API WNetQPoll(HWND hWnd, unsigned iMessage, WORD wParam, LONG lParam)
{
    WORD err ;

    if (!lpfnWNetQPoll)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetQPoll,
                                       "WNETQPOLL" ) ;
        if (err)
        {
            SetLastError(err) ;
            return ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    (*lpfnWNetQPoll)(hWnd, iMessage, wParam, lParam) ;
}

WORD API WNetDeviceMode(HWND p1)
{
    WORD err ;

    if (!lpfnWNetDeviceMode)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetDeviceMode,
                                       "WNETDEVICEMODE" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetDeviceMode)(p1) ) ;
}

WORD API WNetViewQueueDialog(HWND p1,LPSTR p2)
{
    WORD err ;

    if (!lpfnWNetViewQueueDialog)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetViewQueueDialog,
                                       "WNETVIEWQUEUEDIALOG" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetViewQueueDialog)(p1,p2) ) ;
}

WORD API WNetGetCaps16(WORD p1)
{
    WORD err ;

    if (!lpfnWNetGetCaps16)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetGetCaps16,
                                       "WNETGETCAPS" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetGetCaps16)(p1) ) ;
}

WORD API WNetGetError16(LPINT p1)
{
    WORD err ;

    if (!lpfnWNetGetError16)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetGetError16,
                                       "WNETGETERROR" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetGetError16)(p1) ) ;
}

WORD API WNetGetErrorText16(WORD p1, LPSTR p2, LPINT p3)
{
    WORD err ;

    if (!lpfnWNetGetErrorText16)
    {
        //
        // start off as a our code until we get the entry point
        //
        vLastCall = LAST_CALL_IS_LOCAL ;

        //
        // get the entry point from LANMAN.DRV
        //
        err = GetLanmanDrvEntryPoints( (LPFN *)&lpfnWNetGetErrorText16,
                                       "WNETGETERRORTEXT" ) ;
        if (err)
        {
            SetLastError(err) ;
            return err ;
        }
    }

    //
    // note it is no longer an error in our code. and call the API
    //
    vLastCall = LAST_CALL_IS_LANMAN_DRV ;
    return ( (*lpfnWNetGetErrorText16)(p1,p2,p3) ) ;
}

WORD API WNetGetCaps(WORD nIndex)
{
    switch (nIndex)
    {
    case WNNC_SPEC_VERSION:
	return  wSpecVersion;

    case WNNC_NET_TYPE:
	return  wNetTypeCaps;

    case WNNC_DRIVER_VERSION:
	return  wDriverVersion;

    case WNNC_USER:
	return  wUserCaps;

    case WNNC_CONNECTION:
	return  wConnectionCaps;

    case WNNC_PRINTING:
	return  (WNetGetCaps16(nIndex)) ;

    case WNNC_DIALOG:
	return  wDialogCaps;

    case WNNC_ADMIN:
	return  wAdminCaps;

    case WNNC_ERROR:
	return  wErrorCaps;

    default:
	return  0;
    }
}

/*
 * misc support functions
 */

/*******************************************************************

    NAME:	GetLanmanDrvEntryPoints

    SYNOPSIS:   gets the address of the named procedure
                from LANMAN.DRV, will load library if first time.

    ENTRY:      lplpfn - used to receive the address
                lpName - name of the procedure

    EXIT:

    RETURNS:    0 if success, error code otherwise.

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD GetLanmanDrvEntryPoints(LPFN *lplpfn, LPSTR lpName)
{
#define LANMANSHORTPATH "32\\" LANMAN_DRV

    static HINSTANCE hModule = NULL ;
    CHAR    szLanmanFullPath[MAX_PATH + sizeof(LANMANSHORTPATH)];
    USHORT  usLanmanFullPathLen;

    //
    // if we havent loaded it, load it now
    //
    if (hModule == NULL)
    {
        usLanmanFullPathLen = GetSystemDirectory((LPSTR)&szLanmanFullPath, sizeof(szLanmanFullPath));
        if (usLanmanFullPathLen == 0 || usLanmanFullPathLen >= sizeof(szLanmanFullPath))
        {
            return WN_NOT_SUPPORTED ;
        }
        else
        {
            lstrcpyn(&(szLanmanFullPath[usLanmanFullPathLen]), LANMANSHORTPATH, sizeof(LANMANSHORTPATH));
            hModule = LoadLibrary(szLanmanFullPath) ;
            if (hModule <= HINSTANCE_ERROR)
                return WN_NOT_SUPPORTED ;
        }
    }

    //
    // get the procedure
    //
    *lplpfn = (LPFN) GetProcAddress(hModule, lpName) ;
    if (! *lplpfn )
            return WN_NOT_SUPPORTED ;

    return NO_ERROR ;
}

/*******************************************************************

    NAME:	SetLastError

    SYNOPSIS:   makes note of last error

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
WORD SetLastError(WORD err)
{
    vLastError = err ;
    return err ;
}

/*******************************************************************

    NAME:	LibMain

    SYNOPSIS:   dll init entry point. only thing we do here is init
                the capability bits.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/

#define NETWARE_DRV    "NETWARE.DRV"

int FAR PASCAL LibMain(HINSTANCE hInstance,
                       WORD      wDataSeg,
                       WORD      cbHeapSize,
                       LPSTR     lpszCmdLine)
{
#define    NETWARESHORTPATH "32\\" NETWARE_DRV
    BOOL   fLoadNetware = FALSE ;
    char   IsInstalledString[16] ;
    CHAR   szNetwareFullPath[MAX_PATH + sizeof(NETWARESHORTPATH)];
    USHORT usNetwareFullPathLen;

    UNREFERENCED(hInstance) ;
    UNREFERENCED(wDataSeg) ;
    UNREFERENCED(cbHeapSize) ;
    UNREFERENCED(lpszCmdLine) ;

    I_SetCapBits() ;

    if (GetProfileString("NWCS",
                         "NwcsInstalled",
                         "0",
                         IsInstalledString,
                         sizeof(IsInstalledString)))
    {
        fLoadNetware = (lstrcmp("1",IsInstalledString)==0) ;
    }

    //
    // Grab the interrupt for NWIPXSPX
    //
    if (fLoadNetware)
    {
        GrabInterrupts();

        usNetwareFullPathLen = GetSystemDirectory((LPSTR)&szNetwareFullPath, sizeof(szNetwareFullPath));
        if (usNetwareFullPathLen != 0 && usNetwareFullPathLen < sizeof(szNetwareFullPath))
        {
            lstrcpyn(&(szNetwareFullPath[usNetwareFullPathLen]), NETWARESHORTPATH, sizeof(NETWARESHORTPATH));

            //
            // if the file NETWARE.DRV exists, we load it. we dont really
            // use it, but some Netware aware apps require that it is loaded.
            //
            if (LoadLibrary(szNetwareFullPath) > HINSTANCE_ERROR)
            {
                (void)WriteProfileString("Windows",
                                        "NetWarn",
                                        "0") ;

            }
        }
    }

    return 1 ;
}


/*******************************************************************

    NAME:	I_SetCapBits

    SYNOPSIS:   initernal routine to set the capability bits

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          25-Mar-93   Created

********************************************************************/
void I_SetCapBits(void)
{
    wNetTypeCaps    = WNNC_NET_MultiNet |
                      WNNC_SUBNET_WinWorkgroups;

    wUserCaps       = WNNC_USR_GetUser;

    wConnectionCaps =  (WNNC_CON_AddConnection    |
			WNNC_CON_CancelConnection |
			WNNC_CON_GetConnections   |
			WNNC_CON_AutoConnect      |
			WNNC_CON_BrowseDialog     |
			WNNC_CON_RestoreConnection ) ;

    wErrorCaps      = WNNC_ERR_GetError         |
		      WNNC_ERR_GetErrorText;

    wDialogCaps  = (WNNC_DLG_DeviceMode |
                    WNNC_DLG_ShareAsDialog    |
		    WNNC_DLG_PropertyDialog   |
                    WNNC_DLG_ConnectionDialog |
	            WNNC_DLG_ConnectDialog    |
		    WNNC_DLG_DisconnectDialog |
		    WNNC_DLG_BrowseDialog     );

    wAdminCaps      =     ( WNNC_ADM_GetDirectoryType   |
			    WNNC_ADM_DirectoryNotify    ) ;
/* disable LFN for now
                          | WNNC_ADM_LongNames ) ;
 */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\fakewife.c ===
/**************************************************************************
*
*  - fakewife.c -  Dummy functions
*
* Windows Intelligent Font Environment Maneger for Win32 and NT
*
*  Author : kazuyuki Kato [ V-kazuyK ]
*
* History :
*
*  11.Nov.1993 -By- kazuyuki Kato [ V-kazuyK ]
* Create it.
*
*************************************************************************/

#include <windows.h>
#include "wife.h"

extern HINSTANCE hInst;

typedef int (FAR PASCAL * LPLOADSTRING)(HANDLE, USHORT, LPSTR, int);
typedef int (FAR PASCAL * LPMESSAGEBOX)(HWND, LPSTR, LPSTR, USHORT);
typedef int (FAR cdecl * LPWSPRINTF)(LPSTR,LPSTR,...);

#define IDCANCEL            2

SHORT FAR PASCAL InternalWarningMessageByString(
        HWND hParentWindow,
        LPSTR szMsg,
        LPSTR szTitle,
        USHORT mode
)
{
        HANDLE hUser;
        LPMESSAGEBOX lpMessageBox;
        SHORT result;

        /* get instance of user.exe */
        hUser = GetModuleHandle("USER.EXE");
        if( hUser == NULL ) return(IDCANCEL);

        /* get procedure instance of MessageBox */
        lpMessageBox = (LPMESSAGEBOX)GetProcAddress( hUser, MAKEINTRESOURCE(1) );
        if( lpMessageBox == NULL ) return(IDCANCEL);

        result = (*lpMessageBox)(
                NULL,   /* no current window handle */
                szMsg,
                szTitle,
                mode
        );

        return( result );
}



VOID NotifyNoSuport( VOID )
{

    if ( IDNO == MiscWarningMessage( hInst, IDS_NOTSUPORTFUNCTION, IDS_WIFETITLE, MB_YESNO ))
        FatalAppExit( 0, NULL );

//    MessageBox( NULL, sz, sz2, MB_OK );
//    OutputDebugString( sz );


}



LONG FAR PASCAL  FdiClaimFontFile( HFD hFD, LPSTR lpszFileName )
{NotifyNoSuport();return 0;}
LONG FAR PASCAL FdiConvertFontFile( HFD hFD, LPSTR lpszSrcFileName, LPSTR lpszDestDirName, LPSTR lpszResultPackName )
{NotifyNoSuport();return -1L;}
HFF FAR PASCAL FdiLoadFontFile( HFD hFD, LPSTR lpszPackName )
{NotifyNoSuport();return -1L;}
LONG FAR PASCAL FdiUnloadFontFile( HFD hFD, HFF hFF )
{NotifyNoSuport();return -1L;}

LONG FAR PASCAL FdiQueryFaces( HFD hFD, HFF hFF, LPIFIMETRICS lpIfiMetrics, ULONG cMetricLen, ULONG cFontCount, ULONG cStart )
{NotifyNoSuport();return 0;}
HFC FAR PASCAL FdiOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiCloseFontContext( HFD hFD, HFC hFC )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiSetFontContext( HFD hFD, HFC hFC, LPCONTEXTINFO lpContextInfo )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiQueryFaceAttr( HFD hFD, HFC hFC, ULONG iQuery, LPVOID lpBuffer, ULONG cb, LPVOID lpIndex, SHORT Start )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL FdiQueryCharAttr( HFD hFD, HFC hFC, LPCHARATTR lpCharAttr, LPBITMAPMETRICS lpbmm )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FdiControl( HFD hFD, HFC hFC, LPCONTROLTAG lpControlTag, LPVOID lpOutData )
{NotifyNoSuport();return 0;}



HFD FAR PASCAL MimAddFontDriver( LPSTR lpszFileName )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MimRemoveFontDriver( HFD hFD )
{NotifyNoSuport();return 0;}

BOOL NEAR PASCAL RealRemoveFontDriver( HFD hFD )
{NotifyNoSuport();return 0;}

HFF FAR PASCAL MimAddFontPack( HFD hFD, LPSTR lpszPackName )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MimRemoveFontPack( HFD hFD, HFF hFontPack )
{NotifyNoSuport();return 0;}

HFD FAR PASCAL MimEnumFontDrivers( HFD hLastDriver )
{NotifyNoSuport();return 0;}

HFF FAR PASCAL MimEnumFontPacks( HFD hFD, HFF hLastPack )
{NotifyNoSuport();return 0;}

HFC FAR PASCAL MimOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont )
{NotifyNoSuport();return 0;}

LONG FAR PASCAL MimCloseFontContext( HFD hFD, HFF hFF, HFC hFC )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL MimGetInformations( MIMGETINFO_ORDER order, HFD hFD, HFF hFF, LPVOID AnswerBuffer, USHORT SizeOfBuffer )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL MiscSetErroInfo( ULONG ErrorCode )
{NotifyNoSuport();return ;}

ULONG FAR PASCAL MiscGetErroInfo( VOID )
{
        return( 0L );
}






/**************************Public*Routine*******************************\
* SHORT FAR PASCAL MiscWarningMessage(
*       HANDLE hInst,
*       USHORT idsMsg,
*       USHORT idsTitle,
*       USHORT mode
* )
*
* read string from resource and show it by message box
*
* Effects:
*
* Warnings:
*  This function is available after delayed init.
*
* History:
*     04-Sep-1990 12:00:00  -by-    Akira Kawamata [akirak]
* Creation
\***********************************************************************/

char szTitle[256];
char szMsg[256];
char szNewMsg[256];

SHORT FAR PASCAL MiscWarningMessage(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        USHORT mode
)
{
        HANDLE hUser;
        LPLOADSTRING lpLoadString;
        SHORT result;
        SHORT nLength;

        /* get instance of user.exe */
        hUser = GetModuleHandle("USER.EXE");
        if( hUser == NULL ) return(IDCANCEL);

        /* get procedure instance of LoadString */
        lpLoadString = (LPLOADSTRING)GetProcAddress( hUser, MAKEINTRESOURCE(176) );
        if( lpLoadString == NULL ) return(IDCANCEL);

        /* load message string */
        nLength = (*lpLoadString)( hInst, idsMsg, szMsg, sizeof(szMsg) );
        if( nLength == sizeof(szMsg) ){
                szMsg[sizeof(szMsg)-1] = '\0';
        }

        /* load title string */
        nLength = (*lpLoadString)( hInst, idsTitle, szTitle, sizeof(szTitle) );
        if( nLength == sizeof(szTitle) ){
                szMsg[sizeof(szTitle)-1] = '\0';
        }

        result = InternalWarningMessageByString(
                NULL,   /* no current window handle */
                szMsg,
                szTitle,
                mode
        );

        return( result );
}


/**************************Public*Routine*******************************\
* SHORT FAR PASCAL MiscWarningMessageWithArgument(
*       HANDLE hInst,
*       USHORT idsMsg,
*       USHORT idsTitle,
*       LPSTR lpszArgument
*       USHORT mode
* )
*
* read string from resource and conbine argument,
* then show it by message box
*
* Effects:
*
* Warnings:
*  This function is available after delayed init.
*  idsMsg must include only one "%s". if it's not "%s" or many % is appear,
* this function wouldn't work right.
*
* History:
*     04-Sep-1990 12:00:00  -by-    Akira Kawamata [akirak]
* Creation
\***********************************************************************/

SHORT FAR PASCAL MiscWarningMessageWithArgument(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        LPSTR lpszArgument,
        USHORT mode
)
{
        HANDLE hUser;
        LPLOADSTRING lpLoadString;
        LPWSPRINTF lpwsprintf;
        SHORT result;
        SHORT nLength;

        /* get instance of user.exe */
        hUser = GetModuleHandle("USER.EXE");
        if( hUser == NULL ) return(IDCANCEL);

        /* get procedure instance of LoadString */
        lpLoadString = (LPLOADSTRING)GetProcAddress( hUser, MAKEINTRESOURCE(176) );
        if( lpLoadString == NULL ) return(IDCANCEL);

        /* get procedure instance of wsprintf */
        lpwsprintf = (LPWSPRINTF)GetProcAddress( hUser, MAKEINTRESOURCE(420) );
        if( lpwsprintf == NULL ) return(IDCANCEL);

        /* load message string */
        nLength = (*lpLoadString)( hInst, idsMsg, szMsg, sizeof(szMsg) );
        if( nLength == sizeof(szMsg) ){
                szMsg[sizeof(szMsg)-1] = '\0';
        }

        /* load title string */
        nLength = (*lpLoadString)( hInst, idsTitle, szTitle, sizeof(szTitle) );
        if( nLength == sizeof(szTitle) ){
                szMsg[sizeof(szTitle)-1] = '\0';
        }

        (*lpwsprintf)(szNewMsg, szMsg, lpszArgument );

        result = InternalWarningMessageByString(
                NULL,   /* no current window handle */
                szNewMsg,
                szTitle,
                mode
        );

        return( result );
}






VOID FAR PASCAL MiscTrancateString(
        LPSTR lpszStr,
        SHORT length,
        SHORT CharSet
)
{NotifyNoSuport();return ;}

USHORT FAR PASCAL ubstrlen( LPUBCHAR cp )
{NotifyNoSuport();return 0;}

LPUBCHAR FAR PASCAL ubstrcpy( LPUBCHAR dst, LPUBCHAR src )
{NotifyNoSuport();return 0;}

LPUBCHAR FAR PASCAL ubstrncpy( LPUBCHAR dst, LPUBCHAR src, USHORT limit )
{NotifyNoSuport();return 0;}

LPUBCHAR FAR PASCAL ubstrcat( LPUBCHAR dst, LPUBCHAR src )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL ubstrcmp( LPUBCHAR str1, LPUBCHAR str2 )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL AscizToUz(
        LPUBCHAR dst,
        LPSTR src,
        USHORT limit,
        CHAR_SET CharSet
)
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL UzToAsciz(
        LPSTR dst,
        LPUBCHAR src,
        USHORT limit
)
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmCalcByteWidth( SHORT nBitWidth )
{NotifyNoSuport();return 0;}


HFB FAR PASCAL FcmEnumFontBuffers( HFB hLastBuffer )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmValidateFC( HFB hFB )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmUnvalidateFC( HFB hFB )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmCreateCacheBuffer(
        HFD hFD,
        HFF hFF,
        ULONG ulFont,
        LPVOID lpXform,
        USHORT usMinorCharSet,
        USHORT usAttribute
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmDeleteCacheBuffer( HFB hFB )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmForceCacheIn( HFB hFB, LPUBCHAR lpubStr )
{NotifyNoSuport();return 0;}

HFC FAR PASCAL FcmGetFontContext( HFB hFB )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL FcmGetEUDCLeadByteRange( HFB hFB )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmGetEUDCFB( HFB hFB )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL MapWifeFont(
LPLOGFONT lpLogFont,
LPVOID lpMapResult)
{NotifyNoSuport();return ;}

WORD FAR PASCAL MiscRealizeWifeFont(
LPLOGFONT lpLogFont,
LPVOID lpExtFont,
LPVOID lpTextXform)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscDeleteWifeFont( LPVOID lpExtFont)
{NotifyNoSuport();return 0;}

VOID FAR PASCAL FillFontInfo(
        LPVOID lpExtFont,
        LPIFIMETRICS lpIFIMetrics,
        HFD hFD,
        HFF hFF,
        LONG MetricsOrder
)
{NotifyNoSuport();return ;}

SHORT FAR PASCAL FcmRequestImages(
       HFB hFB,
       LPVOID AnswerBuffer,
       short length

)
{NotifyNoSuport();return 0;}



BOOL FAR PASCAL FcmReleaseImages(
       HFB hFB,
       LPVOID AnswerBuffer,
       short length
)
{NotifyNoSuport();return 0;}

LPVOID FAR PASCAL MiscAddHugePtr( LPVOID src, ULONG offset )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL MiscGetSegmentIncrement( VOID )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmRequestDefaultFB(
        LPVOID lpFont,
        LPVOID lpTextXform
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FcmReleaseDefaultFB( HFB hFB )
{NotifyNoSuport();return 0;}

DWORD FAR PASCAL FcmCalculateTextExtent(
        HFB         hFB,
        LPSTR       lpString,
        short       count,
        LPVOID      lpFont,
        LPVOID      lpvoid,
        LPVOID      lpXform,
        LPSHORT     lpCharWidths,
        USHORT      usMode
)
{NotifyNoSuport();return 0;}


SHORT FAR PASCAL FcmCalculateOutputPositions(
        HFB             hFB,
        LPVOID lpFcmCharacteristics,
        SHORT           nArrayLength,
        LPSHORT         lpx,
        LPSHORT         lpy,
        LPRECT          lpClipRect,
        LPSTR           FAR * lplpString,
        LPSHORT         lpcount,
        LPVOID      lpFont,
        LPVOID      lpDrawMode,
        LPVOID     lpXform,
        LPSHORT         FAR * lplpCharWidths,
        USHORT          usMode
)
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmCleanUp( VOID )
{NotifyNoSuport();return 0;}

BYTE FAR PASCAL MiscConvertFontFamily( LPSTR szFamilyName )
{NotifyNoSuport();return 0;}

BYTE FAR PASCAL MiscConvertCharSet( LPSTR CharSetString )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL MiscIfiMetricsToLogFont(
        LPLOGFONT lpLogFont,
        LPIFIMETRICS lpIFIMetrics,
        USHORT usLogicalMapFlag
)
{NotifyNoSuport();return ;}

VOID FAR PASCAL MiscIfiMetricsToTextMetrics(
        LPTEXTMETRIC lpTextMetrics,
        LPIFIMETRICS lpIFIMetrics
)
{NotifyNoSuport();return ;}

VOID FAR PASCAL MiscMakeTextXform(
        LPVOID lpTXF,
        LPIFIMETRICS lpIM,
        LPLOGFONT lpLF
)
{NotifyNoSuport();return ;}

LONG FAR PASCAL FcmQueryFaceAttr(
        HFB         hFB,
        ULONG       iQuery,
        LPABC_TRIPLETS  lpBuffer,
        ULONG       cb,
        LPUBCHAR    lpIndex,
        UBCHAR      Start
)
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL FcmProcessDeviceControl(
        HFB hFB,
        SHORT nFunction,
        LPVOID lpGI,
        LPVOID lpOutData
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL
MiscIsWifeControl( SHORT function )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscIsGaijiControl( SHORT function )
{NotifyNoSuport();return 0;}

USHORT FAR PASCAL FcmGetCharWidth(
        WORD   hFB_,
        DWORD   lpBuffer_,
        WORD   wFirstChar_,
        WORD   wLastChar_,
        DWORD   lpFont_,
        DWORD   lpDrawMode_,
        DWORD   lpFontTrans_,
        WORD   usExpandPixels_,
        WORD   usMode_
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscStretchMonoFontImage(
        LPVOID  lpDestImage,
        USHORT  usSizeOfDestX,
        USHORT  usSizeOfDestY,
        LPVOID  lpSrcImage,
        USHORT  usSizeOfSrcX,
        USHORT  usSizeOfSrcY
)
{NotifyNoSuport();return 0;}

LP_QUICK_SEARCH_TABLE FAR PASCAL MiscValidateQuickSearchTable(
        USHORT usLogicalMapFlag
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscUnvalidateQuickSearchTable(
        USHORT usLogicalMapFlag
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscRegisterNotifyFunction(
        LPVOID lpfnCallBack
)
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL MiscUnregisterNotifyFunction( LPVOID lpfnCallBack )
{NotifyNoSuport();return 0;}

HFB FAR PASCAL FcmRequestDefaultFBEx( LPVOID lpFont, LPVOID lpTextXform, WORD wControlFlag )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL SetCloseOldestFCFunc(LPVOID lpfnCallbackFunc)
{NotifyNoSuport();return ;}


HFC FAR PASCAL CachedOpenFontContext(
HFD hFD,
HFF hFF,
ULONG ulFont,
LPCONTEXTINFO lpContextInfo,
SHORT sMinorCharSet,
SHORT sAttribute
)
{NotifyNoSuport();return 0;}



SHORT FAR PASCAL FillContextInfo(
unsigned short ftHeight,
unsigned short ftWidth,
LPIFIMETRICS lpIfiMetrics,
HFD hFD,
LPCONTEXTINFO lpContextInfo,
LPCONTEXTINFO lpContextInfoEUDC,
LPVOID lpEUDCContext,
BOOL FAR *lpbSelfMode
)
{NotifyNoSuport();return 0;}

VOID FAR PASCAL GetEUDCFD( HFD FAR *lphFD, HFF FAR *lphFF )
{NotifyNoSuport();return ;}

VOID FAR PASCAL GetDefaultFontInfo( LPVOID lpInfo )
{NotifyNoSuport();return ;}

LPVOID FAR PASCAL DiagLocalLockAnything( LOCALHANDLE hAny )
{NotifyNoSuport();return 0;}

LPVOID FAR PASCAL DiagLocalUnlockAnything( LOCALHANDLE hAny )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL DiagGetConfirmString( LPSTR buffer, SHORT length )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL DiagSelfCheck( VOID )
{NotifyNoSuport();return 0;}

SHORT FAR PASCAL DiagSelfCheckAndWarning( VOID )
{NotifyNoSuport();return 0;}

VOID FAR PASCAL DebugAssertion( VOID )
{NotifyNoSuport();return ;}

BOOL FAR PASCAL DelayedInit( VOID )
{NotifyNoSuport();return 0;}

BOOL FAR PASCAL FirstInit( VOID )
{NotifyNoSuport();return 0;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\wifethk.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1994, Microsoft Corporation
;
;   USER.ASM
;   Win16 WINNLS thunks
;
;   History:
;
;   Created 17-May-1994 by hiroh
;--

	TITLE	WIFEMAN.ASM
	PAGE	,132

	.286p

	.xlist
	include wow.inc
	include wowwife.inc
	include cmacros.inc
	.list

	__acrtused = 0
	public	__acrtused	;satisfy external C ref.

externFP    WOW16Call
externA  __MOD_WIFEMAN

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp	    DGROUP,DATA


sBegin	DATA
Reserved    db	16 dup (0)	;reserved for Windows

sEnd	DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

	WifeManThunk  MISCGETEUDCLEADBYTERANGE

sEnd	CODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\wife.h ===
/****************************************************************************\
*
* WIFE.H : East Asia Windows Intelligent Font Environment definitions
*
******************************************************************************
*
* History:
* 21-Oct-1991   bent
*               initial merge of East Asia 3.0 versions
*               Should be updated to resolve local inconsistencies.
*
* Copyright (c) 1990  Microsoft Corporation
*
* Brief instruction
* -----------------
*
*   This header file is a common single header for WIFE drivers.                                                                                    *
*   If you are a developer of FontDriver, please write coding as follow                                                                             *
*
*   #define WIFE_CREATE_FONTDRIVER                                                                                                                    *
*   #include <wife.h>                                                                                                                                 *
*
*   If you are a developer of DeviceDriver which are display or printer
*   drivers, please write coding as follow.                                                                                                                   *
*
*   #define WIFE_CREATE_DEVICEDRIVER                                                                                                                  *
*   #include <wife.h>                                                                                                                                 *
*
*   If you don't define both of symbols, only common defenitions are
*   available.
*
*   Aug.17,1990 Akira Kawamata [AkiraK]                                                                              *
*
\****************************************************************************/

/****** OS/2-like common data type definitions ******************************/

#ifndef WIFEH_NODATATYPES
typedef unsigned short int USHORT;
typedef short int          SHORT;
typedef unsigned long      ULONG;
typedef LONG FAR *         LPLONG;
typedef LONG NEAR *        NPLONG;
typedef ULONG FAR *        LPULONG;
typedef ULONG NEAR *       NPULONG;
typedef SHORT FAR *        LPSHORT;
typedef SHORT NEAR *       NPSHORT;
typedef USHORT FAR *       LPUSHORT;
typedef USHORT NEAR *      NPUSHORT;
typedef char               CHAR;
typedef unsigned char      UCHAR;

typedef VOID NEAR *        NPVOID;

#endif //WIFEH_NODATATYPES

/****** Graphics handling support definitions *******************************/

#ifndef WIFEH_NOGRAPHSUPPORT
/* rotation angle by 90degree */
typedef enum {
        ANGLE000 = 0,
        ANGLE090 = 1,
        ANGLE180 = 2,
        ANGLE270 = 3
} QUOTER_ANGLE;
#define FixedToQuoterAngle(f) ((f.Integer/90)%4)
#define RotationToQuoterAngle(r) ((r/900)%4)

typedef DWORD PACKEDPOINT;
typedef DWORD PACKEDLOGICALPOINT;
typedef DWORD PACKEDPHYSICALPOINT;
typedef struct {
        short x,y;
} XYPOINT;
typedef union {
        PACKEDPOINT packed;
        XYPOINT point;
} UNIONPOINT, NEAR * NPUNIONPOINT, FAR * LPUNIONPOINT;

#define PartOfX(xy)     ((SHORT)(xy))
#define PartOfY(xy)     ((SHORT)(((DWORD)(xy) >> 16) & 0xFFFF))
#define MAKELONG_LO_HI MAKELONG
#define PackXY(x,y)     ((DWORD)MAKELONG_LO_HI((WORD)x,(WORD)y))
#endif //WIFEH_NOGRAPHSUPPORT

/****** UBCS : Unified Byte Character Set, data types defenition  **********/

#ifndef WIFEH_NOUBCS
typedef USHORT UBCHAR;
typedef UBCHAR NEAR * NPUBCHAR;
typedef UBCHAR FAR * LPUBCHAR;

#define UBEOS (0)               /* End Of String */
#define UBNEWLINE (0x0a0d)      /* New Line (CR/LF) */

#define IsSbcsUBChar(uc) ((uc & 0xff00) == 0x2000)
#define IsDbcsUBChar(uc) ((uc & 0xff00) != 0x2000)
#endif //WIFEH_NOUBCS

/****** Utility macros *****************************************************/

#ifndef WIFEH_NOUTILITYMACROS
/* return type of GlobalLock is LPSTR, but it's to be LPVOID */
#define AnyGlobalLock(h) ((LPVOID)GlobalLock(h))
#define AnyLocalLock(h) ((NPVOID)LocalLock(h))
#define TypedLocalLock(h,t) ((t NEAR *)LocalLock(h))
#define TypedGlobalLock(h,t) ((t FAR *)GlobalLock(h))

/* utility macro which is not included windows.h */
#define MAKEWORD(l,h) ((WORD)((BYTE)l+(((BYTE)h) << 8)))
#endif //WIFEH_NOUTILITYMACROS

/****** GDIDEFS.H support definitions **************************************/

#ifdef WIFE_ENABLE_GDIDEFS_SUPPORT
typedef FONTINFO FAR * LPFONTINFO;
typedef DRAWMODE FAR * LPDRAWMODE;
typedef TEXTXFORM FAR * LPTEXTXFORM;
#endif //WIFE_ENABLE_GDIDEFS_SUPPORT

/****** Character set definitions ******************************************/

#ifndef WIFEH_NOCHARSET
typedef enum {
        CHARSET_ANSI = 0,
        CHARSET_SYMBOL = 2,
        CHARSET_SHIFTJIS = 128,
        CHARSET_KOREA = 129,
        CHARSET_CHINESEBIG5 = 136,
	CHARSET_GB2312 = 134,
        CHARSET_OEM = 255
} CHAR_SET;
#endif //WIFEH_NOCHARSET


/***************************************************************************/
/****** Control function support definitions  ******************************/

#ifndef WIFEH_NOCONTROL

/******************************************/
/*      FONT DRIVER MEDIA DESCRIPTER      */
/******************************************/
#ifndef WIFEWH_NOMEDIA
/* FDMEDIA enumration type */
typedef enum {
        FDMEDIA_ON_FILE = 1,
        FDMEDIA_ON_DRIVER = 2,
        FDMEDIA_ON_REMOVEABLE_HARDWARE = 4,
        FDMEDIA_ON_FIXED_HARDWARE = 8,
        FDMEDIA_UNDEFINED = 0x4000,
        FDMEDIA_ANY_MEDIA = 0x7fff
} FDMEDIA;
#endif


/******************************************/
/*    MINOR CHARACTER SETS DEFENITION     */
/******************************************/
#ifndef WIFEH_NOMINORCHARSET_IN_JAPAN

/* general default minor character set */
#define FD_MINOR_CHARSET_DEFAULT 1

/* Minor Character Set in Japan */
#define FD_MINOR_CHARSET_NEW_JIS 1      /* new JIS */
#define FD_MINOR_CHARSET_OLD_JIS 2      /* old JIS */
#define FD_MINOR_CHARSET_IBM_JIS 4      /* IBM JIS */
#define FD_MINOR_CHARSET_NEC_JIS 8      /* NEC JIS */

#endif

/******************************************/
/*        CODE AREA STRUCTURE             */
/******************************************/
#ifndef WIFEH_NOCODEAREA

typedef struct {
        UBCHAR CodeFrom;
        UBCHAR CodeTo;
} CODEAREA, NEAR * NPCODEAREA, FAR * LPCODEAREA;

#endif

/******************************************/
/*    SPECIAL ESCAPE FUNCTION ORDERS      */
/******************************************/

/* subfunction orders in WIFE */
#define FD_CONTROL_RESERVED             (0xa20)
#define FD_CONTROL_RESERVED_LIMIT       (FD_CONTROL_RESERVED+0x3f)

/* standard subfunctions */
#define FD_CONTROL_QUERY_ESC_SUPPORT    (FD_CONTROL_RESERVED+0)
#define FD_CONTROL_SUPPORT_CODES        (FD_CONTROL_RESERVED+1)
#define FD_CONTROL_NUMBER_OF_ATTRIBUTE  (FD_CONTROL_RESERVED+2)
#define FD_CONTROL_NAME_OF_ATTRIBUTE    (FD_CONTROL_RESERVED+3)
#define FD_CONTROL_SET_ATTRIBUTE        (FD_CONTROL_RESERVED+4)
#define FD_CONTROL_GET_ATTRIBUTE        (FD_CONTROL_RESERVED+5)
#define FD_CONTROL_SET_MINOR_CHARSET    (FD_CONTROL_RESERVED+6)
#define FD_CONTROL_GET_MINOR_CHARSET    (FD_CONTROL_RESERVED+7)
#define FD_CONTROL_GET_FONT_DRIVER_NAME (FD_CONTROL_RESERVED+8)
#define FD_CONTROL_GET_FONT_PACK_NAME   (FD_CONTROL_RESERVED+9)
#define FD_CONTROL_GET_MEDIA            (FD_CONTROL_RESERVED+10)
#define FD_CONTROL_GET_DBCS_STRING_KERN (FD_CONTROL_RESERVED+11)

#if defined(TAIWAN) || defined(PRC)
/* Chinese related functions */
#define FD_CONTROL_GET_USERFONT_TECH    (FD_CONTROL_RESERVED+0X0C)
#define FD_CONTROL_SET_USERFONT         (FD_CONTROL_RESERVED+0X0D)
#define FD_CONTROL_SETUP_DIALOG         (FD_CONTROL_RESERVED+0X0E)
#define FD_CONTROL_SET_DEFAULT_CHAR     (FD_CONTROL_RESERVED+0X0F)

/* private interface subfunctions */
#define FD_CONTROL_USER                 (FD_CONTROL_RESERVED+0x10)
#define FD_CONTROL_USER_LIMIT           (FD_CONTROL_RESERVED_LIMIT)

/* EUDC related subfunctions */
#define FD_CONTROL_LEVEL2_EUDC_INFO     (FD_CONTROL_RESERVED+0X12)
#else
/* EUDC related subfunctions */
#define FD_CONTROL_LEVEL2_EUDC_INFO     (FD_CONTROL_RESERVED+12)

/* private interface subfunctions */
#define FD_CONTROL_USER                 (FD_CONTROL_RESERVED+0x10)
#define FD_CONTROL_USER_LIMIT           (FD_CONTROL_RESERVED+0x1f)

/* Chinese related functions */
#define FD_CONTROL_GET_USERFONT_TECH    (FD_CONTROL_RESERVED+0x20)
#define FD_CONTROL_SET_USERFONT         (FD_CONTROL_RESERVED+0x21)
#define FD_CONTROL_SETUP_DIALOG         (FD_CONTROL_RESERVED+0x22)
#define FD_CONTROL_SET_DEFAULT_CHAR     (FD_CONTROL_RESERVED+0x23)
#endif
#if defined(TAIWAN)  || defined(PRC)
// we add this line for the FDCONTROL constant has get the limit
#define FD_CONTROL_CHINESE_RESERVED     FD_CONTROL_RESERVED+0x30
#endif  // TAIWAN

#ifdef WIFE_ENABLE_EUDC_SUPPORT

typedef struct {
        ULONG   cb;             /* length of this structure */
        BOOL    bForceFixedPitch;       /* force fixed pitch */
        BOOL    bVerticalFont;  /* vertical font flag */
        FIXED   fxCharRot;      /* character rotation */
        FIXED   fxInlineDir;    /* inline rotation */
        USHORT  usLimitWidth;   /* maximum width of cachable */
        SHORT   sFixedASpace;   /* font width when bForceFixedPitch is TRUE */
        USHORT  usFixedBSpace;  /* font width when bForceFixedPitch is TRUE */
        SHORT   sFixedCSpace;   /* font width when bForceFixedPitch is TRUE */
} EUDC_CONTEXT, NEAR * NPEUDC_CONTEXT, FAR * LPEUDC_CONTEXT;

#endif

#endif

#if defined(TAIWAN) || defined(PRC)
typedef struct {
HWND hWnd;
HANDLE hInst;
} CALLINGINFO, FAR *LPCALLINGINFO;
#endif  // TAIWAN

#ifndef WIFEH_NOFDCOMMONDEFENITION
typedef LONG HFF;
typedef LONG HFC;
typedef HANDLE HFD;
typedef HANDLE HFB;

#define FACESIZE 32
#define GLYPHNAMESIZE 16

#define WIFEERR_FACENAME_NOT_FOUND        23004L
#define WIFEERR_FD_ALREADY_INSTALLED      23005L
#define WIFEERR_INVALID_CONTEXTINFO       23006L
#define WIFEERR_NOT_A_FONT_FILE           23007L
#define WIFEERR_INVALID_FONT_SELECTION    23008L
#define WIFEERR_INVALID_FORMAT            23009L
#define WIFEERR_BUSY_HFC                  230010L
#define WIFEERR_INVALID_HFC               230011L
#define WIFEERR_INVALID_INDEX             230012L
#define WIFEERR_INVALID_QUERY_TYPE        230013L
#define WIFEERR_CONTEXT_NOT_SET           230014L

#define FD_QUERY_ABC_WIDTHS     2L
#define FD_QUERY_KERNINGPAIRS   3L

#define FD_QUERY_CHARIMAGE      1L
#define FD_QUERY_OUTLINE        2L
#define FD_QUERY_BITMAPMETRICS  4L

typedef UBCHAR GLYPH; /* gi */
typedef LPUBCHAR LPGLYPH; /* lpgi */


typedef struct _ABC_TRIPLETS { /* abc, npabc, lpabc */
        SHORT  sA;
        USHORT usB;
        SHORT  sC;
} ABC_TRIPLETS, NEAR * NPABC_TRIPLETS, FAR * LPABC_TRIPLETS;

typedef struct _SIZEL { /* sizl */
        ULONG cx; // Width.
        ULONG cy; // Height.
} SIZEL;

typedef struct _BITMAPMETRICS { /* bmm, npbmm, lpbmm */
        SIZEL     sizlExtent;
        POINTFX   pfxOrigin;    /* Return character origin. */
        POINTFX   pfxCharInc;   /* Return the device advance width */
} BITMAPMETRICS, NEAR * NPBITMAPMETRICS, FAR * LPBITMAPMETRICS;


typedef struct _FD_KERNINGPAIRS  { /* krnpr, npkrnpr, lpkrnpr */
        GLYPH     giFirst;
        GLYPH     giSecond;
        LONG      eKerningAmount;
} FD_KERNINGPAIRS, NEAR * NPFD_KERNINGPAIRS, FAR * LPFD_KERNINGPAIRS;


typedef struct _CONTEXTINFO  { /* ci */
        ULONG     cb;        /* Length in bytes of this structure. */
        ULONG     fl;        /* Flags. */
        SIZEL     sizlPPM;    /* Device resolution in pels/meter. */
        POINTFX   pfxSpot;   /* Spot size in pels. */
        MAT2      matXform;  /* Notional to Device transform. */
} CONTEXTINFO, NEAR * NPCONTEXTINFO, FAR * LPCONTEXTINFO;


typedef struct _CHARATTR  { /* chattr */
        ULONG     cb;
        ULONG     iQuery;   /* Query type. */
        GLYPH     gi;       /* Glyph index in font. */
        LPBYTE    lpBuffer;  /* Bitmap buffer. */
        ULONG     cbLen;    /* Size of buffer in bytes. */
} CHARATTR, NEAR * NPCHARATTR, FAR * LPCHARATTR;


/* bit-constants for fsType in IFIMETRICS  */

#define IFIMETRICS_FIXED       0x0001   /* Fixed pitch */
#define IFIMETRICS_LICENSED    0x0002   /* dummy defenition */
#define IFIMETRICS_SPARSE      0x0004   /* Incomplete font */
#define IFIMETRICS_SCALEABLE   0x8000   /* scalable font */

/* bit-constant for fsDefn in IFIMETRICS   */

#define IFIMETRICS_OUTLINE     0x0001   /* dummy definition */
                                        /* 1 - Outline. 0 - Raster */

/* bit-constant for fsSelection in IFIMETRICS */

#define IFIMETRICS_ITALIC      0x8000  /*Italic */
#define IFIMETRICS_UNDERSCORE  0x4000  /*Underscored */
#define IFIMETRICS_OVERSTRUCK  0x2000  /*Overstruck */

/* bit-constant for fsSelection in IFIMETRICS valid for bitmap fonts */

#define IFIMETRICS_NEGATIVE    0x1000   /*Negative image */
#define IFIMETRICS_HOLLOW      0x0800   /*Outline (hollow) */


typedef struct _IFIMETRICS {   /* ifim */
                                                                    /* UNITS */
  UCHAR   szFamilyname[FACESIZE];   /*Font Family Name, e.g. Roman */
  UCHAR   szFacename[FACESIZE];     /*Face name, e.g. Tms Rmn Bold Italic */
  UCHAR   szGlyphlistName[GLYPHNAMESIZE]; /*e.g. PM316, Latin-2, Greek */
  USHORT  idRegistry;          /*Dummy                                     I */
  SHORT   sCapEmHeight;        /*Height of uppercase M                     N */
  SHORT   sXHeight;            /*Nominal height of lowercase               N */
  SHORT   sMaxAscender;        /*Maximum height above baseline of any char N */
  SHORT   sMaxDescender;       /*Maximum depth below baseline of any char  N */
  SHORT   sLowerCaseAscent;    /*Maximum height above baseline of any a-z  N */
  SHORT   sLowerCaseDescent;   /*Maximum depth below basiline of any a-z   N */
  SHORT   sInternalLeading;    /*White space within character              N */
  SHORT   sExternalLeading;    /*White space between lines                 N */
  SHORT   sAveCharWidth;       /*Weighted average character width          N */
  SHORT   sMaxCharInc;         /*Maximum character increment               N */
  SHORT   sEmInc;              /*Increment for Capitals (typically 'M')    N */
  SHORT   sMaxBaselineExt;     /*Height of character cell                  N */
  FIXED   fxCharSlope;         /*Slope angle, degrees, clockwise           D */
  FIXED   fxInlineDir;         /*Drawing direction, degrees clockwise      D */
  FIXED   fxCharRot;           /*Glyph rotation in cell, degrees clockwise D */
  USHORT  usWeightClass;       /*Character weight, 1-9 (1=ultra-light)     I */
  USHORT  usWidthClass;        /*Character width, 1-9 (1=ultra condensed)  I */
  SHORT   sEmSquareSize;       /*Em Square size, x-direction               N */
  GLYPH   giFirstChar;         /*Number of first glyph in font             I */
  GLYPH   giLastChar;          /*Number of last glyph in font              I */
  GLYPH   giDefaultChar;       /*Glyph used if requested glyph invalid     I */
  GLYPH   giBreakChar;         /*Space glyph                               I */
  ULONG   aulPanose [1];       /*Panose Number */
  USHORT  usNominalPointSize;  /*Point size for which font was designed    N */
  USHORT  usMinimumPointSize;  /*Minimum point size scaling for font       N */
  USHORT  usMaximumPointSize;  /*Maximum point size scaling for font       N */
  USHORT  fsType;              /*Type indicators  (see #defines)           B */
  USHORT  fsDefn;              /*Font definition data (see #defines)       B */
  USHORT  fsSelection;         /*Font selection flags (see #defines)       B */
  USHORT  fsCapabilities;      /*Font capabilities must be 0               B */
  SHORT   sSubscriptXSize;     /*Size in x-direction of subscript          N */
  SHORT   sSubscriptYSize;     /*Size in y-direction of subscript          N */
  SHORT   sSubscriptXOffset;   /*Offset in x-direction of subscript        N */
  SHORT   sSubscriptYOffset;   /*Offset in y-direction of subscript        N */
  SHORT   sSuperscriptXSize;   /*Size in x-direction of superscript        N */
  SHORT   sSuperscriptYSize;   /*Size in y-direction of superscript        N */
  SHORT   sSuperscriptXOffset; /*Offset in x-direction of superscript      N */
  SHORT   sSuperscriptYOffset; /*Offset in y-direction of superscript      N */
  SHORT   sUnderscoreSize;     /*Underscore size                           N */
  SHORT   sUnderscorePosition; /*Underscore position                       N */
  SHORT   sStrikeoutSize;      /*Strikeout size                            N */
  SHORT   sStrikeoutPosition;  /*Strikeout position                        N */
  SHORT   cKerningPairs;       /*Number of kerning pairs in pair table     I */
  ULONG   ulFontClass;         /*IBM font classification                   B */
} IFIMETRICS, NEAR * NPIFIMETRICS, FAR * LPIFIMETRICS;

#ifdef ENABLE_CONTROL_TAG

/* Tag structure for Fd(i)Control */
typedef struct {
        USHORT SubFunction;
        LPDEVICE lpDevice;
        LPFONTINFO lpFontStructure;
        LPTEXTXFORM lpXform;
        LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#else
typedef struct {
        USHORT SubFunction;
        LPVOID lpDevice;
        LPVOID lpFontStructure;
        LPVOID lpXform;
        LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#endif

#endif


/****************************************/
/* Attribute bits for FdOpenFontContext */
/****************************************/
#ifndef WIFEH_NOWIFEMAN_EUDCFONTCONTEXT
#define OFC_EUDC_CONTEXT (0x80000000L)
#endif


#ifdef WIFE_CREATE_FONTDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in FONT DRIVER */
/***********************************************/

LONG FAR PASCAL FdClaimFontFile( LPSTR lpszFileName );

LONG FAR PASCAL FdConvertFontFile(
        LPSTR lpszSrcFileName,
        LPSTR lpszDestDirName,
        LPSTR lpszResultPackName
);
HFF FAR PASCAL FdLoadFontFile( LPSTR lpszPackName );

LONG FAR PASCAL FdUnloadFontFile( HFF hFF );

LONG FAR PASCAL FdQueryFaces(
        HFF hFF,
        LPIFIMETRICS lpIfiMetrics,
        ULONG cMetricLen,
        ULONG cFontCount,
        ULONG cStart
);

HFC FAR PASCAL FdOpenFontContext( HFF hFF, ULONG ulFont );

LONG FAR PASCAL FdSetFontContext(
        HFC hFC,
        LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdCloseFontContext( HFC hFC );

LONG FAR PASCAL FdQueryFaceAttr(
        HFC       hFC,
        ULONG     iQuery,
        LPVOID    lpBuffer,
        ULONG     cb,
        LPVOID    lpIndex,
        SHORT     Start
);

LONG FAR PASCAL FdQueryCharAttr(
        HFC        hFC,
        LPCHARATTR lpCharAttr,
        LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdControl(
        HFC hFC,
        LPCONTROLTAG lpControlTag,
        LPVOID lpOutData
);


/******************************************/
/*       FAR PTR TO EACH FUNCTION         */
/******************************************/
typedef LONG (FAR PASCAL * LPFDCLF)( LPSTR lpszFileName );

typedef LONG (FAR PASCAL * LPFDCFF)(
        LPSTR lpszSrcFileName,
        LPSTR lpszDestDirName,
        LPSTR lpszResultPackName
);

typedef HFF (FAR PASCAL * LPFDLFF)( LPSTR lpszPackName );

typedef LONG (FAR PASCAL * LPFDQF)(
        HFF hFF,
        LPIFIMETRICS lpIfiMetrics,
        ULONG cMetricLen,
        ULONG cFontCount,
        ULONG cStart
);

typedef LONG (FAR PASCAL * LPFDUFF)( HFF hFF );

typedef HFC (FAR PASCAL * LPFDOFC)( HFF hFF, ULONG ulFont );

typedef LONG (FAR PASCAL * LPFDSFC)(
        HFC hFC,
        LPCONTEXTINFO lpContextInfo
);

typedef LONG (FAR PASCAL * LPFDCFC)( HFC hFC );

typedef LONG (FAR PASCAL * LPFDQFA)(
        HFC       hFC,
        ULONG     iQuery,
        LPVOID    lpBuffer,
        ULONG     cb,
        LPVOID    lpIndex,
        SHORT     Start
);

typedef LONG (FAR PASCAL * LPFDQCA)(
        HFC        hFC,
        LPCHARATTR lpCharAttr,
        LPBITMAPMETRICS lpbmm
);

typedef SHORT (FAR PASCAL * LPFDCTL)(
        HFC hFC,
        LPCONTROLTAG lpControlTag,
        LPVOID lpOutData
);

typedef struct _FDHEADER { /* fdhdr */
        ULONG   cbLength;            /* Length of FDHEADER */
        UCHAR   strId[16];           /* String 'WIFE FONT DRIVER' */
        UCHAR   szTechnology[40];    /* Identifier of Font Driver technology */
        ULONG   ulVersion;           /* IFI version number (0x0100) */
        ULONG   ufDeviceCaps;        /* Capabilities of device */
        NPVOID  npfddisp;
        SHORT   dummy1;
} FDHEADER, NEAR * NPFDHEADER, FAR * LPFDHEADER;

#endif

#define WIFE_CREATE_DEVICEDRIVER
#ifdef WIFE_CREATE_DEVICEDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in WIFEMAN.DLL */
/***********************************************/

/***********************************************/
/*         Module Install Manager              */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MIM

typedef BOOL (FAR PASCAL * LPCBMEAD)
                ( LPSTR lpszFoundFileName, LPSTR lpszDescriptionName );
BOOL FAR PASCAL MimEnumAvailableDrivers
                        ( LPSTR lpszSeachFilePath, LPCBMEAD lpfCallBack );

typedef BOOL (FAR PASCAL * LPCBMEAP)
                ( HFD hFD, LPSTR lpszPackName );
BOOL FAR PASCAL MimEnumAvailablePacks
        ( HFD hFD, LPSTR lpszPackName, LPCBMEAP lpfCallBack );

HFD FAR PASCAL MimAddFontDriver( LPSTR lpszFileName );

HFF FAR PASCAL MimAddFontPack( HFD hFD, LPSTR lpszPackName );

BOOL FAR PASCAL MimRemoveFontDriver( HFD hFD );

BOOL FAR PASCAL MimRemoveFontPack( HFD hFD, HFF hFontPack );

HFD FAR PASCAL MimEnumFontDrivers( HFD hLastDriver );

HFF FAR PASCAL MimEnumFontPacks( HFD hFD, HFF hLastPack );

HFC FAR PASCAL MimOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont );

LONG FAR PASCAL MimCloseFontContext( HFD hFD, HFF hFF, HFC hFC );

typedef enum {
        MIMGETINFO_FD_DESCRIPTION = 0,
        MIMGETINFO_FF_DESCRIPTION = 1,
        MIMGETINFO_FD_FILENAME = 2,
        MIMGETINFO_FF_FILENAME = 3,
        MIMGETINFO_FD_USAGE = 4,
        MIMGETINFO_FF_USAGE = 5,
        MIMGETINFO_FD_INSTALL_COUNT = 6,
        MIMGETINFO_FF_INSTALL_COUNT = 7
} MIMGETINFO_ORDER;

SHORT FAR PASCAL MimGetInformations(
        MIMGETINFO_ORDER order,
        HFD hFD,
        HFF hFF,
        LPVOID AnswerBuffer,
        USHORT SizeOfBuffer
);

#endif

/***********************************************/
/*         Font Driver Interface               */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_FDI

LONG FAR PASCAL  FdiClaimFontFile( HFD hFD, LPSTR lpszFileName );

LONG FAR PASCAL FdiConvertFontFile(
        HFD hFD,
        LPSTR lpszSrcFileName,
        LPSTR lpszDestDirName,
        LPSTR lpszResultPackName
);

HFF FAR PASCAL FdiLoadFontFile( HFD hFD, LPSTR lpszPackName );

LONG FAR PASCAL FdiUnloadFontFile( HFD hFD, HFF hFF );

LONG FAR PASCAL FdiQueryFaces(
        HFD hFD,
        HFF hFF,            // Font File handle
        LPIFIMETRICS lpIfiMetrics,   // Buffer for the metrics
        ULONG cMetricLen,    // Length of the metrics structure
        ULONG cFontCount,    // # of fonts wanted.
        ULONG cStart         // index of the font to start with
);

HFC FAR PASCAL FdiOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont );

LONG FAR PASCAL FdiSetFontContext(
        HFD hFD,
        HFC hFC,
        LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdiCloseFontContext( HFD hFD, HFC hFC );

LONG FAR PASCAL FdiQueryFaceAttr(
        HFD hFD,
        HFC       hFC,
        ULONG     iQuery,
        LPVOID    lpBuffer,
        ULONG     cb,
        LPVOID    lpIndex,
        SHORT     Start
);

LONG FAR PASCAL FdiQueryCharAttr(
        HFD hFD,
        HFC        hFC,
        LPCHARATTR lpCharAttr,
        LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdiControl(
        HFD hFD,
        HFC hFC,
        LPCONTROLTAG lpControlTag,
        LPVOID lpOutData
);

#endif

/***********************************************/
/*         Font Cacheing Manager               */
/***********************************************/
#ifdef WIFE_ENABLE_FCM

#define FCM_WIFE_CHARACTER 1
#define FCM_CLIP_OUT 2
#define FCM_LEFT_CLIP 0x0100
#define FCM_RIGHT_CLIP 0x0200
#define FCM_TOP_CLIP 0x0400
#define FCM_BOTTOM_CLIP 0x0800

typedef struct {
        USHORT  SizeOfStruct;   /* size of structire */
        WORD    WifeFlag;       /* FCM processing flags */
        UBCHAR  ubCode;         /* character code */
        LPSTR   lpCacheBuffer; /* long ptr to cache bitmap */
        SHORT   nBitWidth;      /* x size of character image */
        SHORT   nBitHeight;     /* y size of character image */
        SHORT   nByteWidth;     /* byte width size in alloctaed buffer */
        USHORT  InternalIndex;  /* RESERVED FOR SYSTEM USE */
} FCM_CHARACTERISTIC, NEAR *NP_FCM_CHARACTERISTIC, FAR *LP_FCM_CHARACTERISTIC;

typedef struct {
        USHORT  SizeOfStruct;   /* size of structire */
        WORD    WifeFlag;       /* FCM processing flags */
        UBCHAR  ubCode;         /* character code */
        LPSTR   lpCacheBuffer; /* long ptr to cache bitmap */
        SHORT   nBitWidth;      /* x size of character image */
        SHORT   nBitHeight;     /* y size of character image */
        SHORT   nByteWidth;     /* byte width size in alloctaed buffer */
        USHORT  InternalIndex;  /* RESERVED FOR SYSTEM USE */

        SHORT   xPosOnDst;      /* x position on dst device */
        SHORT   yPosOnDst;      /* y position on dst device */

} FCM_EXTCHARACTERISTIC,
        NEAR * NP_FCM_EXTCHARACTERISTIC, FAR * LP_FCM_EXTCHARACTERISTIC;


HFB FAR PASCAL FcmCreateCacheBuffer(
        HFD hFD,
        HFF hFF,
        ULONG ulFont,
        LPTEXTXFORM lpXform,
        USHORT usMinorCharSet,
        USHORT usAttribute
);

BOOL FAR PASCAL FcmDeleteCacheBuffer( HFB hFontBuffer );

SHORT FAR PASCAL FcmRequestImages(
        HFB hFontBuffer,
        LP_FCM_CHARACTERISTIC AnswerBuffer,
        short length
);

BOOL FAR PASCAL FcmReleaseImages(
        HFB hFontBuffer,
        LP_FCM_CHARACTERISTIC AnswerBuffer,
        short length
);

HFB FAR PASCAL FcmRequestDefaultFB(
        LPFONTINFO lpFont,
        LPTEXTXFORM lpTextXform
);

BOOL FAR PASCAL FcmReleaseDefaultFB( HFB hFB );

#define FCMCALC_BIGFONT 1
#define FCMCALC_ROUGHCLIPINFO 2
#define FCMCALC_DETAILCLIPINFO 4

DWORD FAR PASCAL FcmCalculateTextExtent(
        HFB         hFB,
        LPSTR       lpString,
        short       count,
        LPFONTINFO  lpFont,
        LPDRAWMODE  lpDrawMode,
        LPTEXTXFORM lpXform,
        LPSHORT     lpCharWidths,
        USHORT      usMode
);

SHORT FAR PASCAL FcmCalculateOutputPositions(
        HFB             hFB,
        LP_FCM_EXTCHARACTERISTIC lpFcmCharacteristics,
        SHORT           nArrayLength,
        LPSHORT         lpx,
        LPSHORT         lpy,
        LPRECT          lpClipRect,
        LPSTR           FAR * lplpString,
        LPSHORT         lpcount,
        LPFONTINFO      lpFont,
        LPDRAWMODE      lpDrawMode,
        LPTEXTXFORM     lpXform,
        LPSHORT         FAR * lplpCharWidths,
        USHORT          usMode
);


SHORT FAR PASCAL FcmCleanUp( VOID );

HFB FAR PASCAL FcmEnumFontBuffers( HFB hLastBuffer );

HFC FAR PASCAL FcmGetFontContext( HFB hFB );

SHORT FAR PASCAL FcmCalcByteWidth( SHORT nBitWidth );

SHORT FAR PASCAL FcmForceCacheIn( HFB hFB, LPUBCHAR lpubStr );

BOOL FAR PASCAL FcmValidateFC( HFB hFB );

BOOL FAR PASCAL FcmUnvalidateFC( HFB hFB );

LONG FAR PASCAL FcmQueryFaceAttr(
        HFB         hFB,
        ULONG       iQuery,
        LPABC_TRIPLETS  lpBuffer,
        ULONG       cb,
        LPUBCHAR    lpIndex,
        UBCHAR      Start
);

#ifdef WIFE_ENABLE_FCM_CONTROL

SHORT FAR PASCAL FcmIsProcessableDeviceControl(
        HFB hFB,
        SHORT nFunction,
        GAIJIINFO FAR * lpGI
);

SHORT FAR PASCAL FcmProcessDeviceControl(
        HFB hFB,
        SHORT nFunction,
        GAIJIINFO FAR * lpGI,
        LPVOID lpOutData
);

#endif

USHORT FAR PASCAL FcmGetEUDCLeadByteRange( HFB hFB );

HFB FAR PASCAL FcmGetEUDCFB( HFB hFB );

USHORT FAR PASCAL FcmGetCharWidth(
        HFB         hFB,
        LPUSHORT    lpBuffer,
        USHORT      wFirstChar,
        USHORT      wLastChar,
        LPFONTINFO  lpFont,
        LPDRAWMODE  lpDrawMode,
        LPTEXTXFORM lpFontTrans,
        USHORT      usExpandPixels,
        USHORT      usMode
);

#endif

#endif

/***********************************************/
/*  WIFEMAN's Miscellaneous Service Functions  */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MISC

BOOL FAR PASCAL MiscIsDBCSLeadByte( CHAR_SET CharSet, USHORT ch );

#define MiscIsMBCSCharSet(c) (MiscIsDBCSLeadByte(c,0xffff))

VOID FAR PASCAL MiscSetErroInfo( ULONG ErrorCode );

ULONG FAR PASCAL MiscGetErroInfo( VOID );

SHORT FAR PASCAL MiscWarningMessage(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        USHORT mode
);

SHORT FAR PASCAL MiscWarningMessageWithArgument(
        HANDLE hInst,
        USHORT idsMsg,
        USHORT idsTitle,
        LPSTR lpszArgument,
        USHORT mode
);

#ifdef ENABLE_MESSAGEBOX

/* MessageBox() Flags */
#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000

#define MB_TYPEMASK         0x000F
#define MB_ICONMASK         0x00F0
#define MB_DEFMASK          0x0F00
#define MB_MODEMASK         0x3000
#define MB_MISCMASK         0xC000

#endif /* ENABLE_MESSAGEBOX */

USHORT FAR PASCAL ubstrlen( LPUBCHAR cp );

LPUBCHAR FAR PASCAL ubstrcpy( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncpy( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

LPUBCHAR FAR PASCAL ubstrcat( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncat( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

SHORT FAR PASCAL ubstrcmp( LPUBCHAR str1, LPUBCHAR str2 );

USHORT FAR PASCAL AscizToUz(
        LPUBCHAR dst,
        LPSTR src,
        USHORT limit,
        CHAR_SET CharSet
);

USHORT FAR PASCAL UzToAsciz(
        LPSTR dst,
        LPUBCHAR src,
        USHORT limit
);

VOID FAR PASCAL MiscTrancateString(
        LPSTR lpszStr,
        SHORT length,
        SHORT CharSet
);

#define MiscTrancateByDefaultCharSet(s,l) MiscTrancateString(s,l,-1)

ULONG FAR PASCAL MiscGetVersion( VOID );

USHORT FAR PASCAL MiscGetEUDCLeadByteRange( CHAR_SET csCharSet );

BYTE FAR PASCAL MiscConvertFontFamily( LPSTR szFamilyName );

BYTE FAR PASCAL MiscConvertCharSet( LPSTR CharSetString );

#ifdef WIFE_ENABLE_FONT_STRUCT_CONVERT

/* follow two values are only for usLogicalMapFlag parameter */
/* in MiscIfiMetricsToLogFont function.  */
#define LOGMAP_IGNORE_DESCENT 1
#define LOGMAP_IGNORE_INTERNAL_LEADING 2
#define LOGMAP_NEGATIVE (0x8000)

VOID FAR PASCAL MiscIfiMetricsToLogFont(
        LPLOGFONT lpLogFont,
        LPIFIMETRICS lpIFIMetrics,
        USHORT usLogicalMapFlag
);

VOID FAR PASCAL MiscIfiMetricsToTextMetrics(
        LPTEXTMETRIC lpTextMetrics,
        LPIFIMETRICS lpIFIMetrics
);

#endif

#ifdef WIFE_ENABLE_FONT_STRUCT_MAKE

VOID FAR PASCAL MiscMakeTextXform(
        LPTEXTXFORM lpTXF,
        LPIFIMETRICS lpIM,
        LPLOGFONT lpLF
);

#endif

#ifndef WIFEH_NO_HUGE_SUPPORT
LPVOID FAR PASCAL MiscAddHugePtr( LPVOID src, ULONG offset );
USHORT FAR PASCAL MiscGetSegmentIncrement( VOID );
#endif

#ifndef WIFEH_NO_CONTROL_RANGES
BOOL FAR PASCAL MiscIsWifeControl( SHORT function );
BOOL FAR PASCAL MiscIsGaijiControl( SHORT function );
#endif

#ifndef WIFEH_NO_STRETCHER
BOOL FAR PASCAL MiscStretchMonoFontImage(
        LPVOID  lpDestImage,
        USHORT  usSizeOfDestX,
        USHORT  usSizeOfDestY,
        LPVOID  lpSrcImage,
        USHORT  usSizeOfSrcX,
        USHORT  usSizeOfSrcY
);
#endif

#define WIFE_ENABLE_QUICK_SEARCH_TABLE
#ifdef WIFE_ENABLE_QUICK_SEARCH_TABLE

typedef struct {
        HFD hFD;
        HFF hFF;
        ULONG ulFont;
        BOOL bScalable;
        LOGFONT LogFont;
}QUICK_SEARCH_TABLE, NEAR * NP_QUICK_SEARCH_TABLE, FAR * LP_QUICK_SEARCH_TABLE;

LP_QUICK_SEARCH_TABLE FAR PASCAL MiscValidateQuickSearchTable(
        USHORT usLogicalMapFlag
);

BOOL FAR PASCAL MiscUnvalidateQuickSearchTable(
        USHORT usLogicalMapFlag
);

typedef LP_QUICK_SEARCH_TABLE (FAR PASCAL * LPMISCVALIDATEQST)(
        USHORT usLogicalMapFlag
);

typedef BOOL (FAR PASCAL * LPMISCUNVALIDATEQST)(
        USHORT usLogicalMapFlag
);

#define NMISCVALIDATEQST (67)
#define NMISCUNVALIDATEQST (68)

#endif

#ifdef WIFE_ENABLE_NOTIFY_FUNCTIONS

typedef enum {
        WN_ADD_FONTDRIVER = 0,
        WN_ADD_FONTPACKAGE = 1,
        WN_REMOVE_FONTDRIVER = 2,
        WN_REMOVE_FONTPACKAGE = 3,
        WN_REGISTER_SYSTEM_EUDC_CHAR = 4,
        WN_CHANGE_SYSTEM_EUDC_FILE = 5
} WIFENOTIFY_ORDER;

typedef struct {
        HFD hTargetFontDriver;
} WNS_FONTDRIVER;

typedef struct {
        HFD hTargetFontDriver;
        HFF hTargetFontPackage;
} WNS_FONTPACKAGE;

typedef struct {
        HFD hTargetFontDriver;
        HFF hTargetFontPackage;
        UBCHAR ubRegistedCharCode;
} WNS_REGISTER_SYSTEM_EUDC_CHAR;

typedef struct {
        HFD hTargetFontDriver;
        HFF hTargetFontPackage;
        LPSTR lpszNewFileName;
} WNS_WN_CHANGE_SYSTEM_EUDC_FILE;

typedef BOOL (FAR PASCAL * LPNOTIFYCALLBACKFUNC)(
        WIFENOTIFY_ORDER NotifyOrder,
        LPVOID lpParamBlock
);

BOOL FAR PASCAL MiscRegisterNotifyFunction(
        LPNOTIFYCALLBACKFUNC lpfnCallBack
);

BOOL FAR PASCAL MiscUnregisterNotifyFunction(
        LPNOTIFYCALLBACKFUNC lpfnCallBack
);

#endif

#ifdef WIFE_ENABLE_REALIZE_FUNCTIONS

WORD FAR PASCAL MiscRealizeWifeFont(
        LPLOGFONT lpLogFont,
        LPFONTINFO lpExtFont,
        LPTEXTXFORM lpTextXform
);

BOOL FAR PASCAL MiscDeleteWifeFont(
        LPFONTINFO lpExtFont
);

#endif

#endif


/***********************************************/
/*    DIAGNOSTIC TEST&CHECKING FUNCTIONS       */
/***********************************************/
#ifdef ENABLE_DIAGNOSTIC_FUNCTION

/* test and return error code  */
SHORT FAR PASCAL DiagSelfCheck( VOID );

/* invoke self test and make error record file, display warning dialog */
SHORT FAR PASCAL DiagSelfCheckAndWarning( VOID );

#endif


/************************************************/
/* THESE ARE PRIVATE INTERFACE FOR TEST PROGRAM */
/************************************************/
#ifdef ENABLE_TEST_PROGRAM_INTERFACE

LPVOID FAR PASCAL DiagLocalLockAnything( LOCALHANDLE hAny );
LPVOID FAR PASCAL DiagLocalUnlockAnything( LOCALHANDLE hAny );
SHORT FAR PASCAL DiagGetConfirmString( LPSTR buffer, SHORT length );

#endif

//////  for WOW ///////////

#define IDS_NOTSUPORTFUNCTION	200
#define IDS_WIFETITLE           201


/* end of wife.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..
    nmake  /fmakefile.sub \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
     ALT_PROJECT=usa \
	 DBCS_FLAGS="-DFE_SB"
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\wifeman.c ===
/**************************************************************************
*
*  - WIFEMAN.DLL -
*
* Windows Intelligent Font Environment Maneger for Win32 and NT 
*
*  Author : Hideyuki Nagase [hideyukn]
*
* History :
*
*  11.Aug.1993 -By- Hideyuki Nagase [hideyukn]
* Create it.
*
*************************************************************************/

#include <windows.h>

#define  WIFEMAN_VERSION     0x0109  //  Version 1.09

#define  EUDC_RANGE_SECTION  "System EUDC"
#define  EUDC_RANGE_KEY      "SysEUDCRange"

HINSTANCE hInst;


/************************************************************************
*
* MiscGetVersion()
*
*  Return WIFE driver version
*
************************************************************************/

unsigned long FAR PASCAL
MiscGetVersion
(
    VOID
)
{
    return( (long)WIFEMAN_VERSION );
}


/************************************************************************
*
* MiscIsDbcsLeadByte()
*
*  Return SBCS/DBCS status
*
************************************************************************/

unsigned char FAR PASCAL 
MiscIsDbcsLeadByte
(
    unsigned short usCharSet ,
    unsigned short usChar
)
{
    unsigned char ch;
    unsigned short LangID;

    LangID = GetSystemDefaultLangID();

    if (LangID == 0x404 && usCharSet != CHINESEBIG5_CHARSET)
        return( 0 );
    else if (LangID == 0x804 && usCharSet != GB2312_CHARSET)
        return( 0 );
    else if (LangID == 0x411 && usCharSet != SHIFTJIS_CHARSET)
        return( 0 );
    else if (LangID == 0x412 && usCharSet != HANGEUL_CHARSET)
        return( 0 );
    // CHP
    else if (LangID == 0xC04 && (usCharSet != GB2312_CHARSET) && (usCharSet != CHINESEBIG5_CHARSET))
        return( 0 );
    else
        return( 0 );

    if (usChar == 0xffff)
        return( 1 );

    ch = (unsigned char)((unsigned short)(usChar >> 8) & 0xff);

    if (ch == 0) {
        ch = (unsigned char)((unsigned short)(usChar) & 0xff);
    }

    return((unsigned char)(IsDBCSLeadByte( ch )));
}

/**********************************************************************
*
* WEP()
*
*  Called by Windows when this DLL in unloaded
*
**********************************************************************/

int FAR PASCAL
WEP
(
    int nParam
)
{
    int iRet;

    switch( nParam )
    {
        case WEP_SYSTEM_EXIT :
        case WEP_FREE_DLL :
        default :
            iRet = 1;
    }

    return( iRet );
}

int NEAR PASCAL LibMain(
        HANDLE hInstance,
        WORD wDataSeg,
        WORD wHeapSize,
        LPSTR lpCmdLine
)
{
    hInst = hInstance;

    return 1;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\apisim.asm ===
title	OS2_STUB - OS/2 Simulation routines for DOS 3

;	These routines simulate family API routines for DOS 3
;
;	Routines which are never called under DOS 3 just return
;	popping the parameters.
;
;	87/04/24  SKS	DOSGETMACHINEMODE stores a Byte, not a Word!
;


memL=1			; simulate large model for returns
?PLM=1			; pascal calling conventions
?WIN=0			; no Windows

.xlist
	include  cmac_mrt.inc		; old, customized masm510 cmacros
.list
	include msdos.inc


sBegin	code
assumes cs,code


;	__DOSDEVCONFIG - return 8087/80287 indicator

cProc	__DOSDEVCONFIG,<PUBLIC>,<ES,BX>

	parmDP	devinfo
	parmW	devitem
	parmW	reserved

cbegin
	les	bx,devinfo
	mov	word ptr es:[bx],1	; assume have 287
	xor	ax,ax			; return no error
cend


;	__DOSGETMACHINEMODE - return real mode indicator

cProc	__DOSGETMACHINEMODE,<PUBLIC>,<ES,BX>

	parmDP	mode

cbegin
	les	bx,mode
	xor	ax,ax			; ax = return code and mode
	mov	es:[bx],al		; set machine mode to real
cend


;	__DOSSETVEC - never called under DOS 3.x

cProc	__DOSSETVEC,<PUBLIC>,<>

	parmDP	oldaddr
	parmDP	newaddr
	parmW	vecnum

cbegin
cend


;	__DOSCREATECSALIAS

cProc	__DOSCREATECSALIAS,<PUBLIC>,<ES,BX>

	parmW	dataseg
	parmDP	csalias

cbegin
	mov	ax,dataseg
	les	bx,csalias
	mov	es:[bx],ax		; use dataseg value
cend



;	__DOSFREESEG - never called from DOS 3.x

cProc	__DOSFREESEG,<PUBLIC>,<>

	parmW	dataseg

cbegin
cend

;	__DOSWRITE - stripped-down version called from emulator for no87 message
;		 - note that there is no error detection in this version
;		 - since the emulator doesn't check for write errors anyway

cProc	__DOSWRITE,<PUBLIC>,<ds>	; <di> commented out

	parmW	handle		; unsigned
	parmD	p_buffer	; char far *
	parmW	bytestowrite	; unsigned
	parmD	p_byteswritten	; unsigned far *
				; returns unsgined

cbegin
	mov	cx,bytestowrite
	mov 	bx,handle
	lds	dx,p_buffer
	callos	write
;	jc	wrtret		; if write error, error code already in AX
;				; if no error, set bytes written
;	les	di,p_byteswritten
;	mov	word ptr es:[di],ax
 	xor	ax,ax		; if no error, clear return code
;wrtret:
cend


sEnd	code

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wifeman\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\em386.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	em386.asm - Main Entry Point and Address Calculation Procedure
page
;*********************************************************************;
;								      ;
;	  Main Entry Point and Address Calculation Procedure	      ;
;								      ;
;		80386 version					      ;
;								      ;
;*********************************************************************;
;
; This routine fetches the 8087 instruction, calculates memory address
; if necessary into ES:ESI and calls a routine to emulate the instruction.
; Most of the dispatching is done through tables. (see comments in CONST)
;
; The instruction dispatching is designed to favor the 386 addressing modes

ifdef	XENIX

LDT_DATA=	02Fh		; emulator data LDT
STACK_ALIAS=	027h		; 32 bit alias for stack selector

endif	;XENIX

;------------------------------------------------------------------------------
;
;	emulation entry point
;
;------------------------------------------------------------------------------

pub	protemulation

	cld				; clear direction flag forever

ifdef	XENIX
	push	ss			; save ss
endif	;XENIX

	push	eax			; for common exit code (historical)

	push	ds			; save segment registers

ifdef	XENIX

	push	eax			; UNDONE - slow

	mov	ax,LDT_DATA		; load up emulator's data segment
	mov	ds,ax
	cmp	[Einstall],0		; check if emulator is initialized
	je	installemulator 	;   no - go install it

pub	protemcont

	pop	eax			; UNDONE - slow

endif	;XENIX

	push	es
	push	ss			;   save SegOvr (bp forces SS override)

	push	edi			; save registers
	push	esi			;   must be in this order for indexing
	push	ebp
	push	esp
	push	ebx
	push	edx
	push	ecx
	push	eax

ifdef	XENIX

	mov	ax,ss			; check for 286 using user SS
	lar	eax,ax			; load extended access bits
	test	eax,00400000h		; test BIG bit
	jnz	short prot386		;   386 - ok

	mov	ax,STACK_ALIAS		; setup stack with 32 bit alias segment
	mov	ss,ax
	movzx	esp,sp			; clean up ESP
;	mov	word ptr [esp].regEIP+2,0 ; clean up EIP

pub	prot386

endif	;XENIX

	mov	ebp,esp 		; set up frame pointer
	add	[ebp].regESP,regFlg-regESP	; adjust to original esp

	mov	eax,edi 		; may use original DI to calc address
	lds	edi,fword ptr [ebp].regEIP ; ds:edi = 287 instruction address
	mov	cx,[edi]		; cx = esc 0-7 and opcode

	cmp	cl,09Bh 		; UNDONE - check FWAIT's getting through
	je	sawFWAIT		; UNDONE -   and ignore it

	add	edi,2			; point to displacement
	add	cl,28h			; set carry if esc 0-7 (and cl = 0-7)
	jnc	short protSegOvr	;   no carry - must be segment override

	mov	es,[ebp].regDS		; es = user data segment
	mov	edx,ebx 		; may use original BX to calc address

pub	CommonDispatch
	rol	ch,2			; rotate MOD field next to r/m field


; UNDONE
; UNDONE  should check for instruction prefixes such as address size prefix
; UNDONE

	lar	ebx,[ebp].regCS 	; check if 286 or 386 segment
	test	ebx,00400000h		;
	mov	bl,ch			; get copy of operation
	jz	short Have286segment	;   286 segment - assume 286 addressing

	and	ebx,1FH 		; Mask to MOD and r/m fields
	jmp	EA386Tab[4*ebx]

pub	Have286segment
	and	ebx,1FH 		; Mask to MOD and r/m fields
	jmp	EA286Tab[4*ebx]


;	protect mode Segment override case

glb	<protSegOvrTab>

protSegOvrTab	label	word

	dd	DSSegOvr	; 11
	dd	ESSegOvr	; 00
	dd	CSSegOvr	; 01
	dd	SSSegOvr	; 10


pub	protSegOvr
	mov	edx,ebx 		; may use original BX to calc 286 address
	mov	bl,cl
	shr	bl,1
	and	ebx,0Ch 		; bl = (seg+1) and 0Ch
	inc	edi			; point to displacement
	mov	cx,[edi-2]		; cx = esc 0-7 and opcode
	jmp	protSegOvrTab[ebx]	; process appropriate segment override


pub	DSSegOvr			; 00
	mov	es,[ebp].regDS		; set ES to EA segment
	jmp	short ESSegOvr

pub	CSSegOvr			; 10
	push	ds			; DS = caller's CS
	pop	es			; set ES to EA segment
	jmp	short ESSegOvr

pub	SSSegOvr			; 01
	push	ss			; SS = caller's SS
	pop	es			; set ES to EA segment

pub	ESSegOvr			; 11
	mov	[ebp].regSegOvr,es	; save for bp rel EAs
	jmp	CommonDispatch


;	386 address modes

;	SIB does not handle SS overrides for ebp

SIB	macro	modval
	local	SIBindex,SIBbase

	xor	ebx,ebx
	mov	bl,[edi]		; ebx = SIB field
	inc	edi			; bump past SIB field
	mov	eax,ebx
	and	al,7			; mask down to base register

if	modval eq 0
	cmp	al,5			; base = ebp
	jne	short SIBbase		;   yes - get base register value
	mov	eax,[edi]		; eax = disp32
	add	edi,4			; bump past displacement
	jmp	short SIBindex
endif

SIBbase:
	mov	eax,[ebp+4*eax] 	; eax = base register value

SIBindex:
	mov	[ebp].regESP,0		; no esp indexing allowed
	push	ecx			; UNDONE - slow
	mov	cl,bl
	shr	cl,6			; cl = scale factor
	shr	bl,1
	and	bl,1Ch			; ebx = 4 * index register
	mov	esi,[ebp+ebx]		; esi = index register value
	shl	esi,cl			; esi = scaled index register value
	pop	ecx			; UNDONE - slow
	add	esi,eax 		; esi = SIB address value
	endm


pub	SIB00
	SIB	00			; decode SIB field
	jmp	CommonMemory

pub	SIB01
	SIB	01			; decode SIB field
	mov	al,[edi]
	inc	edi
	cbw				; ax = al
	cwde				; eax = ax
	add	esi,eax
	jmp	short CommonMemory

pub	SIB10
	SIB	10			; decode SIB field
	mov	eax,[edi]
	add	edi,4
	add	esi,eax
	jmp	short CommonMemory


;	386 single register addressing

pub	Exx00
	and	bl,1Ch			; mask off mod bits
	mov	esi,[ebp+ebx]
	jmp	short CommonMemory

pub	Exx01
	and	bl,1Ch			; mask off mod bits
	mov	esi,[ebp+ebx]
	mov	al,[edi]
	inc	edi
	cbw				; ax = al
	cwde				; eax = ax
	add	esi,eax
	jmp	short CommonMemory

pub	Exx10
	and	bl,1Ch			; mask off mod bits
	mov	esi,[ebp+ebx]
	mov	eax,[edi]
	add	edi,4
	add	esi,eax
	jmp	short CommonMemory


;	386 direct addressing

pub	Direct386
	mov	esi,[edi]
	add	edi,4

pub	CommonMemory
	MOV	[ebp].regEIP,edi	; final return offset
	mov	ax,LDT_DATA
	mov	ds,ax
	mov	[CURerr],MemoryOperand	; clear current error, set mem. op bit

; At this point ES:SI = memory address, CX = |Op|r/m|MOD|escape|MF|Arith|

	shr	ch,4			; Move Op field to BX for Table jump
	mov	bl,ch
	and	ebx,0EH

	test	cl,1			; Arith field set?
	JZ	short ArithmeticOpMem

pub	NonArithOpMem
	CALL	NonArithOpMemTab[2*ebx] ; is CH shl 4 needed?
	JMP	EMLFINISH

pub	ArithmeticOpMem
	PUSH	ebx			; Save Op while we load the argument
	CALL	eFLDsdri		; emulate proper load
	POP	ebx

	mov	ax,ds			; ES = DS = task data area
	mov	es,ax
	MOV	esi,[CURstk]		; address top of stack
	MOV	edi,esi
	ChangeDIfromTOStoNOS
	MOV	[RESULT],edi		; Set up destination Pointer

	JMP	short DoArithmeticOpPop


pub	NoEffectiveAddress		; Either Register op or Miscellaneous

	MOV	[ebp].regEIP,edi	; final return offset

	xor	eax,eax
	mov	di,LDT_DATA
	mov	ds,di
	mov	es,di
	mov	[CURerr],ax		; clear current error, memory op bit

; CX = |Op|r/m|MOD|escape|MF|Arith|

	mov	bl,ch
	shr	bl,4			; Mov Op field to BX for jump
	and	ebx,0Eh

	TEST	CL,1			; Arith field set?
	JZ	short ArithmeticOpReg

pub	NonArithOpReg
	CALL	NonArithOpRegTab[2*ebx]
	JMP	EMLFINISH


; For register arithmetic operations, one operand is always the stack top.
; The r/m field of the instruction is used to determine the address of
; the other operand (ST(0) - ST(7))
; CX = xxxRRRxxxxxxxxxx (x is don't care, RRR is relative register # 0-7)

pub	ArithmeticOpReg

	call	RegAddr 		;di <= address of 2nd operand
					;carry set if invalid register
	jc	short InvalidOperand	;no, invalid operand, don't do operation

	MOV	[RESULT],esi		; Set destination to TOS
	TEST	CL,04H			; Unless Dest bit is set
	JZ	short DestIsSet 	; in which case
	MOV	[RESULT],edi		; Set destination to DI

pub	DestIsSet
					; Need to Toggle Reverse bit for DIV or SUB
	TEST	BL,08H			; OP = 1xx for DIV and SUB; BX = |0000|OP|O|
	JZ	short SetUpPop
	XOR	BL,02H			; Toggle Reverse bit

pub	SetUpPop
	TEST	CL,02H
	JZ	short DoArithmeticOpNoPop

pub	DoArithmeticOpPop
	CALL	ArithmeticOpTab[2*ebx]

	POPST
	JMP	short EMLFINISH

pub	DoArithmeticOpNoPop
	CALL	ArithmeticOpTab[2*ebx]
	JMP	short EMLFINISH


;***	InvalidOperand - register operand does not exist
;
;	RETURNS
;		sets Stack Underflow and Invalid bits in [CURerr]
;
;	DESCRIPTION
;		a reference was made to a register that does not
;		exist on the stack.  Set error bits and exit.

pub	InvalidOperand

	call	UnderStk		;indicate stack underflow error
	or	[CURerr],Invalid	;indicate invalid operand
	jmp	short EMLFINISH 	;don't execute instruction


;***	RegAddr - compute register address
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m = register whose address is to be computed
;
;	RETURNS
;		SI = address of top of stack
;		DI = address of requested register
;		PSW.C set if register is not valid
;		PSW.C reset if register is valid
;
;	DESCRIPTION
;		multiply register number by 12 and subtract this from
;		[CURstk] (the address of TOS) to compute address of
;		register referenced by r/m.
;
;	REGISTERS
;		modifies dx

pub	RegAddr
	mov	esi,[CURstk]		; address top of stack
	mov	edi,esi

;set up address of 2nd operand based on r/m field of instruction

	xor	edx,edx
	mov	dl,ch			; dl <== byte containing reg#
	and	dl,01ch 		; mask all but r/m field

; Since r/m field contains the relative reg # in bits 2-4 of dl,
; and bits 0-1 of dl are zero, dl now contains 4*(reg #).  To compute
; the memory location of this register, calculate 12*(reg #) and
; subtract this from di, which contains the address of the TOS.  reg #
; is multiplied by 12 because that is the number of bytes in each stack
; entry.

	lea	edx,[2*edx+edx] 	; edx = 3 * (4 * reg #)
	sub	edi,edx 		; di is address of second operand
	cmp	edi,[BASstk]		; is register in range?
	clc				; assume valid register
	jg	short RAclc		; valid - skip next instruction
	cmc				; set carry to indicate invalid register
pub RAclc
	ret


pub	CallUnused
	CALL	UNUSED			; Treat as unimpleminted
	jmp	short EMLFINISH


;	sawFWAIT - UNDONE - workaround for a 386 bug

pub	sawFWAIT
	inc	edi			; bump past FWAIT
	MOV	[ebp].regEIP,edi	; final return offset
	xor	eax,eax
	mov	di,LDT_DATA
	mov	ds,di
	mov	[CURerr],ax		; clear current error, memory op bit

; return from routine;	restore registers and return

pub	EMLFINISH
	pop	eax
	pop	ecx
	pop	edx
	pop	ebx
	add	esp,4			; toss esp value
	pop	ebp
	pop	esi
	pop	edi
	add	esp,4			; toss regSegOvr

;	check for errors

	MOV	AX,[CURerr]		; fetch errors
	or	[UserStatusWord],ax	; save all exception errors
	OR	[SWerr],AL		; set errors in sticky error flag
	NOT	AL			; make a zero mean an error
	MOV	AH,byte ptr [UserControlWord]  ; get user's IEEE control word
	OR	AH,0C2H 		; mask reserved, IEM and denormal bits
	AND	AH,03FH 		; unmask invalid instruction,
					;    stack overflow.
	OR	AL,AH			; mask for IEEE exceptions
	NOT	AL			; make a one mean an error
	MOV	AH,byte ptr (CURerr+1)	; get stack over/underflow flags
	TEST	AX,0FFFFh-MemoryOperand ; test for errors to report

	pop	es
	pop	ds


	jnz	short ExceptionsEmulator ;   goto error handler

pub	errret
        error_return    noerror          ; common exit sequence

pub	ExceptionsEmulator
	JMP	CommonExceptions


;------------------------------------------------------------------------------
;
;	286 address modes	(for XENIX only)
;
;------------------------------------------------------------------------------

ifdef	XENIX

; In the address calculations below:
;   DX has BX original value
;   AX has DI original value
;   SI has SI original value
;   BP has BP original value
;  [EDI] is address of displacement bytes

pub BXXI0D
	MOV	eax,edx 		; use original BX index value
pub DSDI0D
	MOV	esi,eax 		; use alternate index value
pub DSSI0D
	JMP	short ADRFIN		; have offset in SI

pub BPXI1D
	XOR	eax,eax 		; no index register
pub BPDI1D
	MOV	esi,eax 		; use alternate index value
pub BPSI1D
	ADD	esi,[ebp].regEBP	; add original BP value
	mov	es,[ebp].regSegOvr	; ES = override segment (or SS if none)
	JMP	short DSSI1D		; go get one byte displacement

pub BXSI1D
	MOV	eax,esi 		; really will want SI, not DI
pub BXDI1D
	ADD	edx,eax 		; now DX is original BX plus index
pub BXXI1D
	MOV	eax,edx 		; use original BX index value
pub DSDI1D
	MOV	esi,eax 		; use alternate index value
pub DSSI1D
	MOV	AL,[edi]		; get one byte displacement
	CBW				; sign extend displacement
	INC	edi			; get past displacement byte
	JMP	short DISPAD		; go add AX to SI (time w/ ADD)

pub BPXI2D
	XOR	eax,eax 		; no index register
pub BPDI2D
	MOV	esi,eax 		; use alternate index value
pub BPSI2D
	ADD	esi,[ebp].regEBP	; add original BP value
	mov	es,[ebp].regSegOvr	; ES = override segment (or SS if none)
	JMP	short DSSI2D		; go get two byte displacement

pub BXSI2D
	MOV	eax,esi 		; really will want SI, not DI
pub BXDI2D
	ADD	edx,eax 		; now DX is original BX plus index
pub BXXI2D
	MOV	eax,edx 		; use original BX index value
pub DSDI2D
	MOV	esi,eax 		; use alternate index value
pub DSSI2D
	MOV	AX,[edi]		; get two byte displacement
	INC	edi			; get past displacement byte
	INC	edi			; get past displacement byte
	JMP	short DISPAD		; go add AX to SI (time w/ ADD)

pub DSXI2D
	MOV	SI,[edi]		; get two byte displacement
	INC	edi			; get past displacement byte
	INC	edi			; get past displacement byte
	JMP	short ADRFIN		; have offset in AX

pub BPSI0D
	MOV	eax,esi 		; really will want SI, not DI
pub BPDI0D
	MOV	edx,[ebp].regEBP	; really will want BP, not BX
	mov	es,[ebp].regSegOvr	; ES = override segment (or SS if none)
pub BXDI0D
	MOV	esi,eax 		; use alternate index value
pub BXSI0D
	MOV	eax,edx 		; use original BX (or BP) as base

pub DISPAD
	ADD	esi,eax 		; add original index value

pub	ADRFIN
	movzx	esi,si			; ES:ESI = user memory address
	jmp	CommonMemory

endif	;XENIX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\87emstar.asm ===
;-------------------------------------------------------
;
;  pull in the Windows start up module;
;  pull in the Windows floating-point emulator;
;
;  9876h value is so that the symbol defined won't easily match
;  a constant value in the debugger.
;
public	__acrtused
	__acrtused = 9876h	
extrn	__acrtused2:abs		; pull in winstart: ?winstar.obj or ?libstar.obj

public	__fptaskdata
	__fptaskdata = 9876h	; stub out __fptaskdata so that
				; non-Windows emulator is not brought in

extrn	__fpmath:far		; force in Windows-emulator imports definition

extrn	__fpsignal:far		; force in Windows version of __fpsignal

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emconst.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986-88
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emconst.asm - Constants
page
;*********************************************************************;
;								      ;
;		Constants					      ;
;								      ;
;*********************************************************************;

;	internally used constants

		EVEN


labelW	IEEEzero
    dw	    0,0,0,0		    ; Mantissa of 0
    dw	    IexpMin - IexpBias	    ; Smallest Exponent
    db	    0			    ; Sign positive, not single precision
    db	    ZROorINF		    ; Number is ZERO


labelW	IEEEinfinity
    dw	    0,0,0,0		    ; Mantissa of 0
    dw	    IexpMax - IexpBias	    ; Largest exponent
    db	    0			    ; Sign positive, not single precision
    db	    Special + ZROorINF


labelW	IEEEindefinite
    dw	    0,0,0,0C000H	    ; MSB Turned on in mantissa
    dw	    IexpMax - IexpBias	    ; Largest exponent
    db	    080H		    ; Sign negative, not single precision
    db	    Special


labelW	IEEEbiggest
    dw	    0FFFFH,0FFFFH,0FFFFH,0FFFFH     ; Turn on Mantissa
    dw	    IexpMax - IexpBias - 1	    ; Largest valid exponent
    db	    0			    ; Sign positive, not single precision
    db	    0			    ; Valid non-zero, non-special number



labelW IEEEinfinityS
    dw	    0, 7f80h		    ; Sign 0, Exp 1's, Mantissa 0


labelW	IEEEbiggestS
    dw	    0ffffh, 7f7fh	    ; Sign 0, Exp Max - 1, Mantissa 1's


labelW	IEEEinfinityD
    dw	    0, 0, 0		    ; Mantissa of 0
    dw	    7ff0h		    ; Largest exponent


labelW	IEEEbiggestD
    dw	    0ffffh, 0ffffh, 0ffffh  ; Turn on Mantissa
    dw	    7fefh		    ; Largest exponent - 1


;	transcendental constants

labelW	cFLDZ
    dw	    00000h, 00000h, 00000h, 08000h, IexpMin-IexpBias, 00100h

labelW	cFLD1
    dw	    00000h, 00000h, 00000h, 08000h, 00000h, 00000h


ifndef	frontend
ifndef	SMALL_EMULATOR


labelW	TWOMRT3
    dw	    0B18AH,0F66AH,0A2F4H,08930H,0FFFEH,00000H

labelW	RT3
    dw	    0539EH,0C265H,0D742H,0DDB3H,00000H,00000H

labelW	PIBY6
    dw	    02C23H,06B9BH,091C1H,0860AH,0FFFFH,00000H

labelW	RT2
    dw	    06484H,0F9DEH,0F333H,0B504H,00000H,00000H

labelW	TWO
    dw	    00000H,00000H,00000H,08000H,00001H,00000H

labelW	cFLDPI
    dw	    0C235H,02168H,0DAA2H,0C90FH,00001H,00000H

labelW	cFLDL2T
    dw	    08AFEH,0CD1BH,0784BH,0D49AH,00001H,00000H

labelW	cFLDL2E
    dw	    0F0BCH,05C17H,03B29H,0B8AAH,00000H,00000H

labelW	cFLDLG2
    dw	    0F799H,0FBCFH,09A84H,09A20H,0FFFEH,00000H

labelW	cFLDLN2
    dw	    079ACH,0D1CFH,017F7H,0B172H,0FFFFH,00000H


labelW	TANRAT
	dw	3
	dw	07BD4H,0D85AH,05C3EH,08F69H,00005H,00080H
	dw	04D37H,02CD7H,0D0F8H,0D6D4H,0000CH,00000H
	dw	0DCD3H,06617H,0BBEEH,082BAH,00012H,00080H
	dw	091CBH,05E58H,0868BH,0F506H,00014H,00000H
	dw	3
	dw	086E5H,00120H,00502H,09C79H,00009H,00080H
	dw	06663H,088CFH,0B270H,0C939H,0000FH,00000H
	dw	0FA96H,0C746H,00CFEH,0E4B7H,00013H,00080H
	dw	091CBH,05E58H,0868BH,0F506H,00014H,00000H


labelW	ATNRAT
	dw	4
	dw	05B32H,0CF08H,0A4C9H,0A650H,0FFFDH,00000H
	dw	0D1CEH,0D5CAH,0A84BH,0D0F0H,00002H,00000H
	dw	0899FH,0E22BH,052A8H,09C4AH,00005H,00000H
	dw	04265H,05550H,0E9CFH,090EFH,00006H,00000H
	dw	04B90H,024ADH,0E5E6H,0A443H,00005H,00000H
	dw	3
	dw	08310H,05638H,04F0AH,0F062H,00003H,00000H
	dw	0B4E7H,06D1EH,05190H,0EE50H,00005H,00000H
	dw	0243BH,05B6DH,09020H,0AC50H,00006H,00000H
	dw	04B90H,024ADH,0E5E6H,0A443H,00005H,00000H



labelW	EXPRAT
	dw	2
	dw	01898H,0F405H,006FCH,0F274H,00005H,00000H
	dw	0AD08H,014E1H,03D54H,0EC9BH,0000EH,00000H
	dw	05FAFH,0C3A3H,0D84AH,0FDF0H,00014H,00000H
	dw	2
	dw	0776FH,0387BH,0108BH,0DAA7H,0000AH,00000H
	dw	0E85DH,09B7BH,0B182H,0A003H,00012H,00000H
	dw	0837EH,0E709H,0F814H,0B72DH,00016H,00000H


labelW	LOGRAT
	dw	3
	dw	07704H,0C299H,057E2H,09B71H,0FFFEH,00000H
	dw	04F9CH,0F631H,05E35H,0DE91H,00004H,00080H
	dw	04B8AH,07AEAH,0C9EDH,0B2D3H,00008H,00000H
	dw	028C9H,01D09H,0E42FH,08AC4H,0000AH,00080H
	dw	2
	dw	076BBH,03E70H,0025BH,08EACH,00005H,00080H
	dw	0EF60H,0A933H,01FD0H,09C04H,00008H,00000H
	dw	0BB96H,06C83H,0F4E0H,0C05FH,00009H,00080H


endif	;not SMALL_EMULATOR
endif	;frontend
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emarith.asm ===
page	,132
	subttl	emarith.asm - Arithmetic Operations
;*** 
;emarith.asm -
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Arithmetic Operations
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History: (Also see emulator.hst)
;
;   12/19/89  WAJ   XORSIGN was not masking the sign bit correctly.
;
;*******************************************************************************

;-----------------------------------------------;
;						;
;   Double precision arithmetic 		;
;						;
;-----------------------------------------------;

; Inputs:
;	DI = (op1) NOS (Next on stack)
;	SI = (op2) TOS (Top of stack)
;
; Functions:
;	ADDRQQ - Addition	    RESULT  <--  [DI] + [SI]
;	SUDRQQ - Subtract	    RESULT  <--  [DI] - [SI]
;	MUDRQQ - Multiply	    RESULT  <--  [DI] * [SI]
;	DIDRQQ - Division	    RESULT  <--  [DI] / [SI]
;	SVDRQQ - Subtract Reversed  RESULT  <--  [SI] - [DI]
;	DRDRQQ - Division Reversed  RESULT  <--  [SI] / [DI]
; Outputs:
;	Destination of result is in RESULT
; Registers:
;	All except BP destroyed.

; Understanding this code:
;
;	Assign the  symbol  S  to  SI,	assign	the symbol D to DI.
;
;	Upon entry:  SI <-- S, DI <-- D , Performing D - S


ProfBegin  ARITH

	even

lab SVDRQQ			; Reverse Subtract
	MOV	DX,Sign*256	; DH will be flag[SI], prepare to switch sign
	JMP	short DOADD

	even

lab SUDRQQ			; Normal Subtract
	MOV	DX,Sign 	; DL will be flag[DI], prepare to switch sign
	JMP	short DOADD

	even

lab MUDRQQ			; Multiplication
	xor	idx,idx 	; Do not change signs on entry
	MOV	ibx,offset MULJMPTAB
	JMP	short INITIL

	even

lab DIDRQQ			; Normal Division
	xor	idx,idx
	XCHG	isi,idi 	; Make SI - Numerator, DI - Denominator
	MOV	ibx,offset DIVJMPTAB
	JMP	short INITIL

	even

lab DRDRQQ			; Reverse Division
	xor	idx,idx
	MOV	ibx,offset DIVJMPTAB
	JMP	short INITIL

	even

lab ADDRQQ			; Double Precision Add
	xor	idx,idx 	; No signs get switched
lab DOADD
	MOV	ibx,offset ADDJMPTAB

lab INITIL
	MOV	AL,Tag[idi]	 ; Get tags to determine special cases.
	SHL	AL,1
	SHL	AL,1
	OR	AL,Tag[isi]
	CBI
ifdef	i386
	SHL	iax,2
else
	SHL	iax,1
endif
	ADD	ibx,iax 	 ; BX now points to address of proper routine.

	XOR	DH,Flag[idi]	 ; Sign A
	XOR	DL,Flag[isi]	 ; Sign B
	MOV	CX,Expon[idi]	 ; Exponent of operand A
	MOV	AX,Expon[isi]	 ; Exponent of operand B

	JMP	cs:[ibx]	 ; Go to appropriate routine.

page
;-----------------------------------------------------------;
;							    ;
;	Special Case Routines for Arithmetic Functions	    ;
;							    ;
;-----------------------------------------------------------;

lab DDD
	mov	isi,idi 	;return DI with sign from Add/Subtract
	mov	dl,dh

lab SSS 			;Return SI with sign from Add/Subtract
	call	MOVresult
	MOV	Flag[idi],dl	;Overstore correct Sign from Add/Subtract
	ret


lab D0SSINV			;Return SI, set both Invalid and Zerodivide
	OR	[CURerr],ZeroDivide
	JMP	short SSINV

lab DDINV			;Return DI and set Invalid exception
	MOV	isi,idi

lab SSINV			;Return SI and set INVALID exception
	OR	[CURerr],Invalid
	jmp	short MOVresult


lab ZEROS			;Return 0 with xor of signs
	MOV	isi,offset IEEEzero

lab XORSIGN
	XOR	DH,DL
	AND	DH,80h		    ; Mask to just the sign.
	CALL	csMOVresult
	OR	Flag[idi],DH
	RET

lab DIV0			;Set exception, Return Infinity signed
	OR	[CURerr],ZeroDivide

lab INFS			;Return signed infinity
	MOV	isi,offset IEEEinfinity
	JMP	XORSIGN


lab D0INDINV			;Set div 0 exception, Return Indefinate and Invalid
	OR	[CURerr],ZeroDivide

lab INDINV
	MOV	isi,offset IEEEindefinite
	OR	[CURerr],Invalid

lab csMOVresult
	mov	idi,[RESULT]

lab csMOVRQQ			; as above for constants in CS
ifdef	i386
	MOVS	dword ptr es:[idi],dword ptr cs:[isi]
	MOVS	dword ptr es:[idi],dword ptr cs:[isi]
	MOVS	dword ptr es:[idi],dword ptr cs:[isi]
else
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
	MOVS	word ptr es:[idi],word ptr cs:[isi]
endif
	SUB	idi,Reg87Len
	SUB	isi,Reg87Len
	RET


lab MOVresult
	mov	idi,[RESULT]	; move to result
	cmp	isi,idi
	je	short MOVret	;   unless the same

lab MOVRQQ
ifdef	i386
	MOVS	dword ptr es:[idi],dword ptr ds:[isi]
	MOVS	dword ptr es:[idi],dword ptr ds:[isi]
	MOVS	dword ptr es:[idi],dword ptr ds:[isi]
else
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
	MOVS	word ptr es:[idi],word ptr ds:[isi]
endif
	SUB	idi,Reg87Len
	SUB	isi,Reg87Len

lab MOVret
	RET


lab INFINF			; Addition of two infinities was attempted
	TEST	[CWcntl],InfinityControl    ; Invalid if projective closure
	JSZ	INDINV
	XOR	DL,DH		; Invalid if signs are different
	JSS	INDINV
	JMP	DDD		; Otherwise Inf is the answer, already at DI

lab BIGNAN			; Return the NAN with the Bigger mantissa
	mov	iax, isi
	mov	ibx, idi

	add	isi, MantissaByteCnt-2	    ; UNDONE387:  Convert SNAN to QNAN
	add	idi, MantissaByteCnt-2
	mov	icx, MantissaByteCnt/2
	std
     repe cmps	word ptr ds:[isi], word ptr es:[idi]
	cld
	JSB	DDNAN

	mov	isi, iax	; Greater NAN was in si
	jmp	SSINV

lab DDNAN
	mov	isi, ibx	; Greater NAN was in di
	jmp	SSINV

page

if	fastSP

ifdef	i386
	BUG			; fastsp and i386 do not work together
endif

;Assumes DL = Flag[SI], DH = Flag[DI].	Will convert the mantissa on
;stack to double if necessary by appending zeros.
;Must not change AX, DX, SI, DI.

lab CoerceToDouble
	MOV	BX,DX			; get to work reg
	AND	BX,Single + 256*Single	; mask to single flags only
	JSNZ	CheckDI

lab CoerceToDoubleReturn
	RET

lab CheckDI
	XOR	BX,BX		; Prepare to zero out mantissa
	XCHG	AX,BX
	TEST	DH,Single
	JSZ	CheckSI
	STOSW			; Zero out lower five bytes
	STOSW
	STOSB
	SUB	DI,5		; Reset DI

lab CheckSI
	TEST	DL,Single
	JZ	short ExitCoerceToDouble
	XCHG	DI,SI
	STOSW			; Zero out lower five bytes
	STOSW
	STOSB
	SUB	DI,5		; Reset DI
	XCHG	DI,SI

lab ExitCoerceToDouble
	XCHG	AX,BX		; Reset AX
	XOR	BX,BX		; Set zero flag to indicate results now double
	RET

endif	;fastSP

ProfEnd  ARITH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emds.asm ===
page	,132
	title	emds.asm - Defines __FPDSARRAY
;***
;emmain.asm - Defines __FPDSARRAY.
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Defines __FPDSARRAY
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


_DATA	segment	word public 'DATA'
_DATA	ends

DGROUP	group _DATA

include os2supp.inc

; __FPDSARRAY[0] = MAXTHREADID
; __FPDSARRAY[i] = emulator DS for thread i, 1<=i<=MAXTHREADID


_DATA	segment	word public 'DATA'

public		__FPDSARRAY
__FPDSARRAY dw	    MAXTHREADID 		; table size = MAXTHREADID
	    dw	    MAXTHREADID dup (0) 	; array of per-thread DS's

_DATA	ends


_TEXT	segment word public 'CODE'
assume cs:_TEXT

extrn	__gettidtab:near

public __FarGetTidTab
__FarGetTidTab:
	call	__gettidtab

	retf

_TEXT	ends


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emdoc.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emdoc.asm - Documentation
page
;--------------------------------------------------------------------
;
; WARNING - This may not be accurate for the stand-alone emulator.
;
; Glossary:
;   TOS - top-of-stack (e.g. simulated 8087 register stack)
;   single - single precision real number in one of two formats:
;     memory (IEEE), internal (on stack, see below)
;   double - double precision real number in one of two formats:
;     memory (IEEE), internal (on stack, see below).
;
; This source is organized into the following sections:
;  1. Introductory documentation of instructions and data structures
;  2. External routines, data segment, and const segment definitions
;  3. Startup and terminate, utility truncTOS
;  4. User memory macros
;  5. Macros and procedures for stack push and pop, error handling
;  6. Main entry point and effective address calculation routine
;
; Assumptions about segment usage:
;   SS = user's stack
;   DS = user's emulator data segment (not user's DS)
;   ES = effective address segment for memory operands
;      = user's emulator data segment (all other times)
;
; BASstk is DS offset of the stack base
; CURstk is DS offset of the current register (TOS).
; LIMstk is DS offset of LAST reg in stack
;
; CURerr has internal exception flag byte (<>0 iff exception occured).
; UserControlWord has user set values
; ControlWord has remapped version of UserControlWord
; CWcntl (high byte of ControlWord) has Rounding, precision, Inf modes
;
; Macros:
;   PUSHST allocates a new 12 byte register, and POPST frees one.
;   Both return an address in SI and save all other 8086 registers.
;
;   Five macros handle all data movement between user memory and local
;   memory or registers.
;
; Note standard forms:
;
;  Bits are counted from least significant;  bit 0 is 1's, bit 7 is 128's.
;
;  IEEE format is used, naturally, for values in user memory:
;
;  IEEE single precision:
;    +0: least significant byte of mantissa
;    +1: next sig. byte of mant.
;    +2: bits 6..0: most sig. bits of mant.
;    +2: bit  7:    low order bit of exponent
;    +3: bits 6..0: rest of exponent
;    +3: bit  7:    sign bit
;    mantissa does not include "hidden bit".
;    with hidden bit, mantissa value is 1.0 to 2.0
;    exponent is in biased form, with bias of 127
;    exponent of all 0's means a value of zero
;    exponent of all 1's means a value of "indefinite"
;
;  IEEE double precision:
;    +0: least significant byte of mantissa
;    +1..+5 next sig. bytes of mant.
;    +6: bits 3..0 (lo nibble): most sig. bits of mant.
;    +6: bits 7..4 (hi nibble): least sig. bits of exp.
;    +7: bits 6..0: most sig. bits of exponent
;    +7: bit  7: sign bit
;    mantissa does not include "hidden bit".
;    with hidden bit, mantissa value is 1.0 to 2.0
;    exponent is in biased form, with bias of 1023
;    exponent of all 0's means a value of zero or Denormal
;    exponent of all 1's means a value of NAN or Infinity

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emerror.asm ===
page	,132
	subttl	emerror.asm - Emulator error handler
;***
;emerror.asm - Emulator error handler
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Emulator error handler
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin ERROR

; error entry to check for unmasked errors


error_return    macro   noerror
	pop	eax		; common exit code
ifdef	XENIX
ifdef   i386
	pop	ss		; pop stack selector
endif
ifnb    <noerror>
        iretd                   ; normal return
else
        int     0FFh            ; special XENIX int for error
endif
else
        iretd
endif	;XENIX
	endm


TESTif	macro	nam
	mov	bl,err&nam	; default error number
   IF (nam GE 100H)
	test	ah,nam/256
   ELSE ;not (nam GE 100H)
	test	al,nam
   ENDIF ;(nam GE 100H)
	jnz	short signalerror
	endm

pub	CommonExceptions

ifdef	QB3

	jmp	$EM_INT 	; jump to QB3 error handler

else	;not QB3

	push	ds		; get address from task DS
	push	ebx

	TESTif	StackUnderflow	; Stack underflow
	TESTif	StackOverflow	; Stack overflow
	TESTif	SquareRootNeg	; Square root of negative number?
	TESTif	IntegerOverflow ; Would number not fit in integer?
	TESTif	Invalid 	; indefinite error ?
	TESTif	ZeroDivide	; zero divide error ?
	TESTif	Overflow	; overflow error ?
	TESTif	Underflow	; underflow error ?
;	TESTif	Denormal	; denormal error ?  not yet implemented
	TESTif	Precision	; Precision error ?
	TESTif	Unemulated	; unemulated error ?

; BL = error code value

pub	signalerror

ifndef  XENIX

ifdef	MTHREAD
	LOADthreadDS			; macro in emthread.asm	
					; load thread's DS; trash AX
elseifdef   standalone
	xor	ax,ax
	mov	ds,ax
	mov	ds,ds:[4*TSKINT+2]

elseifdef  _COM_
	mov	ds, [__EmDataSeg]

else	;Default
	mov	ax, edataBASE
	mov	ds,ax
endif	;Default


ifdef	MTHREAD
	; lock _SIGNAL_LOCK to guard SignalAddress (also used by signal func.)
	mov	ax,DGROUP
	mov	ds,ax			; establish DS == DGROUP for __lock
	push	_SIGNAL_LOCK
	call	__lockf
	add	sp,2
	mov	ax,EMULATOR_DATA	; use thread 1's data segment
	mov	ds,ax			; establish DS == EMULATOR_DATA
	mov	ax,word ptr [SignalAddress]	; check for nonzero address
	or	ax,word ptr [SignalAddress+2]
	jnz	short havehandler
	; go straight to DOSEXIT call below ...
	; don't bother cleaning up the stack or unlocking _SIGNAL_LOCK

	;pop	bx		; don't bother tossing
	;pop	ebx		; don't bother tossing
	;pop	ds		; don't bother tossing
	mov	ax,1		
	push	ax
; BL = error code value
	xchg	ax,bx		; al = return code
	xor	ah,ah
	push	ax
	os2call	DOSEXIT		; DOSEXIT(1,return code) to terminate process

elseifdef  WINDOWS
	push	es
	push	bx

	mov	ax, DOS_getvector*256 + TSKINT
	IntDOS

	mov	ax, es
	or	ax, bx

	pop	bx
	pop	es
	jnz	short havehandler

else	;not MTHREAD or WINDOWS
	mov	ax,word ptr [SignalAddress]
	or	ax,word ptr [SignalAddress+2]
	jnz	short havehandler
				; UNDONE - why no "os2call DOSEXIT" for the DOS5 case?
	;pop	bx		; don't bother tossing
	;pop	ds		; don't bother tossing
	xchg	ax,bx		; al = return code
	mov	ah,04Ch
	int	21h		; terminate process with fp error code

endif	;not MTHREAD or WINDOWS

pub	havehandler

ifdef	MTHREAD
;	DS == EMULATOR_DATA		; Use thread 1's DS for SignalAddress.
;	BL = return code
	xchg	ax,bx			; al = return code
	push	word ptr [SignalAddress+2]
	push	word ptr [SignalAddress]

	mov	bx,DGROUP
	mov	ds,bx			; establish DS == DGROUP for __unlock

	push	_SIGNAL_LOCK		; unlock _SIGNAL_LOCK
	call	__unlockf
	add	sp,2

	mov	bx,sp			; SS:BX points to a copy of SignalAddress on the stack

else	;not MTHREAD
					; bl = return code
	xchg	ax,bx			; al = return code

					; other error return info for recovery
	pop	ebx
endif	;not MTHREAD

; all registers are the original values except AX and DS
;
; al = error code (81h and up)
;
; if the signal routine is going to return to the user program, it can
; just do a long ret.  The users DS is sitting above the far return address


ifdef	POLLING 		; new exception handling code
ifndef	frontend

ifdef	DOS3and5
	cmp	[protmode],0	; check for protect mode
	jne	callsig 	;   yes - call signal now
endif	;DOS3and5

ifdef	DOS3
	cmp	[have8087],0	; check if emulating
	je	callsig 	;   yes - call signal now
	cmp	[errorcode],0	; check if pending error
ifdef	WF
	je	ncs1
	jmp	nocallsig
ncs1:
else
	jne	nocallsig	;   yes - just return
endif

	mov	[errorcode],al	; save error code for later


;*
;*  Set 80x87 exception occured flag.
;*

ifdef  USE_IRET
	mov	byte ptr cs:[FWAITiret], iNOP	; nop out "iret"

elseifdef  WINDOWS
ifdef	WF
	cmp	[wfGoFast], 0
	je      WinSlow2

	.286p
;	int 3
	push	bp			; bp[0], ds[2], ax[4], retip[6], retcs[8], retfl[10]
	mov	bp, sp			; faultip[12], faultcs[14]
	push	es
	pusha
	mov	ax, REMLSW
	mov	[wfErr], ax

	push	cs			; if fault CS:IP == our int 3d handler
	pop	ax			; then we don't want to patch it, we just want
	cmp	[bp+14], ax		; to set the flag as if we had
	jnz	wfPatch
	mov	ax, offset wfFaultHere
	cmp	[bp+12], ax
	jnz	wfPatch
	mov	[wfInsn], 3dcdh
	jmp	short wfNoPatch
wfPatch:

	push	[bp+14]			; copy faulting CS to data selector
	push	[wfSel]
	call	ChangeSelector

	mov	es, [wfSel]		; es:bx points to faulting insn
	mov	bx, [bp+12]

	mov	ax, es:[bx]		; save old insn value
	mov	[wfInsn], ax
	mov	es:[bx], 3dcdh		; put INT 3D at fault location
wfNoPatch:
	popa
	pop	es
	pop	bp
	pop	ds
	pop	ax
	iret
; fall through to old code
WinSlow2:
endif
	mov	[ExceptFlag], 1

else	;DEFAULT
	mov	byte ptr cs:[FWAITRetF], iNOP	; nop out "retf 2"
	mov	word ptr cs:[FWAITRetF2], wNOP
endif	;DEFAULT

	jmp	short nocallsig     ; just return
endif	;DOS3

endif	;not frontend
endif	;POLLING


callsig:

ifdef	MTHREAD
	call	dword ptr ss:[bx]   ; call thru thread 1's signal address
	add	sp, 4		    ; remove address of signal handler from stack
	pop	ebx		; note that bx is restored after the call to the
				; SIGFPE signal handler, but the SIG_DFL, SIG_IGN, or
				; user-handler shouldn't care; in the event of SIG_IGN
				; or a user handler that actually returns instead of
				; doing longjump(), this pop instruction will restore bx

elseifdef  WINDOWS
	mov	REMLSW, ax		; save error code

	pop	ds
	pop	ax			; stack is now just an int stack frame

ifdef WF0
	.286p
;	int 3
	push	bp			; bp[0], retip[2], retcs[4], retfl[6]
	mov	bp, sp			; faultip[8], faultcs[10]
	push	ds
	push	es
	pusha
	mov	ax, EMULATOR_DATA
	mov	ds, ax
	cmp	[wfGoFast], 1		; if running Std Mode
	jnz     WinSlow2
	mov	ax, REMLSW
	mov	[wfErr], ax
	push	[bp+10]			; copy faulting CS to data selector
	push	[wfSel]
	call	ChangeSelector

	mov	es, [wfSel]		; es:bx points to faulting insn
	mov	bx, [bp+8]

	mov	ax, es:[bx]		; save old insn value
	mov	[wfInsn], ax

	mov	es:[bx], 3dcdh		; put INT 3D at fault location

	popa
	pop	es
	pop	ds
	pop	bp
	iret
WinSlow2:			; can't do fast (non-poll) fp, so
	popa			; restore stack and use old method
	pop	es
	pop	ds
	pop	bp
; fall through to old code
endif

	inc	bp
	push	bp
	mov	bp, sp
	push	ds

	push	ax			; save user's ax

	push	cs			; must set up another stack frame
	mov	ax, offset DummyReturn
	push	ax
DummyReturn:

	mov	word ptr [bp-2], EMULATOR_DATA	; emulator's ds goes on first frame

	inc	bp
	push	bp
	mov	bp, sp
	push	ds			; push user's ds onto dummy stack frame

	mov	ax, EMULATOR_DATA
	mov	ds, ax

	push	es			; if windows => setup SignalAddress for
	push	bx			; far call

	mov	ax, DOS_getvector*256 + TSKINT
	IntDOS

	mov	word ptr [SignalAddress], bx
	mov	word ptr [SignalAddress+2], es

	pop	bx
	pop	es

	mov	ax, REMLSW		; al = error code

	call	[SignalAddress] 	; execute signal routine

	pop	ds			; restore user's ds
	add	sp, 6			; get rid of dummy stack frame
	pop	ax			; restore user's ax

	add	sp, 2			; get rid of emulator ds on stack

	pop	bp
	dec	bp

	iret				; return


else	;not MTHREAD or WINDOWS
	call	[SignalAddress] ; execute signal routine
endif	;not MTHREAD or WINDOWS

nocallsig:

	pop	ds		; restore user DS
        error_return    noerror ; treat as if nothing happened

else	;XENIX
        pop     ebx             ; restore EBX and DS
	pop	ds
        error_return            ; error exit for XENIX

endif	;XENIX


endif	;not QB3

ProfEnd  ERROR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emdisp.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emdisp.asm - Dispatch Tables
page
;*********************************************************************;
;								      ;
;		Dispatch Tables 				      ;
;								      ;
;*********************************************************************;

;	dispatch tables

;   These tables are based upon the layout of the 8087 instructions
;
;      8087 instruction fields:   |escape|MF|Arith|MOD|Op|r/m|disp1|disp2|
;	  field length in bits:       5    2   1    2	3   3	8     8
;
;   Disp1 and Disp2  are optional address bytes present only if MOD <> 11.
;   When (MOD <> 11) r/m describes which regs (SI,DI,BX,BP) are added to
;	Disp1 and Disp2 to calculate the effective address. This form
;	(memory format) is used for Loads, Stores, Compares, and Arithmetic
;   When using memory format MF determines the Type of the Memory operand
;	i.e. Single Real, Double real, Single Integer, or Double Integer
;   Arith is 0 for Arithmetic opetations (and compares), set to 1 otherwise
;   Op mostly determines which type of operation to do though when not in
;	memory format some of that is coded into MF and r/m
;   All of the tables are set up to do a jump based upon one or more of the
;	above fields. The outline for decoding instructions is:
;
;	    IF (memory format) THEN
;	       Assemble Effective Address (using MOD and r/m and EffectiveAddressTab)
;	       IF (Arith) THEN
;		  Load to the stack (using MF and FLDsdriTab)
;		  Do the Arithmetic Operation (using Op and ArithmeticOpTab)
;	       ELSE  (memory format non- arithmetic)
;		  Do the operation (using Op and NonArithOpMemTab  and
;		    depending on the case MF and one of the FLD or FST Tabs)
;	       ENDIF
;	    ELSE (Register format)
;	       IF (Arith) THEN
;		  Test r/m for legit Stack reference
;		  Do the Arithmetic Operation (using Op and ArithmeticOpTab)
;	       ELSE  (non-arithmetic register format)
;		  Do the operation (using Op and NonArithOpRegTab  and
;		    depending on the case r/m and one of:
;		    Constants, Miscellaneous, Transcendental, or Various Tabs)

	EVEN

glb	<EA286Tab>

eWORD	EA286Tab			; Uses |r/m|MOD| for indexing
	edw	BXSI0D
	edw	BXSI1D
	edw	BXSI2D
	edw	NoEffectiveAddress
	edw	BXDI0D
	edw	BXDI1D
	edw	BXDI2D
	edw	NoEffectiveAddress
	edw	BPSI0D
	edw	BPSI1D
	edw	BPSI2D
	edw	NoEffectiveAddress
	edw	BPDI0D
	edw	BPDI1D
	edw	BPDI2D
	edw	NoEffectiveAddress
	edw	DSSI0D
	edw	DSSI1D
	edw	DSSI2D
	edw	NoEffectiveAddress
	edw	DSDI0D
	edw	DSDI1D
	edw	DSDI2D
	edw	NoEffectiveAddress
	edw	DSXI2D
	edw	BPXI1D
	edw	BPXI2D
	edw	NoEffectiveAddress
	edw	BXXI0D
	edw	BXXI1D
	edw	BXXI2D
	edw	NoEffectiveAddress


ifdef	i386

glb	<EA386Tab>

eWORD	EA386Tab			; Uses |r/m|MOD| for indexing

	edw	Exx00			; eax
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; ecx
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; edx
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; ebx
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	SIB00			; esp (S-I-B follows)
	edw	SIB01
	edw	SIB10
	edw	NoEffectiveAddress
	edw	Direct386		; ebp (00 = direct addressing)
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; esi
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress
	edw	Exx00			; edi
	edw	Exx01
	edw	Exx10
	edw	NoEffectiveAddress

endif	;i386


glb	<ArithmeticOpTab>

eWORD	ArithmeticOpTab 	; Uses |Op| for indexing
	edw	ADDRQQ		;FADD
	edw	MUDRQQ		;FMUL
	edw	eFCOM		;FCOM
	edw	eFCOMP		;FCOMP
	edw	SUDRQQ		;FSUB
	edw	SVDRQQ		;FSUBR
	edw	DIDRQQ		;FDIV
	edw	DRDRQQ		;FDIVR


glb	<NonArithOpMemTab>

eWORD	NonArithOpMemTab	; Uses |Op| for indexing
	edw	eFLDsdri	;load(single/double,real/integer)
	edw	 UNUSED 	;reserved
	edw	eFSTsdri	;Store(single/double,real/integer)
	edw	eFSTPsdri	;Store and POP (single/double,real/integer)
	edw	 UNUSED 	;reserved
	edw	eFLDtempORcw	;Load(TempReal or LongInteger), FLDCW
	edw	 UNUSED 	;reserved
	edw	eFSTtempORcw	;Store(TempReal or LongInteger), FSTCW ,FSTSW


glb	<NonArithOpRegTab>

eWORD	NonArithOpRegTab	; Uses |Op| for indexing
	edw	eFLDregOrFFREE	;load(register), FFREE
	edw	eFXCHGreg	;FXCHG
	edw	eFSTreg 	;Store(register),FNOP
	edw	eFSTPreg	;Store and POP (register)
	edw	eMISCELANEOUS	;FCHS, FABS, FTST, FXAM, FINIT, FENI, FDISI, FCLEX
	edw	eFLDconstants	;FLD1, FLDL2T, FLDL2E, FLDPI, FLDLG2, FLDLN2, FLDZ
	edw	etranscendental ;F2XM1, FYL2X, FPTAN, FPATAN, FXTRACT, FDECSTP, FINCSTP
	edw	eVARIOUS	;FPREM, FYL2XP1, FSQRT, FRNDINT, FSCALE


glb	<FLDsdriTab>

eWORD	FLDsdriTab		; Uses |MF| for indexing
	edw	eFLDsr		;load single real
	edw	eFLDdi		;load double integer
	edw	eFLDdr		;load double real
	edw	eFLDsi		;load single integer


glb	<FSTsdriTab>

eWORD	FSTsdriTab		; Uses |MF| for indexing
	edw	eFSTsr		;store single real
	edw	eFSTdi		;store double integer
	edw	eFSTdr		;store double real
	edw	eFSTsi		;store single integer


glb	<FLDtempORcwTab>

eWORD	FLDtempORcwTab		; Uses |MF| for indexing
	edw	eFLDCW		;load control word
	edw	eFLDtemp	;load temp real
	edw	 UNUSED 	;reserved
	edw	eFLDlongint	;load long integer


glb	<FSTtempORcwTab>

eWORD	FSTtempORcwTab		; Uses |MF| for indexing
	edw	eFSTCW		;store control word
	edw	eFSTtemp	;store temp real
	edw	eFSTSW		;store status word
	edw	eFSTlongint	;store long integer


glb	<FLDconstantsTab>

eWORD	FLDconstantsTab 	; Uses |r/m| for indexing
	edw	eFLD1
	edw	eFLDL2T
	edw	eFLDL2E
	edw	eFLDPI
	edw	eFLDLG2
	edw	eFLDLN2
	edw	eFLDZ
	edw	 UNUSED 	;reserved


glb	<TranscendentalTab>

eWORD	TranscendentalTab	; Uses |r/m| for indexing
	edw	eF2XM1
	edw	eFYL2X
	edw	eFPTAN
	edw	eFPATAN
	edw	eFXTRACT
	edw	 UNUSED 	;reserved
	edw	eFDECSTP
	edw	eFINCSTP


glb	<VariousTab>

eWORD	VariousTab		; Uses |r/m| for indexing
	edw	eFPREM
	edw	eFYL2XP1
	edw	eFSQRT
	edw	 UNUSED 	;reserved
	edw	eFRNDINT
	edw	eFSCALE
	edw	 UNUSED 	;reserved
	edw	 UNUSED 	;reserved


glb	<COMtab>

eWORD	COMtab			;   SI	      DI
	edw	COMvalidvalid	; valid     valid
	edw	COMsignSI	; valid     zero
	edw	COMincomprable	; valid     NAN
	edw	COMsignDIinf	; valid     INF
	edw	COMsignDI	; zero	    valid
	edw	COMequal	; zero	    zero
	edw	COMincomprable	; zero	    NAN
	edw	COMsignDIinf	; zero	    INF
	edw	COMincomprable	; NAN	    valid
	edw	COMincomprable	; NAN	    zero
	edw	COMincomprable	; NAN	    NAN
	edw	COMincomprable	; NAN	    INF
	edw	COMsignSIinf	; INF	    valid
	edw	COMsignSIinf	; INF	    zero
	edw	COMincomprable	; INF	    NAN
	edw	COMinfinf	; INF	    INF


glb	<TSTtab>

eWORD	TSTtab
	edw	COMsignSI	; valid
	edw	COMequal	; zero
	edw	COMincomprable	; NAN
	edw	COMsignSIinf	; INF


glb	<ADDJMPTAB>

eWORD	ADDJMPTAB
eWORD	TAJRQQ
	edw	RADRQQ	    ; 0000 D Valid non-0, S Valid non-0
	edw	DDD	    ; 0001 D Valid non-0, S 0
	edw	SSINV	    ; 0010 D Valid non-0, S NAN
	edw	SSS	    ; 0011 D Valid non-0, S Inf
	edw	SSS	    ; 0100 D 0, S Valid non-0
	edw	DDD	    ; 0101 D 0, S 0
	edw	SSINV	    ; 0110 D 0, S NAN
	edw	SSS	    ; 0111 D 0, S Inf
	edw	DDINV	    ; 1000 D NAN, S Valid non-0
	edw	DDINV	    ; 1001 D NAN, S 0
	edw	BIGNAN	    ; 1010 D NAN, S NAN
	edw	DDINV	    ; 1011 D NAN, S Inf
	edw	DDD	    ; 1100 D Inf, S Valid non-0
	edw	DDD	    ; 1101 D Inf, S 0
	edw	SSINV	    ; 1110 D Inf, S NAN
	edw	INFINF	    ; 1111 D Inf, S Inf


glb	<MULJMPTAB>

eWORD	MULJMPTAB
eWORD	TMJRQQ
	edw	RMDRQQ	    ; 0000 D Valid non-0, S Valid non-0
	edw	ZEROS	    ; 0001 D Valid non-0, S 0
	edw	SSINV	    ; 0010 D Valid non-0, S NAN
	edw	INFS	    ; 0011 D Valid non-0, S Inf
	edw	ZEROS	    ; 0100 D 0, S Valid non-0
	edw	ZEROS	    ; 0101 D 0, S 0
	edw	SSINV	    ; 0110 D 0, S NAN
	edw	INDINV	    ; 0111 D 0, S Inf
	edw	DDINV	    ; 1000 D NAN, S Valid non-0
	edw	DDINV	    ; 1001 D NAN, S 0
	edw	BIGNAN	    ; 1010 D NAN, S NAN
	edw	DDINV	    ; 1011 D NAN, S Inf
	edw	INFS	    ; 1100 D Inf, S Valid non-0
	edw	INDINV	    ; 1101 D Inf, S 0
	edw	SSINV	    ; 1110 D Inf, S NAN
	edw	INFS	    ; 1111 D Inf, S Inf


glb	<DIVJMPTAB>

eWORD	DIVJMPTAB
eWORD	TDJRQQ
	edw	RDDRQQ	    ; 0000 D Valid non-0, S Valid non-0
	edw	ZEROS	    ; 0001 D Valid non-0, S 0
	edw	SSINV	    ; 0010 D Valid non-0, S NAN
	edw	INFS	    ; 0011 D Valid non-0, S Inf
	edw	DIV0	    ; 0100 D 0, S Valid non-0
	edw	D0INDINV    ; 0101 D 0, S 0
	edw	D0SSINV     ; 0110 D 0, S NAN
	edw	DIV0	    ; 0111 D 0, S Inf
	edw	DDINV	    ; 1000 D NAN, S Valid non-0
	edw	DDINV	    ; 1001 D NAN, S 0
	edw	BIGNAN	    ; 1010 D NAN, S NAN
	edw	DDINV	    ; 1011 D NAN, S Inf
	edw	ZEROS	    ; 1100 D Inf, S Valid non-0
	edw	ZEROS	    ; 1101 D Inf, S 0
	edw	SSINV	    ; 1110 D Inf, S NAN
	edw	INDINV	    ; 1111 D Inf, S Inf


glb	<XAMtab>

			    ; Tag Flag	C3 C2 C1 C0	 meaning
XAMtab	DB	04H	    ;  00  0	 0  1  0  0   Positive Normal
	DB	06H	    ;  00  1	 0  1  1  0   Negative Normal
	DB	40H	    ;  01  0	 1  0  0  0   Positive Zero
	DB	42H	    ;  01  1	 1  0  1  0   Negative Zero
	DB	01H	    ;  10  0	 0  0  0  1   Positive NAN
	DB	03H	    ;  10  1	 0  0  1  1   Negative NAN
	DB	05H	    ;  11  0	 0  1  0  1   Positive Infinity
	DB	07H	    ;  11  1	 0  1  1  1   Negative Infinity

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emdecode.asm ===
page	,132
	subttl	emdecode.asm - Instruction decoding
;***
;emdecode.asm - Instruction decoding
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Instruction decoding.
;	Further decoding of instructions done here.
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

ProfBegin  DECODE

	even

pub	eFLDsdri
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FLDsdriTab[2*ebx]
else
	JMP	FLDsdriTab[ebx]
endif

pub	eFSTsdri
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FSTsdriTab[2*ebx]
else
	JMP	FSTsdriTab[ebx]
endif

	even

pub  eFSTPsdri
	mov	bx, cx		; Dispatch on MF
	and	ebx, 6h

ifdef i386
	call	FSTsdriTab[2*ebx]
else
	call	FSTsdriTab[ebx]
endif
	mov	esi, [CURstk]
	cmp	esi, [BASstk]		   ; Do we have an empty stack?
	jbe	short FSTPSTUnder	   ;  Yes, Underflow.
FSTPSTOk:
	sub	esi, Reg87Len		   ; decrement SI to previous register
	mov	[CURstk], esi		   ; set current top of stack
	ret

FSTPSTUnder:
	call	UnderStk		   ;	stack underflow error
	jmp	FSTPSTOk


pub	eFLDtempORcw
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FLDtempORcwTab[2*ebx]
else
	JMP	FLDtempORcwTab[ebx]
endif

pub	eFSTtempORcw
	MOV	BX,CX		; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	JMP	FSTtempORcwTab[2*ebx]
else
	JMP	FSTtempORcwTab[ebx]
endif

pub	eFLDregOrFFREE		; We only emulate FLD ST (Duplicate TOS)
;CX = |Op|r/m|MOD|esc|MF|Arith|

	test	cx,06h		; test MF. MF=01 is FFREE, MF=00 is FLD ST(i)
	jnz	short jmpeFFREE ; go emulate FFREE
	jmp	eFLDreg 	; emulate FLD ST(i)
jmpeFFREE:
	jmp	eFFREE		; emulate FFREE ST(i)

pub	eMISCELANEOUS		; We only emulate FCHS, FABS, FTST, &  FXAM
				; FCLEX is emulated in non-IBM version
	TEST	CX,0806H	; We already have match on Op,MOD,&Arith
	jz	short MFzero	; MF = 0, must be FCHS, FABS, FTST or FXAM
				; check for FCLEX  (cx = 8B03)
	xor	cx,00203h	; toggle low bit of MF and middle bit of r/m
	test	cx,00603h	; test for zero in MF and r/m fields

	jnz	short jnzUNUSED ; MF <> 01 and/or r/m <> 010 => unemulated

	cmp	cx,8104h	; check for FSTSW AX
	je	short eFSTSWAX	;   yes

	mov	[StatusWord],0	; FCLEX: clear status word
	ret

pub eFSTSWAX
ifdef	XENIX
	xor	eax,eax 	; UNDONE - set to non-zero - cleanup code
else
	push	sp		; test for 286 !!!
	pop	ax
	cmp	ax,sp
endif
pub	jnzUNUSED
	jnz	UNUSED		;   UNUSED if not 286

	mov	ax,[StatusWord] ; FSTSW AX: save status word in AX
	mov	[ebp].regAX,ax	; overwrite AX stack entry
	ret

MFzero:
	TEST	CX,1000H
	JZ	short FABSorFCHS
	TEST	CX,0400H	;			r/m = 101 for FXAM
	JNZ	short JMPeFXAM	;			r/m = 100 for FTST
	JMP	eFTST

pub	JMPeFXAM
	JMP	eFXAM

pub	FABSorFCHS
	TEST	CX,0400H	;			r/m = 001 for FABS
	JNZ	short JMPeFABS	;			r/m = 000 for FCHS
	JMP	eFCHS

pub	JMPeFABS
	JMP eFABS

pub	eFLDconstants
	MOV	BL,CH		; Mov r/m field to BX for jump
	SHR	BL,1
	AND	ebx,0EH
ifdef	i386
	JMP	FLDconstantsTab[2*ebx]
else
	JMP	FLDconstantsTab[ebx]
endif

pub	eTranscendental
	MOV	BL,CH		; Mov r/m field to BX for jump
	SHR	BL,1
	AND	ebx,0EH
ifdef	i386
	JMP	TranscendentalTab[2*ebx]
else
	JMP	TranscendentalTab[ebx]
endif

pub	eVARIOUS
	MOV	BL,CH		; Mov r/m field to BX for jump
	SHR	BL,1
	AND	ebx,0EH
ifdef	i386
	JMP	VariousTab[2*ebx]
else
	JMP	VariousTab[ebx]
endif


pub	eFXCHGreg		; only valid FXCHG is with r/m = 001, MF = 00
	TEST	CX,06h		; only valid FXCHG is with MF = 0
	JNZ	short UNUSED	; unemulated
	JMP	eFXCHG		; emulate FXCH ST(i)


pub	eFSTPreg
	xor	cl,04h		; test for MF = 10, valid encoding of FSTP ST(x)
	test	cx,06h
	jne	short UNUSED	; MF <> 10, no such instruction
	mov	ax,1		; indicate stack should be popped after xfer
	jmp	eFST_Preg	; emulate FSTP ST(x)


;***	eFSTreg - decode FST ST(i),FNOP
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;
;	DESCRIPTION
;		All parts of the instruction except MF and r/m have already
;		been decoded.  If MF=0, the instruction is FNOP, which is
;		unemulated.  Otherwise, clear AX to indicate FST ST(i), then
;		jump to eFST_Preg, the common emulator routine for
;		FST ST(i) and FSTP ST(i).
;

eFSTreg:
	test	cl,06h		;test for MF = 0
	jz	short UNUSED	;MF=0 ==> FNOP, which is unemulated
				;otherwise this is FST ST(i)
	xor	ax,ax		;clear ax to indicate FST ST(i), not FSTP ST(i)
	jmp	eFST_Preg	; emulate FSTP ST(x)


; This sets the error flag indicating Unemulated functions

eFXTRACT:
eFDECSTP:
eFINCSTP:


ifdef  frontend 		; unused instructions for frontend version

eFLDL2T:
eFLDL2E:
eFLDPI:
eFLDLG2:
eFLDLN2:

eFPREM:
eF2XM1:
eFYL2X:
eFPTAN:
eFPATAN:
eFYL2XP1:
eFSQRT:

endif	;frontend

ifdef  SMALL_EMULATOR

eFLDL2T:
eFLDL2E:
eFLDPI:
eFLDLG2:
eFLDLN2:

eFPREM:
eF2XM1:
eFYL2X:
eFPTAN:
eFPATAN:
eFYL2XP1:
eFSQRT:

endif	;SMALL_EMULATOR


pub	UNUSED
	OR	[CURerr],Unemulated
	RET

ProfEnd  DECODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emexcept.asm ===
page	,132
	subttl	emexcept.asm - Microsoft exception handler
;***
;emexcept.asm - Microsoft exception handler
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Microsoft exception handler
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:  (Also see emulator.hst.)
;
;   12-08-89  WAJ   Add fld tbyte ptr [mem] denormal check.
;
;*******************************************************************************


;----------------------------------------------------------------------
;   Structure for FSTENV and FLDENV, Store and Load 8087 Environment
;----------------------------------------------------------------------

glb	<ENV_ControlWord,ENV_StatusWord,ENV_TagWord,ENV_IP>
glb	<ENV_Opcode,ENV_OperandPointer,ENV_ControlMask>
glb	<ENV_CallOffset,ENV_CallSegment,ENV_CallFwait,ENV_Call8087Inst>
glb	<ENV_CallLongRet>

ENV_DS			EQU	-4
ENV_BX			EQU	-2

ENV_ControlWord 	EQU	0
ENV_StatusWord		EQU	2
ENV_TagWord		EQU	4
ENV_IP			EQU	6
ENV_Opcode		EQU	8
ENV_OperandPointer	EQU	10
ENV_ControlMask 	EQU	16

ENV_Temp		EQU	18	; Note ENV_Temp occupies

ENV_CallOffset		EQU	18	; the same space as ENV_Call*.
ENV_CallSegment 	EQU	20	; This is possible because there
ENV_CallFwait		EQU	22	; is never simultaneous use of
ENV_Call8087Inst	EQU	23	; this space
ENV_CallLongRet 	EQU	25

ENV_OldBP		EQU	28
ENV_OldAX		EQU	30
ENV_IRETadd		EQU	32

ENV_Size		EQU	28

; UNDONE	386 version is bad - 387 environment is longer

PAGE
;----------------------------------------------------------------------------
;
; 8087 EXCEPTION  HANDLER  - Fields 8087 stack over flow and under flow.
;
;----------------------------------------------------------------------------
;
;	I. The 8087 state vector.
;
;	Upon the execution of a FSAVE or FSTENV instruction the state of the
;	8087 is saved in a user defined state vector.  The first seven words
;	saved in the state vector by the two instructions are identical. The
;	definition of the words is:
;
;	Word.  Bits.	       Bytes.  Function.
;	-----  -----	       ------  ---------
;	0      15..0	       1..0    Control word.
;	1      15..0	       3..2    Status	word.	 (   8087  stack
;				       pointer and   condition	  codes.
;	2      15..0	       5..4    Tag word  ( 8087 stack slot usage
;				       flags ).
;	3      15..0	       7..6    Instruction pointer.	Operator
;				       segment offset.
;	4      15..12	       8       Operator paragraph   bits   (   (
;				       bits 16..19  )  of   address   ).
;	4      11	       8       Always zero.
;	4      10..8	       8       Upper opcode bits ( major opcode ).
;	4      7..0	       9       Lower opcode bits ( minor opcode ).
;	5      15..0	       11..10  Operand Segment offset.
;	6      15..12	       12      Operand paragraph bits.
;	6      11..0		       Not used. Must be zero.
;
;	II.  Restarting instructions.
;
;	Of interest in this  handler  is  the  necessity  of  restarting
;	8087 instructions  which  fail	because  of  8087 stack overflow
;	and underflow.	Even though the 8087  saves  enough  information
;	to restart  an	instruction,  it  is incapable of doing so.  The
;	instruction restart must be done in software.
;
;	There are two cases which must be  considered  after  the  stack
;	exception has been dealt with.
;
;	1.  The faulting instruction deals with top of stack.
;	2.  The faulting instruction deals with memory.
;
;	The first  case  is  handled  by  changing the upper five bits (
;	15..11 ) of vector word four ( 4 ) to  "11011B".   This  changes
;	word  four  into  an  "escape  opcode"	8087  instruction.   The
;	modified opcode is placed in  the  interrupt  code  segment  and
;	executed.
;
;	The second  case  is  handled  by  changing  the upper five bits
;	( 15..11 ) of vector word four	(  4  )  to  "11011B",	changing
;	the MOD  of  the  opcode  to  "00B"  ( 0 displacement ), loading
;	the operand address into DS:SI, and changing  the  RM  field  of
;	the   opcode  to  "100B"  (SI+DISP  addressing).   The	faulting
;	instruction may be restarted as above.
;
;	Instruction restart  may  also	be  accomplished  by building an
;	instruction stream  in	the  interrupt	stack  and  calling  the
;	instruction stream  indirectly.   This	method	is the preferred
;	method because it is reentrant.
;
;	III. Data Segment Considerations.
;
;	DS is restored from the task interrupt vector.	DS is used for
;	stack overflow memory.
;
;
; Documentation of the invalid exception handling code for the stand-alone
; 8087/80287 emulator
;
; The emulator software is being enhanced for the cmerge 4.0 generation of
; languages to support a larger subset of the numeric processor instruction
; set.	In addition to providing instructions which were not previously
; emulated, the model for representing the numeric processor stack is also
; being modified.  The 4.0 languages and their predecessors are object compat-
; ible so it will be possible for programs to be developed which will contain
; code generated by the old model as well as the new model.  For this reason
; it is important to understand the characteristics of both models and how
; the two models will interact.
;
; I.  The Old Model:  Infinite Stack
;
; The old model used an infinite stack model as the basis of its
; emulation of the numeric processor.  Only the classical stack form of
; instructions with operands were emulated so only ST(0) (top of stack)
; and ST(1) (next to top of stack) were referenced by any given instruction.
; In addition, the stack was allowed to overflow beyond the eight registers
; available on the chip into a memory stack overflow area.  The code genera-
; tor did not attempt to maintain all of its register data in the first eight
; register slots but instead made use of this overflow area.  In order to
; maintain compatible behavior with or without the presence of the chip, this
; model made it necessary to handle and recover from stack overflow exceptions
; in the case where the chip is present as well as when it is being emulated.
;
; This stack overflow exception handling could in turn generate a recoverable
; stack underflow exception since a situation could arise where a desired
; operand had been pushed into the memory overflow area (during stack overflow)
; and was not available in the on-chip register area when needed.  This
; scenario would signal an invalid exception due to stack underflow.
; It is recoverable because the required operand is still available in the
; overflow area and simply needs to be moved into a register on the chip.
;
; II.  The New Model:  Finite Stack
;
; The new model uses a finite stack model:  only the eight registers on the
; chip are available for use, so in the new model the invalid exception
; would never be signalled due to stack overflow.  In addition, it extends
; the emulated instruction set to include the general register form of
; instructions with operands (operands can be ST(i),ST or ST,ST(i)).  Since
; the new code generator is aware of how many items it has placed on the stack,
; it does not allow stack overflow or stack underflow to occur.  It can remove
; items from the registers either by storing to memory (FST or FSTP), or by
; using FFREE to mark the register as empty (this instruction is being added
; to the emulated instruction set).  The new model uses FFREE in a well-defined
; manner:  it will only free registers from the boundaries of the block of
; registers it is using.  For example, if the new code is using ST(0)-ST(6),
; it must free the registers in the order ST(6),ST(5),ST(4),... and so on.
; It cannot create gaps of free registers within the block of registers
; it is using.
;
; III.	The Hybrid Model:  Combination of New and Old Code
;
; Due to the possibility of mixture of code generated using both of the above
; models, the new exception handling and emulation software has to be able to
; handle all situations which can arise as a result of the interaction of the
; two models.  The following summarizes the behavior of the two models and
; restrictions placed on their interaction.
;
;	New Code:
;
;	1.  Cannot call anyone with any active entries on the stack.
;	    The new model is always at a conceptual stack level of zero
;	    when it makes external calls.  Thus old code will never
;	    incorrectly make use of register data that was placed on the
;	    register stack by new code.
;
;	2.  May create gaps of free registers in the register stack.
;	    It will not create gaps in the memory stack overflow area.
;
;	3.  Only causes stack overflow by pushing old code entries off of
;	    the register stack and into the memory stack overflow area.
;	    It will never overflow its own entries into the memory stack
;	    overflow area.
;
;	4.  Cannot cause stack underflow.
;
;
;	Old Code:
;
;	1.  Can only reference ST(0), ST(1).
;
;	2.  Can cause stack overflow by pushing too many entries onto the
;	    register stack.
;
;	3.  Can cause stack underflow in two situations:
;
;	    a.	It is trying to get something that is in the memory stack
;		overflow area (stack overflow occurred previously).
;
;	    b.	There are free entries on the chip.  This situation could
;		arise if new code creates free entries then calls old code,
;		so this is a situation that could not have existed before
;		the new model was introduced.
;
; IV.  Stack Overflow/Underflow Exception Handling
;
; The following algorithms will be used for detecting and recovering from
; stack overflow and underflow conditions (signalled via the invalid
; exception).  All invalid exceptions are "before" exceptions so that
; the instruction has to be reexecuted once the exception has been handled.
;
;	A.  Stack Overflow
;
;	If ST(7) is used (possible stack overflow) then {
;	    check for instructions which could cause stack overflow
;		(includes FLD,FPTAN,...)
;	    if instruction could cause stack overflow then {
;		save ST(7) in stack overflow area at [CURstk]
;		mark ST(7) empty
;		if FLD ST(7) instruction then
;		    FLD [CURstk] or rotate chip (clear exceptions)
;		else reexecute the instruction with ST(7) empty
;		}
;	    }
;
;	B.  Stack Underflow
;
;	If ST(0) is free then assume stack underflow since the stack
;		overflow case has already been handled (if the invalid
;		is due to a denormal exception, the exception will occur
;		again when the instruction is reexecuted):
;
;		if chip has any registers in use (check the tag word) then {
;		    rotate chip until ST(0) is not empty
;		    rotate tag word to reflect state of chip
;		    }
;		else (no registers in use)
;		    if operand is in stack overflow area then {
;			load into ST(0) from stack overflow area
;			mark ST(0) full
;			}
;		    else {
;			indicate true stack underflow
;			go print error
;			}
;		if ST(1) is  empty then {
;		    if any of ST(2) thru ST(7) are in use then {
;			rotate chip until ST(1) is not empty
;			    (to share code with first chip rotation above:
;			    store pop st(0) into temp
;			    rotate chip until st(0) is not free
;			    load st(0) back onto chip)
;			update tag word appropriately
;			}
;		    else
;			load ST(1) from overflow area if there
;		    }
;
;	At this point, ST(0) and ST(1) have been filled if possible.
;	Now we must categorize the instructions to determine which
;	of these is required.  Then we will either issue true stack
;	underflow or reexecute the instruction with the compressed
;	stack.
;----------------------------------------------------------------------------
;
; References:
;	Intel 8086 Family Numerics Supplement. 121586-001 Rev A.
;	Intel iAPX 86,88 User's Manual.
;
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;
;	All registers must be saved by __FPEXCEPTION87 except CS,IP,SS,SP.
;
;----------------------------------------------------------------------------


ifdef WINDOWS
;	stack consists of IRET frame and status word before FCLEX
;
;	Since the environment is different in protect mode, reconstruct
;	the opcode like in real mode.

lab protiret
	iret

lab protexskipsegovr
	inc	bx			; bump past segment override
	jmp	short protexsegovr	; try again

public __FPEXCEPTION87P
__FPEXCEPTION87P:
lab protexception
	push	eax			; save user ax
	push	ebp
	sub	esp,ENV_Size		; get Enough bytes for Environment
	mov	ebp,esp 		; set up for rational offsets.
	fstenv	word ptr [ebp]		; save environment.

	mov	eax,offset protiret	; set up for near return address
	xchg	ax,[ebp+ENV_Size+4]	; swap status word and near ret addr
	mov	ENV_StatusWord[ebp],ax	; save status word into environment

	push	ebx
	push	ds			; save a few more registers

	lds	ebx,dword ptr ENV_IP[ebp] ; get address of instruction
lab protexsegovr
	mov	ax,[ebx]		; get 1st 2 bytes of instruction
	add	al,28h			; add -(ESC 0)
	jnc	protexskipsegovr	;   wasn't ESC - skip seg. override
	xchg	al,ah			; swap bytes to make real opcode
	mov	ENV_Opcode[ebp],ax	; save it in environment

	sti
	jmp	short exceptionhandler
endif	;WINDOWS



ifdef	DOS5
;	stack consists of IRET frame and status word before FCLEX
;
;	Since the environment is different in protect mode, reconstruct
;	the opcode like in real mode.

lab protiret
	iret

lab protexskipsegovr
	inc	bx			; bump past segment override
	jmp	short protexsegovr	; try again

lab protexception
	push	eax			; save user ax
	push	ebp
	sub	esp,ENV_Size		; get Enough bytes for Environment
	mov	ebp,esp 		; set up for rational offsets.
	fstenv	word ptr [ebp]		; save environment.

	mov	eax,offset protiret	; set up for near return address
	xchg	ax,[ebp+ENV_Size+4]	; swap status word and near ret addr
	mov	ENV_StatusWord[ebp],ax	; save status word into environment

	push	ebx
	push	ds			; save a few more registers

	lds	ebx,dword ptr ENV_IP[ebp] ; get address of instruction
lab protexsegovr
	mov	ax,[ebx]		; get 1st 2 bytes of instruction
	add	al,28h			; add -(ESC 0)
	jnc	protexskipsegovr	;   wasn't ESC - skip seg. override
	xchg	al,ah			; swap bytes to make real opcode
	mov	ENV_Opcode[ebp],ax	; save it in environment
endif	;DOS5

ifdef	DOS3and5
	jmp	short exceptionhandler
endif	;DOS3and5


ifdef	DOS3
	public	__FPEXCEPTION87

__FPEXCEPTION87:
	PUSH	AX			; Save user's AX next to IRET
	PUSH	BP
	SUB	SP,ENV_Size		; Get Enough bytes for Environment
					; 8087 status.
	MOV	BP,SP			; Set up for rational offsets.

	;Caveat Programmer!
	;FSTENV does an implicit set of all exception masks.

	FNSTENV WORD PTR [BP]		; Save environment.
	FCLEX				; Clear exceptions.
	STI				; Restore host interrupts.

	PUSH	BX
	PUSH	DS			; Need access to user data
endif	;DOS3

;----------------------------------------------------------------------------
;   In	a  multitasking  environment  one  would  not  want  to  restore
;   interrupts at this point.  One would wait until the  8087  had  been
;   flushed and any operand data copied to a storage area.
;----------------------------------------------------------------------------

	;---------------
	; Inside of the while exception loop and Redo8087Instruction
	; registers AX and BX must contain the values as described
	; below:

	; AL bit 0 = 1 indicates invalid exception
	;    bit 1 = 1 indicates denormal exception
	;    bit 2 = 1 indicates divide by zero exception
	;    bit 3 = 1 indicates numeric overflow
	;    bit 4 = 1 indicates numeric underflow
	;    bit 5 = 1 indicates precision loss
	;    bit 6 = unused by 8087
	;    bit 7 = 1 indicates sqrt of negative number
	;		(this flag is not from the NPX status word, but
	;		 is set after all other exceptions have been
	;		 handled if the opcode is FSQRT)

	; AH bit 0 = unused
	;    bit 1 = 1 indicates stack overflow
	;    bit 2 = 1 indicates stack underflow
	;    bit 3 = unused
	;    bit 4 = unused
	;    bit 5 = 1 indicates memory operand
	;    bit 6 = 1 indicates instruction was reexcuted
	;    bit 7 = 1 indicates ST relative operand

	; BL = The complement of the exception masks copied from
	;      UserControlWord altered so that Denormal and Invalid
	;      exceptions are always unmasked, while the reserved
	;      bits are masked.

	; BH bit 0 = 1 indicates 8087 only invalid handling complete
	;    bit 1 = 1 indicates 8087 only denormal handling complete
	;    bit 2 = 1 indicates 8087 only divide by zero handling complete
	;    bit 3 = 1 indicates 8087 only numeric overflow handling complete
	;    bit 4 = 1 indicates 8087 only numeric underflow handling complete
	;    bit 5 = 1 indicates 8087 only precision loss handling complete
	;    bit 6 = unused
	;    bit 7 = unused
	;
	; Algorithm: Handle 8087 exceptions which do not occur in the
	; emulator and then jump to the common exception handling code.
	;
	; To handle 8087 only exceptions we must first determine if the
	; exception occured before the 8087 executed the instruction
	; or afterward.  Invalid, denormal (except FLD) and divide by
	; zero exceptions all occur before 8087 instruction execution,
	; others occur afterward.  "Before" exceptions must set the
	; "before" flag in AH and then reexecute the instruction.  After
	; reexecution (while all exceptions are masked) all of the
	; exceptions resulting from the current 8087 instruction will
	; be known and can be handled as a group.  "After" exceptions
	; are handled individually since reexecution of an already
	; executed instruction will destroy the validity of the 8087 stack.
	; A flag in AH is used by Redo8087instruction to avoid reexecuting
	; an instruction twice.   At the beginning of Redo8087instruction
	; the flag is checked, and if it is set the instruction is not
	; redone.
	;
	; "Before" exceptions must be reexecuted because it is
	; difficult to determine stack over/underflow if reexecution
	; is not performed.  Stack over/underflow is signaled by
	; an invalid exception.  The current algorithm for stack over/
	; underflow detection is as follows:
	;
	;	...
	;
	;---------------

ProfBegin EXCEPT

lab exceptionhandler


ifdef	MTHREAD			
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS; trashes AX
else	;MTHREAD

ifdef	standalone
	XOR	AX,AX			; Prepare to access vector, clear flags
	MOV	DS,AX
	MOV	DS,DS:[4*TSKINT+2]	; DS = emulator task data segment

elseifdef  _COM_
	mov	ds, [__EmDataSeg]
	xor	ax,ax

else
	mov	ax, edataBASE
	mov	ds,ax
	xor	ax,ax
endif

endif	;MTHREAD

	MOV	AL,ENV_StatusWord[eBP]	; Get 8087 status flags.
	XOR	BH,BH			; Clear out 8087 handling flags

;----------------------------------------------------------------------------
;
;   Can the interrupt be serviced by this routine?  Dispatch exceptional
;   conditions.
;
;   Multi-pass algorithm
;	Handle exception and reexcute instruction if necessary
;	Loop back to WhileException and handle additional exceptions
;
;	AX = status before exception handling
;	BX = flag indicating exception handled
;
;----------------------------------------------------------------------------

	cmp	[ExtendStack], 0	; check if the extended stack was
	jne	WhileException		;  turned off.

	or	bh, Invalid

lab WhileException

ifndef	_NOSTKEXCHLR			; no stack overflow/underflow handler
	TEST	BH,Invalid		; stack over/underflow already handled?
	JNZ	short NotOverUnderflow	; Yes - forget stack over/underflow
	TEST	AL,Invalid		; Invalid exception?
	JZ	short NotOverUnderflow	; No - bypass over/underflow checking
	OR	BH,Invalid		; Indicate stack over/undeflow checked
	JMP	ProcessOverUnderflow	; See about stack over/underflow
endif	;_NOSTKEXCHLR			

lab NotOverUnderflow

; Either the exception was not an invalid or stack over/underflow has
; already been handled.

; check for denormal exception - completely resolved on pass 1

	TEST	AL,Denormal		; Denormal exception?
	JZ	short NotDenormal	; No - bypass denormal handling
	JMP	ProcessDenormal 	; Process the denormal

lab NotDenormal

; check for zero divide exception

	TEST	BH,ZeroDivide		; Divide by zero already handled?
	JNZ	short NotZeroDivide	; Yes - bypass divide by zero handling
	TEST	AL,ZeroDivide		; Divide by zero exception?
	JZ	short NotZeroDivide	; No - bypass divide by zero handling
	OR	BH,ZeroDivide		; Indicate divide by zero handled

	CALL	ReDo8087Instruction	; Process divide by zero exception
	JMP	WhileException

lab NotZeroDivide

; check for numeric overflow exception

	TEST	BH,Overflow		; Overflow already handled?
	JNZ	short AllExceptionsHandled ; Yes - bypass overflow handling
	TEST	AL,Overflow		; Overflow exception?
	JZ	short AllExceptionsHandled ; No - bypass overflow handling
	OR	BH,Overflow		; Indicate overflow handled
	JMP	ProcessNumericOverflow	; Process numeric overflow


lab AllExceptionsHandled

; We have already handled any exceptions which require instruction
; reexecution.
; At this point 8087 instruction reexecution is done.  We need
; to extract a little more information for error message
; generation.

	MOV	BL, BYTE PTR UserControlWord	; 8087 exception masks
	OR	BL, 0C0H		; Mask reserved

	AND	BL, 0FDH		; Unmask denormal. DON'T unmask invalid
					; here. (Otherwiae user has no way of
					; masking invalids.)

	NOT	BL			; complement
	AND	AL, BL			; eliminate all masked exceptions
					; from AL
	TEST	AL,Invalid		; Possibly square root of neg?
	JZ	short NotFLDshortorlongNaN ; No - don't set square root flag
	PUSH	AX			; ... Use AX as scratch ...
	MOV	AX,ENV_Opcode[eBP]	; Get the instruction op code
	AND	AH,7			; Mask off the junk
	CMP	AX,001FAh		; Square root op code?
	JNE	short NotSquareRootError   ; No - don't set square root flag
	POP	AX			; ... Restore AX ...
	OR	AL,SquareRootNeg	; Set the square root flag
	JMP short NotFLDshortorlongNaN

;-----------------------------------------------------------------------------
; Test for invalid exception caused by an FLD of a NaN underflow or overflow.
;-----------------------------------------------------------------------------
lab NotSquareRootError		    ; Next check for FLD of a NaN
					; (only happens for SNaNs on
					; the 80387; not for 8087/287)
	MOV	AX,ENV_Opcode[eBP]
	AND	AX,0338h		; Mask off the inessential bits
	CMP	AX,0100h		; Check for possible FLD 
					; of short/long real from memory.
					; We are assuming that an invalid
					; exception means FLD of a NaN
					; since stack over/under-flow
					; has already been dealt with.
					; (we don't handle FLD ST(n) or
					; FLD temp real in this way)
	POP	AX			; ... Restore AX ...
	JNE	short NotFLDshortorlongNaN

	;
	; (MOD==11 case: no special code)
	; We don't handle FLD ST(n) here since it isn't properly 
	; handled in our stack overlow checking code either and
	; it doesn't generate an invalid in the case of an SNaN
	; without a stack overflow;  FFREE ST(n) will not cause
	; an Invalid exception.
	;
	; FLD TBYTE PTR ... shouldn't cause an Invalid due to a NaN
	;

	XOR	AL,Invalid		; Turn off invalid exception.
					; There should be a NaN in ST(0);
					; we will just leave it there.
	
lab NotFLDshortorlongNaN
	FCLEX
	FLDCW	ENV_ControlWord[eBP]	; Restore original Control Word

lab CleanUpHost
	or	[UserStatusWord],ax	; OR into user status word
	POP	DS
	POP	eBX
	ADD	eSP,ENV_Size		; Point to users BP
	POP	eBP
	TEST	AX,0FFFFh-Reexecuted	; exceptions?
	JNZ	Exceptions8087		; Process other exceptions as emulator
	POP	eAX			; Now just IRET address on stack
	ret				; return to OEM interrupt exit routine

lab Exceptions8087
; toss OEM routine return address

	push	eax
	push	ebx
	mov	ebx,esp

; UNDONE - this does not work for 386

	mov	eax,ss:[ebx+4]		; get original AX
	mov	ss:[ebx+6],eax		; overwrite OEM routine return address
	pop	ebx
	pop	eax

ifdef	i386
	add	esp,4			; remove original AX
else
	add	sp,2			; remove original AX
endif
	JMP	CommonExceptions

PAGE
;-----------------------------------------------------------------------------
; Test for stack underflow or overflow.
;-----------------------------------------------------------------------------

	; There are eight sets of tag bits in the tag  word.   Each  set
	; denotes the state of one of the 8087 stack elements.

	; 00 - normal
	; 01 - true zero
	; 10 - special: nan,infinity,unnormal
	; 11 - empty

	; If all are empty we have underflow, if all are full we have overflow

	; There was an invalid exception: check to see if it was stack
	; overflow or underflow.

	; Register usage in this code block:
	;	BX = tag word, complemented
	;	CL = NPX stack ptr

ifndef	_NOSTKEXCHLR			; no stack overflow/underflow handler
lab ProcessOverUnderflow
	PUSH	eSI
	PUSH	eBX			; Make room for local temps
	PUSH	eCX
	PUSH	eDX
	PUSH	eDI

	MOV	BX,ENV_TagWord[eBP]	; Get tag word.
	MOV	CX,ENV_StatusWord[eBP]	; Get status word
	NOT	BX			; Tag zero means empty, else full
	MOV	CL,CH			; Get stack pointer into CL
	AND	CL,038h 		; Mask to stack pointer
	SHR	CL,1
	SHR	CL,1			; compute number of bits to shift
	ROR	BX,CL			; tag ST(0) in low BL.

	; To service stack overflow we must make sure there is an empty space
	; above the top of stack before the instruction is reexecuted.	If
	; after reexecution we again get an invalid exception, then we
	; know there was something besides stack overflow causing the invalid
	; exception.

	; We check for stack overflow by seeing if ST(7) is empty.  We make
	; the check by testing the complemented, rotated tag word in BX.

	TEST	BH,0C0h 		; Possible stack overflow?
	JZ	short StackUnderflowCheck ; No - bypass offloading stack

	; ST(7) is not empty, so we may have stack overflow.  We verify that
	; we have stack overflow by looking at the instruction to be sure
	; that it can generate stack overflow (i.e., it puts more stuff on
	; the stack than it removes).
	; Note that a subset of the 287 instruction set is being decoded
	; here; only those instructions which can generate invalid exceptions
	; get to this point in the code (see Table 2-14 in the Numeric
	; Supplement for list of instructions and possible exceptions).
	;
	; The instructions which can generate stack overflow are:
	;	all memory FLDs,FILDs,FBLDs,constant instructions,
	;	FPTAN and FXTRACT

	MOV	DX,ENV_Opcode[eBP]	; Get the instruction op code
	XOR	DX,001E0h		; Toggle arith, mod and special bits

; Test for mod of 0,1, or 2 (indicates memory operand)

	TEST	DL,0C0h 		; Memory operand instruction?
	JNZ	short MemoryFLDCheck	; Yes - go see what kind

; Test bits 5 & 8 of instruction opcode: of remaining instructions, only those
; with stack relative operands do NOT have both of these bits as 1 in the opcode
; (remember these bits are toggled).

	TEST	DX,00120h		; ST Relative Op group?
	JNZ	short StackUnderflowCheck ; Yes - ST Relative Ops
					; cannot cause stack overflow

; Test bit 4 of the instruction opcode: of remaining instructions, only the
; transcendentals have this bit set.

	TEST	DL,010h 		; Constant or arith instruction?
	JNZ	short TransCheck	; No - must be Transcendental

; Test bit 3 of the instruction opcode: of remaining instructions, only the
; constant instructions have this bit set.

	TEST	DL,008h 		; Constant instruction?
	JNZ	short StackOverflowVerified ; Yes, can cause stack overflow

; The instructions which get to this point are FCHS, FABS, FTST and FXAM.
; None of these can cause stack overflow.

	JMP	StackUnderflowCheck	; so go check for stack underflow

lab TransCheck

; The instruction was a transcendental.  Of the transcendentals, only
; FPTAN and FXTRACT can cause stack overflow, so check for these.

	CMP	DL,012h 		; is this FPTAN
	JE	short StackOverflowVerified ; yes, can cause stack overflow
	CMP	DL,014h 		; is this FXTRACT
	JE	short StackOverflowVerified ; yes, can cause stack overflow
	JMP	StackUnderflowCheck	; not either one, won't cause overflow

lab MemoryFLDCheck
	TEST	DX,00110h		; FLD memory instruction?
	JNZ	short StackUnderflowCheck ; no - go check for stack underflow

lab StackOverflowVerified

	; ST(7) was not empty and the instruction can cause stack overflow.
	; To recover from stack overflow, move ST(7) contents to the
	; stack extension area, modifying the tag word appropriately.

	AND	BH,0FFh-0C0h		; Indicate 1st above TOS is free
	PUSHST				; Let PUSHST make room for value.
	FDECSTP 			; Point to bottom stack element.
	FSTP	TBYTE PTR [eSI] 	; Store out bottom stack element.
	JMP	InvalidReexecute	; No - reexecute instruction

lab StackUnderflowCheck

	; To service stack underflow we must make sure all the operands the
	; instruction requires are placed on the stack before the instruction
	; is reexecuted.  If after reexecution we again get an invalid
	; exception, then its due to something else.

	TEST	BL,003h 		; Is ST(0) empty?
	JZ	short UFMemoryFLDcheck	; yes - first check for memory FLD
	JMP	ST1EmptyCheck		; No - Let's try to fill ST(1), too.
					; We may need it!

	;
	; This block of code is for making sure that FLD memory operand is not
	; among those instructions where stack underflow could occur; this is
	; so FLD of SNaN can be detected (under the AllExceptionsHandled 
	; section) for the case of the 80387.
	;

lab UFMemoryFLDcheck
	MOV	DX,ENV_Opcode[eBP]	; Get the instruction opcode
	XOR	DX,001E0h		; Toggle arith, mod and special bits		
	TEST 	DL,0C0h			; Memory operand instruction?
	JZ	ST0Empty		; No - continue underflow processing
					; Try to fill ST(0)
	TEST	DX,00110h		; FLD memory instruction?
	JNZ	ST0Empty		; No - continue underflow processing
					; Try to fill ST(0)
	JMP	ST1EmptyCheck		; Let's try to fill ST(1), too.
					; We may need it!
	
	; Formerly we did JMP InvalidReexecute here; but this caused
	; an "invalid" to be reported for instructions with two stack
	; operands.  (Doing JMP ST1EMptyCheck fixes this bug: 
	; Fortran 4.01 BCP #1767.)  
	;
	; This fixes the underflow-handling case of instructions 
	; needing both ST0 and ST1 under the conditions that ST0 
	; is full but ST1 is empty.


lab ST0Empty

	; assume stack underflow since ST(0) is empty and we did not have
	; stack overflow

	OR	BX,BX			; Are any registers on the chip in
					; use? (BX = 0 if not)
	JZ	short LoadST0FromMemory ; No, load ST(0) from memory stack
	CALL	RotateChip		; yes, then point ST(0) at first
					; valid register and update tag in BX
	JMP	ST1EmptyCheck		; go check if ST(1) is empty

lab LoadST0FromMemory
	MOV	eSI,[CURstk]		; Get pointer to memory stack
	CMP	eSI,[BASstk]		; Anything in memory to load?
	JNE	short LoadST0		; Yes, go load it
	JMP	TrueUnderflow		; No, go issue error

lab LoadST0
	OR	BL,003h 		; Indicate ST(0) is full
	FINCSTP 			; Avoid altering stack pointer.
	FLD	TBYTE PTR [eSI] 	; Load value from memory.
	POPST				; Let POPST decrement memory pointer.

lab ST1EmptyCheck
	TEST	BL,00Ch 		; Is ST(1) empty?
	JNZ	short EndST1EmptyCheck	; No - so don't load from memory

	MOV	SI,BX			; move tag word to SI
	AND	SI,0FFF0h		; mask off ST(0),ST(1)
	OR	SI,SI			; Are any of ST(2)-ST(7) in use?
					; (SI = 0 if not)
	JZ	short LoadST1FromMemory ; No, try to get ST(1) from memory
	FSTP	TBYTE PTR [REG8087ST0]	; offload ST(0) temporarily
	SHR	BX,1
	SHR	BX,1			; ST(1) becomes ST(0) in tag word
	CALL	RotateChip		; get 1st in-use register into ST(1)
	FLD	TBYTE PTR [REG8087ST0]	; reload ST(0)
	SHL	BX,1
	SHL	BX,1			; adjust tag word for reloaded ST(0)
	OR	BL,003h 		; Indicate ST(0) is full
	JMP	SHORT EndST1EmptyCheck	; ST(0) and ST(1) are full

lab LoadST1FromMemory
	MOV	eSI,[CURstk]		; Get pointer to memory stack
	CMP	eSI,[BASstk]		; Anything in memory to load?
	JE	short EndST1EmptyCheck	; No, so don't load it.

	OR	BL,00Ch 		; Indicate ST(1) is full
	FINCSTP 			; Point to ST(1)
	FINCSTP 			; Point to ST(2)
	FLD	TBYTE PTR [eSI] 	; Load value from memory into ST(1).
	FDECSTP 			; Point to ST(0)
	POPST				; Let POPST decrement memory pointer.

lab EndST1EmptyCheck

; At this point we know that ST(0) is full.  ST(1) may or may not be full
; and may or may not be needed.
; Now we look at the instruction opcode and begin categorizing instructions
; to determine whether they can cause stack underflow and if so, whether
; they require ST(0) only or ST(1) as well.

	MOV	DX,ENV_Opcode[eBP]	; Get the instruction op code
	XOR	DX,001E0h		; Toggle arith, mod, and special bits

; Test for mod of 0,1, or 2 (indicates memory operand)

	TEST	DL,0C0h 		; Memory operand instruction?
	JNZ	short StackUnderflowServiced  ; Yes, then stack underflow cannot
					; be a problem since memory instructions
					; require at most one stack operand
					; and we know that ST(0) is full

; Test bits 5 & 8 of instruction opcode: of remaining instructions, only those
; with stack relative operands do NOT have both of these bits as 1 in the opcode
; (remember these bits are toggled).

	TEST	DX,00120h		; ST Relative Op group?
	JNZ	short STRelativeOpGroup ; Yes - ST Relative Ops

lab ConstOrTrans

; Test bit 4 of the instruction opcode: of remaining instructions, only the
; transcendentals have this bit set.

	TEST	DL,010h 		; Constant or arith instruction?
	JNZ	short TranscendentalInst ; No - must be Transcendental

; The instructions that get to here are the constant instructions and
; FCHS, FABS, FTST and FXAM.  The constant instructions do not have any
; stack operands; the others require ST(0) which we know is valid.
; Therefore, none of the remaining instructions can cause stack underflow.

lab StackUnderflowServiced
	JMP	InvalidReexecute	; Stack underflow corrected
					; reexecute instruction

lab TranscendentalInst
; Transcendentals may require one or two stack elements as operands.
; Here we decide whether or not ST(1) needs to be present.

	MOV	CL,DL			; Need low op code in CL
	AND	CL,00Fh 		; Mask to low four bits

; Read the next block of comments column-wise.	It shows the transcendental
; instructions represented by each bit in the constant loaded into DX below.
; Note: as it turns out, of the instructions requiring two operands below,
; only FSCALE and FPREM generate invalid exceptions when the second operand
; is missing.
	;	   FFFFFRFFFFFRFFRR
	;	   2YPPXEDIPYSERSEE
	;	   XLTATSENRLQSNCSS
	;	   M2ATRECCE2REDAEE
	;	   1XNAARSSMXTRILRR
	;	   ...NCVTT.P.VNEVV
	;	   ....TEPP.1.ET.EE
	;	   .....D.....D..DD

	MOV	DX,0101000011000100b	; 1's for 2 operand instructions

	SHL	DX,CL			; Get corresponding bit into sign
	JNS	short StackUnderflowServiced  ; If just ST(0) needed we're O.K.

	TEST	BL,00Ch 		; ST(1) full?
	JNZ	short StackUnderflowServiced  ; Yes - stack underflow no problem

lab STRelativeOpGroup

; The following code block handles the general operand ST(x) even though
; the original code generator only uses ST(0) and ST(1) as operands.
; The current code generator uses ST(x) but will never cause stack underflow
; exceptions.

	AND	DX,00007h		; Mask to relative register number
	SHL	DL,1			; Compute tag word shift amount
	MOV	CX,DX			; Get amount into CL
	MOV	DX,BX			; Get tag into DX
	ROR	DX,CL			; Shift operand tag into low DL
	TEST	DL,003h 		; Is operand register empty?
	JNZ	short InvalidReexecute	; No - go reexecute

; The following conditions could cause a true underflow error to be
; erroneously generated at this point:
; FST ST(x) signals an invalid because ST(0) is empty.	ST(0) gets filled
; by the stack underflow recovery code in this handler, but then
; the instruction is classified as an STRelative instruction and the
; above paragraph of code checks if ST(x) is empty.  HOWEVER, FST ST(x) does
; not require ST(x) to be empty so a true underflow error should not occur.
; This code should be changed if this situation can ever occur.

	JMP	TrueUnderflow		; true stack underflow

;***	RotateChip - rotate coprocessor registers
;
;	ENTRY
;		BX: tag word, complemented
;		ST(0): empty
;		at least one other register on the chip is non-empty
;			(or else this routine will loop infinitely)
;
;	RETURNS
;		BX: updated tag word, complemented
;		ST(0): non-empty
;
;	DESCRIPTION
;		This routine rotates the registers on the coprocessor
;		until the first in-use register is in ST(0).  This
;		will correct a stack underflow exception which has been
;		caused by old model code encountering a gap of free
;		registers created by new model code.  The complemented
;		tag word is also updated appropriately.
;
lab RotateChip
	ROR	BX,1			; Rotate tag word
	ROR	BX,1
	FINCSTP 			; Point to new ST(0)
	TEST	BX,00003h		; Is this register empty?
	JZ	short RotateChip	; No, go rotate again
	RET

lab TrueUnderflow
	OR	AH,StackUnderflow/256	; indicate true stack underflow
	MOV	BYTE PTR ENV_StatusWord[eBP],0	 ; Clear exceptions
	FLDENV	WORD PTR [eBP]		; Restore old environment.
	POP	eDI
	POP	eDX
	POP	eCX
	POP	eBX
	POP	eSI
	JMP	CleanUpHost		; Leave exception handler.

lab InvalidReexecute
	AND	AL,0FFH-Invalid 	; Reset invalid flag.
	CALL	ReDo8087Instruction	; Was invalid so redo instruction.

	POP	eDI
	POP	eDX
	POP	eCX
	POP	eBX
	POP	eSI
	JMP	WhileException
endif	;_NOSTKEXCHLR

;----------------------------------------------------------------------------

PAGE
lab ProcessDenormal

	; Correct 8087	bug.   The  FLD  instruction  signals a denormal
	; exception AFTER it  has  completed.	Reexecuting  FLD  for  a
	; denormal exception  would  thus mess up the 8087 stack.  INTEL
	; documentation   states   denormal   exceptions   are	  BEFORE
	; exceptions, so there is a contradiction.  To avoid reexecution
	; of FLD we do as follows:  And op code with 138H  to  mask  out
	; MOD, RM,  ESC  and  memory  format bits.  Compare with 100H to
	; distinguish FLD from other instructions which  could	possibly
	; generate a denormal exception.

	or	byte ptr [UserStatusWord],Denormal	; set denorm bit
	push	ecx

	mov	cx,ENV_Opcode[eBP]	; see if we have a reg,reg operation
	and	cl, bMOD
	cmp	cl, bMOD		; if MOD = 11b then we have a reg,reg op
	je	notMemOpDenormal

	mov	cx,ENV_Opcode[eBP]
	and	cx, not (0fc00h or bMOD or bRM) ; remove escape, OpSizeBit, MOD and R/M

	cmp	cx,0008h		; check for FMUL real-memory
	je	short isMemOpDenormal

	cmp	cx,0010h		; check for FCOM real-memory
	je	short isMemOpDenormal

	and	cl,30h			; clear low opcode bit
	cmp	cx,0030h		; check for FDIV/FDIVR real-memory
	jne	short notMemOpDenormal

;	have FDIV/FDIVR real-memory
;	have FMUL real-memory
;	have FCOM real-memory
;
;	do the following steps
;	1.	free ST(7) if not free to avoid stack overflow
;	2.	change instruction to FLD real-memory and redo
;	3.	normalize TOS
;	4.	change instruction to FMUL or FDIV[R]P ST(1),ST and redo

lab isMemOpDenormal
	TEST	BH,0C0h 		; 1. Possible stack overflow?
	JZ	short nostkovr		;    No - bypass offloading stack
	AND	BH,0FFh-0C0h		;    Indicate 1st above TOS is free
	PUSHST				;    Let PUSHST make room for value.
	FDECSTP 			;    Point to bottom stack element.
	FSTP	TBYTE PTR [eSI] 	;    Store out bottom stack element.
lab nostkovr

	mov	cx,ENV_Opcode[ebp]	; 2. get original instruction
	push	cx			;    save it for later
	and	cx,0400h
	add	cx,0104h		;    changed to FLD real DS:[SI]
	mov	ENV_Opcode[ebp],cx	;    change for redo
	call	ReDoIt			;    do FLD denormal

	call	normalize		; 3. normalize TOS

	pop	cx			; 4. restore original instruction
	and	cx,0038h		;    reduce to operation
	cmp	cl,08h			;    is it FMUL
	je	short isFMUL		;      yes
	cmp	cl,10h			;    is it FCOM
	je	short isFCOM		;      yes

	xor	cl,08h			;    must be FDIV[R] - flip R bit
lab isFMUL
	or	cx,06C1h		;    or to FoprP ST(1),ST
	mov	ENV_Opcode[ebp],cx	;    change for redo
	call	ReDo8087Instruction	;    do FDIV[R]P ST(1),ST
	jmp	short denormaldone	;    done with FDIV[R] denormal

lab notMemOpDenormal
	MOV	cx,ENV_Opcode[eBP]

	and	cx, 0738h
	cmp	cx, 0328h
	je	short noredo		; check for FLD long double

	AND	cx,0138H
	CMP	cx,0100H		; check for FLD float/double
	JZ	short noredo

	CALL	ReDo8087Instruction	; redo other instructions
lab noredo
	call	normalize
	jmp	short denormaldone

;	FCOM is a little more complicated to recover because of status
;
;	FCOM is like FDIV in that the operands need to be exchanged
;	and the value loaded onto the chip needs to be popped.
;
;	This routine is like a mini ReDo8087Instruction

lab isFCOM
	OR	AH,Reexecuted/256	; Flag instruction reexecuted
	FCLEX				; clear exceptions
	FXCH				; swap ST(0) and ST(1)
	FCOM	ST(1)			;   so that ST(1) is the "source"
	FXCH
	FSTP	ST(0)			; toss stack entry
	FSTSW	[NewStatusWord] 	; get status word
	FWAIT
	OR	AL,BYTE PTR [NewStatusWord]	; Include new with unhandled exceptions

lab denormaldone
	pop	ecx
	AND	AL,0FFh-Denormal	; clear denormal exception
	jmp	WhileException

lab normalize
	fstp	tbyte ptr ENV_Temp[ebp] 	; save denormal/unnormal
	fwait

	mov	cx,ENV_Temp[ebp+8]		; get old exponent
	test	cx,07FFFh			; test for zero exponent
	jz	short isdenormal		;   denormal temp real

	test	byte ptr ENV_Temp[ebp+7],80h	; test for unnormal
	jnz	short isnormal			;   no - skip normalization

	fild	qword ptr ENV_Temp[ebp] 	; load mantissa as integer*8
	fstp	tbyte ptr ENV_Temp[ebp] 	; save mantissa
	fwait

	cmp	word ptr ENV_Temp[ebp+8],0	; check for 0.0
	je	short isdenormal		;   yes - we had a pseudo-zero

	sub	cx,403Eh			; exponent adjust (3fff+3f)
	add	ENV_Temp[ebp+8],cx		; add to mantissa exponent

lab isnormal
	fld	tbyte ptr ENV_Temp[ebp] 	; reload normalized number
	ret

lab isdenormal
	xor	cx,cx				; make it into a zero
	mov	ENV_Temp[ebp],cx
	mov	ENV_Temp[ebp+2],cx
	mov	ENV_Temp[ebp+4],cx
	mov	ENV_Temp[ebp+6],cx
	mov	ENV_Temp[ebp+8],cx
	jmp	isnormal			; reload it as zero

PAGE
lab ProcessNumericOverflow

	; We must reexecute for numeric overflow only if the instruction
	; was an FST or FSTP.  This is because only  these  instructions
	; signal the  exception  before  the  instruction  is  executed.
	; If we reexecute under other conditions the state of  the  8087
	; will be  destroyed.	Only  memory operand versions of FST and
	; FSTP can produce  the  Overflow  exception,  and  of	all  the
	; non-arithmetic memory   operand  instructions,  only	FST  and
	; FSTP produce	overflow  exceptions.	Thus  it  is  sufficient
	; to reexecute	only  in  case	of non-arithmetic memory operand
	; instructions.  To check for these and the op code with  001C0H
	; to mask  down  to  the  arith  and  MOD fields, flip the arith
	; bit by xoring with 00100H and if the	result	is  below 000C0H
	; then we  have  a  non-arithmetic  memory  operand instruction.

	PUSH	eAX
	MOV	AX,ENV_Opcode[eBP]
	AND	AX,001C0H
	XOR	AH,001H
	CMP	AX,000C0H
	POP	eAX
	JAE	short NumericOverflowRet

	CALL	ReDo8087Instruction

lab NumericOverflowRet
	JMP	WhileException

PAGE
;----------------------------------------------------------------------------
; Reexecute aborted 8087 instruction, and include any exceptions in ENV [BP]
;----------------------------------------------------------------------------

ifdef  WINDOWS
lab ReDo8087InstructionRet
	ret
endif

lab ReDo8087Instruction
	TEST	AH,Reexecuted/256	; Already reexecuted?
	JNZ	short ReDo8087InstructionRet  ; If so don't do it again
	OR	AH,Reexecuted/256	; Flag instruction reexecuted

lab ReDoIt
	PUSH	DS
	PUSH	eDI
	PUSH	eSI
	PUSH	eCX
	PUSH	eBX
	FCLEX				; clear error summary flags


ifdef  WINDOWS
	mov	di, ss			; assume SS
	mov	bx, __WINFLAGS
	test	bx, WF_PMODE
	jz	SkipSSAlias

	push	es
;	push	ax		; CHICAGO needs 32-bit register saves ...
;	push	dx

	push	eax		; for CHICAGO
	push	ebx		; for CHICAGO
	push	ecx		; for CHICAGO
	push	edx		; for CHICAGO
	push	ebp		; for CHICAGO
	push	esi		; for CHICAGO
	push	edi		; for CHICAGO

	push	ss
	call	ALLOCDSTOCSALIAS

	pop		edi		; for CHICAGO
	mov	di, ax

;	pop	dx			; CHICAGO needs 32-bit register restores
;	pop	ax

	pop		esi		; for CHICAGO
	pop		ebp		; for CHICAGO
	pop		edx		; for CHICAGO
	pop		ecx		; for CHICAGO
	pop		ebx		; for CHICAGO
	pop		eax		; for CHICAGO
	pop		es

	or	di, di
	jz	ReExecuteRestoreRet
lab SkipSSAlias

else	;not WINDOWS

ifdef	DOS3and5
	mov	di,ss			; assume SS
	cmp	[protmode],0		; check if protect mode
	je	noSSalias		;   no - don't get SS alias
endif	;DOS3and5

ifdef	DOS5

ifdef SQL_EMMT
	push	ax

	push	ss			; The SQL server may have switched stacks
	push	ds			; so update SSalias.
	mov	ax,offset SSalias
	push	ax
	os2call DOSCREATECSALIAS

	pop	ax
endif	;SQL_EMMT

	mov	di,[SSalias]		; Get segment alias to stack
endif	;DOS5

endif	;not WINDOWS

ifdef	DOS3and5
lab noSSalias
endif	;DOS3and5

	MOV	CX,ENV_Opcode[eBP]	; Get aborted 8087 instruction.
	MOV	BX,CX			; Copy instruction.
	AND	CH,07H			; Clear upper 5 bits.
	OR	CH,0D8H 		; "OR" in escape code.
	AND	BL,0C0H 		; Mask to MOD field.
	XOR	BL,0C0H 		; If MOD = "11" (no memory operand)
	JZ	short REEXECUTE 	; then address mode modification code
					;    must be bypassed.
	AND	CL,38H			; Clear MOD and RM fields,
	OR	CL,4H			; Turn on bits in MOD and RM fields
					;    to force DS:[SI+0] addressing.
	LDS	SI,ENV_OperandPointer[eBP] ; DS:SI <-- operand address

lab REEXECUTE
	XCHG	CH,CL			; convert to non-byte swapped
					;    code format
	;
	; Stack restart method.  Restart instruction in interrupt stack
	; frame.  Code is reentrant.
	;

ifdef  WINDOWS
	mov	ENV_CallSegment[ebp],di ; Code segment alias to stack
elseifdef   DOS5
	mov	ENV_CallSegment[ebp],di ; Code segment alias to stack
else
	MOV	ENV_CallSegment[eBP],SS ; Stack segment
endif

	LEA	eDI,ENV_CallFwait[eBP]	  ; Offset to code in stack.
	MOV	ENV_CallOffset[BP],eDI
	MOV	BYTE PTR ENV_CallFwait[eBP],09BH   ; FWAIT.
	MOV	ENV_Call8087Inst[eBP],CX	   ; 8087 instruction.
	MOV	BYTE PTR ENV_CallLongRet[eBP],0CBH ; Intra segment return.
	CALL	DWORD PTR ENV_CallOffset[eBP]	   ; Reexecute instruction.

ifdef  WINDOWS
	mov	bx, __WINFLAGS
	test	bx, WF_PMODE
	jz	ReExecuteRestoreRet

	push	es		; if in PMODE, free alias
;	push	ax		; CHICAGO needs 32-bit register saves
;	push	dx

	push	eax		; for CHICAGO
	push	ebx		; for CHICAGO
	push	ecx		; for CHICAGO
	push	edx		; for CHICAGO
	push	ebp		; for CHICAGO
	push	esi		; for CHICAGO
	push	edi		; for CHICAGO

	push	ENV_CallSegment[eBP]
	call	FREESELECTOR

;	pop	dx			; CHICAGO needs 32-bit register restores
;	pop	ax

	pop		edi		; for CHICAGO
	pop		esi		; for CHICAGO
	pop		ebp		; for CHICAGO
	pop		edx		; for CHICAGO
	pop		ecx		; for CHICAGO
	pop		ebx		; for CHICAGO
	pop		eax		; for CHICAGO
	pop		es
endif	;WINDOWS


lab ReExecuteRestoreRet
	POP	eBX
	POP	eCX
	POP	eSI
	POP	eDI
	POP	DS

ifdef  SQL_EMMT
	push	ax			; free the ss alias because we always
	push	[SSalias]		; get a new one for the SQL_EMMT
	os2call DOSFREESEG
	pop	ax
endif	;SQL_EMMT


	FSTSW	[NewStatusWord] 	; 8/18/84 GFW need proper DS set
	FWAIT
	OR	AL,BYTE PTR [NewStatusWord]	; Include new with unhandled exceptions

ifndef	WINDOWS
lab ReDo8087InstructionRet
endif
	RET

ProfEnd EXCEPT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfcom.asm ===
page	,132
	subttl	emfcom.asm - Comparison instructions
;***
;emfcom.asm - Comparison instructions
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Comparison instructions
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;	    Comparison instructions: FCOM,FCOMP,FCOMPP,FTST,FXAM      ;
;								      ;
;*********************************************************************;

ProfBegin FCOM


pub	eFCOMP
	MOV	DX,1		; Counts number of POPs needed (0 or 1)
	JMP	short CommonCOM
pub	eFCOM
	XOR	DX,DX		; No extra POP needed at end

pub	CommonCOM		; SI points to ST, DI points to source
	TEST	WORD PTR [CURerr],MemoryOperand
	JZ	short ComSIandDIset
	XCHG	esi,edi 	; Switch SI, DI for memory operands

pub	ComSIandDIset
	MOV	AL,Flag[esi]	; All comparisons are ST ? source
	MOV	AH,Flag[edi]	; Fetch signs
	XOR	ebx,ebx
	MOV	BL,Tag[esi]
	SHL	BL,1
	SHL	BL,1
	OR	BL,Tag[edi]
ifdef	i386
	JMP	COMtab[4*ebx]
else
	SHL	BL,1
	JMP	COMtab[ebx]
endif

pub	COMvalidvalid
if	fastSP
	MOV	BX,AX			; Keep copy of the Single Flags
endif
	XOR	AH,AL			; Are signs different?
	JS	short COMsignSI 	; if so then sign of SI will determine
	OR	AL,AL			; else signs are same. See if negative
	JNS	short CompareExponents	; If negative then reverse sense of compare
	XCHG	esi,edi 		;  by swapping the arguments
	XCHG	BL,BH			;  Swap single flags

pub	CompareExponents
	MOV	AX,Expon[esi]
	CMP	AX,Expon[edi]
	JL	short COMless
	JG	short COMgreater

pub	CompareMantissas
if	fastSP
	XOR	BH,BL
	TEST	BH,Single	    ; Were both args the same length?
	JNZ	DifferentTypes
	TEST	BL,Single	    ; Args same type - Single?
	JZ	BothDouble
	MOV	ecx,3		    ; Compare 3 bytes of mantissa
DoCompare:
	ADD	esi,MB7 	    ; point to most significant byte
	ADD	edi,MB7
	STD
	REP	CMPS	word ptr es:[edi],word ptr ds:[esi]
	CLD
else
	mov	ecx,4		    ; compare 4 words of mantissa
	ADD	esi,MB6 	    ; point to most significant word
	ADD	edi,MB6
	STD
	REP	CMPS	word ptr [edi],word ptr [esi]
	CLD
endif
	JB	short COMless
	JA	short COMgreater

pub	COMequal
	MOV	[SWcc],CCequal
	JMP	short COMexit

if	fastSP
DifferentTypes:
	TEST	BL,Single
	JNZ	CoerceSI
	MOV	word ptr MB0[edi],0
	MOV	word ptr MB2[edi],0
	MOV	byte ptr MB4[edi],0
	MOV	ecx,8		    ; Compare 8 bytes of mantissa
	JMP	DoCompare

CoerceSI:
	MOV	word ptr MB0[esi],0
	MOV	word ptr MB2[esi],0
	MOV	byte ptr MB4[esi],0
BothDouble:
	MOV	ecx,8		    ; Compare 8 bytes of mantissa
	JMP	DoCompare
endif

pub	COMless
	MOV	[SWcc],CCless
	JMP	short COMexit

pub	COMgreater
	MOV	[SWcc],CCgreater
	JMP	short COMexit

pub	COMincomprable
	OR	[CURerr],Invalid
pub	COMincompr0
	MOV	[SWcc],CCincomprable
	JMP	short COMexit

pub	COMsignSIinf			; if projective inf numbers are incomprable
	TEST	[CWcntl],InfinityControl
	JZ	COMincompr0
pub	COMsignSI			; sign of SI tells all (DI = 0)
	AND	AL,Sign
	JS	COMless
	JMP	COMgreater

pub	COMsignDIinf			; if projective inf numbers are incomprable
	TEST	[CWcntl],InfinityControl
	JZ	COMincompr0
pub	COMsignDI			; sign of DI tells all (SI = 0)
	AND	AH,Sign
	JS	COMgreater
	JMP	COMless

pub	COMinfinf
	TEST	[CWcntl],InfinityControl
	JZ	COMincompr0
	XOR	AH,AL			; Are signs the same?
	AND	AH,Sign
	JZ	COMequal		; yes - infinities are equal
	JMP	COMsignSI		; else SI negative implies it is less

pub	COMexit
	OR	DX,DX			; do we need to pop the stack?
	JZ	short COMreturn
	POPST
pub	COMreturn
	RET

pub	eFXAM
	MOV	esi,[CURstk]

	mov	al, 41h 		; see if stack was empty
	cmp	esi,[BASstk]
	je	RetFXAM

	MOV	AX,Flag[esi]		; Sign in AH, Tag in AL
	XCHG	AL,AH
	ROL	AX,1
	AND	AL,7			; Mask to Tag-Sign
	MOV	ebx,offset XAMTAB
	XLAT	byte ptr cs:[ebx]	; Convert to condition code

pub  RetFXAM
	MOV	[SWcc],AL		; Stuff into hi-byte of status word
	RET

pub	eFTST
	MOV	esi,[CURstk]
	MOV	AL,Flag[esi]
	AND	AL,Sign 		; Mask to sign only
	XOR	ebx,ebx
	MOV	edx,ebx 		; DX 0 to indicate no POP in COMP
	MOV	BL,Tag[esi]
ifdef	i386
	jmp	TSTtab[4*ebx]
else
	SHL	ebx,1
	JMP	TSTtab[ebx]
endif

ProfEnd  FCOM

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfconst.asm ===
page	,132
	subttl	emfconst.asm - Loading of 8087 on chip constants
;***
;emfconst.asm - Loading of 8087 on chip constants
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Loading of 8087 on chip constants
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

;-----------------------------------------;
;					  ;
;	     Constant Loading		  ;
;					  ;
;-----------------------------------------;

;---------------------------------------------------
;						   !
;	8087 emulator constant loading		   !
;						   !
;---------------------------------------------------

ProfBegin FCONST


LoadConstantEntry	MACRO	cName,Position
pub	e&cName
	mov	ebx,offset c&cName
   IFIDN <&Position>,<Last>
   ELSE ;IFIDN <&Position>,<Last>
	jmp	short CommonConst
   ENDIF ;IFIDN <&Position>,<Last>
	ENDM

ifndef	frontend
ifndef	SMALL_EMULATOR

LoadConstantEntry	FLDPI,NotLast

LoadConstantEntry	FLDL2T,NotLast

LoadConstantEntry	FLDL2E,NotLast

LoadConstantEntry	FLDLG2,NotLast

LoadConstantEntry	FLDLN2,NotLast

endif	;not SMALL_EMULATOR
endif	;not frontend

LoadConstantEntry	FLDZ,NotLast

LoadConstantEntry	FLD1,Last

pub	CommonConst
	PUSHST
	MOV	esi,ebx
	MOV	edi,[CURstk]
ifdef	i386
	   rept Reg87Len/4
	MOVS	dword ptr es:[edi], dword ptr cs:[esi]
	   endm
else
	   rept Reg87Len/2
	MOVS	word ptr es:[edi], word ptr cs:[esi]
	   endm
endif
	RET

ProfEnd  FCONST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfadd.asm ===
page	,132
	subttl	emfadd.asm - Addition and Subtraction
;***
;emfadd.asm - Addition and Subtraction
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Addition and Subtraction
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

;-----------------------------------------;
;					  ;
;   Addition and Subtraction		  ;
;					  ;
;-----------------------------------------;

ProfBegin FADD

RABRQQ: 	; Routine Add Both   must see if we have two singles.

if	fastSP
	MOV	BX,DX
	XOR	BX,Single + 256*Single
	TEST	BX,Single + 256*Single
	JNZ	RADRQQ
	MOV	BX,OFFSET TASRQQ
	JMP	[BX]
endif	;fastSP


pub	RADRQQ	; RoutineAddDouble    SI & DI point to valid non-0 reals
				; AX   CX  are the exponents
				; DL   DH  are the signs
if	fastSP
	CALL	CoerceToDouble	; insure that both args are double
endif	;fastSP

	SUB	AX,CX		; See which number is larger
	JL	short DIBIG
	XCHG	esi,edi 	; Swap pointers to operands
	XCHG	DH,DL		; Swap signs
	ADD	CX,AX		; CX = larger exponent (Tentative result)
	NEG	AX
pub	DIBIG			; DI = larger, CX = expon, DH = sign
	NEG	AX
	CMP	AX,64+3 	; Is smaller argument significant?
	JLE	short SIGNIF

	PUSH	ebp		; Not signif so result is at DI except for
	PUSH	edx		; rounding. ROUND assumes old BP and Sign on
	MOV	SI,Expon[edi]	; stack. Exponent in SI
	MOV	BP,1		; Other argument collapses into a sticky bit
	XOR	DL,DH		; if signs of operands differ bit is negative
	JNS	short GetOpMantissa
	NEG	BP
pub	GetOpMantissa
	MOV	DX,MB0[edi]
	MOV	CX,MB2[edi]
	MOV	BX,MB4[edi]
	MOV	DI,MB6[edi]
	OR	BP,BP
	JS	short NegativeStickyBit
	JMP	ROUND

pub	NegativeStickyBit
	SUB	DX,1		; Must propagate negative sticky bit
	SBB	CX,0
	SBB	BX,0
	SBB	DI,0
	JMP	NODRQQ

pub	SIGNIF
; Now things look like this:
;	SI has pointer to smaller operand
;	DI has pointer to larger operand
;	AX has exponent difference ( 0 <= CL <= 53 )
;	CX has exponent
;	DH has sign

	PUSH	ebp		; Need all the registers
	PUSH	edx		; Save sign
	PUSH	ecx		; Save exponent
	XOR	DL,DH		; Must eventually know whether signs are same
	PUSHF

	MOV	BP,AX		; Need all 8-bit registers now

; Load smaller operand

	LODS	word ptr ds:[esi]
	MOV	DX,AX
	LODS	word ptr ds:[esi]
	MOV	CX,AX
	LODS	word ptr ds:[esi]
	MOV	BX,AX
	LODS	word ptr ds:[esi]
	XOR	si,si		; BP Will be round,guard, & sticky bits (=0)
	XCHG	bp,si		; Done with Pointer to small. so SI = shift cnt

;			 hi	  lo 0
; Smaller operand now in AX:BX:CX:DX:BP with implied bit set, SI has shift count

	OR	si,si
	JZ	ALIGNED 	; Alignment operations necessary?
pub	CHKALN
	CMP	si,14		; Do shifts of 16 bits by word rotate
	JL	short BYTSHFT	; If not enough for word, go try byte
	OR	BP,BP		; See if we're shifting something off the end
	JZ	short NOSTIK
	OR	DX,1		; Ensure sticky bit will be set
pub	NOSTIK
	MOV	BP,DX
	MOV	DX,CX
	MOV	CX,BX
	MOV	BX,AX
	XOR	AX,AX
	SUB	si,16		; Counts for 16 bit shifts
	JA	short CHKALN	; If not enough, try again
	JZ	short ALIGNED	; Hit it exactly?
	JB	short SHFLEF	; Back up if too far

pub	BYTSHFT
	CMP	si,6		; Can we do a byte shift?
	JL	short BITSHFT
	XCHG	BP,AX
	OR	AL,AL
	JZ	short NSTIK
	OR	AH,1
pub	NSTIK
	MOV	AL,AH
	MOV	AH,DL
	XCHG	BP,AX
	MOV	DL,DH
	MOV	DH,CL
	MOV	CL,CH
	MOV	CH,BL
	MOV	BL,BH
	MOV	BH,AL
	MOV	AL,AH
	XOR	AH,AH
	SUB	SI,8
	JA	short BITSHFT
	JZ	short ALIGNED

; To get here, we must have used a byte shift when we needed to shift less than
; 8 bits. Now we must correct by 1 or 2 left shifts.

pub	SHFLEF
	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	RCL	AX,1
	INC	SI
	JNZ	SHFLEF		; Until DI is back to zero (from -1 or -2)
	JMP	SHORT ALIGNED

pub	BITSHFT
ifdef	i386
	and	esi,0FFFFh	; clear upper half of esi
endif
	XCHG	ecx,esi 	; Swap count into CX, lo3:lo4 into DI
	TEST	BP,3FH		; See if we're shifting stuff off the end
	JZ	short SHFRIG
	OR	BP,20H		; Set sticky bit if so
pub	SHFRIG
	SHR	AX,1
	RCR	BX,1
	RCR	SI,1
	RCR	DX,1
	RCR	BP,1
	LOOP	SHFRIG		; Do 1 to 5 64-bit right shifts
	MOV	CX,SI		; Get back CX = lo3:lo4
pub	ALIGNED
	MOV	esi,edi 	; Address of larger operand
	MOV	DI,AX		; Now DI = msb:mid
	TEST	BP,3FFFH	; Collapse LSBs into sticky bit
	JZ	short GETSIGN
	OR	BP,1		; Set sticky bit
pub	GETSIGN
	POPF			; Recover XOR of signs
				; 80286 errata for POPF shouldn't
				; apply because interrupts should be
				; turned on in this context
	POP	eax		; Recover Exponent
; Sign flag is XOR of signs

	JS	short SUBMAN	; Subtract mantissas if signs are different
	ADD	DX,[esi]
	ADC	CX,[esi+2]
	ADC	BX,[esi+4]
	ADC	DI,[esi+6]
	JNC	short JROUND	; Done if no overflow

; Have a carry, so result must be shifted right and exponent incremented
	RCR	DI,1
	RCR	BX,1
	RCR	CX,1
	RCR	DX,1
	RCR	BP,1
	JNC	short STIKYOK
	OR	BP,1		; Shifted out the sticky bit so reset it.
pub	STIKYOK
	INC	AX		; Bump exponent.
;	JMP	JROUND		; and go round. (need not normalize)

pub	JROUND
	MOV	SI,AX		; We must have SI equal to exponent
	JMP	ROUND		; on our way to Round

pub	SUBMAN
; Subtract mantissas since signs are different.  We'll be subtracting larger
; from smaller, so sign will be inverted first after the subtraction.

	SUB	DX,[esi]
	SBB	CX,[esi+2]
	SBB	BX,[esi+4]
	SBB	DI,[esi+6]
	JNC	short JNORM	; Won't carry if we mixed up larger and smaller

; As expected, we got a carry which means we original sign was OK
	XOR	SI,SI		; We'll need a zero, so let's use SI
	NOT	DI
	NOT	BX
	NOT	CX
	NOT	DX
	NEG	BP		; Carry clear if zero
	CMC			; Set CY
	ADC	DX,SI
	ADC	CX,SI		; Propagate carry
	ADC	BX,SI
	ADC	DI,SI
	MOV	SI,AX		; Get exponent to SI
	JMP	NODRQQ		; Go normalize

pub	JNORM
	MOV	SI,AX		; Exponent in SI
	POP	eax
	XOR	AH,SIGN 	; invert sign bit (on top of stack)
	PUSH	eax
	JMP	NODRQQ		; and go normalize

ProfEnd  FADD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfmisc.asm ===
page	,132
	subttl	emfmisc.asm - Miscellaneous Operations
;***
;emfmisc.asm - Miscellaneous Operations
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Miscellaneous Operations: FABS, FCHS, DupTOS, FSCALE, FXCHG
;
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin FMISC


pub	eFABS
	MOV	esi,[CURstk]			; point to TOS
	AND	byte ptr Flag[esi],0FFH - Sign	; mask off sign
	RET

pub	eFCHS
	MOV	esi,[CURstk]			; point to TOS
	XOR	byte ptr Flag[esi],Sign 	; toggle the sign
	RET


;	FLDCW and FSTCW should only be used in a nested fashion
;	and should never change the denormal and invalid masks (in real 8087)
;
;	FSTCW	old
;	FLDCW	new		; new and old have same denormal/invalid masks
;	...
;	FLDCW	old

pub	eFLDCW
	LDUS2AX 		; Fetch control word from user memory
	MOV	[ControlWord],AX ; Store in the emulated control word
	MOV	[UserControlWord],AX ; Store in the user control word
	RET

pub	eFSTCW
	MOV	AX,[UserControlWord] ; Fetch user control word
	MOV	edi,esi
	STAX2US 		; Store into user memory
	RET

pub	eFSTSW
	MOV	AX,[StatusWord]     ; Fetch emulated Status word
	MOV	edi,esi
	STAX2US 		; Store into user memory
	RET

pub	eFSCALE 		; NOS is treated as short integer and TOS gets
	MOV	esi,[CURstk]	 ; its exponent bumped by that amount
	MOV	edi,esi
	ChangeDIfromTOStoNOS
	MOV	CL,15
	MOV	AL,Expon[edi]	; Assume word integer
	AND	AL,0FH		; Assume exp is positive and in range
	SUB	CL,AL		; Generate shift count for mantissa
	MOV	AX,MB6[edi]	; MSW will contain the whole integer
	SHR	AX,CL		; AX is now the integer
	MOV	CL,Flag[edi]	; Get the sign for the integer
	OR	CL,CL
	JNS	short GotExponInc
	NEG	AX

pub	GotExponInc
	ADD	AX,Expon[esi]
	JO	short ExpOverflowed
	CMP	AX,IexpMax - IexpBias
	JGE	short ScaledToInfinity
	CMP	AX,IexpMin - IexpBias
	JLE	short ScaledToZero

pub	ScaleReturn
	MOV	Expon[esi],AX
	RET

pub	ExpOverflowed
	JNS	short ScaledToZero

pub	ScaledToInfinity
	MOV	AX,IexpMax - IexpBias
	MOV	byte ptr Tag[esi],Special + ZROorINF
	JMP	short ScaleReturn

pub	ScaledToZero
	MOV	AX,IexpMin - IexpBias
	MOV	byte ptr Tag[esi],ZROorINF
	JMP	short ScaleReturn

ProfEnd  FMISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfdiv.asm ===
page	,132
	subttl	emfdiv.asm - Division
;***
;emfdiv.asm - Division
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Division
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;		Division		  ;
;					  ;
;-----------------------------------------;

ProfBegin FDIV

RDBRQQ:     ; Routine Div Both	 must see if we have two singles.

if	fastSP
	MOV	BX,DX
	XOR	BX,Single + 256*Single
	TEST	BX,Single + 256*Single
	JNZ	RDDRQQ
	MOV	bx,offset TDSRQQ
	JMP	[bx]
endif	;fastSP


pub	RDDRQQ	; Routine Division Double
; Now we have
;   SI --> numerator   , AX - Expon , DL - Sign
;   DI --> denominator , CX - Expon , DH - Sign

if	fastSP
	CALL	CoerceToDouble	; insure that both args are double
endif	;fastSP

	STC			; exponent will be difference - 1
	SBB	AX,CX		; compute result exponent

; AH has the (tentative) true exponent of the result.  It is correct if the
; result does not need normalizing.  If normalizing is required, then this
; must be incremented to give the correct result exponent

	XOR	DH,DL		; Compute sign
	PUSH	ebp
	PUSH	edx		; Save sign
	PUSH	esi
	PUSH	edi
	ADD	esi,6
	ADD	edi,6
	MOV	ecx,4
	STD
	REP	CMPS  word ptr [esi],word ptr [edi] ; compare numerator mantissa
	CLD			;    with denominator mantissa
	POP	edi
	POP	esi
	PUSHF			; save the flags from the compare
	MOV	BP,AX		; save the exponent
	LODS	word ptr [esi]	; Load up numerator
	MOV	CX,AX
	LODS	word ptr [esi]
	MOV	BX,AX
	LODS	word ptr [esi]
	MOV	DX,AX
	LODS	word ptr [esi]
	XCHG	AX,DX

; Move divisor to DAC so we can get at it easily.

	MOV	esi,edi 	; Move divisor to DAC
	MOV	edi,offset DAC
ifdef	i386
	MOVSD
	MOVSD
else
	MOVSW
	MOVSW
	MOVSW
	MOVSW
endif

; Now we're all set:
;	DX:AX:BX:CX has dividend
;	DAC has divisor (in normal format)
; Both are 64 bits with zeros and have implied bit set.
; Top of stack has sign and tentative exponent.

	XOR	DI,DI
	POPF			; numerator mantissa < denominator?
				; 80286 errata for POPF shouldn't
				; apply because interrupts should be
				; turned on in this context
	JB	short DivNoShift ;    if so bypass numerator shift
	SHR	DX,1		; Make sure dividend is smaller than divisor
	RCR	AX,1		;   by dividing it by two
	RCR	BX,1
	RCR	CX,1
	RCR	DI,1
	INC	BP		; increment result exponent
pub	DivNoShift
	PUSH	ebp		; save result exponent
	MOV	[REMLSW],DI	; Save lsb of remainder
	CALL	DIV16		; Get a quotient digit
	PUSH	edi
	MOV	[REMLSW],0	; Turn off the shifted bit
	CALL	DIV16
	PUSH	edi
	CALL	DIV16
	PUSH	edi
	CALL	DIV16
	MOV	BP,8001H	; turn round and sticky on
	SHL	CX,1
	RCL	BX,1
	RCL	AX,1
	RCL	DX,1		; multiply remainder by 2
	JC	short BPset	; if overflow, then round,sticky valid
	MOV	esi,offset DAC
	CMP	DX,[esi+6]
	JNE	short RemainderNotHalf
	CMP	AX,[esi+4]
	JNE	short RemainderNotHalf
	CMP	BX,[esi+2]
	JNE	short RemainderNotHalf
	CMP	CX,[esi]	; compare 2*remainder with denominator

;Observe, oh wondering one, how you can assume the result of this last
;compare is not equality.  Use the following notation: n=numerator,
;d=denominator,q=quotient,r=remainder,b=base(2^64 here).  If
;initially we had n < d then there was no shift and we will find q and r
;so that q*d+r=n*b, if initially we had n >= d then there was a shift and
;we will find q and r so that q*d+r=n*b/2.  If we have equality here
;then r=d/2  ==>  n={possibly 2*}(2*q+1)*d/(2*b), since this can only
;be integral if d is a multiple of b, but by definition b/2 <= d < b, we
;have a contradiction.	Equality is thus impossible at this point.

pub	RemainderNotHalf	; if 2*remainder > denominator
	JAE	short BPset	;    then round and sticky are valid
	OR	AX,DX
	OR	AX,CX
	OR	AX,BX
	OR	AL,AH		; otherwise or sticky bits into AL
	XOR	AH,AH		; clear round bit
	MOV	BP,AX		; move round and sticky into BP
pub	BPset
	MOV	DX,DI		; get low 16 bits into proper location
	POP	ecx
	POP	ebx
	POP	edi
	POP	esi		; Now restore exponent

	JMP	ROUND		; Result is normalized, round it


;	Remainder in DX:AX:BX:CX:REMLSW

pub	DIV16
	MOV	SI,[DAC+6]	; Get high word of divisor
	XOR	DI,DI		; Initialize quotient digit to zero
	CMP	DX,SI		; Will we overflow?
	JAE	MAXQUO		; If so, go handle special
	OR	DX,DX		; Is dividend small?
	JNZ	short DDIV
	CMP	SI,AX		; Will divisor fit at all?
	JA	short ZERQUO	; No - quotient is zero

pub	DDIV
	DIV	SI		; AX is our digit "guess"
	PUSH	edx		; Save remainder -
	PUSH	ebx		;   top 32 bits
	XCHG	AX,DI		; Quotient digit in DI
	XOR	BP,BP		; Initialize quotient * divisor
	MOV	SI,BP
	MOV	AX,[DAC]
	OR	AX,AX		; If zero, save multiply time
	JZ	short REM2
	MUL	DI		; Begin computing quotient * divisor
	MOV	SI,DX

pub	REM2
	PUSH	eax		; Save lowest word of quotient * divisor
	MOV	AX,[DAC+2]
	OR	AX,AX
	JZ	short REM3
	MUL	DI
	ADD	SI,AX
	ADC	BP,DX

pub	REM3
	MOV	AX,[DAC+4]
	OR	AX,AX
	JZ	short REM4
	MUL	DI
	ADD	BP,AX
	ADC	DX,0
	XCHG	AX,DX

;	Remainder - Quotient * divisor
;	[SP+4]:[SP+2]:CX:REMLSW - AX:BP:SI:[SP]

pub	REM4
	MOV	DX,[REMLSW]	; Low word of remainder
	POP	ebx		; Recover lowest word of quotient * divisor
	SUB	DX,BX
	SBB	CX,SI
	POP	ebx
	SBB	BX,BP
	POP	ebp		; Remainder from DIV
	SBB	BP,AX
	XCHG	AX,BP

pub	ZERQUO			; Remainder in AX:BX:CX:DX
	XCHG	AX,DX
	XCHG	AX,CX
	XCHG	AX,BX
	JNC	short DRET	; Remainder in DX:AX:BX:CX

pub	RESTORE
	DEC	DI		; Drop quotient since it didn't fit
	ADD	CX,[DAC]	; Add divisor back in until remainder goes +
	ADC	BX,[DAC+2]
	ADC	AX,[DAC+4]
	ADC	DX,[DAC+6]
	JNC	RESTORE 	; Loop is performed at most twice

pub	DRET
	RET

pub	MAXQUO
	DEC	DI		; DI=FFFF=2**16-1, DX:AX:BX:CX is remainder,
	SUB	CX,[DAC]	;    DX = [DAC+6], d = divisor = [DAC]
	SBB	BX,[DAC+2]
	SBB	AX,[DAC+4]	; subtract 2^16*d from DX:AX:BX:CX:0000H
	ADD	CX,[DAC+2]	;    (DX-[DAC+6] = 0 is implied)
	ADC	BX,[DAC+4]
	ADC	AX,DX		; add high 48 bits of d to AX:BX:CX:0000H
	MOV	DX,[DAC]	; add low 16 bits of d to zero giving DX
	CMC			; DI should be FFFEH if no carry from add
	JMP	ZERQUO

ProfEnd  FDIV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emdos.asm ===
page	,132
	subttl	emdos.asm - Initialization and Termination
;***
;emdos.asm - Initialization and Termination
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Initialization and Termination
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History: (Also see emulator.hst)
;
;   12-10-89  WAJ   Added MTHREAD DS == 0 check.
;
;*******************************************************************************


comment !

DOS interfaces to emulator/8087 functions

Certain emulator/8087 functions are performed by calling __fpmath
with an function code and arguments.

__fpmath	general floating point	math  package  interface  used
		by the emulator/8087 and float calls interfaces.  This
		is a far routine and must be far called.

entry:

  bx = 0	initialize floating point math
		dx:ax = task data area (dx = segment , ax = size)
			extra size is used to increase floating point stack
			(can pass segmented address of __fptaskdata in dx:ax)
		si = environment segment
		returns:
		  ax = 0 if successful and using software floating point
		       1 if successful and using 8087
		       negative if error

  bx = 1	reset (FINIT)

  bx = 2	terminate floating point math

  bx = 3	set error signal address
		dx:ax = segment:offset of user error handler

  bx = 4	load user control word
		(user should not use FLDCW instruction directly)
		ax = user control word value

  bx = 5	store user control word
		returns:
		  ax = user control word value

  bx = 6	truncate TOS to integer TOS
		ax = user control word (only use round mode)

  bx = 7	truncate TOS to 32-bit integer in DX:AX
		ax = user control word (only use round mode)

  bx = 8	store user status word
		returns:
		  ax = user status word value

  bx = 9	clear exceptions

  bx = 10	return number of stack elements in ax

  bx = 11	returns 1 if using 80x87, 0 if not

  bx = 12	if ax = 0, turn off extended stack. if ax = 1, turn on e.s.

QB3 version

  bx = 0	init, ax = initCW, es = PSP
  bx = 1	reset
  bx = 2	term
  bx = 3	set vectors
  bx = 4	reset vectors

!

glb	<functab>

functab label	word

	dw	initialization		; 0 - initialize emulator/8087
	dw	reset			; 1 - reset emulator/8087 stack
	dw	termination		; 2 - terminate emulator/8087

ifdef	QB3

	dw	set_vectors		; 3 - set interrupt vectors
	dw	rst_vectors		; 4 - reset interrupt vectors

SizeJmpTab  equ    4

else	;not QB3
	dw	setsignal		; 3 - set error signal address

	dw	loadcontrolword 	; 4 - load user control word
	dw	storecontrolword	; 5 - store user control word
	dw	truncateTOS		; 6 - truncate TOS to integer TOS
	dw	truncateTOSto32int	; 7 - truncate TOS to integer in DX:AX
	dw	storestatusword 	; 8 - store user status word
	dw	clearexceptions 	; 9 - clear execeptions
	dw	NumStack		; 10 - report number of elements in stack
	dw	ReturnHave8087		; 11 - report if using coprocessor
	dw	SetExtendedStack	; 12 - turn on or off extended stack

SizeJmpTab  equ    12

endif	;not QB3

endfunc label	word

szfunctab=	endfunc - functab



	public	__fpmath		; emulator entry point
					; (if linked with user program)

__fpmath	proc	far

	cmp	bx, SizeJmpTab
	ja	RetFPErr

	shl	bx,1
	push	ds			; save DS

ifdef	QB3
	push	es
	push	ax
	push	cx
	push	dx
	push	si
	push	di
endif

ifdef	MTHREAD
	or	bx,bx			; check for initialization
	jz	callfunc		;  yes - skip set up of ds
	
	push	ax			; preserve AX = __fpmath argument
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS; trashes AX
	mov	ax, ds
	or	ax, ax			; check for DS of zero.
	pop	ax
	jz	FPMathRet
callfunc:

else	;MTHREAD

ifdef	standalone
	xor	cx,cx
	mov	ds,cx
	mov	ds,ds:[TSKINT*4+2]	; point to task data area

elseifdef  _COM_
	mov	ds, [__EmDataSeg]

else
	mov	cx, edataBASE
	mov	ds,cx
endif	;standalone

endif	;MTHREAD

	call	functab[bx]

ifdef	QB3
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	ax
	pop	es
endif

lab FPMathRet
	pop	ds			; restore DS

pub emuret
	ret

RetFPErr:
	or	ax, -1
	mov	dx, ax
	jmp	emuret

__fpmath	endp


ProfBegin  DOS

subttl	emdos.asm - Initialization and Termination
page
;*********************************************************************;
;								      ;
;		      Initialization and Termination		      ;
;								      ;
;*********************************************************************;

wastetime macro
	push	cx
	mov	cx,20			;; wait for a short time
	loop	$
	pop	cx
endm

ifndef	only87
CHIPKEY 	db	'NO87='
CHIPKEYLEN	equ	$ - CHIPKEY
crlf		db	13,10
endif	;only87

ifdef	standalone
Installed	db	0		; installation flag

pub	sizeerror
	mov	ax,-1			; return size error
	stc
	ret
endif	;standalone


;	initialization
;
;	entry	dx:ax = task data area (segment and size) for standalone
;		si = DOS environment segment for NO87 lookup

pub	initialization

ifdef	QB3
	mov	[initCW],ax		; save initial BASIC control word
endif

setstacklimits macro
	mov	di,offset BEGstk	; di = base of register stack
	mov	[BASstk],di		; initialize stack base
	mov	cx,Reg87Len		; cx = register length
	xchg	ax,dx			; ax = task data segment size
	sub	ax,di			; ax = number bytes for stack
	cwd				; dx:ax = number of bytes
	div	cx			; ax = number of entries
	mul	cx			; ax = number of bytes
	add	ax,di			; ax = top of stack
	sub	ax,cx			; Leave room for one on overflow
	mov	[LIMstk],ax		; set top of stack
endm


ifdef	standalone

; check task data area sizes for correctness

	cmp	ax,offset __fptaskdata	; compare against minimum size
	jb	sizeerror		;  too small
	mov	ds,dx			; set up task data segment
	xchg	dx,ax			; set up size
	mov	ax,25h*256 + TSKINT	; set TASK DATA pointer vector
	int	21h

	setstacklimits
endif	;standalone

ifdef	MTHREAD
	ALLOCthreadDS			; macro in emthread.asm	
	mov	dx,(offset __fptaskdata)-cvtbufsize
					; set up size in dx
					; cvt buf not part of stack
	setstacklimits
endif	;MTHREAD


ifdef  QP
    mov     ax, edataOFFSET BEGstk	; initialize BASstk, CURstk, LIMstk
    mov     [BASstk], ax		; QuickPascal has no data initialization
    mov     [CURstk], ax

    mov     ax, edataOFFSET ENDstk
    sub     ax, 2*Reg87Len
    mov     [LIMstk], ax
endif	;QP


ifndef	frontend
ifdef	DOS5
	push	ss			; current stack segment selector
	push	ds
	mov	ax,offset SSalias
	push	ax			; address of SSalias
	os2call	DOSCREATECSALIAS	; get SS alias for exception handling
endif	;DOS5

endif	;frontend

ifdef	DOS3and5
	push	ds
	mov	ax,offset protmode
	push	ax
	os2call	DOSGETMACHINEMODE	; get machine mode flag
endif	;DOS3and5

ifdef	MTHREAD
 	mov	ax,ds
 	cmp	ax,EMULATOR_DATA	; check for thread 1
 	je	initcheckenv		;   yes - go look for NO87=
	

;	other threads should copy thread 1's Have8087 value
;	and then go to initfinish

	push	ds
	mov	ax,EMULATOR_DATA
	mov	ds,ax
	mov	al,[Have8087]		
	pop	ds
	mov	[Have8087],al	
	jmp	initfinish		
	
	
endif	;MTHREAD
pub	initcheckenv

ifdef	frontend
	mov	[Have8087],0		; indicate no 8087
else
ifndef	only87
	push	ds

;	Examine the environment looking for the NO87= switch

	or	si,si			; check for no environment passed in
	je	init1			;   don't look for NO87=

	mov	es,si			; ES = environment segment
	push	cs
	pop	ds
	xor	di,di			; DI -> 1st byte of environment
	cld

pub	envstart
	cmp	byte ptr es:[di],0	; 1st byte zero means end of env.
	je	init1			;   continue with initialization

	mov	cx,CHIPKEYLEN		; Length of key 'NO87='
	mov	si,offset CHIPKEY	; key string address

	repe	cmpsb

	je	envwrtmsg

	mov	cx,7FFFh		; Scan rest of environment
	xor	al,al			; for 0
	repne	scasb
	je	envstart		;   yes - check next entry
	jmp	short init1		; UNDONE - bad environment if here

pub	envwrtmsg
	mov	cx,7FFFh
	mov	al,' '			; skip leading blanks
	repe	scasb
	dec	di
	mov	dl,es:[di]		; Get character of message
	or	dl,dl			; Do we have a null?
	jz	envmsgend		; If so we're done

pub	envwrtlp
	xor	ax,ax	;** vvv 	; scan for a null byte
	mov	cx,7FFFh
	mov	bx,di			; save offset of string
	repne	scasb
	dec	di
	sub	di,bx
	mov	cx,di			; count of characters before null byte

;
;	write out NO87= environment string to standard output
;

ifdef	DOS5
	mov	di,bx			; restore offset of string
	push	ax
	mov	ax,sp			; allocate space for return count

	mov	bx,1
	push	bx			; file handle (standard output)
	push	es
	push	di			; address of buffer
	push	cx			; number of bytes to write
	push	ss
	push	ax			; address for return count
	os2call	DOSWRITE

;
;	write out CR-LF pair to standard output
;
	mov	ax,sp			; pointer to space for return count

	mov	bx,1
	push	bx			; file handle (standard output)
	push	cs
	mov	di,offset crlf
	push	di			; address of CR-LF pair
	mov	bx,2
	push	bx			; number of bytes to write: 2
	push	ss
	push	ax			; address for return count
	os2call	DOSWRITE
	pop	bx	;** ^^^ 	; deallocate space for return count
else
	push	es
	pop	ds
	mov	dx,bx			; ds:dx = string
	mov	bx,1			; bx = file handle (1)
	mov	ah,40H
	int	21h			; call DOS - write string

	push	cs
	pop	ds
	mov	dx,offset crlf		; ds:dx = CR/LF
	mov	cx,2			; cx = 2 bytes
	mov	ah,40H
	int	21h			; call DOS - write string
endif

pub	envmsgend
	pop	ds			; restore user data area
	mov	[Have8087],0		; indicate emulation
ifdef	_NO87INSTALL
	jmp	initinstallno87 	; go call __FPINSTALLNO87
else	;_NO87INSTALL
	jmp	initvec 		; initialize for emulation
endif	;_NO87INSTALL

pub	init1
	pop	ds			; restore user data area

endif	;only87


;	check if 8087/80287 is present

ifdef	DOS3and5
	cmp	[protmode],0		; check for protect mode
	jne	prot287chk		;   yes - check for 287
endif	;DOS3and5

ifdef	DOS3

;	real mode 8087/80287 check

ifdef	PCDOS
PCBIOSEQ	equ	11H		; PC BIO's Equipment determination call.
COPROCESSORMASK equ	 2H		; Mask for Coprocessor sense switch.

	int	PCBIOSEQ		; PC-DOS Bios Equipment
	and	al,COPROCESSORMASK	; Coprocessor present?
	shr	al,1			; al = 0 if no 8087/80287 , 1 = if yes
ifdef	only87
	jz	installerror		; error if no 8087/80287
endif	;only87
else
	fninit				; Initialize the 8087.
	wastetime
	xor	ax,ax			; Clean AX.
	mov	[statwd],ax		; Clear temporary.
	fnstcw	[statwd]		; have bits 033Fh  set	if  8087
	wastetime
	and	[statwd],0F3Fh	; (was 1F3Fh, but now allows for 80387-A1 step)
	cmp	[statwd],033Fh
	jnz	realno87		; no 8087 or 287

;	80287 can fool you - also check for status word

	fnstsw	[statwd]		; save status word
	wastetime
	inc	ax			; al = 1 (assume have an 80287)
	test	[statwd],0B8BFh 	; should be off if present

pub	realno87
	jz	realhave87
ifdef	only87
	jmp	short installerror	; error if no 8087/80287
else
	xor	ax,ax			; al = 0
endif	;only87

pub	realhave87
endif	;PCDOS

	MOV	[Have8087],al
endif	;DOS3

ifdef	DOS3and5
	jmp	short initinstall
endif	;DOS3and5

ifdef	DOS5

;	protect mode 80287 check

pub	prot287chk
	push	ds

	.286
	push	offset Have8087 	; directly change Have8087
	push	3			; 3rd byte is coprocessor flag
	push	0			; reserved parameter

ifndef	DOS5only
	.8086
endif

	os2call	DOSDEVCONFIG
ifdef	only87
	cmp	[Have8087],0		; error if no 87 present
	je	installerror
endif	;only87
endif	;DOS5

endif	;frontend


; check if floating point emulator/8087 already installed (device driver)

pub	initinstall

ifndef	QB3

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; check for 8087/80287
ifdef	_NO87INSTALL
	jne	initcontinue		
pub	initinstallno87
	extrn	__FPINSTALLNO87:near
	call	__FPINSTALLNO87
	jmp	initvec
initcontinue:
else	;_NO87INSTALL
	je	initvec 		;   no - don't install hardware
endif	;_NO87INSTALL
endif	;only87

ifdef	DOS3and5
	cmp	[protmode],0		; check for protect mode
	jne	initprotinstall 	;   yes - don't install hardware
endif	;DOS3and5
ifdef	DOS5only
	jmp	initprotinstall
endif

ifdef	DOS3
ifdef	standalone
	cmp	[Installed],0		; note - in code segment (not task)
	jnz	initvec 		;   installed - skip installation
endif	;standalone

	extrn	__FPINSTALL87:near
	call	__FPINSTALL87		; OEM installation
	jnc	initvec

endif	;DOS3

pub	installerror
	mov	ax,-2			; return installation error
	stc
	ret


ifdef	DOS5
pub	initprotinstall

	.286
	push	16			; exception error
	push	cs
	push	offset protexception
	push	ds
	push	offset oldvec+4 	; address for old exception vector

ifndef	DOS5only
	.8086
endif
	os2call	DOSSETVEC
endif	;DOS5
endif	;frontend

endif	;QB3

;	set up interrupt vectors for emulator or fixup-on-the-fly

pub	initvec

ifdef	DOS3and5
	cmp	[protmode],0
	jne	initvecprot		;   yes - protect mode setup
endif	;DOS3and5

ifdef	DOS3
;	real mode emulation and fixup on the fly vector setup

ifndef	QB3
	call	set_vectors
endif


endif	;DOS3
ifdef	DOS3and5
	jmp	short initfinish
endif

ifdef	DOS5
pub	initvecprot
ifndef	only87
	cmp	[Have8087],0		; emulation?
	jne	initfinish		;   no - don't setup vector

	.286
	push	7			; emulation
	push	cs
	push	offset protemulation
	push	ds
	push	offset oldvec		; address for old emulation vector

ifndef	DOS5only
	.8086
endif
	os2call	DOSSETVEC
endif	;only87
endif	;DOS5

;	finish initialization

pub	initfinish

	call	reset			; reset (0), FINIT if 8087 present

ifdef	QB3
	mov	ax,[initCW]
else
	mov	ax,InitControlWord	; setup initial control word
endif
	call	loadcontrolword

ifndef	QB3
	xor	ax,ax
	mov	word ptr [SignalAddress],ax    ; clear SignalAddress
	mov	word ptr [SignalAddress+2],ax
endif

ifdef  MTHREAD
	mov	[ExtendStack],1
endif	;MTHREAD


ifndef	only87
ifdef  LOOK_AHEAD
ifdef  DOS3and5
	mov	ax, offset DOSLookAhead
	cmp	[protmode], 0
	je	SetLookAheadRoutine

	mov	ax, offset ProtLookAhead
SetLookAheadRoutine:
	mov	[LookAheadRoutine], ax

endif	;DOS3and5
endif	;LOOK_AHEAD
endif	;not only87


	mov	al,[Have8087]
	cbw				; ax = 0 or 1 depending on 8087
	ret

ifdef  MTHREAD
lab  LoadDS_EDI 			; this is used from emds.asm
	push	bx
	push	cx
	push	dx

	mov	bx, DGROUP
	mov	ds, bx

	call	__FarGetTidTab
	mov	ds, dx
	mov	di, ax
	add	di, __fpds

	pop	dx
	pop	cx
	pop	bx

	ret
endif	;MTHREAD


;------ termination ----------------------------------------------------

pub	termination

ifdef	DOS3and5
	cmp	[protmode],0		; are we in protect mode?
	jne	termprot		;   yes
endif	;DOS3and5

ifdef	DOS3
;	real mode termination

ifndef	QB3
	call	rst_vectors
endif

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; Non zero if 8087 chip exists
ifdef	_NO87INSTALL
	jne	termcontinue
	extrn	__FPTERMINATENO87:near
	call	__FPTERMINATENO87
	ret
termcontinue:
else	;_NO87INSTALL
	je	termrealdone
endif	;_NO87INSTALL
endif	;only87

	FNINIT				; Clean up 8087.

ifndef	QB3
	extrn	__FPTERMINATE87:near
	call	__FPTERMINATE87 	; OEM 8087 cleanup routine
endif

endif	;frontend

pub	termrealdone
	ret
endif	;DOS3

ifdef	DOS5
;	protect mode termination

pub	termprot

;	UNDONE - don't do any cleanup - should be handled by DOS

ifndef	frontend			; UNDONE - should not be needed
	push	[SSalias]
	os2call	DOSFREESEG		; free up SSalias
endif	;frontend

ifdef	MTHREAD
	FREEthreadDS			; defined in emthread.asm
					; uses DOSFREESEG
endif	;MTHREAD

	ret
endif	;DOS5



subttl	emdos.asm - reset and clearexceptions
page
;*********************************************************************;
;								      ;
;		     Reset and Clearexceptions			      ;
;								      ;
;*********************************************************************;

pub	reset

ifndef	frontend
ifndef	only87
	cmp    [Have8087],0		; Nonzero if 8087 chip exists
	je     noFINIT
endif	;only87
	FNINIT				; Initialize 8087.
endif	;frontend

pub	noFINIT
	mov	ax,[BASstk]
	mov	[CURstk],ax		; reset stack to bottom

;	fall into clearexceptions


pub	clearexceptions

	xor	ax,ax
ifndef	frontend
ifndef	only87
	cmp	al,[Have8087]		; Nonzero if 8087 chip exists
	je	noFCLEX
endif	;only87
	FCLEX				; clear exceptions
endif	;frontend

pub	noFCLEX
ifndef	only87
	mov	[StatusWord],ax 	; clear status word
endif	;only87
	mov	[UserStatusWord],ax	; clear exception status word

ifdef	QB3
	mov	ax,[initCW]
	call	loadcontrolword 	; reload 8087 control word
endif	;QB3

	ret



subttl	emdos.asm - setsignal ---------------------------------
page
;*********************************************************************;
;								      ;
;		     Setsignal					      ;
;								      ;
;*********************************************************************;

ifndef	QB3

pub	setsignal
	mov	word ptr [SignalAddress],ax   ; set offset
	mov	word ptr [SignalAddress+2],dx ; set segment
	ret

endif	;QB3


ifdef	DOS3

pub	set_vectors

	mov	cx,NUMVEC		; save old vectors under DOS 3
	mov	ax,35h*256 + BEGINT	; get vector
	mov	di,offset oldvec	; di = old vector table
pub	getvecs
	int	21h
	inc	ax
	mov	[di],bx 		; save old vector
	mov	[di+2],es
	add	di,4
	loop	getvecs

ifndef	only87
	mov	dx,offset DStrap	; assume emulator
	mov	si,offset SOtrap
	mov	di,offset FWtrap
endif	;only87

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; are we using 8087 ?
	jz	setvectors		;    no - go ahead and set them
endif	;only87

	mov	dx,offset DSFixUpOnFly	; set up for fixup-on-the-fly
	mov	si,offset SOFixUpOnFly
	mov	di,offset FWFixUpOnFly
endif	;frontend

pub	setvectors
	push	ds

	push	cs
	pop	ds
	mov	ax,25h*256 + BEGINT
	mov	cx,8			; 8 vectors for DStrap
pub	vecloop
	int	21h			; set vector
	inc	ax			; bump to next one
	loop	vecloop

	mov	dx,si			; set Segtrap
	int	21h
	inc	ax
	mov	dx,di			; set FWtrap
	int	21h

	pop	ds			; restore task data area

	ret


pub	rst_vectors

	mov	cx,NUMVEC
	mov	ax,25h*256 + BEGINT	; set vector
	mov	di,offset oldvec	; di = old vector table

pub	termresetvecs
	push	ds
	lds	dx,[di] 		; get old vector value
	int	21h
	pop	ds
	inc	ax
	add	di,4
	loop	termresetvecs

	ret


endif	;DOS3



pub NumStack			; returns the number of stack elements in ax

	xor	dx, dx		; dx will count nonzero elements

ifndef	only87
	cmp	Have8087, 0
	je	CountEmulatorStack
endif	;only87

	sub	sp, 14		; need 14 bytes for fstenv
	mov	bx, sp
	fstenv	ss:[bx]
	fldcw	ss:[bx] 	; reset control word
	mov	ax, ss:[bx+4]	; put tag word in ax
	add	sp, 14		; reset stack

	mov	cx, 8
pub NotEmptyLoop
	mov	bx, ax

	shr	ax, 1
	shr	ax, 1

	and	bx, 3
	cmp	bx, 3
	je	StackEntryEmpty

	inc	dx		; stack element was not empty
pub StackEntryEmpty
	loop	NotEmptyLoop


pub CountEmulatorStack

	mov	ax, CURstk
	sub	ax, BASstk

	mov	bl, Reg87Len

	div	bl

	add	ax, dx		; add elements on 80x87 stack

	ret


ReturnHave8087 proc near

	mov	al, [Have8087]
	cbw

	ret
ReturnHave8087 endp


SetExtendedStack proc near

	mov	[ExtendStack], ax

	ret
SetExtendedStack endp

ProfEnd  DOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfixfly.asm ===
page	,132
	subttl	emfixfly.asm - Fixup-on-the-fly routines
;***
;emfixfly.asm - Fixup-on-the-fly routines
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Fixup-on-the-fly routines
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*******************************************************************************
;	03/29/85 - added 286 optimizations to change FWAITs to NOPs
;	09/10/87 - added FWAIT's for BASIC error handling
;	11/02/87 - changed FWFixUpOnFly to check for errors
;*******************************************************************************


ProfBegin FIXFLY


ifdef	DOS3

pub	SOFixUpOnFly
	sti				; turn on interrupts
	fwait				; For BASIC error handling
	push	ax
	push	bp
	push	ds
	push	si
	mov	bp,sp			; Point to stack
	lds	si,dword ptr 8[bp]	; Fetch ret address,(points to after instruction)
	mov	al,[si] 		; get ESC byte
	or	byte ptr [si],0C0h	; turn back into ESC x byte
	dec	si			; Make SI point to start off instruction
	dec	si
	mov	8[bp],si		; Change ret address to return to instruction
	shr	al,1			; move 2 bits into correct position
	shr	al,1
	shr	al,1
	not	al			; negate them
	and	al,018h 		; mask to middle 2 bits
	or	al,fES			; turn into correct segmented override
	xchg	al,ah			; into high half
	mov	al,fFWAIT		; low byte
	mov	[si],ax 		; stuff it
	push	bx
	mov	bx,1			; bx = 1 to skip segment override
ifdef	WF
	jmp	fixupdone
else
	jmp	short fixupdone
endif

;	new routine - don't back patch - check for error
;	UNDONE - need to change this for Windows - can't edit code
;		 need to check errorcode

pub	FWFixUpOnFly
	sti				; turn on interrupts
	fwait				; For BASIC error handling


ifdef	WF
wfFaultHere = $-1
;	int 3
	push	ds			; ds[18] retip[20] retcs[22] retfl[24]
	push	es			; es[16]
	pusha				;
	mov	bp, sp			;
	mov	ax, EMULATOR_DATA
	mov	ds, ax
	cmp	[wfGoFast], 1
	jnz	WinSlow
	push	[bp+22]			; faulting CS - get data alias
	push	[wfSel]
	call	ChangeSelector
	mov	es, [wfSel]
	sub	word ptr [bp+20], 2
	mov	bx, [bp+20]		; point to faulting insn
	xor	ax, ax
	xchg	[wfInsn], ax
	or	ax, ax			; are we here due to fault?
	je	wfNoFault
	mov	es:[bx], ax		; yes - restore 'fake' INT 3d
	xor	ax,ax
	xchg	[errorcode],al		; get and reset errorcode
	mov	REMLSW, ax		; save error code

	popa
	pop	es
	pop	ds
	jmp     WinFastContinue

;	mov	ax, 353eh
;	int	21h
;	mov	ax, es			; does app have a handler?
;	or	ax, bx
;	jz	wfDone
;
;	mov	ax, [wfErr]
;
;	push	cs			; return to wfDone
;	push	offset wfDone
;
;	push	es			; call app handler
;	push	bx
;
;	retf

FWAITNOP equ (iNOP + 256*fFWAIT)
wfNoFault:				; this was a 'real' INT 3d,
	mov	es:[bx], FWAITNOP	; so we'll patch it to inline code

wfDone:
	popa
	pop	es
	pop	ds
	iret

WinSlow:				; can't use fast method, fall through
	popa
	pop	es
	pop	ds			; fall through into old code
endif

ifdef	POLLING 			; new exception handling under POLLING

ifdef  USE_IRET
FWAITiret:
	iret				; Edit to nop if error occurs

elseifdef  WINDOWS

	push	ds
	push	ax

	mov	ax, EMULATOR_DATA
	mov	ds, ax

	cmp	[ExceptFlag], 0 	; if not zero, 80x87 exception occured.

	pop	ax
	pop	ds

	jnz	PolledException

	iret

else	;DEFUALT

FWAITRetF   db	  bRETF 		; Edit to 3 byte nop if error occurs
FWAITRetF2  dw	  2

endif	;DEFAULT


pub  PolledException
	push	eax			; same frame as in emerror.asm
	push	ds			; get address from task DS

ifdef	standalone
	xor	ax,ax
	mov	ds,ax
	mov	ds,ds:[4*TSKINT+2]

elseifdef  _COM_
	mov	ds, [__EmDataSeg]

else	;not standalone or _COM_
	mov	ax,EMULATOR_DATA
	mov	ds,ax
endif	;not standalone or _COM_

    ;*
    ;*	Reset fwait polling flag.
    ;*

ifdef  USE_IRET
	mov	byte ptr cs:[FWAITiret], bIRET	; reset "iret"

elseifdef  WINDOWS
	mov	[ExceptFlag], 0

else	;DEFAULT
	mov	[FWAITRetF], bRETF		; reset "retf 2"
	mov	[FWAITRetF2], 2
endif	;DEFAULT


	xor	ax,ax
	xchg	[errorcode],al		; get and reset errorcode


ifdef  WINDOWS
	mov	REMLSW, ax		; save error code

	pop	ds
	pop	ax			; stack is now just an int stack frame
WinFastContinue:
	inc	bp
	push	bp
	mov	bp, sp
	push	ds

	push	ax			; save user's ax

	push	cs			; must set up another stack frame
	mov	ax, offset FF_DummyReturn
	push	ax
FF_DummyReturn:

	mov	word ptr [bp-2], EMULATOR_DATA	; emulator's ds goes on first frame

	inc	bp
	push	bp
	mov	bp, sp
	push	ds			; push user's ds onto dummy stack frame

	mov	ax, EMULATOR_DATA
	mov	ds, ax

	push	es			; if windows => setup SignalAddress for
	push	bx			; far call

	mov	ax, DOS_getvector*256 + TSKINT
	IntDOS

	mov	word ptr [SignalAddress], bx
	mov	word ptr [SignalAddress+2], es

	pop	bx
	pop	es

	mov	ax, REMLSW		; al = error code

	call	[SignalAddress] 	; execute signal routine

	pop	ds			; restore user's ds
	add	sp, 6			; get rid of dummy stack frame
	pop	ax			; restore user's ax

	add	sp, 2			; get rid of emulator ds on stack

	pop	bp
	dec	bp

	iret				; return

else	;not WINDOWS

	call	[SignalAddress] 	; execute signal routine

	pop	ds			; restore user DS
	pop	eax
	iret

endif	;not WINDOWS


else	;not POLLING
	push	ax
	mov	ax,FIWRQQ		; isolated FWAIT fixup
	jmp	short FixUpOnFly
endif	;not POLLING

pub	DSFixUpOnFly
	sti				; turn on interrupts
	fwait				; For BASIC error handling
	push	ax
	mov	ax,FIDRQQ		; DS segment fixup

pub	FixUpOnFly
	PUSH	BP
	PUSH	DS
	PUSH	SI
	MOV	BP,SP			; Point to stack
	LDS	SI,dword ptr 8[BP]	; Fetch ret address,(points to after instruction)
	DEC	SI			; Make SI point to instruction
	DEC	SI
	MOV	8[BP],SI		; Change ret address to return to instruction
	SUB	[SI],ax 		; Remove Fixup to convert to 8087 instruction
	push	bx
	xor	bx,bx			; bx = 0 for no segment override

;	For the 286 change FWAITs on numeric instructions to NOPs
;
;	ds:si = FWAIT address
;	ds:(si+bx+1) = 8087/287 instruction

pub	fixupdone
	push	sp			; check for 286
	pop	ax
	cmp	ax,sp
	jne	fixupxit		; not 286

	mov	ax,[bx+si+1]		; get instruction
	and	ax,030FBh		; mask for FSTCW/FSTSW/FSTENV/FSAVE
	cmp	ax,030D9h		; underlying bits
	jne	fixcheck2		; not one of the above
	mov	al,[bx+si+2]		; get 2nd byte of instruction again
	cmp	al,0F0h 		; check if kernel functions
	jb	fixupxit		;   no - exit

pub	fixcheck2
	mov	ax,[bx+si+1]		; get instruction
	and	ax,0FEFFh		; mask for FCLEX/FINIT
	cmp	ax,0E2DBh		; underlying bits
	je	fixupxit		; can't remove FWAIT

	mov	ax,[bx+si+1]		; get instruction
	cmp	ax,0E0DFh		; check for FSTSW AX
	je	fixupxit		; can't remove FWAIT

	mov	byte ptr [si],iNOP	; NOP the FWAIT

pub	fixupxit
	pop	bx
	POP	SI
	POP	DS
	POP	BP
	pop	ax
	IRET


endif	;DOS3

ProfEnd  FIXFLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfmul.asm ===
page	,132
	subttl	emfmul.asm - Multiplication
;***
;emfmisc.asm - Multiplication
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Multiplication
;
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;	     Multiplication		  ;
;					  ;
;-----------------------------------------;

; Perform multiply by summing partial products of 16x16 hardware multiply.
; Before each multiply, the operands are checked for zero to see if it can be
; skipped, since it's a slow operation on the 8086.  The sum is kept in
; registers as much as possible.  Any insignificant bits lost are ORed together
; and kept in a word on the top of the stack.  This can be used for sticky bit
; rounding. First we will need some macros.

ProfBegin FMUL


MULP	MACRO	SIOFFSET,DIOFFSET,NEXTLOC
	;Will multiply the words found at the given offsets if those words
	;are non-0. since we assume the numbers are normalized and the
	;most significant word has offset 6 we know that words with offset
	;6 are non-0 hence the conditional code in this macro.

	MOV	AX,SIOFFSET[esi]

    IF	SIOFFSET - 6	  ;When SI offset is 6 it is most sig word hence not 0
	OR	AX,AX
	JZ	short NEXTLOC
    ENDIF

    IF	DIOFFSET - 6
	MOV	DX,DIOFFSET[edi]
	OR	DX,DX
	JZ	short NEXTLOC
	MUL	DX
    ELSE
	MUL	WORD PTR DIOFFSET[edi]
    ENDIF

ENDM

ADDP	MACRO	HI,MID,LO
	;Will add the double word result of a multiply to the triple word
	; at HI:MID:LO using HI to record overflow

	ADD	LO,AX
	ADC	MID,DX
	ADC	HI,0
ENDM

STICKY	MACRO	R
	;R is the register containing the least significant word which
	;should be ORed to the sticky bit (kept on the stack) and then
	;cleared so the register can be reused

	POP	eax
	OR	AX,R
	PUSH	eax
	XOR	R,R
ENDM

page


RMBRQQ:     ; Routine MUL Both	 must see if we have two singles.

if	fastSP
	MOV	BX,DX
	XOR	BX,Single + 256*Single
	TEST	BX,Single + 256*Single
	JNZ	RMDRQQ
	MOV	BX,OFFSET TMSRQQ
	JMP	[BX]
endif	;fastSP


pub	RMDRQQ	;RoutineMulDouble     SI & DI point to valid non-0 reals
				; AX   CX  are the exponents
				; DL   DH  are the signs
if	fastSP
	CALL	CoerceToDouble	; insure that both args are double
endif	;fastSP

	PUSH	ebp		; Must save BP
	MOV	BH,DH		; Save Single double flag
	XOR	DH,DL		; Get sign onto stack
	PUSH	edx
	ADD	AX,CX		; New exponent is sum of old plus 1
	INC	AX		;  because of the normalize step
	PUSH	eax		; Save it while we Multiply
	AND	BH,DL

pub	PROD1
	XOR	BX,BX
	MOV	BP,BX
	MOV	CX,BX
	MULP	0,0,PROD2
	MOV	BP,AX		; Save insignificant bits
	MOV	CX,DX
pub	PROD2
	PUSH	ebp		; Save Sticky bit on stack
	xor	ebp, ebp	; bp is now the working high word of bp:bx:cx
	MULP	0,2,PROD3
	ADDP	BP,BX,CX
pub	PROD3
	MULP	2,0,PROD4
	ADDP	BP,BX,CX

pub	PROD4
	STICKY	CX
	MULP	0,4,PROD5
	ADDP	CX,BP,BX
pub	PROD5
	MULP	2,2,PROD6
	ADDP	CX,BP,BX
pub	PROD6
	MULP	4,0,PROD7
	ADDP	CX,BP,BX

pub	PROD7
	STICKY	BX
	MULP	0,6,PROD8
	ADDP	BX,CX,BP
pub	PROD8
	MULP	2,4,PROD9
	ADDP	BX,CX,BP
pub	PROD9
	MULP	4,2,PROD10
	ADDP	BX,CX,BP
pub	PROD10
	MULP	6,0,PROD11
	ADDP	BX,CX,BP

pub	PROD11
	MOV	DX,BP		; Everything but guard and round go to sticky
	AND	BP,03FFFH
	STICKY	BP
	PUSH	edx		; Save guard and round on stack
	MULP	2,6,PROD12
	ADDP	BP,BX,CX
pub	PROD12
	MULP	4,4,PROD13
	ADDP	BP,BX,CX
pub	PROD13
	MULP	6,2,PROD14
	ADDP	BP,BX,CX

pub	PROD14
	PUSH	ecx		; Save LSW on stack (not enough registers)
	XOR	CX,CX
	MULP	4,6,PROD15
	ADDP	CX,BP,BX
pub	PROD15
	MULP	6,4,PROD16
	ADDP	CX,BP,BX

pub	PROD16
	MULP	6,6,PROD17
	ADD	AX,BP
	ADC	DX,CX
	POP	ecx
	POP	ebp		; Result in DX:AX:BX:CX:BP Sticky on stack

	MOV	DI,DX
	MOV	DX,CX
	MOV	CX,BX
	MOV	BX,AX		; Result in DI:BX:CX:DX:BP
	POP	eax		; Merge Sticky bit into BP
	OR	AX,AX
	JZ	short STBITOK
	OR	BP,1
pub	STBITOK
	POP	esi		; Exponent in SI, Sign on Stack, Old BP on Stack
	JMP	NORMSHF 	; Result must be normalized at most 1 bit

ProfEnd  FMUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfsqrt.asm ===
page	,132
	subttl	emfsqrt.asm - Square root
;***
;emfsqrt.asm - Square root
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Square root
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;	     Square root		  ;
;					  ;
;-----------------------------------------;

ProfBegin FSQRT


pub	eFSQRT
	MOV	esi,[CURstk]
	CALL	$FSQRT
	RET

;---------------------------------------------------
;						   !
;	8087 emulator square root		   !
;						   !
;---------------------------------------------------

;  With 0<=x={TOS=[SI]}<infinity,  $FSQRT  performs   {TOS=[SI]}   <--
;  {TOS=[SI]}^.5.  All	registers  except  SI  are  destroyed.	 Roots
;  of negative numbers, infinities, and NAN's result in  errors.   The
;  square root	of  -0	is  -0.   Algorithm:   x is initially adjusted
;  so that the exponent is even (when the exponent is odd the exponent
;  is incremented  and	the  mantissa  is shifted right one bit).  The
;  exponent is then  divided  by  two  and  resaved.   A  single  word
;  estimate of	y (the root of x) accurate to 5 bits is produced using
;  a wordlength implementation of a  linear  polynomial  approximation
;  of  sqrt  x.  Four  Newton-Raphson  iterations are then computed as
;  follows:
;
;  1) qa*ya+r1a=xa:0h,ya=(ya+qa)/2
;  2) qa*ya+r1a=xa:xb,ya=(ya+qa)/2
;  3) qa*ya+r1a=xa:xb,qb*ya+r2a=r1a:xc,ya:yb=(ya:yb+qa:qb)/2
;  *** iteration 4 implemented with standard divide ***
;  4) qa*ya+r1a=xa:xb,p1a:p1b=qa*yb,
;     if p1a<r1a continue
;	 if p1a=r1a
;	    if p1b=xc continue else r1a=r1a+ya,qa=qa-1 endif,
;	 else r1a=r1a+ya,qa=qa-1,p1a:p1b=p1a:p1b-yb endif,
;     r1a:r1b=r1a:xc-p1a:p1b,
;     qb:ya+r2a=r1a:r1b,p2a:p2b=qb*yb,
;     if p2a<r2a continue
;	 if p2a=r2a
;	    if p2b=xd continue else r2a=r2a+ya,qb=qb-1 endif,
;	 else r2a=r2a+ya,qb=qb-1,p2a:p2b=p2a:p2b-yb endif,
;     r2a:r2b=r2a:xd-p2a:p2b,
;     qc*ya+r3a=r2a:r2b,p3a:p3b=qc*yb,
;     if p3a>=r3a then r3a=r3a+ya,qc=qc-1 endif,
;     r3a=r3a-p3a,qd*ya+r4a=r3a:0h,
;     ya:yb:yc:yd=(ya:yb:0h:0h+qa:qb:qc:qd)/2

pub	SQRTSPECIAL
	RCR	AH,1			;if NAN
	JNC	short SETFLAG		;   set invalid flag and return
	RCL	AL,1			;if -infinity
	JC	short SQRTERROR 	;   return real indefinite
	MOV	AL,[CWcntl]		;get Infinity control
	TEST	AL,ICaffine		;if affine closure
	JNZ	short SQRTDONE		;   return +infinity
	JMP	SHORT SQRTERROR 	;else return real indefinite

pub	NOTPOSVALID
	TEST	AH,2			;if special
	JNZ	SQRTSPECIAL		;   process special
	RCR	AH,1			;if zero
	JC	SHORT SQRTDONE		;   return argument
					;otherwise -ve, return NAN

pub	SQRTERROR
	MOV	edi,esi
	MOV	esi,offset IEEEindefinite
	CALL	csMOVRQQ
	MOV	esi,edi 		;return indefinite

pub	SETFLAG
	OR	[CURerr],Invalid+SquareRootNeg	;Set flag indicating invalid

pub	SQRTDONE
	RET

pub	$FSQRT
	MOV	AX,[esi+Flag]		;get flags
	TEST	AX,00380H		;if Sign, Invalid or Zero
	JNZ	NOTPOSVALID		;   perform special processing
	PUSH	esi			;save ptr to x
	MOV	edi,offset TEMP1	;[DI]=y=temp
	MOV	word ptr [edi+Flag],0	;clear flags in y
	MOV	AX,[esi+Expon]		;get exponent of x
	DEC	AX			;adjust for shift divide by 2
	MOV	BX,[esi+6]
	MOV	CX,[esi+4]
	MOV	DX,[esi+2]		;get first three mantissa words of x
	TEST	AL,1			;if exponent is even
	JZ	short EXPEVEN		;   bypass adjust
	INC	AX			;increment exponent
	SHR	BX,1
	RCR	CX,1
	RCR	DX,1			;divide mantissa by 2

pub	EXPEVEN
	SAR	AX,1			;divide exponent by 2
	MOV	[edi+Expon],AX		;store exponent of y
	CMP	BX,0FFFEH		;if mantissa < 0.FFFEh
	JB	short NOTNEARONE1	;   perform main root routine
	STC				;otherwise x to become (1+x)/2
	JMP	SHORT SINGLEDONE	;single precision complete

pub	NOTNEARONE1
	PUSH	edx			;save third mantissa word
	MOV	AX,0B075H		;AX=.B075h
	MUL	BX			;DX=.B075h*x
	MOV	BP,057D8H		;BP=.57D8h
	ADD	BP,DX			;BP=.B075h*x+.57D8h
	JNC	short NORMEST		;if y is more than one
	MOV	BP,0FFFFH		;   replace y with .FFFFh

pub	NORMEST
	MOV	DX,BX
	XOR	AX,AX			;load divide regs with xa:0h
	DIV	BP			;qa*ya+r1a=xa:0h
	ADD	BP,AX			;ya=ya+qa
	RCR	BP,1			;ya=ya/2
	MOV	DX,BX
	MOV	AX,CX			;load divide regs with xa:xb
	DIV	BP			;qa*ya+r1a=xa:xb
	STC				;add one to qa for better rounding
	ADC	BP,AX			;ya=ya+qa
	RCR	BP,1			;ya=ya/2
	MOV	DX,BX
	MOV	AX,CX			;load divide regs with xa:xb
	DIV	BP			;qa*ya+r1a=xa:xb
	MOV	SI,AX			;save qa
	POP	eax			;load divide regs with r1a:xc
	DIV	BP			;qb*ya+r2a=r1a:xc
	MOV	BX,BP
	MOV	CX,AX			;move qa:qb
	ADD	CX,1			;add one to qa:qb for better rounding
	ADC	BX,SI			;ya:yb=ya:0h+qa:qb

pub	SINGLEDONE
	RCR	BX,1
	RCR	CX,1			;ya:yb=(ya:0h+qa:qb)/2
	MOV	word ptr [edi+6],BX
	MOV	word ptr [edi+4],CX
	MOV	word ptr [edi+2],0
	MOV	word ptr [edi],0	;save ya:yb:0h:0h
	MOV	esi,edi 		;[SI]=y
	POP	edi			;[DI]=x
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=x/y
	MOV	esi,offset TEMP1	;[SI]=y
	CALL	ADDRQQ			;[DI]=y+x/y
	DEC	word ptr [edi+Expon]	;[DI]=(y+x/y)/2=TOS
	MOV	esi,edi 		;[SI]=sqrt(x)
	RET

ProfEnd  FSQRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfprem.asm ===
page	,132
	subttl emfprem.asm - fprem
;***
;emfprem.asm - FPREM emulation
;
;	Copyright (c) 1987, Microsoft Corporation
;
;Purpose:
;	To emulate the 8087/80287 FPREM instruction.
;
;Revision History:
;   08-12-86  JMB   Initial version
;
;   09-23-86  JMB   Changed from unsigned (jnc) to signed branch
;		    (jge) on lc < 0 comparison
;
;   10-24-86  BCM   Fixed a problem with large quotients that
;		    caused a signed comparison (cmp bp,2) to
;		    behave in an undesired manner when bp (quotient)
;		    becomes larger than 32767; we now use bigquot
;		    to indicate a quotients overflowing an unsigned word
;		    Also, the quotient is now enregistered in bp
;		    through most of the FPREM algorithm.
;
;   11-14-86  BCM   Fixed a problem with the 4-word comparison of
;		    numerator and denominator mantissas by substituting
;		    unsigned-compare jumps (JB and JA) for signed-compare
;		    jumps (JL and JG).
;
;   Also see emulator.hst
;
;*******************************************************************************

;	The following is a working C program which was used to simulate
;	floating point numbers and to test the algorithm used in the
;	fprem emulation.

;#include <math.h>
;#include <stdio.h>
;
;typedef struct floating {
;	unsigned long man;
;	unsigned int expo;
;	} FLOAT_NUM;
;
;double fprem(double,double,unsigned int *);
;
;#define normalize(n) while (n&0x8000==0) { \
;			if (lc == 0) \
;			    return(ldexp((double)(num.man)/65536,den.expo)); \
;			n <<= 1; \
;			lc--; \
;			*pq <<=1; \
;			}
;
;
;main() {
;	unsigned int qv,qt;
;	double n,d,rv,rt;
;	FILE *fpinp;
;
;	fpinp = fopen("fprem.dat","r");
;	if (fpinp) {
;		while (fscanf(fpinp,"%E %E",&n,&d) != EOF) {
;			qv=(unsigned int)(n/d);
;			rv=n-(d*qv);
;			printf(" \nnumerator is %f\n denominator is %f",n,d);
;			printf(" \nquotient is %x\n remainder is %f",qv,rv);
;			rt = fprem(n,d,&qt);
;			printf(" \nquotient is %x\n remainder is %f\n\n",qt,rt);
;			}
;		fclose(fpinp);
;		}
;	else
;		printf(" \nerror opening fprem.dat");
;	}
;
;double fprem(n,d,pq)
;	double n,d;
;	unsigned int *pq; {
;	int lc;
;	FLOAT_NUM num;
;	FLOAT_NUM den;
;
;	num.man = (unsigned long)(65536*frexp(n,&num.expo));
;	den.man = (unsigned long)(65536*frexp(d,&den.expo));
;
;	printf(" \nnumerator mantissa: %lx",num.man);
;	printf(" \nnumerator exponent: %x",num.expo);
;	printf(" \ndenominator mantissa: %lx",den.man);
;	printf(" \ndenominator exponent: %x",den.expo);
;
;	*pq=0;
;	lc = num.expo - den.expo;
;	if (lc < 0) { /* then the numerator is the remainder */
;		return(ldexp((double)(num.man)/65536,num.expo));
;		}
;	while(1) {
;		if (den.man <= num.man) { /* do subtraction */
;			num.man -= den.man;
;			(*pq)++;
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}
;			normalize(num.man)
;			}
;		else { /* don't do the subtraction */
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}
;
;			num.man <<= 1;
;			lc--;
;			(*pq) <<= 1;
;
;			num.man -= den.man;
;			(*pq)++;
;
;			normalize(num.man)
;			}
;		}
;	}

;***
;eFPREM - entry point for FPREM emulation
;Purpose:
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;*******************************************************************************

ProfBegin FPREM


pub	eFPREM

; NOTE: The C program excerpts interspersed below are from the C program
;	shown in its entirety above.
;
;	The correspondence between the C variables and the assembly
;	language version is as follows:
;
;		C version		masm version
;		*pq			bp (quotient)
;		lc			loopct
;		num.expo		Expon[di]
;		den.expo		Expon[si]
;		num.man 		MB0[di],MB2[di],MB4[di],MB6[di]
;		den.man 		MB0[si],MB2[si],MB4[si],MB6[si]

;	*pq=0;
;	lc = num.expo - den.expo;

	push	ebp			;save bp; use bp as quotient

	mov	edi,[CURSTK]		;point to ST(0), the numerator
	mov	[RESULT],edi		;ST(0) is result (remainder)
	xor	bp,bp			;begin with quotient = 0
	mov	bigquot,0		;quotient not > 65535 yet
	mov	esi,edi 		;si points to ST(0)
	sub	esi,Reg87Len		;si points to ST(1), the denominator

	mov	ax,word ptr Expon[edi]	;ax <== numerator exponent
	sub	ax,word ptr Expon[esi]	;loopct = (num exponent - den exponent)

	mov	loopct,ax

	mov	dx,MB0[edi]		;move the mantissa of the
	mov	cx,MB2[edi]		;numerator into
	mov	bx,MB4[edi]		;ax:bx:cx:dx
	mov	ax,MB6[edi]

;	if (lc < 0) { /* then the numerator is the remainder */
;		return(ldexp((double)(num.man)/65536,num.expo));
;		}
	jge	short fpremLoop
	mov	si,Expon[edi]
	jmp	DoneEarly

;	while(1) {
fpremLoop:

;		if (den.man <= num.man) { /* do subtraction */
	cmp	ax,MB6[esi]		;compare msw of num to msw of den
	jb	short NumLess		;numerator is less
	ja	short NumMore		;numerator is more
	cmp	bx,MB4[esi]		;compare word 2 of num to word 2 of den
	jb	short NumLess		;numerator is less
	ja	short NumMore		;numerator is more
	cmp	cx,MB2[esi]		;compare word 4 of num to word 4 of den
	jb	short NumLess		;numerator is less
	ja	short NumMore		;numerator is more
	cmp	dx,MB0[esi]		;compare lsw of num to lsw of den
	jb	short NumLess		;numerator is less

;			num.man -= den.man;
;			(*pq)++;
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}

NumMore:
	call	SubInc			;do subtraction, increment quotient
	cmp	loopct,0		;is expon diff zero?
	je	short Done		;yes, then we're done

;			normalize(num.man)
;			}

	call	fpremNorm		;normalize the numerator
	jnz	fpremLoop		;do the next iteration
	jmp	short Done		;loop counter is zero; we're done

;		else { /* don't do the subtraction */
;			if (lc == 0) {
;				/* normalize(num.man) */
;				return(ldexp((double)(num.man)/65536,den.expo));
;				}
NumLess:
	cmp	loopct,0		;is expon diff zero?
	je	short Done		;yes, then all done

;
;			num.man <<= 1;
;			lc--;
;			(*pq) <<= 1;
	call	ShiftDec		;shift quotient, numerator

;
;			num.man -= den.man;
;			(*pq)++;
	call	SubInc			;do subtraction, increment quotient
;
;			normalize(num.man)
;			}
	call	fpremNorm		;normalize for next iteration
	jnz	fpremLoop		;do next iteration
	jmp	short Done		;loop counter is zero; we're done

;	remainder:	ax:bx:cx:dx is mantissa; Expon[si] is the exponent
Done:

;NOTE: the rounding routine wants the mantissa in di:bx:cx:dx:bp
;	the exponent in SI the sign and the old BP on the stack
	mov	si,Expon[esi]		; mov exponent to si

DoneEarly:
	mov	di,Flag[edi]		; move sign of remainder to di
	xchg	di,ax			; di becomes high mantissa word
	mov	ah,al			; move sign to ah
	push	ax			; put sign on stack

; Except for bp which gets zeroed out later,
; everything is now set up the way it needs to be for the normalization
; routine, NODRQQ.  Before we go there we need to set up the status
; word as it should be set by fprem.  For simplicity we did a complete
; reduction of the dividend in one pass, so we will always clear C2
; to indicate that the reduction is complete.

	mov	ax,bp			; move quotient into ax
	and	bp,0FFFCh		; check if quotient mod 64K < 4
	or	bp,bigquot		;      and quotient < 64K

; bp is zero if and only if quotient < 4
; (bp no longer holds the quotient itself)
; al has low byte of quotient
; ah will be for C0-C3 flags

	mov	ah,SWcc 		; move status word to ah
	and	ah,not C2		; clear C2 to indicate complete
	test	al,01h			; is low bit of quotient set?
	jnz	short SetC1		; yes, go set C1
	and	ah,not C1		; low bit off, turn off C1
	jmp	short DoC3		; do the C3 bit
SetC1:
	or	ah,C1			; low bit on, turn on C1

DoC3:
	test	al,02h			; is bit 1 of quotient set?
	jnz	short SetC3		; yes, go set C3
	or	bp,bp			; is quotient less than 4?
	jz	short QuotL2		; then quotient < 2 (bit 1 off)
					; so don't set c0 or c3 from quotient
					; else if quotient >= 4
	and	ah,not C3		; bit 1 is off, so turn off C3
	jmp	short DoC0		; do the C0 bit
SetC3:
	or	ah,C3			; bit 1 on, turn on C3

DoC0:
	test	al,04h			; is bit 2 of quotient set?
	jnz	short SetC0		; yes, go set C0
	or	bp,bp			; is quotient less than 4?
	jz	short QuotL4		; yes, don't set c0 from quotient
					; else if quotient >= 4
	and	ah,not C0		; bit 2 off, turn off C0
	jmp	short GoNormal		; we're done, go normalize

SetC0:
	or	ah,C0			; bit 1 on, turn on C0
GoNormal:
	mov	SWcc,ah 		; set new status word
	xor	bp,bp			; clear low mantissa word
	jmp	NODRQQ			; go normalize
					; (does pop ax, pop bp)

; special case code if quotient is less than 2

QuotL2:
	mov	al,SWcc 		; get old status word
	test	al,C1			; was C1 set
	jnz	short SetC3toC1 	; yes, set C3
	and	ah,not C3		; clear C3
	jmp	short QuotL4

SetC3toC1:
	or	ah,C3			; set C3

; special case code if quotient is less than 4

QuotL4:
	mov	al,SWcc 		; get old status word
	test	al,C3			; was C3 set
	jnz	short SetC0toC3 	; yes, set C0
	and	ah,not C0		; clear C0
	jmp	short GoNormal		; go normalize the result

SetC0toC3:
	or	ah,C0			; set C0
	jmp	short GoNormal		; go normalize the result

;#define normalize(n) while (n&0x8000==0) { \
;			if (lc == 0) \
;			    return(ldexp((double)(num.man)/65536,den.expo)); \
;			n <<= 1; \
;			lc--; \
;			*pq <<=1; \
;			}

;Inputs: ah contains high byte of numerator mantissa
;Outputs: zero flag set indicates the loop counter is zero so we're finished
;	  zero flag clear indicates the number was already normalized
fpremNorm:
	test	ah,80h			;is the numerator normalized?
	jnz	short fpremIsNorm	;yes
					;no, normalize it
	cmp	loopct,0		;is expon diff zero?
	je	short fpremIsNorm	;yes, then we're done
	call	ShiftDec		;shift num, quotient
					;decrement loop ctr
	jmp	short fpremNorm

fpremIsNorm:
	ret

ShiftDec:
	shl	dx,1			;numerator*2
	rcl	cx,1
	rcl	bx,1
	rcl	ax,1
	dec	loopct			;reduce exponent diff by one
	shl	bp,1			;quotient*2
	jc	short QuotLarge 	;carry out on quotient shift
	ret
QuotLarge:
	mov	bigquot,1		;indicate large quotient > 65535
	ret

SubInc:
	sub	dx,MB0[esi]		;subtract lsw of den from lsw of num
	sbb	cx,MB2[esi]		;subtract next word of den from num
	sbb	bx,MB4[esi]		;subtract next word of den from num
	sbb	ax,MB6[esi]		;subtract msw of den from msw of num
	inc	bp			;add one to quotient
	ret


ProfEnd  FPREM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emintern.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emintern.asm - Emulator Internal Format and Macros
page
;---------------------------------------------------------------------------
;
; Emulator Internal Format:
;
;	     +0  +1  +2  +3  +4  +5  +6  +7  +8  +9  +10 +11
;	    .___.___.___.___.___.___.___.___.___.___.___.___.
;   ptr --> |___|___|___|___|___|___|___|___|___|___|___|___|
;	     lsb			 msb exl exh flg tag
;	    |<---      mantissa 	--->|exponent
;
;   The mantissa contains the leading 1 before the decimal point in the hi
;   bit of the msb. The exponent is not biased i.e. it is a signed integer.
;   The flag and tag bytes are as below.
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Flag:   |___|_X_|_X_|_X_|_X_|_X_|_X_|___|  X = unused
;	      ^ 			  ^
;	     SIGN			SINGLE (=1 if single precision)
;
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Tag:    |_X_|_X_|_X_|_X_|_X_|_X_|___|___|  X = unused
;				      ^   ^
;				      |   |
;    Special (Set for NAN or Inf)  ---+   |
;    ZROorINF (Set for 0 or Inf)   -------+
;
PAGE
; Data Structure Equates
Lsb		equ	0
Msb		equ	7
 MB0		equ	0
 MB1		equ	1
 MB2		equ	2
 MB3		equ	3
 MB4		equ	4
 MB5		equ	5
 MB6		equ	6
 MB7		equ	7

Expon		equ	8

Flag		equ	10
 Sign		equ	128
if	fastSP
 Single 	equ	1
endif

Tag		equ	11
 Special	equ	2
 ZROorINF	equ	1

Reg87Len	equ	12

MantissaByteCnt equ	Msb - Lsb + 1
IexpBias	equ	3FFFh	; 16,383
IexpMax 	equ	7FFFh	; Biased Exponent for Infinity
IexpMin 	equ	0	; Biased Exponent for zero

DexpBias	equ	3FFh	; 1023
DexpMax 	equ	7FFh	; Biased Exponent for Infinity
DexpMin 	equ	0	; Biased Exponent for zero

SexpBias	equ	07Fh	; 127
SexpMax 	equ	0FFh	; Biased Exponent for Infinity
SexpMin 	equ	0	; Biased Exponent for zero

; Control Word Format	CWcntl
InfinityControl 	equ	10h
    ICaffine		equ	10h
    ICprojective	equ	 0

RoundControl		equ	0Ch
    RCchop		equ	0Ch
    RCup		equ	08h
    RCdown		equ	04h
    RCnear		equ	 0

PrecisionControl	equ	03h
    PC24		equ	 0
    PC53		equ	02h
    PC64		equ	03h

; Status Word Format	SWcc
    C0			equ	01h
    C1			equ	02h
    C2			equ	04h
    C3			equ	40h
ConditionCode		equ	C0 + C1 + C2+ C3
    CCgreater		equ	 0
    CCless		EQU	C0
    CCequal		equ	C3
    CCincomprable	equ	C3 + C2 + C0


; Status Flags Format	CURerr

Invalid 		equ	   1h		; chip status flags
Denormal		equ	   2h
ZeroDivide		equ	   4h
Overflow		equ	   8h
Underflow		equ	  10h
Precision		equ	  20h

Unemulated		equ	  40h		; soft status flags
SquareRootNeg		equ	  80h
IntegerOverflow 	equ	 100h
StackOverflow		equ	 200h
StackUnderflow		equ	 400h

UStatMask		equ	1FFFh		; user status flags

MemoryOperand		equ	2000h		; special instruction flags
Reexecuted		equ	4000h


;	floating point error signals (also used as DOS return code)

errInvalid		equ	81h		; sorted as above
errDenormal		equ	82h
errZeroDivide		equ	83h
errOverflow		equ	84h
errUnderflow		equ	85h
errPrecision		equ	86h

errUnemulated		equ	87h
errSquareRootNeg	equ	88h
errIntegerOverflow	equ	89h
errStackOverflow	equ	8Ah
errStackUnderflow	equ	8Bh


subttl	emintern.asm - Emulator interrupt frame
page

; define emulator interrupt frame

ifdef	i386

ifdef	XENIX

;	386 frame for XENIX

frame		struc			; emulator interrupt frame

regEAX		dd	?		; 386 registers
regECX		dd	?
regEDX		dd	?
regEBX		dd	?
regESP		dd	?
regEBP		dd	?
regESI		dd	?
regEDI		dd	?

regSegOvr	dw	?,?		; segment override for bp relative EAs
regES		dw	?,?
regDS		dw	?,?

regAX		dw	?,?		; original EAX - stuff area for FSTSW AX
regSS		dd	?		; need to save ss
regEIP		dd	?
regCS		dw	?,?
regFlg		dd	?

frame		ends

else

;	386 frame

frame		struc			; emulator interrupt frame

regEAX		dd	?		; 386 registers
regECX		dd	?
regEDX		dd	?
regEBX		dd	?
regESP		dd	?
regEBP		dd	?
regESI		dd	?
regEDI		dd	?

regSegOvr	dw	?,?		; segment override for bp relative EAs
regES		dw	?,?
regDS		dw	?,?

regAX		dw	?,?		; original EAX - stuff area for FSTSW AX
regEIP		dd	?
regCS		dw	?,?
regFlg		dd	?

frame		ends

endif

else

;	286 frame

frame		struc			; emulator interrupt frame

regBP		dw	?
regSegOvr	dw	?		; segment override for bp relative EAs
regBX		dw	?
regCX		dw	?
regDX		dw	?
regSI		dw	?
regDI		dw	?
regDS		dw	?
regES		dw	?
regAX		dw	?
regIP		dw	?
regCS		dw	?
regFlg		dw	?

frame		ends

endif	;i386


subttl	emintern.asm - User Memory Management Macros
page
;*********************************************************************;
;								      ;
;		      User Memory Management Macros		      ;
;								      ;
;*********************************************************************;

; All user data access uses these five macros.

; Load user memory word at (DS:)SI to AX register;  smash AX only

LDUS2AX MACRO
	lods	word ptr es:[esi]		; 12 move word from ES:SI to AX
	ENDM


; Store word from AX to user memory at (ES:)DI;  smash AX only

STAX2US MACRO
	stos	word ptr es:[edi]		; 10 move word from AX to ES:DI
	ENDM


; Move user memory word at (DS:)SI to local at (ES:)DI;  smash AX only

MVUS2DI MACRO
	movs	word ptr es:[edi],word ptr ds:[esi] ; 18 move word from DS:SI to ES:DI
	ENDM


; Move local word at (DS:)SI to user memory at (ES:)DI;  smash AX only

MVSI2US MACRO
	movs	word ptr es:[edi],word ptr ds:[esi] ; 18 move word from DS:SI to ES:DI
	ENDM


; Move local word at (CS:)SI to user memory at (ES:)DI;  smash AX only

csMVSI2US MACRO
	movs	word ptr es:[edi],word ptr cs:[esi]
	ENDM

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emlsquad.asm ===
page	,132
	subttl	emlsquad.asm - Load/Store 64-bit integers
;***
;emlsquad.asm - Load/Store 64-bit integers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store 64-bit integers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		 Load Quad (64 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 64 bit integer


ProfBegin LSQUAD

pub	eFLDlongint
	LDUS2AX 		; Fetch the integer
	MOV	DX,AX		;  into DI:BP:BX:DX
	LDUS2AX
	MOV	BX,AX
	LDUS2AX
	MOV	BP,AX
	LDUS2AX
	MOV	DI,AX

	OR	AX,BP
	OR	AX,BX
	OR	AX,DX
	JZ	short Jmp2LoadZero

	MOV	AX,63		; Exponent would be 63 if no shifts needed
	PUSHST			; Get a new TOS
	XOR	CL,CL
	MOV	Tag[esi],CL	; Tag number as valid non-zero
	MOV	CX,DI		; Sign of Integer to CH
	AND	CH,Sign
	JNS	short SETFLAG64 ; If positive integer set the flag

	call	TwosComplement64; Otherwise complement the number first

pub	SETFLAG64
	MOV	Flag[esi],CH
	OR	DI,DI
	JNZ	Jmp2IntegerToInternal
	OR	BP,BP
	JNZ	Jmp2IntegerToInternal

pub	SPEEDSHIFT64
	MOV	DI,BX
	MOV	BP,DX
	XOR	BX,BX
	XOR	DX,DX
	SUB	AX,32
Jmp2IntegerToInternal:
	JMP	IntegerToInternal

Jmp2LoadZero:
	JMP	LoadZero


page
;*********************************************************************;
;								      ;
;		Store Quad (64 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 64 bit integer

pub	eFSTlongint
	PUSH	esi
	call	TOSto64int		; convert TOS to 64-bit integer
					;  in DI:BP:BX:DX
	XCHG	AX,DI
	XCHG	AX,DX			;  now in DX:BP:BX:AX
	POP	edi			; Restore Memory address
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,BP
	STAX2US
	MOV	AX,DX			
	STAX2US
	RET


pub	TOSto64int
	MOV	esi,[CURstk]
					; Test for special conditions
	TEST	byte ptr Tag[esi],Special ; If number is not in range it is overflow
	JNZ	short IntegerOverflow64
	TEST	byte ptr Tag[esi],ZROorINF
	JNZ	short StoreIntegerZero64
					; Fetch Exponent & test fo blatent overflow
	MOV	CX,Expon[esi]
	CMP	CX,63
	JG	short IntegerOverflow64

if	fastSP
	;UNDONE - ????
else
	MOV	BP,MB4[esi]		; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger
					; Integer in DI:BP:BX:DX 
					;  (not yet 2's complement)
	MOV	AH,Flag[esi]		; See if we need to complement
	OR	AH,AH
	JNS	short Int64in2sComp
	call	TwosComplement64

pub	Int64in2sComp
	XOR	AX,DI			; If Signs agree we did not overflow
	JS	short IntOverOrZero64	; Special case is -0 which we let pass

pub	Store64
	POPSTsi			; store POP to long-integer
	ret

if	fastSP
	;UNDONE ???
endif

pub	StoreIntegerZero64
	XOR	DI,DI
pub	ZeroLower48
	XOR	BP,BP	
	MOV	BX,BP
	MOV	DX,BP
	JMP Store64 

pub	IntOverOrZero64
	OR	DI,BP
	OR	DI,BX
	OR	DI,DX	
	JNZ	IntegerOverflow64
	JMP	Store64	; Return zero

pub	IntegerOverflow64
	OR	CURerr,Invalid
	MOV	DI,8000H	; Integer Indefinite
	JMP	short ZeroLower48

pub	TwosComplement64
	NOT	DI			; 2's Complement of DI:BP:BX:DX
	NOT	BP
	NOT	BX
	NEG	DX
	CMC
	ADC	BX,0
	ADC	BP,0
	ADC	DI,0
	ret


ProfEnd  LSQUAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emftran.asm ===
page	,132
	subttl	emftran.asm - Transcendentals
;***
;emftran.asm - Transcendentals
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Transcendentals
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;-----------------------------------------;
;					  ;
;	     Transcendentals		  ;
;					  ;
;-----------------------------------------;

ProfBegin FTRAN


pub	MoveCodeSItoDataSI
	PUSH	edi
	MOV	edi,offset COEFFICIENT
ifdef	i386
    rept	Reg87Len/4
	MOVS	dword ptr es:[edi],dword ptr cs:[esi]
    endm
else
    rept	Reg87Len/2
	MOVS	word ptr es:[edi],word ptr cs:[esi]
    endm
endif
	MOV	esi,offset COEFFICIENT
	POP	edi
	RET

;---------------------------------------------------
;						   !
;	8087 emulator transcendental utilities	   !
;						   !
;---------------------------------------------------

;  COMPcsSIDI is  analogous  to the 8086 CMP instruction with operands
;  cs:[SI],[DI].  All registers except CX and DX are  left  unaltered.
;  Zero and  negative  zero  are  determined to be unequal.  NAN's and
;  infinities may not be compared with this routine.
;
;  FRAT2X performs   {TOS=[DI]}   <--	{TOS=[SI]}*PNUM({TOS=[SI]}^2),
;  and program created {temp=[SI]} <-- PDEN({TOS=[SI]}^2).  On	input,
;  [BX] must  contain  the  degree  of	PNUM, the coefficients of PNUM
;  in descending order, the degree-1  of  PDEN	and  the  coefficients
;  of PDEN in descending order.  PDEN is evaluated assuming an implied
;  highest coefficient of one.	[BX] is left unaltered, ARG2 is loaded
;  with   {TOS}^2,  DENORX is  used, all  registers are destroyed with
;  DI returning the value input in SI.

pub	BOTHZERO
	CMP	CH,CH			;set flags to equal
	JMP	short COMPDONE		;compare finished

pub	COMPcsSIDI
	MOV	CX,CS
	MOV	DS,CX
	MOV	CX,[esi+Flag]		;get sign byte of [SI]
	AND	CL,Sign 		;mask for sign
	MOV	DX,ES:[edi+Flag]	;get sign byte of [DI]
	AND	DL,Sign 		;mask for sign
	CMP	DL,CL			;compare signs
	JNE	short SIGNDIFF
	PUSH	ES
	PUSH	esi
	PUSH	edi			;save pointers
	OR	CL,CL			;if signs are +
	JNS	short BOTHPOS		;   don't exchange pointers
	PUSH	DS
	PUSH	ES
	POP	DS
	POP	ES
	XCHG	esi,edi 		;exchange pointers
	XCHG	CX,DX			;exchange flags

pub	BOTHPOS
	AND	CH,ZROorINF		;mask for zero
	AND	DH,ZROorINF		;mask for zero
	CMP	DH,CH			;if exactly one zero
	JNE	short COMPDONE		;   then finished
	OR	CH,CH			;if both zero
	JA	BOTHZERO		;   then done after flags set
	MOV	CX,[esi+Expon]		;get exponent of [SI]
	ADD	CX,IexpBias		;make it unbiased
	MOV	DX,ES:[edi+Expon]	;get exponent of [DI]
	ADD	DX,IexpBias		;make it unbiased
	CMP	CX,DX
	JNE	short COMPDONE		;compare exponents
	ADD	esi,MB6
	ADD	edi,MB6
	STD
	CMPS	word ptr [edi],word ptr [esi]
	JNE	short COMPDONE
	CMPS	word ptr [edi],word ptr [esi]
	JNE	short COMPDONE
	CMPS	word ptr [edi],word ptr [esi]
	JNE	short COMPDONE
	CMPS	word ptr [edi],word ptr [esi]	;compare mantissas

pub	COMPDONE
	CLD
	POP	edi
	POP	esi
	POP	ES

pub	SIGNDIFF
	MOV	CX,ES
	MOV	DS,CX
	RET

pub	FRAT2X
	MOV	edi,offset DENORX	;[DI]=temp
	CALL	MOVRQQ			;[DI]=x=temp
	PUSH	edi			;save ptr to x=temp
	PUSH	esi			;save ptr to TOS
	PUSH	ebx			;save ptr to polynomials
	MOV	edi,offset ARG2 	;get ptr to space for x^2
	CALL	MOVRQQ			;copy x to space for x^2
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;ARG2 gets x^2
	POP	esi			;get ptr to numerator poly
ifdef	i386
	xor	ecx,ecx
endif
	LODS	word ptr CS:[esi]
	XCHG	CX,AX			;CX=denominator degree-1
	POP	edi			;[DI]=TOS
	CALL	csMOVRQQ		;[DI]=first coeff=TOS
	MOV	[RESULT],edi		;result=[DI]

pub	POLYLOOPA
	PUSH	ecx			;save no. of terms left
	PUSH	esi			;save ptr to next coeff
	MOV	esi,offset ARG2 	;get ptr to x^2
	CALL	MUDRQQ			;multiply TOS by x^2
	POP	esi			;get pointer to coeff
	ADD	esi,Reg87Len		;point to next coeff
	PUSH	esi			;save pointer to coeff
	CALL	MoveCodeSItoDataSI
	CALL	ADDRQQ			;add coeff to TOS
	POP	esi			;get ptr to coeff
	POP	ecx			;get no. of terms remaining
	LOOP	POLYLOOPA		;loop until no terms left

	MOV	ebx,esi 		;move poly ptr
	POP	esi			;[SI]=x=temp
	PUSH	esi			;save ptr to x
	PUSH	ebx			;save poly ptr
	CALL	MUDRQQ			;multiply poly by x
	POP	esi			;get ptr to poly
	ADD	esi,12			;[SI]=denominator degree-1
ifdef	i386
	xor	ecx,ecx
endif
	LODS	word ptr CS:[esi]
	XCHG	CX,AX			;CX=denominator degree-1
	POP	ebx			;[BX]=temp
	PUSH	edi			;save denominator ptr
	MOV	edi,ebx 		;[DI]=temp
	CALL	csMOVRQQ		;move second coeff to temp
	PUSH	ecx			;save poly degree-1
	PUSH	esi			;save ptr to denominator poly
	MOV	esi,offset ARG2 	;get ptr to x^2
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;add x^2 to temp
	POP	esi			;get ptr to second coeff
	POP	ecx			;get poly degree-1

pub	POLYLOOPB
	PUSH	ecx			;save no. of terms left
	ADD	esi,Reg87Len		;point to next coeff
	PUSH	esi			;save ptr to next coeff
	MOV	esi,offset ARG2 	;get ptr to x^2
	CALL	MUDRQQ			;multiply temp by x^2
	POP	esi			;get pointer to coeff
	PUSH	esi			;save pointer to coeff
	CALL	MoveCodeSItoDataSI
	CALL	ADDRQQ			;add coeff to temp
	POP	esi			;get ptr to coeff
	POP	ecx			;get no. of terms remaining
	LOOP	POLYLOOPB		;loop until no terms left

	MOV	esi,edi 		;[SI]=denominator=temp
	POP	edi			;[DI]=numerator=TOS
	RET
;-------------------------------------------------------------------------------

pub	eFPTAN
	MOV	esi,[CURstk]
	CALL	$FPTAN
	PUSH	esi
	PUSHST
	MOV	edi,[CURstk]
	POP	esi
	CALL	MOVRQQ
	RET

;---------------------------------------------------
;						   !
;	8087 emulator partial tangent		   !
;						   !
;---------------------------------------------------

;  When 0<=x={TOS=[SI]}<=pi/4  then  $FPTAN  performs  {TOS=[DI]}  <--
;  numerator tangent  ({TOS=[SI]}),  system  created  {temp=[SI]}  <--
;  denominator tangent	({TOS=[SI]).   Every  register	except	DI  is
;  destroyed.

pub	$FPTAN
	MOV	ebx,offset TANRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=TOS,
	RET				;   [SI]=denominator=temp
;-------------------------------------------------------------------------------

pub	eFPATAN
	MOV	edi,[CURstk]
	MOV	esi,edi
	MOV	AX,Flag[esi]
	SUB	edi,Reg87Len

pub	CALLFPATAN
	CALL	$FPATAN
	MOV	esi,[CURstk]
	POPST
	RET

;---------------------------------------------------
;						   !
;	8087 emulator arctangent		   !
;						   !
;---------------------------------------------------

;  When 0<y={[DI]=NOS}<=x={[SI]=TOS}<infinity  then  $FPATAN  performs
;  {NOS=[DI]} <--   arctangent({NOS=[DI]}/{TOS=[SI]}),	 TOS  is  left
;  unaltered.  All registers except DI are destroyed.

pub	$FPATAN
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;NOS=[DI] <-- [DI]/[SI]=x
	MOV	AL,0			;flag reset
	MOV	esi,offset TWOMRT3	;[SI]=2-3^.5
	CALL	COMPcsSIDI		;if 2-3^.5 >= x
	JNB	short ATNREDUCED	;   then bypass arg reduction
	MOV	esi,edi 		;[SI]=x=NOS
	MOV	edi,offset TEMP1	;[DI]=temp
	CALL	MOVRQQ			;[DI]=x=temp
	PUSH	esi			;save NOS
	MOV	esi,offset RT3		;[SI]=3^.5
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;[DI]=3^.5*x=temp
	MOV	esi,offset cFLD1	;[SI]=1
	CALL	MoveCodeSItoDataSI
	CALL	SUDRQQ			;[DI]=3^.5*x-1
	POP	esi			;get NOS
	PUSH	edi			;save ptr to 3^.5*x-1
	MOV	edi,esi 		;DI gets NOS
	MOV	esi,offset RT3		;[SI]=3^.5
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;[DI]=x+3^.5=NOS
	POP	esi			;[SI]=3^.5*x-1
	CALL	DRDRQQ			;[DI]=(3^.5*x-1)/(x+3^.5)=NOS
	MOV	AL,1			;flag set

pub	ATNREDUCED
	PUSH	eax			;save flag
	MOV	esi,edi 		;[SI]=reduced x=NOS
	MOV	ebx,offset ATNRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=NOS,
					;   [SI]=denominator=temp
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=arctan(reduced x)=NOS
	POP	eax			;get flag
	OR	AL,AL			;if flag=0
	JZ	short ATNCOMPLETE	;   bypass adjust
	MOV	esi,offset PIBY6	;[SI]=pi/6
	CALL	MoveCodeSItoDataSI
	CALL	ADDRQQ			;[DI]=arctan(x)=NOS

pub	ATNCOMPLETE
	RET
;-------------------------------------------------------------------------------

pub	eF2XM1
	MOV	esi,[CURstk]
	CALL	$F2XM1
	RET

;---------------------------------------------------
;						   !
;	8087 emulator exponential		   !
;						   !
;---------------------------------------------------

;  When  0<=x={TOS=[SI]}<=.5  then  $F2XM1  performs  {TOS=[SI]}   <--
;  2^{TOS=[SI]}-1.  All registers except SI are destroyed.

pub	$F2XM1
	MOV	ebx,offset EXPRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=TOS
	PUSH	edi			;save numerator=TOS
	XCHG	esi,edi 		;[SI]=numerator, [DI]=denominator
	MOV	[RESULT],edi		;result=[DI]
	CALL	SUDRQQ			;[DI]=denominator-numerator
	MOV	esi,edi 		;[SI]=denominator-numerator
	POP	edi			;[DI]=numerator=TOS
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=(2^x-1)/2
	INC	word ptr [edi+Expon]	;[DI]=2^x-1
	MOV	esi,edi 		;[SI]=2^x-1
	RET
;-------------------------------------------------------------------------------

pub	eFYL2X
	MOV	edi,[CURstk]
	MOV	esi,edi
	MOV	AX,Flag[esi]
	SUB	edi,Reg87Len

pub	CALLFYL2X
	CALL	$FYL2X
	MOV	esi,[CURstk]
	POPST
	RET


;---------------------------------------------------
;						   !
;	8087 emulator multiple of logarithm	   !
;						   !
;---------------------------------------------------

;  When -infinity<y={NOS=[DI]}<infinity   and  0<x={TOS=[SI]}<infinity
;  then $FYL2X performs  {NOS=[DI]}  <--  {NOS=[DI]}*log2({TOS=[SI]}).
;  TOS is  left  unaltered,  all  registers  except  DI are destroyed.

pub	$FYL2X
	PUSH	esi			;save ptr to x=TOS
	MOV	esi,edi 		;[SI]=y=NOS
	MOV	edi,offset TEMP2	;[DI]=temp2
	CALL	MOVRQQ			;[DI]=y=temp2
	MOV	edi,esi 		;[DI]=y=NOS
	POP	esi			;[SI]=x=TOS
	PUSH	edi			;save ptr to y=NOS
	MOV	edi,offset TEMP3	;[DI]=temp3
	CALL	MOVRQQ			;[DI]=x=temp3
	MOV	BX,[edi+Expon]		;BX=exponent of x
	MOV	word ptr [edi+Expon],0	;set exponent of x to 0
	MOV	esi,offset RT2		;[SI]=2^.5
	CALL	COMPcsSIDI		;if reduced x < 2^.5
	JA	short LOGREDUCED	;   then bypass normalization
	DEC	word ptr [edi+Expon]	;otherwise make x < 2^.5
	INC	BX			;adjust exponent

pub	LOGREDUCED
	PUSH	ebx			;save exponent of x
	MOV	esi,offset cFLD1	;[SI]=1
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	SUDRQQ			;[DI]=(reduced x)-1=temp3
	MOV	esi,edi 		;[SI]=(reduced x)-1=temp3
	POP	ebx			;get exponent of x
	POP	edi			;[DI]=y=NOS
	PUSH	ebx			;save exponent of x
	CALL	$FYL2XP1		;[DI]=y*log2(reduced x)=NOS
	POP	ebx			;get exponent of x
	XOR	AX,AX			;zero AX
	OR	BX,BX			;if exponent is zero
	JZ	short LOGRETURN 	;   then done
	MOV	DX,AX			;make sign +
	JNS	short EXPPOSITIVE	;if + then bypass adjust
	MOV	DL,Sign 		;make sign -
	NEG	BX			;negate exponent

pub	EXPPOSITIVE
	MOV	CX,16			;initialize bit count

pub	LOGLOOP
	DEC	CX			;decrement shift count
	SHL	BX,1			;and shift exponent of x left
	JNC	LOGLOOP 		;until carry detected
	PUSH	edi			;save ptr to y*log2(reduced x)=NOS
	RCR	BX,1			;normalize exponent of x
	MOV	edi,offset TEMP3	;[DI]=temp3
	STOS	word ptr es:[edi]
	STOS	word ptr es:[edi]
	STOS	word ptr es:[edi]
	MOV	AX,BX
	STOS	word ptr es:[edi]
	MOV	AX,CX
	STOS	word ptr es:[edi]
	MOV	AX,DX
	STOS	word ptr es:[edi]	;store exponent of x in temp3
	MOV	edi,offset TEMP2	;[DI]=y=temp2
	MOV	esi,offset TEMP3	;[SI]=exponent of x=temp3
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;[DI]=y*exponent of x=temp2
	MOV	esi,edi 		;[SI]=y*exponent of x=temp2
	POP	edi			;[DI]=y*log2(reduced x)=NOS
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;[DI]=y*log2(x)=NOS

pub	LOGRETURN
	RET
;-------------------------------------------------------------------------------

pub	eFYL2XP1
	MOV	edi,[CURstk]
	MOV	esi,edi
	MOV	AX,Flag[esi]
	SUB	edi,Reg87Len

pub	CALLFYL2XP1
	CALL	$FYL2XP1
	MOV	esi,[CURstk]
	POPST
	RET

;---------------------------------------------------
;						   !
;	8087 emulator add 1 multiple of logarithm  !
;						   !
;---------------------------------------------------

;  When 	      -infinity<y={[DI]=NOS}<infinity		   and
;  2^-.5-1<=x={[SI]=TOS}<2^.5-1 then  $FYL2XP1	 performs   {NOS=[DI]}
;  <-- {NOS=[DI]}*log2({TOS=[SI]}+1).	TOS  is  left  unaltered,  all
;  registers except DI are destroyed.

pub	$FYL2XP1
	PUSH	edi			;save ptr to y
	MOV	edi,offset TEMP1	;[DI]=temp
	CALL	MOVRQQ			;[DI]=x=temp
	PUSH	esi			;save ptr to x
	MOV	esi,offset TWO		;[SI]=2
	CALL	MoveCodeSItoDataSI
	MOV	[RESULT],edi		;result=[DI]
	CALL	ADDRQQ			;[DI]=x+2=temp
	POP	esi			;[SI]=x=TOS
	CALL	DRDRQQ			;[DI]=x/(x+2)=temp
	INC	word ptr [edi+Expon]	;[DI]=2x/(x+2)=temp
	MOV	esi,edi 		;[SI]=2x/(x+2)=temp
	MOV	ebx,offset LOGRAT	;[BX]=rational function
	CALL	FRAT2X			;[DI]=numerator=temp,
					;   [SI]=denominator=temp
	MOV	[RESULT],edi		;result=[DI]
	CALL	DIDRQQ			;[DI]=log2(x+1)=temp
	MOV	esi,edi 		;[SI]=log2(x+1)=temp
	POP	edi			;get ptr to y=NOS
	MOV	[RESULT],edi		;result=[DI]
	CALL	MUDRQQ			;[DI]=y*log2(x+1)=NOS
	RET

ProfEnd  FTRAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emfrndi.asm ===
page	,132
	subttl	emfrndi.asm - Round to INT
;***
;emfrndi.asm - Round to INT
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Round to INT
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		Round TOS to Integer				      ;
;								      ;
;*********************************************************************;

ProfBegin FRNDI


pub	eFRNDINT
	MOV	esi,[CURstk]	    ; Point to TOS
	MOV	CX,Expon[esi]	     ; Get exponent
	CMP	CX,63		    ; See if we have very large integer
	JGE	short DONERNDINT

if	fastSP
	MOV	BX,MB4[esi]	 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	TEST	byte ptr Flag[esi],Single
	JZ	RNDD
	XOR	BL,BL
	MOV	BP,BX
	XOR	BX,BX
	MOV	DX,BX
RND:
else
	MOV	BP,MB4[esi]	; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger

	XOR	AX,AX		    ; Test for zero
	OR	AX,DI
	OR	AX,BP
	OR	AX,BX
	OR	AX,DX
	JZ	short RoundIntToZero

	MOV	AX,63		    ; What expon should be if no shifting

	CALL	IntegerToInternal

pub	DONERNDINT
	RET

if	fastSP
RNDD:
	MOV	BP,BX
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
	JMP	RND
endif

pub	RoundIntToZero
	MOV	Expon[esi],IexpMin - IexpBias
	MOV	MB0[esi],AX
	MOV	MB2[esi],AX
	MOV	MB4[esi],AX
	MOV	MB6[esi],AX
	MOV	byte ptr Tag[esi],ZROorINF
	JMP	DONERNDINT
PAGE
pub	IntegerToInternal
	; On entry DI:BP:BX:DX is the integer (unsigned i.e. no longer in 2's
	; compliment) DS:SI points to TOS (the ultimate destination).
	; AX contains the Exponent (assuming that the number will require
	; no shifting. the routine will adjust it as it goes along)
	; On exit the mantissa and exponent will be put in TOS.
	; This routine is used to Load int16 and int32 also to round-to-int

	XOR	ecx,ecx

pub	SHIFTLEFT
	SHL	DX,1	    ; Left justify number
	RCL	BX,1
	RCL	BP,1
	RCL	DI,1
	JC	short DONESHIFT
	LOOP	SHIFTLEFT   ; CX will count number of shifts done

pub	DONESHIFT
	RCR	DI,1	    ; We went one too far so reset
	RCR	BP,1
	RCR	BX,1
	RCR	DX,1

	ADD	AX,CX		; Adjust exponent
	MOV	Expon[esi],AX	 ; Store exponent
	MOV	MB0[esi],DX	 ; Store mantissa
	MOV	MB2[esi],BX
	MOV	MB4[esi],BP
	MOV	MB6[esi],DI
	RET
PAGE
pub	InternalToInteger
	; On entry DI:BP:BX:DX is the mantissa, CX is the Exponent, and
	; DS:SI points to TOS where the number came from. On exit
	; DI:BP:BX:DX is an integer (unsigned i.e. needs to be jiggled to
	; 2's compliment based upon the sign in TOS) rounded according to
	; Round control.  This routine used to Store int16 and int32 also
	; by round-to-integer

ifdef	i386
	movsx	ecx,cx		; (ecx) = sign-extended cx
endif
	XOR	AX,AX		; Clear Stickybit (AL) and roundbit (AH)
	SUB	ecx,63		; Convert exponent to shift count
	NEG	ecx		; Shift will be done in 2 parts, 1st to get
	DEC	ecx		;  sticky then 1 more to get round
ifdef	i386
	JGE	short NOTRUNCATE; Shift count Neg means num was large int.
	JMP	TRUNCATE
NOTRUNCATE:
	JE	short GETROUND	; Zero shift means no sticky bit, only round
else
	JL	short TRUNCATE	; Shift count Neg means num was large int.
	JE	short GETROUND	; Zero shift means no sticky bit, only round
endif
	CMP	ecx,64		; If big shift count then number is all sticky
	JGE	short STICKYNOROUND

	cmp	ecx,48		; fast out for 16-bit ints
	jle	SHIFTRIGHT	;   no

	or	dx,bx
	or	dx,bp		; dx = low 48 bits
	jz	nostick48	; if 0 then no sticky bits
	or	al,1		; set sticky bit
nostick48:
	mov	dx,di		; move upper 16 to lower 16
	xor	di,di		; zero upper 48 bits
	mov	bp,di
	mov	bx,di
	sub	ecx,48		; just like looping 48 times

pub	SHIFTRIGHT
	SHR	DI,1		; Shift into sticky bit (lsb of AL)
	RCR	BP,1
	RCR	BX,1
	RCR	DX,1
	JNC	short LOOPEND
	RCL	AL,1

pub	LOOPEND
	LOOP	SHIFTRIGHT

pub	GETROUND
	SHR	DI,1		; Shift into round
	RCR	BP,1
	RCR	BX,1
	RCR	DX,1
	RCL	AH,1		; Shift round into lsb of AH

pub	GOTROUNDANDSTICKY
	OR	AX,AX		; Was number exact?
	JZ	short TRUNCATE
	OR	[CURerr],Precision
	TEST	[CWcntl],RCdown ; True if down or chop
	JNZ	short INTDNorCHP
	TEST	[CWcntl],RCup	; True if UP (or CHOP)
	JNZ	short INTUP

pub	INTNEAR
	OR	AL,DL		; In near mode inc if (sticky or lastbit) and Roundbit
	AND	AH,AL
	SHR	AH,1
	JNC	short TRUNCATE

pub	INCREMENT
	XOR	AX,AX
	ADD	DX,1
	ADC	BX,AX
	ADC	BP,AX
	ADC	DI,AX

INTCHOP:
pub	TRUNCATE
	RET

pub	STICKYNOROUND
	MOV	AL,1
	XOR	AH,AH
	XOR	DI,DI
	MOV	BP,DI
	MOV	BX,DI
	MOV	DX,DI
	JMP	GOTROUNDANDSTICKY

pub	INTDNorCHP
	TEST	[CWcntl],RCup	    ; True if UP or CHOP
	JNZ	INTCHOP

pub	INTDOWN
	TEST	byte ptr Flag[esi],Sign ; Truncate if round down and +
	JNZ	INCREMENT
	JMP	TRUNCATE

pub	INTUP
	TEST	byte ptr Flag[esi],Sign ; Truncate if round up and -
	JNZ	TRUNCATE
	JMP	INCREMENT

ProfEnd  FRNDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emlsdbl.asm ===
page	,132
	subttl	emlsdbl.asm - Load/Store Double Precision Numbers
;***
;emlsdbl.asm - Load/Store Double Precision Numbers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store Double Precision Numbers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		   Load Double Real				      ;
;								      ;
;*********************************************************************;
;
; Subroutine pushes double internal with double IEEE format at ES:SI

ProfBegin LSDBL


FLDSTOver:
	xchg	edi, esi	    ;  di = TOS, es:si = double in memory
	call	OverStk
	xchg	edi, esi	    ;  di = TOS, es:si = double in memory
	jmp	short FLDSTOk

	even

pub  eFLDdr
	mov	edi, [CURstk]	    ; Get current register
	cmp	edi, [LIMstk]	    ; Is current register the last register?
	jae	short FLDSTOver     ;	Then report overflow.

FLDSTOk:
	add	edi, Reg87Len	    ; Move to next free register.
	mov	[CURstk], edi	    ; Update current top of stack

	LDUS2AX
	mov	bp, ax
	LDUS2AX
	mov	dx, ax
	LDUS2AX
	mov	cx, ax
	LDUS2AX 		    ; get final 2 bytes of source

	mov	esi, edi	    ; ds:si = TOS

	mov	bx, ax		    ; Double in bx:cx:dx:bp

    ; assume we have a valid non-zero number so normalize and store

	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1

	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1

	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1

	OR	BL,80H		; Set leading bit of mantissa
	MOV	MB7[esi],BL
	MOV	MB5[esi],CX
	MOV	MB3[esi],DX
	MOV	MB1[esi],BP

	OR	CX,BP		; Will need to determine if number is 0 later
	OR	CX,DX		; so mash all the bits together
	MOV	DH,AH
	AND	DH,Sign 	; Mask everything but sign
	MOV	Flag[esi],DH	;  and store
	XOR	DH,DH		; Clear for Tag
	MOV	MB0[esi],DH	; Also clear out least significant byte
	AND	AH,7FH		; Remove sign from exponent
	SHR	AX,1		; Adjust
	SHR	AX,1
	SHR	AX,1
	SHR	AX,1
	CMP	AX,DexpMax	; See if number is NAN or Inf
	JE	short DNANorInf
	CMP	AX,DexpMin	; See if number is Zero or Denormal
	JE	short DZeroorDenorm
	SUB	AX,DexpBias	; Unbias exponent

pub	DStoreExpnTag
	MOV	Expon[esi],AX
	MOV	Tag[esi],DH
	RET

pub	DNANorInf
	MOV	AX,IexpMax - IexpBias	; Set exponent to internal max
	MOV	DH,Special		; Set Tag to show NAN or Inf
	CMP	BL,80H			; If anything other than leading bit
	JNE	short DStoreExpnTag	;  is set number is NAN (not Inf)
	OR	CX,CX
	JNE	DStoreExpnTag
	OR	DH,ZROorINF		; Set Tag to show Inf
	JMP	DStoreExpnTag

pub	DZeroorDenorm
	CMP	BL,80H			; If anything other than leading bit
	JNE	short DDenormal 	;  is set number is Denormal
	OR	CX,CX
	JNE	short DDenormal
	MOV	AX,IexpMin - IexpBias	; Set exponent to internal min
	MOV	DH,ZROorINF		; Set Tag to show 0
	JMP	DStoreExpnTag

pub	DDenormal
	OR	[CURerr],Denormal	; Set Denormal Exception
	SUB	AX,DexpBias		; unbias the Exponent
	MOV	BP,MB0[esi]		; must refetch mantissa and normalize
	MOV	DX,MB2[esi]
	MOV	CX,MB4[esi]
	MOV	BX,MB6[esi]
	INC	AX			; Shift once if exp = expmin

pub	DNormalize
	DEC	AX			; Drop exponent
	SHL	BP,1			; Shift mantissa
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	OR	BX,BX
	JNS	DNormalize

	MOV	MB0[esi],BP		; Store mantissa
	MOV	MB2[esi],DX
	MOV	MB4[esi],CX
	MOV	MB6[esi],BX
	XOR	DH,DH		    ; Clear Tag
	JMP	DStoreExpnTag

page
;*********************************************************************;
;								      ;
;		    Store Double Real				      ;
;								      ;
;*********************************************************************;
;

pub	DSpecial
	TEST	CL,Special	; NAN or INF?
	JNE	short DDNANorINF
	XOR	AX,AX		; Number is zero
	STAX2US
	STAX2US
	STAX2US
	STAX2US
	JMP	DCommonExit

pub	DDNANorINF
	TEST	CL,ZROorINF
	JNE	short DInf
	MOV	DX,MB1[esi]	; Number is a NAN
	MOV	BX,MB3[esi]	; Fetch Mantissa
	MOV	AX,MB5[esi]
	MOV	CL,MB7[esi]

	SHR	CL,1		; Shift into place
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	; Now store the Mantissa

	XCHG	DX,AX
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,DX
	STAX2US

	MOV	BH,Flag[esi]	; Pick up Sign
	AND	BH,Sign
	MOV	AX,DexpMax*16	; Load shifted max exponent
	OR	AH,BH		; Merge in sign
	OR	AL,CL		; Merge in top bits of Mantissa
	STAX2US
	JMP	DCommonExit

pub	DInf
	MOV	BL,Flag[esi]
	AND	BL,Sign
	JMP	DSignedInfinity

pub	JMPDOver
	JMP	DOver

pub	JMPDUnder
	JMP	DUnder

pub	JMPDSpecial
	JMP	DSpecial

	even

pub	eFSTdr

; internal TOS register at DS:SI to double IEEE in memory at ES:DI

	MOV	edi,esi 	; 10 save target memory offset
	MOV	esi,[CURstk]	; 14 source offset is current TOS

	MOV	CL,Tag[esi]	; See if number is NAN, Inf, or 0
	OR	CL,CL
	JNZ	short JMPDSpecial
	MOV	CL,Flag[esi]	; Pick up sign
if	fastSP
	TEST	CL,Single
	JZ	DD1
	MOV	word ptr MB0[esi],0
	MOV	word ptr MB2[esi],0
	MOV	byte ptr MB4[esi],0
DD1:
endif
	MOV	BP,Expon[esi]	; See if we blatently over or under flow
	CMP	BP,DexpMax - DexpBias
	JGE	JMPDOver
	CMP	BP,DexpMin - DexpBias
	JLE	JMPDUnder

	;Since we won't have room to decide about rounding after we load
	;the mantissa we will determine the rounding style first

	MOV	AL,MB0[esi]	; Low byte becomes sticky bit ...
	MOV	DX,MB1[esi]	;  when combined with lo 2 bits of next byte
	OR	AL,AL
	JZ	short NOSTK
	OR	DL,1

pub	NOSTK
	TEST	DL,7H		; See if anything will be chopped off in truncation
	JZ	short DTRUNC
	OR	[CURerr],Precision  ; number is not exact so set flag and round
	MOV	AL,[CWcntl]	    ; Pick up rounding control

	; Mantissa gets incremented for rounding only on these conditions:
	; (UP and +) or (DOWN and -) or
	; (NEAR and Roundbit and (Sticky or Oddlastbit))

	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	JC	short StDOWNorCHOP53
	SHR	AL,1
	JC	short StUP53

pub	StNEAR53
	TEST	DL,4H		; 3rd bit over is round bit
	JZ	short DTRUNC
	TEST	DL,0BH		; 4th bit is last bit, 1st and 2nd are Sticky
	JZ	short DTRUNC

pub	DINC			; Know we must increment mantissa so
	MOV	BX,MB3[esi]	; Fetch mantissa
	MOV	AX,MB5[esi]
	MOV	CL,MB7[esi]
	AND	CL,7FH		; Mask off leading bit
	ADD	DX,8H		; Add 1 to what will be last bit after the shift

	ADC	BX,0
	ADC	AX,0
	ADC	CL,0
	JNS	short DShift

	AND	CL,7FH		; Mask off leading bit
	INC	BP		; Increment exponent
	CMP	BP,DexpMax - DexpBias
	JL	short DShift	; And test for the rare chance we went over
	JMP	short DOverReset

	even

pub	StUP53
	SHL	CL,1		; Test sign
	JNC	short DINC	; UP and + means inc
	JMP	SHORT DTRUNC

pub	StDOWNorCHOP53
	SHR	AL,1
	JC	short StCHOP53

pub	StDOWN53
	SHL	CL,1		; Test sign
	JC	short DINC	; DOWN and - means inc

StCHOP53:
pub	DTRUNC
	MOV	BX,MB3[esi]	; Fetch mantissa
	MOV	AX,MB5[esi]
	MOV	CL,MB7[esi]
	AND	CL,7FH		; Mask off leading bit

pub	DShift
	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	SHR	CL,1
	RCR	AX,1
	RCR	BX,1
	RCR	DX,1

	; Now store the Mantissa

	XCHG	DX,AX
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,DX
	STAX2US

	MOV	AX,BP		    ; Merge in the exponent
	ADD	AX,DexpBias	    ; Bias exponent
	SHL	AX,1		    ; Shift into position
	SHL	AX,1
	SHL	AX,1
	SHL	AX,1
	OR	AL,CL		    ; Merge in top bits of Mantissa
	MOV	CL,Flag[esi]	    ; Pick up sign
	AND	CL,Sign
	OR	AH,CL		    ; Merge in the sign
	STAX2US

pub	DCommonExit
	RET			;  8 return

pub	DOverReset	    ; We come here if we stored 6 bytes of mantissa
			    ; befor detecting overflow so must reset pointer
	SUB	edi,6	    ; to double in memory

pub	DOver			; Here on overflow
	OR	[CURerr],Overflow + Precision
	MOV	BL,Flag[esi]
	AND	BL,Sign 	; Mask to sign
	MOV	CL,[CWcntl]	; Determine rounding style
	SHR	CL,1
	SHR	CL,1
	SHR	CL,1
	JC	short StMOVDNorCHP53
	SHR	CL,1
	JC	short StMOVUP53

StMOVNEAR53:
pub	DSignedInfinity
	MOV	esi,offset IEEEinfinityD
pub	DStore
	csMVSI2US
	csMVSI2US
	csMVSI2US
	LODS	word ptr cs:[esi]
	OR	AH,BL		;Overstore correct sign
	STAX2US
	JMP	DCommonExit

pub	StMOVDNorCHP53
	SHR	CL,1
	JC	short StMOVCHOP53

pub	StMOVDOWN53
	OR	BL,BL		; DOWN and + means biggest
	JNZ	short DSignedInfinity

StMOVCHOP53:
pub	DSignedBiggest
	MOV	esi,offset IEEEbiggestD
	JMP	DStore

pub	StMOVUP53
	OR	BL,BL		; UP and - means biggest
	JZ	DSignedInfinity
	JMP	DSignedBiggest

pub	DUnder
	OR	[CURerr],Underflow+Precision  ; Set flag
	ADD	BP,DexpBias		; Bias the exponent which was less than
	NEG	BP			; Min = 0 so convert to positive difference
ifdef	i386
	movzx	ecx,BP			; Convert to shift count
else
	MOV	CX,BP			; Convert to shift count
endif
	ADD	ecx,4			; 3 for Double format 1 to expose hidden bit

	MOV	DH,Flag[esi]		; Need and exp of 0 for denormal
	AND	DH,Sign

	MOV	DL,MB7[esi]
	MOV	BX,MB5[esi]
	MOV	BP,MB3[esi]
	MOV	AX,MB1[esi]

pub	DshiftLoop
	SHR	DL,1
	RCR	BX,1
	RCR	BP,1
	RCR	AX,1
	LOOP	DshiftLoop

	STAX2US
	MOV	AX,BP
	STAX2US
	MOV	AX,BX
	STAX2US
	MOV	AX,DX
	STAX2US
	JMP	DCommonExit

ProfEnd  LSDBL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emlsint.asm ===
page	,132
	subttl	emlsint.asm - Load/Store 16/32-bit integers
;***
;emlsint.asm - Load/Store 16/32-bit integers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store 16/32-bit integers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;		 Load Single (16 Bit) Integer			      ;
;								      ;
;*********************************************************************;

; ES:SI: memory address of 16 bit integer

ProfBegin LSINT


pub	eFLDsi
	LDUS2AX 		; Fetch the integer
	MOV	DI,AX		;  into DI:BP:BX:DX
	OR	DI,DI
	JZ	short LoadZero
	XOR	BP,BP
	MOV	BX,BP
	MOV	DX,BX

	MOV	AX,15		; Exponent would be 15 if no shifts needed
	PUSHST			; Get a new TOS
	XOR	CL,CL
	MOV	Tag[esi],CL	; Tag number as valid non-zero
	MOV	CX,DI		; Sign of Integer to CH
	AND	CH,Sign
if	fastSP
	OR	CH,Single
endif
	JNS	short SETFLAG16 ; If positive integer set the flag

	NEG	DI		; Otherwise compliment the number first

pub	SETFLAG16
	MOV	Flag[esi],CH
	JMP	IntegerToInternal

pub	LoadZero
	PUSHST			; Get a new TOS
	XOR	AX,AX
	MOV	MB0[esi],AX
	MOV	MB2[esi],AX
	MOV	MB4[esi],AX
	MOV	MB6[esi],AX
	MOV	Expon[esi],IexpMin - IexpBias
	MOV	Flag[esi],AH
	MOV	AH,ZROorINF
	MOV	Tag[esi],AH
	RET
PAGE
;*********************************************************************;
;								      ;
;		 Store Single (16 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 16 bit integer

pub	eFSTsi
	PUSH	esi		; Save memory address for store
	MOV	esi,[CURstk]
				; Test for special conditions
	TEST	byte ptr Tag[esi],Special ; If number is not in range it is overflow
	JNZ	short IntegerOverflow16
	TEST	byte ptr Tag[esi],ZROorINF
	JNZ	short StoreIntegerZero16
				; Fetch Exponent & test fo blatent overflow
	MOV	CX,Expon[esi]
	CMP	CX,15
	JG	short IntegerOverflow16

if	fastSP
	MOV	BX,MB4[esi]	 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	TEST	byte ptr Flag[esi],Single
	JZ	SSID
	XOR	BL,BL
	MOV	BP,BX
	XOR	BX,BX
	MOV	DX,BX
SSI:
else
	MOV	BP,MB4[esi]	 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger
				; Integer now in BX:DX (not yet 2's compliment)
	OR	BX,BX		; Test again for Overflow
	JNZ	short IntegerOverflow16
	MOV	AH,Flag[esi]	; See if we need to compliment
	OR	AH,AH
	JNS	short Int16in2sComp

	NEG	DX
	JZ	short Store16	; Special case 0

pub	Int16in2sComp
	XOR	AX,DX		; If Signs agree we did not overflow
	JS	short IntegerOverflow16

pub	Store16
	POP	edi		; Restore Memory address
	MOV	AX,DX
	STAX2US
	RET

if	fastSP
SSID:
	MOV	BP,BX
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
	JMP	SSI
endif

pub	StoreIntegerZero16
	XOR	DX,DX
	JMP	Store16

pub	IntegerOverflow16
	OR	[CURerr],Invalid
	MOV	DX,8000H	; Integer Indefinite
	JMP	Store16

page
;*********************************************************************;
;								      ;
;		 Load Double (32 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 32 bit integer

pub	eFLDdi
	LDUS2AX 		; Fetch the integer
	MOV	BP,AX		;  into DI:BP:BX:DX
	LDUS2AX
	MOV	DI,AX

	OR	AX,BP
	JZ	short JMPLoadZeroBecauseThisLanguageHasNoFarConditionalJump
	XOR	BX,BX
	MOV	DX,BX

	MOV	AX,31		; Exponent would be 31 if no shifts needed
	PUSHST			; Get a new TOS
	XOR	CL,CL
	MOV	Tag[esi],CL	; Tag number as valid non-zero
	MOV	CX,DI		; Sign of Integer to CH
	AND	CH,Sign
	JNS	short SETFLAG32 ; If positive integer set the flag

	XOR	DI,0FFFFH	; Otherwise compliment the number first
	XOR	BP,0FFFFH
	ADD	BP,1
	ADC	DI,0

pub	SETFLAG32
	MOV	Flag[esi],CH
	OR	DI,DI
	JZ	short SPEEDSHIFT32
	JMP	IntegerToInternal

JMPLoadZeroBecauseThisLanguageHasNoFarConditionalJump:
	JMP	LoadZero

pub	SPEEDSHIFT32
	MOV	DI,BP
	XOR	BP,BP
	SUB	AX,16
	JMP	IntegerToInternal

page
;*********************************************************************;
;								      ;
;		Store Double (32 Bit) Integer			      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 32 bit integer

pub	eFSTdi
	PUSH	esi
	call	TOSto32int		; convert TOS to 32-bit integer
	POP	edi			; Restore Memory address
	MOV	AX,DX
	STAX2US
	MOV	AX,BX
	STAX2US
	RET


pub	TOSto32int
	MOV	esi,[CURstk]
					; Test for special conditions
	TEST	byte ptr Tag[esi],Special ; If number is not in range it is overflow
	JNZ	short IntegerOverflow32
	TEST	byte ptr Tag[esi],ZROorINF
	JNZ	short StoreIntegerZero32
					; Fetch Exponent & test fo blatent overflow
	MOV	CX,Expon[esi]
	CMP	CX,31
	JG	short IntegerOverflow32

if	fastSP
	MOV	BX,MB4[esi]		 ; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	TEST	byte ptr Flag[esi],Single
	JZ	SDID
	XOR	BL,BL
	MOV	BP,BX
	XOR	BX,BX
	MOV	DX,BX
SDI:
else
	MOV	BP,MB4[esi]		; Fetch mantissa to DI:BP:BX:DX
	MOV	DI,MB6[esi]
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
endif
	CALL	InternalToInteger
					; Integer in BP:BX:DX (not yet 2's compliment)
	OR	BP,BP			; Test again for Overflow
	JNZ	short IntegerOverflow32
	MOV	AH,Flag[esi]		; See if we need to compliment
	OR	AH,AH
	JNS	short Int32in2sComp

	XOR	BX,0FFFFH		; 2's Compliment of BX:DX
	XOR	DX,0FFFFH
	ADD	DX,1
	ADC	BX,0

pub	Int32in2sComp
	XOR	AX,BX			; If Signs agree we did not overflow
	JS	short IntOverOrZero32	; Special case is -0 which we let pass

pub	Store32
	ret

if	fastSP
SDID:
	MOV	BP,BX
	MOV	DX,MB0[esi]
	MOV	BX,MB2[esi]
	JMP	SDI
endif

pub	StoreIntegerZero32
	XOR	DX,DX
	MOV	BX,DX
	ret

pub	IntOverOrZero32
	OR	BX,DX
	JZ	Store32

pub	IntegerOverflow32
	OR	CURerr,Invalid
	MOV	BX,8000H	; Integer Indefinite
	XOR	DX,DX
	ret

ProfEnd  LSINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emlssng.asm ===
page	,132
	subttl	emlssng.asm - Load/Store Single Precision Numbers
;***
;emlssng.asm - Load/Store Single Precision Numbers
;
;	Copyright (c) 1984-89, Microsoft Corporation
;
;Purpose:
;	Load/Store Single Precision Numbers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin LSSNG

;*********************************************************************;
;								      ;
;			 Load Single Real			      ;
;								      ;
;*********************************************************************;
;
; Subroutine converts single in regs to internal at ES:SI


pub	eFLDsr
	LDUS2AX 		;    get lower mantissa part
	MOV	DI,AX		;  2 keep lower mantissa in DX
	LDUS2AX 		;    get upper exponent/sign part
	MOV	DL,AL		;  2 copy most sig. mantissa byte
	ROL	AX,1		;  2 sign to AL, exponent to AH
	AND	AL,1		;  4 clear all flags except sign
	ROR	AL,1		;  2 get sign in right position
	XCHG	AL,AH

    ; AX, DI, DL: operand one

	PUSHST			; 64 allocate another register

pub	SingleToInternal

	OR	DL,80H		; Set leading bit of mantissa
	XOR	DH,DH		; Set Tag to valid non-zero
	CMP	AL,SexpMax	; Is Number NAN or Inf?
	JE	short SNANorInf
if	fastSP
	OR	AH,Single	; Set single Precision flag
endif
	CMP	AL,SexpMin	; Is Number Zero or Denormal
	JE	short SZeroOrDenorm
				; Otherwise number is valid non-zero
	MOV	Flag[esi],AH	 ; Store sign
	SUB	AL,SexpBias	; Unbias the exponent
	CBW

pub	SStoreExpnTag
	MOV	Expon[esi],AX	 ; Store Exponent
	MOV	Tag[esi],DH	 ; Store Tag
	MOV	MB7[esi],DL	 ; Store Mantissa
	MOV	MB5[esi],DI
ife	fastSP
	XOR	AX,AX		; Clear low order bytes of Mantissa
	MOV	MB4[esi],AL
	MOV	MB2[esi],AX
	MOV	MB0[esi],AX
endif
	RET

pub	SNANorInf
	MOV	Flag[esi],AH		; Store sign
	MOV	AX,IexpMax - IexpBias	; Set exponent to internal max
	MOV	DH,Special		; Set Tag to show NAN or Inf
	CMP	DL,80H			; If anything other than leading bit
	JNE	short SStoreExpnTag	;  is set number is NAN (not Inf)
	OR	DI,DI
	JNE	short SStoreExpnTag
	OR	DH,ZROorINF		; Set Tag to show Inf
	JMP	SStoreExpnTag

pub	SZeroorDenorm
	MOV	Flag[esi],AH		; Store sign
	CMP	DL,80H			; If anything other than leading bit
	JNE	short SDenormal 	;  is set number is Denormal
	OR	DI,DI
	JNE	short SDenormal
	MOV	AX,IexpMin - IexpBias	; Set exponent to internal min
	OR	DH,ZROorINF		; Set Tag to show 0
	JMP	SStoreExpnTag

pub	SDenormal
	OR	[CURerr],Denormal	; Set Denormal Exception
	SUB	AL,SexpBias		; unbias the Exponent
	CBW
	INC	AX

pub	SNormalize
	DEC	AX
	SHL	DI,1
	RCL	DL,1
	OR	DL,DL
	JNS	SNormalize

	JMP	SStoreExpnTag

page
;************************************************************;
;							     ;
;		 Store Single Real			     ;
;							     ;
;************************************************************;

pub	SSpecial		; number is NAN or INF or Zero
	TEST	CL,Special	; NAN or INF?
	JNE	short SSNANorINF
	XOR	AX,AX		; Number is Zero
	MOV	BX,AX
	JMP	STRUNC

pub	SSNANorINF
	TEST	CL,ZROorINF
	JNE	short SInf
	MOV	BX,MB5[esi]	 ; Number is a NAN
	MOV	AL,MB7[esi]
	MOV	AH,Flag[esi]	 ; Pick up Sign
	SHL	AX,1		; Destroy leading bit, Sign to CF
	MOV	AH,SexpMax
	RCR	AX,1
	JMP	STRUNC

 pub	SInf
	MOV	AH,Flag[esi]
	JMP	SSignedInfinity

pub	JMPSOver
	JMP	SOver

pub	JMPSUnder
	JMP	SUnder

; ES:SI: memory address of single
; stores and misc. operations;	first setup register values as follows:
; AX: TOS flags (for DOUB and SIGN flags)
; SI: TOS address (offset)

pub	eFSTsr
	mov	edi,esi 	; ES:DI = store address
	MOV	esi,[CURstk]	 ; 14 load TOS address
	MOV	AX,Flag[esi]	 ; 21 get TOS flags (sign, double)

; convert internal at DS:SI to single
; DS:SI = TOS, ES:DI = memory, CH = operation (POP), BP = old ES value

	MOV	CL,Tag[esi]	 ; See if number is NAN or Inf or Zero
	OR	CL,CL
	JNZ	short SSpecial
	MOV	CL,Flag[esi]	 ; Pick up sign & single precision flag

	MOV	AX,Expon[esi]
	CMP	AX,SexpMax - SexpBias
	JGE	short JMPSOver
	CMP	AX,SexpMin - SexpBias
	JLE	short JMPSUnder

	ADD	AL,SexpBias	; Bias the Exponent
	MOV	AH,MB7[esi]	 ; Pick up MSB of Mantissa
	XCHG	AH,AL
	SHL	AL,1		; Shift mantissa to destroy leading integer bit
	SHL	CL,1		; Get sign into CF
	RCR	AX,1		; Pack sign, exp, & MSB
if	fastSP
	TEST	CL,Single*2	; if number was single rounding is not needed
	JZ	SS1
	MOV	BX,MB5[esi]
	JMP	SHORT STRUNC
SS1:
endif
	MOV	DX,MB0[esi]	 ; DL Will be the sticky bit
	OR	DX,MB2[esi]	 ; DH will be round and the rest of sticky
	OR	DL,DH
	XOR	DH,DH
	MOV	BX,MB5[esi]
	OR	DX,MB3[esi]
	JZ	short STRUNC	; If no Round or Sticky result is exact
	OR	[CURerr],Precision

pub	SRound			; single in AX:BX:DX
	MOV	CL,[CWcntl]	; Need to know Rounding Control
	SHR	CL,1
	SHR	CL,1
	SHR	CL,1
	JC	short StDOWNorCHOP24
	SHR	CL,1
	JC	short StUP24

pub	StNEAR24
	CMP	DX,8000H	; How are round and sticky bits?
	JB	short STRUNC	; No round, so truncate
	JA	short SINC	; Round and sticky so round up
	TEST	BL,1		; Round and no sticky, is last bit even?
	JZ	short STRUNC	; Yes, so truncate.

pub	SINC
	MOV	DL,AL		; Increment mantissa
	ADD	BX,1
	ADC	AX,0
	XOR	DL,AL		; See if we overflowed a bit into the exponent
	JNS	short STRUNC	; If not number is now correct so go store
	MOV	DX,AX		; Exponent was incremented, see if it overflowed
	SHL	DX,1
	CMP	DH,SexpMax
	JE	short SOver

pub	StCHOP24
STRUNC:
	XCHG	AX,BX
	STAX2US
	MOV	AX,BX
	STAX2US

pub	SStoreExit
	RET

pub	StDOWNorCHOP24
	SHR	CL,1
	JC	short StCHOP24

pub	StDOWN24
	OR	AH,AH			; Test the sign
	JS	short SINC
	JMP	short STRUNC

pub	StUP24
	OR	AH,AH			; Test the sign
	JS	short STRUNC
	JMP	short SINC

pub	SOver				; Number overflowed Single Precision range.
					; Result returned depends upon rounding control
	OR	[CURerr],Overflow + Precision
	MOV	CL,[CWcntl]
	SHR	CL,1
	SHR	CL,1
	SHR	CL,1
	JC	short StMOvDNorCHP24

	SHR	CL,1
	JC	short StMOvUP24

StMOvNEAR24:				; Masked Overflow Near Rounding

pub	SSignedInfinity 		; Return signed infinity
	MOV	BX,[IEEEinfinityS + 2]
	AND	AH,Sign 		; Overstore the proper sign
	OR	BH,AH
	MOV	AX,[IEEEinfinityS]
	STAX2US
	MOV	AX,BX
	STAX2US
	JMP	SStoreExit

pub	StMOvDNorCHP24
	SHR	CL,1
	JC	short StMOvCHOP24

pub	StMOvDOWN24			; Masked Overflow Down Rounding
	TEST	AH,Sign 		; Positive goes to biggest
	JNZ	short SSignedInfinity

StMOvCHOP24:				; Masked Overflow Chop Rounding
pub	SSignedBiggest
	MOV	BX,[IEEEbiggestS + 2]
	AND	AH,Sign 		; Overstore the proper sign
	OR	AH,BH
	MOV	AL,BL
	STAX2US
	MOV	AX,[IEEEbiggestS]
	STAX2US
	JMP	SStoreExit

pub	StMOvUP24			; Masked Overflow Up Rounding
	TEST	AH,Sign 		; Negative goes to biggest
	JZ	short SSignedInfinity
	JMP	SSignedBiggest

pub	SUnder				; Masked Underflow - Try to denormalize
	OR	[CURerr],Underflow+Precision
	NEG	AX			; Convert exponent (which is too small)
	ADD	AX,SexpMin-SexpBias+1	; To a positive shift count
	CMP	AX,24			; Is shift more than mantissa precision
	JGE	short Szero
	XCHG	CX,AX
ifdef	i386
	movzx	ecx,cx			; (ecx) = zero-extended loop count
endif
	MOV	DX,MB0[esi]		; Pick up Insignif bytes for sticky bit
	OR	DX,MB2[esi]
	MOV	AL,DL
	OR	AL,DH
	MOV	DX,MB4[esi]
	MOV	BX,MB6[esi]
	OR	AL,AL
	JZ	short SSHIFTR
	OR	DL,1			; Set the sticky bit

pub	SSHIFTR
	SHR	BX,1
	RCR	DX,1
	JNC	short SSLOOP
	OR	DL,1
pub	SSLOOP
	LOOP	SSHIFTR

	XCHG	AH,CH			; Restore operation to CH
	MOV	AH,Flag[esi]		; Pick up sign
	AND	AH,Sign 		; Mask to sign only
	MOV	AL,BH			; Biased exponent for a denormal is 0
	MOV	BH,BL
	MOV	BL,DH
	MOV	DH,DL
	XOR	DL,DL
	JMP	SRound

pub	Szero
	XOR	AX,AX
	MOV	BX,AX
	JMP	STRUNC			; Go store single and exit

ProfEnd  LSSNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emlstmp.asm ===
page	,132
	subttl	emlstmp.asm - Load/Store Temp Real Numbers
;***
;emlstmp.asm - Load/Store Temp Real Numbers
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Load/Store Temp Real Numbers
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin LSTMP

;*********************************************************************;
;								      ;
;		 Load 80 Bit Temp Real				      ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 80 bit tempreal

pub	eFLDtemp
	MOV	edi,esi 	; Get a new stack element and leave
	PUSHST
	XCHG	edi,esi

	mov	ax,es
	mov	dx,ds
	mov	es,dx
	mov	ds,ax
	MVUS2DI 		; Move 8 bytes of mantissa to TOS
	MVUS2DI
	MVUS2DI
	MVUS2DI
	mov	ax,es
	mov	dx,ds
	mov	es,dx
	mov	ds,ax
	LDUS2AX 		; Fetch exponent
	SUB	edi,8		; Reset pointer to TOS
	XCHG	esi,edi 	; Now DS:SI points to TOS

	MOV	DH,AH		; Exponent and Sign to DX
	AND	DH,Sign 	; Mask to Sign only
	MOV	Flag[esi],DH
	AND	AH,7FH		; Mask out sign
	XOR	DH,DH		; Set Tag to valid non-zero
	CMP	AX,IexpMax
	JE	short TNANorInf
	CMP	AX,IexpMin
	JE	short TZeroOrDenorm
	SUB	AX,IexpBias

pub	TStoreExpnTag
	MOV	Expon[esi],AX
	MOV	Tag[esi],DH
	RET

pub	TNANorInf
	MOV	AX,IexpMax - IexpBias
	MOV	DH,Special
	CMP	MB6[esi],8000H	     ; Test for Infinity
	JNE	short TStoreExpnTag
	MOV	BP,MB4[esi]
	OR	BP,MB2[esi]
	OR	BP,MB0[esi]
	JNZ	TStoreExpnTag
	OR	DH,ZROorINF
	JMP	TStoreExpnTag

pub	TZeroOrDenorm
	MOV	BP,MB6[esi]
	OR	BP,MB4[esi]
	OR	BP,MB2[esi]
	OR	BP,MB0[esi]
	JNZ	short TDenormal

pub	TZero
	MOV	AX,IexpMin - IexpBias
	MOV	DH,ZROorINF
	JMP	TStoreExpnTag

pub	TDenormal
	OR	[CURerr],Underflow+Precision ; Say it underflowed - set it to 0
	XOR	BP,BP
	MOV	MB0[esi],BP
	MOV	MB2[esi],BP
	MOV	MB4[esi],BP
	MOV	MB6[esi],BP
	JMP	TZero

PAGE
;*********************************************************************;
;								      ;
;   Store 80 Bit Temp Real (& POP since only FSTP supported for temp) ;
;								      ;
;*********************************************************************;
;
; ES:SI: memory address of 80 bit tempreal

pub	TNANorINFST
	TEST	BH,ZROorINF
	JNZ	short TInfST

pub	TNANST
	MVSI2US 		; copy mantissa
	MVSI2US
	MVSI2US
	MVSI2US
	MOV	AX,IexpMax	; Set maximum mantissa
	OR	AH,DH		; Overstore proper sign
	STAX2US
	POPST
	RET

pub	TInfST
	XOR	AX,AX
	STAX2US
	STAX2US
	STAX2US
	MOV	AX,8000H
	STAX2US
	MOV	AX,IexpMax	; Set maximum mantissa
	OR	AH,DH		; Overstore proper sign
	STAX2US
	POPST
	RET

pub	TSpecialST
	TEST	BH,Special
	JNZ	TNANorINFST

pub	TzeroST
	XOR	AX,AX
	STAX2US
	STAX2US
	STAX2US
	STAX2US
	STAX2US
	POPST
	RET

pub	eFSTtemp
	MOV	edi,esi
	MOV	esi,[CURstk]

	MOV	AX,Expon[esi]	; Adjust exponent of TOS
	ADD	AX,IexpBias
	MOV	DH,Flag[esi]
if	fastSP
	TEST	DH,Single
	JZ	TD1
	MOV	word ptr MB0[esi],0
	MOV	word ptr MB2[esi],0
	MOV	byte ptr MB4[esi],0
TD1:
endif
	AND	DH,Sign 	; Mask to sign only
	OR	AH,DH
	MOV	BH,Tag[esi]	 ; See if it is a special case
	OR	BH,BH
	JNZ	TSpecialST

	MVSI2US 		; Move Mantissa
	MVSI2US
	MVSI2US
	MVSI2US
	STAX2US 		; Move Exponent & Sign

	SUB	esi,8		; Reset pointer to TOS
	POPSTsi

	RET

ProfEnd  LSTMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emoemqb.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;
	page	,132
title	emoem.asm - OEM dependent code for 8087

;--------------------------------------------------------------------
;
;	OEM customization routines for 8087/80287 coprocessor
;
;	This module is designed to work with the following
;	Microsoft language releases:
;
;		Microsoft Quick BASIC 4.0 and later
;		Microsoft Quick BASIC (KANJI) 4.0 and later
;		Microsoft BASCOM 3.0
;		Microsoft BASCOMK 3.0
;		Microsoft BASCOM/2
;		Microsoft BASCOMK/2
;
;	This module supersedes the OEMR7.ASM module used in earlier
;	versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;	provided with the FORTRAN and Pascal releases refers to the old
;	OEMR7.ASM module and is only slightly relevant to this module.
;
;	The following routines need to be written to properly handle the
;	8087/808287 installation, termination, and interrupt handler
;
;	__FPINSTALL87		install 8087 interrupt handler
;	__FPTERMINATE87 	deinstall 8087 interrupt handler
;	__fpintreset		reset OEM hardware if an 8087 interrupt
;
;	*****  NEW INSTRUCTIONS  *****
;
;	If you want a PC clone version, do nothing.  The libraries are
;	setup for working on IBM PC's and clones.
;
;	This instructions only need to be followed if a non-IBM PC
;	clone version is desired.
;
;	This module should be assembled with the
;	Microsoft Macro Assembler Version 4.00 or later as follows:
;
;		masm -DOEM -r emoem.asm;
;
;	For QuickBASIC, assemble as follows:
;
;		masm -D_QB -DOEM -r emoem.asm;
;
;	Most hardware handles the 8087/80287 in one of the following
;	three ways -
;
;	1.	NMI - IBM PC and clones all handle the interrupt this way
;	2.	single 8259
;	3.	master/slave 8259
;
;	Manufacturer specific initialization is supported for these 3
;	machine configurations either by modifying this file and replacing
;	the existing EMOEM module in the math libraries or by patching
;	the .LIB and .EXE files directly.
;
;		LIB 87-+EMOEM;
;		LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef	OEM
if1
	%out	OEM version for non-clone support
endif
endif

ifndef	_QB
	_HOOK_CTRLC=1
endif

ifdef	_HOOK_CTRLC
if1
	%out	Non-QB version.  Hooks Ctrl-C.  Hooks INT 75h.
endif
else
if1
	%out	QB version.  Doesn't hook Ctrl-C.  Hooks INT 75h.
endif
endif

;---------------------------------------------------------------------
;	Assembly constants.
;---------------------------------------------------------------------

; MS-DOS OS calls

   OPSYS	EQU	21H
   SETVECOP	EQU	25H
   GETVECOP	EQU	35H
   DOSVERSION	EQU	30h
ifdef	_HOOK_CTRLC
   CTLCVEC	EQU	23h
endif	;_HOOK_CTRLC

EMULATOR_DATA	segment public 'FAR_DATA'
assume	ds:EMULATOR_DATA

;	User may place data here if DS is setup properly.
;	Recommend keeping the data items in the code segment.

EMULATOR_DATA	ends



EMULATOR_TEXT	segment public 'CODE'
assume	cs:EMULATOR_TEXT

	public	__FPINSTALL87		; DO NOT CHANGE THE CASE ON
	public	__FPTERMINATE87 	; THESE PUBLIC DEFINITIONS

	extrn	__FPEXCEPTION87:near	; DO NOT CHANGE CASE


ifdef	OEM

;***********************************************************************
;
; Hardware dependent parameters in the 8087 exception handler.
;
; For machines using 2 8259's to handle the 8087 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 8087
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 8087 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum	db	0		; MS-DOS OEM number (IBM is 00h)
intnum	db	2		; IBM PC clone interrupt number
share	db	0		; nonzero if original vector should be taken
a8259	dw	0		; 1st 8259 (A0=0) port #
aocw2	db	0		; 1st 8259 (A0=0) EOI command
b8259	dw	0		; 2nd 8259 (A0=0) port #
bocw2	db	0		; 2nd 8259 (A0=0) EOI command
a8259m	dw	0		; 1st 8259 (A0=1) port #
aocw1m	db	0		; 1st 8259 (A0=1) value to mask against IMR
b8259m	dw	0		; 2nd 8259 (A0=1) port #
bocw1m	db	0		; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;	OEM specific 8087 information
;
;	If the OEM number returned from the DOS version call matches,
;	this information is automatically moved into the oem struc below.

oemtab	label	byte	; Table of OEM specific values for 8087

;		OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db	0	; end of table

;	Unique pattern that can be searched for with the debugger so that
;	.LIB or .EXE files can be patched with the correct values.
;	If new values are patched into .LIB or .EXE files, care must be
;	taken in insure the values are correct.  In particular, words and
;	bytes are intermixed in oeminfo structure.  Remember words are
;	stored low byte - high byte in memory on the 8086 family.

	db	'<<8087>>'	; older versions used '<8087>'

;	Some manufacturer's machines can not be differentiated by the
;	OEM number returned by the MS-DOS version check system call.
;	For these machines it is necessary to replace the line below

oem1	oeminfo <>		; default values for IBM PC & clones

;	with one of the following.  If your machine has an 8087 capability
;	and it is not in the list below, you should contact your hardware
;	manufacturer for the necessary information.

;ACT Apricot
;oem1	 oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1	 oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

aoldIMR 	db	0	; 1st 8259 original IMR value
boldIMR 	db	0	; 2nd 8259 original IMR value

endif	;OEM

statwd		dw	0	; Temporary for status word
oldvec		dd	0	; Old value in 8087 exception interrupt vector
ifdef	_HOOK_CTRLC
ctlc		dd	0	; Old value of Control-C vector (INT 23h)
endif	;_HOOK_CTRLC
ifndef	OEM
oldvec75	dd	0	; Old value INT 75H interrupt vector
INT75FLAGS	DW	0	; flags at INT 75 time
INT75CS 	DW	0	; CS at INT 75 time
INT75IP 	DW	0	; IP at INT 75 time
INT75VEC	DW	OFFSET FPREALINT2	; place INT 75 IRETs to
endif	;OEM
page

;---------------------------------------------------------------------
;
;	Perform OEM specific initialization of the 8087.
;

__FPINSTALL87:
	push	ds			; DS = EMULATOR_DATA

	push	cs			; Move current CS to DS for opsys calls.
	pop	ds
assume	ds:EMULATOR_TEXT

ifdef	OEM
	push	ds
	pop	es			; CS = DS = ES
	mov	ah,DOSVERSION
	int	OPSYS			; bh = OEM#
	cld
	mov	si,offset oemtab	; start of OEM 8087 info table
	mov	di,offset oem1+1
	mov	cx,(size oem1)-1
OEMloop:
	lodsb				; get OEM#
	or	al,al
	jz	OEMdone 		; OEM# = 0 - did not find OEM
	cmp	al,bh			; correct OEM#
	je	OEMfound
	add	si,cx			; skip over OEM information
	jmp	OEMloop

OEMfound:
	rep	movsb			; move the information

OEMdone:				; done with automatic customization
endif	;OEM


; Save old interrupt vector.
; Ask operating system for vector.

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es
else
	mov	ax,GETVECOP shl 8 + 75H ; get interrupt vector 75H
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec75],bx	; Squirrel away old vector.
	mov	word ptr [oldvec75+2],es;

	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es
endif	;OEM

; Have operating system install interrupt vectors.

ifdef	OEM
	mov	dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
	int	OPSYS			; Install vector.
else
	mov	dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
	int	OPSYS			; Install vector.

	mov	dx,offset __fpinterrupt75 ; Load DX with 8087 interrupt handler.
	mov	ax,SETVECOP shl 8 + 75H ; set interrupt vector 75
	int	OPSYS			; Install vector.
endif	;OEM

; Intercept Control-C vector to guarentee cleanup

ifdef	_HOOK_CTRLC			;
	mov	ax,GETVECOP shl 8 + CTLCVEC
	int	OPSYS
	mov	word ptr [ctlc],bx
	mov	word ptr [ctlc+2],es
	mov	dx,offset ctlcexit
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
endif	;_HOOK_CTRLC

ifdef	OEM

;	set up 8259's so that 8087 interrupts are enabled

	mov	ah,[oem1].aocw1m 	; get mask for 1st 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;   and only 1 8259
	mov	dx,[oem1].a8259m 	; get port number for 1st 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[aoldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

	mov	ah,[oem1].bocw1m 	; get mask for 2nd 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;
	mov	dx,[oem1].b8259m 	; get port number for 2nd 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[boldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

installdone:

endif	;OEM

assume	ds:EMULATOR_DATA
	pop	ds
	ret


page
;	__FPTERMINATE87
;
;	This routine should do the OEM 8087 cleanup.  This routine is called
;	before the program exits.
;
;	DS = EMULATOR_DATA

__FPTERMINATE87:
	push	ds
	push	ax
	push	dx

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
	lds	dx,[oldvec]
	int	OPSYS
else
	mov	ax,SETVECOP shl 8 + 2
	lds	dx,[oldvec]
	int	OPSYS

	mov	ax,SETVECOP shl 8 + 75H ; restore int 75
	lds	dx,[oldvec75]		;
	int	OPSYS			;
endif	;OEM

ifdef	OEM

;	reset 8259 IMR's to original state

	push	cs
	pop	ds			; DS = CS
assume	ds:EMULATOR_TEXT
	cmp	[oem1].aocw1m,0		; did we have to change 1st 8259 IMR
	je	term2nd8259		;   no - check 2nd 8259
	mov	al,[aoldIMR]		; get old IMR
	mov	dx,[oem1].a8259m 	; get 1st 8259 (A0=1) port #
	out	dx,al			; restore IMR

term2nd8259:
	cmp	[oem1].bocw1m,0		; did we have to change 2nd 8259 IMR
	je	terminatedone		;   no
	mov	al,[boldIMR]		; get old IMR
	mov	dx,[oem1].b8259m 	; get 2nd 8259 (A0=1) port #
	out	dx,al			; restore IMR

terminatedone:

endif	;OEM

	pop	dx
	pop	ax
	pop	ds
assume	ds:EMULATOR_DATA
	ret

ifdef	_HOOK_CTRLC
;	Forced cleanup of 8087 exception handling on Control-C

ctlcexit:
	push	ax
	push	dx
	push	ds
	call	__FPTERMINATE87 	; forced cleanup of exception handler
	lds	dx,[ctlc]		; load old control C vector
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
	pop	ds
	pop	dx
	pop	ax
	jmp	[ctlc]			; go through old vector
endif	;_HOOK_CTRLC

page
;
; __fpinterrupt75
;
; This is the "real" 80x87 interrupt routine for AT's and clones.
; Entire routine added [2].
;
; We hook INT 75 in order to work around a DOS nuance that otherwise causes the
; exception handler to get executed with the wrong stack segment.
;
; In PC's, a math exception is a simple INT 2, which since we hook, we recieve
; unobstructed. On AT's, an INT 75H is generated, which is normally trapped by
; the BIOS, which performs some hardware magic, and then executes an INT 2
; instruction to simulate the PC's behaviour. Hooking INT 2 alone is sufficient
; to handle these two cases.
;
; In MS-DOS (and PC-DOS) versions 3.2x, a stack swapping scheme is employed in
; which the DOS actually allocates a new SS:SP before executing the interrupt
; handler. If we do not hook INT 75H, then it gets a new SS:SP, and executes
; the INT 2 with that stack, and we cannot look back on the stack for our
; context, nor can we really know anything about the stack at the time of the
; exception.
;
; The process used to over come this problem is, essentially, to allow the
; INT 75H to execute, including it's embedded INT 2, but to do nothing in that
; INT 2. We fake the INT 75H return, though, such that it returns to us, (with
; the right stack to boot), and we can continue to process the exception.
;
; The steps invoved:
;
; 1) Hook BOTH INT 2 and INT 75H
;
; 2) On an INT 75, save the CS, IP and FLAGS of the return address, and REPLACE
;    THEM with values that will cause the INT 75H's IRET to return step 5,
;    below.
;
; 3) Just jump to the previous INT 75H handler.
;
; 4) On the subsequent INT 2, IF there is a CS as saved in step 1, then do
;    nothing. Just IRET. If there is not saved CS, then we have a plain old
;    INT 2 (running on an XT, most likely), and we just go to step 6.
;
; 5) On return from the INT 75H, we have the SS:SP at the time of the
;    exception. Just push the previously saved FLAGS, CS and IP of the
;    exception, clear the saved CS, and fall into....
;
; 6) A normal INT 2 handler.
;
ifndef	OEM			;
__fpinterrupt75:
ASSUME	DS:NOTHING

	POP	CS:[INT75IP]	;Squirel away exception address
	POP	CS:[INT75CS]
	POP	CS:[INT75FLAGS]
	PUSHF			;Set up INT 75 to return to our code
	PUSH	CS
	PUSH	CS:[INT75VEC]
	JMP	[oldvec75]	;And execute original INT 75H
endif				; ifndef OEM
;
;	__fpinterrupt87
;
;	This is the 8087 exception interrupt routine.
;
;	All OEM specific interrupt and harware handling should be done in
;	__fpintreset because __FPEXCEPTION87 (the OEM independent 8087
;	exception handler) may not return.  __FPEXCEPTION87 also turns
;	interrupts back on.
;

PENDINGBIT=	80h		; Bit in status word for interrupt pending

__fpinterrupt87:
assume	ds:nothing

	nop
	fnstsw	[statwd]	; Store out exceptions
ifndef	OEM			;
	TEST	CS:[INT75CS],-1 ; has INT 75 ocurred?
	JZ	FPWASINT2	; jump if not
	IRET			; just return to original INT 75 handler

FPREALINT2:			; INT 75 IRETs here
	PUSH	CS:[INT75FLAGS] ; fake up original exception
	PUSH	CS:[INT75CS]	;
	PUSH	CS:[INT75IP]	;
	MOV	CS:[INT75CS],0	; and clear the INT75 occurred flag.

FPWASINT2:			;
endif				; ifndef OEM

	push	cx		; waste time
	mov	cx,3
self:
	loop	self
	pop	cx
	test	byte ptr [statwd],PENDINGBIT	; Test for 8087 interrupt
	jz	not87int	; Not an 8087 interrupt.

ifdef	OEM
	call	__fpintreset	; OEM interrupt reset routine
endif	;OEM

	call	__FPEXCEPTION87 ; 8087 error handling - may not return
				; this routine turns interrupts back on

ifdef	OEM
	cmp	[oem1].share,0	; Should we execute the old interrupt routine?
	jz	done8087	;    if not then return

;	If you fall through here to do further hardware resetting, things
;	may not always work because __FPEXCEPTION87 does not always return
;	This only happens when the 8087 handler gets an exception that is
;	a fatal error in the language runtimes.  I.e., divide by zero
;	is a fatal error in all the languages, unless the control word has
;	set to mask out divide by zero errors.

else				;
	iret			;
endif	;OEM

not87int:
	jmp	[oldvec]	; We should never return from here.


ifdef	OEM

done8087:
	iret


__fpintreset:
	push	ax
	push	dx
	mov	al,[oem1].aocw2	; Load up EOI instruction.
	or	al,al		; Is there at least one 8259 to be reset?
	jz	Reset8259ret	; no
	mov	dx,[oem1].a8259
	out	dx,al		; Reset (master) 8259 interrupt controller.
	mov	al,[oem1].bocw2	; Load up EOI instruction.
	or	al,al		; Is there a slave 8259 to be reset?
	jz	Reset8259ret
	mov	dx,[oem1].b8259
	out	dx,al		; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop	dx
	pop	ax
	ret

endif	;OEM


EMULATOR_TEXT	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emmain.asm ===
page	,132
	subttl	emmain.asm - Main Entry Point and Address Calculation Procedure
;***
;emmain.asm - Main Entry Point and Address Calculation Procedure
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Main Entry Point and Address Calculation Procedure
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


;*********************************************************************;
;								      ;
;	  Main Entry Point and Address Calculation Procedure	      ;
;								      ;
;*********************************************************************;
;
; This routine fetches the 8087 instruction, calculates memory address
; if necessary into ES:SI and calls a routine to emulate the instruction.
; Most of the dispatching is done through tables. (see comments in CONST)


ProfBegin MAIN

ifdef	XENIX

ifdef   i386
LDT_DATA=       02Fh            ; UNDONE - 386 emulator data LDT
else
LDT_DATA=       037h            ; UNDONE - 286 emulator data LDT
endif   ;i386

endif	;XENIX


ifdef   PROTECT
;	protect mode Segment override case

glb	<protSegOvrTab>

protSegOvrTab	label	word

	dw	DSSegOvr	; 11
	dw	ESSegOvr	; 00
	dw	CSSegOvr	; 01
	dw	SSSegOvr	; 10
endif   ;PROTECT


ifdef	DOS3
;	isolated FWAIT


ifdef  WINDOWS
pub  FWtrap
	cld		    ; this CLD is a nop.
	iret

else	;not WINDOWS
pub  FWtrap
	PUSH	BP			; fix up isolated FWAIT
	PUSH	DS
	PUSH	SI
	MOV	BP,SP			; Point to stack
	LDS	SI,DWORD PTR 6[BP]	; Fetch ret address,(points to after instruction)
	DEC	SI			; Make DI point to instruction
	DEC	SI
	MOV	6[BP],SI		; Change ret address to return to instruction
	mov	word ptr [si],0C0h*256+89h  ; change interrupt to mov ax,ax
	POP	SI
	POP	DS
	POP	BP
	IRET				; interrupt return

endif	;not WINDOWS
;	Segment override case

glb	<SegOvrTab>

SegOvrTab	label	word

	dw	DSSegOvr
	dw	SSSegOvr
	dw	CSSegOvr
	dw	ESSegOvr

pub	SOtrap
	STI				; re-enable interrupts
	push	ax
	push	es			; set up frame
	push	ds
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	sub	sp,2			; reserve for regSegOvr
	push	bp
	mov	bp,sp			; set up frame pointer
	CLD				; clear direction flag forever

; get address mode information, dispatch to address calculation

	MOV	DX,BX			; may use original BX to calc address
	MOV	AX,DI			; may use original DI to calc address
	LDS	DI,dword ptr [bp].regIP ; DS:DI is caller's CS:IP
	INC	DI			; increment past operation byte
	INC	DI			; increment past operation byte
	MOV	CX,[DI-2]		; get trap number, opcode (DS=caller CS)
	mov	bx,cx			; upper 2 bits indicate segment override
	rol	bl,1
	rol	bl,1
	and	bx,3
	rol	bx,1
	jmp	SegOvrTab[bx]
endif	;DOS3


pub	DSSegOvr			; 00
	mov	es,[bp].regDS		; set ES to EA segment
	jmp	short ESSegOvr

pub	CSSegOvr			; 10
	mov	bx,ds			; DS = caller's CS
	mov	es,bx			; set ES to EA segment
	jmp	short ESSegOvr

pub	SSSegOvr			; 01
	mov	bx,ss			; SS = caller's SS
	mov	es,bx			; set ES to EA segment

pub	ESSegOvr			; 11
	mov	[bp].regSegOvr,es	; save for bp rel EAs
	jmp	short CommonDispatch


ifdef   PROTECT
pub	protSegOvr
	mov	dx,bx			; may use original BX to calc address
	mov	bl,cl

	.286
	shr	bl,2

ifndef	DOS5only
	.8086
endif
	and	bx,6			; bl = (seg+1) and 6
	inc	di			; point to displacement
	mov	cx,[di-2]		; cx = esc 0-7 and opcode
	jmp	protSegOvrTab[bx]	; process appropriate segment override


ifdef   XENIX
pub     jinstall
        jmp     installemulator
endif   ;XENIX


pub	protemulation
	cld				; clear direction flag forever

ifdef	XENIX

        push    ax                      ; UNDONE - slow
        push    ds                      ; UNDONE - slow

	mov	ax,LDT_DATA		; load up emulator's data segment
	mov	ds,ax
	cmp	[Einstall],0		; check if emulator is initialized
        je      jinstall                ;   no - go install it

pub	protemcont

        pop     ds                      ; UNDONE - slow
        pop     ax                      ; UNDONE - slow

endif	;XENIX

	push	ax
	push	es			; set up frame
	push	ds
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	push	ss			; save SegOvr (bp forces SS override)
	push	bp
	mov	bp,sp			; set up frame pointer
	mov	dx,ds			; save original DS for default case
	mov	ax,di			; may use original DI to calc address
	lds	di,dword ptr [bp].regIP ; ds:di = 287 instruction address
	mov	cx,[di] 		; cx = esc 0-7 and opcode
	add	di,2			; point to displacement
	add	cl,28h			; set carry if esc 0-7 (and cl = 0-7)
	jnc	protSegOvr		;   no carry - must be segment override
	mov	es,dx			; es = user data segment
	mov	dx,bx			; may use original BX to calc address
endif   ;PROTECT

ifdef	DOS3and5
	jmp	short CommonDispatch
endif	;DOS3and5


ifdef	DOS3
;	normal entry point for emulator interrupts

	even

pub	DStrap
	STI				; re-enable interrupts
	push	ax
	push	es			; set up frame
	push	ds
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	push	ss			; save SegOvr (bp forces SS override)
	push	bp
	mov	bp,sp			; set up frame pointer
	mov	ax,ds
	mov	es,ax			; ES = caller's DS
	CLD				; clear direction flag forever

; get address mode information, dispatch to address calculation

	MOV	DX,BX			; may use original BX to calc address
	MOV	AX,DI			; may use original DI to calc address
	LDS	DI,dword ptr [bp].regIP ; DS:DI is caller's CS:IP
	INC	DI			; increment past operation byte
	MOV	CX,[DI-2]		; get trap number, opcode (DS=caller CS)
; Otherwise, CL contains BEGINT + |MF|Arith| so we must unbias it
	SUB	CL,BEGINT
endif	;DOS3


;	DS:DI = original CS:IP of displacement field
;	ES    = Effective Address segment (original DS if no segment override)
;	DX    = original BX
;	AX    = original DI
;	SI    = original SI
;	CX    = (opcode,0-7 from ESC byte)
;	stack = saved register set

pub	CommonDispatch
	ROL	CH,1			; rotate MOD field next to r/m field
	ROL	CH,1
	MOV	BL,CH			; get copy of operation
	AND	BX,1FH			; Mask to MOD and r/m fields
	SHL	BX,1			; make into word offset
	JMP	EA286Tab[BX]


OneByteDisp  macro
	mov	al, [di]		;; get one byte displacement
	cbw				;; sign extend displacement
	inc	di			;; get past displacement byte
	add	si, ax			;; add one byte displacement
	endm

TwoByteDisp  macro
	add	si, [di]		;; add word displacement
	add	di, 2			;; get past displacement word
	endm


	even

pub BXXI0D
	MOV	SI,DX			; use original BX index value
	JMP	short ADRFIN		; have offset in SI

pub DSDI0D
	MOV	SI,AX			; use alternate index value
	JMP	short ADRFIN		; have offset in SI

	even

pub BPXI1D
	mov	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	OneByteDisp
	JMP	short ADRFIN

	even

pub BPDI1D
	MOV	SI,AX			; use alternate index value
pub BPSI1D
	ADD	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	OneByteDisp
	JMP	short ADRFIN

	even

pub BXSI1D
	MOV	AX,SI			; really will want SI, not DI
pub BXDI1D
	ADD	DX,AX			; now DX is original BX plus index
pub BXXI1D
	MOV	AX,DX			; use original BX index value
pub DSDI1D
	MOV	SI,AX			; use alternate index value
pub DSSI1D
	OneByteDisp
	JMP	short ADRFIN

	even

pub BPXI2D
	mov	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	TwoByteDisp
	JMP	short ADRFIN

	even

pub BPDI2D
	MOV	SI,AX			; use alternate index value
pub BPSI2D
	ADD	SI,[bp].regBP		; add original BP value
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	TwoByteDisp
	JMP	short ADRFIN

	even

pub BXSI2D
	MOV	AX,SI			; really will want SI, not DI
pub BXDI2D
	ADD	DX,AX			; now DX is original BX plus index
pub BXXI2D
	MOV	AX,DX			; use original BX index value
pub DSDI2D
	MOV	SI,AX			; use alternate index value
pub DSSI2D
	TwoByteDisp
	JMP	short ADRFIN

	even

pub BPDI0D
	MOV	SI,AX			; use alternate index value
pub BPSI0D
	add	si,[bp].regBP		; really will want BP, not BX
	mov	es,[bp].regSegOvr	; ES = override segment (or SS if none)
	jmp	short ADRFIN

	even

pub BXDI0D
	MOV	SI,AX			; si = regDI
pub BXSI0D
	add	si,dx			; si = regSI+regBX
	jmp	short ADRFIN

	even

pub DSXI2D
	MOV	SI,[DI] 		; get two byte displacement
	INC	DI			; get past displacement byte
	INC	DI			; get past displacement byte

pub DSSI0D				; SI = EA (original SI for DSSI0D)

pub	ADRFIN
	MOV	[bp].regIP,DI		; final return offset

ifdef  LOOK_AHEAD
	mov	bl,[di] 		; get byte of next instruction
endif

ifdef	MTHREAD			
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS, trashes AX
else	;not MTHREAD
    ifdef   standalone
	xor	ax,ax
	mov	ds,ax
	mov	ds,ds:[4*TSKINT+2]	; DS = emulator task data segment

    elseifdef  XENIX
	mov	ax,LDT_DATA
	mov	ds,ax

    elseifdef  _COM_
	mov	ds, [__EmDataSeg]

    else
	mov	ax, edataBASE
	mov	ds,ax
    endif
endif	;not MTHREAD

ifdef  LOOK_AHEAD
	mov	[NextOpCode], bl	; save byte of next instruction
endif

	mov	[CURerr],MemoryOperand	; clear current error, set mem. op bit

; At this point ES:SI = memory address, CX = |Op|r/m|MOD|escape|MF|Arith|

	SHR	CH,1
	SHR	CH,1			; Move Op field to BX for Table jump
	SHR	CH,1
	SHR	CH,1
	MOV	BL,CH
	AND	BX,0EH

	TEST	CL,1			; Arith field set?
	JZ	ArithmeticOpMem

pub	NonArithOpMem
	mov	eax,offset EMLFINISH
	push	eax
	jmp 	NonArithOpMemTab[BX]

	even

pub	ArithmeticOpMem
	PUSH	BX			; Save Op while we load the argument
	MOV	BX,CX			; Dispatch on MF
	AND	ebx,6H
ifdef	i386
	call	FLDsdriTab[2*ebx]	; emulate proper load
else
	call	FLDsdriTab[ebx] 	; emulate proper load
endif
	POP	BX

	mov	ax,ds			; ES = DS = task data area
	mov	es,ax
	MOV	SI,[CURstk]		; address top of stack
	MOV	DI,SI
	ChangeDIfromTOStoNOS
	MOV	[RESULT],DI		; Set up destination Pointer

	JMP	short DoArithmeticOpPop


	even

pub	NoEffectiveAddress		; Either Register op or Miscellaneous

	MOV	[bp].regIP,DI		; final return offset

ifdef  LOOK_AHEAD
	mov	bl, [di]		; get first byte of next instruction.
endif

ifdef	MTHREAD			
	LOADthreadDS			; macro in emthread.asm
					; loads thread's DS; trashes AX
	mov	ax,ds
	mov	es,ax			; DS = ES = per-thread em. data area
	xor	ax,ax

else	;not MTHREAD

	xor	ax,ax

    ifdef   standalone
	mov	ds,ax
	mov	di,ds:[4*TSKINT+2]	; DI = emulator task data segment

    elseifdef	XENIX
        mov     di,LDT_DATA

    elseifdef  _COM_
	mov	di, [__EmDataSeg]

    else
	mov	di, edataBASE
    endif

	mov	ds,di			; di = emulator data segment
	mov	es,di			; ax = 0
endif	;not MTHREAD

; ES = emulator data segment
; DS = emulator data segment
; AX = 0 

ifdef  LOOK_AHEAD
	mov	[NextOpCode], bl	; save first byte of next instruction
endif

	mov	[CURerr],ax		; clear current error, memory op bit

; CX = |Op|r/m|MOD|escape|MF|Arith|

	MOV	BL,CH
	SHR	BL,1			; Mov Op field to BX for jump
	SHR	BL,1
	SHR	BL,1
	SHR	BL,1
	AND	BX,0EH

	TEST	CL,1			; Arith field set?
	JZ	ArithmeticOpReg

pub	NonArithOpReg
	CALL	NonArithOpRegTab[BX]
	JMP	EMLFINISH

; For register arithmetic operations, one operand is always the stack top.
; The r/m field of the instruction is used to determine the address of
; the other operand (ST(0) - ST(7))
; CX = xxxRRRxxxxxxxxxx (x is don't care, RRR is relative register # 0-7)

	even

pub	ArithmeticOpReg

	call	RegAddr 		;di <= address of 2nd operand
					;carry set if invalid register
	jc	InvalidOperand		;no, invalid operand, don't do operation

	MOV	[RESULT],SI		; Set destination to TOS
	TEST	CL,04H			; Unless Dest bit is set
	JZ	DestIsSet		; in which case
	MOV	[RESULT],DI		; Set destination to DI

pub	DestIsSet
					; Need to Toggle Reverse bit for DIV or SUB
	TEST	BL,08H			; OP = 1xx for DIV and SUB; BX = |0000|OP|O|
	JZ	SetUpPop
	XOR	BL,02H			; Toggle Reverse bit

pub	SetUpPop
	TEST	CL,02H
	JZ	DoArithmeticOpNoPop

pub	DoArithmeticOpPop
	CALL	ArithmeticOpTab[BX]
	mov	esi,[CURstk]
	cmp	esi,[BASstk]		   ; 15 was it last register in the chunk ?
	jz 	short AOPstovr		   ; 16 yes, overflow
AOPstok:
	sub	esi,Reg87Len		   ;  4 decrement SI to previous register
	mov	[CURstk],esi		   ; 15 set current top of stack
	JMP	short EMLFINISH

AOPstovr:
	call	UnderStk		   ;	stack underflow error
	jmp	AOPstok

	even

pub	DoArithmeticOpNoPop
	mov	eax,offset EMLFINISH
	push	eax
	jmp 	ArithmeticOpTab[BX]


;***	InvalidOperand - register operand does not exist
;
;	RETURNS
;		sets Stack Underflow and Invalid bits in [CURerr]
;
;	DESCRIPTION
;		a reference was made to a register that does not
;		exist on the stack.  Set error bits and exit.

pub	InvalidOperand
	call	UnderStk		;indicate stack underflow error
	or	[CURerr],Invalid	;indicate invalid operand
	jmp	short EMLFINISH 	;don't execute instruction

;***	RegAddr - compute register address
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m = register whose address is to be computed
;
;	RETURNS
;		SI = address of top of stack
;		DI = address of requested register
;		PSW.C set if register is not valid
;		PSW.C reset if register is valid
;
;	DESCRIPTION
;		multiply register number by 12 and subtract this from
;		[CURstk] (the address of TOS) to compute address of
;		register referenced by r/m.
;
;	REGISTERS
;		modifies dx

pub	RegAddr
	MOV	SI,[CURstk]		; address top of stack
	MOV	DI,SI
;set up address of 2nd operand based on r/m field of instruction
	mov	dl,ch			; dl <== byte containing reg#
	and	dl,01ch 		; mask all but r/m field

; Since r/m field contains the relative reg # in bits 2-4 of dl,
; and bits 0-1 of dl are zero, dl now contains 4*(reg #).  To compute
; the memory location of this register, calculate 12*(reg #) and
; subtract this from di, which contains the address of the TOS.  reg #
; is multiplied by 12 because that is the number of bytes in each stack
; entry.
	mov	dh,dl			; dh = dl = 4*(reg #)
	shl	dh,1			; dh = 2*dh = 8*(reg #)
	add	dl,dh			; dl = 8*(reg #) + 4*(reg #) = 12*(reg #)
	xor	dh,dh			; zero out high byte of DX
	sub	di,dx			; di is address of second operand
	cmp	di,[BASstk]		; is register in range?
	clc				; assume valid register
	jg	$+3			; valid - skip next instruction
	cmc				; set carry to indicate invalid register
	ret


pub	CallUnused
	CALL	UNUSED			; Treat as unimpleminted
	jmp	EMLFINISH


;	out of line returns from emulator


pub	SawException
	pop	bp			; restore registers
	add	sp,2			; toss regSegOvr
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es

pub	ExceptionsEmulator
	JMP	CommonExceptions


ifdef LOOK_AHEAD

pub  NoPipeLine

	pop	bp			; restore registers
	add	sp,2			; toss regSegOvr
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es

pub	errret
        error_return    noerror         ; common exit sequence

endif	;LOOK_AHEAD

; return from routine;	restore registers and return


	even

pub	EMLFINISH

    ; check for errors

	MOV	AX,[CURerr]		; fetch errors
	or	[UserStatusWord],ax	; save all exception errors
	OR	[SWerr],AL		; set errors in sticky error flag
	NOT	AL			; make a zero mean an error
	MOV	bh,byte ptr [UserControlWord]	; get user's IEEE control word
	OR	bh,0C2H 		; mask reserved, IEM and denormal bits
	AND	bh,03FH 		; unmask invalid instruction,
					;    stack overflow.
	OR	AL,bh			; mask for IEEE exceptions
	NOT	AL			; make a one mean an error
	TEST	AX,0FFFFh-MemoryOperand ; test for errors to report

	jnz	SawException		; goto error handler

ifndef	LOOK_AHEAD
	pop	bp			; restore registers
	add	sp,2			; toss regSegOvr
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es

pub	errret
        error_return    noerror         ; common exit sequence

else	;LOOK_AHEAD


ifdef  DOS3and5
	jmp	[LookAheadRoutine]
endif


ifdef  DOS3

pub  DOSLookAhead
	cmp	[NextOpcode], fINT	; Quick check.	If first byte isn't
	jne	NoPipeLine		; an int instruction then exit.

    ; can stay in the emulator - set up registers for CommonDispatch

	mov	bp, sp			; set up frame pointer
	lds	di, dword ptr [bp].regIP ; DS:DI = address of next instruction
	add	di, 3			; skip 3 bytes to displacement field
	mov	cx, [di-2]		; CX = (opcode byte,0-7 from ESC)
	sub	cl, BEGINT

	cmp	cl, 7			; Can't handle segment overrides with
	ja	NoPipeLine		; pipe lining.

	mov	ax, [bp].regDI		; ax = original di
	mov	dx, [bp].regBX		; dx = original bx
	mov	si, [bp].regSI		; si = original si
	mov	es, [bp].regDS		; es = original ds (no segment override)
	mov	[bp].regSegOvr, ss	; reset override segment

	rol	ch, 1			; rotate MOD field next to r/m field
	rol	ch, 1
	mov	bl, ch			; get copy of operation
	and	bx, 1fh 		; Mask to MOD and r/m fields
	shl	bx, 1			; make into word offset
	jmp	EA286Tab[bx]

endif	;DOS3


ifdef  PROTECT

pub ProtLookAhead
	mov	cl, [NextOpcode]

	cmp	cl, fFWAIT
	je	CheckNextByte

	cmp	cl, iNOP
	je	CheckNextByte

	xor	cl,  20h		; See if this is a floating point instruction.
	cmp	cl, 0f8h
jbNoPipeLine:
	jb	NoPipeLine

	mov	bp, sp			 ; set up frame pointer
	lds	di, dword ptr [bp].regIP ; ds:di = address of next instruction

	jmp	short CanDoPipeLine

pub CheckNextByte
	mov	bp, sp			 ; set up frame pointer
	lds	di, dword ptr [bp].regIP ; ds:di = address of next instruction
	inc	di			 ; next instruction was NOP or FWAIT

	mov	cl, [di]
	xor	cl,  20h
	cmp	cl, 0f8h
	jb	jbNoPipeLine

pub CanDoPipeLine
	mov	ch, [di+1]		; we already have first byte of next
	add	di, 2			; instruction in cl

	add	cl, 8h			; clear out what's left of escape

	mov	ax, [bp].regDI		; ax = original di
	mov	dx, [bp].regBX		; dx = original bx
	mov	si, [bp].regSI		; si = original si
	mov	es, [bp].regDS		; es = original ds (no segment override)
	mov	[bp].regSegOvr, ss	; reset override segment

	rol	ch, 1			; rotate MOD field next to r/m field
	rol	ch, 1
	mov	bl, ch			; get copy of operation
	and	bx, 1fh 		; Mask to MOD and r/m fields
	shl	bx, 1			; make into word offset
	jmp	EA286Tab[bx]

endif	;PROTECT



endif	;LOOK_AHEAD


ProfEnd  MAIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emoem.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987-92
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
title	emoem.asm - OEM dependent code for 80x87

;--------------------------------------------------------------------
;
;	OEM customization routines for 8087/80287/80387 coprocessor
;
;	This module is designed to work with the following
;	Microsoft language releases:
;
;		Microsoft C 3.00 and later
;		Microsoft FORTRAN 77 3.30 and later
;		Microsoft Pascal 3.30 and later
;
;	This module supersedes the OEMR7.ASM module used in earlier
;	versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;	provided with the FORTRAN and Pascal releases refers to the old
;	OEMR7.ASM module and is only slightly relevant to this module.
;
;	The following routines need to be written to properly handle the
;	8087/80287/80387 installation, termination, and interrupt handler
;
;	__FPINSTALL87		install 80x87 interrupt handler
;	__FPTERMINATE87 	deinstall 80x87 interrupt handler
;	__fpintreset		reset OEM hardware if an 80x87 interrupt
;
;	*****  NEW INSTRUCTIONS  *****
;
;	If you want a PC clone version, do nothing.  The libraries are
;	setup for working on IBM PC's and clones.
;
;	These instructions only need to be followed if a non-IBM PC
;	clone version is desired.
;
;	This module should be assembled with the
;	Microsoft Macro Assembler Version 4.00 or later as follows:
;
;		masm -DOEM -r emoem.asm;
;
;	Most hardware handles the 8087/80287/80387 in one of the following
;	three ways -
;
;	1.	NMI - IBM PC and clones all handle the interrupt this way
;	2.	single 8259
;	3.	master/slave 8259
;
;	Manufacturer specific initialization is supported for these 3
;	machine configurations either by modifying this file and replacing
;	the existing EMOEM module in the math libraries or by patching
;	the .LIB and .EXE files directly.
;
;		LIB 87-+EMOEM;
;		LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef	OEM
if1
	%out	OEM version for non-clone support
endif
endif

;---------------------------------------------------------------------
;	Assembly constants.
;---------------------------------------------------------------------

; MS-DOS OS calls

   OPSYS	EQU	21H
   SETVECOP	EQU	25H
   GETVECOP	EQU	35H
   DOSVERSION	EQU	30h
ifndef	_NOCTRLC
   CTLCVEC	EQU	23h
endif	;_NOCTRLC

EMULATOR_DATA	segment para public 'FAR_DATA'
assume	ds:EMULATOR_DATA

;	User may place data here if DS is setup properly.
;	Recommend keeping the data items in the code segment.

EMULATOR_DATA	ends



EMULATOR_TEXT	segment para public 'CODE'
assume	cs:EMULATOR_TEXT

	public	__FPINSTALL87		; DO NOT CHANGE THE CASE ON
	public	__FPTERMINATE87 	; THESE PUBLIC DEFINITIONS

	extrn	__FPEXCEPTION87:near	; DO NOT CHANGE CASE


ifdef	_NO87INSTALL	; install/terminate routines for NO87 case for QuickC

	public	__FPINSTALLNO87	
	public	__FPTERMINATENO87

endif	;_NO87INSTALL


ifdef	OEM

;***********************************************************************
;
; Hardware dependent parameters in the 80x87 exception handler.
;
; For machines using 2 8259's to handle the 80x87 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 80x87
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 80x87 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum	db	0		; MS-DOS OEM number (IBM is 00h)
intnum	db	2		; IBM PC clone interrupt number
share	db	0		; nonzero if original vector should be taken
a8259	dw	0		; 1st 8259 (A0=0) port #
aocw2	db	0		; 1st 8259 (A0=0) EOI command
b8259	dw	0		; 2nd 8259 (A0=0) port #
bocw2	db	0		; 2nd 8259 (A0=0) EOI command
a8259m	dw	0		; 1st 8259 (A0=1) port #
aocw1m	db	0		; 1st 8259 (A0=1) value to mask against IMR
b8259m	dw	0		; 2nd 8259 (A0=1) port #
bocw1m	db	0		; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;	OEM specific 80x87 information
;
;	If the OEM number returned from the DOS version call matches,
;	this information is automatically moved into the oem struc below.

oemtab	label	byte	; Table of OEM specific values for 80x87

;		OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db	0	; end of table

;	Unique pattern that can be searched for with the debugger so that
;	.LIB or .EXE files can be patched with the correct values.
;	If new values are patched into .LIB or .EXE files, care must be
;	taken in insure the values are correct.  In particular, words and
;	bytes are intermixed in oeminfo structure.  Remember words are
;	stored low byte - high byte in memory on the 8086 family.

	db	'<<8087>>'	; older versions used '<8087>'

;	Some manufacturer's machines can not be differentiated by the
;	OEM number returned by the MS-DOS version check system call.
;	For these machines it is necessary to replace the line below

oem1	oeminfo <>		; default values for IBM PC & clones

;	with one of the following.  If your machine has an 80x87 capability
;	and it is not in the list below, you should contact your hardware
;	manufacturer for the necessary information.

;ACT Apricot
;oem1	 oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1	 oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

aoldIMR 	db	0	; 1st 8259 original IMR value
boldIMR 	db	0	; 2nd 8259 original IMR value

endif	;OEM

statwd		dw	0	; Temporary for status word
oldvec		dd	0	; Old value in 80x87 exception interrupt vector
ifndef	_NOCTRLC
ctlc		dd	0	; Old value of Control-C vector (INT 23h)
endif	;_NOCTRLC

page

;---------------------------------------------------------------------
;
;	Perform OEM specific initialization of the 80x87.
;

__FPINSTALL87:
	push	ds			; DS = EMULATOR_DATA

	push	cs			; Move current CS to DS for opsys calls.
	pop	ds
assume	ds:EMULATOR_TEXT

ifdef	OEM
	push	ds
	pop	es			; CS = DS = ES
	mov	ah,DOSVERSION
	int	OPSYS			; bh = OEM#
	cld
	mov	si,offset oemtab	; start of OEM 80x87 info table
	mov	di,offset oem1+1
	mov	cx,(size oem1)-1
OEMloop:
	lodsb				; get OEM#
	or	al,al
	jz	OEMdone 		; OEM# = 0 - did not find OEM
	cmp	al,bh			; correct OEM#
	je	OEMfound
	add	si,cx			; skip over OEM information
	jmp	OEMloop

OEMfound:
	rep	movsb			; move the information

OEMdone:				; done with automatic customization
endif	;OEM

; Save old interrupt vector.
; Ask operating system for vector.

ifdef  WINDOWS
	mov	ax, word ptr [oldvec]
	or	ax, word ptr [oldvec+2]
	jnz	SetVector
endif	;WINDOWS

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.

	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

SetVector:
	mov	dx,offset __fpinterrupt87 ; Load DX with 80x87 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

ifndef	_NOCTRLC
; Intercept Control-C vector to guarentee cleanup

	mov	ax,GETVECOP shl 8 + CTLCVEC
	int	OPSYS
	mov	word ptr [ctlc],bx
	mov	word ptr [ctlc+2],es
	mov	dx,offset ctlcexit
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
endif	;_NOCTRLC

ifdef	OEM

;	set up 8259's so that 80x87 interrupts are enabled

	mov	ah,[oem1].aocw1m 	; get mask for 1st 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;   and only 1 8259
	mov	dx,[oem1].a8259m 	; get port number for 1st 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[aoldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

	mov	ah,[oem1].bocw1m 	; get mask for 2nd 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;
	mov	dx,[oem1].b8259m 	; get port number for 2nd 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[boldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

installdone:

endif	;OEM

assume	ds:EMULATOR_DATA
	pop	ds
	ret


page
;	__FPTERMINATE87
;
;	This routine should do the OEM 80x87 cleanup.  This routine is called
;	before the program exits.
;
;	DS = EMULATOR_DATA

__FPTERMINATE87:
	push	ds
	push	ax
	push	dx

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
	int	OPSYS

ifdef	OEM

;	reset 8259 IMR's to original state

	push	cs
	pop	ds			; DS = CS
assume	ds:EMULATOR_TEXT
	cmp	[oem1].aocw1m,0		; did we have to change 1st 8259 IMR
	je	term2nd8259		;   no - check 2nd 8259
	mov	al,[aoldIMR]		; get old IMR
	mov	dx,[oem1].a8259m 	; get 1st 8259 (A0=1) port #
	out	dx,al			; restore IMR

term2nd8259:
	cmp	[oem1].bocw1m,0		; did we have to change 2nd 8259 IMR
	je	terminatedone		;   no
	mov	al,[boldIMR]		; get old IMR
	mov	dx,[oem1].b8259m 	; get 2nd 8259 (A0=1) port #
	out	dx,al			; restore IMR

terminatedone:

endif	;OEM

	pop	dx
	pop	ax
	pop	ds
assume	ds:EMULATOR_DATA
	ret


;	Forced cleanup of 80x87 exception handling on Control-C

ifndef	_NOCTRLC
ctlcexit:
	push	ax
	push	dx
	push	ds
	call	__FPTERMINATE87 	; forced cleanup of exception handler
	lds	dx,[ctlc]		; load old control C vector
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
	pop	ds
	pop	dx
	pop	ax
	jmp	[ctlc]			; go through old vector
endif	;_NOCTRLC

page
;	__fpinterrupt87
;
;	This is the 80x87 exception interrupt routine.
;
;	All OEM specific interrupt and harware handling should be done in
;	__fpintreset because __FPEXCEPTION87 (the OEM independent 80x87
;	exception handler) may not return.  __FPEXCEPTION87 also turns
;	interrupts back on.
;

PENDINGBIT=	80h		; Bit in status word for interrupt pending

__fpinterrupt87:
assume	ds:nothing
	nop
	fnstsw	[statwd]	; Store out exceptions
	push	cx		; waste time
	mov	cx,3
self:
	loop	self
	pop	cx
	test	byte ptr [statwd],PENDINGBIT	; Test for 80x87 interrupt
	jz	not87int	; Not an 80x87 interrupt.

ifdef	OEM
	call	__fpintreset	; OEM interrupt reset routine
endif	;OEM

	call	__FPEXCEPTION87 ; 80x87 error handling - may not return
				; this routine turns interrupts back on

ifdef	OEM
	cmp	[oem1].share,0	; Should we execute the old interrupt routine?
	jnz	not87int	;    if so then do it
				;    else return from interrupt

;	If you fall through here to do further hardware resetting, things
;	may not always work because __FPEXCEPTION87 does not always return
;	This only happens when the 80x87 handler gets an exception that is
;	a fatal error in the language runtimes.  I.e., divide by zero
;	is a fatal error in all the languages, unless the control word has
;	set to mask out divide by zero errors.

endif	;OEM

done8087:
	iret

not87int:
	jmp	[oldvec]	; We should never return from here.


ifdef	OEM


__fpintreset:
	push	ax
	push	dx
	mov	al,[oem1].aocw2	; Load up EOI instruction.
	or	al,al		; Is there at least one 8259 to be reset?
	jz	Reset8259ret	; no
	mov	dx,[oem1].a8259
	out	dx,al		; Reset (master) 8259 interrupt controller.
	mov	al,[oem1].bocw2	; Load up EOI instruction.
	or	al,al		; Is there a slave 8259 to be reset?
	jz	Reset8259ret
	mov	dx,[oem1].b8259
	out	dx,al		; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop	dx
	pop	ax
	ret

endif	;OEM

ifdef	_NO87INSTALL
__FPINSTALLNO87:
	push	bx
	push	es
	push	ax
	push	dx
	push	ds

	mov	ax,cs			; Move current CS to DS for opsys calls.
	mov	ds,ax
assume	ds:EMULATOR_TEXT
	
; Save old interrupt vector.
; Ask operating system for vector.

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

	mov	dx,offset __fpinterruptno87 ; Load DX with fake 80x87 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

	pop	ds
assume	ds:nothing
	pop	dx
	pop	ax
	pop	es
	pop	bx
	
	ret

__fpinterruptno87:
	jmp	[oldvec]		; will use CS: override

__FPTERMINATENO87:
	push	ds
	push	ax
	push	dx

	mov	ax,cs
	mov	ds,ax
assume	ds:EMULATOR_TEXT

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
assume	ds:nothing
	int	OPSYS

	pop	dx
	pop	ax
	pop	ds

	ret

endif	;_NO87INSTALL

EMULATOR_TEXT	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emnormal.asm ===
page	,132
	subttl	emnormal.asm - Normalize and Round
;***
;emnormal.asm - Normalize and Round
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Normalize and Round.
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin NORMAL

;------------------------------------------;
;					   ;
;   Double Precision Normalize and Round   ;
;					   ;
;------------------------------------------;

	even

pub	NODRQQ
; Normalize the double precision number
; All arithmetic operations exit through NODRQQ or RNDR7Q
; Mantissa in DI:BX:CX:DX:BP, Exponent in SI, sign on Stack, old BP on Stack

	MOV	AL,4		; Maximum of 4 word shifts, sign in AH(6)
pub	DNOR
	OR	DI,DI		; See if any bits on in high word
	JNZ	short HIBYT	; If so, go check high byte for zero
	SUB	SI,16		; Drop exponent by shift count
	DEC	AL		; Bump count
	JZ	short NORZERO
	MOV	DI,BX
	MOV	BX,CX
	MOV	CX,DX
	MOV	DX,BP
	XOR	BP,BP
	JMP	DNOR

pub	NORZERO 	       ; Here if result after normalization is zero
	MOV	esi,offset IEEEzero
	MOV	edi,[RESULT]
	POP	eax	    ; Throw out sign on stack
	POP	ebp	    ; Restore Old BP
	JMP	csMOVRQQ    ; Move IEEE zero to TOS and return

	even

pub	HIBYT
	TEST	DI,0FF00H	; See if high byte is zero
	JNZ	short NORMSHF2
	SUB	SI,8		; Drop exponent by shift amount

pub	DN2
	XCHG	AX,DI
	MOV	AH,AL
	MOV	AL,BH
	MOV	BH,BL
	MOV	BL,CH
	MOV	CH,CL
	MOV	CL,DH
	MOV	DH,DL
	XCHG	AX,DI
	XCHG	AX,BP
	MOV	DL,AH
	MOV	AH,AL
	XOR	AL,AL
	XCHG	AX,BP

	even

pub	NORMSHF2
	TEST	DI,8000H	; Normalization complete?
	JNZ	ROUND		; Normalization complete

pub	NORMLP			; Have to shift left
	DEC	SI		; Account for shift in exponent
	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	RCL	DI,1
	TEST	DI,8000H	; Check for normalized result
	JZ	NORMLP		; Bit will be set when normalized
	JMP	short ROUND


pub	ROUND24 		; Round to 24 bits
	OR	DX,BP		; See if result fits exactly in 24 bits
	OR	CX,DX
	OR	CL,CH
	MOV	CH,BL
	OR	CX,CX
	JZ	short JEXACT
	OR	[CURerr],Precision   ; Set flag on inexact result
	SHR	AL,1
	JC	short DOWNorCHOP24
	SHR	AL,1
	JC	short UP24

pub	NEAR24			; Round to nearest or Even
	CMP	CX,8000H
	JA	short INC24	; Remainder Bigger then .5 so Bump up
	JB	short MSK24	; Remainder Less then .5 so Mask off
	TEST	BH,1		; Remainder = .5 so see if even
	JZ	short MSK24	; When even Mask
	JMP	short INC24	; When odd Bump up

pub	UP24
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short MSK24	; Trunc neg numbers to move toward + Inf
	JMP	short INC24

pub	DOWNorCHOP24
	SHR	AL,1
	JC	short CHOP24

pub	DOWN24
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short INC24
	JMP	short MSK24	; Trunc Pos numbers to move toward - Inf

pub	INC24
	ADD	BH,1
	ADC	DI,0
	JNC	short MSK24
	MOV	DI,8000H	; Number overflowed from 1,111... to 10,000...
	INC	SI		; Bump up Exponent

pub	CHOP24
MSK24:				; Mask off insignificant bits
	XOR	BP,BP
	MOV	DX,BP
	MOV	CX,DX
	MOV	BL,CL
pub	JEXACT
	JMP	EXACT


	even

pub	NORMSHF 		; from multiply only
	TEST	DI,8000H	; Normalization complete?
	JNZ	ROUND		; Normalization complete

	DEC	SI		; Account for shift in exponent
	SHL	BP,1
	RCL	DX,1
	RCL	CX,1
	RCL	BX,1
	RCL	DI,1

	even
				; mantissa in DI:BX:CX:DX:BP

pub	ROUND			; Drop into ROUND when normalized
	MOV	AL,[CWcntl]	; Pick up hi byte of control word
	SHR	AL,1		; Which has Rounding & Precision Control
	jnc	short ROUND53

pub	ROUND64 		; Round to 64 bits
	SHR	AL,1		; Remove other bit of Precision control
	OR	BP,BP		; See if result fits exactly in 64 bits
	JZ	short EXACT
	OR	[CURerr],Precision   ; Set flag on inexact result
	SHR	AL,1
	JC	short DOWNorCHOP64
	SHR	AL,1
	JC	short UP64

pub	NEAR64			; Round to nearest or Even
	CMP	BP,8000H
	JA	short INC64	; Remainder Bigger then .5 so Bump up
	JB	short MSK64	; Remainder Less then .5 so Mask off
	TEST	DL,1		; Remainder = .5 so see if even
	JZ	short MSK64	; When even Mask

pub	INC64
	XOR	BP,BP		; Need a 0
	ADD	DX,1
	ADC	CX,BP
	ADC	BX,BP
	ADC	DI,BP
	JNC	short EXACT

	MOV	DI,8000H	; Number overflowed from 1,111... to 10,000...
	INC	SI		; Bump up Exponent

	even

CHOP64:
MSK64:				; Mask off insignificant bits

pub	EXACT
	MOV	eax,[RESULT]
	XCHG	eax,edi
	MOV	MB0[edi],DX	   ; Save Mantissa
	MOV	MB2[edi],CX
	MOV	MB4[edi],BX
	MOV	MB6[edi],AX
	POP	eax		; Fetch Sign
	POP	ebp		; Fetch Old BP
	AND	AH,Sign 	; Mask off single precision
	MOV	Flag[edi],AH

	CMP	SI,IexpMax - IexpBias ; Test for overflow
	JGE	short jOVER
	CMP	SI,IexpMin - IexpBias ; Test for Underflow
	JLE	short UNDER

pub	NORTAG
	MOV	Expon[edi],SI
	MOV	byte ptr Tag[edi],0	  ; Number is in range and on TOS so ret
	RET

jOVER:	jmp	OVER

pub	UP64
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short MSK64	; Trunc neg numbers to move toward + Inf
	JMP	short INC64

pub	DOWNorCHOP64
	SHR	AL,1
	JC	short CHOP64

pub	DOWN64
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short INC64
	JMP	short MSK64	; Trunc Pos numbers to move toward - Inf


jROUND24:
	jmp	ROUND24

pub	ROUND53 		; Round to 53 bits (or 24)
	SHR	AL,1
	JNC	short jROUND24

	XCHG	BP,AX		; See if result fits exactly in 53 bits
	OR	AL,AH
	OR	AL,DL
	MOV	AH,DH
	AND	AH,007H
	AND	DH,0F8H
	XCHG	BP,AX
	OR	BP,BP
	JZ	EXACT
	OR	[CURerr],Precision   ; Set flag on inexact result
	SHR	AL,1
	JC	short DOWNorCHOP53
	SHR	AL,1
	JC	short UP53

pub	NEAR53			; Round to nearest or Even
	CMP	BP,0400H
	JA	short INC53	; Remainder Bigger then .5 so Bump up
	JB	short MSK53	; Remainder Less then .5 so Mask off
	TEST	DH,08H		; Remainder = .5 so see if even
	JZ	short MSK53	; When even Mask
	JMP	short INC53	; When odd Bump up


pub	UNDER
MUNDER: 	; Masked Underflow
	MOV	esi,offset IEEEzero
	CALL	csMOVRQQ
	MOV	Flag[edi],AH	     ; Overstore correct sign
	RET


pub	UP53
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short MSK53	; Trunc neg numbers to move toward + Inf
	JMP	short INC53

pub	DOWNorCHOP53
	SHR	AL,1
	JC	short CHOP53

pub	DOWN53
	POP	eax		; Get the sign
	PUSH	eax
	SHL	AH,1
	JC	short INC53
	JMP	short MSK53	; Trunc Pos numbers to move toward - Inf

pub	INC53
	XOR	BP,BP		; Need a 0
	ADD	DH,08H
	ADC	CX,BP
	ADC	BX,BP
	ADC	DI,BP
	JNC	short MSK53

	MOV	DI,8000H	; Number overflowed from 1,111... to 10,000...
	INC	SI		; Bump up Exponent

pub	CHOP53
MSK53:				; Mask off insignificant bits
	XOR	BP,BP
	XOR	DL,DL		; Note: The garbage in DH was masked off at ROUND53
	JMP	EXACT

PAGE

pub	OVER			    ; Here if number overflowed
MOVER:		; The masked response to rounding depends on whether rounding
		;  is directed or not.	If it is then Overflow flag is not set
		;  but precision is. Also the result is set to Inf or Biggest
		;  If rounding is not directed then Overflow is set and result
		;  is set to Inf.

	OR	[CURerr],Overflow
	MOV	AL,[CWcntl]
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	JC	short MOvDNorCHP

	SHR	AL,1
	JC	short MOvUP

MOvNEAR:	; Masked Overflow Near Rounding

pub	SignedInfinity			; Return signed infinity

	MOV	esi,offset IEEEinfinity
	CALL	csMOVRQQ
	MOV	Flag[edi],AH		 ; Overstore the proper sign
	RET

pub	MOvDNorCHP
	SHR	AL,1
	JC	short MOvCHOP

pub	MOvDOWN 			; Masked Overflow Down Rounding
	OR	[CURerr],Precision
	TEST	AH,Sign 		; Positive goes to biggest
	JNZ	short SignedInfinity

MOvCHOP:	; Masked Overflow Chop Rounding
pub	SignedBiggest
	MOV	esi,offset IEEEbiggest
	CALL	csMOVRQQ
	MOV	Flag[edi],AH		 ; Overstore the proper sign
	RET

pub	MOvUP				; Masked Overflow Up Rounding
	OR	[CURerr],Precision
	TEST	AH,Sign 		; Negative goes to biggest
	JZ	short SignedInfinity
	JMP	SignedBiggest

ProfEnd  NORMAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emnew.asm ===
page	,132
	subttl	emnew - emulator new instruction support
;***
;emnew.asm - emulator new instruction support
;
;	Copyright (c) 1985-89, Microsoft Corporation
;
;Purpose:
;	Emulator new instruction support
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

ProfBegin NEW

;***	eFFREE - emulate FFREE ST(i)
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m is register to free
;
;	DESCRIPTION
;		This routine assumes that the register being freed is
;		either at the top or the bottom of the floating point
;		stack.	This is consistent with its use by the cmerge
;		compiler.  If ST(i) is valid, all registers from ST(0)
;		to ST(i-1) are moved down one position in the stack,
;		eliminating ST(i).  [CURstk] is moved to the new location
;		of ST(0).
;
;	REGISTERS
;		modifies si,di,dx

pub	eFFREE
	call	RegAddr 	; di <== address of ST(i)
				; carry set if invalid register
	jnc	short validSTi	; ok, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	; set stack underflow/invalid and exit

validSTi:
	mov	esi,edi 	; si <== address of ST(i)
MovLoop:
	add	esi,Reg87Len	; si <== address of ST(i-1)
	cmp	esi,[CURstk]	; source addr <= top of stack?
	jg	short SetCURstk ; set [CURstk] and exit
	call	MOVRQQ		; ST(j) <== ST(j-1)
	add	edi,Reg87Len	; move dest ptr to next stack entry
	jmp	short MovLoop	; continue moving register entries

SetCURstk:
	sub	edi,Reg87Len	; di points to new location of ST(0)
	mov	[CURstk],edi	; set new top of stack ptr
	ret

;***	eFXCHG - emulate FXCH ST(i)
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m is the source register
;
;	DESCRIPTION
;		exchange ST(i) and ST(0) as follows:
;			temp <== ST(0); ST(0) <== ST(i); ST(i) <== temp
;		indicate stack underflow error if ST(i) does not exist
;
;	REGISTERS
;		modifies ax,es,si,di,dx,cx,bx

pub	eFXCHG
	test	cx,01c00h	;test for ST(i) == ST(0)
	jz	short fxchRet	;fxch ST(0),ST(0) is a nop
	mov	ax,ds
	mov	es,ax		;set es == ds
	call	RegAddr 	;di points to ST(i), si points to ST(0)
				;carry set if invalid register
	jnc	short okReg	;ok, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	;give stack underflow/invalid error

okReg:
	mov	ecx,6			;loop counter
WordSwap:				;exchange a word of ST(0) and ST(i)
	mov	ax,[esi]		;ax <== [si]
	mov	bx,[edi]		;bx <== [di]
	stos	word ptr es:[edi]	;[(di++)] <== ax
	mov	[esi],bx		;[si] <== bx
	inc	esi
	inc	esi			;si++
	loop	WordSwap		;exchange the six words of ST(0), ST(i)
fxchRet:
	ret

;***	eFLDreg - emulate FLD ST(i)
;
;	ARGUMENTS
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;		r/m is the source register
;
;	DESCRIPTION
;		allocate new ST(0) and copy ST(i) into it
;		indicate stack underflow error if ST(i) does not exist
;
;	REGISTERS
;		modifies ax,di,si

pub	eFLDreg
	call	RegAddr 	;di <== address of ST(i), si points to ST(0)
				;carry set if invalid register
	jnc	short okSTi	;yes, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	;stack underflow, invalid operation

okSTi:
	PUSHST			;allocate new TOS
	mov	ax,ds
	mov	es,ax		;set ES == DS
	xchg	esi,edi 	;si = source , di = destination
	call	MOVRQQ		;move ST(i) to new ST(0)
	ret

;***	eFST_Preg - emulate FST ST(i) and FSTP ST(i)
;
;	ARGUMENTS
;		AX = 0 if FST ST(i)
;		     1 if FSTP ST(i)
;		CX = |Op|r/m|MOD|esc|MF|Arith|
;			(except bit 2 of cl is toggled)
;		r/m is the source register
;
;	DESCRIPTION
;		move contents of ST(0) to ST(i).  If ax <> 0 pop stack
;		after transfer.
;
;	REGISTERS
;		modifies si,di,dx

pub	eFST_Preg
	test	cx,01c0h	;test for ST(i) == ST(0)
	jz	short FSTRet	;pop stack and return
	call	RegAddr 	;di <== address of ST(i), si points to ST(0)
				;carry set if invalid register
	jnc	short ValidReg	;yes, continue
	pop	edx		; toss return address
	jmp	InvalidOperand	;no, indicate stack underflow/invalid

ValidReg:
	mov	dx,ds
	mov	es,dx		;set es == ds
	call	MOVRQQ		;ST(i) <== ST(0)

FSTRet:
	or	ax,ax		;FST ST(i) or FSTP ST(i)?
	jz	short NoPOP	;FST ST(i) - don't pop the stack
	POPST			;pop the 8087 stack
NoPOP:
	ret


ProfEnd  NEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emoemqp.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
title	emoem.asm - OEM dependent code for 8087

;--------------------------------------------------------------------
;
;	OEM customization routines for 8087/80287 coprocessor
;
;	This module is designed to work with the following
;	Microsoft language releases:
;
;		Microsoft C 3.00 and later
;		Microsoft FORTRAN 77 3.30 and later
;		Microsoft Pascal 3.30 and later
;
;	This module supersedes the OEMR7.ASM module used in earlier
;	versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;	provided with the FORTRAN and Pascal releases refers to the old
;	OEMR7.ASM module and is only slightly relevant to this module.
;
;	The following routines need to be written to properly handle the
;	8087/808287 installation, termination, and interrupt handler
;
;	__FPINSTALL87		install 8087 interrupt handler
;	__FPTERMINATE87 	deinstall 8087 interrupt handler
;	__fpintreset		reset OEM hardware if an 8087 interrupt
;
;	*****  NEW INSTRUCTIONS  *****
;
;	If you want a PC clone version, do nothing.  The libraries are
;	setup for working on IBM PC's and clones.
;
;	These instructions only need to be followed if a non-IBM PC
;	clone version is desired.
;
;	This module should be assembled with the
;	Microsoft Macro Assembler Version 4.00 or later as follows:
;
;		masm -DOEM -r emoem.asm;
;
;	Most hardware handles the 8087/80287 in one of the following
;	three ways -
;
;	1.	NMI - IBM PC and clones all handle the interrupt this way
;	2.	single 8259
;	3.	master/slave 8259
;
;	Manufacturer specific initialization is supported for these 3
;	machine configurations either by modifying this file and replacing
;	the existing EMOEM module in the math libraries or by patching
;	the .LIB and .EXE files directly.
;
;		LIB 87-+EMOEM;
;		LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef	OEM
if1
	%out	OEM version for non-clone support
endif
endif

;---------------------------------------------------------------------
;	Assembly constants.
;---------------------------------------------------------------------

; MS-DOS OS calls

   OPSYS	EQU	21H
   SETVECOP	EQU	25H
   GETVECOP	EQU	35H
   DOSVERSION	EQU	30h
ifndef	_NOCTRLC
   CTLCVEC	EQU	23h
endif	;_NOCTRLC

DATA   segment word public
assume	ds:DATA

;	User may place data here if DS is setup properly.
;	Recommend keeping the data items in the code segment.

DATA   ends



CODE   segment word public
assume	cs:CODE

	public	__FPINSTALL87		; DO NOT CHANGE THE CASE ON
	public	__FPTERMINATE87 	; THESE PUBLIC DEFINITIONS

	extrn	__FPEXCEPTION87:near	; DO NOT CHANGE CASE


ifdef	_NO87INSTALL	; install/terminate routines for NO87 case for QuickC

	public	__FPINSTALLNO87	
	public	__FPTERMINATENO87

endif	;_NO87INSTALL


ifdef	OEM

;***********************************************************************
;
; Hardware dependent parameters in the 8087 exception handler.
;
; For machines using 2 8259's to handle the 8087 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 8087
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 8087 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum	db	0		; MS-DOS OEM number (IBM is 00h)
intnum	db	2		; IBM PC clone interrupt number
share	db	0		; nonzero if original vector should be taken
a8259	dw	0		; 1st 8259 (A0=0) port #
aocw2	db	0		; 1st 8259 (A0=0) EOI command
b8259	dw	0		; 2nd 8259 (A0=0) port #
bocw2	db	0		; 2nd 8259 (A0=0) EOI command
a8259m	dw	0		; 1st 8259 (A0=1) port #
aocw1m	db	0		; 1st 8259 (A0=1) value to mask against IMR
b8259m	dw	0		; 2nd 8259 (A0=1) port #
bocw1m	db	0		; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;	OEM specific 8087 information
;
;	If the OEM number returned from the DOS version call matches,
;	this information is automatically moved into the oem struc below.

oemtab	label	byte	; Table of OEM specific values for 8087

;		OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db	0	; end of table

;	Unique pattern that can be searched for with the debugger so that
;	.LIB or .EXE files can be patched with the correct values.
;	If new values are patched into .LIB or .EXE files, care must be
;	taken in insure the values are correct.  In particular, words and
;	bytes are intermixed in oeminfo structure.  Remember words are
;	stored low byte - high byte in memory on the 8086 family.

	db	'<<8087>>'	; older versions used '<8087>'

;	Some manufacturer's machines can not be differentiated by the
;	OEM number returned by the MS-DOS version check system call.
;	For these machines it is necessary to replace the line below

oem1	oeminfo <>		; default values for IBM PC & clones

;	with one of the following.  If your machine has an 8087 capability
;	and it is not in the list below, you should contact your hardware
;	manufacturer for the necessary information.

;ACT Apricot
;oem1	 oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1	 oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

aoldIMR 	db	0	; 1st 8259 original IMR value
boldIMR 	db	0	; 2nd 8259 original IMR value

endif	;OEM

statwd		dw	0	; Temporary for status word
oldvec		dd	0	; Old value in 8087 exception interrupt vector
ifndef	_NOCTRLC
ctlc		dd	0	; Old value of Control-C vector (INT 23h)
endif	;_NOCTRLC

page

;---------------------------------------------------------------------
;
;	Perform OEM specific initialization of the 8087.
;

__FPINSTALL87:
	push	ds			; DS = EMULATOR_DATA

	push	cs			; Move current CS to DS for opsys calls.
	pop	ds
assume	ds:CODE

ifdef	OEM
	push	ds
	pop	es			; CS = DS = ES
	mov	ah,DOSVERSION
	int	OPSYS			; bh = OEM#
	cld
	mov	si,offset oemtab	; start of OEM 8087 info table
	mov	di,offset oem1+1
	mov	cx,(size oem1)-1
OEMloop:
	lodsb				; get OEM#
	or	al,al
	jz	OEMdone 		; OEM# = 0 - did not find OEM
	cmp	al,bh			; correct OEM#
	je	OEMfound
	add	si,cx			; skip over OEM information
	jmp	OEMloop

OEMfound:
	rep	movsb			; move the information

OEMdone:				; done with automatic customization
endif	;OEM

; Save old interrupt vector.
; Ask operating system for vector.

ifdef  WINDOWS
	mov	ax, word ptr [oldvec]
	or	ax, word ptr [oldvec+2]
	jnz	SetVector
endif	;WINDOWS

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.

	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

SetVector:
	mov	dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

ifndef	_NOCTRLC
; Intercept Control-C vector to guarentee cleanup

	mov	ax,GETVECOP shl 8 + CTLCVEC
	int	OPSYS
	mov	word ptr [ctlc],bx
	mov	word ptr [ctlc+2],es
	mov	dx,offset ctlcexit
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
endif	;_NOCTRLC

ifdef	OEM

;	set up 8259's so that 8087 interrupts are enabled

	mov	ah,[oem1].aocw1m 	; get mask for 1st 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;   and only 1 8259
	mov	dx,[oem1].a8259m 	; get port number for 1st 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[aoldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

	mov	ah,[oem1].bocw1m 	; get mask for 2nd 8259 IMR
	or	ah,ah			;   if 0, don't need to do this
	jz	installdone		;
	mov	dx,[oem1].b8259m 	; get port number for 2nd 8259 (A0=1)
	in	al,dx			; read old IMR value
	mov	[boldIMR],al		; save it to restore at termination
	and	al,ah			; mask to enable interrupt
	jmp	short $+2		; for 286's
	out	dx,al			; write out new mask value

installdone:

endif	;OEM

assume	ds:DATA
	pop	ds
	ret


page
;	__FPTERMINATE87
;
;	This routine should do the OEM 8087 cleanup.  This routine is called
;	before the program exits.
;
;	DS = EMULATOR_DATA

__FPTERMINATE87:
	push	ds
	push	ax
	push	dx

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
	int	OPSYS

ifdef	OEM

;	reset 8259 IMR's to original state

	push	cs
	pop	ds			; DS = CS
assume	ds:CODE
	cmp	[oem1].aocw1m,0		; did we have to change 1st 8259 IMR
	je	term2nd8259		;   no - check 2nd 8259
	mov	al,[aoldIMR]		; get old IMR
	mov	dx,[oem1].a8259m 	; get 1st 8259 (A0=1) port #
	out	dx,al			; restore IMR

term2nd8259:
	cmp	[oem1].bocw1m,0		; did we have to change 2nd 8259 IMR
	je	terminatedone		;   no
	mov	al,[boldIMR]		; get old IMR
	mov	dx,[oem1].b8259m 	; get 2nd 8259 (A0=1) port #
	out	dx,al			; restore IMR

terminatedone:

endif	;OEM

	pop	dx
	pop	ax
	pop	ds
assume	ds:DATA
	ret


;	Forced cleanup of 8087 exception handling on Control-C

ifndef	_NOCTRLC
ctlcexit:
	push	ax
	push	dx
	push	ds
	call	__FPTERMINATE87 	; forced cleanup of exception handler
	lds	dx,[ctlc]		; load old control C vector
	mov	ax,SETVECOP shl 8 + CTLCVEC
	int	OPSYS
	pop	ds
	pop	dx
	pop	ax
	jmp	[ctlc]			; go through old vector
endif	;_NOCTRLC

page
;	__fpinterrupt87
;
;	This is the 8087 exception interrupt routine.
;
;	All OEM specific interrupt and harware handling should be done in
;	__fpintreset because __FPEXCEPTION87 (the OEM independent 8087
;	exception handler) may not return.  __FPEXCEPTION87 also turns
;	interrupts back on.
;

PENDINGBIT=	80h		; Bit in status word for interrupt pending

__fpinterrupt87:
assume	ds:nothing
	nop
	fnstsw	[statwd]	; Store out exceptions
	push	cx		; waste time
	mov	cx,3
self:
	loop	self
	pop	cx
	test	byte ptr [statwd],PENDINGBIT	; Test for 8087 interrupt
	jz	not87int	; Not an 8087 interrupt.

ifdef	OEM
	call	__fpintreset	; OEM interrupt reset routine
endif	;OEM

	call	__FPEXCEPTION87 ; 8087 error handling - may not return
				; this routine turns interrupts back on

ifdef	OEM
	cmp	[oem1].share,0	; Should we execute the old interrupt routine?
	jnz	not87int	;    if so then do it
				;    else return from interrupt

;	If you fall through here to do further hardware resetting, things
;	may not always work because __FPEXCEPTION87 does not always return
;	This only happens when the 8087 handler gets an exception that is
;	a fatal error in the language runtimes.  I.e., divide by zero
;	is a fatal error in all the languages, unless the control word has
;	set to mask out divide by zero errors.

endif	;OEM

done8087:
	iret

not87int:
	jmp	[oldvec]	; We should never return from here.


ifdef	OEM


__fpintreset:
	push	ax
	push	dx
	mov	al,[oem1].aocw2	; Load up EOI instruction.
	or	al,al		; Is there at least one 8259 to be reset?
	jz	Reset8259ret	; no
	mov	dx,[oem1].a8259
	out	dx,al		; Reset (master) 8259 interrupt controller.
	mov	al,[oem1].bocw2	; Load up EOI instruction.
	or	al,al		; Is there a slave 8259 to be reset?
	jz	Reset8259ret
	mov	dx,[oem1].b8259
	out	dx,al		; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop	dx
	pop	ax
	ret

endif	;OEM

ifdef	_NO87INSTALL
__FPINSTALLNO87:
	push	bx
	push	es
	push	ax
	push	dx
	push	ds

	mov	ax,cs			; Move current CS to DS for opsys calls.
	mov	ds,ax
assume	ds:CODE
	
; Save old interrupt vector.
; Ask operating system for vector.

ifdef	OEM
	mov	al,[oem1].intnum 	; Interrupt vector number.
	mov	ah,GETVECOP		; Operating system call interrupt.
else
	mov	ax,GETVECOP shl 8 + 2	; get interrupt vector 2
endif	;OEM
	int	OPSYS			; Call operating system.
	mov	word ptr [oldvec],bx	; Squirrel away old vector.
	mov	word ptr [oldvec+2],es

; Have operating system install interrupt vectors.

	mov	dx,offset __fpinterruptno87 ; Load DX with fake 8087 interrupt handler.
ifdef	OEM
	mov	ah,SETVECOP		; Set interrupt vector code in AH.
	mov	al,[oem1].intnum 	; Set vector number.
else
	mov	ax,SETVECOP shl 8 + 2	; set interrupt vector 2
endif	;OEM
	int	OPSYS			; Install vector.

	pop	ds
assume	ds:nothing
	pop	dx
	pop	ax
	pop	es
	pop	bx
	
	ret

__fpinterruptno87:
	jmp	[oldvec]		; will use CS: override

__FPTERMINATENO87:
	push	ds
	push	ax
	push	dx

	mov	ax,cs
	mov	ds,ax
assume	ds:CODE

ifdef	OEM
	mov	ah,SETVECOP
	mov	al,[oem1].intnum
else
	mov	ax,SETVECOP shl 8 + 2
endif	;OEM
	lds	dx,[oldvec]
assume	ds:nothing
	int	OPSYS

	pop	dx
	pop	ax
	pop	ds

	ret

endif	;_NO87INSTALL

CODE   ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emoemwin.asm ===
;
;
;       Copyright (C) Microsoft Corporation, 1987-89
;
;       This Module contains Proprietary Information of Microsoft
;       Corporation and should be treated as Confidential.
;
title   emoem.asm - OEM dependent code for 8087

;--------------------------------------------------------------------
;
;       OEM customization routines for 8087/80287 coprocessor
;
;       This module is designed to work with the following
;       Microsoft language releases:
;
;               Microsoft C 3.00 and later
;               Microsoft FORTRAN 77 3.30 and later
;               Microsoft Pascal 3.30 and later
;
;       This module supersedes the OEMR7.ASM module used in earlier
;       versions of Microsoft FORTRAN 77 and Pascal.  The documentation
;       provided with the FORTRAN and Pascal releases refers to the old
;       OEMR7.ASM module and is only slightly relevant to this module.
;
;       The following routines need to be written to properly handle the
;       8087/808287 installation, termination, and interrupt handler
;
;       __FPINSTALL87           install 8087 interrupt handler
;       __FPTERMINATE87         deinstall 8087 interrupt handler
;       __fpintreset            reset OEM hardware if an 8087 interrupt
;
;       *****  NEW INSTRUCTIONS  *****
;
;       If you want a PC clone version, do nothing.  The libraries are
;       setup for working on IBM PC's and clones.
;
;       These instructions only need to be followed if a non-IBM PC
;       clone version is desired.
;
;       This module should be assembled with the
;       Microsoft Macro Assembler Version 4.00 or later as follows:
;
;               masm -DOEM -r emoem.asm;
;
;       Most hardware handles the 8087/80287 in one of the following
;       three ways -
;
;       1.      NMI - IBM PC and clones all handle the interrupt this way
;       2.      single 8259
;       3.      master/slave 8259
;
;       Manufacturer specific initialization is supported for these 3
;       machine configurations either by modifying this file and replacing
;       the existing EMOEM module in the math libraries or by patching
;       the .LIB and .EXE files directly.
;
;               LIB 87-+EMOEM;
;               LIB EM-+EMOEM;
;
;--------------------------------------------------------------------

ifdef   OEM
if1
	%out    OEM version for non-clone support
endif
endif

;---------------------------------------------------------------------
;       Assembly constants.
;---------------------------------------------------------------------

NULL_JMP    macro
	jmp     $+2
	endm

WASTE_TIME  macro   count
	local   WasteLoop

	push    cx
ifnb  <count>
	mov     cx, count
else
	mov     cx, 10h
endif
WasteLoop:
	push    ax
	pop     ax

	loop    WasteLoop
	pop     cx

	endm


; MS-DOS OS calls

   OPSYS        EQU     21H
   SETVECOP     EQU     25H
   GETVECOP     EQU     35H
   DOSVERSION   EQU     30h
ifndef  _NOCTRLC
   CTLCVEC      EQU     23h
endif   ;_NOCTRLC

extrn __WINFLAGS:abs
WF_PMODE    equ     1
WF_CPU286   equ     2
WF_CPU386   equ     4
WF_WIN286   equ     10h
WF_WIN386   equ     20h

EMULATOR_DATA   segment para public 'FAR_DATA'
assume  ds:EMULATOR_DATA

;       User may place data here if DS is setup properly.
;       Recommend keeping the data items in the code segment.


ifdef  OEM
extrn  aoldIMR:byte             ; 1st 8259 original IMR value
extrn  boldIMR:byte             ; 2nd 8259 original IMR value
endif   ;OEM


extrn  OldNMIVec:dword          ; Old value in 8087 exception interrupt vector

ifndef  _NOCTRLC
extrn  ctlc:dword               ; Old value of Control-C vector (INT 23h)
endif   ;_NOCTRLC


EMULATOR_DATA   ends



EMULATOR_TEXT   segment para public 'CODE'
assume  cs:EMULATOR_TEXT

	public  __FPINSTALL87           ; DO NOT CHANGE THE CASE ON
	public  __FPTERMINATE87         ; THESE PUBLIC DEFINITIONS

	extrn   __FPEXCEPTION87:near    ; DO NOT CHANGE CASE
	extrn   __FPEXCEPTION87P:near


ifdef   _NO87INSTALL    ; install/terminate routines for NO87 case for QuickC

	public  __FPINSTALLNO87 
	public  __FPTERMINATENO87

endif   ;_NO87INSTALL


ifdef   OEM

;***********************************************************************
;
; Hardware dependent parameters in the 8087 exception handler.
;
; For machines using 2 8259's to handle the 8087 exception, be sure that
; the slave 8259 is the 1st below and the master is the 2nd.
;
; The last 4 fields allow you to enable extra interrupt lines into the
; 8259s.  It should only be necessary to use these fields if the 8087
; interrupt is being masked out by the 8259 PIC.
;
; The ocw2's (EOI commands) can be either non-specific (20H) or
; specific (6xH where x=0 to 7).  If you do not know which interrupt
; request line on the 8259 the 8087 exception uses, then you should issue
; the non-specific EOI (20H).  Interrupts are off at this point in the
; interrupt handler so a higher priority interrupt will not be seen.

oeminfo struc
oemnum  db      0               ; MS-DOS OEM number (IBM is 00h)
intnum  db      2               ; IBM PC clone interrupt number
share   db      0               ; nonzero if original vector should be taken
a8259   dw      0               ; 1st 8259 (A0=0) port #
aocw2   db      0               ; 1st 8259 (A0=0) EOI command
b8259   dw      0               ; 2nd 8259 (A0=0) port #
bocw2   db      0               ; 2nd 8259 (A0=0) EOI command
a8259m  dw      0               ; 1st 8259 (A0=1) port #
aocw1m  db      0               ; 1st 8259 (A0=1) value to mask against IMR
b8259m  dw      0               ; 2nd 8259 (A0=1) port #
bocw1m  db      0               ; 2nd 8259 (A0=1) value to mask against IMR
oeminfo ends

;-----------------------------------------------------------------------
;       OEM specific 8087 information
;
;       If the OEM number returned from the DOS version call matches,
;       this information is automatically moved into the oem struc below.

oemtab  label   byte    ; Table of OEM specific values for 8087

;               OEM#, int, shr, a59, acw2,b59, bcw2,a59m,acw1,b59m,bcw1

;TI Professional Computer
TI_prof oeminfo <028h,047h,000h,018h,020h,0000,0000,0000,0000,0000,0000>

	db      0       ; end of table

;       Unique pattern that can be searched for with the debugger so that
;       .LIB or .EXE files can be patched with the correct values.
;       If new values are patched into .LIB or .EXE files, care must be
;       taken in insure the values are correct.  In particular, words and
;       bytes are intermixed in oeminfo structure.  Remember words are
;       stored low byte - high byte in memory on the 8086 family.

	db      '<<8087>>'      ; older versions used '<8087>'

;       Some manufacturer's machines can not be differentiated by the
;       OEM number returned by the MS-DOS version check system call.
;       For these machines it is necessary to replace the line below

oem1    oeminfo <>              ; default values for IBM PC & clones

;       with one of the following.  If your machine has an 8087 capability
;       and it is not in the list below, you should contact your hardware
;       manufacturer for the necessary information.

;ACT Apricot
;oem1    oeminfo <000h,055h,000h,000h,020h,000h,000h,000h,000h,000h,000h>

;NEC APC3 and PC-9801  (OEM number returned by NEC MS-DOS's is different)
;oem1    oeminfo <000h,016h,000h,008h,066h,000h,067h,00Ah,0BFh,002h,07Fh>

;---------------------------------------------------------------------

endif   ;OEM


page

;---------------------------------------------------------------------
;
;       Perform OEM specific initialization of the 8087.
;

__FPINSTALL87:
	push    ds                      ; DS = EMULATOR_DATA


ifdef   OEM
	push    ds
	pop     es                      ; CS = DS = ES
	mov     ah,DOSVERSION
	int     OPSYS                   ; bh = OEM#
	cld
	mov     si,offset oemtab        ; start of OEM 8087 info table
	mov     di,offset oem1+1
	mov     cx,(size oem1)-1
OEMloop:
	lodsb                           ; get OEM#
	or      al,al
	jz      OEMdone                 ; OEM# = 0 - did not find OEM
	cmp     al,bh                   ; correct OEM#
	je      OEMfound
	add     si,cx                   ; skip over OEM information
	jmp     OEMloop

OEMfound:
	rep     movsb                   ; move the information

OEMdone:                                ; done with automatic customization
endif   ;OEM

; Save old interrupt vector.
; Ask operating system for vector.

ifdef  WINDOWS
	mov     ax, word ptr [OldNMIVec]
	or      ax, word ptr [OldNMIVec+2]
	jnz     SetVector
endif   ;WINDOWS

ifdef   OEM
	mov     al,[oem1].intnum        ; Interrupt vector number.
	mov     ah,GETVECOP             ; Operating system call interrupt.
else
	mov     ax,GETVECOP shl 8 + 2   ; get interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Call operating system.

	mov     word ptr [OldNMIVec],bx ; Squirrel away old vector.
	mov     word ptr [OldNMIVec+2],es

; Have operating system install interrupt vectors.

SetVector:
	push    cs                      ; Move current CS to DS for opsys calls.
	pop     ds
assume  ds:EMULATOR_TEXT

	mov     dx,offset __fpinterrupt87 ; Load DX with 8087 interrupt handler.
ifdef   OEM
	mov     ah,SETVECOP             ; Set interrupt vector code in AH.
	mov     al,[oem1].intnum        ; Set vector number.
else
	mov     ax,SETVECOP shl 8 + 2   ; set interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Install vector.

	mov     ax, __WINFLAGS
	test    ax, WF_PMODE
	jz      SkipSettingIRQ13

	.286p
	.287
	fsetpm                          ; set PM just in case Windows didn't.
	.8086
	.8087

	push    cs
	pop     ds                       ; Move current CS to DS for opsys calls.
assume  ds:EMULATOR_TEXT
	mov     dx, offset __fpIRQ13     ; Load DX with IRQ 13 interrupt handler.
	mov     ax, SETVECOP shl 8 + 75h ; set interrupt vector 75h
	int     OPSYS                    ; Install vector.
SkipSettingIRQ13:

ifndef  _NOCTRLC
; Intercept Control-C vector to guarentee cleanup

	mov     ax,GETVECOP shl 8 + CTLCVEC
	int     OPSYS
	mov     word ptr [ctlc],bx
	mov     word ptr [ctlc+2],es
	mov     dx,offset ctlcexit
	mov     ax,SETVECOP shl 8 + CTLCVEC
	int     OPSYS
endif   ;_NOCTRLC

ifdef   OEM

;       set up 8259's so that 8087 interrupts are enabled

	mov     ah,[oem1].aocw1m        ; get mask for 1st 8259 IMR
	or      ah,ah                   ;   if 0, don't need to do this
	jz      installdone             ;   and only 1 8259
	mov     dx,[oem1].a8259m        ; get port number for 1st 8259 (A0=1)
	in      al,dx                   ; read old IMR value
	mov     [aoldIMR],al            ; save it to restore at termination
	and     al,ah                   ; mask to enable interrupt
	jmp     short $+2               ; for 286's
	out     dx,al                   ; write out new mask value

	mov     ah,[oem1].bocw1m        ; get mask for 2nd 8259 IMR
	or      ah,ah                   ;   if 0, don't need to do this
	jz      installdone             ;
	mov     dx,[oem1].b8259m        ; get port number for 2nd 8259 (A0=1)
	in      al,dx                   ; read old IMR value
	mov     [boldIMR],al            ; save it to restore at termination
	and     al,ah                   ; mask to enable interrupt
	jmp     short $+2               ; for 286's
	out     dx,al                   ; write out new mask value

installdone:

endif   ;OEM

assume  ds:EMULATOR_DATA
	pop     ds
	ret


page
;       __FPTERMINATE87
;
;       This routine should do the OEM 8087 cleanup.  This routine is called
;       before the program exits.
;
;       DS = EMULATOR_DATA

__FPTERMINATE87:
	push    ds
	push    ax
	push    dx

ifdef   OEM
	mov     ah,SETVECOP
	mov     al,[oem1].intnum
else
	mov     ax,SETVECOP shl 8 + 2
endif   ;OEM
	lds     dx,[OldNMIVec]
	int     OPSYS

ifdef   OEM

;       reset 8259 IMR's to original state

	push    cs
	pop     ds                      ; DS = CS
assume  ds:EMULATOR_TEXT
	cmp     [oem1].aocw1m,0         ; did we have to change 1st 8259 IMR
	je      term2nd8259             ;   no - check 2nd 8259
	mov     al,[aoldIMR]            ; get old IMR
	mov     dx,[oem1].a8259m        ; get 1st 8259 (A0=1) port #
	out     dx,al                   ; restore IMR

term2nd8259:
	cmp     [oem1].bocw1m,0         ; did we have to change 2nd 8259 IMR
	je      terminatedone           ;   no
	mov     al,[boldIMR]            ; get old IMR
	mov     dx,[oem1].b8259m        ; get 2nd 8259 (A0=1) port #
	out     dx,al                   ; restore IMR

terminatedone:

endif   ;OEM

	pop     dx
	pop     ax
	pop     ds
assume  ds:EMULATOR_DATA
	ret


;       Forced cleanup of 8087 exception handling on Control-C

ifndef  _NOCTRLC
ctlcexit:
	push    ax
	push    dx
	push    ds
	call    __FPTERMINATE87         ; forced cleanup of exception handler
	lds     dx,[ctlc]               ; load old control C vector
	mov     ax,SETVECOP shl 8 + CTLCVEC
	int     OPSYS
	pop     ds
	pop     dx
	pop     ax
	jmp     [ctlc]                  ; go through old vector
endif   ;_NOCTRLC

page
;       __fpinterrupt87
;
;       This is the 8087 exception interrupt routine.
;
;       All OEM specific interrupt and harware handling should be done in
;       __fpintreset because __FPEXCEPTION87 (the OEM independent 8087
;       exception handler) may not return.  __FPEXCEPTION87 also turns
;       interrupts back on.
;

PENDINGBIT=     80h             ; Bit in status word for interrupt pending

public __fpIRQ13
__fpIRQ13:
	cli

	WASTE_TIME  70

	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	mov     al, 65h
	NULL_JMP
	out     0a0h, al        ; EOI slave irq 5
	NULL_JMP
	mov     al, 62h
	NULL_JMP
	out     20h, al         ; EOI master irq 2
	NULL_JMP
	pop     ax


	sub     sp, 2

	push    bp
	mov     bp, sp

	fnstsw  [bp+2]
	WASTE_TIME
	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	pop     ax

	pop     bp

;       fnclex                  ; 486 bug - must wait till after last
				; "out f0" to clear fp exceptions
				; or IGNNE# will be permanently active.
	WASTE_TIME
	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	pop     ax

;       fnclex                  ; 486 bug - must wait till after last
				; "out f0" to clear fp exceptions
				; or IGNNE# will be permanently active.
	WASTE_TIME
	push    ax
	xor     al, al
	NULL_JMP
	out     0f0h, al        ; reset busy line.
	NULL_JMP
	pop     ax

	fnclex                  ;Now this is safe.
	WASTE_TIME 70           ;Fix timing problem??

	jmp     __FPEXCEPTION87P


public __fpinterrupt87
__fpinterrupt87:
assume  ds:nothing
	nop

	push    bp
	mov     bp, sp
	sub     sp, 2

	fnstsw  word ptr [bp-2]     ; Store out exceptions

	push    cx                  ; waste time
	mov     cx, 3
self:
	loop    self
	pop     cx

	test    byte ptr [bp-2],PENDINGBIT  ; Test for 8087 interrupt

	mov     sp, bp
	pop     bp

	jz      not87int                    ; Not an 8087 interrupt.

ifdef   OEM
	call    __fpintreset    ; OEM interrupt reset routine
endif   ;OEM

	call    __FPEXCEPTION87 ; 8087 error handling - may not return
				; this routine turns interrupts back on

ifdef   OEM
	cmp     [oem1].share,0  ; Should we execute the old interrupt routine?
	jnz     not87int        ;    if so then do it
				;    else return from interrupt

;       If you fall through here to do further hardware resetting, things
;       may not always work because __FPEXCEPTION87 does not always return
;       This only happens when the 8087 handler gets an exception that is
;       a fatal error in the language runtimes.  I.e., divide by zero
;       is a fatal error in all the languages, unless the control word has
;       set to mask out divide by zero errors.

endif   ;OEM

done8087:
	iret

not87int:
	sub     sp, 4

	push    bp
	mov     bp, sp

	push    ds
	push    ax

	mov     ax, EMULATOR_DATA
	mov     ds, ax
	assume  ds:EMULATOR_DATA

	mov     ax, word ptr [OldNMIVec+2]      ; segment of OldNMIVec
	mov     [bp+4], ax

	mov     ax, word ptr [OldNMIVec]        ; offset of OldNMIVec
	mov     [bp+2], ax

	pop     ax
	pop     ds
	mov     sp, bp
	pop     bp

	retf                    ; jmp  [OldNMIVec]. We should not return.


ifdef   OEM


__fpintreset:
	push    ax
	push    dx
	mov     al,[oem1].aocw2 ; Load up EOI instruction.
	or      al,al           ; Is there at least one 8259 to be reset?
	jz      Reset8259ret    ; no
	mov     dx,[oem1].a8259
	out     dx,al           ; Reset (master) 8259 interrupt controller.
	mov     al,[oem1].bocw2 ; Load up EOI instruction.
	or      al,al           ; Is there a slave 8259 to be reset?
	jz      Reset8259ret
	mov     dx,[oem1].b8259
	out     dx,al           ; Reset slave 8259 interrupt controller.

Reset8259ret:
	pop     dx
	pop     ax
	ret

endif   ;OEM

ifdef   _NO87INSTALL
__FPINSTALLNO87:
	push    bx
	push    es
	push    ax
	push    dx
	push    ds

	mov     ax,cs                   ; Move current CS to DS for opsys calls.
	mov     ds,ax
assume  ds:EMULATOR_TEXT  r
	
; Save old interrupt vector.
; Ask operating system for vector.

ifdef   OEM
	mov     al,[oem1].intnum        ; Interrupt vector number.
	mov     ah,GETVECOP             ; Operating system call interrupt.
else
	mov     ax,GETVECOP shl 8 + 2   ; get interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Call operating system.
	mov     word ptr [OldNMIVec],bx ; Squirrel away old vector.
	mov     word ptr [OldNMIVec+2],es

; Have operating system install interrupt vectors.

	mov     dx,offset __fpinterruptno87 ; Load DX with fake 8087 interrupt handler.
ifdef   OEM
	mov     ah,SETVECOP             ; Set interrupt vector code in AH.
	mov     al,[oem1].intnum        ; Set vector number.
else
	mov     ax,SETVECOP shl 8 + 2   ; set interrupt vector 2
endif   ;OEM
	int     OPSYS                   ; Install vector.

	pop     ds
assume  ds:nothing
	pop     dx
	pop     ax
	pop     es
	pop     bx
	
	ret

__fpinterruptno87:
	jmp     [OldNMIVec]             ; will use CS: override

__FPTERMINATENO87:
	push    ds
	push    ax
	push    dx

	mov     ax,cs
	mov     ds,ax
assume  ds:EMULATOR_TEXT

ifdef   OEM
	mov     ah,SETVECOP
	mov     al,[oem1].intnum
else
	mov     ax,SETVECOP shl 8 + 2
endif   ;OEM
	lds     dx,[OldNMIVec]
assume  ds:nothing
	int     OPSYS

	pop     dx
	pop     ax
	pop     ds

	ret

endif   ;_NO87INSTALL

EMULATOR_TEXT   ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emstack.asm ===
page	,132
	subttl	emstack.asm - Emulator Stack Management Area
;***
;emstack.asm - Emulator Stack Management Area
;
;	Copyright (c) 1986-89, Microsoft Corporation
;
;Purpose:
;	Emulator Stack Management Area
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin STACK


;*********************************************************************;
;								      ;
;		    Emulator Stack Management Area		      ;
;								      ;
;*********************************************************************;

; The emulator maintains an "finite" stack of 12 byte registers.

; Stand-alone emulator has 1 chunk only.

; This is done using a list of finite length stack chunks, each of
; which has the following format:
;      +00   first (deepest) 12 byte register
;      +12   next 12 byte register
;	     (and so on through last possible register)


; MACROS used to manipulate the emulator/8087 memory stack


; This macro allocates a new TOS register, returns SI with its address.

PUSHST	MACRO
	local	pushstok
	mov	esi,[CURstk]	; 14 get address of current register
	cmp	esi,[LIMstk]	; 15 is current register end of stack
	jne	short pushstok	; 16 no, still room in stack
	call	OverStk 	;    stack overflow error
pushstok:
	add	esi,Reg87Len	;  4 increment SI to next free register
	mov	[CURstk],esi	; 15 set current top of stack
	ENDM			; 64 total


; This macro deallocates TOS register, returns SI with new TOS address.
; Note:  assumes SI contains TOS address, CURstk
; BASstk converted back to a variable to enable macro use for 8087 stack
; handling.  Brad Verheiden, 4-13-84.

POPSTsi MACRO
	local	popstok
	cmp	esi,[BASstk]		   ; 15 was it last register in the chunk ?
	jnz	short popstok		   ; 16 no, still room in current chunk
	call	UnderStk		   ;	stack underflow error
popstok:
	sub	esi,Reg87Len		   ;  4 decrement SI to previous register
	mov	[CURstk],esi		   ; 15 set current top of stack
	ENDM				   ; 64 total

POPST	MACRO
	mov	esi,[CURstk]
	POPSTsi
	ENDM


ChangeDIfromTOStoNOS	MACRO
	sub	edi,Reg87Len
	ENDM


page
; This area contains two procedures, OverStk and UnderStk,
; which generate a stack overflow error.

; OverStk:   invoked within PUSHST macro
;   on entry, the stack is full
;   on return, SI contains address of base of stack

; UnderStk:  invoked within POPST macro
;   on entry, the stack is empty
;   on return, SI contains address of base of stack

pub	OverStk
	OR	byte ptr [CURerr+1],StackOverflow/256 ; raise stack overflow
	CMP	[Have8087],0		; Is 8087 present
	JZ	short OverStkEnd	; No - don't touch AX
	OR	AH,StackOverflow/256	; Indicate memory overflow for 8087

pub	OverStkEnd
	RET				; finished

pub	UnderStk
	OR	byte ptr [CURerr+1],StackUnderflow/256 ; raise stack underflow
	RET				; finished

ProfEnd  STACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emthread.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1987
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emthread.asm - Emulator multi-thread support for OS/2
page


thread1static=1		; set DS = EMULATOR_DATA for thread 1
			; dynamically allocate data areas for other threads

_DATA	segment	word public 'DATA'
_DATA	ends

DGROUP	group _DATA

_DATA	segment	word public 'DATA'
	extrn	__FPDSARRAY:WORD

	ifdef	i386
		extrn	__threadid:FWORD	; far pointer to ???? thread id
	else
		extrn	__threadid:DWORD	; far pointer to WORD thread id
	endif	
_DATA	ends

dataoffset equ offset DGROUP:

include	os2dll.inc			; defines _SIGNAL_LOCK
					; and other lock values;
					; must be synchronized with
					; \clib\include\86\os2dll.inc
					; and \clib\include\os2dll.h
extrn __lockf:FAR
extrn __unlockf:FAR

LOAD_DS_EDI	macro
		local	TIDOk, LoadDone
;
;	loads ds:edi with far pointer to thread's DS selector
;	(pointer into __FPDSARRAY)
;
;	uses eax,edi,es,ds
;
;	sets eax = 2 * (thread id)
;

	mov	ax,DGROUP
	mov	ds,ax			; set DS = DGROUP temporarily
	assume 	ds:DGROUP
	les	edi,[__threadid]	; ES:eDI = far pointer to thread id
	mov	ax,es:[edi]		; AX = thread id (far ptr to WORD)

	cmp	ax, MAXTHREADID
	jbe	TIDOk

	push	ax
	call	LoadDS_EDI
	pop	ax
	shl	ax, 1			; thread id times 2
	jmp	short LoadDone

TIDOk:
	shl	eax,1			; thread id times 2
	mov	edi,dataoffset __FPDSARRAY
	add	edi,eax			; index into __FPDSARRAY 
LoadDone:
	endm


LOADthreadDS	macro
;
; loads thread's DS from __FPDSARRAY indexed by thread id 
; preserves all registers except DS and eAX
;
; __FPDSARRAY[0] = MAXTHREAD
; __FPDSARRAY[i] = emulator DS for thread i, 1<=i<=MAXTHREAD
;
	push	edi			; save eDI
	push	es			; save ES

	LOAD_DS_EDI			; get pointer (ds:edi) to thread's DS
	
	mov	ds,ds:[edi]		; set up DS to thread's data area
	assume 	ds:EMULATOR_DATA 	; or dynamically allocated copy

	pop	es
	pop	edi			; restore DI
	endm

ALLOCthreadDS	macro
pub	allocperthread
	LOAD_DS_EDI			; get pointer into __FPDSARRAY
; eAX = 2 * (thread_id)
ifdef	thread1static
;
; for thread 1, use EMULATOR_DATA segment
;
	cmp	eax,2			; thread 1?
	jnz	allocds			;  no - dynamically allocate DS
	mov	ax,EMULATOR_DATA	;  yes - use static area
	mov 	ds:[edi],ax		; store new DS into __FPDSARRAY 
	mov	ds,ax
	assume	ds:EMULATOR_DATA	; or dynamically allocated copy
	mov	es,ax			; ES = DS = EMULATOR_DATA
	jmp	allocdone
else	
	jmp	allocds
endif	;thread1static

pub	allocerror
	mov	ax,-3			; return allocation error
	stc
	ret
;
ifdef	thread1static
; for threads other than thread 1, allocate new DS from the system
else
; for all threads, allocate new DS from the system
endif
;

pub	allocds
	assume	ds:DGROUP
	push	offset __fptaskdata	; size of per-thread data area
	push	ds			; ds:di = addr of thread's DS
	push	edi
	push	0			; non-shared segment
	os2call	DOSALLOCSEG	

	or	ax,ax			; allocation error?
	jnz	allocerror		;  yes - cause thread init to fail

	mov	di,ds:[edi]		; set ES = DS = thread's data selector 
	mov	ds,di			
	mov	es,di		
	assume 	ds:EMULATOR_DATA 	; or dynamically allocated copy

pub	allocdone
;
; ES = DS = selector for emulator data area
;
	mov	edx,offset __fptaskdata	; dx = size of emulator data area
	sub	edx,offset EMULATOR_DATA; jwm

	xor	ax,ax			; prepare to zero out data segment
	xor	edi,edi			; start at offset zero 
	mov	edi,offset EMULATOR_DATA; jwm : begin at the beginning

	mov	ecx,edx			; cx = size of segment (even)
	shr	ecx,1			; halve it
	rep	stosw			; zero it!
	endm

FREEthreadDS	macro
pub	freeperthread
	assume	ds:EMULATOR_DATA	; or dynamically allocated copy
ifdef	thread1static
 	mov	ax,ds
 	cmp	ax,EMULATOR_DATA	; don't free thread 1's area
 	je	nofreeseg
endif	;thread1static
 
	push	ds
	os2call	DOSFREESEG		; free per-thread emulator data area

nofreeseg:
	LOAD_DS_EDI			; get pointer into __FPDSARRAY
	mov	word ptr ds:[edi],0	; zero out __FPDSARRAY element
					; for the current thread
	assume 	ds:EMULATOR_DATA 	
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emulator.asm ===
page	,132
	title	emulator - 8087/287 emulator for MS-DOS, XENIX, OS/2, Windows
;*** 
;emulator.asm -  8087/287 emulator for MS-DOS, XENIX, OS/2, Windows
;
;	Copyright (c) 1984-89, Microsoft Corporation
;
;Purpose:
;	8087/287 emulator for MS-DOS, XENIX, OS/2, Windows
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

	include  emulator.hst	    ; Emulator history file.


major_ver   equ     6
minor_ver   equ     0

fastSP = 0			    ; default to no fast single precision


;*******************************************************************************
;
;   Print out emulator version.
;
;*******************************************************************************


OutMsg	macro	text
    ifndef  ?QUIET
	%out text
    endif
	endm


outver	macro	maj,tens,hunds
	OutMsg	<Emulator Version maj&.&tens&hunds>
	endm


if1

    outver  %major_ver,%(minor_ver/10),%(minor_ver mod 10)

    ifdef WINDOWS
	OutMsg	<Windows 2.00 Emulator>
    endif

    ifdef QB3
	OutMsg	<QuickBASIC 3.00 Emulator>
    endif

    ifdef _NOSTKEXCHLR				; formerly called QB4
	OutMsg	<No stack overflow/underflow hadler.>
    endif

    ifdef PCDOS
	OutMsg	<IBM PC-DOS version - Uses int 11h BIOS equipment check.>
    endif

    ifdef MTHREAD
	ifdef DOS5only
	    OutMsg  <Reentrant multithread OS/2 emulator.>
	else
	    %out  *** Error: MTHREAD supported only if DOS5only defined.
	endif
    endif

    ifdef  SQL_EMMT
	ifdef  MTHREAD
	    OutMsg  <Special SQL version.>
	else
	    %out  *** Error: SQL supported only if MTHREAD is defined.
	endif
    endif

    ifdef  _COM_
	OutMsg	<COM files supported.>
    endif ;_COM_

    ifdef XENIX
	OutMsg	<XENIX emulator.>
        PROTECT = 1             ; XENIX is always protect mode

    else    ;not XENIX
	ifdef DOS5only
	    OutMsg  <DOS 5 only emulator.>
	    DOS5 = 1
	    PROTECT = 1 	 ; DOS 5 is always protect mode

	else	;not DOS5only
	    DOS3=	1		; DOS 3 support is default
	    ifdef DOS5
		OutMsg	<DOS 3 & 5 emulator.>
		DOS3and5=	1
		PROTECT = 1	      ; DOS 5 is always protect mode

	    else    ;not DOS5
		OutMsg	<DOS 3 only emulator.>
	    endif   ;not DOS5

	endif	;not DOS5only

	ifdef standalone
	    OutMsg  <Stand-alone version (uses task vector for DS).>
	    ifdef   DOS5
		%out	*** Error: DOS 5 support not allowed.
		.error
	    endif   ;DOS5
	endif	;standalone

	ifdef frontend
	    OutMsg  <Front-end version - No hardware and limited instructions.>
	endif	;frontend

	ifdef SMALL_EMULATOR
	    OutMsg  <Small Emulator - Limited instructions.>
	endif	;SMALL_EMULATOR

	ifdef only87
	    OutMsg  <8087 only version - No emulation.>
	endif	;only87

	ifdef POLLING
	    OutMsg  <Exception handling uses polling FWAITs.>
	endif

    endif   ;not XENIX

    ifdef i386
	OutMsg	<386 version>
    endif

    if	  fastSP
	%out	Fast Single Precision version - Not supported.
    endif   ;fastSP

    ifdef DEBUG
	OutMsg	<+++  Debug Version  +++>
    endif   ;DEBUG

    ifdef  PROFILE
	OutMsg	<Profiling version.>
    endif   ;PROFILE

endif	;if1


;*******************************************************************************
;
;   Include cmacros.inc
;
;*******************************************************************************

?PLM = 1
?WIN = 0
?DF = 1

?NOGLOBAL = 1
?NOSTATIC = 1
?NOEXTERN = 1
?NODEF = 1
?NOPTR = 1

	include  cmac_mrt.inc		; old, customized masm510 cmacros
	include  mrt386.inc

ifdef  MTHREAD
	include os2supp.inc
endif


;*******************************************************************************
;
;   Include emulator macros.
;
;*******************************************************************************

	include  emulator.inc


;*******************************************************************************
;
;   Processor  setup.
;
;*******************************************************************************

ifdef  i386
	.386p
	.287

elseifdef  XENIX
	.286c		    ; allow 286 instructions if XENIX
	.287

elseifdef  DOS5only
	.286c		    ; allow 286 instructions if DOS 5 only
	.287

else	;Default
	.8086		    ; otherwise only 8086 instructions
	.8087		    ; make sure there are fwaits before all instruction
endif


;*******************************************************************************
;
;   Define segments.
;
;*******************************************************************************

ifdef  QB3

    createSeg EMULATOR_DATA, edata, para, public, CODE, <>
    createSeg EMULATOR_TEXT, ecode, para, public, CODE, <>

elseifdef QP

    createSeg DATA, edata, word, public,, <>
    createSeg CODE, ecode, word, public,, <>

else	;DEFAULT

    createSeg EMULATOR_DATA, edata, para, public, FAR_DATA, <>
    createSeg EMULATOR_TEXT, ecode, para, public, CODE, <>

endif	;DEFAULT



;*******************************************************************************
;
;   Define Number of stack elements, BEGINT and TSKINT
;
;*******************************************************************************


ifdef XENIX
    Numlev  equ     10			    ; 10 levels minimum for floating point

else	;not XENIX

    ifdef  QB3

	extrn	$EM_INT:far		    ; QB3 emulator error entry
	BEGINT	equ	084h		    ; MSDOS beginning interrupt
	Numlev	equ	10		    ; 10 levels minimum for floating point

    else    ;not QB3

	BEGINT	equ	034h		    ; MSDOS beginning interrupt

	ifdef _NOSTKEXCHLR
	    Numlev  equ     10		    ; 10 levels minimum for floating point

	elseifdef MTHREAD
	   Numlev equ	  16		    ; 16 levels minimum for floating-point

	else	;Default
	   Numlev  equ	  16		    ; 16 levels minimum for floating point
	endif	;Default

	ifdef	standalone
	  TSKINT  equ	  BEGINT + 10	    ; Task data pointer
	endif

	ifdef	WINDOWS
	  TSKINT  equ	  BEGINT + 10	    ; SignalAddress pointer
	endif

    endif   ;not QB3


    ifdef WINDOWS

	FIDRQQ	equ	(fINT + 256*(BEGINT + 0)) - (fFWAIT + 256*fESCAPE)
	FIERQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fES)
	FIWRQQ	equ	(fINT + 256*(BEGINT + 9)) - (iNOP + 256*fFWAIT)

	FIARQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fDS)
	FJARQQ	equ	256*(((0 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FISRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fSS)
	FJSRQQ	equ	256*(((1 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FICRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fCS)
	FJCRQQ	equ	256*(((2 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)

    elseifdef QP	; QuickPascal can't do absolutes

	FIDRQQ	equ	(fINT + 256*(BEGINT + 0)) - (fFWAIT + 256*fESCAPE)
	FIERQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fES)
	FIWRQQ	equ	(fINT + 256*(BEGINT + 9)) - (iNOP + 256*fFWAIT)

	FIARQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fDS)
	FJARQQ	equ	256*(((0 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FISRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fSS)
	FJSRQQ	equ	256*(((1 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
	FICRQQ	equ	(fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fCS)
	FJCRQQ	equ	256*(((2 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)

    else    ;not WINDOWS or QuickPascal

	extrn	FIWRQQ:abs, FIERQQ:abs, FIDRQQ:abs
	extrn	FISRQQ:abs, FJSRQQ:abs
	extrn	FIARQQ:abs, FJARQQ:abs
	extrn	FICRQQ:abs, FJCRQQ:abs

    endif   ;not WINDOWS or QuickPascal

endif	;not XENIX


;*******************************************************************************
;
;   List external functions.
;
;*******************************************************************************


ifdef  WINDOWSP
    extrn   DOS3CALL:far
endif

ifdef  WINDOWS
    extrn   __WINFLAGS:abs
    extrn   ALLOCDSTOCSALIAS:far
    extrn   FREESELECTOR:far
ifdef WF
    extrn   ALLOCSELECTOR:far
;if we are linking to LIBW from Win 3.0, CS isn't found, use PCS
	CHANGESELECTOR equ <PRESTOCHANGOSELECTOR>
    extrn   CHANGESELECTOR:far
endif
endif


ifdef  DOS3and5
	os2extrn    DOSGETMACHINEMODE
endif	;DOS3and5

ifdef  DOS5

    ifndef  frontend
	ifndef	only87
	    os2extrn	DOSWRITE	    ; only needed to print out "NO87="
	endif	;only87

	os2extrn    DOSCREATECSALIAS
	os2extrn    DOSFREESEG
	os2extrn    DOSDEVCONFIG

    endif   ;not frontend

    os2extrn	DOSSETVEC

    ifdef  MTHREAD
	os2extrn    DOSALLOCSEG
	os2extrn    DOSEXIT
	extrn	    __FarGetTidTab:far
    endif   ;MTHREAD

endif	;DOS5


;*******************************************************************************
;
;   Include some more macros and constants.
;
;*******************************************************************************


	include emdoc.asm
	include emintern.asm

ifdef  MTHREAD
	include	emthread.asm
endif	;MTHREAD

subttl	emulator.asm - Emulator Task DATA Segment
page
;*********************************************************************;
;								      ;
;		  Emulator Task DATA Segment			      ;
;								      ;
;*********************************************************************;


sBegin	edata


; eventually this needs to be a big struct

glb	<REMLSW,InitControlWord,CURerr>
glb	<UserControlWord,UserStatusWord,Have8087>
glb	<ControlWord,CWcntl,StatusWord,SWcc>
glb	<BASstk,CURstk,LIMstk>

;*******************************************************************************
;
;   Order of information here must not change (for CodeView debugging).
;	Check with CodeView guys before changing.
;
;*******************************************************************************


ifndef	i386
glb	<SignalAddress>
nedd	SignalAddress,<1 dup (?)> ; Error signal address
endif

Have8087	db	0	; Is a real 8087 present (0 = no 8087)
Einstall	db	0	; Emulator installed flag (XENIX sets to 1)

UserControlWord dw	?	; User level control word
UserStatusWord	dw	?	; User level exception status word

ControlWord	label	word
  CWmask	db	?	; exception masks
  CWcntl	db	?	; arithmetic control flags

StatusWord	label	word
  SWerr 	db	?	; Initially no exceptions (sticky flags)
  SWcc		db	?	; Condition codes from various operations


ifdef	XENIX
    nedw    BASstk,<?>			    ; init to BEGstk + 8*Have8087*Reg87Len
					    ;	 = start of memory (+ 8 regs if 8087)
    nedw    CURstk,<?>			    ; init to BASstk = start of stack
    nedw    LIMstk,<?>			    ; ENDstk - 1 reg = end of memory

else	;not XENIX
    nedw    BASstk,<offset BEGstk>	    ; init to BEGstk + 8*Have8087*Reg87Len
					    ;	 = start of memory (+ 8 regs if 8087)
    nedw    CURstk,<?>			    ; init to BASstk = start of stack
    nedw    LIMstk,<offset ENDstk-(2*Reg87Len)> ; ENDstk - 1 reg = end of memory
endif	;not XENIX

;*******************************************************************************
;
;   End of fixed area
;
;*******************************************************************************


ifdef	DOS3and5
glb	<protmode>
protmode	dw	?		; Protect mode flag (0 = real)
endif	;DOS3and5

ifdef	POLLING 			; used by new POLLING exception code
ifdef	DOS3
glb	<errorcode>
errorcode	db	0		; error code
		db	0
endif	;DOS3
endif	;POLLING

ifdef	QB3
initCW		dw	?		; QB3 initial control word
endif

InitControlWord equ	1332H		; Default - Affine, Round near,
					;   64 bits, all exceptions unmasked

NewStatusWord	label	word		; space for status after reexecution
CURerr		dw	?		; initially 8087 exception flags clear
					; this is the internal flag reset after
					; each operation to detect per instruction
					; errors

ifndef	XENIX
glb	<env_seg>
env_seg 	dw	?		; environment segment
endif

REMLSW		dw	?		; sometimes used as a temp
		dw	?		;   (2 or 4 bytes)


ifndef	XENIX

  ifdef   DOS5only
  NUMVEC= 2				  ; coprocesser no present + exception
  else
  NUMVEC= 11				  ; 8 DS + 1 segovr + 1 fwait + 1 task
  endif   ;DOS5only

  glb	  <oldvec>
  oldvec  dd	  NUMVEC dup (0)	  ; old interrupt vector values

endif


;Transcendental working variables

glb	<Reg8087ST0,TEMP1>

Reg8087ST0	label	word
TEMP1		dw	Reg87Len/2 DUP (?)


ifndef	frontend
ifdef	DOS5
SSalias 	dw	?		; SSalias for exception handler
endif	;DOS5
endif	;frontend

ifdef	DOS3
ifndef	frontend
glb	<statwd>
statwd	dw	0			; Location for 8087 status/control word
endif	;frontend
endif	;DOS3

ifndef	only87
glb	<TEMP2,TEMP3,ARG2,DENORX,COEFFICIENT,RESULT,DAC>
TEMP2		dw	Reg87Len/2 DUP (?)
TEMP3		dw	Reg87Len/2 DUP (?)
ARG2		dw	Reg87Len/2 DUP (?)
DENORX		dw	Reg87Len/2 DUP (?)
COEFFICIENT	dw	Reg87Len/2 DUP (?)
nedw		RESULT,<?>
DAC		dw	MantissaByteCnt/2 DUP (?)
endif	;only87

ifndef	frontend
ifndef	SMALL_EMULATOR

    loopct	    dw	    0	    ; data for FPREM emulation
    bigquot	    dw	    0	    ; quotient > 65535 ?

endif	;not SMALL_EMULATOR
endif	;not frontend

ExtendStack	dw	1		; 1 => extend 80x87 stack


ifdef  WINDOWS

Installed	dw	0		; Installation flag

ExceptFlag	db	0		; 80x87 exception flag for polling.
		db	0

ifdef WF
wfInsn		dw	0		; instruction we overwrote with INT 3d
wfSel		dw	0		; selector to use for alias
wfErr		dw	0		; FP error code (YAEC)
wfGoFast	dw	0		; 1 if we are Enhanced with coproc
endif

public OldNMIVec
OldNMIVec	dd	0		; Old value in 8087 exception interrupt vector

endif	;WINDOWS

ifdef  LOOK_AHEAD
NextOpCode	db	0		; first byte of next instruction
LookAheadRoutine dw	0
endif



; Emulator stack area

glb	<BEGstk,ENDstk>

BEGstk		db	Numlev*Reg87Len dup (?)     ; emulator stack area
ENDstk		label	byte

ifdef	MTHREAD
cvtbufsize= 349				; see \clib\include\cvt.h
cvtbuf		db	cvtbufsize	dup (?)	    ; used by ecvt/fcvt	
						    ; routines
endif	;MTHREAD

	public	__fptaskdata

__fptaskdata	label	byte		; task data pointer and size
					; (if linked with user program)

sEnd  edata



subttl	emulator.asm
page
;*********************************************************************;
;								      ;
;		Start of Code Segment				      ;
;								      ;
;*********************************************************************;


sBegin	ecode

assumes cs, ecode
assumes ds, edata

	public	__fpemulatorbegin
__fpemulatorbegin:			    ; emulator really starts here


reservedspace:		; IMPORTANT: Must be EMULATOR_TEXT:0000

	EMver		; IMPORTANT: Emulator version number
			; IMPORTANT: EBASIC needs this here!


	db	'gfw...GW'

ifdef  _COM_
extrn	__EmDataSeg:word
endif	;_COM_

page


ifdef	XENIX
	include emxenix.asm		; XENIX initialization

elseifdef WINDOWS
	include emwin.asm		; WINDOWS initialization

else	;not XENIX or WINDOWS
	include emdos.asm		; DOS initialization
endif	;not XENIX or WINDOWS

	include emstack.asm		; stack management macros

ifndef  QB3                             ; no exception handling for QB3
ifndef  XENIX                           ; UNDONE - no exception handling for XENIX
ifndef	frontend
	include emexcept.asm		; oem independent 8087 exception handling
endif	;frontend
endif   ;XENIX                          ; UNDONE -   at this time
endif   ;QB3

	include emerror.asm		; error handler

ifndef	XENIX				; not used with XENIX

	include emspec.asm		; special emulator/8087 functions

ifndef	frontend
	include emfixfly.asm		; fixup on the fly
endif	;not frontend

endif	;not XENIX

ifndef	only87

	public	__fpemulator
__fpemulator:				; emulator starts here

	include emdisp.asm		; dispatch tables
	include emconst.asm		; constants

ifdef	i386
	include em386.asm		; 386 emulation/initialization entry
else
	include emmain.asm		; main entry and address calculation
endif
	include emdecode.asm		; instruction decoder

	include emarith.asm		; arithmetic dispatcher
	include emfadd.asm		; add and subtract
	include emfmul.asm		; multiply
	include emfdiv.asm		; division
	include emnormal.asm		; normalize and round
	include emlssng.asm		; load and store single
	include emlsdbl.asm		; load and store double
	include emlsint.asm		; load and store integer
	include	emlsquad.asm		; load and store quadword integer
	include emfrndi.asm		; round to integer
	include emlstmp.asm		; load and store temp real
	include emfmisc.asm		; miscellaneous instructions
	include emfcom.asm		; compare
	include emfconst.asm		; constant loading
	include emnew.asm		; new instructions: f<op> ST(i)

ifndef	frontend
ifndef	SMALL_EMULATOR

	include emfprem.asm		; partial remainder
	include emfsqrt.asm		; square root
	include emftran.asm		; transcendentals

endif	;not SMALL_EMULATOR
endif	;not frontend


endif	;not only87

	public	__fpemulatorend
__fpemulatorend:			  ; emulator ends here

sEnd  ecode


ifdef WINDOWS
    EM_END  equ   <end	 LoadTimeInit>

else
    EM_END  equ   <end>
endif


EM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emu8087.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
only87  equ     1                       ; no emulator

include emulator.asm

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emwin.asm ===
page	,132
	subttl	emwin.asm - Initialization and Termination for Windows
;***
;emwin.asm - Initialization and Termination for Windows
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Initialization and Termination for Windows
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


comment !

Windows/DOS interfaces to emulator/8087 functions

Certain emulator/8087 functions are performed by calling __fpmath
with an function code and arguments.

__fpmath	general floating point	math  package  interface  used
		by the emulator/8087 and float calls interfaces.  This
		is a far routine and must be far called.

entry:

  bx = 0	initialize floating point math (program startup)
		dx, ax, si input values ignored in WINDOWS emulator
		returns:
		  ax = 0 if successful and using software floating point
		       1 if successful and using 8087
		  just terminates process if error

  bx = 1	reset (FINIT) - finit ok even under WINDOWS;
		typical usage will load control word afterward
		so other tasks won't be hindered (as with _fpreset() call)

  bx = 2	terminate floating point math (program termination)

  bx = 3	set error signal address
		dx:ax = segment:offset of user error handler

  bx = 4	load user control word
		(user should not use FLDCW instruction directly)
		ax = user control word value

  bx = 5	store user control word
		returns:
		  ax = user control word value

  bx = 6	truncate TOS to integer TOS
		ax = user control word (only use round mode)

  bx = 7	truncate TOS to 32-bit integer in DX:AX
		ax = user control word (only use round mode)

  bx = 8	store user status word
		returns:
		  ax = user status word value

  bx = 9	clear exceptions

  bx = 10	return number of stack elements in ax

  bx = 11	returns 1 if using 80x87, 0 if not

  bx = 12	if ax = 0, turn off extended stack. if ax = 1, turn on e.s.

! 


glb	<functab>

functab label	word

	dw	initialization		; 0 - initialize emulator/8087
	dw	reset			; 1 - reset emulator/8087 stack
	dw	termination		; 2 - terminate emulator/8087
	dw	setsignal		; 3 - set error signal address
	dw	loadcontrolword 	; 4 - load user control word
	dw	storecontrolword	; 5 - store user control word
	dw	truncateTOS		; 6 - truncate TOS to integer TOS
	dw	truncateTOSto32int	; 7 - truncate TOS to integer in DX:AX
	dw	storestatusword 	; 8 - store user status word
	dw	clearexceptions 	; 9 - clear execeptions
	dw	NumStack		; 10 - report number of elements in stack
	dw	ReturnHave8087		; 11 - report if using coprocessor
	dw	SetExtendedStack	; 12 - turn on or off extended stack
endfunc label	word

SizeJmpTab  equ    12

sEnd  ecode


sBegin	ecode

assumes cs, ecode
assumes ds, edata



public	__fpmath

__fpmath  proc	far

	cmp	bx, SizeJmpTab
	ja	RetFPErr

	shl	bx, 1
	push	ds			; save DS

	mov	cx, EMULATOR_DATA
	mov	ds, cx

	call	functab[bx]

	pop	ds			; restore DS

EmuRet:
	ret


RetFPErr:
	or	ax, -1
	cwd
	jmp	EmuRet

__fpmath  endp




subttl	emwin.asm - Initialization and Termination
page
;*********************************************************************;
;								      ;
;		      Initialization and Termination		      ;
;								      ;
;*********************************************************************;

wastetime macro
	push	cx
	mov	cx,20			;; wait for a short time
	loop	$
	pop	cx
endm



;	program initialization
;
;	entry	dx:ax = task data area (segment and size) for standalone
;		si = DOS environment segment for NO87 lookup ???
;	DX,AX,SI - ignored in WINDOWS case
;	these register inputs are ignored for Windows app
;		program-time initialization

pub  initialization			; all initialization is done when loaded

ifdef WF
	cmp	[Installed],0
	jnz	@F
	.286p
	push	0
	call	AllocSelector
	mov	[wfSel], ax		; Error checking??
	mov	ax, __WINFLAGS
;	int 3
	test	ax, WF_WIN386
	jz	wfSlow1
	cmp	[Have8087], 0
	je	wfSlow1
	or	[wfGoFast], 1		; We can use fast if Enh Mode & FPU
wfSlow1:
@@:
endif
	inc	[Installed]		; Installed will count number of apps
					; using the emulator.

	cmp	[Have8087], 0		; check for 8087/80287
	je	NoInstall87

	extrn	__FPINSTALL87:near
	call	__FPINSTALL87		; set NMI (int 2) for this instance
NoInstall87:

	call	reset
	xor	ax, ax

	ret




ifdef	standalone
	mov	di,offset BEGstk	; di = base of register stack
	mov	[BASstk],di		; initialize stack base
	mov	cx,Reg87Len		; cx = register length
	xchg	ax,dx			; ax = task data segment size
	sub	ax,di			; ax = number bytes for stack
	cwd				; dx:ax = number of bytes
	div	cx			; ax = number of entries
	mul	cx			; ax = number of bytes
	add	ax,di			; ax = top of stack
	sub	ax,cx			; Leave room for one on overflow
	mov	[LIMstk],ax		; set top of stack
endif	;standalone



; check if floating point emulator/8087 already installed (device driver)



    ; load time initialization

pub  LoadTimeInit

	push	di
	push	si
	push	ds
	mov	ax,EMULATOR_DATA
	mov	ds,ax

	mov	ax, __WINFLAGS
	and	ax, WF_80x87
	cmp	ax, WF_80x87
	jz	WinHave87

ifdef only87
	jmp	loadiniterrorret
endif
	jmp	WinSet87

pub WinHave87
	mov	al,1

pub WinSet87
	mov	[Have8087],al

    ; real mode emulation and fixup on the fly vector setup

pub  initvec
	call	SaveVectors
	call	SetVectors


pub  loadinitfinish


    ; finish initialization

pub  initfinish

	mov	[Installed], 0		; Installed will count number of apps

	call	reset			; reset (0), FINIT if 8087 present and
					; set up default control word

	mov	ax, 1			; return non zero result

pub  loadiniterrorret

	pop	ds
	pop	si
	pop	di
	retf				 ; far return for dynalink lib entry pt.


;*
;*  DLL termination routine.
;*

public	WEP
WEP  label  far

	push	ds
	push	ax

	push	si
	push	di

	mov	ax,EMULATOR_DATA
	mov	ds,ax

	call	reset
	call	RestoreVectors

	pop	di
	pop	si
	pop	ax
	pop	ds

	retf	2	    ; WEP functions are called with a word paramater.


;------ program termination ----------------------------------------------------

pub termination

	call	reset			; reset chip for other apps

	dec	[Installed]		; if Installed is not 0, someone is
	jnz	termrealdone		; still using the emulator.

ifdef WF
	xor	ax, ax
	xchg	ax, [wfSel]
	or	ax, ax
	jz	@F
	push	ax
	call	FreeSelector
@@:
endif

ifndef	only87
	cmp	[Have8087],0		; Non zero if 8087 chip exists
	je	termrealdone
endif	;only87

	extrn	__FPTERMINATE87:near   ; reset NMI (int 2) for this instance
	call	__FPTERMINATE87

pub termrealdone
	ret




subttl	emwin.asm - reset and clearexceptions
page
;*********************************************************************;
;								      ;
;		     Reset and Clearexceptions			      ;
;								      ;
;*********************************************************************;

pub reset

ifndef	only87
	cmp    [Have8087],0		; Nonzero if 8087 chip exists
	je     NoFINIT
endif	;only87
	fninit
	fwait				; Workaround for 80387 bug.
	fninit

pub NoFINIT
	mov	ax, [BASstk]
	mov	[CURstk], ax		; reset stack to bottom

	mov	ax, InitControlWord	; setup initial control word
	call	loadcontrolword


    ; fall into clearexceptions


pub  clearexceptions

	xor	ax, ax
ifndef	only87
	cmp	al, [Have8087]		; Nonzero if 8087 chip exists
	je	NoFCLEX
endif	;only87
	fclex				; clear exceptions

pub NoFCLEX
ifndef	only87
	mov	[StatusWord], ax	; clear status word
endif	;only87
	mov	[UserStatusWord], ax	; clear exception status word

	ret



subttl	emwin.asm - setsignal ---------------------------------
page
;*********************************************************************;
;								      ;
;		     Setsignal					      ;
;								      ;
;*********************************************************************;


pub  setsignal

	push	ds

	mov	ds, dx			; set TSKINT to SignalAddress
	mov	dx, ax
	mov	ax, 25h*256 + TSKINT
	IntDOS

	pop	ds
	ret


pub  SaveVectors

	mov	cx, NUMVEC		; save old vectors under DOS 3
	mov	ax, 35h*256 + BEGINT	; get vector
	mov	di, offset oldvec	; di = old vector table

pub getvecs
	IntDOS
	inc	ax
	mov	[di], bx		; save old vector
	mov	[di+2], es
	add	di, 4
	loop	getvecs

	ret

pub  SetVectors

ifndef	only87
	mov	dx, offset DStrap	; assume emulator
	mov	si, offset SOtrap
	mov	di, offset FWtrap
ifdef  WINDOWS
	mov	ax, __WINFLAGS		  ; if we are in PMODE & win386 increment all of
	and	ax, WF_PMODE or WF_WIN386 ; the handler address past the "sti".
	cmp	ax, WF_PMODE or WF_WIN386
	jne	NotPmode1

	inc	dx
	inc	si
	inc	di
lab NotPmode1
endif	;WINDOWS

	cmp	[Have8087], 0		; are we using 8087 ?
	jz	SetEmVecs		;    no - go ahead and set them
endif	;only87

	mov	dx, offset DSFixUpOnFly ; set up for fixup-on-the-fly
	mov	si, offset SOFixUpOnFly
	mov	di, offset FWFixUpOnFly
ifdef  WINDOWS
	mov	ax, __WINFLAGS		  ; if we are in PMODE & win386 increment all of
	and	ax, WF_PMODE or WF_WIN386 ; the handler address past the "sti".
	cmp	ax, WF_PMODE or WF_WIN386
	jne	NotPmode2

	inc	dx
	inc	si
	inc	di
lab NotPmode2
endif	;WINDOWS

pub  SetEmVecs
	push	ds

	push	cs
	pop	ds
	mov	ax, 25h*256 + BEGINT
	mov	cx, 8			; 8 vectors for DStrap

pub  SetDSLoop
	IntDOS				; set vector
	inc	ax			; bump to next one
	loop	SetDSLoop

	mov	dx, si			; set Segtrap
	IntDOS
	inc	ax
	mov	dx, di			; set FWtrap
	IntDOS

	pop	ds			; restore task data area

	ret


pub  RestoreVectors

	mov	cx, NUMVEC
	mov	ax, 25h*256 + BEGINT	; Dos set vector.
	mov	di, offset oldvec	; di = old vector table

pub  ResetVecLoop
	push	ds
	lds	dx, [di]		; get old vector value
	IntDOS
	pop	ds
	inc	ax
	add	di,4

	loop	ResetVecLoop

	ret



pub  NumStack			; returns the number of stack elements in ax

	xor	dx, dx		; dx will count nonzero elements

ifndef	only87
	cmp	Have8087, 0
	je	CountEmulatorStack
endif	;only87

	sub	sp, 14		; need 14 bytes for fstenv
	mov	bx, sp
	fstenv	ss:[bx]
	fldcw	ss:[bx] 	; reset control word
	mov	ax, ss:[bx+4]	; put tag word in ax
	add	sp, 14		; reset stack

	mov	cx, 8
pub NotEmptyLoop
	mov	bx, ax

	shr	ax, 1
	shr	ax, 1

	and	bx, 3
	cmp	bx, 3
	je	StackEntryEmpty

	inc	dx		; stack element was not empty
pub StackEntryEmpty
	loop	NotEmptyLoop


pub CountEmulatorStack

	mov	ax, CURstk
	sub	ax, BASstk

	mov	bl, Reg87Len

	div	bl

	add	ax, dx		; add elements on 80x87 stack

	ret


ReturnHave8087 proc near

	mov	al, [Have8087]
	cbw

	ret
ReturnHave8087 endp


SetExtendedStack proc near

	mov	[ExtendStack], ax

	ret
SetExtendedStack endp



;***
;int far pascal __Win87EmInfo( WinInfoStruct far * p, int cb );
;
;Purpose:
;   returns information about win87em.exe to CodeView
;
;Entry:
;   WinInfoStruct far * p
;   int cb  - size of WinInfoStruct
;
;Exit:
;   returns non zero if error.
;
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


cProc	__WIN87EMINFO,<PUBLIC,FAR,PLM>,<ds>

	parmD	p
	parmW	cb

cBegin
	or	ax, -1
	cmp	[cb], size WinInfoStruct
	jb	WIDone

	mov	ax, edataBASE
	mov	es, ax
	assumes es, edata

	lds	bx, [p]
	assumes ds, nothing

	mov	[bx.WI_Version], (major_ver shl 8) +  minor_ver
	mov	[bx.WI_SizeSaveArea], Size80x87Area + edataOFFSET __fptaskdata
	mov	[bx.WI_WinDataSeg], es
	mov	[bx.WI_WinCodeSeg], cs

	mov	al, [Have8087]
	cbw
	mov	[bx.WI_Have80x87], ax
	assumes es, nothing

	xor	ax, ax			    ; return 0 if no error
	mov	[bx.WI_Unused], ax
WIDone:
cEnd


;***
;int far pascal __Win87EmSave( void far * p, int cb );
;
;Purpose:
;   saves win87em.exe info in p
;
;Entry:
;   void far * p    - pointer to save area.
;   int cb	    - size of save area.
;
;Exit:
;   returns non zero if error.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


cProc	__WIN87EMSAVE,<PUBLIC,FAR,PLM>,<ds,si,di>

	parmD	p
	parmW	cb

cBegin
	or	ax, -1
	cmp	[cb], Size80x87Area + edataOFFSET __fptaskdata
	jb	WSDone

	mov	ax, edataBASE
	mov	ds, ax
assumes  ds, edata

	les	di, [p]
assumes  es, nothing

	cmp	[Have8087], 0
	je	NoSave80x87

	fsave	es:[di.WSA_Save80x87]
NoSave80x87:

	add	di, (WSA_SaveEm - WSA_Save80x87)
	xor	si, si
	mov	cx, edataOFFSET __fptaskdata
	shr	cx, 1

	rep movsw

	jnc	NoSaveLastByte
	movsb
NoSaveLastByte:

	xor	ax, ax		; return 0 if no error.

WSDone:
cEnd



;***
;int far pascal __Win87EmRestore( void far * p, int cb );
;
;Purpose:
;   retores win87em.exe info from p
;
;Entry:
;   void far * p    - pointer to save area.
;   int cb	    - size of save area.
;
;Exit:
;   returns non zero if error.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


cProc	__WIN87EMRESTORE,<PUBLIC,FAR,PLM>,<ds,si,di>

	parmD	p
	parmW	cb

cBegin
	or	ax, -1
	cmp	[cb], Size80x87Area + edataOFFSET __fptaskdata
	jb	WRDone

	mov	ax, edataBASE
	mov	es, ax
assumes  es, edata

	lds	si, [p]
assumes  ds, nothing

	add	si, (WSA_SaveEm - WSA_Save80x87)
	xor	di, di
	mov	cx, edataOFFSET __fptaskdata
	shr	cx, 1

	rep movsw

	jnc	NoRestoreLastByte
	movsb
NoRestoreLastByte:

	mov	si, [OFF_p]	    ; reset source pointer.

	cmp	[Have8087], 0
	je	NoRestore80x87

	frstor	[si.WSA_Save80x87]
NoRestore80x87:

	xor	ax, ax		; return 0 if no error.

WRDone:
cEnd

assumes ds, edata
assumes es, nothing
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emulator.inc ===
subttl	emulator.inc - Emulator macros.
;*** 
;emulator.inc - Emulator history.
;
;	Copyright (c) 1989-89, Microsoft Corporation
;
;Purpose:
;	Defines macros for emulator.
;
;Revision History
;
;   See emulator.hst
;
;*******************************************************************************



;*******************************************************************************
;
;   EMver  - defines version tag put in code segment.
;
;*******************************************************************************


EMver	macro
	db	'MSEM87',major_ver,minor_ver
	endm


;*******************************************************************************
;
;   Define pub and glb macros to make labels public for debugging.
;
;*******************************************************************************


ifdef  DEBUG

    lab     macro   name
    public  name
    name:
	    endm

    pub     macro   name
    public  name
    name:
	    endm

    glb     macro   name
	    irp     nm,<name>
	    public  nm
	    endm
	    endm

elseifdef  WINDOWS		; If windows, make these public for the map file.

    lab     macro   name
    public  name
    name:
	    endm

    pub     macro   name
    public  name
    name:
	    endm

    glb     macro   name
	    irp     nm,<name>
	    public  nm
	    endm
	    endm

else	;DEFAULT
    lab     macro   name
    name:
	    endm

    pub     macro   name
    name:
	    endm

    glb     macro   name
	    endm

endif	;DEFAULT



;*******************************************************************************
;
;   Macros and register aliases to keep the 386/8086 versions close.
;
;*******************************************************************************

ifdef	i386

eWORD	macro	nam				; 386 macros
nam	label	dword
	endm

nedw	macro	nam,contents
nam	dd	contents
	endm

nedd	macro	nam,contents
nam	df	contents
	endm

edw	macro	contents
	dd	contents
	endm

edd	macro	contents
	df	contents
	endm


else	; not i386

eWORD	macro	nam				; 286 macros
nam	label	word
	endm

nedw	macro	nam,contents
nam	dw	contents
	endm

nedd	macro	nam,contents
nam	dd	contents
	endm

edw	macro	contents
	dw	contents
	endm

edd	macro	contents
	dd	contents
	endm

eax	equ	ax
ecx	equ	cx
edx	equ	dx
ebx	equ	bx
esp	equ	sp
ebp	equ	bp
esi	equ	si
edi	equ	di

iretd   equ     iret

endif	;not i386


;*******************************************************************************
;
;   Processor opcode byte definitions.
;
;*******************************************************************************

fINT	equ	0cdh
fFWAIT	equ	9bh
fESCAPE equ	0d8h

iNOP	equ	90h	    ; byte nop

fES	equ	26h	    ; segment prefix opcodes
fCS	equ	2eh
fSS	equ	36h
fDS	equ	3eh

bIRET	equ	0cfh	    ; "iret"

bRETF	equ	0cah	    ; first byte of "retf 2".  Followed by word operand.
wNOP	equ	0c08bh	    ; word nop.  "mov  ax, ax"

bEscMask equ	0f8h	    ; masks all bits but escape
bMOD	equ	0c0h	    ; MOD bits are the two highest bits
bRM	equ	7h	    ; R/M bits are the three lowest bits.


;*******************************************************************************
;
;   Define os2extrn and os2call for dual mode emulators
;
;*******************************************************************************


ifdef	DOS3and5

    os2call macro name
	    call    __&name
	    endm

    os2extrn macro name
	    extrn   __&name : far
	    endm

endif	;DOS3and5

ifdef	DOS5only

    os2call macro name
	    call    name
	    endm

    os2extrn macro name
	    extrn   name : far
	    endm

endif	;DOS5only


;*******************************************************************************
;
;   Define ProfBegin ProfEnd macros for when profiling emulator.
;
;*******************************************************************************

ProfBegin  macro   name

ifdef  PROFILE
	nop

public EM_&name&_BEGIN
EM_&name&_BEGIN  label	far
endif
	endm


ProfEnd macro	name

ifdef  PROFILE
public EM_&name&_END
EM_&name&_END  label  far

	nop
endif
	endm


;*******************************************************************************
;
;   Define IntDOS macro for handling "int 21h" and "call DOS3CALL".
;
;*******************************************************************************


IntDOS	macro

ifdef  WINDOWSP
	call	DOS3CALL
else
	int	21h
endif
	endm


;*******************************************************************************
;
;   Define constants for DOS int 21h
;
;*******************************************************************************


DOS_getvector	equ	35H



INT_GetEquipList equ	 11h		 ; PC BIOS equipment list call.
GEL_80x87	 equ	  2h		 ; Mask for Coprocessor sense switch.


;*******************************************************************************
;
;   Define structures for __WinInfo(), __WinSave(), and __WinRestore().
;
;*******************************************************************************

WinInfoStruct	struc

    WI_Version	    dw	    ?	    ; High byte is major version.
    WI_SizeSaveArea dw	    ?	    ; Size of save area.
    WI_WinDataSeg   dw	    ?
    WI_WinCodeSeg   dw	    ?
    WI_Have80x87    dw	    ?
    WI_Unused	    dw	    ?	    ; Coprocessor type will go here.

WinInfoStruct	ends


Size80x87Area	equ	94


WinSaveArea struc

    WSA_Save80x87   db	    Size80x87Area dup(?)   ; Where 80x87 info will go.
    WSA_SaveEm	    db	    ?			   ; Where emulator data will go.

WinSaveArea ends



;*******************************************************************************
;
;   Define constants for checking "extrn __WINFLAGS:asb"
;
;*******************************************************************************


WF_PMODE    equ     1
WF_CPU286   equ     2
WF_CPU386   equ     4
WF_WIN286   equ     10h
WF_WIN386   equ     20h
WF_80x87    equ     400h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emxenix.asm ===
;
;
;	Copyright (C) Microsoft Corporation, 1986
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
subttl	emxenix.asm - XENIX function jump tables and Initialization
page


	public	__eminit, __emulate, __87exception


	org	10h

__eminit:                               ; UNDONE - not used any more


	org	15h

__emulate:
	jmp	protemulation		; protect mode emulation


	org	1Ah

__87exception:
        pop     eax                     ; eax = error code
        int     0FFh

page
;------------------------------------------------------------------------------
;
;	install emulator (initial all data elements
;
;	This routine is executed once for the 1st emulated instruction
;
;------------------------------------------------------------------------------


pub	installemulator

	mov	[Einstall],1		; mark emulator as initialized

	mov	eax,offset BEGstk	; pointer to beginning of stack
	mov	[BASstk],eax		; set base of stack
	mov	[CURstk],eax		; set current stack element
	mov	eax,offset ENDstk-Reg87Len
	mov	[LIMstk],eax		; set end of stack

        mov     ax,InitControlWord
	mov	[UserControlWord],ax	; initialize control words
	mov	[ControlWord],ax

	xor	eax,eax
	mov	[UserStatusWord],ax	; initialize status words
	mov	[StatusWord],ax

	jmp	protemcont		; continue emulating 1st instruction
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winnls\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winnls\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winnls\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winnls\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winnls\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winoldap\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\emspec.asm ===
page	,132
	subttl	emspec.asm - Special emulator functions for speed
;***
;emspec.asm - Special emulator functions for speed
;
;	Copyright (c) 1987-89, Microsoft Corporation
;
;Purpose:
;	Special emulator functions for speed
;
;	This Module contains Proprietary Information of Microsoft
;	Corporation and should be treated as Confidential.
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************


ProfBegin SPEC


pub	loadcontrolword
ifdef	QB3
	or	al,2			; mask denormal exceptions
endif	;QB3
	mov	[UserControlWord],ax	; save user's version
	and	ax,0FF3CH		; Turn off reserved, IEM, Denormal
					; & invalid exception mask bits
ifndef	frontend
ifndef	only87
	cmp	[Have8087],0		; Non-0 if 8087 present
	je	EmulateFLDCW
endif	;only87

	mov	[REMLSW],ax		; use this cell (not busy)
	fnop				; fix for intel erratum #8
	fldcw	[REMLSW]		; 8087 gets new control word
endif	;frontend

pub	EmulateFLDCW
	mov	[ControlWord],ax	; save internal control word
	ret


;-----------------------------------------------------------------------------

ifndef	QB3				; rest not needed if QB 3

pub	storecontrolword
	mov	ax,[UserControlWord]	; get user's version
	ret


pub	storestatusword
	xor	ax,ax
ifndef	frontend
	cmp	al,[Have8087]
	je	no87status
	fstsw	[NewStatusWord]
	fwait
	mov	al,byte ptr [NewStatusWord] ; get exception summary
	and	al,03Fh 		; only low 6 bits are wanted
endif	;frontend

pub	no87status
	or	ax,[UserStatusWord]	; or with full status
	and	ax,UStatMask		; mask down to actual status bits
	mov	[UserStatusWord],ax	; update full status word
	ret

page

; Procedure to truncate TOS to integer TOS

;	ax = new rounding control

pub	truncateTOS
	and	ax,RoundControl shl 8	; mask to new rounding control

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0
	je	Emulatetruncate
endif	;only87

	FSTCW	[ControlWord]		; get control word
	FWAIT				; synchronize
	MOV	CX,[ControlWord]	; round mode saved
	and	ch,not RoundControl	; clear rounding control bits
	OR	ax,cx			; set new rounding
	MOV	[REMLSW],AX		; back to memory
	FLDCW	[REMLSW]		; reset rounding
	FRNDINT 			; "round" top of stack
	FLDCW	[ControlWord]		; restore rounding
	RET				; simple return
endif	;frontend

ifndef	only87
pub	Emulatetruncate
	mov	cx,[ControlWord]
	push	cx			; remember what control word was
	and	ch,not RoundControl	; clear rounding control bits
	OR	ah,ch			; set new rounding
	MOV	[CWcntl],ah		; flag new rounding mode
	PUSH	BP			; save BP
	CALL	eFRNDINT
	POP	BP			; restore BP
	POP	[ControlWord]		; set back to the way it was

	call	checktrunc		; check for truncation error

	RET				; finished
endif	;only87

page

; Procedure to truncate TOS to integer in DX:AX

;	ax = new rounding control

pub	truncateTOSto32int
	and	ax,RoundControl shl 8

ifndef	frontend
ifndef	only87
	cmp	[Have8087],0
	je	Emulatetruncateto32int
endif	;only87

	FSTCW	[ControlWord]		; get control word
	FWAIT				; synchronize
	MOV	CX,[ControlWord]	; round mode saved
	and	ch,not RoundControl	; clear rounding control bits
	OR	ax,cx			; set new rounding
	MOV	[REMLSW],AX		; back to memory
	FLDCW	[REMLSW]		; reset rounding
	FISTP	dword ptr [REMLSW]	; "round" top of stack
	FLDCW	[ControlWord]		; restore rounding
	mov	ax,[REMLSW]
	mov	dx,[REMLSW+2]
	RET				; simple return
endif	;frontend

ifndef	only87
pub	Emulatetruncateto32int
	mov	cx,[ControlWord]
	push	cx			; remember what control word was
	and	ch,not RoundControl	; clear rounding control bits
	OR	ah,ch			; set new rounding
	MOV	[CWcntl],ah		; flag new rounding mode
	PUSH	BP			; save BP
	CALL	TOSto32int		; convert to 32-bit int in BX:DX
	POP	BP			; restore BP
	mov	ax,dx
	mov	dx,bx

	call	checktrunc		; check for truncation error

	POPST				; pop of current stack entry
	POP	[ControlWord]		; set back to the way it was

pub	truncerrOK			; (reuse RET for routine below)
	RET				; finished

;	check for errors

pub	checktrunc			; !!! check emmain for same code
	MOV	cx,[CURerr]		; fetch errors
	or	[UserStatusWord],cx	; OR into user status word
	OR	[SWerr],cl		; set errors in sticky error flag
	NOT	cl			; make a zero mean an error
	MOV	ch,byte ptr [UserControlWord]  ; get user's IEEE control word
	OR	ch,0C2H 		; mask reserved, IEM and denormal bits
	AND	ch,03FH 		; unmask invalid instruction,
					;    stack overflow.
	OR	cl,ch			; mask for IEEE exceptions
	NOT	cl			; make a one mean an error
	MOV	ch,byte ptr (CURerr+1)	; get stack over/underflow flags
	TEST	cx,0FFFFh-MemoryOperand ; test for errors to report
	jz	truncerrOK		;   error is masked

	xchg	ax,cx			; ax = exception
	jmp	CommonExceptions	; handle error (??? unclean stack)

endif	;only87


endif	;QB3


ProfEnd  SPEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\wfpinit.asm ===
page	,132
	title	 wfpinit - Functions for initializing win87em.exe from a DLL
;***
;wfpinit.asm - Functions for initializing win87em.exe from a DLL
;
;	Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	Defines the initialization and termination routines for the Windows
;	emulator (used in DLLs).
;
;Revision History:
;   04/14/88  WAJ   Initial version.
;   04/06/89  WAJ   Cleaned up source.
;   04/12/90  WAJ   Will now work in protected mode.
;
;*******************************************************************************


memL = 1
?PLM = 1	    ; Pascal names.
?WIN = 1	    ; Windows calling sequence

.xlist
	include  cmac_mrt.inc		; old, customized masm510 cmacros
.list

TSKINT	    equ     3eh 		; int 3e is used for the Signal handler
OPSYS	    equ     21h
SETVECOP    equ     25h
GETVECOP    equ     35h


externFP  __fpmath
externFP  __fpsignal

sBegin	data
DefaultFPSignal  dd  __fpsignal 	; want to a thunk for this function
sEnd	data

sBegin	code

assumes cs, code
assumes ds, data


;***
; _FPInit -
;
;Purpose: Initializes the Windows emulator.
;
;Entry:
;
;Exit:	returns the old signal handler
;
;Uses:
;
;Exceptions: none
;
;*******************************************************************************

cProc	_FPINIT,<PUBLIC,FAR>,<>

cBegin
	xor	bx, bx			; initialize Emulator/Coprocessor
	call	__fpmath


	push	ds
	mov	ax,GETVECOP shl 8 + TSKINT  ; get interrupt vector TSKINT
	int	OPSYS			    ; Call operating system.
	pop	ds

	push	es			; save previous FP signal handler on
	push	bx			; stack

	mov	ax, word ptr [DefaultFPSignal]
	mov	dx, word ptr [DefaultFPSignal+2]

	mov	bx, 3			; 3 => set SignalAddress
	call	__fpmath

	pop	ax			; get previous FP signal handler off
	pop	dx			; stack
cEnd



;***
; _FPTerm -
;
;Purpose: terminates Windows emulator
;
;Entry: old floating point signal handler
;
;Exit: none
;
;Uses:
;
;Exceptions: none
;
;*******************************************************************************

cProc	_FPTERM,<PUBLIC,FAR>,<>

	parmD  DefaultSignalHandler

cBegin
	mov	ax, [OFF_DefaultSignalHandler]
	mov	dx, [SEG_DefaultSignalHandler]

	mov	bx, 3			; 3 => set SignalAddress
	call	__fpmath

	mov	bx, 2			; 2 => terminate FP
	call	__fpmath
cEnd

sEnd  code

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winoldap\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winsock\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\win87em.h ===
/***
*win87em.h - definitions/declarations for win87em.exe exports.
*
*   Copyright (c) 1989-1989, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   exported from win87em.exe
*
*Revision History:
*
*   06-26-89  WAJ   Initial version.
*
****/


typedef  struct _Win87EmInfoStruct {
			    unsigned	 Version;
			    unsigned	 SizeSaveArea;
			    unsigned	 WinDataSeg;
			    unsigned	 WinCodeSeg;
			    unsigned	 Have80x87;
			    unsigned	 Unused;
			    } Win87EmInfoStruct;

#define SIZE_80X87_AREA     94

/*
 * The Win87EmSaveArea loks like this:
 *
 * typedef  struct _Win87EmSaveArea {
 *			       unsigned char  Save80x87Area[SIZE_80X87_AREA];
 *			       unsigned char  SaveEmArea[];
 *			       } Win87EmSaveArea;
 */


int far pascal __Win87EmInfo( Win87EmInfoStruct far * pWIS, int cbWin87EmInfoStruct );
int far pascal __Win87EmSave( void far * pWin87EmSaveArea, int cbWin87EmSaveArea );
int far pascal __Win87EmRestore( void far * pWin87EmSaveArea, int cbWin87EmSaveArea );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\wfpsig.asm ===
page	,132
	title	wfpinit  - Functions for initializing win87em.exe from a DLL
;*** 
;wfoinit.asm - Functions for initializing win87em.exe from a DLL
;
;	Copyright (c) 1988-89, Microsoft Corporation
;
;Purpose:
;	Functions for initializing win87em.exe from a DLL
;
;Revision History:
;   04/06/89  WAJ   Added this header.
;   04/06/89  WAJ   Cleaned up source, Save more registers in __fpsignal
;
;*******************************************************************************


	memL = 1

	?PLM = 1	; Pascal naming
	?WIN = 1	; Windows calling convention

.xlist
	include  cmac_mrt.inc		; old, customized masm510 cmacros
.list


externFP POSTQUITMESSAGE


sBegin	code

assumes cs,code
assumes ds,data

;
; Windows floating-point emulator error routine
; (replaces CFPSIG.ASM in regular C math runtime)
;
; The behavior is to die with error code.
; (Calling POSTQUITMESSAGE doesn't cause immediate termination of
; the Windows "task", but sends a WM_QUIT message
; to the application queue of the current Windows app.)
;

cProc	__fpsignal,<PUBLIC,FAR>,<es,bx,cx,dx>

cBegin
	sub	ah, ah

	push	ax
	call	POSTQUITMESSAGE
cEnd

sEnd	code

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winsock\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winspool\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winnls\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=usa \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winspool\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowdeb\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winnls\winnls.asm ===
;++
;
;   WOW v1.0
;
;   Copyright (c) 1991, Microsoft Corporation
;
;   WINNLS.ASM
;   Win16 WINNLS thunks
;
;   History:
;
;   Created 3-Feb-1992 by Junichi Okubo (junichio)
;--

	TITLE	WINNLS.ASM
	PAGE	,132

        ; Some applications require that USER have a heap.  This means
        ; we must always have: LIBINIT equ 1
	;
	; NOTICE THIS junichio memo: This is on the developement.
	;			    I cannot figure out it need or not?
        ;LIBINIT equ 1

	FIRST_CALL_MUST_BE_USER_BUG equ 1

	ifdef	FIRST_CALL_MUST_BE_USER_BUG
	;LIBINIT equ 1
	endif

	.286p

	.xlist
	include wow.inc
	include wownls.inc
	include cmacros.inc
	.list

	__acrtused = 0
	public	__acrtused	;satisfy external C ref.

ifdef LIBINIT
externFP LocalInit
endif
externFP    WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp	    DGROUP,DATA


sBegin	DATA
Reserved    db	16 dup (0)	;reserved for Windows

sEnd	DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

ifdef LIBINIT
;externFP LibMain
endif

cProc	WINNLS16,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>

	cBegin <nogen>
	IFDEF	LIBINIT
        ; push params and call user initialisation code

	push di 		;hModule

        ; if we have a local heap declared then initialize it

        jcxz no_heap

	push 0			;segment
	push 0			;start
	push cx 		;length
        call LocalInit

no_heap:
;	call LibMain		;return exit code from LibMain
	ELSE
	mov  ax,1		;are we dressed for success or WHAT?!
	ENDIF
	ret
	cEnd <nogen>


cProc	WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
	parmW	iExit		;DLL exit code

	cBegin
	mov	ax,1		;always indicate success
	cEnd

;	WINNLSThunk   INQUIREWINNLS
cProc InquireWINNLS,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
	mov	ax,0		; WOW does not support
cEnd InquireWINNLS

;	WINNLSTHunk   HOOKKEYBOARDMESSAGE
cProc HookKeyboardMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW nCode
parmW VKey
parmD lParam
cBegin
	mov	ax,0		; WOW does not support
cEnd HookKeyboardMessage

	WINNLSThunk   SENDIMEMESSAGE
	WINNLSThunk   SENDIMEMESSAGEEX

;	WINNLSThunk   WINNLSSETKEYBOARDHOOK
cProc WINNLSSetKeyboardHook,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW fHookNew
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetKeyboardHook

;	WINNLSThunk   WINNLSSETIMEHANDLE
cProc WINNLSSetIMEHandle,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpszName
parmW hWnd
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetIMEHandle

;	WINNLSThunk   WINNLSSETIMESTATUS
cProc WINNLSSetIMEStatus,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW fStatus
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetIMEStatus

;	WINNLSThunk   WINNLSSETIMEHOTKEY
cProc WINNLSSetIMEHotkey,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW key
ifdef KOREA
parmW unknown
endif
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetIMEHotkey

	WINNLSThunk   WINNLSGETIMEHOTKEY
	WINNLSThunk   WINNLSENABLEIME	

;	WINNLSThunk   WINNLSGETKEYSTATE
cProc WINNLSGetKeyState,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSGetKeyState

	WINNLSThunk   WINNLSGETENABLESTATUS

;	WINNLSThunk   WINNLSSETKEYSTATE
cProc WINNLSSetKeyState,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW uVKey
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSetKeyState

;	WINNLSThunk   IMPADDIME
cProc IMPAddIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpCIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPAddIME

;	WINNLSThunk   IMPDELETEIME
cProc IMPDeleteIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpCIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPDeleteIME

	WINNLSThunk   IMPQUERYIME
	WINNLSThunk   IMPGETIME
	WINNLSThunk   IMPSETIME

;	WINNLSThunk   IMPMODIFYIME
cProc IMPModifyIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpszFile
parmD lpCIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPModifyIME

;	WINNLSThunk   IMPGETDEFAULTIME
cProc IMPGetDefaultIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpNIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPGetDefaultIME

;	WINNLSThunk   IMPSETDEFAULTIME
cProc IMPSetDefaultIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpNIMEPro
cBegin
	mov	ax,0		; WOW does not support
cEnd IMPSetDefaultIME

;	WINNLSThunk   WINNLSSENDSTRING
cProc WINNLSSendString,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW wFunc
parmD lpData
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSendString

;	WINNLSThunk   WINNLSPOSTAPPMESSAGE
cProc WINNLSPostAppMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW uMsg
parmW wParam
parmD lParam
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSPostAppMessage

;	WINNLSThunk   WINNLSSENDAPPMESSAGE
cProc WINNLSSendAppMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW uMsg
parmW wParam
parmD lParam
cBegin
	mov	ax,0		; WOW does not support
cEnd WINNLSSendAppMessage

ifdef TAIWAN_PRC 
;dchiang 032594 add NULL THUNK for CWIN30 & 31 Internal-ISV
;       WINNLSThunk   WINNLSSetSysIME
cProc WINNLSSetSysIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSSetSysIME

;       WINNLSThunk   WINNLSGetSysIME
cProc WINNLSGetSysIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSGetSysIME

;       WINNLSThunk   WINNLSIMEControl
cProc WINNLSIMEControl,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW hIMEWnd
parmD lpIME
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSIMEControl

;       WINNLSThunk   WINNLSSendControl
cProc WINNLSSendControl,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW wChar
parmW wCount
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSSendControl

;       WINNLSThunk   WINNLSQueryIMEInfo
cProc WINNLSQueryIMEInfo,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW hIMEWnd
parmD lpCIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSQueryIMEInfo

;       WINNLSThunk   IMPEnableIME
cProc IMPEnableIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
parmW fFlag
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPEnableIME

;       WINNLSThunk   IMPSetFirstIME
cProc IMPSetFirstIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpNIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPSetFirstIME

;       WINNLSThunk   IMPGetFirstIME
cProc IMPGetFirstIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPGetFirstIME

;       WINNLSThunk   IMPSetUsrFont
cProc IMPSetUsrFont,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPSetUsrFont

;       WINNLSThunk   InquireIME
cProc InquireIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
cBegin
        mov     ax,0            ; WOW does not support
cEnd InquireIME


;dchiang 032494 add THUNK for CWIN31
;       WINNLSThunk   IMPRETRIEVEIME
cProc IMPRetrieveIME,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmD lpCIMEPro
parmW wFlags
cBegin
        mov     ax,0            ; WOW does not support
cEnd IMPRetrieveIME

;       WINNLSThunk   WINNLSDEFIMEPROC
cProc WINNLSDefIMEProc,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmW hDC
parmW wProc
parmW wFunc
parmD lParam1
parmD lParam2
cBegin
        mov     ax,0            ; WOW does not support
cEnd WINNLSDefIMEProc

;       WINNLSThunk   CONTROLIMEMESSAGE
cProc ControlIMEMessage,<PUBLIC,FAR,PASCAL,NODATA,WIN>
parmW hWnd
parmD lpCIMEPro
parmW wControl
parmW wFunc
parmD lpParam
cBegin
        mov     ax,0            ; WOW does not support
cEnd ControlIMEMessage
endif

sEnd	CODE

end	WINNLS16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowdeb\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winoldap\winoldap.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    winoldap.c

Abstract:

    This module is a Win16 "stub" run by the WOW kernel when invoking
    non-Win16 applications.  It calls WowLoadModule to wait for the
    non-win16 app to terminate, and then exits

    This makes WINOLDAP a strange Windows program, since it doesn't
    create a window or pump messages.

    The binary is named WINOLDAP.MOD for historic reasons.

Author:

    04-Apr-1995 Jonle , created

Environment:

    Win16 (WOW)

Revision History:

--*/

#include <windows.h>

HINSTANCE WINAPI WowLoadModule(LPCSTR, LPVOID, LPCSTR);

//
// WinMain
//

int PASCAL WinMain(HANDLE hInstance, HANDLE hPrevInstance,
                   LPSTR lpszCmdLine, int nCmdShow)
{
    return (int) WowLoadModule(NULL,           // no module name
                               NULL,           // no parameterblock
                               lpszCmdLine     // pass along cmd line
                               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winspool\winspool.asm ===
TITLE	WINSPOOL.ASM
	PAGE	,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; WINSPOOL.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   17-OCT-1991 Matt Felton (mattfe)
;   Created.
;

	.286p

	.xlist
	include wow.inc
	include wowgdi.inc
	include cmacros.inc
	.list

	__acrtused = 0
	public	__acrtused	;satisfy external C ref.

externFP WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp	    DGROUP,DATA

sBegin	DATA
Reserved	db  16 dup (0)	    ;reserved for Windows  //!!!!! what is this

WINSPOOL_Identifier	db	'WINSPOOL16 Data Segment'
public _iLogLevel
_iLogLevel	dw	0
public _iBreakLevel
_iBreakLevel	dw	0

sEnd	DATA


sBegin	CODE
assumes	CS,CODE
assumes DS,DATA
assumes ES,NOTHING

cProc	WINSPOOL16,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>
	cBegin	<nogen>
	mov	ax,1		;always indicate success
	ret
	cEnd	<nogen>

assumes DS,NOTHING

cProc	WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
	parmW	iExit		;DLL exit code

	cBegin
	mov	ax,1		;always indicate success
	cEnd

assumes DS,DATA

assumes DS,NOTHING

	DGDIThunk	 DEVICEMODE
	DGDIThunk	 EXTDEVICEMODE
	DGDIThunk	 DEVICECAPABILITIES

cProc	ExtTextOut,<PUBLIC,FAR>
cBegin
	int 3
cEnd


sEnd	CODE

end	WINSPOOL16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\winsock\winsock.asm ===
TITLE   WINSOCK.ASM
        PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; MMSYSTEM.ASM
; Thunks in 16-bit space to route Winsock API calls to WOW32
;
; History:
;   02-Oct-1992 David Treadwell (davidtr)
;   Created.
;

        .286p

        .xlist
        include wow.inc
        include wowwsock.inc
        include cmacros.inc
        .list

        __acrtused = 0
        public  __acrtused      ;satisfy external C ref.

externFP WOW16Call

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

sBegin  DATA
Reserved        db  16 dup (0)      ;reserved for Windows  //!!!!! what is this

WINSOCK_Identifier   db      'WINSOCK16 Data Segment'

sEnd
sEnd    DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

cProc   WINSOCK16,<PUBLIC,FAR,PASCAL,NODATA,ATOMIC>

        cBegin  <nogen>
            mov     ax,1
        ret
        cEnd    <nogen>

assumes DS,NOTHING

cProc   WEP,<PUBLIC,FAR,PASCAL,NODATA,NOWIN,ATOMIC>
        parmW   iExit           ;DLL exit code

        cBegin
        mov     ax,1            ;always indicate success
        cEnd

assumes DS,NOTHING

       WinsockThunk    ACCEPT
       WinsockThunk    BIND
       WinsockThunk    CLOSESOCKET
       WinsockThunk    CONNECT
       WinsockThunk    GETPEERNAME
       WinsockThunk    GETSOCKNAME
       WinsockThunk    GETSOCKOPT
       WinsockThunk    HTONL
       WinsockThunk    HTONS
       WinsockThunk    INET_ADDR
       WinsockThunk    INET_NTOA
       WinsockThunk    IOCTLSOCKET
       WinsockThunk    LISTEN
       WinsockThunk    NTOHL
       WinsockThunk    NTOHS
       WinsockThunk    RECV
       WinsockThunk    RECVFROM
       WinsockThunk    SELECT
       WinsockThunk    SEND
       WinsockThunk    SENDTO
       WinsockThunk    SETSOCKOPT
       WinsockThunk    SHUTDOWN
       WinsockThunk    SOCKET
       WinsockThunk    GETHOSTBYADDR
       WinsockThunk    GETHOSTBYNAME
       WinsockThunk    GETPROTOBYNAME
       WinsockThunk    GETPROTOBYNUMBER
       WinsockThunk    GETSERVBYNAME
       WinsockThunk    GETSERVBYPORT
       WinsockThunk    GETHOSTNAME
       WinsockThunk    WSAASYNCSELECT
       WinsockThunk    WSAASYNCGETHOSTBYADDR
       WinsockThunk    WSAASYNCGETHOSTBYNAME
       WinsockThunk    WSAASYNCGETPROTOBYNUMBER
       WinsockThunk    WSAASYNCGETPROTOBYNAME
       WinsockThunk    WSAASYNCGETSERVBYPORT
       WinsockThunk    WSAASYNCGETSERVBYNAME
       WinsockThunk    WSACANCELASYNCREQUEST
       WinsockThunk    WSASETBLOCKINGHOOK
       WinsockThunk    WSAUNHOOKBLOCKINGHOOK
       WinsockThunk    WSAGETLASTERROR
       WinsockThunk    WSASETLASTERROR
       WinsockThunk    WSACANCELBLOCKINGCALL
       WinsockThunk    WSAISBLOCKING
       WinsockThunk    WSASTARTUP
       WinsockThunk    WSACLEANUP
       WinsockThunk    __WSAFDISSET

; End of additions

sEnd    CODE

end     WINSOCK16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowdeb\wowdeb.c ===
#include <windows.h>                /* required for all Windows applications */

#define MAX_COMMUNICATION_BLOCK_SIZE    4096
#define DEAD_VALUE                      0xFEFEFEFEL

#include <dbginfo.h>

#define MAX_PATH    260

extern BOOL FAR PASCAL WowKillRemoteTask( LPSTR lpBuffer );

int PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance, LPSTR lpszCmdLine, int iCmd )
{
    HANDLE          hCommunicationBlock;
    LPSTR           lpCommunicationBlock;
    BOOL            b;
    LPCOM_HEADER    lphead;
    WORD            wArgsPassed;
    WORD            wArgsSize;
    WORD            wSuccess;
    DWORD           dwReturnValue;
    LPSTR           lpModuleName;
    LPSTR           lpEntryName;
    HANDLE          hModule;
    DWORD           (FAR PASCAL *lpfn)();
    BOOL            fFailed;
    LPWORD          lpw;
    char            szLoad[MAX_PATH];
    WORD            wPos;

    // We only want 1 instance of WOWDEB
    if ( hPrevInstance != NULL ) {
        return( FALSE );
    }

    hCommunicationBlock = GlobalAlloc(GMEM_FIXED, MAX_COMMUNICATION_BLOCK_SIZE);
    if ( hCommunicationBlock == (HANDLE)0 ) {
        OutputDebugString("Failed to allocate memory block\n");
        return( FALSE );
    }

    lpCommunicationBlock = GlobalLock(hCommunicationBlock);
    if ( lpCommunicationBlock == NULL ) {
        OutputDebugString("Failed to lock memory block\n");
        return( FALSE );
    }

    wPos = GetSystemDirectory( (LPSTR)&szLoad, sizeof(szLoad));
    if (wPos == 0 || wPos >= sizeof(szLoad)-1-8-1-8-1-3-1) {
        OutputDebugString("Could not get a decent system directory\n");
        return( FALSE );
    }

    /*
    ** Just make sure that TOOLHELP is loaded before we remotely kill
    ** ourselves.
    */
    lstrcpyn( &szLoad[wPos], "32\\TOOLHELP.DLL", sizeof("32\\TOOLHELP.DLL"));
    hModule = LoadLibrary( szLoad );

    dwReturnValue = DEAD_VALUE;
    wSuccess = (WORD)FALSE;

    do {
        /*
        ** Initialize the communications block
        */
        lphead = (LPCOM_HEADER)lpCommunicationBlock;

        lphead->dwBlockAddress = (DWORD)lpCommunicationBlock;
        lphead->dwReturnValue  = dwReturnValue;
        lphead->wArgsPassed    = 0;
        lphead->wArgsSize      = 0;
        lphead->wBlockLength   = MAX_COMMUNICATION_BLOCK_SIZE;
        lphead->wSuccess       = (WORD)wSuccess;

        b = WowKillRemoteTask( lpCommunicationBlock );

        if ( !b ) {
            break;
        }

        wSuccess = (WORD)FALSE;
        dwReturnValue = 0;

        /*
        ** Unpacketize the information and execute it
        ** Note: The below statements expect the contents of the structures
        ** to change after the above "WowKillRemoteTask" API call.  If the
        ** compiler attempts to optimize the references below, it will get
        ** the wrong values.
        */
        wArgsPassed  = lphead->wArgsPassed;
        wArgsSize    = lphead->wArgsSize;
        lpModuleName = lpCommunicationBlock + sizeof(COM_HEADER) + wArgsSize;
        lpEntryName  = lpModuleName + lstrlen(lpModuleName) + 1;

        hModule = LoadLibrary( lpModuleName );
        if ( hModule == 0 ) {
#ifdef DEBUG
            OutputDebugString("Failed to load library\n");
#endif
            continue;
        }

        lpfn = (DWORD (FAR PASCAL *)())GetProcAddress( hModule, lpEntryName );
        if ( lpfn == NULL ) {
#ifdef DEBUG
            OutputDebugString("Failed to get proc address\n");
#endif
            continue;
        }

        // Now copy the right number of bytes onto the stack and call the
        // function.
        lpw = (LPWORD)(lpCommunicationBlock + sizeof(COM_HEADER));
        fFailed = FALSE;

        // Cheesy way of putting a variable number of arguments on the stack
        // for a pascal call.
        switch( wArgsPassed ) {
            case 0:
                dwReturnValue = (* lpfn)();
                break;
            case 2:
                dwReturnValue = (* lpfn)( lpw[ 0] );
                break;
            case 4:
                dwReturnValue = (* lpfn)( lpw[ 1], lpw[ 0] );
                break;
            case 6:
                dwReturnValue = (* lpfn)( lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 8:
                dwReturnValue = (* lpfn)( lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 10:
                dwReturnValue = (* lpfn)( lpw[ 4], lpw[ 3], lpw[ 2], lpw[ 1],
                                          lpw[ 0] );
                break;
            case 12:
                dwReturnValue = (* lpfn)( lpw[ 5], lpw[ 4], lpw[ 3], lpw[ 2],
                                          lpw[ 1], lpw[ 0] );
                break;
            case 14:
                dwReturnValue = (* lpfn)( lpw[ 6], lpw[ 5], lpw[ 4], lpw[ 3],
                                          lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 16:
                dwReturnValue = (* lpfn)( lpw[ 7], lpw[ 6], lpw[ 5], lpw[ 4],
                                          lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 18:
                dwReturnValue = (* lpfn)( lpw[ 8], lpw[ 7], lpw[ 6], lpw[ 5],
                                          lpw[ 4], lpw[ 3], lpw[ 2], lpw[ 1],
                                          lpw[ 0] );
                break;
            case 20:
                dwReturnValue = (* lpfn)( lpw[ 9], lpw[ 8], lpw[ 7], lpw[ 6],
                                          lpw[ 5], lpw[ 4], lpw[ 3], lpw[ 2],
                                          lpw[ 1], lpw[ 0] );
            case 22:
                dwReturnValue = (* lpfn)( lpw[10], lpw[ 9], lpw[ 8], lpw[ 7],
                                          lpw[ 6], lpw[ 5], lpw[ 4], lpw[ 3],
                                          lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 24:
                dwReturnValue = (* lpfn)( lpw[11], lpw[10], lpw[ 9], lpw[ 8],
                                          lpw[ 7], lpw[ 6], lpw[ 5], lpw[ 4],
                                          lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 26:
                dwReturnValue = (* lpfn)( lpw[12], lpw[11], lpw[10], lpw[ 9],
                                          lpw[ 8], lpw[ 7], lpw[ 6], lpw[ 5],
                                          lpw[ 4], lpw[ 3], lpw[ 2], lpw[ 1],
                                          lpw[ 0] );
                break;
            case 28:
                dwReturnValue = (* lpfn)( lpw[13], lpw[12], lpw[11], lpw[10],
                                          lpw[ 9], lpw[ 8], lpw[ 7], lpw[ 6],
                                          lpw[ 5], lpw[ 4], lpw[ 3], lpw[ 2],
                                          lpw[ 1], lpw[ 0] );
                break;
            case 30:
                dwReturnValue = (* lpfn)( lpw[14], lpw[13], lpw[12], lpw[11],
                                          lpw[10], lpw[ 9], lpw[ 8], lpw[ 7],
                                          lpw[ 6], lpw[ 5], lpw[ 4], lpw[ 3],
                                          lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            case 32:
                dwReturnValue = (* lpfn)( lpw[15], lpw[14], lpw[13], lpw[12],
                                          lpw[11], lpw[10], lpw[ 9], lpw[ 8],
                                          lpw[ 7], lpw[ 6], lpw[ 5], lpw[ 4],
                                          lpw[ 3], lpw[ 2], lpw[ 1], lpw[ 0] );
                break;
            default:
#ifdef DEBUG
            OutputDebugString("Wrong number of parameters\n");
#endif
                fFailed = TRUE;
                break;
        }
        if ( fFailed ) {
            continue;
        }

        wSuccess = (WORD)TRUE;

    } while( TRUE );

    return( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\wowexec.h ===
/****************************** Module Header ******************************\
* Module Name: exec.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Niblet's header file
*
* History:
* 04-13-91 ScottLu	Stolen from niblet sources
* 21-mar-92 mattfe	added stuff form win3.1 progman
\***************************************************************************/
#define NO_CALLPROC32_DECL
#include "windows.h"


/*
 * Resource defines
 */
#define WINDOWMENU          1
#define ID_WOWEXEC_ICON     2
#define ID_PARTY_DIALOG     3

#ifdef RC_INVOKED
#define ID(id) id
#else
#define ID(id) MAKEINTRESOURCE(id)
#endif

/*
 * Menu ID's
 */
#define MM_BREAK	8001
#define MM_ABOUT	8002
#define MM_EXIT         8003
#define MM_FAULT        8004
#define MM_WATSON       8005
#define MM_PARTY        8006
#define MM_GENTHUNK     8007

/*
 * Dialog control IDs
 */
#define IDD_PARTY_NUMBER   1
#define IDD_PARTY_STRING   2
#define IDD_PARTY_NUMLABEL 3
#define IDD_PARTY_STRLABEL 4

/* String Table Defines */
#define errTitle		0
#define IDS_BADPATHMSG3 	1
#define IDS_NOMEMORYMSG 	2
#define IDS_FILENOTFOUNDMSG	3
#define IDS_MANYOPENFILESMSG	4
#define IDS_NOASSOCMSG		5
#define IDS_ASSOCINCOMPLETE	6
#define IDS_MULTIPLEDSMSG	7
#define IDS_OS2APPMSG		8
#define IDS_NEWWINDOWSMSG	9
#define IDS_PMODEONLYMSG       10
#define IDS_ACCESSDENIED       11
#define IDS_DDEFAIL	       12
#define IDS_COMPRESSEDEXE      13
#define IDS_INVALIDDLL	       14
#define IDS_SHAREERROR	       15
#define IDS_BADPATHMSG	       16
#define	IDS_OOMEXITTITLE       17
#define	IDS_OOMEXITMSG	       18
#define IDS_UNKNOWNMSG	       19
#define IDS_EXECERRTITLE       20
#define	IDS_BADPATHTITLE       21
#define IDS_APPTITLE           22
#define IDS_SHAREDAPPTITLE     23
#define IDS_CANTLOADWIN32DLL   24

#define IDS_LAST               24       // Put New Strings Before this one


#ifdef JAPAN
#define MAXTITLELEN		42	/* Length of MessageBox titles */
#else
#define MAXTITLELEN		50	/* Length of MessageBox titles */
#endif
#define MAXMESSAGELEN		256	/* Length of MessageBox messages */
#define MAXITEMPATHLEN		64+16+48 /* Path + 8.3 + Drive(colon) + arguments */

/* PMDOS.ASM */
BOOL  FAR PASCAL IsReadOnly(LPSTR);
BOOL  FAR PASCAL PathType(LPSTR);
LONG  FAR PASCAL GetDOSErrorCode( void );
int   FAR PASCAL GetCurrentDrive(void);
int   FAR PASCAL SetCurrentDrive(WORD);
int   FAR PASCAL GetCurrentDirectory(WORD, LPSTR);
int   FAR PASCAL SetCurrentDirectory(LPSTR);
BOOL  FAR PASCAL IsRemoteDrive(int);
BOOL  FAR PASCAL IsRemovableDrive(int);
int   FAR PASCAL DosDelete(LPSTR);
int   FAR PASCAL DosRename(LPSTR, LPSTR);
LPSTR FAR PASCAL lmemmove(LPSTR, LPSTR, WORD);
DWORD FAR PASCAL FileTime(HANDLE);

typedef unsigned short USHORT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\wowexfax.c ===
//**************************************************************************
//  WOW fax support:
//       supports delrina winfax only
//                                                - nandurir  created
//**************************************************************************


#define NOGDI
#define PRINTDRIVER
#define _WOWFAX16_
#define DEFINE_DDRV_DEBUG_STRINGS
#include "wowexec.h"
#include "wowfax.h"

#define WOWDRV_BITBLT       MAKEINTRESOURCE(1)
#define WOWDRV_CONTROL      MAKEINTRESOURCE(3)
#define WOWDRV_DISABLE      MAKEINTRESOURCE(4)
#define WOWDRV_ENABLE       MAKEINTRESOURCE(5)
#define WOWDRV_EXTDEVMODE   MAKEINTRESOURCE(90)
#define WOWDRV_DEVCAPS      MAKEINTRESOURCE(91)

//**************************************************************************
// FaxWndProc
//
//    NOTE: the definitions such as 'BITMAP' struct is different in this
//          file. This file is compiled with NOGDI option so that the
//          printer driver versions of the structure get defined
//          (in gdidefs.inc). However we donot use printer drivers version
//          of such structures, particularly BITMAP.
//**************************************************************************

LONG FAR PASCAL FaxWndProc(HWND hwnd, WORD message, WORD hdc,
                                                LPWOWFAXINFO16 lpfaxinfo)
{
    LPPOINT lppt;
    HANDLE       hMem;
    RECT rc;
    HINSTANCE    hInst;
    WORD         wSize;
    LONG         lRet = (LONG)lpfaxinfo;
    WORD         wRet;
    char         szDriverFileName[MAXITEMPATHLEN+1];

#ifdef DEBUG
    char         szTmp[128];

    if ((message >= WM_DDRV_FIRST) && (message <= WM_DDRV_LAST)) {
        wsprintf(szTmp, "FaxWndProc, 0x%XH, %s, 0x%XH, 0x%lX\n", hwnd, (LPSTR) szWmDdrvDebugStrings[message - WM_DDRV_FIRST], hdc, lpfaxinfo);
        OutputDebugString((LPSTR) szTmp);
    }
#endif
 
    switch (message) {
        default:
            return DefWindowProc(hwnd, message, hdc, (LPARAM)lpfaxinfo);
            break;

        case WM_DDRV_INITFAXINFO16:
            // allocate and initialize lpfaxinfo

            hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                                     sizeof(WOWFAXINFO16));
            lpfaxinfo = (LPWOWFAXINFO16)GlobalLock(hMem);
            if (lpfaxinfo) {
                lpfaxinfo->hmem = hMem;
            }

            lRet = (LONG)lpfaxinfo;
            break;

        case WM_DDRV_ENABLE:
        case WM_DDRV_LOAD:
            // now load the drv - lpfaxinfo must have been initialized

            if (lpfaxinfo == (LPWOWFAXINFO16)NULL)
                break;

            lstrcpy(szDriverFileName, lpfaxinfo->lpDriverName);
            lstrcat(szDriverFileName, ".DRV");
            hInst = lpfaxinfo->hInst = LoadLibrary(szDriverFileName);

            if (hInst) {

                // store necessary info
                (FARPROC)lpfaxinfo->lpControl = GetProcAddress(hInst, WOWDRV_CONTROL);
                (FARPROC)lpfaxinfo->lpDisable = GetProcAddress(hInst, WOWDRV_DISABLE);
                (FARPROC)lpfaxinfo->lpEnable = GetProcAddress(hInst, WOWDRV_ENABLE);
                (FARPROC)lpfaxinfo->lpBitblt = GetProcAddress(hInst, WOWDRV_BITBLT);
                (FARPROC)lpfaxinfo->lpExtDMode = GetProcAddress(hInst, WOWDRV_EXTDEVMODE);
                (FARPROC)lpfaxinfo->lpDevCaps = GetProcAddress(hInst, WOWDRV_DEVCAPS);

                if (!lpfaxinfo->lpControl || !lpfaxinfo->lpDisable || !lpfaxinfo->lpEnable ||
                      !lpfaxinfo->lpBitblt || !lpfaxinfo->lpExtDMode || !lpfaxinfo->lpDevCaps) {

#ifdef DEBUG
                    wsprintf(szTmp, "FaxWndProc, Failed GetProcAddress on: %s\n", szDriverFileName);
                    OutputDebugString((LPSTR) szTmp);
#endif
                    lRet = 0;
                }
            }
            else {
#ifdef DEBUG
                wsprintf(szTmp, "FaxWndProc, Failed load of: %s\n", szDriverFileName);
                OutputDebugString((LPSTR) szTmp);
#endif
                lRet = 0;
            }
            if (message == WM_DDRV_LOAD || lRet == 0)
                break;

            // case WM_DDRV_ENABLE continues

            if (lpfaxinfo) {
                // win31 gdi calls 'enable' twice - first to get the gdiinfo struct and next to get
                // pdevice struct
                wRet = (*lpfaxinfo->lpEnable)(lpfaxinfo->lpOut, InquireInfo,
                                           lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName, lpfaxinfo->lpIn);
#ifdef DEBUG
                if (!wRet) {
                    wsprintf(szTmp, "FaxWndProc, Enable InquireInfo Failed: %s, %s\n", szDriverFileName, lpfaxinfo->lpPortName);
                    OutputDebugString((LPSTR) szTmp);
                }
#endif
                hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                                      ((LPGDIINFO)lpfaxinfo->lpOut)->dpDEVICEsize);
                lpfaxinfo->hmemdevice = hMem;
                lpfaxinfo->lpDevice = GlobalLock(hMem);
                if (!lpfaxinfo->lpDevice) {
#ifdef DEBUG
                    wsprintf(szTmp, "FaxWndProc, GlobalAlloc Failed: 0x%lX\n", ((LPGDIINFO)lpfaxinfo->lpOut)->dpDEVICEsize);
                    OutputDebugString((LPSTR) szTmp);
#endif
                    return(0);
                }
                wRet = (*lpfaxinfo->lpEnable)(lpfaxinfo->lpDevice, EnableDevice,
                                           lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName, lpfaxinfo->lpIn);
#ifdef DEBUG
                if (!wRet) {
                    wsprintf(szTmp, "FaxWndProc, Enable, EnableDevice Failed: %s, %s\n", szDriverFileName, lpfaxinfo->lpPortName);
                    OutputDebugString((LPSTR) szTmp);
                }
#endif
                lppt = (LPPOINT)((LPSTR)lpfaxinfo->lpOut + sizeof(GDIINFO16));
                lppt->x = lppt->y = 0;
                wRet = (*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice, GETPRINTINGOFFSET, 0, lppt);
#ifdef DEBUG
                if (!wRet) {
                    OutputDebugString((LPSTR) "FaxWndProc, Control GETPRINTINGOFFSET Failed\n");
                }
#endif
                lpfaxinfo->flState |= WFINFO16_ENABLED;
            }
            break;

        case WM_DDRV_STARTDOC:
            if (lpfaxinfo) {
                lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice,
                                             SETPRINTERDC, (LPSTR)&hdc, 0);
                if (lRet) {
                    // EasyFax Ver2.0 support
                    // Also Procomm+ 3 cover sheets.  Bug #305665
                    lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice,
                                             STARTDOC, (LPSTR)lpfaxinfo->szDocName, 0);

#ifdef DEBUG
                    if (lRet < 0) {
                        OutputDebugString((LPSTR) "FaxWndProc, Control STARTDOC Failed\n");
                    }
#endif
                }
#ifdef DEBUG
                else {
                    OutputDebugString((LPSTR) "FaxWndProc, Control SETPRINTERDC Failed\n");
                }
#endif
            }
            break;

        case WM_DDRV_PRINTPAGE:
            if (lpfaxinfo) {
                for (;;) {
                    lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice,
                                              NEXTBAND, NULL, (LPSTR)&rc);
                    if (lRet < 0) {
#ifdef DEBUG
                        OutputDebugString((LPSTR) "FaxWndProc, Control NEXTBAND Failed\n");
#endif
                        break;
                    }

                    if (rc.left || rc.top || rc.right || rc.bottom) {
                        wRet = (*lpfaxinfo->lpBitblt)(lpfaxinfo->lpDevice, rc.left, rc.top,
                                     NULL, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                                    SRCCOPY, NULL, NULL);
#ifdef DEBUG
                        if (!wRet) {
                            OutputDebugString((LPSTR) "FaxWndProc, BitBlt Failed\n");
                        }
#endif
                    }
                    else {
                        break;
                    }
                }
            }

            break;

        case WM_DDRV_ENDDOC:
            if (lpfaxinfo) {
                lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice, ENDDOC, 0, 0);
#ifdef DEBUG
                if (lRet <= 0) {
                    OutputDebugString((LPSTR) "FaxWndProc, Control ENDDOC Failed\n");
                }
#endif
            }
            break;

        case WM_DDRV_ESCAPE:
            if (lpfaxinfo) {
                lRet = (LONG)(*lpfaxinfo->lpControl)(lpfaxinfo->lpDevice, lpfaxinfo->wCmd, 0, 0);
#ifdef DEBUG
                if (lRet <= 0) {
                    wsprintf(szTmp, "FaxWndProc, Escape %X Failed\n", lpfaxinfo->wCmd);
                    OutputDebugString((LPSTR) szTmp);
                }
#endif
            }
            break;

        case WM_DDRV_DISABLE:
            if (lpfaxinfo) {

                if (lpfaxinfo->flState & WFINFO16_ENABLED) {
                    (*lpfaxinfo->lpDisable)(lpfaxinfo->lpDevice);
                }

                GlobalUnlock(lpfaxinfo->hmemdevice);
                GlobalFree(lpfaxinfo->hmemdevice);
            }

            lRet = 0;

            // fall through

        case WM_DDRV_UNLOAD:

            if (lpfaxinfo) {
                if (lpfaxinfo->hInst) {
                    FreeLibrary(lpfaxinfo->hInst);
                }
            }

            lRet = 0;

            // fall through

        case WM_DDRV_FREEFAXINFO16:

            if  (lpfaxinfo) {
                GlobalUnlock(lpfaxinfo->hmem);
                GlobalFree(lpfaxinfo->hmem);
                lpfaxinfo = (LPWOWFAXINFO16)NULL;
            }

            lRet = 0;
            break;

        case WM_DDRV_EXTDMODE:
            if (lpfaxinfo) {
                lRet = (*lpfaxinfo->lpExtDMode)(lpfaxinfo->hwndui, lpfaxinfo->hInst,
                                             lpfaxinfo->lpOut, lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName,
                                             lpfaxinfo->lpIn, 0, lpfaxinfo->wCmd);
            }
            break;

        case WM_DDRV_DEVCAPS:
            if (lpfaxinfo) {
                lRet = (*lpfaxinfo->lpDevCaps)(lpfaxinfo->szDeviceName, lpfaxinfo->lpPortName,
                                                       lpfaxinfo->wCmd, lpfaxinfo->lpOut, 0);
            }
            break;

    }

    return lRet;
}

//**************************************************************************
// FaxInit
//
//**************************************************************************


HWND FaxInit(HINSTANCE hInst)
{
    WNDCLASS wc;

    // Make sure we only allow one FaxWndProc to handle WowFax messages

    if (FindWindow(WOWFAX_CLASS, NULL)) {
        return((HWND)0);
    }

    wc.style            = 0;
    wc.lpfnWndProc      = (WNDPROC)FaxWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInst;
    wc.hIcon            = 0;
    wc.hCursor          = 0;
    wc.hbrBackground    = 0;
    wc.lpszMenuName     = 0;
    wc.lpszClassName    = WOWFAX_CLASS;

    if (!RegisterClass(&wc)) {
        return (HWND)0;
    }

    return CreateWindow(wc.lpszClassName, "", WS_OVERLAPPEDWINDOW,
                                0, 0, 0, 0, NULL, NULL, hInst, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\wowexec.c ===
/****************************** Module Header ******************************\
* Module Name: wowexec.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* WOWEXEC - 16 Bit Server Task - Does Exec Calls on Behalf of 32 bit CreateProcess
*
*
* History:
* 05-21-91 MattFe       Ported to Windows
* mar-20-92 MattFe      Added Error Message Boxes (from win 3.1 progman)
* apr-1-92 mattfe       added commandline exec and switch to path (from win 3.1 progman)
* jun-1-92 mattfe       changed wowgetnextvdmcommand
* 12-Nov-93 DaveHart    Multiple WOW support and remove captive
*                       GetNextVDMCommand thread from WOW32.
* 16-Nov-93 DaveHart    Reduce data segment size.
\***************************************************************************/
#include "wowexec.h"
#include "wowinfo.h"
#include "shellapi.h"
#ifndef PULONG
#define PULONG
#endif
#include "vint.h"
#include "dde.h"


/*
 * External Prototypes
 */
extern WORD FAR PASCAL WOWQueryDebug( void );
extern WORD FAR PASCAL WowWaitForMsgAndEvent( HWND);
extern void FAR PASCAL WowMsgBox(LPSTR szMsg, LPSTR szTitle, DWORD dwOptionalStyle);
extern DWORD FAR PASCAL WowPartyByNumber(DWORD dw, LPSTR psz);
extern DWORD FAR PASCAL WowKillTask(WORD htask);
extern void FAR PASCAL WowShutdownTimer(WORD fEnable);
HWND FaxInit(HINSTANCE hInst);

/*
 * Global Variables
 */
HANDLE hAppInstance;
HWND ghwndMain = NULL;
HWND ghwndEdit = NULL;
char    szOOMExitTitle[32+1];
char    szOOMExitMsg[64+1];
char    szAppTitleBuffer[32];
LPSTR   lpszAppTitle = szAppTitleBuffer;
char    szWindowsDirectory[MAXITEMPATHLEN+1];
char    szOriginalDirectory[MAXITEMPATHLEN+1];
BOOL    gfSharedWOW = FALSE;
BOOL    gfInjectedWOW = FALSE;
WORD    gwFirstCmdShow;



/*
 * Forward declarations.
 */
BOOL InitializeApp(LPSTR lpszCommandLine);
LONG FAR PASCAL WndProc(HWND hwnd, WORD message, WORD wParam, LONG lParam);
WORD NEAR PASCAL ExecProgram(PWOWINFO pWowInfo);
BOOL NEAR PASCAL ExecApplication(PWOWINFO pWowInfo);
void NEAR PASCAL MyMessageBox(WORD idTitle, WORD idMessage, LPSTR psz);
PSTR FAR PASCAL GetFilenameFromPath( PSTR szPath );
void NEAR PASCAL GetPathInfo ( PSTR szPath, PSTR *pszFileName, PSTR *pszExt, WORD *pich, BOOL *pfUnc);
BOOL NEAR PASCAL StartRequestedApp(VOID);
#ifdef DEBUG
BOOL FAR PASCAL PartyDialogProc(HWND hDlg, WORD msg, WORD wParam, LONG lParam);
#endif

#define AnsiNext(x) ((x)+1)

typedef struct PARAMETERBLOCK {
    WORD    wEnvSeg;
    LPSTR   lpCmdLine;
    LPVOID  lpCmdShow;
    DWORD   dwReserved;
} PARAMETERBLOCK, *PPARAMETERBLOCK;

typedef struct CMDSHOW {
    WORD    two;
    WORD    nCmdShow;
} CMDSHOW, *PCMDSHOW;

#define CCHMAX 260+13  // MAX_PATH plus 8.3 plus NULL

#define ERROR_ERROR         0
#define ERROR_FILENOTFOUND  2
#define ERROR_PATHNOTFOUND  3
#define ERROR_MANYOPEN      4
#define ERROR_DYNLINKSHARE  5
#define ERROR_LIBTASKDATA   6
#define ERROR_MEMORY        8
#define ERROR_VERSION       10
#define ERROR_BADEXE        11
#define ERROR_OTHEREXE      12
#define ERROR_DOS4EXE       13
#define ERROR_UNKNOWNEXE    14
#define ERROR_RMEXE         15
#define ERROR_MULTDATAINST  16
#define ERROR_PMODEONLY     18
#define ERROR_COMPRESSED    19
#define ERROR_DYNLINKBAD    20
#define ERROR_WIN32         21

/* FindPrevInstanceProc -
 * A little enumproc to find any window (EnumWindows) which has a
 * matching EXE file path.  The desired match EXE pathname is pointed to
 * by the lParam.  The found window's handle is stored in the
 * first word of this buffer.
 */

BOOL CALLBACK FindPrevInstanceProc(HWND hWnd, LPSTR lpszParam)
{
    char szT[CCHMAX];
    HANDLE hInstance;

    // Filter out invisible and disabled windows
    //

    if (!IsWindowEnabled(hWnd) || !IsWindowVisible(hWnd))
        return TRUE;

    hInstance = GetWindowWord(hWnd, GWW_HINSTANCE);
    GetModuleFileName(hInstance, szT, sizeof (szT)-1);

    // Make sure that the hWnd belongs to the current VDM process
    //
    // GetWindowTask returns the wowexec htask16 if the window belongs
    // to a different process - thus we filter out windows in
    // 'separate VDM' processes.
    //                                                     - nanduri

    if (lstrcmpi(szT, lpszParam) == 0 &&
        GetWindowTask(hWnd) != GetWindowTask(ghwndMain)) {
        *(LPHANDLE)lpszParam = hWnd;
        return FALSE;
    }
    else {
        return TRUE;
    }
}

HWND near pascal FindPopupFromExe(LPSTR lpExe)
{
    HWND hwnd = (HWND)0;
    BOOL b;

    b = EnumWindows(FindPrevInstanceProc, (LONG)(LPSTR)lpExe);
    if (!b && (hwnd = *(LPHANDLE)(LPSTR)lpExe))  {
        // Find a "main" window that is the ancestor of a given window
        //

        HWND hwndT;

        // First go up the parent chain to find the popup window.  Then go
        // up the owner chain to find the main window
        //

        while (hwndT = GetParent(hwnd))
             hwnd = hwndT;

        while (hwndT = GetWindow(hwnd, GW_OWNER))
             hwnd = hwndT;
    }

    return hwnd;
}

WORD ActivatePrevInstance(LPSTR lpszPath)
{
    HWND hwnd;
    HINSTANCE ret = IDS_MULTIPLEDSMSG;

    if (hwnd = FindPopupFromExe(lpszPath)) {
        if (IsIconic(hwnd)) {
            ShowWindow(hwnd,SW_SHOWNORMAL);
        }
        else {
            HWND hwndT = GetLastActivePopup(hwnd);
            BringWindowToTop(hwnd);
            if (hwndT && hwnd != hwndT)
                BringWindowToTop(hwndT);
        }
        ret = 0;
    }

    return (ret);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ExecProgram() -                                                         */
/*                                                                          */
/* Taken from Win 3.1 Progman -maf                                          */
/*--------------------------------------------------------------------------*/

/* Returns 0 for success.  Otherwise returns a IDS_ string code. */

WORD NEAR PASCAL ExecProgram(PWOWINFO pWowInfo)
{
  WORD    ret;
  PARAMETERBLOCK ParmBlock;
  CMDSHOW CmdShow;
  char  CmdLine[CCHMAX];

  ret = 0;

  // Don't mess with the mouse state; unless we're on a mouseless system.
  if (!GetSystemMetrics(SM_MOUSEPRESENT))
      ShowCursor(TRUE);

  //
  // prepare the dos style cmd line (counted pascal string)
  // pWowInfo->lpCmdLine contains the command tail (excluding argv[0])
  //
  CmdLine[0] = lstrlen(pWowInfo->lpCmdLine) - 2;
  lstrcpy( &CmdLine[1], pWowInfo->lpCmdLine);

  // We have a WOWINFO structure, then use it to pass the correct environment

  ParmBlock.wEnvSeg = HIWORD(pWowInfo->lpEnv);
  ParmBlock.lpCmdLine = CmdLine;
  ParmBlock.lpCmdShow = &CmdShow;
  CmdShow.two = 2;
  CmdShow.nCmdShow = pWowInfo->wShowWindow;

  ParmBlock.dwReserved = NULL;

  ret = LoadModule(pWowInfo->lpAppName,(LPVOID)&ParmBlock) ;

  switch (ret)
    {
      case ERROR_ERROR:
      case ERROR_MEMORY:
          ret = IDS_NOMEMORYMSG;
          break;

      case ERROR_FILENOTFOUND:
          ret = IDS_FILENOTFOUNDMSG;
          break;

      case ERROR_PATHNOTFOUND:
          ret = IDS_BADPATHMSG;
          break;

      case ERROR_MANYOPEN:
          ret = IDS_MANYOPENFILESMSG;
          break;

      case ERROR_DYNLINKSHARE:
          ret = IDS_ACCESSDENIED;
          break;

      case ERROR_VERSION:
          ret = IDS_NEWWINDOWSMSG;
          break;

      case ERROR_RMEXE:
          /* KERNEL has already put up a messagebox for this one. */
          ret = 0;
          break;

      case ERROR_MULTDATAINST:
          ret = ActivatePrevInstance(pWowInfo->lpAppName);
          break;

      case ERROR_COMPRESSED:
          ret = IDS_COMPRESSEDEXE;
          break;

      case ERROR_DYNLINKBAD:
          ret = IDS_INVALIDDLL;
          break;

      case SE_ERR_SHARE:
          ret = IDS_SHAREERROR;
          break;

      case ERROR_WIN32:
          ret = IDS_CANTLOADWIN32DLL;
          break;

      //
      // We shouldn't get any of the following errors,
      // so the strings have been removed from the resource
      // file.  That's why there's the OutputDebugString
      // on checked builds only.
      //

#ifdef DEBUG
      case ERROR_OTHEREXE:
      case ERROR_PMODEONLY:
      case SE_ERR_ASSOCINCOMPLETE:
      case SE_ERR_DDETIMEOUT:
      case SE_ERR_DDEFAIL:
      case SE_ERR_DDEBUSY:
      case SE_ERR_NOASSOC:
          {
              char szTmp[64];
              wsprintf(szTmp, "WOWEXEC: Unexpected error %d executing app, fix that code!\n", (int)ret);
              OutputDebugString(szTmp);
          }
          //
          // fall through to default case, so the execution
          // is the same as on the free build.
          //
#endif

      default:
          if (ret < 32)
              goto EPExit;
          ret = 0;
    }

EPExit:

  if (!GetSystemMetrics(SM_MOUSEPRESENT)) {
      /*
       * We want to turn the mouse off here on mouseless systems, but
       * the mouse will already have been turned off by USER if the
       * app has GP'd so make sure everything's kosher.
       */
      if (ShowCursor(FALSE) != -1)
          ShowCursor(TRUE);
  }

  return(ret);
}

/***************************************************************************\
* ExecApplication
*
* Code Taken From Win 3.1 ExecItem()
*
\***************************************************************************/

#define TDB_PDB_OFFSET  0x60
#define PDB_ENV_OFFSET  0x2C

BOOL NEAR PASCAL ExecApplication(PWOWINFO pWowInfo)
{

    WORD    ret;
    LPSTR   szEnv;
    LPSTR   szEnd;
    BYTE    bDrive;
    WORD    wSegEnvSave;
    HANDLE  hTask;
    LPSTR   lpTask;
    HANDLE  hPDB;
    LPSTR   lpPDB;
    HANDLE  hNewEnv;

    int     nLength;
    int     nNewEnvLength;
    LPSTR   lpstrEnv;
    LPSTR   lpstr;
    LPSTR   lpOriginalEnv;
    BOOL    bBlanks;
    LPSTR   szEnvTmp;


    if (!pWowInfo) {
        return FALSE;
        }

    //
    // Seup the environment from WOWINFO record from getvdmcommand
    //


    // Figure out who we are (so we can edit our PDB/PSP)

    hTask = GetCurrentTask();
    lpTask = GlobalLock( hTask );
    if ( lpTask == NULL ) {
        ret = IDS_NOMEMORYMSG;
        goto punt;
    }

    hPDB = *((LPWORD)(lpTask + TDB_PDB_OFFSET));
    lpPDB = GlobalLock( hPDB );

    // Save our environment block
    wSegEnvSave = *((LPWORD)(lpPDB + PDB_ENV_OFFSET));


    // Now determine the length of the original env

    lpOriginalEnv = (LPSTR)MAKELONG(0,wSegEnvSave);

    do {
        nLength = lstrlen(lpOriginalEnv);
        lpOriginalEnv += nLength + 1;
    } while ( nLength != 0 );

    lpOriginalEnv += 2;         // Skip over magic word, see comment below

    nNewEnvLength = 4 + lstrlen(lpOriginalEnv); // See magic comments below!

    // WOW Apps cannot deal with an invalid TEMP=c:\bugusdir directory
    // Usually on Win 3.1 the TEMP= is checked in ldboot.asm check_temp
    // routine.   However on NT since we get a new environment with each
    // WOW app it means that we have to check it here.   If it is not
    // valid then it is edited in the environment.
    //      - mattfe june 11 93

    szEnv = pWowInfo->lpEnv;
    szEnd = szEnv + pWowInfo->EnvSize;
    szEnd--;

    while ( szEnv < szEnd ) {

       nLength = lstrlen(szEnv) + 1;

       if (  (*szEnv == 'T') &&
         (*(szEnv+1) == 'E') &&
         (*(szEnv+2) == 'M') &&
         (*(szEnv+3) == 'P') &&
         (*(szEnv+4) == '=') )  {

            // Try to set the current directory to the TEMP= dir
            // If it fails then nuke the TEMP= part of the environment
            // in the same way check_TEMP does in ldboot.asm
            // We also scan for blanks, just like check_TEMP

            bBlanks = FALSE;
            szEnvTmp = szEnv+5;
            while (*szEnvTmp != 0) {
                if (*szEnvTmp == ' ') {
                    bBlanks = TRUE;
                    break;
                }
                szEnvTmp++;
            }

            if (bBlanks || (SetCurrentDirectory(szEnv+5) )) {
                while (*szEnv != 0) {
                    *szEnv = 'x';
                    szEnv++;
                }
            }
       break;
       }
       szEnv += nLength;
    }

    // WOW Apps only have a Single Current Directory
    // Find =d:=D:\path where d is the active drive letter
    // Note that the drive info doesn have to be at the start
    // of the environment.

    bDrive = pWowInfo->CurDrive + 'A';
    szEnv = pWowInfo->lpEnv;
    szEnd = szEnv + pWowInfo->EnvSize;
    szEnd--;

    while ( szEnv < szEnd ) {

       nLength = lstrlen(szEnv) + 1;
       if ( *szEnv == '=' ) {
            if ( (bDrive == (*(szEnv+1) & 0xdf)) &&
                 (*(szEnv+2) == ':') && (*(szEnv+3) == '=') ) {
                SetCurrentDirectory(szEnv+4);
            }
       } else {
            nNewEnvLength += nLength;
       }
       szEnv += nLength;
    }

    // Now allocate and make a personal copy of the Env

    hNewEnv = GlobalAlloc( GMEM_MOVEABLE, (DWORD)nNewEnvLength );
    if ( hNewEnv == NULL ) {
        ret = IDS_NOMEMORYMSG;
        goto punt;
    }
    lpstrEnv = GlobalLock( hNewEnv );
    if ( lpstrEnv == NULL ) {
        GlobalFree( hNewEnv );
        ret = IDS_NOMEMORYMSG;
        goto punt;
    }

    // Copy only the non-current directory env variables

    szEnv = pWowInfo->lpEnv;
    lpstr = lpstrEnv;

    while ( szEnv < szEnd ) {
        nLength = lstrlen(szEnv) + 1;

        // Copy everything except the drive letters

        if ( *szEnv != '=' ) {
            lstrcpy( lpstr, szEnv );
            lpstr += nLength;
        }
        szEnv += nLength;
    }
    *lpstr++ = '\0';          // Extra '\0' on the end

    // Magic environment goop!
    //
    // Windows only supports the passing of environment information
    // using the LoadModule API.  The WinExec API just causes
    // the application to inherit the current DOS PDB's environment.
    //
    // Also, the environment block has a little gotcha at the end.  Just
    // after the double-nuls there is a magic WORD value 0x0001 (DOS 3.0
    // and later).  After the value is a nul terminated string indicating
    // the applications executable file name (including PATH).
    //
    // We copy the value from WOWEXEC's original environment because
    // that is what WinExec appears to do.
    //
    // -BobDay

    *lpstr++ = '\1';
    *lpstr++ = '\0';        // Magic 0x0001 from DOS

    lstrcpy( lpstr, lpOriginalEnv );    // More Magic (see comment above)

    // Temporarily update our environment block

    *((LPWORD)(lpPDB + PDB_ENV_OFFSET)) = (WORD)hNewEnv | 1;

    pWowInfo->lpEnv = lpstrEnv;


    //
    // Set our current drive & directory as requested.
    //

    SetCurrentDirectory(pWowInfo->lpCurDir);

    ret = ExecProgram(pWowInfo);

    // Restore our environment block

    *((LPWORD)(lpPDB + PDB_ENV_OFFSET)) = wSegEnvSave;

    GlobalUnlock( hPDB );
    GlobalUnlock( hTask );
    GlobalUnlock( hNewEnv );
    GlobalFree( hNewEnv );


punt:

    // Change back to the Windows Directory
    // So that if we are execing from a NET Drive its
    // Not kept Active

    SetCurrentDirectory(szWindowsDirectory);

    //  Always call this when we are done try to start an app.
    //  It will do nothing if we were successful in starting an
    //  app, otherwise if we were unsucessful it will signal that
    //  the app has completed.
    WowFailedExec();

    // Check for errors.
    if (ret) {
        MyMessageBox(IDS_EXECERRTITLE, ret, pWowInfo->lpAppName);

        if ( ! gfSharedWOW) {

            //
            // We have just failed to exec the only app we are going to
            // try to exec in this separate WOW VDM.  We need to end WOW
            // here explicitly, otherwise we'll hang around forever because
            // the normal path is for kernel to exit the VDM when a task
            // exit causes the number of tasks to transition from 2 to 1 --
            // in this case the number of tasks never exceeds 1.
            //

            ExitKernelThunk(0);

        }
    }

    return(ret);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyMessageBox() -                                                        */
/*  Taken From Win 3.1 Progman - maf                                        */
/*--------------------------------------------------------------------------*/

void NEAR PASCAL MyMessageBox(WORD idTitle, WORD idMessage, LPSTR psz)
{
  char szTitle[MAXTITLELEN+1];
  char szMessage[MAXMESSAGELEN+1];
  char szTempField[MAXMESSAGELEN+1];


  if (!LoadString(hAppInstance, idTitle, szTitle, sizeof(szTitle)))
      goto MessageBoxOOM;

  if (idMessage > IDS_LAST)
    {
      if (!LoadString(hAppInstance, IDS_UNKNOWNMSG, szTempField, sizeof(szTempField)))
          goto MessageBoxOOM;
      wsprintf(szMessage, szTempField, idMessage);
    }
  else
    {
      if (!LoadString(hAppInstance, idMessage, szTempField, sizeof(szTempField)))
          goto MessageBoxOOM;

      if (psz)
          wsprintf(szMessage, szTempField, (LPSTR)psz);
      else
          lstrcpy(szMessage, szTempField);
    }

  WowMsgBox(szMessage, szTitle, MB_ICONEXCLAMATION);
  return;


MessageBoxOOM:
  WowMsgBox(szOOMExitMsg, szOOMExitTitle, MB_ICONHAND);

  return ;
}



/***************************************************************************\
* main
*
*
* History:
* 04-13-91 ScottLu      Created - from 32 bit exec app
* 21-mar-92 mattfe      significant alterations for WOW
\***************************************************************************/

int PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance, LPSTR lpszCmdLine, int iCmd)

{
    int     i;
    MSG     msg;
    LPSTR   pch,pch1;
    WORD    ret;
    WOWINFO wowinfo;
    char    aszWOWDEB[CCHMAX];
    LPSTR   pchWOWDEB;
    HANDLE  hMMDriver;
    char    szLoad[CCHMAX];
    int     iPastSystem32Pos;
    char    szBuffer[150];
    BOOL    bFinished;
    int     iStart;
    int     iEnd;

#define PATH_32_WHACK    "32\\"

    hAppInstance = hInstance ;

    // Only Want One WOWExec
    if (hPrevInstance != NULL) {
        return(FALSE);
    }

    if (!InitializeApp(lpszCmdLine)) {
        OutputDebugString("WOWEXEC: InitializeApp failure!\n");
        return 0;
    }

    iPastSystem32Pos = GetSystemDirectory((LPSTR)&szLoad, sizeof(szLoad));

    //
    // Make sure to have room for 32\filename.ext\0
    //
    if (iPastSystem32Pos == 0 || iPastSystem32Pos >= CCHMAX-1-3-1-8-1-3-1) {
        OutputDebugString("WOWEXEC: Bad system32 directory!\n");
        return 0;
    }

    lstrcpyn( &(szLoad[iPastSystem32Pos]), PATH_32_WHACK, sizeof(PATH_32_WHACK));
    iPastSystem32Pos += sizeof(PATH_32_WHACK)-1;

/*
 * Look for a drivers= line in the [boot] section of SYSTEM.INI
 * If present it is the 16 bit MultiMedia interface, so load it
 */

    /* Load DDL's from DRIVERS section in system.ini
     */
    GetPrivateProfileString( (LPSTR)"boot",      /* [Boot] section */
                            (LPSTR)"drivers",   /* Drivers= */
                            (LPSTR)"",          /* Default if no match */
                            szBuffer,    /* Return buffer */
                            sizeof(szBuffer),
                            (LPSTR)"system.ini" );

    if (!*szBuffer) {
        goto Done;
    }

    bFinished = FALSE;
    iStart    = 0;

    while (!bFinished) {
        iEnd = iStart;

        while (szBuffer[iEnd] && (szBuffer[iEnd] != ' ') &&
               (szBuffer[iEnd] != ',')) {
            iEnd++;
        }

        if (szBuffer[iEnd] == NULL) {
            bFinished = TRUE;
        }
        else {
            szBuffer[iEnd] = NULL;
        }

        /* Load and enable the driver.
         */
        OpenDriver( &(szBuffer[iStart]), NULL, NULL );
        iStart = iEnd + 1;
    }

Done:

/*
 * Look for a debug= line in the [boot] section of SYSTEM.INI
 * If present it is the 16 bit MultiMedia interface, so load it
 */

    if ( !gfInjectedWOW && (WOWQueryDebug() & 0x0001)!=0 ) {
        pchWOWDEB = "WOWDEB.EXE";
    } else {
        pchWOWDEB = "";
    }

    GetPrivateProfileString((LPSTR)"boot", (LPSTR)"debug",pchWOWDEB, aszWOWDEB, sizeof(aszWOWDEB), (LPSTR)"SYSTEM.INI");
    aszWOWDEB[sizeof(aszWOWDEB)-1] = '\0';

    if ( lstrlen(pchWOWDEB) != 0 ) {
        if (lstrcmp(pchWOWDEB, aszWOWDEB) == 0) {
            lstrcpyn(&(szLoad[iPastSystem32Pos]), pchWOWDEB, sizeof("WOWDEB.EXE"));
            WinExec((LPSTR)szLoad,SW_SHOW);
        } else {
            WinExec((LPSTR)aszWOWDEB,SW_SHOW);
        }
    }

#if 0
/*  Preload winspool.exe.   Apps will keep loading and freeing it
 *  which is slow.   We might as well load it now so the reference
 *  count is 1 so it will never be loaded or freed
 */
    //
    // Disabled load of winspool.exe to save 8k.  Size vs. speed,
    // which one do we care about?  Right now, size!
    //
    LoadLibrary("WINSPOOL.EXE");
#endif

    // Always load SHELL.DLL, FileMaker Pro and Lotus Install require it.

    lstrcpyn(&(szLoad[iPastSystem32Pos]), "SHELL.DLL", sizeof("SHELL.DLL"));
    LoadLibrary(szLoad);

    //
    // Start any apps pending in basesrv queue
    //

    while (StartRequestedApp() && gfSharedWOW) {
        /* null stmt */ ;
    }


    while (1)  {

        WowWaitForMsgAndEvent(ghwndMain);
           
        //    
        // Always check for messages
        // 

        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) &&
            msg.message != WM_WOWEXECHEARTBEAT )
           {
            if (msg.message != WM_QUIT) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return 1;
}


/***************************************************************************\
* InitializeApp
*
* History:
* 04-13-91 ScottLu      Created.
\***************************************************************************/

BOOL InitializeApp(LPSTR lpszCommandLine)
{
    WNDCLASS wc;
    int cyExecStart, cxExecStart;
    USHORT TitleLen, cbCopy;
    HWND  hwndFax;
    int   lResult;


    // Remove Real Mode Segment Address

    wc.style            = 0;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hAppInstance;
    wc.hIcon            = LoadIcon(hAppInstance, MAKEINTRESOURCE(ID_WOWEXEC_ICON));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = GetStockObject(WHITE_BRUSH);
    wc.lpszClassName    = "WOWExecClass";
#ifdef DEBUG
    wc.lpszMenuName     = "MainMenu";
#else
    wc.lpszMenuName     = NULL;
#endif

    if (!RegisterClass(&wc)) {
        OutputDebugString("WOWEXEC: RegisterClass failed\n");
        return FALSE;
    }

    /* Load these strings now.  If we need them later, we won't be able to load
     * them at that time.
     */
    LoadString(hAppInstance, IDS_OOMEXITTITLE, szOOMExitTitle, sizeof(szOOMExitTitle));
    LoadString(hAppInstance, IDS_OOMEXITMSG, szOOMExitMsg, sizeof(szOOMExitMsg));
    LoadString(hAppInstance, IDS_APPTITLE, szAppTitleBuffer, sizeof(szAppTitleBuffer));

    ghwndMain = CreateWindow("WOWExecClass", lpszAppTitle,
            WS_OVERLAPPED | WS_CAPTION | WS_BORDER | WS_THICKFRAME |
            WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_CLIPCHILDREN |
            WS_SYSMENU,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, hAppInstance, NULL);

    if (ghwndMain == NULL ) {
#ifdef DEBUG
        OutputDebugString("WOWEXEC: ghwndMain Null\n");
#endif
        return FALSE;
    }

    hwndFax = FaxInit(hAppInstance);

    //
    // Give our window handle to BaseSrv, which will post WM_WOWEXECSTARTAPP
    // messages when we have commands to pick up.  The return value tells
    // us if we are the shared WOW VDM or not (a seperate WOW VDM).
    // We also pick up the ShowWindow parameter (SW_SHOW, SW_MINIMIZED, etc)
    // for the first WOW app here.  Subsequent ones we get from BaseSrv.
    //

         //
         // gwFirstCmdShow is no longer used, and is available.
         //

    lResult = WOWRegisterShellWindowHandle(ghwndMain,
                                               &gwFirstCmdShow,
                                               hwndFax
                                               );

    if (lResult < 0) {
       gfInjectedWOW=TRUE;
    } else if (lResult > 0) {
       gfSharedWOW=TRUE;
    }



    //
    // If this isn't the shared WOW, tell the kernel to exit when the
    // last app (except WowExec) exits.
    //

    if (!gfSharedWOW) {
        WowSetExitOnLastApp(TRUE);
    }

      /* Remember the original directory. */
    GetCurrentDirectory(NULL, szOriginalDirectory);
    GetWindowsDirectory(szWindowsDirectory, MAXITEMPATHLEN+1);

#ifdef DEBUG

    ShowWindow(ghwndMain, SW_MINIMIZE);

    //
    // If this is the shared WOW, change the app title string to
    // reflect this and change the window title.
    //

    if (gfSharedWOW) {

        LoadString(hAppInstance, IDS_SHAREDAPPTITLE, szAppTitleBuffer, sizeof(szAppTitleBuffer));

    }

    SetWindowText(ghwndMain, lpszAppTitle);
    UpdateWindow(ghwndMain);

#endif

    return TRUE;
}


/***************************************************************************\
* WndProc
*
* History:
* 04-07-91 DarrinM      Created.
\***************************************************************************/

LONG FAR PASCAL WndProc(
    HWND hwnd,
    WORD message,
    WORD wParam,
    LONG lParam)
{
    char chbuf[50];
    HICON hIcon;

    switch (message) {
    case WM_CREATE:
        break;

    case WM_DESTROY:
        // ignore since wowexec must stay around
        return 0;

#ifdef DEBUG
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
            case MM_ABOUT:
                LoadString(hAppInstance, errTitle, (LPSTR)chbuf, sizeof(chbuf));
                hIcon = LoadIcon(hAppInstance, MAKEINTRESOURCE(ID_WOWEXEC_ICON));
                ShellAbout(ghwndMain, (LPSTR)chbuf, (LPSTR)lpszAppTitle, hIcon);
            break;

            case MM_BREAK:
                _asm int 3
            break;

            case MM_FAULT:
                _asm mov cs:0,ax
            break;

            case MM_EXIT:
                ExitKernelThunk(0);
            break;

            case MM_WATSON:
                WinExec("drwatson", SW_MINIMIZE );
            break;

            case MM_PARTY:
            {
                FARPROC lpPartyDialogProc;

                lpPartyDialogProc = MakeProcInstance(PartyDialogProc, hAppInstance);

                DialogBox(hAppInstance, MAKEINTRESOURCE(ID_PARTY_DIALOG),
                          hwnd, lpPartyDialogProc);

                FreeProcInstance(lpPartyDialogProc);
            }
            break;

            case MM_GENTHUNK:
            {
                DWORD FAR PASCAL CallProc32W(DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD, DWORD,
                                             DWORD, DWORD, DWORD
                                             );

#define BIT(bitpos)  ((DWORD)1 << bitpos)

                DWORD hmodKernel32, hmodUser32, hmodWow32;
                DWORD pfn32;
                DWORD dw16, dw32;
                DWORD p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
                      p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                      p21, p22, p23, p24, p25, p26, p27, p28, p29, p30,
                      p31, p32;
                char szBuf16[1024], szBuf32[1024];
                char *pszErr;

                hmodKernel32 = LoadLibraryEx32W("kernel32", 0, 0);
                hmodUser32 = LoadLibraryEx32W("user32", 0, 0);
                hmodWow32 = LoadLibraryEx32W("wow32", 0, 0);


                //
                // Simple printf test.
                //

                pfn32 = GetProcAddress32W(hmodUser32, "wsprintfA");

                dw16 = wsprintf(szBuf16, "simple printf %ld", 12345678);

                dw32 = CallProc32W(   (DWORD)(LPSTR) szBuf32,
                                      (DWORD)(LPSTR) "simple printf %ld",
                                      12345678,
                                      0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      pfn32,
                                      BIT(30) | BIT(31),
                                      CPEX_DEST_CDECL | 32
                                      );

                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "simple printf comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "s1 success", "Genthunk Sanity Test", MB_OK);


                dw32 = CallProcEx32W( CPEX_DEST_CDECL | 3,
                                      BIT(0) | BIT(1),
                                      pfn32,
                                      (DWORD)(LPSTR) szBuf32,
                                      (DWORD)(LPSTR) "simple printf %ld",
                                      12345678 );

                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "simple printf comparison failed (CallProcEx)";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "s2 success", "Genthunk Sanity Test", MB_OK);

                //
                // Complex printf test.
                //

                // pfn32 still points to wsprintfA
                // pfn32 = GetProcAddress32W(hmodUser32, "wsprintfA");


               #if 0  // this blows out Win16 wsprintf!
                dw16 = wsprintf(szBuf16,
                                "complex printf "
                                 "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s "
                                 "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s ",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str",
                                12345678,
                                0x87654321,
                                "str"
                                );
               #else
                lstrcpy(szBuf16, "complex printf "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 "12345678 87654321 str "
                                 );
                dw16 = lstrlen(szBuf16);
               #endif

                dw32 = CallProc32W(
                                (DWORD)(LPSTR) szBuf32,
                                (DWORD)(LPSTR) "complex printf "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s ",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                pfn32,
                                BIT(0) | BIT(3) | BIT(6) | BIT(9) | BIT(12) | BIT(15) |
                                  BIT(18) | BIT(21) | BIT(24) | BIT(27) | BIT(30) | BIT(31),
                                CPEX_DEST_CDECL | 32
                                );

                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "complex printf comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "c1 success", "Genthunk Sanity Test", MB_OK);

                dw32 = CallProcEx32W( CPEX_DEST_CDECL | 32,
                                      BIT(0) | BIT(1) | BIT(4) | BIT(7) | BIT(10) | BIT(13) |
                                      BIT(16) | BIT(19) | BIT(22) | BIT(25) | BIT(28) | BIT(31),
                                      pfn32,
                                (DWORD)(LPSTR) szBuf32,
                                (DWORD)(LPSTR) "complex printf "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s "
                                         "%ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s %ld %lx %s ",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str",
                                12345678,
                                0x87654321,
                                (DWORD)(LPSTR) "str"
                                );


                if (dw16 != dw32 || lstrcmp(szBuf16, szBuf32)) {
                    pszErr = "complex printf comparison failed (CallProcEx)";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "c2 success", "Genthunk Sanity Test", MB_OK);

                //
                // Simple WINAPI test (GetProcAddress of LoadModule)
                //

                pfn32 = GetProcAddress32W(hmodKernel32, "GetProcAddress");

                dw16 = GetProcAddress32W(hmodKernel32, "LoadModule");

                dw32 = CallProc32W(   hmodKernel32,
                                      (DWORD)(LPSTR) "LoadModule",
                                      0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      0, 0, 0, 0,
                                      pfn32,
                                      BIT(30),
                                      CPEX_DEST_STDCALL | 32
                                      );

                if (dw16 != dw32) {
                    pszErr = "GetProcAddress comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "w1 success", "Genthunk Sanity Test", MB_OK);

                dw32 = CallProcEx32W( CPEX_DEST_STDCALL | 2,
                                      BIT(1),
                                      pfn32,
                                      hmodKernel32,
                                      (DWORD)(LPSTR) "LoadModule" );

                wsprintf(szBuf16, "GPA via CP32Ex(LoadModule) == %lx\n", dw32);
                OutputDebugString(szBuf16);
                if (dw16 != dw32) {
                    pszErr = "GetProcAddress comparison failed (CallProcEx)";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "w2 success", "Genthunk Sanity Test", MB_OK);

                //
                // Complex WINAPI test WOWStdCall32ArgsTestTarget exists only on
                // checked WOW32.dll
                //

                pfn32 = GetProcAddress32W(hmodWow32, "WOWStdCall32ArgsTestTarget");

                if (!pfn32) {
                    MessageBox(hwnd,
                               "WOWStdCall32ArgsTestTarget not found, use checked wow32.dll for this test.",
                               "Genthunk Quicktest",
                               MB_OK
                               );
                    goto Done;
                }

                p1 = 1;
                p2 = 2;
                p3 = 3;
                p4 = 4;
                p5 = 5;
                p6 = 6;
                p7 = 7;
                p8 = 8;
                p9 = 9;
                p10 = 10;
                p11 = 11;
                p12 = 12;
                p13 = 13;
                p14 = 14;
                p15 = 15;
                p16 = 16;
                p17 = 17;
                p18 = 18;
                p19 = 19;
                p20 = 10;
                p21 = 21;
                p22 = 22;
                p23 = 23;
                p24 = 24;
                p25 = 25;
                p26 = 26;
                p27 = 27;
                p28 = 28;
                p29 = 29;
                p30 = 30;
                p31 = 31;
                p32 = 32;

                dw16 = ((((p1+p2+p3+p4+p5+p6+p7+p8+p9+p10) -
                          (p11+p12+p13+p14+p15+p16+p17+p18+p19+p20)) << p21) +
                        ((p22+p23+p24+p25+p26) - (p27+p28+p29+p30+p31+p32)));

                dw32 = CallProc32W(   p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
                                      p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                                      p21, p22,
                                      (DWORD)(LPDWORD) &p23,
                                                     p24, p25, p26, p27, p28, p29, p30,
                                      p31,
                                      (DWORD)(LPDWORD) &p32,
                                      pfn32,
                                      BIT(9) | BIT(0),
                                      CPEX_DEST_STDCALL | 32
                                      );

                if (dw16 != dw32) {
                    pszErr = "WOWStdCall32ArgsTestTarget comparison failed";
                    goto ErrorMsg;
                }

                MessageBox(hwnd, "cw1 success", "Genthunk Sanity Test", MB_OK);

                dw32 = CallProcEx32W( CPEX_DEST_STDCALL | 32,
                                      BIT(22) | BIT(31),
                                      pfn32,
                                      p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
                                      p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                                      p21, p22,
                                      (DWORD)(LPDWORD) &p23,
                                                     p24, p25, p26, p27, p28, p29, p30,
                                      p31,
                                      (DWORD)(LPDWORD) &p32
                                      );

                if (dw16 != dw32) {
                    pszErr = "WOWStdCall32ArgsTestTarget comparison failed (CallProcEx)";
                    goto ErrorMsg;

            ErrorMsg:
                    MessageBox(hwnd, pszErr, "Genthunk Sanity Test Failure", MB_OK);
                    goto Done;
                }

                wsprintf(szBuf16, "result of odd calc is %lx\n", dw32);
                OutputDebugString(szBuf16);

                MessageBox(hwnd, "Test successful!", "Genthunk Quicktest", MB_OK);

            Done:
                FreeLibrary32W(hmodKernel32);
                FreeLibrary32W(hmodUser32);
                FreeLibrary32W(hmodWow32);
            }
            break;

        }
        break;
#endif

    case WM_WOWEXECSTARTAPP:      // WM_USER+0

#ifdef DEBUG
        OutputDebugString("WOWEXEC - got WM_WOWEXECSTARTAPP\n");
#endif

        //
        // Either BaseSrv or Wow32 asked us to go looking for
        // commands to run.
        //

        if (!gfSharedWOW) {

            //
            // We shouldn't get this message unless we are the shared
            // WOW VDM!
            //

#ifdef DEBUG
            OutputDebugString("WOWEXEC - separate WOW VDM got WM_WOWEXECSTARTAPP!\n");
            _asm int 3;
#endif
            break;
        }

        //
        // Start requested apps until there are no more to start.
        // This handles the case where several Win16 apps are launched
        // in a row, before BaseSrv has the window handle for WowExec.
        //

        while (StartRequestedApp()) {
            /* Null stmt */ ;
        }

        break;

    case WM_WOWEXEC_START_TASK:
        {
            char sz[512];

            sz[ GlobalGetAtomName(wParam, sz, sizeof sz) ] = 0;
            GlobalDeleteAtom(wParam);
            WinExec(sz, (WORD)lParam);
        }

    case WM_WOWEXECHEARTBEAT:
        // Probably will never get here...
        break;

    case WM_WOWEXECSTARTTIMER:
        WowShutdownTimer(1);
        break;

    case WM_TIMER:
        if (wParam == 1) {  // timer ID

            KillTimer(ghwndMain, 1);

            //
            // The shutdown timer has expired, meaning it's time to kill this
            // shared WOW VDM.  First we need to let basesrv know not to queue
            // any more apps for us to start.
            //

            if (WOWRegisterShellWindowHandle(NULL,
                                             &gwFirstCmdShow,
                                             NULL
                                            )) {

                //
                // BaseSrv deregistered us successfully after confirming
                // there are no pending commands for us.
                //

                ExitKernelThunk(0);
            } else {

                //
                // There must be pending commands for us.  Might as well
                // start them.
                //

                PostMessage(ghwndMain, WM_WOWEXECSTARTAPP, 0, 0);
            }

        }

        break;

    case WM_TIMECHANGE:
        *((DWORD *)(((DWORD)40 << 16) | FIXED_NTVDMSTATE_REL40))
         |= VDM_TIMECHANGE;
        break;

    case WM_DDE_INITIATE:
        {
            // In win31, the Program Manager WindowProc calls peekmessage to filterout
            // otherwindowcreated and otherwindowdestroyed messages (which are atoms in win31)
            // whenever it receives WM_DDE_INITIATE message.
            //
            // This has a side effect - basically when peekmessage is called the app ie program
            // manager effectively yields allowing scheduling of other apps.
            //
            // So we do the side effect thing (simulate win31 behaviour) -
            //
            // The bug: 20221, rumba as/400 can't connect the firsttime to sna server.
            // Scenario: Rumbawsf execs snasrv and blocks on yield, snasrv execs wnap and blocks
            //           on yield. Eventually wnap yields and rumbawsf is scheduled which
            //           broadcasts a ddeinitiate message. When WOWEXEC receives this message
            //           it will peek for nonexistent msg, which allows snasrv to get scheduled

            MSG msg;
            while (PeekMessage(&msg, NULL, 0xFFFF, 0xFFFF, PM_REMOVE))
                DispatchMessage(&msg);
        }
        break;



    case WM_CLOSE:
#ifdef DEBUG
        ExitKernelThunk(0);
#else
        // ignore since wowexec must stay around
        return 0;
#endif // ! DEBUG


    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }

    return 1;
}

BOOL FAR PASCAL PartyDialogProc(HWND hDlg, WORD msg, WORD wParam, LONG lParam)
{
#ifdef DEBUG
    BOOL f;
    DWORD dw;
    char szBuf[255];

    switch (msg) {

        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_PARTY_NUMBER, EM_LIMITTEXT, 5, 0L);
            SendDlgItemMessage(hDlg, IDD_PARTY_STRING, EM_LIMITTEXT, sizeof(szBuf)-1, 0L);
            break;

        case WM_COMMAND:
            switch (wParam) {

                case 0xdab /* IDCANCEL */:
                    EndDialog(hDlg, FALSE);
                    break;

                case 0xdad /* IDOK */:
                    dw = GetDlgItemInt(hDlg, IDD_PARTY_NUMBER, &f, FALSE);
                    GetDlgItemText(hDlg, IDD_PARTY_STRING, szBuf, sizeof(szBuf));
                    WowPartyByNumber(dw, szBuf);
                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
#endif

    return TRUE;
}

// Misc File Routines - taken from progman (pmdlg.c) mattfe apr-1 92

//-------------------------------------------------------------------------
PSTR FAR PASCAL GetFilenameFromPath
    // Given a full path returns a ptr to the filename bit. Unless it's a UNC style
    // path in which case
    (
    PSTR szPath
    )
    {
    DWORD dummy;
    PSTR pFileName;
    BOOL fUNC;


    GetPathInfo(szPath, &pFileName, (PSTR*) &dummy, (WORD*) &dummy,
        &fUNC);

    // If it's a UNC then the 'filename' part is the whole thing.
    if (fUNC)
        pFileName = szPath;

    return pFileName;
    }


//-------------------------------------------------------------------------
void NEAR PASCAL GetPathInfo
    // Get pointers and an index to specific bits of a path.
    // Stops scaning at first space.
    (
                        // Uses:
    PSTR szPath,        // The path.

                        // Returns:
    PSTR *pszFileName,  // The start of the filename in the path.
    PSTR *pszExt,       // Extension part of path (starting with the dot).
    WORD *pich,         // Index (in DBCS characters) of filename part starting at 0.
    BOOL *pfUnc         // Contents set to true if it's a UNC style path.
    )
    {
    char *pch;          // Temp variable.
    WORD ich = 0;       // Temp.

    *pszExt = NULL;             // If no extension, return NULL.
    *pszFileName = szPath;      // If no seperate filename component, return path.
    *pich = 0;
    *pfUnc = FALSE;             // Default to not UNC style.

    // Check for UNC style paths.
    if (*szPath == '\\' && *(szPath+1) == '\\')
        *pfUnc = TRUE;

    // Search forward to find the last backslash or colon in the path.
    // While we're at it, look for the last dot.
    for (pch = szPath; *pch; pch = AnsiNext(pch))
        {
        if (*pch == ' ')
            {
            // Found a space - stop here.
            break;
            }
        if (*pch == '\\' || *pch == ':')
            {
            // Found it, record ptr to it and it's index.
            *pszFileName = pch+1;
            *pich = ich+1;
            }
        if (*pch == '.')
            {
            // Found a dot.
            *pszExt = pch;
            }
        ich++;
        }

    // Check that the last dot is part of the last filename.
    if (*pszExt < *pszFileName)
        *pszExt = NULL;

    }


//-----------------------------------------------------------------------------
//  StartRequestedApp
//      Calls WIN32 Base GetNextVDMCommand
//      and then starts the application
//
//-----------------------------------------------------------------------------

#define LargeEnvSize()    0x1000           // Size of a large env

BOOL NEAR PASCAL StartRequestedApp(VOID)
{
    char achCmdLine[CCHMAX];
    char achAppName[CCHMAX];
#ifdef DEBUG
    char achAppNamePlusCmdLine[sizeof(achCmdLine) + sizeof(achAppName)];
    int iGetNextVdmCmdLoops = 0;
#endif
    char achCurDir[CCHMAX];
    WOWINFO wowinfo;
    BOOL    b;
    HANDLE  hmemEnvironment;
    USHORT usEnvSize;

    achCmdLine[0] = '\0';
    achAppName[0] = '\0';

    // We start by assuming that the app will have an environment that will
    // be less than a large environment size. If not then
    // WowGetNextVdmCommand will fail and we will try again with the
    // enviroment size needed for the app as returned from the failed
    // WowGetNextVdmCommand call. If we detect that WowGetNextVdmCommand fails
    // but that we have plenty of environment space then we know another
    // problem has occured and we give up.

    // We don't worry about wasting memory since the environment will be
    // merged into another buffer and this buffer will be freed below.

    wowinfo.EnvSize = LargeEnvSize();
    hmemEnvironment = NULL;

    do {
        if (hmemEnvironment != NULL) {
            GlobalUnlock(hmemEnvironment);
       GlobalFree(hmemEnvironment);
        }
   
        // We need to allocate twice the space specified so that international
        // character set conversions can be successful.
        hmemEnvironment = GlobalAlloc(GMEM_MOVEABLE, 2*wowinfo.EnvSize);
        if (hmemEnvironment == NULL) {
#ifdef DEBUG
            OutputDebugString("WOWEXEC - failed to allocate Environment Memory\n");
#endif
            MyMessageBox(IDS_EXECERRTITLE, IDS_NOMEMORYMSG, NULL);
            return FALSE;
        }
   
        wowinfo.lpEnv    = GlobalLock(hmemEnvironment);
#ifdef DEBUG
        if (wowinfo.lpEnv == NULL) {
            OutputDebugString("WOWEXEC ASSERT - GlobalLock failed, fix this!\n");
            _asm { int 3 };
        }

        if (2*wowinfo.EnvSize > GlobalSize(hmemEnvironment)) {
            OutputDebugString("WOWEXEC ASSERT - alloced memory too small, fix this!\n");
            _asm { int 3 };
        }
#endif
        wowinfo.lpCmdLine = achCmdLine;
        wowinfo.CmdLineSize = CCHMAX;
        wowinfo.lpAppName = achAppName;
        wowinfo.AppNameSize = CCHMAX;
        wowinfo.CurDrive = 0;
        wowinfo.lpCurDir = achCurDir;
        wowinfo.CurDirSize = sizeof(achCurDir);
        wowinfo.iTask = 0;

        usEnvSize = wowinfo.EnvSize;   

#ifdef DEBUG
        if (++iGetNextVdmCmdLoops == 4) {
            OutputDebugString("WOWEXEC ASSERT - Too many calls to GetNextVdmCommand\n");
            _asm { int 3 };
        }
#endif
    } while (! (b = WowGetNextVdmCommand(&wowinfo)) &&
           (wowinfo.EnvSize > usEnvSize));

    if ( ! b ) {
#ifdef DEBUG
        OutputDebugString("WOWEXEC - GetNextVdmCommand failed.\n");
#endif
        MyMessageBox(IDS_EXECERRTITLE, IDS_NOMEMORYMSG, achCmdLine);
        GlobalUnlock( hmemEnvironment );
        GlobalFree( hmemEnvironment );
        return FALSE;
    }

    //
    // If CmdLineSize == 0, no more commands (wowexec was the command)
    // see WK32WowGetNextVdm
    //
    if (! wowinfo.CmdLineSize) {
        GlobalUnlock( hmemEnvironment );
        GlobalFree( hmemEnvironment );
        return FALSE;
    }


#ifdef DEBUG
    lstrcpy(achAppNamePlusCmdLine, achAppName);
    lstrcat(achAppNamePlusCmdLine, ":");
    lstrcat(achAppNamePlusCmdLine, achCmdLine);
    // Chop off trailing CRLF from command tail.
    achAppNamePlusCmdLine[ lstrlen(achAppNamePlusCmdLine) - 2 ] = '\0';

    OutputDebugString("WOWEXEC: CommandLine = <");
    OutputDebugString(achAppNamePlusCmdLine);
    OutputDebugString(">\n");

    SetWindowText(ghwndMain, achAppNamePlusCmdLine);
    UpdateWindow(ghwndMain);
#endif

    ExecApplication(&wowinfo);

#ifdef DEBUG

    if ( ! gfSharedWOW ) {

        //
        // If this is a separate WOW, we have just executed the one and only
        // app we're going to spawn.  Change our window title to
        // Command Line - WOWExec so that it's easy to see which WOW this
        // window is associated with.  No need to worry about freeing
        // this memory, since when we go away the VDM goes away and
        // vice-versa.
        //

        lpszAppTitle = GlobalLock(
            GlobalAlloc(GMEM_FIXED,
                        lstrlen(achAppNamePlusCmdLine) +
                        3 +                        // for " - "
                        lstrlen(szAppTitleBuffer) +
                        1                          // for null terminator
                        ));

        lstrcpy(lpszAppTitle, achAppNamePlusCmdLine);
        lstrcat(lpszAppTitle, " - ");
        lstrcat(lpszAppTitle, szAppTitleBuffer);
    }


    SetWindowText(ghwndMain, lpszAppTitle);
    UpdateWindow(ghwndMain);
#endif

    GlobalUnlock(hmemEnvironment);
    GlobalFree(hmemEnvironment);

    return TRUE;  // We ran an app.
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\wowexec\pmdos.asm ===
;****************************************************************************
;*									    *
;*  PMDOS.ASM - 							    *
;*									    *
;*	Low level DOS routines needed by the Program Manager.		    *
;*									    *
;****************************************************************************

memS=1
?PLM=1
?WIN=1

include cmacros.inc

SelectDisk		equ 0Eh
FCBFindFirstFile	equ 11h
FCBFindNextFile 	equ 12h
FCBDeleteFile		equ 13h
FCBRenameFile		equ 17h
GetCurrentDisk		equ 19h
SetDTAAddress		equ 1Ah
GetFileSize		equ 23h
GetDiskFreeSpace	equ 36h
CreateDir		equ 39h
RemoveDir		equ 3Ah
ChangeCurrentDir	equ 3Bh
CreateFile		equ 3Ch
DeleteFile		equ 41h
GetSetFileAttributes	equ 43h
GetCurrentDir		equ 47h
FindFirstFile		equ 4Eh
FindNextFile		equ 4Fh
RenameFile		equ 56h

externFP DOS3CALL

externFP    AnsiToOem
ifdef	DBCS
externFP    IsDBCSLeadByte
endif

;=============================================================================

createSeg _%SEGNAME, %SEGNAME, WORD, PUBLIC, CODE

sBegin %SEGNAME

assumes CS,%SEGNAME
assumes DS,DATA

cProc	PathType, <FAR, PUBLIC>

    parmD   lpFile

    localV  szOEM, 128

cBegin

    RegPtr lpszOEM, ss, bx
    lea     bx, szOEM
    cCall   AnsiToOem, <lpFile, lpszOEM>

    lea     dx, szOEM
    mov     ax, 4300h
    call    DOS3CALL
    jnc     id_noerror
    xor     ax, ax
    jmp     short id_exit

id_noerror:
    and     cx, 10h
    jnz     id_dir
    mov     ax, 1
    jmp     short id_exit

id_dir:
    mov     ax, 2

id_exit:
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  FileTime*() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc FileTime, <FAR, PUBLIC>

    parmW   hFile

cBegin
    mov     ax, 5700h
    mov     bx, hFile
    cCall   DOS3CALL
    jnc     ft_ok
    sub     ax, ax
    sub     dx, dx
    jmp     short ft_ex
ft_ok:
    mov     ax, cx
ft_ex:
cEnd

;*--------------------------------------------------------------------------*
;*									    *
;*  IsReadOnly() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc IsReadOnly, <FAR, PUBLIC>

    parmD   lpFile

    localV  szOEM, 128

cBegin

    RegPtr  lpszOEM, ss, bx
    lea     bx, szOEM
    cCall   AnsiToOem,<lpFile,lpszOEM>

    mov     ax, 4300h		; get attributes...
    lea     dx, szOEM		; ...for given file...
    call    DOS3CALL
    jc	    f_exit		; ax == 0 if error...
    and     ax, 1		; test RO bit
    jmp     short t_exit        ; true
f_exit:
    xor     ax, ax              ; false
t_exit:
cEnd



;*--------------------------------------------------------------------------*
;*									    *
;*  GetDOSErrorCode() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetDOSErrorCode, <FAR, PUBLIC>, <SI,DI>

cBegin

    mov     ah,59h		; Get DOS extended error
    sub     bx,bx		; cause ray duncan says so
    push    ds			; function trashes registers
    push    bp			; so we gotta save 'em for cProc
    call    DOS3CALL
    pop     bp			; be nice to C
    pop     ds			; get DS
    mov     dl,bh		; class in byte 2
    mov     dh,ch		; locus in byte 3 (skip the rec. action)

cEnd

;*--------------------------------------------------------------------------*
;*									    *
;*  GetCurrentDrive() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetCurrentDrive, <FAR, PUBLIC>

cBegin
	    mov     ah,GetCurrentDisk
	    call    DOS3CALL
	    sub     ah,ah		; Zero out AH
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  SetCurrentDrive() - 						    *
;*									    *
;*--------------------------------------------------------------------------*

; Returns the number of drives in AX.

cProc SetCurrentDrive, <FAR, PUBLIC>

ParmW Drive

cBegin
	    mov     dx,Drive
	    mov     ah,SelectDisk
	    call    DOS3CALL
	    sub     ah,ah		; Zero out AH
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  GetCurrentDirectory() -						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc GetCurrentDirectory, <FAR, PUBLIC>, <SI, DI>

parmW wDrive
ParmD lpDest

cBegin
	    push    ds			; Preserve DS

	    mov     ax,wDrive
	    or	    al,al
	    jnz     GCDHaveDrive

	    call    GetCurrentDrive

	    inc     al			; Convert to logical drive number

GCDHaveDrive:
	    les     di,lpDest		; ES:DI = lpDest
	    push    es
	    pop     ds			; DS:DI = lpDest
	    cld

	    mov     dl,al		; DL = Logical Drive Number
	    add     al,'@'		; Convert to ASCII drive letter
	    stosb
	    mov     al,':'
	    stosb
	    mov     al,'\'		; Start string with a backslash
	    stosb
	    mov     byte ptr es:[di],0	; Null terminate in case of error
	    mov     si,di		; DS:SI = lpDest[1]
	    mov     ah,GetCurrentDir
	    call    DOS3CALL
	    jc	    GCDExit		; Skip if error
	    xor     ax,ax		; Return FALSE if no error
GCDExit:
	    pop     ds			; Restore DS
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  SetCurrentDirectory() -						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc SetCurrentDirectory, <FAR, PUBLIC>, <DS, DI>

ParmD lpDirName

cBegin
	    lds     di,lpDirName	; DS:DI = lpDirName

	    ; Is there a drive designator?
ifdef	DBCS
	    mov     al, byte ptr [di]	; fetch a first byte of path
	    xor     ah,ah
	    cCall   IsDBCSLeadByte, <ax>
	    test    ax,ax		; DBCS lead byte?
	    jnz     SCDNoDrive		; jump if so
endif
	    cmp     byte ptr [di+1],':'
	    jne     SCDNoDrive		; Nope, continue
	    mov     al,byte ptr [di]	; Yup, change to that drive
	    sub     ah,ah
	    and     al, 0DFH	 ;Make drive letter upper case
	    sub     al,'A'
	    push    ax
	    call    SetCurrentDrive

            mov     al,byte ptr [di+2]  ; string just a drive letter and colon?
	    cbw
	    or	    ax,ax
            jz      SCDExit             ; Yup, just set the current drive and done
SCDNoDrive:
	    mov     dx,di
	    mov     ah,ChangeCurrentDir
	    call    DOS3CALL
	    jc	    SCDExit		; Skip on error
	    xor     ax,ax		; Return FALSE if successful
SCDExit:
cEnd


if 0
;*--------------------------------------------------------------------------*
;*									    *
;*  IsRemovableDrive() -						    *
;*									    *
;*--------------------------------------------------------------------------*

cProc IsRemovableDrive, <FAR, PUBLIC>

ParmW wDrive

cBegin
	    mov     ax,4408h	; IOCTL: Check If Block Device Is Removable
	    mov     bx,wDrive
	    inc     bx
	    call    DOS3CALL
	    and     ax,1	; Only test bit 0
	    xor     ax,1	; Flip so 1 == Removable
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  IsRemoteDrive() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc IsRemoteDrive, <FAR, PUBLIC>

ParmW wDrive

cBegin
	    mov     ax,4409h	; IOCTL: Check If Block Device Is Remote
	    mov     bx,wDrive
	    inc     bx
	    call    DOS3CALL
	    xor     ax,ax
	    and     dx,0001000000000000b    ; Test bit 12
	    jz	    IRDRet
	    mov     ax,1
IRDRet:
cEnd
endif

;*--------------------------------------------------------------------------*
;*									    *
;*  DosDelete() -							    *
;*									    *
;*--------------------------------------------------------------------------*

%out assuming SS==DS

cProc DosDelete, <FAR, PUBLIC>

ParmD lpSource

localV	szOEM, 128

cBegin

	    RegPtr  lpszOEM,ss,bx   ; convert path to OEM chars
	    lea     bx, szOEM
	    cCall   AnsiToOem, <lpSource, lpszOEM>

	    lea     dx, szOEM
	    mov     ah,DeleteFile   ;
	    call    DOS3CALL
	    jc	    DDExit
	    xor     ax,ax	    ; Return 0 if successful
DDExit:
cEnd


;*--------------------------------------------------------------------------*
;*									    *
;*  DosRename() -							    *
;*									    *
;*--------------------------------------------------------------------------*

cProc DosRename, <FAR, PUBLIC>, <DI>

ParmD lpSource
ParmD lpDest

localV	szOEM1, 128
localV	szOEM2, 128

cBegin
	    RegPtr  lpszOEM1, ss, bx
	    lea     bx, szOEM1
	    cCall   AnsiToOem, <lpSource, lpszOEM1>

	    RegPtr  lpszOEM2, ss, bx
	    lea     bx, szOEM2
	    cCall   AnsiToOem, <lpDest, lpszOEM2>

	    lea     dx, szOEM1
	    lea     di, szOEM2
	    push    ss
	    pop     es
	    mov     ah,RenameFile
	    call    DOS3CALL
	    jc	    DRExit
	    xor     ax,ax	    ; Return 0 if successful
DRExit:
cEnd

;   lmemmove() -
;
;   Shamelessly heisted from the C5.1 runtime library, and modified to
;   work in mixed model Windows programs!
;
;***
;memcpy.asm - contains memcpy and memmove routines
;
;	Copyright (c) 1986-1988, Microsoft Corporation.  All right reserved.
;
;Purpose:
;	memmove() copies a source memory buffer to a destination memory buffer.
;	This routine recognize overlapping buffers to avoid propogation.
;
;   Algorithm:
;
;	void * memmove(void * dst, void * src, size_t count)
;	{
;		void * ret = dst;
;
;		if (dst <= src || dst >= (src + count)) {
;			/*
;			 * Non-Overlapping Buffers
;			 * copy from lower addresses to higher addresses
;			 */
;			while (count--)
;				*dst++ = *src++;
;			}
;		else {
;			/*
;			 * Overlapping Buffers
;			 * copy from higher addresses to lower addresses
;			 */
;			dst += count - 1;
;			src += count - 1;
;
;			while (count--)
;				*dst-- = *src--;
;			}
;
;		return(ret);
;	}
;
;
;Entry:
;	void *dst = pointer to destination buffer
;	const void *src = pointer to source buffer
;	size_t count = number of bytes to copy
;
;Exit:
;	Returns a pointer to the destination buffer in DX:AX
;
;Uses:
;	CX,DX,ES
;
;Exceptions:
;*******************************************************************************

cProc	lmemmove,<FAR,PUBLIC>,<si,di>

	parmD	dst		; destination pointer
	parmD	src		; source pointer
	parmW	count		; number of bytes to copy

cBegin
	push	ds		; Preserve DS
	lds	si,src		; DS:SI = src
	les	di,dst		; ES:DI = dst

	mov	ax,di		; save dst in AX for return value
	mov	cx,count	; cx = number of bytes to move
	jcxz	done		; if cx = 0 Then nothing to copy

;
; Check for overlapping buffers:
;	If segments are different, assume no overlap
;		Do normal (Upwards) Copy
;	Else If (dst <= src) Or (dst >= src + Count) Then
;		Do normal (Upwards) Copy
;	Else
;		Do Downwards Copy to avoid propogation
;
	mov	ax,es		; compare the segments
	cmp	ax,word ptr (src+2)
	jne	CopyUp
	cmp	di,si		; src <= dst ?
	jbe	CopyUp

	mov	ax,si
	add	ax,cx
	cmp	di,ax		; dst >= (src + count) ?
	jae	CopyUp
;
; Copy Down to avoid propogation in overlapping buffers
;
	mov	ax,di		; AX = return value (offset part)

	add	si,cx
	add	di,cx
	dec	si		; DS:SI = src + count - 1
	dec	di		; ES:DI = dst + count - 1
	std			; Set Direction Flag = Down
	rep	movsb
	cld			; Set Direction Flag = Up
	jmp	short done

CopyUp:
	mov	ax,di		; AX = return value (offset part)
;
; There are 4 situations as far as word alignment of "src" and "dst":
;	1. src and dst are both even	(best case)
;	2. src is even and dst is odd
;	3. src is odd and dst is even
;	4. src and dst are both odd	(worst case)
;
; Case #4 is much faster if a single byte is copied before the
; REP MOVSW instruction.  Cases #2 and #3 are effectively unaffected
; by such an operation.  To maximum the speed of this operation,
; only DST is checked for alignment.  For cases #2 and #4, the first
; byte will be copied before the REP MOVSW.
;
	test	al,1		; fast check for dst being odd address
	jz	move

	movsb			; move a byte to improve alignment
	dec	cx
;
; Now the bulk of the copy is done using REP MOVSW.  This is much
; faster than a REP MOVSB if the src and dst addresses are both
; word aligned and the processor has a 16-bit bus.  Depending on
; the initial alignment and the size of the region moved, there
; may be an extra byte left over to be moved.  This is handled
; by the REP MOVSB, which moves either 0 or 1 bytes.
;
move:
	shr	cx,1		; Shift CX for count of words
	rep	movsw		; CF set if one byte left over
	adc	cx,cx		; CX = 1 or 0, depending on Carry Flag
	rep	movsb		; possible final byte
;
; Return the "dst" address in AX/DX:AX
;
done:
	pop	ds		;restore ds
	mov	dx,es		;segment part of dest address

cEnd

sEnd %SEGNAME

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\aaa.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* aaa.c -- special bogus module to substitute dummy function(s)
   for c library stuff which is never called but gets pulled in anyway. */


_malloc()
{
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\bitmaps.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* These are defines for the different-sized, conditionally-loaded Ruler 
   bitmaps.  See header of WRITE.RC and also FCreateRuler()   ..pault */


#define idBmBtns       100     /* Ruler Buttons */
#define idBmBtnsCGA    100
#define idBmBtnsEGA    101
#define idBmBtnsVGA    102
#define idBmBtns8514   103
#define idBmBtnsMax    104

#define idBmMarks      200     /* Ruler Marks */
#define idBmMarksCGA   200
#define idBmMarksEGA   201
#define idBmMarksVGA   202
#define idBmMarks8514  203
#define idBmMarksMax   204

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\addprm.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* AddPrm.c -- Routines to add prms and sprms to docs */
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSMETRICS
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOPEN
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NOWNDCLASS
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOHDC
#define NOMB
#define NOMENUS
#define NOMETAFILE
#define NOMSG
#define NOTEXTMETRIC
#define NOSOUND
#define NOSCROLL
#define NOCOMM
/* no everything except MEMMGR */
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "code.h"
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "stcdefs.h"
#include "fkpdefs.h"
#include "macro.h"
#include "dispdefs.h"

/* E X T E R N A L S */

extern int docCur;
extern struct SEL selCur;
extern struct DOD (**hpdocdod)[];
extern struct UAB vuab;
extern int vfSysFull;
extern CHAR dnsprm[];
extern struct CHP vchpSel;
extern typeCP vcpLimParaCache;
extern typeCP cpMacCur;
extern typeCP CpLimNoSpaces();
extern int ferror;

/* G L O B A L S */

struct FPRM     fprmCache = { 0 };
struct PRM      prmCache = {0,0,0,0};


/* A D D  O N E  S P R M */
/* applies sprm at psprm to the current selection. Take care of
undoing, invalidation, special endmark cases, and extension of selection
to paragraph boundaries */
void AddOneSprm(psprm, fSetUndo)
CHAR *psprm;
int fSetUndo; /* True if we need to set up the undo buffer */
{
        int cch;
        int fParaSprm = fFalse;
        typeCP cpFirst, cpLim, dcp;

        if (!FWriteOk( fwcNil ))
            return;

        if ((dnsprm[*psprm] & ESPRM_sgc) != sgcChar)
            {
            typeCP dcpExtraPara = cp0;

            cpFirst = CpFirstSty( selCur.cpFirst, styPara );
            CachePara( docCur, CpMax( selCur.cpLim - 1, selCur.cpFirst ) );
            cpLim = vcpLimParaCache;

            dcp = cpLim - cpFirst;

            /* Check for para following selection that has no Eol */

            if (cpLim < cpMacCur)
                {
                /* Note that in this case only, dcp (the # of cp's affected
                   by the change) does not equal (cpLim - cpFirst)
                   (the # of cp's to which the sprm should apply) */
                CachePara( docCur, cpLim );
                dcpExtraPara = vcpLimParaCache - cpLim;
                }

            if (cpFirst + dcp + dcpExtraPara > cpMacCur)
                {   /* Last para affected has no Eol -- add one */
                struct SEL selSave;

                dcp += dcpExtraPara;
                Assert( cpFirst + dcp == cpMacCur + (typeCP) ccpEol);

                if (fSetUndo)
                    {
                    SetUndo( uacReplNS, docCur, cpFirst, dcp,
                             docNil, cpNil, dcp - ccpEol, 0 );
                    fSetUndo = fFalse;
                    }
                /* Add an eol.  Save the current selection so
                   it does not get adjusted */
                selSave = selCur;
                InsertEolInsert(docCur,cpMacCur);
                selCur = selSave;
                }
            }
        else
            { /* Char sprm -- eliminate trailing spaces from the
                 affected region, so we don't underline spaces after words. */
            cpFirst = selCur.cpFirst;
            cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);
            dcp = cpLim - cpFirst;
            if (dcp == 0)
                { /* Doing character looks to the insert point...  */
                if (fSetUndo)
                    SetUndo(uacReplNS, docCur, cpFirst, cp0,
                                       docNil, cp0, cp0, 0);
                DoSprm(&vchpSel, 0, *psprm, psprm + 1);
                return;
                }
            }

        if (fSetUndo)
            SetUndo(uacReplNS, docCur, cpFirst, dcp, docNil, cpNil, dcp, 0);

        if (ferror)  /* not enough memory to store info for undo operation */
            {
            NoUndo();
            return;
            }

        AddSprmCps(psprm, docCur, cpFirst, cpLim);
        AdjustCp( docCur, cpFirst, dcp, dcp );
}

/* E X P A N D  C U R  S E L */
ExpandCurSel(pselSave)
struct SEL *pselSave;
{
        *pselSave = selCur;

        selCur.cpFirst = CpFirstSty(selCur.cpFirst, styPara);
        CachePara(docCur, CpMax(selCur.cpLim - 1, selCur.cpFirst));
        selCur.cpLim = vcpLimParaCache;
}

/* E N D  L O O K  S E L */
EndLookSel(pselSave, fPara)
struct SEL *pselSave; BOOL fPara;
        {
        typeCP cpLim, cpFirst, dcp;
        dcp = (cpLim = selCur.cpLim) - (cpFirst = selCur.cpFirst);
        if (fPara)
                {
                TrashCache();
                if (cpLim <= cpMacCur)
                        {
                        CachePara(docCur, selCur.cpLim);
                        if (vcpLimParaCache > cpMacCur) /* Last (partial) paragraph */
                                dcp = cpMacCur - cpFirst + 1;
                        }
                }
        AdjustCp(docCur, cpFirst, dcp, dcp);

        selCur = *pselSave;
        }



/* A D D  S P R M */

AddSprm(psprm)
CHAR *psprm;
{ /* Add a single property modifier to the pieces contained in selCur. */
        AddSprmCps(psprm, docCur, selCur.cpFirst, selCur.cpLim);
}


/* A D D  S P R M  C P S */
AddSprmCps(char *psprm, int doc, typeCP cpFirst, typeCP cpLim)
{
        struct PCTB **hpctb;
        int ipcdFirst, ipcdLim, ipcd;
        struct DOD *pdod;
        int cch;
        struct PCD *ppcd;

/* First get address of piece table and split off desired pieces. */
        pdod = &(**hpdocdod)[doc];
        hpctb = pdod->hpctb;
        pdod->fFormatted = fTrue;
        ipcdFirst = IpcdSplit(hpctb, cpFirst);
        ipcdLim = IpcdSplit(hpctb, cpLim);
        if (ferror)
                /* Ran out of memory trying to expand piece table */
            return;

/* Now just add this sprm to the pieces. */
        FreezeHp();
        for (ipcd = ipcdFirst, ppcd = &(**hpctb).rgpcd[ipcdFirst];
                ipcd < ipcdLim && !vfSysFull; ++ipcd, ++ppcd)
                ppcd->prm = PrmAppend(ppcd->prm, psprm);
        MeltHp();
}

/* P R M  A P P E N D */

struct PRM PrmAppend(struct PRM prm, CHAR *psprm)
{ /* Append <sprm, val> to the chain of sprm's in prm.  Return new prm. */
        struct FPRM *pfprmOld;
        CHAR *pfsprm;
        CHAR *pfsprmOld;
        int sprm = *psprm;
        int sprmOld;
        register int esprm = dnsprm[sprm];
        register int esprmOld;
        int cchNew = (esprm & ESPRM_cch);
        int cchOld;
        int sgc = (esprm & ESPRM_sgc);
        int spr = (esprm & ESPRM_spr);
        int fSame = (esprm & ESPRM_fSame);
        int fClobber = (esprm & ESPRM_fClobber);
        int dval = 0;
        int cch;
        int cchT;
        typeFC fcPrm;

        struct FPRM fprm;

        if (cchNew == 0) cchNew = CchPsprm(psprm);

        pfsprm = fprm.grpfsprm;

        if (prm.fComplex)
                { /* Get the old list of sprm's from scratch file; copy it to fprm. */
                pfprmOld = (struct FPRM *) PchFromFc(fnScratch,
                        //(typeFC)(unsigned)(((struct PRMX *) &prm)->bfprm << 1), &cch);
                        fcSCRATCHPRM(prm), &cch);
                pfsprmOld = pfprmOld->grpfsprm;
                cchT = cch = pfprmOld->cch;
                while (cchT)
                        { /* Copy grpsprm, removing ones which we will clobber */
                        sprmOld = *pfsprmOld;
                        esprmOld = dnsprm[sprmOld];
                        if ((cchOld = (esprmOld & ESPRM_cch)) == 0)
                                cchOld = CchPsprm(pfsprmOld);
#ifdef DEBUG
                        if (cchOld == 0)
                                panic();
#endif
                        if (sprmOld == sprm && fSame ||
                                (esprmOld & ESPRM_sgc) == sgc &&
                                (esprmOld & ESPRM_spr) <= spr && fClobber)
                                {
				/* make sure we properly coalesce change
				   size prms */
                                if (sprm == sprmOld && sprm == sprmCChgHps)
                                        dval += *(pfsprmOld + 1);
                                cch -= cchOld;
                                }
                        /* CHps overrides CChgHps */
                        else if (sprmOld == sprmCChgHps && sprm == sprmCHps)
                                {
                                cch -= cchOld;
                                }
                        else
                                pfsprm = (CHAR *)bltbyte(pfsprmOld, pfsprm, cchOld);
                        pfsprmOld += cchOld;
                        cchT -= cchOld;
                        }
                }
        else
                { /* No file entry yet; convert simple prm to fsprm */
                int valOld = prm.val;
                sprmOld = prm.sprm;
                esprmOld = dnsprm[sprmOld];

                if (bPRMNIL(prm) ||
                        sprmOld == sprm && fSame ||
                        (esprmOld & ESPRM_sgc) == sgc &&
                        (esprmOld & ESPRM_spr) <= spr && fClobber)
                        {
                         /* make sure we are combinning consecutive sprmCChgHps */
                        if (sprm == sprmOld && sprm == sprmCChgHps)
                                dval += valOld;
                        cch = 0;
                        }
                /* CHps overrides CChgHps */
                else if (sprmOld == sprmCChgHps && sprm == sprmCHps)
                        {
                        cch = 0;
                        }
                else
                        { /* Save old sprm */
                        *pfsprm++ = sprmOld;
                        if ((cch = (esprmOld & ESPRM_cch)) == 2)
                                *pfsprm++ = valOld;
                        }
                }
/* we have: cch = length of old prm after removal of clobbered/etc. entries.
cchNew: length of the entry to be appended.
dval: correction for 2nd byte of new entry
pfsprm: where 1st byte of new entry will go
*/
        bltbyte((CHAR *) psprm, pfsprm, imin(cchNew, cchMaxGrpfsprm - cch));
        *(pfsprm + 1) += dval;

        if (cch == 0 && cchNew <= 2)
                { /* Pack sprm and val into a prm word. */
                struct PRM prmT;
                prmT.dummy=0;
                bltbyte(pfsprm, (CHAR *) &prmT, cchNew);
                prmT.fComplex = false;
                prmT.sprm = *pfsprm;
                return (prmT);
                }

        if ((cch += cchNew) > cchMaxGrpfsprm)
                {
                int fSave = ferror;
                Error(IDPMT2Complex);
                ferror = fSave;
                return (prm);
                }
        if (vfSysFull)
                return prm; /* Assume disk full message already given */

        fprm.cch = cch;

/* Check newly created prm to see if same as previous */
        if (CchDiffer(&fprmCache, &fprm, cch + 1) == 0)
                return prmCache;
        bltbyte(&fprm, &fprmCache, cch + 1);

        AlignFn(fnScratch, cch = ((cch >> 1) + 1) << 1, fTrue);
        prm.fComplex = fTrue;

        //((struct PRMX)prm).bfprm = FcWScratch((CHAR *) &fprm, cch) >> 1;

        fcPrm = FcWScratch((CHAR *) &fprm, cch) >> 1;
        ((struct PRMX *)&prm)->bfprm_hi = (fcPrm >> 16) & 0x7F;
        ((struct PRMX *)&prm)->bfprm_low = fcPrm & 0xFFFF;

        prmCache = prm;
        return prm;
}


/* A P P L Y  C  L O O K S */
/* character looks. val is a 1 char value */
ApplyCLooks(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{
/* Assemble sprm */
        CHAR rgbSprm[1 + cchINT];
        CHAR *pch = &rgbSprm[0];
        *pch++ = sprm;
        *pch = val;

        if (pchp == 0)
                {
                /* apply looks to current selection */
                AddOneSprm(rgbSprm, fTrue);
                vuab.uac = uacChLook;
                SetUndoMenuStr(IDSTRUndoLook);
                }
        else
                {
                /* apply looks to pchp */
                DoSprm(pchp, 0, sprm, pch);
                }
}


/* A P P L Y  L O O K S  P A R A  S */
/* val is a char value */
ApplyLooksParaS(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
        {
        int valT = 0;
        CHAR *pch = (CHAR *)&valT;
        *pch = val;
/* all the above is just to prepare bltbyte later gets the right byte order */
        ApplyLooksPara(pchp, sprm, valT);
        }


/* A P P L Y  L O O K S  P A R A */
/* val is an integer value. Char val's must have been bltbyte'd into val */
ApplyLooksPara(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{

if (FWriteOk(fwcNil)) /* Check for out-of-memory/ read-only */
        {
        CHAR rgbSprm[1 + cchINT];
        CHAR *pch = &rgbSprm[0];

        *pch++ = sprm;
        bltbyte(&val, pch, cchINT);
        AddOneSprm(rgbSprm, fTrue);
        vuab.uac = uacChLook;
        SetUndoMenuStr(IDSTRUndoLook);
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\cache.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* cache.c -- Paragraph attribute fetching and caching for WRITE */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NOATOM
#define NOMETAFILE
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOPEN
#define NOBITMAP
#define NOCOLOR
#define NODRAWTEXT
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NORESOURCE
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "fmtdefs.h"
#define NOKCCODES
#include "ch.h"
#include "prmdefs.h"
#include "debug.h"

extern int              vfDiskError;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern typeFC           fcMacPapIns;
extern struct           FCB (**hpfnfcb)[];
extern struct           FKPD vfkpdParaIns;
extern int              ichInsert;
extern CHAR             rgchInsert[];
extern int              vdocExpFetch;
extern int              vdocSectCache;
extern typeCP           vcpFirstSectCache;
extern typeCP           vcpLimSectCache;
extern int              vdocPageCache;
extern typeCP           vcpMinPageCache;
extern typeCP           vcpMacPageCache;
extern typeCP           cpMinCur;

extern struct PAP      vpapAbs;
extern struct PAP      *vppapNormal;
extern struct DOD (**hpdocdod)[];
extern struct FLI vfli;
extern int              vdxaPaper;
extern int              vdyaPaper;
extern typePN           PnFkpFromFcScr();


extern int     vdocParaCache;
extern int                     visedCache;
extern int              vdocPageCache;

extern struct SEP              vsepAbs;
extern struct SEP               vsepPage;
extern struct SEP       vsepNormal;

extern   int      ctrCache;
extern   int      itrFirstCache;
extern   int      itrLimCache;
extern   typeCP   cpCacheHint;

CHAR *PchFromFc();
CHAR *PchGetPn();

CachePara(doc, cp)
int doc;
typeCP cp;
{ /* Make the para containing <doc, cp> the currently cached para */
struct PCD *ppcd, *ppcdBase;
typeCP cpMac, cpGuess;
struct DOD *pdod;
int     dty;
struct PCTB *ppctb;

if (vdocParaCache == doc && vcpFirstParaCache <= cp &&
    cp < vcpLimParaCache)
        return; /* That's what the cache is for */

Assert(cp >= cp0);

pdod = &(**hpdocdod)[doc];
dty = pdod->dty;
if (cp >= pdod->cpMac)
        { /* Use normal para for end mark and beyond */
#ifdef ENABLE   /* Occasionally this is not true (but it should be) */
        Assert( cp == pdod->cpMac );
#endif

        if (cp > cpMinCur)
            {   /* this piece of code treats the case when the whole document
                   is a non-empty semi-paragraph (chars but no EOL's) */
            CachePara( doc, cp - 1 );   /* Recursion will not happen */
            if ( vcpLimParaCache > cp )
                {
                vcpLimParaCache = pdod->cpMac + ccpEol;
                return;
                }
             }
        vdocParaCache = doc;
        vcpLimParaCache = (vcpFirstParaCache = pdod->cpMac) + ccpEol;
        DefaultPaps( doc );
        return;
        }

FreezeHp();
ppctb = *pdod->hpctb;
ppcdBase = &ppctb->rgpcd [ IpcdFromCp( ppctb, cpGuess = cp ) ];

if (vdocParaCache == doc && cp == vcpLimParaCache)
        vcpFirstParaCache = cp;
else
        { /* Search backward to find para start */
        for (ppcd = ppcdBase; ; --ppcd)
                { /* Beware heap movement! */
                typeCP cpMin = ppcd->cpMin;
                int fn = ppcd->fn;
                if (! ppcd->fNoParaLast)
                        { /* Don't check if we know there's no para end */
                        typeFC fcMin = ppcd->fc;
                        typeFC fc;

                        if ((fc = FcParaFirst(fn,
                            fcMin + cpGuess - cpMin, fcMin)) != fcNil)
                                { /* Found para begin */
                                vcpFirstParaCache = cpMin + (fc - fcMin);
                                break;
                                }
                        }
                /* Now we know there's no para end from cpMin to cpGuess. */
                /* If original piece, may be one after cp */
#ifdef BOGUSBL
                /* vfInsertMode protects against a critical section in insert */
                /* when the CR is already inserted but the supporting PAP structure */
                /* is not in place yet */

                if (cp != cpGuess && fn != fnInsert && !vfInsertMode)
#else           /* Insert CR works differently now, above test slows us down
                   by forcing many calls to FcParaLim */
                if (cp != cpGuess)
#endif
                        ppcd->fNoParaLast = true; /* Save some work next time */
                if (cpMin == cp0)
                        { /* Beginning of doc is beginning of para */
                        vcpFirstParaCache = cpMinCur;
                        break;
                        }

                /** Some low memory error conditions may cause ppctb to be 
                    messed up **/
                if (ppcd == ppctb->rgpcd)
                {
                    Assert(0);
                    vcpFirstParaCache = cp0; // hope for divine grace
                    break;
                }

                cpGuess = cpMin;
                }
        }

vdocParaCache = doc;
/* Now go forward to find the cpLimPara */
cpMac = pdod->cpMac;
cpGuess = cp;

for (ppcd = ppcdBase; ; ++ppcd)
        {
        typeCP cpMin = ppcd->cpMin;
        typeCP cpLim = (ppcd + 1)->cpMin;
        typeFC fc;
        int fn = ppcd->fn;

        if (! ppcd->fNoParaLast)
                { /* Don't check if we know there's no para end */
                typeFC fcMin = ppcd->fc;
                if ((fc = FcParaLim(fn, fcMin + cpGuess - cpMin,
                    fcMin + (cpLim - cpMin), &vpapAbs)) != fcNil)
                        { /* Found para end */
                        vcpLimParaCache = cpMin + (fc - fcMin);
                        /* Under Write, FcParaLim can't set the correct rgtbd */
                        /* That's because tabs are a DOCUMENT property */
                        /* We set it here instead */
                        GetTabsForDoc( doc );
                        break;
                        }
                }
        /* Now we know there's no para end. */
#ifdef BOGUSBL
        /* The check for vfInsertMode is necessary because of a critical */
        /* section in insertion between the insertion of a CR and the call */
        /* to AddRunScratch */
        if (cp != cpGuess && fn != fnInsert && !vfInsertMode)
#else   /* Insert CR has changed, we no longer try to pretend that
           the CR is not in the scratch file piece before the run is
           added. This new approach gains us speed, especially during backspace */
        if (cp != cpGuess)
#endif
                ppcd->fNoParaLast = true;    /* Save some work next time */
        if (cpLim == cpMac)
                { /* No EOL at end of doc */
                vcpLimParaCache = cpMac + ccpEol;
                MeltHp();
                DefaultPaps( doc );
                return;
                }
        /** Some low memory error conditions may cause ppctb to be 
            messed up **/
        else if ((cpLim > cpMac) || (ppcd == (ppctb->rgpcd + ppctb->ipcdMac - 1)))
        {
            Assert(0);
            vcpLimParaCache = cpMac + ccpEol; // hope for divine grace
            MeltHp();
            DefaultPaps( doc );
            return;
        }
        cpGuess = cpLim;
        }

/* Don't bother with properties for buffers */
#ifdef ENABLE       /* No buffers or styles in MEMO */
if (dty != dtyBuffer || pdod->docSsht != docNil)
#endif
        {
        struct PRM prm = ppcd->prm;
        if (!bPRMNIL(prm))
                DoPrm((struct CHP *) 0, &vpapAbs, prm);
#ifdef STYLES
        blt(vpapCache.fStyled ? PpropXlate(doc, &vpapCache, &vpapCache) :
            &vpapCache, &vpapAbs, cwPAP);
#endif /* STYLES */
        }

/* This little piece of code is necessary to provide compatibility between Word
and Memo documents.  It compresses the entire range of line spacing into single
spacing, one and one-half spacing, and double spacing. */
if (vpapAbs.dyaLine <= czaLine)
    {
    vpapAbs.dyaLine = czaLine;
    }
else if (vpapAbs.dyaLine >= 2 * czaLine)
    {
    vpapAbs.dyaLine = 2 * czaLine;
    }
else
    {
    vpapAbs.dyaLine = (vpapAbs.dyaLine + czaLine / 4) / (czaLine / 2) *
      (czaLine / 2);
    }

MeltHp();
}




DefaultPaps( doc )
int doc;
{
typeCP cpFirstSave, cpLimSave;
struct TBD (**hgtbd)[];

if (vcpFirstParaCache > cpMinCur)
        { /* Get pap from previous paragraph */
        cpFirstSave = vcpFirstParaCache;
        cpLimSave = vcpLimParaCache;
        CachePara(doc, cpFirstSave - 1); /* Recursion should not happen */
        vpapAbs.fGraphics = false; /* Don't make last para a picture */
        vpapAbs.rhc = 0;        /* Don't make last para a running head */
        vcpLimParaCache = cpLimSave;
        vcpFirstParaCache = cpFirstSave;
        return;
        }
#ifdef CASHMERE
blt(vppapNormal, &vpapAbs, cwPAPBase+cwTBD);
#else   /* For MEMO, the default PAPS have the document's tab table */
blt(vppapNormal, &vpapAbs, cwPAPBase);
GetTabsForDoc( doc );
#endif

#ifdef STYLES
blt(&vpapNormal, &vpapCache, cwPAP);
blt(PpropXlate(doc, &vpapNormal, &vpapStd), &vpapAbs, cwPAP);
#endif
}




GetTabsForDoc( doc )
int doc;
{   /* Get tab table for passed document into vpapAbs.rgtbd */
struct TBD (**hgtbd)[];

hgtbd = (**hpdocdod)[doc].hgtbd;
if (hgtbd==0)
    bltc( vpapAbs.rgtbd, 0, cwTBD * itbdMax );
else
    blt( *hgtbd, vpapAbs.rgtbd, cwTBD * itbdMax );
}



#ifdef CASHMERE
CacheSect(doc, cp)
int doc;
typeCP cp;
{
struct SETB **hsetb, *psetb;
struct SED *psed;
CHAR *pchFprop;
int cchT;
struct DOD *pdod;

if (doc == vdocSectCache && cp >= vcpFirstSectCache && cp < vcpLimSectCache)
        return;

if ( vdocSectCache != doc && cp != cp0 )
    CacheSect( doc, cp0 );  /* Changing docs, assure vsepPage is accurate */

vdocSectCache = doc;
visedCache = iNil;
blt(&vsepNormal, &vsepAbs, cwSEP);

if ((hsetb = HsetbGet(doc)) == 0)
        {
        vcpFirstSectCache = cp0;
        vcpLimSectCache =  (pdod = &(**hpdocdod)[doc])->cpMac + 1;
        blt(&vsepAbs, &vsepPage, cwSEP);        /* set up page info */
        return;
        }

psetb = *hsetb;
psed = psetb->rgsed;

FreezeHp();
psed += (visedCache = IcpSearch(cp + 1, psed, cchSED, bcpSED, psetb->csed));

Assert( (visedCache >= 0) && (visedCache < psetb->csed) );

vcpFirstSectCache = (visedCache == 0) ? cp0 : (psed - 1)->cp;
vcpLimSectCache = psed->cp;

if (psed->fc != fcNil)
    {
    pchFprop = PchFromFc(psed->fn, psed->fc, &cchT);
    if (*pchFprop != 0)
        bltbyte(pchFprop + 1, &vsepAbs, *pchFprop);
    }

if (vcpFirstSectCache == cp0)
    blt(&vsepAbs, &vsepPage, cwSEP);
else
    RecalcSepText();    /* Since this is not the first section of a document,
                         the margins could be wrong and must be recalculated */
MeltHp();
}
#endif  /* CASHMERE */



CacheSect(doc, cp)
int doc;
typeCP cp;
{           /* Get current section properties into vsepAbs; section
               limits into vcpFirstSectCache, vcpLimSectCache
               MEMO VERSION: one section per document */
 struct DOD *pdod;

 if (doc == vdocSectCache)
    return;

 vdocSectCache = doc;
 pdod = &(**hpdocdod)[doc];

 if ( pdod->hsep )
    blt( *pdod->hsep, &vsepAbs, cwSEP );
 else
    blt( &vsepNormal, &vsepAbs, cwSEP );

 vcpFirstSectCache = cp0;
 vcpLimSectCache = pdod->cpMac;
 blt(&vsepAbs, &vsepPage, cwSEP);
}




RecalcSepText()
{
/* calculate value to be changed because of change in page dimensions */
int xaRight, dxaText, cColumns;
int yaBottom, dyaText;

xaRight = vsepPage.xaMac - vsepPage.cColumns * vsepPage.dxaText -
          vsepPage.xaLeft - vsepPage.dxaGutter -
          (vsepPage.cColumns - 1) * vsepPage.dxaColumns;
dxaText = vdxaPaper - xaRight - vsepPage.xaLeft;
cColumns = vsepAbs.cColumns;
vsepAbs.dxaText = max(dxaMinUseful,
       ((dxaText-vsepPage.dxaGutter-(cColumns-1)*vsepAbs.dxaColumns)/cColumns));
vsepAbs.xaMac = vdxaPaper;

 /* Calculate bottom margin, correct */
yaBottom = vsepPage.yaMac - vsepPage.yaTop - vsepPage.dyaText;
vsepAbs.dyaText = max(dyaMinUseful, vdyaPaper - vsepPage.yaTop - yaBottom);
vsepAbs.yaMac = vdyaPaper;
}




InvalidateCaches(doc)
int doc;
{
if (doc == vfli.doc)    /* Invalidate current formatted line */
        vfli.doc = docNil;
if (doc == vdocExpFetch)
        vdocExpFetch = docNil;
if (doc == vdocParaCache)
        vdocParaCache = docNil;
if (doc == vdocSectCache)
        vdocSectCache = docNil;

/* When the current doc is equal to the cached doc, it is unnecessary */
/*  to invalidate the page cache when the vcpMinPageCache is 0 and the  */
/*  vcpMacPageCache is cpMax, since this indicates that all characters in  */
/*  the document are on page 1.           */
if ((doc == vdocPageCache) &&
    (!(vcpMinPageCache == cp0 && vcpMacPageCache == cpMax)))
        vdocPageCache = docNil;
}




TrashCache()
{ /* Invalidate scrolling cache */
ctrCache = 0;
cpCacheHint = cp0;
itrFirstCache = itrLimCache = 0;
}




typeFC FcParaFirst(fn, fc, fcMin)
int fn;
typeFC fc, fcMin;
{ /* Return the fc after the latest para end before fc.
        if there is no para end in [fcMin, fc), return fcNil. */
struct FCB *pfcb;

if ((fn == fnInsert) || (fc == fcMin))
    return fcNil;

if (fn == fnScratch && fc >= fcMacPapIns)
    return (fcMin <= fcMacPapIns) ? fcMacPapIns : fcNil;

pfcb = &(**hpfnfcb)[fn];
if (!pfcb->fFormatted)
    { /* Unformatted file; scan for an EOL */
    typePN pn;
    typeFC fcFirstPage;

#ifdef p2bSector
    fcFirstPage = (fc - 1) & ~(cfcPage - 1);
    pn = fcFirstPage / cfcPage;
#else
    pn = (fc - 1) / cfcPage;
    fcFirstPage = pn * cfcPage;
#endif

    while (fc > fcMin)
        {
        CHAR *pch;
        int cchT;

        pch = PchGetPn( fn, pn--, &cchT, false ) + (fc - fcFirstPage);
        if (fcMin > fcFirstPage)
            fcFirstPage = fcMin;
        while (fc > fcFirstPage)
            {
            if (*(--pch) == chEol)
                {
                return fc;
                }
            fc--;
            }
        fcFirstPage -= cfcPage;
        }
    return fcNil;
    }
else
    { /* Formatted file; get info from para run */
    struct FKP *pfkp;
    typeFC fcFirst, fcLim;
    int cchT;

    pfkp = (struct FKP *) PchGetPn(fn, fn == fnScratch ?
        PnFkpFromFcScr(&vfkpdParaIns, fc) :
          pfcb->pnPara + IFromFc(**pfcb->hgfcPap, fc), &cchT, false);
    if (vfDiskError)
        return fcNil;
    BFromFc(pfkp, fc, &fcFirst, &fcLim);
    return (fcMin < fcFirst) ? fcFirst : fcNil;
    }
}




typeFC FcParaLim(fn, fc, fcMac, ppap)
int fn;
typeFC fc, fcMac;
struct PAP *ppap;
{ /* Return the fc after the first para end after or at fc.
        if there is no para end in [fc, fcMac), return fcNil. */
/* Also return paragraph properties in ppap */
 struct FCB *pfcb;

/* Start out by feeding caller the normal pap */
#ifdef CASHMERE
 blt(vppapNormal, ppap, cwPAPBase + cwTBD);
#else
 blt(vppapNormal, ppap, cwPAPBase);
#endif

 if ( (fn == fnInsert) || ((fn == fnScratch) && (fc >= fcMacPapIns)) )
        return fcNil;

 if (!(pfcb = &(**hpfnfcb) [fn])->fFormatted)
        { /* Unformatted file; scan for EOL */
        typePN pn;
        typeFC fcFirstPage;

#ifdef p2bSector
        fcFirstPage = fc & ~(cfcPage - 1);
        pn = fcFirstPage / cfcPage;
#else
        pn = fc / cfcPage;
        fcFirstPage = pn * cfcPage;
#endif

        while (fc < fcMac)
                {
                CHAR *pch;
                int cchT;

                pch = PchGetPn( fn, pn++, &cchT, false ) + (fc - fcFirstPage);

                if ((fcFirstPage += cfcPage) > fcMac)
                        fcFirstPage = fcMac;
                while (fc < fcFirstPage)
                        {
                        fc++;
                        if (*pch++ == chEol)
                                return fc;
                        }
                }
        return fcNil;
        }
else
        { /* Formatted file; get info from para run */
        struct FKP *pfkp;
        struct FPAP *pfpap;
        int bfpap;
        typeFC fcLim;
        int cchT;

        pfkp = (struct FKP *) PchGetPn(fn, fn == fnScratch ?
            PnFkpFromFcScr(&vfkpdParaIns, fc) :
              pfcb->pnPara + IFromFc(**pfcb->hgfcPap, fc), &cchT, false);
        if (vfDiskError)
            {   /* Recover from severe disk error reading formatting info */
            blt(vppapNormal, ppap, cwPAP);
            return (fcMac == pfcb->fcMac) ? fcMac : fcNil;
            }

        {   /* In-line, fast substitute for BFromFc */
        register struct RUN *prun = (struct RUN *) pfkp->rgb;

        while (prun->fcLim <= fc)
            prun++;

        fcLim = prun->fcLim;
        bfpap = prun->b;
        }

        if (fcLim <= fcMac)
                {
                if (bfpap != bNil)
                        { /* Non-standard para */
                        pfpap = (struct FPAP *) &pfkp->rgb[bfpap];
                        bltbyte(pfpap->rgchPap, ppap, pfpap->cch);
                        }
                return fcLim;
                }
        return fcNil;
        }
}


/* B  F R O M  FC */
int BFromFc( pfkp, fc, pfcFirst, pfcLim )
struct FKP *pfkp;
typeFC fc;
typeFC *pfcFirst, *pfcLim;
{   /* Return the base offset & bounds for the first run with fcLim > fc. */
    /* Short table, linear search */
 register struct RUN *prun = (struct RUN *) pfkp->rgb;

 while (prun->fcLim <= fc)
    prun++;

 *pfcFirst = ((prun == (struct RUN *)pfkp->rgb) ?
                                       pfkp->fcFirst : (prun - 1)->fcLim);
 *pfcLim = prun->fcLim;
 return prun->b;
}



/* I  F R O M  F C */
int IFromFc(pfcLim, fc)
register typeFC *pfcLim;
typeFC fc;
{ /* Return the index of the first fcLim > fc. */
int ifc = 0;

/* Probably a small table, so linear search? */
while (*pfcLim++ <= fc)
        ++ifc;
return ifc;
}





#ifdef BOGUSBL
/*  B  F R O M   F C */
int BFromFc(pfkp, fc, pfcFirst, pfcLim)
struct FKP *pfkp;
typeFC fc;
typeFC *pfcFirst, *pfcLim;
{ /* Return the base offset & bounds for the first run with fcLim > fc. */
struct RUN *prun, *rgrun;
int ifcMin, ifcLim;

ifcMin = 0;
ifcLim = pfkp->crun;
rgrun = (struct RUN *)pfkp->rgb;

#ifdef INEFFICIENT
ifc = IcpSearch(fc + 1, pfkp->rgb, cchRUN, bfcRUN, pfkp->crun);
#endif

while (ifcMin + 1 < ifcLim)
        {
        int ifcGuess = (ifcMin + ifcLim - 1) >> 1;
        if (rgrun[ifcGuess].fcLim <= fc)
                ifcMin = ifcGuess + 1;
        else
                ifcLim = ifcGuess + 1;
        }

prun = &rgrun[ifcMin];
*pfcLim = prun->fcLim;
*pfcFirst = (ifcMin == 0 ? pfkp->fcFirst : (prun - 1)->fcLim);
return prun->b;
}
#endif  /* BOGUSBL */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\chngwin.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOCLIPBOARD
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#define NODRAWTEXT
#define NOSOUND
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "winddefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "docdefs.h"
#include "debug.h"

extern HWND             vhWnd;
extern HWND             vhWndSizeBox;
extern HWND             vhWndRuler;
extern HWND             vhWndPageInfo;
extern HWND             vhWndCancelPrint;
extern HDC              vhDCPrinter;
extern HFONT            vhfPageInfo;
extern HCURSOR          vhcArrow;
extern HCURSOR          vhcIBeam;
extern HCURSOR          vhcBarCur;
extern struct WWD       rgwwd[];
extern struct WWD       *pwwdCur;
extern HANDLE           hMmwModInstance; /* handle to own module instance */
extern int              vfShiftKey;
extern int              vfCommandKey;
extern int              vfOptionKey;
extern int              vfDoubleClick;
extern struct SEL       selCur;
extern long             rgbBkgrnd;
extern long             rgbText;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;
extern int              vfIconic;
extern int              vfLargeSys;
extern int              dxpRuler;
extern HMENU    vhMenu;

#ifdef	JAPAN	// Indicate whether to show IME convert window
extern	BOOL	ConvertEnable;
#endif



void MmwSize(hWnd, cxpNew, cypNew, code)
HWND hWnd;
int cxpNew;
int cypNew;
WORD code;
{
    if (code == SIZEICONIC)
        {
#ifdef NOT_RECOMMENDED
/* This should already be done by Windows itself! 
   Moving here could cause confusion */

        /* Resize the document window. */
        if (wwdCurrentDoc.wwptr != NULL)
            MoveWindow(wwdCurrentDoc.wwptr, 0, 0, 0, 0, FALSE);
#endif

        /* Deselect our fonts so that they can move if necessary. */
        ResetFont(FALSE);
        if (vhWndCancelPrint == NULL)
            {
            /* Reset the printer font iff we are not printing or repaginating.
            */
            ResetFont(TRUE);
            }
        if (!vfLargeSys && vhfPageInfo != NULL)
            {
            DeleteObject(SelectObject(GetDC(vhWndPageInfo),
              GetStockObject(SYSTEM_FONT)));
            vhfPageInfo = NULL;
            }

        vfIconic = TRUE;
        }
    else
        {
        int dxpBorder = GetSystemMetrics(SM_CXBORDER);
        int dypBorder = GetSystemMetrics(SM_CYBORDER);
        int xpMac = cxpNew - dxpScrlBar + dxpBorder;
        int ypMac = cypNew - dypScrlBar + dypBorder;
        int dypOverlap = 0;

        /* If we are coming back from being iconic, then reestablish the printer
        DC. */
        if (vfIconic && vhDCPrinter == NULL)
            {
            GetPrinterDC(FALSE);
            }

        /* Reposition all of the windows. */
        MoveWindow(wwdCurrentDoc.hVScrBar, xpMac, -dypBorder, dxpScrlBar, ypMac
          + (dypBorder << 1), TRUE);
        MoveWindow(wwdCurrentDoc.hHScrBar, dxpInfoSize, ypMac, cxpNew -
          dxpInfoSize - dxpScrlBar + (dxpBorder << 1), dypScrlBar, TRUE);
#ifndef NOMORESIZEBOX        
        MoveWindow(vhWndSizeBox, xpMac, ypMac, dxpScrlBar, dypScrlBar, TRUE);
#endif
        MoveWindow(vhWndPageInfo, 0, ypMac, dxpInfoSize, dypScrlBar, TRUE);
        if (vhWndRuler != NULL)
            {
            dypOverlap = dypRuler - (wwdCurrentDoc.ypMin - 1);
            MoveWindow(vhWndRuler, 0, 0, xpMac, dypRuler, TRUE);
            }

        /* Resize the document window. */
        if (wwdCurrentDoc.wwptr != NULL)
            {
            MoveWindow(wwdCurrentDoc.wwptr, 0, dypOverlap, xpMac, ypMac -
              dypOverlap, FALSE);

            /* Validate the area of the document window that is overlapped by
            the ruler if necessary. */
            if (vhWndRuler != (HWND)NULL)
                {
                RECT rc;

                rc.left = rc.top = 0;
                rc.right = dxpRuler;
                rc.bottom = wwdCurrentDoc.ypMin;
                ValidateRect(wwdCurrentDoc.wwptr, (LPRECT)&rc);
                }

            }

        vhMenu = GetMenu(hWnd); // kludge patch cause Write does its own
                                // accelerator handling (6.24.91) v-dougk
        vfIconic = FALSE;
        }
}




void MdocSize(hWnd, cxpNew, cypNew, code)
HWND hWnd;
int cxpNew;
int cypNew;
WORD code;
{
extern int wwCur;
extern int vfSeeSel;
extern int vfInitializing;

    typeCP cp;
    struct EDL *pedl;

    /* Let's start thing off with a couple of assumptions. */
    Assert( code == SIZENORMAL || code == SIZEFULLSCREEN );
    Assert( wwdCurrentDoc.wwptr == hWnd );

#ifdef ENABLE   /* We repaint completely on resize */
    if (cypNew > wwdCurrentDoc.ypMac)
            /* We are growing vertically, mark exposed area invalid
               so UpdateWw does not try to recycle a partial line
               at the bottom of the window. */
        InvalBand( &wwdCurrentDoc, wwdCurrentDoc.ypMac, cypNew );
#endif
    if (wwCur != wwNil)
        TrashWw( wwCur );

        /* Mark the window dirty so that dlMac gets reset according to the new
           window size */
    wwdCurrentDoc.fDirty = TRUE;

    wwdCurrentDoc.xpMac = cxpNew;
    wwdCurrentDoc.ypMac = cypNew;

    /* If minimizing the window, we are done */
    if ((cxpNew == 0) && (cypNew == 0))
        return;

        /* If the selection was visible before, so shall it be hereafter */
    if ( ((cp = CpEdge()) >= wwdCurrentDoc.cpFirst) &&
         (wwdCurrentDoc.dlMac > 0) &&
         (cp < (pedl =
                   &(**wwdCurrentDoc.hdndl)[wwdCurrentDoc.dlMac - 1])->cpMin +
               pedl->dcpMac))
        {
        /* Normally, we would just set vfSeeSel and wait for Idle to
           put the selection in view.  However, we can be resized even
           when we are not the current app, and in that case Idle will not
           get called soon enough. So, we scroll the selection into view here */

        if (!vfInitializing)
            {    /* Avoid the peril of trying to do this operation too early */
            extern int wwCur;

            UpdateWw( wwCur, FALSE );   /* To lock in the new dlMac */
            PutCpInWwVert( cp );
            UpdateWw( wwCur, FALSE );
            }
        }
}



FreeMemoryDC( fPrinterToo )
BOOL fPrinterToo;
{
extern HDC vhMDC;
extern int dxpbmMDC;
extern int dypbmMDC;
extern HBITMAP hbmNull;

/* Delete the memory DC if necessary. */
if ( vhMDC != NULL )
    {
    /* Delete the old bitmap if necessary. */
    if (dxpbmMDC != 0 || dypbmMDC != 0)
        {
        DeleteObject( SelectObject( vhMDC, hbmNull ) );
        dxpbmMDC = dypbmMDC = 0;
        }
    /* Discard the screen fonts. */
    FreeFonts( TRUE, FALSE );

    /* Delete the memory DC. */
    DeleteDC( vhMDC );
    vhMDC = NULL;
    }

/* Also, delete the DC for the printer width, if necessary. */
if ( fPrinterToo )
    {
    FreePrinterDC();
    }
}


FreePrinterDC()
{
extern int vdocBitmapCache;
extern HDC vhDCPrinter;
extern BOOL vfPrinterValid;
extern HWND hParentWw;

/* Delete the printer DC if necessary. */
if ( vhDCPrinter != NULL )
    {
    /* Discard the printer fonts. */
    FreeFonts( FALSE, TRUE );

    if ( vfPrinterValid )
        {
        /* This is a real printer DC; delete it. */
        DeleteDC( vhDCPrinter );
        }
    else
        {
        /* This is really the screen DC; it must be released. */
        ReleaseDC( hParentWw, vhDCPrinter );
        }
    vhDCPrinter = NULL;

    /* Free the cached bitmap because it was stretched for the display to
    reflect its appearance on the printer. */
    if (vdocBitmapCache != docNil)
        FreeBitmapCache();
    }
}


void MdocGetFocus(hWnd, hWndPrevFocus)
HWND hWnd;
HWND hWndPrevFocus;
{
extern int vfInsertOn;
extern int vfFocus;

 if (!vfFocus)
    {
    vfFocus = TRUE;
        /* Start up a timer event to blink the caret */
        /* MdocWndProc gets notified with a message of WM_TIMER */
        /* every wCaretBlinkTime milliseconds */
    SetTimer( hWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );

        /* Set the caret on right away, for looks */
    if (!vfInsertOn)
        MdocTimer( hWnd, tidCaret );

        /* Update globals that tell us the state of the lock/shift keys */
    SetShiftFlags();
    }
#ifdef	JAPAN
	ConvertEnable = TRUE;
	IMEManage( FALSE );
#endif
}



void MdocLoseFocus(hWnd, hWndNewFocus)
HWND hWnd;
HWND hWndNewFocus;
{
 extern int vfFocus;

 if (vfFocus)
    {
    extern int vfGotoKeyMode;

        /* Cancel caret blink timer event & clear the caret */
    KillTimer( hWnd, tidCaret );
    ClearInsertLine();
        /* Free up the memory DC */
        /* We interpret the loss of focus as a signal that */
        /* some other app will be using resources */
    vfFocus = FALSE;
    vfGotoKeyMode = FALSE;  /* Cancel GOTO key modifier */
        /* Close all files on removable media in case the guy swaps disks */
    CloseEveryRfn( FALSE );
    }
#ifdef	JAPAN
	ConvertEnable = FALSE;
	IMEManage( TRUE );
#endif
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\clipbord.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* clipbord.c -- Cut/Paste to clipboard */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCTLMGR
#define NOFONT
#define NOPEN
#define NOBRUSH
#define NOSCROLL
#define NOCOMM
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "str.h"
#include "propdefs.h"
#include "editdefs.h"
#include "winddefs.h"
#include "filedefs.h"
#include "wwdefs.h"
#include "prmdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
#endif

#include "debug.h"

extern struct SEL       selCur;      /* Current selection (i.e., sel in current ww */
extern int              docCur;     /* Document in current ww */

extern int              docUndo;
extern int              docScrap;
extern int              vfSeeSel;
extern struct DOD       (**hpdocdod)[];
extern struct PAP       vpapAbs;
extern typeCP           vcpLimParaCache;
extern typeCP           vcpFirstParaCache;
extern int              vfPictSel;
extern HCURSOR          vhcIBeam;
extern int              vfScrapIsPic;
extern struct UAB       vuab;
extern int              ferror;
extern struct FCB       (**hpfnfcb)[];
extern struct WWD       rgwwd[];

/* THESE ARE LOCAL TO THIS MODULE */
#if defined(OLE)
int NEAR PASCAL CopyScrapToTmp(void);
#endif

    /* fn we created during the last non-local cut of MEMO rich text */
int fnLastCut=fnNil;
    /* Local communication between ChangeClipboard() and MdocDestroyClip() */
int fDontDestroyClip=FALSE;


FMdocClipboardMsg( message, wParam, lParam )
unsigned message;
WORD wParam;
LONG lParam;
{   /* Process WRITE clipboard messages sent to MdocWndproc.
       return TRUE if a message was processed, FALSE otherwise */

 switch (message)
    {
    default:
        return FALSE;

    /*-------DATA INTERCHANGE COMMANDS-----------*/
    case WM_CUT:
        fnCutEdit();
        break;

    case WM_COPY:
        fnCopyEdit();
        break;

    case WM_PASTE:
#if defined(OLE)
        vbObjLinkOnly = FALSE;
#endif
        fnPasteEdit();
        break;

    case WM_CLEAR:
        fnClearEdit(OBJ_DELETING);
        break;

    case WM_UNDO:
        fnUndoEdit();
        break;

    /*---------------CLIPBOARD INTERACTION-------------*/

    case WM_DESTROYCLIPBOARD:
        /*  A notification that we are about to lose the ownership
            of the clipboard.  We should free any resources that are
            holding the contents of the clipboard */
        MdocDestroyClip();
        break;

    case WM_RENDERFORMAT:
        /* A request to render the contents of the clipboard
           in the data format specified.  Reception of this message
           implies that the receiver is the current owner of the
           clipboard. See clipbord.c */
        MdocRenderFormat( wParam );
        break;

    /*-------CLIPBOARD DISPLAY---------------------*/

    case WM_PAINTCLIPBOARD:
            /* A request to paint the clipboard contents.
               wParam is a handle to the clipboard window
               LOWORD( lParam ) is a handle to a PAINTSTRUCT giving
                    a DC and RECT for the area to repaint */

        MdocPaintClipboard( wParam, LOWORD(lParam) );
        break;

    case WM_VSCROLLCLIPBOARD:
            /* A request to vertically scroll the clipboard contents.
               wParam is a handle to the clipboard window
               LOWORD( lParam ) is the scroll type (SB_)
               HIWORD( lParam ) is the new thumb position (if needed) */

        MdocVscrollClipboard( wParam, LOWORD(lParam), HIWORD(lParam) );
        break;

    case WM_HSCROLLCLIPBOARD:
            /* A request to horizontally scroll the clipboard contents.
               wParam is a handle to the clipboard window
               LOWORD( lParam ) is the scroll type (SB_)
               HIWORD( lParam ) is the new thumb position (if needed) */

        MdocHscrollClipboard( wParam, LOWORD(lParam), HIWORD(lParam) );
        break;

    case WM_SIZECLIPBOARD:
            /* A notification that the clipboard window is being re-sized.
               wParam is a handle to the clipboard window
               LOWORD(lParam) is a handle to a RECT giving the new size */

        MdocSizeClipboard( wParam, LOWORD(lParam) );
        break;

    case WM_ASKCBFORMATNAME:
        /* A request for the name of the CF_OWNERDISPLAY clip format.
           wParam is the max. # of chars to store (including terminator)
           lParam is a long pointer to a buffer in which to store the name */

        MdocAskCBFormatName( (LPCH) lParam, wParam );
        break;
    }

 return TRUE;
}




fnCopyEdit()
{               /* COPY command: copy selection to clipboard */
 extern int vfOwnClipboard;
 typeCP cpFirst;
 typeCP dcp;

 StartLongOp();

 cpFirst = selCur.cpFirst;
 SetUndo( uacReplScrap, docCur, cpFirst, dcp = selCur.cpLim - cpFirst,
          docNil, cpNil, cp0, 0);
 SetUndoMenuStr(IDSTRUndoEdit);

 ClobberDoc(docScrap, docCur, cpFirst, dcp);

#ifdef DCLIP
    {
    char rgch[100];
    wsprintf(rgch,"fnCopyEdit: cpFirst %lu, dcp %lu \n\r", cpFirst, dcp);
    CommSz(rgch);
    }
#endif

 if (ferror)
    NoUndo();
 else
    {
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        MakeScrapUnRunning();
    vfScrapIsPic = vfPictSel;
    }

#ifdef STYLES
(**hpdocdod)[docScrap].docSsht = (**hpdocdod)[docCur].docSsht;
#endif


#if defined(OLE)
    ObjEnumInDoc(docScrap,ObjCloneObjectInDoc);
#endif

ChangeClipboard();      /* Force repaint of clipboard display & Set ownership */

 EndLongOp(vhcIBeam);
}


MakeScrapUnRunning()
{   /* If the 1st para of docScrap is a running head,
       apply a sprm to the whole of docScrap that gives it an rhc code of 0.
       This is to avoid pasting running head stuff into the main part of a doc */

 CHAR rgb [2];
 typeCP cpMacScrap = (**hpdocdod) [docScrap].cpMac;

 if (cpMacScrap != cp0 )
    {
    CachePara( docScrap, cp0 );
    if (vpapAbs.rhc != 0)
        {
        rgb [0] = sprmPRhc;
        rgb [1] = 0;
        AddSprmCps( rgb, docScrap, cp0, cpMacScrap );
        }
    }
}




fnCutEdit()
{               /* CUT command: copy selection to clipboard & delete it */
 extern int vfOwnClipboard;
 typeCP cpFirst, cpLim, dcp;

 ClearInsertLine();     /* Since we will be affecting cp's */

 if (!FWriteOk( fwcDelete ))
        /* Not OK to write on this doc */
    return;

 cpFirst = selCur.cpFirst;
 cpLim = selCur.cpLim;

 if (!ObjDeletionOK(OBJ_CUTTING))
    return;

 StartLongOp();

 SetUndo( uacDelScrap, docCur, cpFirst, dcp = cpLim - cpFirst, docNil,
          cpNil, cp0, 0);
 ClobberDoc(docScrap, docCur, cpFirst, dcp);
 if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
    MakeScrapUnRunning();


 if (!ferror) /* Don't stomp document if Clobber Doc failed	*/
    {
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        MakeScrapUnRunning();
    Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
    }
else
    NoUndo(); /* undo would be invalid */

#ifdef STYLES
(**hpdocdod)[docScrap].docSsht = (**hpdocdod)[docCur].docSsht;
#endif

 vfScrapIsPic = vfPictSel;
 vfPictSel = false;

 ChangeClipboard();     /* Force repaint of clipboard display, get ownership */

#if 0
#if defined(OLE)
    ObjEnumInDoc(docScrap,ObjCloneObjectInDoc);
#endif
#endif

 EndLongOp(vhcIBeam);
}


fnPasteEdit()
{
 /* PASTE command: replace selection    with clipboard contents */
 extern CHAR szDocClass[];
 extern int vfScrapIsPic;
 extern HWND vhWnd;
 HWND hWndClipOwner;
 int fUnFormattedText = FALSE;
 typeCP cpFirst = selCur.cpFirst;
 BOOL bClearScrap=FALSE;

 StartLongOp();

 if ( (hWndClipOwner = GetClipboardOwner()) != vhWnd )
    {   /* Clipboard owner is not this instance of memo */
    if ( (hWndClipOwner == NULL) ||
         !FSameClassHwndSz( hWndClipOwner, szDocClass ))
        {   /* Clipboard owner is not MEMO -- process standard CF_ formats */
        if ( !FReadExtScrap() )
            goto PasteErr;

        bClearScrap = TRUE;
        fUnFormattedText = !vfScrapIsPic;
        }
    else
        {   /* Clipboard owner is another instance of MEMO */
        if (!FGrabExtMemoScrap())
            goto PasteErr;
        }
    }

    /* Replace the selection with the scrap document */
 CmdInsScrap( fUnFormattedText );

 if (ferror)
    goto PasteErr;

#if defined(OLE)
    if (!bClearScrap) // then we're keeping scrap, need to clone
    {
        if (ObjEnumInDoc(docScrap,ObjCloneObjectInDoc) < 0)
            goto PasteErr;
    }

    else // then we're not keeping scrap (came from clipboard)
    {
        /*
        We don't need contents anymore, and if it contains an object,
        then its got to go because its been inserted into the doc and not cloned
        and we don't want a duplicate around.

        Also gotta mark the object in docCur as no longer reusable (if
        it gets copied later we will need to clone it).
        */
        typeCP cpLim = cpFirst+CpMacText(docScrap);
        ClobberDoc(docScrap,docNil,cp0,cp0);
        ObjEnumInRange(docCur,cpFirst,cpLim,ObjFromCloneInDoc);
    }
#endif

 EndLongOp(vhcIBeam);
 return;

PasteErr:
 NoUndo();
 EndLongOp(vhcIBeam);
 _beep();
}



MdocRenderFormat( wCf )
int wCf;
{       /* Render clipboard data in format specified by wCf */
 typeCP cpMac=CpMacText( docScrap );
 struct PICINFOX picInfo;

#if defined(OLE)
    if (vfScrapIsPic)
    {
        GetPicInfo( cp0, cpMac, docScrap, &picInfo );

        if ((picInfo.mfp.mm == MM_OLE) && (wCf != CF_OWNERDISPLAY))
            goto Render;
    }
#endif

 switch (wCf) {

    case CF_OWNERDISPLAY:
            /* Render rich text to another MEMO instance */
        FPutExtMemoScrap();
        break;

    case CF_TEXT:
            /* Remove formatting from scrap; put bare text out to clipboard */
        goto Render;

    case CF_BITMAP:
            if (picInfo.mfp.mm == MM_BITMAP)
                {
                goto Render;
                }
        break;

    case CF_METAFILEPICT:
            /* We can supply this if the scrap is a metafile picture */
            if (picInfo.mfp.mm != MM_BITMAP)
                {
                Render:
                if (!FWriteExtScrap())
                    Error( IDPMTClipLarge );
                }
        break;

 }

}




MdocDestroyClip()
{       /* Handles WM_DESTROYCLIPBOARD message.  We are being notified that
           the clipboard is being emptied & we don't need to keep its
           contents around anymore. */

 extern int vfOwnClipboard;
 extern HWND vhWnd;

 if (fDontDestroyClip)
    return;

 vfOwnClipboard = FALSE;

     /* Clear out the scrap document */
 ClobberDoc( docScrap, docNil, cp0, cp0 );

     /* Disable UNDO operations that require the clipboard */
 switch (vuab.uac) {
 case uacDelScrap:
 case uacUDelScrap:
 case uacReplScrap:
 case uacUReplScrap:
    NoUndo();
    break;
 }

    /* Remove all records of the file we generated in FPutExtMemoScrap
       from the hpfnfcb array.  Note that we assume that no document
       in this instance has pieces of fn. */

if ( fnLastCut != fnNil )
    {
    FreeFn( fnLastCut );
    fnLastCut = fnNil;
    }

    /* If we made a wwd entry for the display of the clipboard,
       remove it now.  We test here to avoid bringing in the
       CLIPDISP module if we never did any display. */
    {
    if (wwClipboard != wwNil)
        FreeWw( wwClipboard );
    }
}




int FPutExtMemoScrap()
{   /* Write docScrap to a new file; send the normalized name
       of the file to the clipboard as data handle for rich text type.
       Assumes clipboard is open for SetClipboardData call.  On exit,
       the file written has an fn, but no document (including docScrap)
       has pieces that point to it.  This allows us to relinquish
       ownership of the fn to the pasting instance.
       RETURN: TRUE == OK, FALSE == ERROR
     */
 int fn;
 CHAR szT[ cchMaxFile ];
 HANDLE hMem;
 LPCH   lpch;
 int cch;
#if defined(OLE)
 int     docTemp;
#endif

    /* Create a new, formatted file with a unique name */
 szT [0] = '\0';    /* Create it on a temp drive in the root */
 if ((fn = FnCreateSz( szT, cp0, dtyNetwork ))== fnNil )
    {
    return FALSE;
    }

 fnLastCut = fn;    /* Save in a static so we can relinquish it later */

    /* Save scrap document to file.  Note that FWriteFn does NOT modify
       the piece table of docScrap, so no document has pieces pointing
       to fn.  This is important because we don't want local pastes
       to generate pieces pointing to this fn; we want to be able to cleanly
       transfer ownership of the fn to another instance */

#if defined(OLE)
 if ((docTemp = CopyScrapToTmp()) == docNil)
 {
    FDeleteFn( fn );    /* This will free the fn even if deleting the file
                           fails */
    return FALSE;
 }
#endif

 if (!FWriteFn( fn, docTemp, TRUE ))
    {
    FDeleteFn( fn );    /* This will free the fn even if deleting the file
                           fails */
    return FALSE;
    }


#if defined(OLE)
 if (docTemp != docScrap)
    KillDoc (docTemp);
#endif

    /* Make a global handle containing the name of the file; send it to the
       clipboard as the rendering of the rich text format */

 if ( ((hMem = GlobalAlloc( GMEM_MOVEABLE, (LONG)(cch=CchSz( szT ))))== NULL ) ||
      ((lpch = GlobalLock( hMem )) == NULL) )
    {
    return FALSE;
    }
 bltbx( (LPCH)szT, lpch, cch );
 GlobalUnlock( hMem );

 SetClipboardData( CF_OWNERDISPLAY, hMem );

 return TRUE;
}




int FGrabExtMemoScrap()
{
/* We get here on a PASTE if the clipboard contains rich text from a
   MEMO instance other than this one.  This routine requests the contents of
   the clipboard from the other instance, and places the contents into docScrap.
   The contents of the clipboard are passed in a MEMO formatted file, whose
   filename is contained in the clipboard's	handle.	 The instance that owns
   the clipboard does not keep any references to the fn for the clipboard
   file (once we EmptyClipboard).  After pasting, this routine arrogates
   the ownership of the clipboard to this instance.
   returns FALSE=error, true=OK */

    extern int vfOwnClipboard;
    extern HWND vhWnd;

    LPCH lpch;
    CHAR szT [cchMaxFile];
    int  fn;
    typeFC dfc;
    HANDLE hData;
    int fOK=false;

    /* Open Clipboard to lock out contenders */

    if ( !OpenClipboard( vhWnd ))
        {
        return FALSE;
        }

    /* Grab clipboard data handle contents: it is a normalized
       filename string referring to a formatted file containing
       the rich text.  The GetClipboardData call actually initiates
       a WM_RENDERFORMAT message to which MdocRenderFormat responds */

    if ( ((hData = GetClipboardData( CF_OWNERDISPLAY )) == NULL ) ||
         ((lpch = GlobalLock( hData )) == NULL ) )
        {
        goto GrabErr;
        }

    bltszx( lpch, (LPCH)szT );
    GlobalUnlock( hData );  /* handle will be freed in EmptyClipboard sequence */

    /* Open the file; replace the contents of the scrap document
       with the contents of the file */

    if ((fn = FnOpenSz( szT, dtyNormal, FALSE )) == fnNil)
        {   /* Unfortunately, if this fails, the file that the other
               instance created will "float", with noone holding an fn
               for it, and it will not get deleted at the end of the session.
               On the bright side, if the reason for the failure was that
               the file never got created anyway, we have done exactly right */
        goto GrabErr;
        }

    {   /* Opened file OK */
    struct FCB *pfcb = &(**hpfnfcb)[fn];
    struct FFNTB **hffntb;
    struct FFNTB **HffntbCreateForFn();
    int wUnused;

    pfcb->fDelete = TRUE;
    dfc = pfcb->fFormatted ? cfcPage : fc0;
    Replace( docScrap,
             cp0,
             (**hpdocdod)[docScrap].cpMac,
             fn,
             dfc,
             pfcb->fcMac - dfc );

    /* give the scrap the correct font table */
    FreeFfntb((**hpdocdod)[docScrap].hffntb);
    if (FNoHeap(hffntb = HffntbCreateForFn(fn, &wUnused)))
            hffntb = 0;
    (**hpdocdod)[docScrap].hffntb = hffntb;
    }

#if defined(OLE)
    /* if there are any objects in there, Load 'em */
    if (ObjEnumInDoc(docScrap,ObjLoadObjectInDoc) < 0)
        fOK = FALSE;
    else
#endif
        fOK = !ferror;     /* All is well if we didn't run out of memory */

        /* Take over ownership of the clipboard.  This results in a
           WM_DESTROYCLIPBOARD message being sent to the other instance,
           which will delete its fn entry for the file so we are the
           exclusive owners */

GrabErr:
    CloseClipboard();
    ChangeClipboard();
    return fOK;
}




ChangeClipboard()
{   /* Mark clipboard as changed.  If we are not the owner of the clipboard, */
    /* make us the owner (via EmptyClipboard).  The EmptyClipboard call */
    /* will result in a WM_DESTROYCLIPBOARD message being sent to the */
    /* owning instance.  The CloseClipboard call will result in a */
    /* WM_DRAWCLIPBOARD message being sent to the clipboard viewer. */
    /* If the clipboard viewer is CLIP.EXE, we will get a WM_PAINTCLIPBOARD */
    /* message */
    /* Added 10/8/85 by BL: If docScrap is empty, relinquish ownership */
    /* of the clipboard */

 extern int vfOwnClipboard;
 extern HWND vhWnd;
 int cf;
 struct PICINFOX picInfo;
 typeCP cpMacScrap = (**hpdocdod) [docScrap].cpMac;

 if (!OpenClipboard( vhWnd ))
    {   /* Couldn't	open the clipboard,	wipe out contents &	disable	UNDO */
    MdocDestroyClip();
    return;
    }

 /* We want to clear out previous data formats in the clipboard.
    Unfortunately, the only way to do this is to call EmptyClipboard(),
    which has the side effect of calling us with a WM_MDOCDESTROYCLIP
    message. We use this primitive global comunication to prevent
    docScrap from being wiped out in MdocDestroyClip() */

 fDontDestroyClip = TRUE;
 EmptyClipboard();
 fDontDestroyClip = FALSE;

 /* Re-validate vfScrapIsPic (in case a docScrap edit changed what it should be */

 CachePara( docScrap, cp0 );
 vfScrapIsPic = (vpapAbs.fGraphics && vcpLimParaCache == cpMacScrap);

 if (!vfScrapIsPic)
    cf = CF_TEXT;
 else
    {
    GetPicInfo( cp0, cpMacScrap, docScrap, &picInfo );
    switch(picInfo.mfp.mm)
    {
        case MM_BITMAP:
            cf = CF_BITMAP;
        break;

        case MM_OLE:
            cf = 0;
        break;

        default:
            cf = CF_METAFILEPICT;
        break;
    }
    }

 vfOwnClipboard = (cpMacScrap != cp0);
 if (vfOwnClipboard)
    {   /* only set handles if we really have something in docScrap */
    SetClipboardData( CF_OWNERDISPLAY, NULL );
    if ((cf != CF_TEXT) && (picInfo.mfp.mm == MM_OLE))
    {
        while (cf = OleEnumFormats(lpOBJ_QUERY_OBJECT(&picInfo),cf))
        {
            if (cf == vcfLink)
                SetClipboardData( vcfOwnerLink, NULL );
            else
                SetClipboardData( cf, NULL );
            //if (cf == vcfNative)
                //SetClipboardData( vcfOwnerLink, NULL );
        }
    }
    else
        SetClipboardData( cf, NULL );
    }

 CloseClipboard();
}

#ifdef JAPAN //T-HIROYN Win3.1
extern typeCP          vcpFetch;
extern int             vcchFetch;
extern CHAR            *vpchFetch;
#endif

CmdInsScrap( fUnFormattedText )
int fUnFormattedText;
{    /* Insert the scrap into the document at the current point (PASTE) */
     /* If fUnFormattedText is TRUE, the scrap is treated as unformatted */
     /* text; that is, the characters are put into the document with the */
     /* formatting that is active at the selection */
extern struct CHP vchpSel;
typeCP cp, dcp;
int cchAddedEol=0;
struct CHP chpT;

if (!FWriteOk( fwcInsert ))
    return;

if ((dcp = CpMacText(docScrap)) == cp0)
    return;

ClearInsertLine();

if (fnClearEdit(OBJ_INSERTING))
    return;

chpT = vchpSel;
cp = selCur.cpFirst;

CachePara( docScrap, cp0 );
if (vpapAbs.fGraphics && cp > cp0)
    { /* Special case for inserting a picture paragraph */
      /* Must put an Eol in front of the picture unless we're
         inserting it at the start of the document or one is there already */

    Assert( !fUnFormattedText );
    (**hpdocdod)[docCur].fFormatted = fTrue;
    CachePara(docCur, cp - 1);
    if (vcpLimParaCache != cp)
        {
        cchAddedEol = ccpEol;

        InsertEolPap(docCur, cp, &vpapAbs);
        dcp += (typeCP)ccpEol;
        }
    }

SetUndo( uacInsert, docCur, cp, dcp, docNil, cpNil, cp0, 0 );

SetUndoMenuStr(IDSTRUndoEdit);
ReplaceCps(docCur, cp + (typeCP)cchAddedEol, cp0, docScrap, cp0,
                                        dcp - (typeCP)cchAddedEol);
if (ferror) /* Not enough memory to do replace operation */
    NoUndo();  /* should not be able to undo what never took place */
else
    {
    typeCP cpSel=CpFirstSty( cp + dcp, styChar );

    if (vfScrapIsPic && vuab.uac == uacReplNS)
            /* Special UNDO code for picture paste */
        vuab.uac = uacReplPic;

    if (fUnFormattedText)
        {   /* If pasting unformatted text, give it the props at the selection */
        CHAR rgch[ cchCHP + 1 ];

        rgch [0] = sprmCSame;
#ifdef JAPAN //T-HIROYN Win3.1
            {
                struct CHP savechpT;
                typeCP  cpF, cpFirst, cpLim, kcpF, kcpL;
                int     cchF;
                int     kanjiftc, alphaftc;
                CHAR    *rp;
                CHAR    ch;
                int     cch, cblen;

                if(NATIVE_CHARSET != GetCharSetFromChp(&chpT)) {
                    kanjiftc = GetKanjiFtc(&chpT);
                    alphaftc = GetFtcFromPchp(&chpT);
                    savechpT = chpT;
                    cpFirst = cp;

                    do {
                        FetchCp(docCur, cpFirst, 0, fcmChars);
                        cpF = vcpFetch;
                        cchF = vcchFetch;
                        kcpF = cpF;

                        if ((cpF+cchF) < cp + dcp)
                            cpLim = (cpF+cchF);
                        else
                            cpLim = cp + dcp;

                        cch = 0;
                        rp = vpchFetch;

                        while ( kcpF < cpLim ) {
                            ch = *rp;

                            if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                                cblen = GetKanjiStringLen(cch, cchF, rp);
                                chpT.ftc = kanjiftc;
                            } else {
                                cblen = GetAlphaStringLen(cch, cchF, rp);
                                chpT.ftc = alphaftc;
                            }

                            kcpL = kcpF + cblen;
                            cch += cblen;
                            rp  += cblen;

                            bltbyte( &chpT, &rgch [1], cchCHP );
                            AddSprmCps(rgch, docCur, kcpF, kcpL);

                            kcpF = kcpL;
                        }
						cpFirst = kcpF;
                    } while ((cpF + cchF) < cp + dcp );
                    chpT = savechpT;
                } else {
                    bltbyte( &chpT, &rgch [1], cchCHP );
                    AddSprmCps( rgch, docCur, cp, cp + dcp );
                } //END IF ELSE
            } // END JAPAN
#else
        bltbyte( &chpT, &rgch [1], cchCHP );
        AddSprmCps( rgch, docCur, cp, cp + dcp );
#endif
        }
    Select( cpSel, cpSel );
    vchpSel = chpT; /* Preserve insert point props across this operation */
    if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {   /* If running head/foot, remove chSects & set para props */
        MakeRunningCps( docCur, cp, dcp );
        }
    if (ferror)
        NoUndo();
    }

vfSeeSel = true;    /* Tell Idle() to scroll the selection into view */
}


#if defined(OLE)
int NEAR PASCAL CopyScrapToTmp(void)
/*
    If scrap doesn't contain OLE objects, return docScrap.  Else 
    create docTemp and copy docScrap into it.  Make sure objects
    all have their data and have their lpObjInfos NULL'd out.
*/
{
    extern typeCP cpMinCur, cpMacCur, cpMinDocument;
    typeCP  cpMinCurT       = cpMinCur,
            cpMacCurT       = cpMacCur,
            cpMinDocumentT  = cpMinDocument;
    int     docTemp         = docNil,
            docReturn       = docNil;

    /* are there any objects? */
    switch (ObjEnumInDoc(docScrap,NULL))
    {
        case -1: // error
        return docNil;
        case 0:  // no objects in scrap
        return docScrap;
    }

    /* Create copy of document */
    if ((docTemp = DocCreate(fnNil, HszCreate(""), dtyNormal)) == docNil)
        return docNil;

    /* copy scrap to docTemp */
    ClobberDoc(docTemp, docScrap, cp0, CpMacText(docScrap));

    if (ferror)
        goto error;

    /* now save objects to make sure their data is present */
    {
        OBJPICINFO picInfo;
        typeCP cpPicInfo;

        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,docTemp,cp0,CpMacText(docTemp),&cpPicInfo);
            )
        {
            OBJINFO ObjInfoSave;
            typeCP cpRetval;

            if (picInfo.lpObjInfo == NULL)
                continue;

            ObjInfoSave = *picInfo.lpObjInfo;

            cpRetval = ObjSaveObjectToDoc(&picInfo,docTemp,cpPicInfo);

            /*
                Do this just in case saving the object to docTemp changes the
                object's state.  We don't want the object to appear clean
                or saved when in fact it isn't or hasn't been except in docTemp,
                which will be deleted by the calling routine.
            */
            *picInfo.lpObjInfo = ObjInfoSave;

            if (cpRetval == cp0) // save failed
                goto error;

            /* so pasting instance will reload object */
            picInfo.lpObjInfo = NULL;
            ObjSetPicInfo(&picInfo,docTemp,cpPicInfo);
        }
    }

    /* success */
    docReturn = docTemp;

    error:

    if ((docReturn == docNil) && (docTemp != docNil))
        KillDoc(docTemp);

    /* Restore cpMinCur, cpMacCur */
    cpMinCur = cpMinCurT;
    cpMacCur = cpMacCurT;
    cpMinDocument = cpMinDocumentT; /* destroyed possibly by DocCreate */

    return docReturn;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\chlook.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* chlook.c -- modify format from the keyboard or directly from dropdown */
#define NOCLIPBOARD
#define NOCTLMGR
#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES

#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "dispdefs.h"
#include "menudefs.h"

/* E X T E R N A L S */
extern HMENU vhMenu;
extern int vfVisiMode;
extern int vfInsLast;
extern int vfSeeSel;
extern int fGrayChar;
extern struct UAB vuab;
#ifdef ENABLE /* myMenus and mpifntfont not used */
extern MENUHANDLE myMenus[];
extern int mpifntfont[];
#endif
extern int vifntMac;
extern int vifntApplication;

#define keyDownMask     8

CHAR rgbAgain[1 + cchINT]; /* holds last sprm with value for Again key */

/* D O  C H  L O O K */
/* decode ch and apply looks to pchp (or to current sel if pchp == 0) */
DoChLook(ch, pchp)
int ch;
struct CHP *pchp;
{
#ifdef ENABLE /* DoChLook not implemented yet */
        typeCP cpFirst, cpLim;
        int val;
        int sprm;
        int enbSave;

        vfSeeSel = vfInsLast = fTrue;
        if (ch == chAgain)
                {
                AddOneSprm(rgbAgain, fTrue);
                vuab.uac = uacChLook;
                SetUndoMenuStr(IDSTRUndoLook);
                return;
                }

        val = fTrue;
        switch(ChUpper(ch & 0377))
                {
        default:
/*----          Error(IDPMTBadLook);----*/
                beep();
                return;
        case chLookStd & 0377:
                sprm = sprmCPlain;
                val = stcNormal;
                goto LApplyCLook;
        case chLookItalic & 0377:
                sprm = sprmCItalic;
                goto LApplyCLook;
        case chLookBold & 0377:
                sprm = sprmCBold;
                goto LApplyCLook;
        case chLookUline & 0377:
                sprm = sprmCUline;
                goto LApplyCLook;
        case chLookShadow & 0377:
                sprm = sprmCShadow;
                goto LApplyCLook;
        case chLookOutline & 0377:
                sprm = sprmCOutline;
                goto LApplyCLook;
        case chLookSuper & 0377:
                sprm = sprmCPos;
                val = ypSubSuper;
                goto LApplyCLook;
        case chLookSub & 0377:
                sprm = sprmCPos;
                val = -ypSubSuper;
                goto LApplyCLook;
        case chLookSmCaps & 0377:
                sprm = sprmCCsm;
                val = csmSmallCaps;
                goto LApplyCLook;
        case chLookHpsBig & 0377:
                sprm = sprmCChgHps;
                val = 1;
                goto LApplyCLook;
        case chLookHpsSmall & 0377:
                sprm = sprmCChgHps;
                val = -1;
                goto LApplyCLook;
        case chLookFont & 0377:
/* Disable eject disk/ print image key handlers */
#define SCRDMPENB (0x2f8L)
                enbSave = LDBI(SCRDMPENB);
                STBI(0, SCRDMPENB);
                ch = ChInpWait();
                STBI(enbSave, SCRDMPENB);
                if (ch < '0' || ch > '9')
                        {
/*----                  Error(IDPMTBadLook);----*/
                        beep();
                        return;
                        }
                sprm = sprmCChgFtc;
                val = ch - '0';
/* Map from font index to system font code */
                val = val >= vifntMac ? vifntApplication  & 0377: mpifntfont[val];
                goto LApplyCLook;

 /* Paragraph looks */
        case chLookGeneral & 0377:
                sprm = sprmPNormal;
                /*val = 0;*/
                break;
        case chLookLeft & 0377:
                sprm = sprmPJc;
                val = jcLeft;
                break;
        case chLookRight & 0377:
                sprm = sprmPJc;
                val = jcRight;
                break;
        case chLookJust & 0377:
                sprm = sprmPJc;
                val = jcBoth;
                break;
        case chLookCenter & 0377:
                sprm = sprmPJc;
                val = jcCenter;
                break;
        case chLookIndent & 0377:
                val = czaInch/2;
                sprm = sprmPFIndent;
                goto LApplyPLook;
        case chLookDouble & 0377:
                val = czaLine * 2;
                sprm = sprmPDyaLine;
                goto LApplyPLook;
        case chLookOpen & 0377:
                val = czaLine;
                sprm = sprmPDyaBefore;
                goto LApplyPLook;
        case chLookNest & 0377:
                sprm = sprmPNest;
                /*val = 0;*/
                break;
        case chLookUnNest & 0377:
                sprm = sprmPUnNest;
                /*val = 0;*/
                break;
        case chLookHang & 0377:
                sprm = sprmPHang;
                /*val = 0;*/
                break;
                }
/* apply look with 1 char value */
        ApplyLooksParaS(pchp, sprm, val);
        return;
/* apply look with cchInt char value */
LApplyPLook:
        ApplyLooksPara(pchp, sprm, val);
        return;

LApplyCLook:
        ApplyCLooks(pchp, sprm, val);
        return;
#endif /* ENABLE */
}

/* A P P L Y  C  L O O K S */
/* character looks. val is a 1 char value */
ApplyCLooks(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{
/* Assemble sprm */
        CHAR *pch = rgbAgain;
        *pch++ = sprm;
        *pch = val;

        if (pchp == 0)
                {
/* apply looks to current selection */
                AddOneSprm(rgbAgain, fTrue);
                vuab.uac = uacChLook;
                SetUndoMenuStr(IDSTRUndoLook);
                }
        else
/* apply looks to pchp */
                DoSprm(pchp, 0, sprm, pch);
}

/* A P P L Y  L O O K S  P A R A  S */
/* val is a char value */
ApplyLooksParaS(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
        {
        int valT = 0;
        CHAR *pch = (CHAR *)&valT;
        *pch = val;
/* all the above is just to prepare bltbyte later gets the right byte order */
        ApplyLooksPara(pchp, sprm, valT);
        }

/* A P P L Y  L O O K S  P A R A */
/* val is an integer value. Char val's must have been bltbyte'd into val */
ApplyLooksPara(pchp, sprm, val)
struct CHP *pchp;
int sprm, val;
{

#ifdef ENABLE /* related to footnote */
if (FWriteCk(fwcNil)) /* Just check for illegal action in footnote */
#endif
        {
/* set Again stuff since we may have been called from the menu */
        CHAR *pch = rgbAgain;
        *pch++ = sprm;
        bltbyte(&val, pch, cchINT);
        AddOneSprm(rgbAgain, fTrue);
        vuab.uac = uacChLook;
        SetUndoMenuStr(IDSTRUndoLook);
        }
return;
}


#ifdef ENABLE  /* fnChar/fnPara */
/* F N  C H A R  P L A I N */
void fnCharPlain()
{
        ApplyCLooks(0, sprmCPlain, 0);
}

/* F N  C H A R  B O L D */
void fnCharBold()
{
        ApplyCLooks(0, sprmCBold, FMenuUnchecked(imiBold));
}

void fnCharItalic()
{
        ApplyCLooks(0, sprmCItalic, FMenuUnchecked(imiItalic));
}

void fnCharUnderline()
{
        ApplyCLooks(0, sprmCUline, FMenuUnchecked(imiUnderline));
}

void fnCharSuperscript()
{
        ApplyCLooks(0, sprmCPos, FMenuUnchecked(imiSuper) ? ypSubSuper : 0);
}

void fnCharSubscript()
{
        ApplyCLooks(0, sprmCPos, FMenuUnchecked(imiSub) ? -ypSubSuper : 0);
}

void fnParaNormal()
{
extern int vfPictSel;

        ApplyLooksParaS(0, sprmPNormal, 0);
        if (vfPictSel)
                CmdUnscalePic();
}

void fnParaLeft()
{
        ApplyLooksParaS(0, sprmPJc, jcLeft);
}

void fnParaCentered()
{
        ApplyLooksParaS(0, sprmPJc, jcCenter);
}

void fnParaRight()
{
        ApplyLooksParaS(0, sprmPJc, jcRight);
}

void fnParaJustified()
{
        ApplyLooksParaS(0, sprmPJc, jcBoth);
}

void fnParaOneandhalfspace()
{
        ApplyLooksPara(0, sprmPDyaLine, czaLine * 3 / 2);
}

void fnParaDoublespace()
{
        ApplyLooksPara(0, sprmPDyaLine, czaLine * 2);
}

void fnParaSinglespace()
{
        ApplyLooksPara(0, sprmPDyaLine, czaLine);
}

int
FMenuUnchecked(imi)
int     imi;
{ /* Return true if there is NO check mark in front of menu */
int flag;

        if (fGrayChar)
                return true;
        flag = CheckMenuItem(vhMenu, imi, MF_CHECKED);
        CheckMenuItem(vhMenu, imi, flag); /* back to original status */
        return(flag == MF_UNCHECKED ? true : false);

#ifdef SAND
        GetItemMark(myMenus[CHARACTER - 1], imi, &ch);
/***** WRONG COMMENT BELOW! *****/
        return (ch != 18); /* Return true is there is a check mark in front of menu */
#endif /* SAND */
}
#endif


int ChInpWait()
{
#ifdef ENABLE /* CpInpWait not implemented yet */
EVENT event;
int i;
for (i = 0; i < 15000; i++)
        {
        if(GetNextEvent(keyDownMask, &event))
                return (event.message.wl & 0x007f);
        }
return -1; /* Will cause a beep if the user times out */
#endif /* ENABLE */
}

#ifdef CASHMERE /* smcap, overstrike, dbline, open para, visible mode */
fnCharSmallcaps()
{
        ApplyCLooks(0, sprmCCsm, FMenuUnchecked(7) ? csmSmallCaps : csmNormal);
}
fnCharOutline()
{
        ApplyCLooks(0, sprmCOutline, FMenuUnchecked(5));
}

fnCharShadow()
{
        ApplyCLooks(0, sprmCShadow, FMenuUnchecked(6));
}
fnParaOpenspace()
{
        ApplyLooksPara(0, sprmPDyaBefore, czaLine);
}
fnVisiMode()
{
        vfVisiMode = !vfVisiMode;
        TrashAllWws();
}
#endif /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\clipdisp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* clipdisp.c -- Clipboard display routines */
/* This module only gets called in when the clipboard view window is up */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCTLMGR
#include "windows.h"

#include "mw.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "str.h"
#include "propdefs.h"
#include "editdefs.h"
#include "winddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#define SCRIBBLE
#include "debug.h"

extern int              docCur;     /* Document in current ww */
extern int              docScrap;
extern struct WWD       rgwwd [];


int NEAR FGetClipboardDC( void );
int NEAR SetupClipboardDC( void );
int NEAR ReleaseClipboardDC( void );


MdocPaintClipboard( hWnd, hPS )
HWND   hWnd;
HANDLE hPS;
{   /* Paint portion of clipboard window indicated by hPS */
 LPPAINTSTRUCT lpps;

 if (wwClipboard == wwNil)
    return;

 /* Must set the scroll bar range each time we get a PAINT message;
    CLIPBRD.EXE resets it when it gets WM_DRAWCLIPBOARD */

 SetScrollRange( wwdClipboard.wwptr, SB_VERT, 0, drMax-1, FALSE );
 SetScrollRange( wwdClipboard.wwptr, SB_HORZ, 0, xpRightLim, FALSE );

 if ( (lpps = (LPPAINTSTRUCT)GlobalLock( hPS )) != NULL )
    {   /* Paint the clipboard */
    wwdClipboard.hDC = lpps->hdc;
    SetupClipboardDC();
    NewCurWw( wwClipboard, TRUE );
    InvalBand( &wwdClipboard, lpps->rcPaint.top, lpps->rcPaint.bottom - 1 );
    UpdateWw( wwClipboard, FALSE );
    NewCurWw( wwDocument, TRUE );
    GlobalUnlock( hPS );
    }

    /* Since the DC is no longer good, we'll set it to NULL */
  wwdClipboard.hDC = NULL;

#if 0
#if defined(OLE)
    /* gotta delete objects loaded from scrap document */
    ObjEnumInDoc(docScrap,ObjDeleteObjectInDoc);
#endif
#endif
}




MdocSizeClipboard( hWnd, hRC )
HWND    hWnd;
HANDLE  hRC;
{   /* Set clipboard window to be the rect in hRC */
    /* If rectangle is 0 units high or wide, this means we're losing the
        necessity for display until the next size message */
 LPRECT lprc;
 int    dypRect;

 if ( (lprc = (LPRECT)GlobalLock( hRC )) == NULL )
    return;

 if ( (dypRect = lprc->bottom - lprc->top) <= 0 )
    {   /* NULL rect, means lose display until we get a nonnull size */
    if (wwClipboard != wwNil)
        FreeWw( wwClipboard );
    }
 else if ( (wwClipboard != wwNil) ||
           ((wwClipboard=WwAlloc( hWnd, docScrap )) != wwNil))
        {   /* Have WWD entry for clipboard, set its size */

        wwdClipboard.wwptr = hWnd;  /* Just in case clipboard
                                       was closed, then re-opened */
        wwdClipboard.xpMin = lprc->left;
        wwdClipboard.xpMac = lprc->right;
        wwdClipboard.ypMin = lprc->top;
        wwdClipboard.ypMac = lprc->bottom;
#ifdef WIN30        
        SetScrollPos(hWnd, SB_HORZ, 0, TRUE); /* suggested by sankar */
#endif
        }

 GlobalUnlock( hRC );
}




MdocVScrollClipboard( hWnd,  sbMessage, wNewThumb )
HWND    hWnd;
int     sbMessage;
int     wNewThumb;
{
 if ( hWnd != wwdClipboard.wwptr || wwClipboard == wwNil)
    {
    Assert( FALSE );
    return;
    }

 if (!FGetClipboardDC())
        /* Unable to create clipboard device context */
    return;

 NewCurWw( wwClipboard, TRUE );

switch ( sbMessage )
{
case SB_THUMBPOSITION:
    {
    extern typeCP cpMacCur;

    DirtyCache( wwdClipboard.cpFirst = (cpMacCur - wwdClipboard.cpMin) *
                        wNewThumb / (drMax - 1) + wwdClipboard.cpMin);
    wwdClipboard.ichCpFirst = 0;
    wwdClipboard.fCpBad = TRUE;
    TrashWw( wwClipboard );
    break;
    }

case SB_LINEUP:
    ScrollUpCtr( 1 );
    break;
case SB_LINEDOWN:
    ScrollDownCtr( 1 );
    break;
case SB_PAGEUP:
    ScrollUpDypWw();
    break;
case SB_PAGEDOWN:
    ScrollDownCtr( 100 );   /* 100 > tr's in a page */
    break;
}

UpdateWw( wwClipboard, FALSE );

NewCurWw( wwDocument, TRUE );          /* Frees the memory DC */
ReleaseClipboardDC();
}




MdocHScrollClipboard( hWnd,  sbMessage, wNewThumb )
HWND    hWnd;
int     sbMessage;
int     wNewThumb;
{
 if ( hWnd != wwdClipboard.wwptr || wwClipboard == wwNil)
    {
    Assert( FALSE );
    return;
    }

 if (!FGetClipboardDC())
        /* Unable to create clipboard device context */
    return;

 NewCurWw( wwClipboard, TRUE );

 switch (sbMessage)
    {
    case SB_LINEUP:     /* line left */
        ScrollRight(xpMinScroll);
        break;
    case SB_LINEDOWN:   /* line right */
        ScrollLeft(xpMinScroll);
        break;
    case SB_PAGEUP:     /* page left */
        ScrollRight(wwdClipboard.xpMac - xpSelBar);
        break;
    case SB_PAGEDOWN:   /* page right */
        ScrollLeft(wwdClipboard.xpMac - xpSelBar);
        break;
    case SB_THUMBPOSITION:
        /* position to posNew */
        AdjWwHoriz( wNewThumb - wwdClipboard.xpMin );
        break;
    }

UpdateWw( wwClipboard, FALSE );

NewCurWw( wwDocument, TRUE );          /* Frees the memory DC */
ReleaseClipboardDC();
}




MdocAskCBFormatName( lpchName, cchNameMax )
LPCH lpchName;
int cchNameMax;
{   /* Copy the format name for the current contents of the clipboard
       (of which we are the owner) to lpchName, copying no more than
        cchNameMax characters */

extern int vfOwnClipboard;
extern int vfScrapIsPic;
extern CHAR szWRITEText[];
int cchCopy;

Assert( vfOwnClipboard );

/* Don't give a format name for pictures; the name is covered by the
   standard types */

if (!vfScrapIsPic)
    {
    if ( (cchCopy=CchSz( szWRITEText )) > cchNameMax )
        {
        lpchName[ cchCopy = cchNameMax - 1 ] = '\0';
        }

    bltbx( (LPSTR)szWRITEText, (LPSTR)lpchName, cchCopy );
    }

}




int NEAR FGetClipboardDC()
{   /* Get a DC for the clipboard window.  Leave it in rgwwd [wwClipboard].
       Call SetupClipboardDC to set up proper colors */

 if ((wwdClipboard.hDC = GetDC( wwdClipboard.wwptr )) == NULL )
    return FALSE;

 SetupClipboardDC();
 return TRUE;
}

int NEAR SetupClipboardDC()
{  /*  Select in the background brush for appropriate color behavior. */

 extern long rgbBkgrnd;
 extern long rgbText;
 extern HBRUSH hbrBkgrnd;

SelectObject( wwdClipboard.hDC, hbrBkgrnd );
SetBkColor( wwdClipboard.hDC, rgbBkgrnd );
SetTextColor( wwdClipboard.hDC, rgbText );
}



int NEAR ReleaseClipboardDC()
{
ReleaseDC( wwdClipboard.wwptr, wwdClipboard.hDC );
wwdClipboard.hDC = NULL;    /* Mark clipboard DC as invalid */
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\ch.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file defines the characters used by Windows Word. */
/* You must include windows.h to get virtual key definitions */

#define chNil		(-1)

/* Characters in files */

#define chDelPrev	0x08
#define chTab		0x09
#define chEol		0x0A
#define chNewLine	0x0B
#define chSect		0x0C
#define chReturn	0x0D
#define chNRHFile	0x1F	    /* Non-required hyphen */

#ifndef NOKCCODES
/* Keyboard Characters */
/* A high bit of 1 means that this is a command character */
/* For Windows, a command character it one that is processed through */
/* the virtual key mechanism (WM_KEYBOARD) instead of translated (WM_CHAR) */

#define wKcCommandMask		0x8000		/* mask that tells if command */
#define FIsCommandKc(kc)	((int)(kc) < 0) /* or, test it this way */

#define kcDelPrev	(wKcCommandMask | VK_BACK)
#define kcDelNext	(wKcCommandMask | VK_DELETE)
#define kcInsert	(wKcCommandMask | VK_INSERT)
#define kcTab		(wKcCommandMask | VK_TAB )
#define kcReturn	(wKcCommandMask | VK_RETURN)
#define kcLeft		(wKcCommandMask | VK_LEFT)
#define kcUp		(wKcCommandMask | VK_UP)
#define kcRight 	(wKcCommandMask | VK_RIGHT)
#define kcDown		(wKcCommandMask | VK_DOWN)
#define kcPageUp	(wKcCommandMask | VK_PRIOR)
#define kcPageDown	(wKcCommandMask | VK_NEXT)
#define kcBeginLine	(wKcCommandMask | VK_HOME)
#define kcEndLine	(wKcCommandMask | VK_END)
#define kcGoto		(wKcCommandMask | VK_CLEAR)

/* Special for windows: we must handle these key codes & update shift state */

#define kcShift 	(wKcCommandMask | VK_SHIFT)
#define kcControl	(wKcCommandMask | VK_CONTROL)
#define kcAlt		(wKcCommandMask | VK_MENU)
#define kcCapsLock	(wKcCommandMask | VK_CAPITAL)

/* Phony Keyboard Characters, used to force actions */

#define kcNextPara	0xFFFE		/* Generated from GOTO-DOWN */
#define kcPrevPara	0xFFFD		/* Generated from GOTO-UP */
/* #define kcAlphaVirtual  0xFFFC      Defined below, outside ifdef   */

/* Keys that affect the look of the current selection (char or para) */

#define kcLookMin	0x8001		/* As of now, no look keys */
#define kcLookMax	0x8000

/* These control keys are processed as WM_CHAR ASCII codes */

#define kcLFld		(wKcCommandMask | ('[' & 0x1F)) /* Print-Merge <<>> */
#define kcRFld		(wKcCommandMask | (']' & 0x1F)) /* CTRL-[ and CTRL-] */

/* Keyboard Kontrol (CTRL) codes -- a key message word is interpreted
   as a kk instead of a kc, if the CTRL key is down */

#define kkUpScrollLock	(kcUp)
#define kkDownScrollLock (kcDown)
#define kkTopDoc	(wKcCommandMask | VK_HOME)
#define kkEndDoc	(wKcCommandMask | VK_END)
#define kkTopScreen	(wKcCommandMask | VK_PRIOR)
#define kkEndScreen	(wKcCommandMask | VK_NEXT)
#define kkWordLeft	(wKcCommandMask | VK_LEFT)
#define kkWordRight	(wKcCommandMask | VK_RIGHT)
#define kkCopy    	(wKcCommandMask | VK_INSERT)
#define kkDelPrev	(wKcCommandMask | VK_BACK)

#if WINVER < 0x300
#define kkNonReqHyphen	(wKcCommandMask | VK_MINUS)
#else
/* I don't know how the above EVER worked so I'm changing 
   it to use the return value from VkKeyScan().  See routines
   KcAlphaKeyMessage() and FNonAlphaKeyMessage() ..pault */

#define kkNonReqHyphen  (wKcCommandMask | vkMinus)
#endif

#ifdef CASHMERE     /* These keys not supported by MEMO */
#define kkNonBrkSpace	(wKcCommandMask | (unsigned) ' ')
#define kkNLEnter	(wKcCommandMask | VK_RETURN)   /* EOL w/o end Para */
#endif

/* CTRL-shifted keys */

#define kksPageBreak	(wKcCommandMask | VK_RETURN)

#ifdef DEBUG
#define kksEatWinMemory  (wKcCommandMask | 'H') /* Hog Windows Heap */
#define kksFreeWinMemory (wKcCommandMask | 'R') /* Release Windows heap */
#define kksEatMemory	 (wKcCommandMask | 'E') /* Eat WRITE Heap Space */
#define kksFreeMemory	 (wKcCommandMask | 'F') /* Free WRITE Heap Space */
#define kksTest 	 (wKcCommandMask | VK_ESCAPE)
#endif

/* Transformation from kk && kks codes to a unique kc code */

#define KcFromKk(kk)	( (kk) + 0x100 )
#define KcFromKks(kks)	( (kks) + 0x200 )

/* new style ctrl-key accelerators (7.22.91) v-dougk */
#define kkNewCopy   (wKcCommandMask | 'C')
#define kkNewUndo   (wKcCommandMask | 'Z')
#define kkNewPaste  (wKcCommandMask | 'V')
#define kkNewCut    (wKcCommandMask | 'X')

/* Kc codes for CTRL-keys that are processed at the virtual key level */

#define kcNewCopy   KcFromKk( kkNewCopy )
#define kcNewUndo   KcFromKk( kkNewUndo )
#define kcNewPaste  KcFromKk( kkNewPaste )
#define kcNewCut    KcFromKk( kkNewCut )
#define kcTopDoc	KcFromKk( kkTopDoc )
#define kcEndDoc	KcFromKk( kkEndDoc )
#define kcTopScreen	KcFromKk( kkTopScreen )
#define kcEndScreen	KcFromKk( kkEndScreen )
#define kcWordLeft	KcFromKk( kkWordLeft )
#define kcWordRight	KcFromKk( kkWordRight )
#define kcCut		KcFromKk( kkCut )
#define kcPaste 	KcFromKk( kkPaste )
#define kcCopy		KcFromKk( kkCopy )
#define kcClear 	KcFromKk( kkClear )
#define kcUndo		KcFromKk( kkUndo )
#define kcUpScrollLock	KcFromKk( kkUpScrollLock )
#define kcDownScrollLock KcFromKk( kkDownScrollLock )

#ifdef DEBUG	/* kc codes for Debugging control keys */
#define kcEatWinMemory	KcFromKks(kksEatWinMemory)
#define kcFreeWinMemory KcFromKks(kksFreeWinMemory)
#define kcEatMemory	KcFromKks(kksEatMemory)
#define kcFreeMemory	KcFromKks(kksFreeMemory)
#define kcTest		(KcFromKks(kksTest))
#endif /* DEBUG */

/* A special case: kcPageBreak is a CTRL-SHIFT key that is processed in
   AlphaMode */
#define kcPageBreak	KcFromKks( kksPageBreak )

#define kcNonReqHyphen	KcFromKk( kkNonReqHyphen )

#ifdef CASHMERE     /* These keys not supported by MEMO */
#define kcNonBrkSpace	KcFromKk( kkNonBrkSpace )
#define kcNLEnter	KcFromKk( kkNLEnter )
#endif

#endif	/* #ifndef NOKCCODES */

    /* Outside #ifdef because these are return codes from Kc funcs */
    /* Also defined in mmw.c because of compiler stack overflow problems */
#define kcNil		0xFFFF
#define kcAlphaVirtual	0xFFFC	   /* Means "Virtual Key, must translate it" */

/* Display & text-processing characters.  These are real characters in the ANSI
character set as opposed to characters that appear in the file. */

#define chSpace 	' '
#define chHyphen	'-'

#ifndef DBCS
/* we defined them in kanji.h */
#define chStatPage	(CHAR)'\273'
#define chStatRH	'>'
#define chEMark 	(CHAR)'\244'
#endif

#define chSplat 	'.'
#define chSectSplat	':'
#define chDot		'.'
#define chDecimal	'.'
#define chBang		'!'
#define chQMark 	'?'
#define chQuote 	'"'
#define chFldSep	','
#define chLParen	'('
#define chRParen	')'
#define chStar		'*'
#define chLFldFile	(CHAR)'\253'
#define chRFldFile	(CHAR)'\273'
#define chNBH		(CHAR)'\255'	/* Non-breaking hyphen */
#define chNBSFile	(CHAR)'\240'	/* Non-breaking space */


/* The following are "special" characters that are essentially macros for longer
strings. */

#define schPage 	(CHAR)'\001'
#define schFootnote	(CHAR)'\005'
#define schInclude	(CHAR)'\006'

/* Characters in Search patterns */
#define chPrefixMatch	'^'
#define chMatchAny	'?'
#define chMatchWhite	'w'
#define chMatchTab	't'
#define chMatchEol	'p'
#define chMatchNewLine	'n'
#define chMatchSect	'd'
#define chMatchNBSFile	's'
#define chMatchNRHFile	'-'

/* ANSI block character, see FWriteExtTextScrap! ..pault */

#define chBlock 0x7f

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\clipbrd2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Clipbrd2.c -- less frequently used clipboard routines */

#define NOWINMESSAGES
#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOVIRTUALKEYCODES
#define NOMENUS
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOOPENFILE
#define NOSOUND
#define NOCOMM
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOWH
#define NOSCROLL
#define NOPEN
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "winddefs.h"
#include "fmtdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#if defined(JAPAN) & defined(DBCS_IME)
#include "prmdefs.h"        /* IME: use sprmCSame in CmdInsIRString() */
#else
#define NOSTRMERGE
#define NOSTRUNDO
#endif

#include "str.h"

#define NOIDISAVEPRINT
#define NOIDIFORMATS
#include "dlgdefs.h"
#include "wwdefs.h"
#include "debug.h"

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
#include "fontdefs.h"
#include "kanji.h"
extern struct CHP vchpSel;
#endif

extern struct WWD   rgwwd[];
extern int              wwMac;
extern struct DOD       (**hpdocdod)[];
extern int              docCur;     /* Document in current ww */
extern int              docMac;
extern int              ferror;
extern int              docScrap;

#if  defined(JAPAN) & defined(DBCS_IME)     /* Document for IRSTRING */
extern int              docIRString;
#include <ime.h>
extern int              wwCur;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
typeCP selUncpFirst = cp0;
typeCP selUncpLim   = cp0;
HANDLE hImeUnAttrib = NULL;
HANDLE hImeUnString = NULL;
BOOL   ImeClearInsert = FALSE;
struct CHP vchpHidden;
extern int     HiddenTextTop;
extern int     HiddenTextBottom;
// 12/28/92
extern BOOL    whileUndetermine; // if TRUE we are managing IR_UNDETERMINE
#endif

#endif

extern struct PAP       vpapAbs;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern struct PAP       *vppapNormal;
extern struct CHP       vchpNormal;
extern int              vfScrapIsPic;
extern typeCP           vcpLimParaCache;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              vfOwnClipboard;
extern struct FLI       vfli;


#if WINVER >= 0x300
/* We can copy more than 64k in the clipboard and need to
   correctly handle when we cross segment boundaries.  See
   note in bltbh() ..pault */
void bltbh(HPCH, HPCH, int);
#define  bltbx(from,to,count)      bltbh(from,to,count)
#define  LPCHCLIP   HPCH
#else
#define  LPCHCLIP   LPCH
#endif /* if-else-WINVER */


FRenderAll()
{   /* WRITE is going away, and we are the owners of the clipboard.
       Render the contents of the clipboard in as many formats as
       we know.  Prompt the user if the save will use more than 1000
       cp's; this is to avoid massive inadvertant gobbling of global
       heap space. */
 extern int vfOwnClipboard;
 extern HANDLE hMmwModInstance;
 extern HANDLE hParentWw;
 extern FARPROC lpDialogConfirm;
 typeCP cpMac=CpMacText( docScrap );


 if ( (cpMac == cp0) || !vfOwnClipboard)
    {   /* We are not the clipboard owner OR the scrap is empty:
           no actions required */
    return TRUE;
    }
#ifdef ENABLE   /* By popular demand, this dialog box is removed */
 else if (cpMac > 1000L)
    {
    /* Clipboard contents (docScrap) are > 1000 bytes; ask the user to confirm
       that it should be saved away in a global handle */

    switch ( OurDialogBox( hMmwModInstance, MAKEINTRESOURCE( dlgSaveScrap ),
                        hParentWw, lpDialogConfirm ) )
        {
        default:
        case idiCancel:     /* [CANCEL]     Abort exit sequence */
            return FALSE;
        case idiNo:         /* [DISCARD]    Discard large clipboard */
            return TRUE;
        case idiOk:         /* [SAVE]       Save large clipboard */
            break;
        }
    }

    /* Believe it or not, we have to check the vfOwnClipboard flag AGAIN.
       A user as sneaky as gaben might have gone into another app and
       copied to the clipboard while our dialog is up. */

if (!vfOwnClipboard)
    /* We have to check the vfOwnClipboard flag AGAIN.
       A user might have gone into another app and
       copied to the clipboard while our dialog was up. */
    return TRUE;
#endif  /* ENABLE */

    /* Render the clipboard contents */
if (OpenClipboard( wwdCurrentDoc.wwptr ))
    {
    int f;

    f = FWriteExtScrap();
    CloseClipboard();
    if (f)
        return TRUE;
    else
        {   /* Failed to write scrap contents -- report error */

        extern HWND hParentWw;
        CHAR *PchFillPchId( CHAR *, int, int );
        CHAR sz[ 256 ];

        PchFillPchId( sz, IDPMTClipQuest, sizeof(sz) );

        switch ( IdPromptBoxSz( hParentWw, sz,
                                MB_OKCANCEL | MB_ICONHAND | MB_SYSTEMMODAL ) )
            {
            default:
                break;
            case IDOK:
                return TRUE;
            }
        }
    }
return FALSE;
}




FWriteExtScrap()
{   /* Write the scrap document into the external scrap */
    /* This means: Write the clipboard contents to the clipboard */
    /* in the standard Windows CF_TEXT format, or, if a picture, */
    /* in CF_BITMAP or CF_METAFILEPICT, whichever it was originally. */
    /* We get here in response to a WM_RENDERFORMAT or WM_RENDERALLFORMATS */
    /* message.  The clipboard is assumed to be already OPEN, and is left open */
    /* Returns TRUE if all is well, FALSE if an error occurs.  The caller
    /* is responsible for reporting errors. */

int NEAR FWriteExtTextScrap();
typeCP  cpNow;
typeCP  cpMac=(**hpdocdod) [docScrap].cpMac;
unsigned long cbScrap;
struct  PICINFOX picInfo;
HANDLE  hScrapDescriptor=NULL;
HANDLE  hScrap;

if (!vfScrapIsPic)
    {   /* Text */
    return FWriteExtTextScrap();
    }

GetPicInfo( cp0, cpMac, docScrap, &picInfo );

#if defined(OLE)
    if (picInfo.mfp.mm == MM_OLE)
        return ObjWriteToClip(&picInfo);
#endif

    /* Prime the loop */
FetchCp(docScrap, cpNow = (typeCP)picInfo.cbHeader, 0, fcmChars + fcmNoExpand);
if ((hScrap = GlobalAlloc( GMEM_MOVEABLE, cbScrap = (LONG)vccpFetch )) == NULL)
    goto SetFailed;

while (cpNow < cpMac)
    {
    LPCHCLIP lpch;
    HANDLE hScrapT;

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"FWES:cpNow %lu cpMac %lu vccpFetch %d \n\r", cpNow, cpMac, vccpFetch);
    CommSz(rgch);
    }
#endif

    /* Add bytes from scrap document to global handle */

    if ((lpch = GlobalLock( hScrap )) == NULL)
        goto SetFailed;
    bltbx( (LPCHCLIP) vpchFetch, lpch + (cbScrap - vccpFetch), vccpFetch );
    GlobalUnlock( hScrap );

    /* Fetch the next run and expand the handle */

    if ((cpNow += vccpFetch) >= cpMac)
        break;
    FetchCp( docScrap, cpNow, 0, fcmChars + fcmNoExpand );
    /* the above fetchcp should probably be converted to use the speed-
       hack in fetchcp which passes docnil cpnil to get the next series
       of chars ..pault */

    hScrapT = hScrap;
    hScrap = GlobalReAlloc( hScrap, cbScrap += vccpFetch, GMEM_MOVEABLE );
    if (hScrap == NULL)
        {   /* Could not grow the handle; bail out */
        hScrap = hScrapT;   /* So it gets freed */
        goto SetFailed;
        }
    }

/* Now we have the whole of docScrap in a windows Global handle */
/* See whether we have a bitmap or a metafile picture */

switch(picInfo.mfp.mm)
{
    case MM_BITMAP:
    {   /* Bitmap */
        LPCHCLIP lpch;

        if ( ((lpch=GlobalLock( hScrap ))==NULL) ||
            (picInfo.bm.bmBits=lpch,
                ((hScrapDescriptor=
                    CreateBitmapIndirect((LPBITMAP)&picInfo.bm))==NULL)))
            {
            if (lpch != NULL)
                GlobalUnlock( hScrap );
            goto SetFailed;
            }
        else
            {
                /* Tell the clipboard about the "goal size" for this guy */
            SetBitmapDimension( hScrapDescriptor, picInfo.mfp.xExt,
                                                picInfo.mfp.yExt );
            SetClipboardData( CF_BITMAP, hScrapDescriptor );
            }

        GlobalUnlock( hScrap );
        GlobalFree( hScrap );   /* Bitmap was copied by CreateBitmapIndirect,
                                don't need it anymore */
        hScrap = NULL;
    }
    break;

    default:
    {   /* Metafile Picture */
        LPCHCLIP lpch;
        Diag(CommSzNum("FWES: sizeof(metafilepict) ==",sizeof(METAFILEPICT)));

        if ( ((hScrapDescriptor=GlobalAlloc(GMEM_MOVEABLE,
                                            (long)sizeof(METAFILEPICT) ))==NULL) ||
            ((lpch=GlobalLock( hScrapDescriptor ))==NULL))
            {
            goto SetFailed;
            }
        else
            {
            picInfo.mfp.hMF = hScrap;
            bltbx( (LPCHCLIP) &picInfo.mfp, lpch, sizeof(METAFILEPICT) );
            GlobalUnlock( hScrapDescriptor );
            SetClipboardData( CF_METAFILEPICT, hScrapDescriptor );
            }
    }
    break;
}

return true;

SetFailed:
    if (hScrapDescriptor != NULL)
        GlobalFree( hScrapDescriptor );
    if (hScrap != NULL)
        GlobalFree( hScrap );
    return false;   /* Caller should report errors */
}




int NEAR FWriteExtTextScrap()
{   /* Create ASCII text in a global Windows handle corresponding
       to the contents of docScrap.  Add CR-LF combinations at the
       points at which text would wrap on the display.
       Set the handle into the clipboard if successful, as type CF_TEXT.
       Returns the handle built up, or NULL if we ran out of memory */

long lcchHandle = 0L;
HANDLE h=GlobalAlloc( GMEM_MOVEABLE, (long) 1 );
LPCHCLIP lpch;
typeCP cpNow=cp0;
typeCP cpMac=(**hpdocdod) [docScrap].cpMac;
HANDLE hT;
#if WINVER < 0x300
int cLine = 0;
#endif

Assert( !vfScrapIsPic );
Assert( vfOwnClipboard );

if (h==NULL)
    goto Failed;

while (cpNow < cpMac)
    {
    int ich;
    int dcpLine;

    /* Check for picture para */

    /** Is this syntax intentional???!!! (1.28.91) D. Kent **/
    if (CachePara( docScrap, cpNow ), vpapAbs.fGraphics )
        {
        cpNow = vcpLimParaCache;
        continue;
        }

    /* Format a line of text for the screen */

    FormatLine( docScrap, cpNow, 0, cpMac, flmSandMode );
    dcpLine = vfli.ichReal;

    /* Special: Check for NULLs */
    /* This is a last-minute workaround for a WRITE */
    /* bug in which FormatLine sometimes returns a NULL in vfli.rgch */

    for ( ich = 0; ich < vfli.ichReal; ich++ )
        {
        if (vfli.rgch [ich] == '\0')
            {
#ifdef DCLIP
            CommSzNum("Oddity in FormatLine: returned a zero in rgch at ich==",ich);
#endif

#if WINVER < 0x300
            dcpLine = ich;
            break;
#else
            /* Rather than assign the string a zero length if there is
               just one block character in the selection, we make it the
               ansi block char!  This fixes WINBUG #8150..pault 1/16/90 */
            vfli.rgch [ich] = chBlock;
#endif
            }
        }

    /* Put the chars + a CRLF into the handle */

#define cbNeeded (lcchHandle + dcpLine + 2)

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"FWETS:cbNeeded %lu (lcchHandle %lu, dcpLine %d) \n\r",
            cbNeeded, lcchHandle, dcpLine);
    CommSz(rgch);
    }
#endif

    hT = h;
    if ((h=GlobalReAlloc( h, (LONG) cbNeeded, GMEM_MOVEABLE ))==NULL)
        {   /* Could not expand handle */
        h = hT;  /* So it gets freed */
        goto Failed;
        }

    if ((lpch=GlobalLock( h )) == NULL)
        goto Failed;

    if (vfli.cpMac > cpMac)
            /* Do not cut the endmark character (but alloc for it to allow
               space for zero-terminating the clipboard string) */
#ifdef DBCS
/* We use double byte charactor for END Mark,So we have to go back 2 byte */
#if defined(JAPAN) || defined(KOREA)   //T-HIROYN 1992.07.28
/* In Win31J We use single byte charactor for END Mark */
    dcpLine--;
#else
    dcpLine -= 2;
#endif
#else
        dcpLine--;
#endif

    bltbx( (LPCHCLIP) vfli.rgch, lpch + lcchHandle, dcpLine );

    lpch [lcchHandle += dcpLine] = 0x0D;
    lpch [++lcchHandle] = 0x0A;
#if WINVER < 0x300
    cLine++;
#endif

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"      cpNow %lu cpMac %lu lcchHandle %lu dcpLine %d \n\r",
             cpNow, cpMac, lcchHandle+1, dcpLine);
    CommSz(rgch);
    }
#endif

    ++lcchHandle;
    cpNow = vfli.cpMac;
    GlobalUnlock( h );
    }

 /* SUCCEEDED!  NULL-terminate the string before returning the handle */
#if WINVER >= 0x300
 /* This means we must alloc one more byte at the end ..pault 1/11/90 */

#ifdef DCLIP
    {
    char rgch[200];
    wsprintf(rgch,"FWETS:cbNeeded to fit in sz %lu \n\r", lcchHandle+1);
    CommSz(rgch);
    }
#endif
 hT = h;
 if ((h=GlobalReAlloc( h, (LONG) lcchHandle+1, GMEM_MOVEABLE ))==NULL)
     {   /* Could not expand handle */
     h = hT;  /* So it gets freed */
     goto Failed;
     }
#endif

 if ((lpch = GlobalLock( h )) == NULL)
    goto Failed;

#if WINVER >= 0x300
/* It turns out that we're not really representing the contents of the 
   selection correctly.  The user should really ONLY end up at the start
   of a new line (that is, the last thing "pasted in" was a CRLF sequence)
   if they were really at the end of a line!  (Especially a problem when
   pasting 3 lines of text into the CALENDAR Scratchpad)  12/3/89..pault */

 if (cpMac < vfli.cpMac)
#else
 if (cLine == 1)   /* Special case: < 1 line, do not terminate w/ CRLF */
#endif
    /* Back up over crlf already written */
    lcchHandle = max(0, lcchHandle-2);

 lpch [lcchHandle] = '\0';
 GlobalUnlock( h );
 SetClipboardData( CF_TEXT, h );
 return TRUE;

Failed:

 if (h != NULL)
    GlobalFree( h );
 return FALSE;
}



int FReadExtScrap()
{       /* Transfer the external scrap to the scrap document.  This means:
           read the contents of the clipboard into docScrap, using whatever
           available standard format we can process. Return FALSE=ERR, TRUE=OK */

    extern int vfSysFull;
    extern BOOL fError;
    extern HWND vhWnd;
    extern int vfOwnClipboard;
    int    fOk = FALSE;
    struct PICINFOX picInfo;

    Assert( !vfOwnClipboard );

    vfScrapIsPic = false;
    ClobberDoc( docScrap, docNil, cp0, cp0 );

    if ( !OpenClipboard( vhWnd ) )
        return FALSE;

    /* Get the handle for the highest-priority type available in the clipboard */

    /* if !(PasteLink or (PasteSpecial and not CF_TEXT)) */
    if (!(vbObjLinkOnly || vObjPasteLinkSpecial ||
        (cfObjPasteSpecial && (cfObjPasteSpecial != CF_TEXT))))  // no text handler yet
    /* try to use text format */
    {
        WORD wFormat=0;
        typeCP  cp=cp0;
        unsigned long cb;
        struct PAP *ppap = NULL;
        CHAR    rgch[256];
        HANDLE  hClipboard; /* Handle that was being kept in the clipboard */
        LPCHCLIP lpch;

        while (wFormat = EnumClipboardFormats(wFormat))
        /* enumerate to see whether text precedes native.  If so, take it */
        {
            if (wFormat == CF_TEXT) // take it
            {
                if ((hClipboard = GetClipboardData( wFormat )) == NULL)
                    goto done;

                cb = GlobalSize( hClipboard );
                lpch = MAKELP(hClipboard,0);

                while (cb > 0)
                {   /* Copy bytes from lpch to docScrap's cp stream */
                    #define ulmin(a,b)  (((a) < (b)) ? a : b)

                    unsigned cch=ulmin(cb,255);    /* <= 255 bytes per pass */
                    int fEol;
#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
                    unsigned ccht;

                    if ((cch = CchReadLineExtDBCS((LPCHCLIP) lpch, cch, rgch,
                                 &fEol, &ccht))==0) /* Reached terminator */
                    {
                        fOk = TRUE;
                        goto done;
                    }

                    if (fEol)
                        ppap = vppapNormal;
#ifdef KKBUGFIX     //  added by Hiraisi (pasted several lines. BUG#2791)
                    else
                        ppap = NULL;
#endif

                    InsertRgch( docScrap, cp, rgch, ccht, &vchpNormal, ppap );
                    if (fError)      /* an error was reported mid-copy */
                        goto done;

                    cb -= cch;
                    cp += (typeCP) ccht;
                    lpch += cch;
#else
                    if ((cch = CchReadLineExt((LPCHCLIP) lpch, cch, rgch,
                                 &fEol))==0) /* Reached terminator */
                    {
                        fOk = TRUE;
                        goto done;
                    }

                    if (fEol)
                        ppap = vppapNormal;
#ifdef KKBUGFIX     //  added by Hiraisi (pasted several lines. in Japan)
                    else
                        ppap = NULL;
#endif

                    InsertRgch( docScrap, cp, rgch, cch, &vchpNormal, ppap );
                    if (fError)      /* an error was reported mid-copy */
                        goto done;

                    cb -= cch;
                    cp += (typeCP) cch;
                    lpch += cch;
#endif
                }
                Assert(0); // shouldn't get here
            }
            else if ((cfObjPasteSpecial != CF_TEXT) &&
                      (wFormat == vcfNative)) // make an object
                /* NOTE: if pastespecial and the format == CF_TEXT, then
                   we look for the text format regardless of presence of
                   native */
                break;
        }
    }

    /*  Fell through to here, so didn't find or don't want text,
        see whether can make an object (static included) */

    if (!ObjCreateObjectInClip(&picInfo))
        goto done;

    vfScrapIsPic = true;

    /* save new picinfo to doc */
    CachePara(docScrap,cp0);
    if (ObjSaveObjectToDoc(&picInfo,docScrap,cp0) == cp0)
    {
        OleDelete(lpOBJ_QUERY_OBJECT(&picInfo));
        goto done;
    }

    /* this'll force paste to reuse rather than clone */
    if (ObjToCloneInDoc(&picInfo,docScrap,cp0) == cp0)
    {
        OleDelete(lpOBJ_QUERY_OBJECT(&picInfo));
        goto done;
    }

    fOk = TRUE;

    done:

    CloseClipboard();
    if (vfSysFull || (!fOk && (picInfo.mfp.mm == MM_OLE)))
        {   /* Filled the scratch file trying to bring in the object */
        ClobberDoc(docScrap, docNil, cp0, cp0);
        fOk = FALSE;
        }

    return fOk;
}

#if defined(JAPAN) & defined(DBCS_IME)
// We know that this special routine is particularly useful for Japanese IME

//CmdInsIRString(int doc)   T-HIROYN 3.1J
CmdInsIRString()
{
    extern struct CHP vchpSel;
    typeCP cp, dcp;
    struct CHP chpT;
    extern struct SEL       selCur;     /* Current Selection */
    extern int              vfSeeSel;

    if (!FWriteOk(fwcInsert))
        return;

    if ((dcp = CpMacText(docIRString))  == cp0)
        return;

    NoUndo();   /* So the Undo doesn't get combined	with previous ops */

    /* Stomp the current selection, if any */
    if (selCur.cpLim > selCur.cpFirst)
        DeleteSel();

    chpT = vchpSel;
    cp = selCur.cpFirst;

    CachePara( docIRString, cp0 );

    SetUndo( uacInsert, docCur, cp, dcp, docNil, cpNil, cp0, 0 );

    SetUndoMenuStr(IDSTRUndoEdit);
    ReplaceCps(docCur, cp , cp0, docIRString, cp0, dcp);

    if (ferror) /* Not enough memory to do replace operation */
        NoUndo();  /* should not be able to undo what never took place */
    else
    {
        CHAR rgch[ cchCHP + 1 ];

        typeCP cpSel=CpFirstSty( cp + dcp, styChar );

        rgch [0] = sprmCSame;
        bltbyte( &chpT, &rgch [1], cchCHP );
        AddSprmCps( rgch, docCur, cp, cp + dcp );

        Select( cpSel, cpSel );
        vchpSel = chpT; /* Preserve insert point props across this operation */
        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {   /* If running head/foot, remove chSects & set para props */
            MakeRunningCps( docCur, cp, dcp );
        }
        if (ferror)
            NoUndo();
    }

    vfSeeSel = true;    /* Tell Idle() to scroll the selection into view */
}


PutImeString( hWnd,  hIME )
HWND hWnd;
HANDLE hIME;
{
    LPCHCLIP lpch;
    CHAR rgch[256];
    unsigned long cb;
    typeCP cp = cp0;
    extern BOOL fError;
    extern int vfSysFull;
    int fUnFormattedText =  FALSE;
    extern void ForceImeBlock();

    //T-HIROUN 3.1J    ForceImeBlock(hWnd, TRUE);
    //StartLongOp();
    ClearInsertLine();

    vfScrapIsPic = false;
    ClobberDoc( docIRString, docNil, cp0, cp0 );
    cb = GlobalSize( hIME );

    if (lpch = GlobalLock( hIME )) {

        //T-HIROYN  Win3.1
        //change CHARSET to KANJI_CHARSET
        {
            int ftc;
            if( ftcNil != (ftc = GetKanjiFtc(&vchpSel))) {
                ApplyCLooks(&vchpSel, sprmCFtc, ftc);
            }
        }

        while(cb > 0) {
            unsigned cch = ulmin(cb, 255);
            int fEol;
            struct PAP *ppap = NULL;

            if ((cch = CchReadLineExt((LPCHCLIP)lpch,cch,rgch,&fEol)) == 0)
                break;
            if (fEol)
                ppap = vppapNormal;

            InsertRgch(docIRString, cp, rgch, cch, &vchpNormal, ppap );
            if (fError) {
                break;
            }
            cb -= cch;
            cp += (typeCP) cch;
            lpch += cch;
        }
        GlobalUnlock( hIME );
    }
    if (vfSysFull) {
        ClobberDoc( docIRString, docNil, cp0, cp0 );
    }
    fUnFormattedText = !vfScrapIsPic;
    // T-HIROYN 3.1J CmdInsIRString(docIRString);
    //EndLongOp();
    // T-HIROYN 3.1J ForceImeBlock(hWnd, FALSE);
}
#endif // JAPAN & DBCS_IME

CchReadLineExt( lpch, cbRead, rgch, pfEol)
LPCHCLIP lpch;
int     cbRead;
CHAR    rgch[];
int     *pfEol;
{ /* Read from lpch to the next eol or null terminator, whichever comes first */
/* Return number of bytes read (max is 255) and whether there is a eol at end */
/* The count does not include the null terminator, but does include the eol */

CHAR    *pch;
extern  CHAR *index();

Assert(cbRead <= 255);
bltbx( lpch, (LPCHCLIP) rgch, cbRead );
rgch[ cbRead ] = 0;       /* Null terminate the string (so index will work) */

if (*pfEol = ((pch=index(rgch,chEol)) != NULL))
    {   /* FOUND EOL */
    return (pch - rgch + 1);
    }
else
    {   /* NO EOL */
    return CchSz(rgch) - 1;
    }
}

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
CchReadLineExtDBCS( lpch, cbRead, rgch, pfEol, ccht)
LPCHCLIP lpch;
int     cbRead;
CHAR    rgch[];
int     *pfEol;
int     *ccht;
{
/*Read from lpch to the next eol or null terminator, whichever comes first */
/*Return number of bytes read (max is 255) and whether there is a eol at end */
/*The count does not include the null terminator, but does include the eol */

CHAR    *pch;
int     i, j, ret;

    Assert(cbRead <= 255);

#ifdef KKBUGFIX     //  added by Hiraisi (BUG#2791)
    *pfEol = FALSE;
#endif
    i = j = 0;
    while( j < cbRead) {
        if( IsDBCSLeadByte(*lpch) ) {
            if(j + 2 > cbRead)
                break;
            if( FKanji2(*(lpch+1)) ) {
                rgch[j++] = *lpch++;
                rgch[j++] = *lpch++;
                i += 2;
            } else {
                lpch++;
                i++;
            }
        } else {
            /* FOUND Null */
            if(*lpch == 0)
                break;
            rgch[j++] = *lpch;
            i++;
            /* FOUND EOL */
            if(*lpch == chEol)
#ifdef KKBUGFIX     //  added by Hiraisi (BUG#2791)
            {
                *pfEol = TRUE;
                break;
            }
#else
                break;
#endif
            lpch++;
        }
    }

    rgch[j] = 0;    /* Null terminate the string (so index will work) */
                    /* j == set bytes for rgch */
                    /* i == read bytes from lpch */
    *ccht = j;

    if(j == 0)
        i = 0;
    return(i);
}
#endif



FComputePictSize( pmfp, pdxa, pdya )
register METAFILEPICT *pmfp;
int *pdxa;
int *pdya;
{   /* Compute an initial size, in twips, for the picture described by the
       passed metafile picture structure. Return the size through
       parameters.  Return FALSE if the metafile picture structure
       contained bad information, TRUE otherwise */

#ifdef SCALE_FOR_SCREEN
#define hDCBasis    wwdCurrentDoc.hDC
#define dxaConvert  czaInch
#define dxpConvert  dxpLogInch
#define dyaConvert  czaInch
#define dypConvert  dypLogInch
#else   /* Scale for printer */
 extern int dxaPrPage, dxpPrPage, dyaPrPage, dypPrPage;
 extern HDC vhDCPrinter;
#define hDCBasis    vhDCPrinter
#define dxaConvert  dxaPrPage
#define dxpConvert  dxpPrPage
#define dyaConvert  dyaPrPage
#define dypConvert  dypPrPage
#endif

 int mm = pmfp->mm;
 int dxp, dyp;
 int xres;
 int yres;
 int xsiz;
 int ysiz;

#if defined(OLE)
 if (mm == MM_OLE)
    return ObjQueryObjectBounds((struct PICINFOX FAR *)pmfp, vhDCPrinter, pdxa, pdya);
 else
#endif

{
 xres = GetDeviceCaps( hDCBasis, HORZRES );
 yres = GetDeviceCaps( hDCBasis, VERTRES );
 xsiz = GetDeviceCaps( hDCBasis, HORZSIZE );
 ysiz = GetDeviceCaps( hDCBasis, VERTSIZE );

 switch (mm) {
    case MM_ISOTROPIC:
    case MM_ANISOTROPIC:
        if (! ((pmfp->xExt > 0) && (pmfp->yExt > 0)))
            {   /* No "Suggested Size" given */
                /* Use 3" vertically, 3" or as dictated by */
                /* aspect ratio horizontally */
            dyp = PxlConvert( MM_LOENGLISH, 300, yres, ysiz );
            dxp = ((pmfp->xExt == 0) && (pmfp->yExt == 0)) ?
                       /* No aspect ratio info given -- use 3" horizontal */
                       PxlConvert( MM_LOENGLISH, 300, xres, xsiz ) :
                       /* Info has neg #'s; use to compute aspect ratio */
                      ((long)((long)dyp * (long)(iabs(pmfp->xExt)))) /
                      (long) (iabs(pmfp->yExt));
            break;
            }
         else
             mm = MM_HIMETRIC;
        /* FALL THROUGH TO COMPUTE "SUGGESTED SIZE" */
    default:
        dxp = PxlConvert( mm, pmfp->xExt, xres, xsiz );
        dyp = PxlConvert( mm, pmfp->yExt, yres, ysiz );
        break;
    }
}

if ((dxp == 0) || (dyp == 0))
    /* bogus info or unknown map mode */
    return FALSE;

*pdxa = MultDiv( dxp, dxaConvert, dxpConvert );
*pdya = MultDiv( dyp, dyaConvert, dypConvert );
return TRUE;
}


HbmMonoFromHbmColor( hbmSrc )
HBITMAP hbmSrc;
{   /* Return a monochrome copy of the passed bitmap. Return NULL
       if an error occurred.  Assumes that the passed bitmap can be
       selected into a memory DC which is compatible with the doc DC. */

extern long rgbBkgrnd;
extern long rgbText;
extern HWND vhWnd;

BITMAP bm;
HBITMAP hbmMono=NULL;
HDC hMDCSrc = NULL;
HDC hMDCDst = NULL;

/* Create memory DC for source, set colors, select in passed bitmap */

 if ((hMDCSrc = CreateCompatibleDC( wwdCurrentDoc.hDC )) == NULL)
    goto Error;

#ifdef BOGUS
 /* We can't assume that every window out there has the same window colors that
 we have.  In fact, we have no way to figure out how to convert this color
 bitmap; so white will map to white and everything else will map to black. */
 SetBkColor( hMDCSrc, rgbBkgrnd );
 SetTextColor( hMDCSrc, rgbText );
#endif /* BOGUS */

 if (SelectObject( hMDCSrc, hbmSrc ) == NULL)
    goto Error;

 /* Create memory DC for destination, select in a new monochrome bitmap */

 if ( ((hMDCDst = CreateCompatibleDC( wwdCurrentDoc.hDC )) == NULL) ||
      ((GetObject( hbmSrc, sizeof (BITMAP), (LPSTR) &bm ) == 0)) ||
      ((hbmMono = CreateBitmap( bm.bmWidth, bm.bmHeight,
                                1, 1, (LPSTR) NULL )) == NULL) ||
      (SelectObject( hMDCDst, hbmMono ) == NULL) )
    {
    goto Error;
    }

#ifdef DCLIP
 {
 char rgch[200];
 wsprintf(rgch,"HMFH: (dst) bmWidthB %lu * bmHeight %lu bmPlanes %lu\n\r",
         (unsigned long) bm.bmWidthBytes, (unsigned long) bm.bmHeight,
         (unsigned long) bm.bmPlanes );
 CommSz(rgch);
 }
#endif

 /* Now blt the bitmap contents.  The screen driver in the source will
    "do the right thing" in copying color to black-and-white. */

 if (!BitBlt( hMDCDst, 0, 0, bm.bmWidth, bm.bmHeight, hMDCSrc, 0, 0, SRCCOPY ))
    goto Error;

 DeleteDC( hMDCSrc );
 DeleteDC( hMDCDst );
 return hbmMono;

Error:

    if (hMDCSrc != NULL)            /* ORDER IS IMPORTANT: DC's before */
        DeleteDC( hMDCSrc );    /* objects selected into them */
    if (hMDCDst != NULL)
        DeleteDC( hMDCDst );
    if (hbmMono != NULL)
        DeleteObject( hbmMono );
    return NULL;
}


#if WINVER >= 0x300
    /* Since copying more than 64k to the clipboard is now a real
       possibility under protect mode, we really need a good assembler
       bltbh().  We don't copy more than 64k at a time but we do 
       need to properly handle crossing segment boundaries.  For now
       the clipboard is the only place we need this so this C routine
       will suffice for now ..pault */

void bltbh(HPCH hpchFrom, HPCH hpchTo, int cch)
    {
    HPCH hpchFromLim;

    for (hpchFromLim  = hpchFrom + cch;
            hpchFrom < hpchFromLim;
                *(hpchTo++) = *(hpchFrom++))
        ;
    }
#endif

#if defined(JAPAN) & defined(DBCS_IME)
LONG GetIRString(HWND, LPARAM);
LONG GetIRStringEx(HWND, LPARAM);

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J

LONG GetIRUndetermin(HWND, LPARAM);

//IR_UNDETERMINE
LONG GetIRUndetermin(hWnd, lParam)
HANDLE    hWnd;
LONG      lParam;
{
    LPUNDETERMINESTRUCT lpUn;
    HANDLE      hImeUn;
    LPSTR       lpImeattrbuf, lpImechbuf, lpImeDchbuf;
    LPSTR       lpAttrib, lpText;
    UINT        uC, uCurPos, uLen, cb, clen, uDLen;
    UINT	uDelta = 0; //12/28/92 add
    HANDLE      hMem;
    typeCP      cpSel = 0L;
    typeCP      dcp = 0L;
    BOOL        bUpdate = FALSE;
    WORD        lRet = (LONG)FALSE;

    extern int              vfSeeSel;

    ImeClearInsert = FALSE;

    if(NULL == (hImeUn = LOWORD(lParam))) {
        //Cut prev IME string
        if(selUncpLim > selUncpFirst) {
            dcp = selUncpLim - selUncpFirst;
            Replace(docCur, selUncpFirst, dcp, fnNil, fc0, fc0);
            selCur.cpFirst = selCur.cpLim = selUncpLim = selUncpFirst;

            HiddenTextTop = 0;              //IME rectangle top
            HiddenTextBottom = 0;           //IME rectangle bottom
        }
        return lRet;
    }

    // Undetermine string attribute area alloc. when it free is Write close:
    if (hImeUnAttrib == NULL) {
        if ((hImeUnAttrib = GlobalAlloc(GMEM_MOVEABLE, 512L)) == NULL)
            return lRet; // something wrong
    }

#if 0 //12/28/92 cut
    // Undetermine string area alloc. when it free is Write close:
    if (hImeUnString == NULL) {
        if ((hImeUnString = GlobalAlloc(GMEM_MOVEABLE, 512L)) == NULL)
            return lRet; // something wrong
    }
#endif

    whileUndetermine = TRUE;

    if(selUncpLim == selUncpFirst)
        SetImeFont(hWnd);

    if (lpUn = (LPUNDETERMINESTRUCT)GlobalLock(hImeUn)) {
        uCurPos = lpUn->uCursorPos;
        uC = uCurPos;
		uDelta = lpUn->uDeltaStart; //12/28/92
        lpImechbuf = (LPSTR)lpUn;
        lpImechbuf += lpUn->uUndetTextPos;
        lpImeattrbuf = (LPSTR)lpUn;
        lpImeattrbuf += lpUn->uUndetAttrPos;
        lpImeDchbuf = (LPSTR)lpUn;
        lpImeDchbuf += lpUn->uDetermineTextPos;

        //Undetermine string length
        if( lpUn->uUndetTextPos != 0 && lpUn->uUndetTextLen != 0 )
            uLen = lpUn->uUndetTextLen;
        else
            uLen = 0;

        //Determine string length
        if( lpUn->uDetermineTextPos != 0 &&
            lpUn->uDetermineTextLen != 0)
            uDLen = lpUn->uDetermineTextLen;
        else
            uDLen = 0;

        //Insert Determin string
        if( uDLen != 0 ) {
            if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uDLen+1))) {
                if (lpText = GlobalLock(hMem)) {
#if 1
			        struct DOD *pdod;

	                pdod = &(**hpdocdod)[docCur];
                    pdod->fDirty = true;	//because we don't use undo()
#endif
                    //copy string from IME UNDETERMIN struct
                    lstrcpy(lpText, lpImeDchbuf);

                    //chp Set
                    vchpSel = vchpHidden;

                    // string set to docIRString
                    PutImeString( hWnd, hMem);

                    // inset point set
                    selCur.cpFirst = selUncpFirst;

                    // copy from docIRString to docCur
                    CmdInsIRStringUndetermin((typeCP)uDLen);

                    bUpdate = TRUE;

                    GlobalUnlock(hMem);

                    lRet = (LONG)TRUE;

                    selUncpFirst += (typeCP)uDLen;
                    selUncpLim   += (typeCP)uDLen;

                    HiddenTextTop = 0;           //IME rectangle top

                }
                GlobalFree(hMem);
            }
        }

        // cursor position
        if(uC == -1)
           uC = uLen;

        // IME IR_UNDETERMIN Mode start or No change
        if(selUncpFirst == selUncpLim && uLen == 0) {
            GlobalUnlock(hImeUn);
            whileUndetermine = FALSE; //12/28/92
            return lRet;
        }

        /* prev SELECT doc ? */
        if (selCur.cpLim > selCur.cpFirst)
            DeleteSel();

        //First Undetermine string
        if(selUncpFirst == selUncpLim && uLen != 0) {
            selUncpFirst = selCur.cpFirst;
            selUncpLim = selUncpFirst;
            vchpHidden = vchpSel;
        }

        clen = 0;

        //Cut prev IME string
        if(selUncpLim > selUncpFirst) {
            dcp = selUncpLim - selUncpFirst;
#if 0 //12/28/92 rep
            //Compare prev Undetermin string and New Undetermin string
            if ( lpText = GlobalLock(hImeUnString) ) {
                if( lpAttrib = GlobalLock(hImeUnAttrib) ){

                    for(clen = 0; ((typeCP)clen < dcp && clen < uLen); clen++) {
                        if( *(lpText+clen) != *(lpImechbuf+clen)) {
                            break;
                        }
                        if( *(lpAttrib+clen) != *(lpImeattrbuf+clen)) {
                            break;
                        }
                        if(IsDBCSLeadByte(*(lpText+clen))) {
                            if( *(lpText+clen+1) != *(lpImechbuf+clen+1)) {
                                break;
                            }
                            clen++;
                        }
                    }

                    GlobalUnlock(hImeUnAttrib);
                }

                GlobalUnlock(hImeUnString);
            }
#else
			if(-1 == uDelta)
				clen = uLen;
			else
				clen = uDelta;
#endif
            if((typeCP)clen < dcp) {
                Replace(docCur, selUncpFirst+(typeCP)clen, dcp-(typeCP)clen,
                         fnNil, fc0, fc0);
                bUpdate = TRUE;
            }
        }

        selUncpLim = selUncpFirst + (typeCP)uLen;

        //Insert New Undetermin string
        if(uLen != 0 && clen < uLen) {
            if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uLen+1))) {
                if (lpText = GlobalLock(hMem)) {

                    //copy string from IME UNDETERMIN struct
                    lstrcpy(lpText, lpImechbuf + clen);

                    //chp Set;
                    vchpSel = vchpHidden;

                    // string set to docIRString
                    PutImeString( hWnd, hMem);

                    // inset point set
                    selCur.cpFirst = selUncpFirst+(typeCP)clen;

                    // copy from docIRString to docCur
                    CmdInsIRStringUndetermin((typeCP)uC);

                    bUpdate = TRUE;

                    GlobalUnlock(hMem);

                    HiddenTextBottom = 0;           //IME rectangle bottom
                }
                GlobalFree(hMem);
            }
        } else {
            //ALL Cut only
            if(uLen == 0) {
                selCur.cpFirst = selCur.cpLim = selUncpLim = selUncpFirst;
                HiddenTextTop = 0;              //IME rectangle top
                HiddenTextBottom = 0;           //IME rectangle bottom
            }
        }

        // save new info
        //save new Undetermin string;
#if 0  //12/28/92 cut
        if (lpText = GlobalLock(hImeUnString)) {
            bltbcx(lpText, 0, 512);
            if(uLen < 512)
                lstrcpy(lpText,lpImechbuf);
            GlobalUnlock(hImeUnString);
        }
#endif
        //save new Undetermin string Attrib
        //12/28/92 add
        if(uLen > 512) {
            hImeUnAttrib = GlobalReAlloc(hImeUnAttrib, (DWORD)uLen, 0);
        }

        if(lpAttrib = GlobalLock(hImeUnAttrib)) {
// 12/28/92 bltbcx(lpAttrib, 0, 512);
            for(cb = 0;cb < uLen;cb++) {
                lpAttrib[cb] = lpImeattrbuf[cb];
            }
            GlobalUnlock(hImeUnAttrib);
        }

        //Insert Point set:
        cpSel=CpFirstSty( selUncpFirst + (typeCP)uC, styChar );
        Select( cpSel, cpSel );

        //InsertPoint(caret) don`t disp ?
        if( -1 == uCurPos && selUncpLim > selUncpFirst )
            ImeClearInsert = TRUE;

		vfSeeSel = true; /* Tell Idle() to scroll the selection into view */

        GlobalUnlock(hImeUn);
    }

    //text display
    if(bUpdate) {
        UpdateWw(wwCur, FALSE);
// 12/28/92        DoHiddenRectSend();
    }

    whileUndetermine = FALSE;
    return lRet;
}

CmdInsIRStringUndetermin(typeCP cpCc)
{
    extern struct CHP vchpSel;
    typeCP cp, dcp;
    struct CHP chpT;
    extern struct SEL       selCur;     /* Current Selection */
    extern int              vfSeeSel;

    if (!FWriteOk(fwcInsert))
        return;

    if ((dcp = CpMacText(docIRString))  == cp0)
        return;

//NNN    NoUndo();   /* So the Undo doesn't get combined with previous ops */

    /* Stomp the current selection, if any */
//NNN    if (selCur.cpLim > selCur.cpFirst)
//NNN        DeleteSel();

    chpT = vchpSel;
    cp = selCur.cpFirst;

    CachePara( docIRString, cp0 );

//NNN    SetUndo( uacInsert, docCur, cp, dcp, docNil, cpNil, cp0, 0 );

//NNN    SetUndoMenuStr(IDSTRUndoEdit);
    ReplaceCps(docCur, cp , cp0, docIRString, cp0, dcp);

    if (ferror) /* Not enough memory to do replace operation */
        NoUndo();  /* should not be able to undo what never took place */
    else
    {
        CHAR rgch[ cchCHP + 1 ];

//NNN        typeCP cpSel=CpFirstSty( cp + dcp, styChar );
//      typeCP cpSel=CpFirstSty( cp + uC, styChar );
        typeCP cpSel=CpFirstSty( selUncpFirst + cpCc, styChar );

        rgch [0] = sprmCSame;
        bltbyte( &chpT, &rgch [1], cchCHP );
        AddSprmCps( rgch, docCur, cp, cp + dcp );

        Select( cpSel, cpSel );

        vchpSel = chpT; /* Preserve insert point props across this operation */
        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
        {   /* If running head/foot, remove chSects & set para props */
            MakeRunningCps( docCur, cp, dcp );
        }
        if (ferror)
            NoUndo();
    }

    vfSeeSel = true;    /* Tell Idle() to scroll the selection into view */
}

UndetermineToDetermine(HWND hWnd)
{
    selUncpFirst   = selUncpLim;
    selCur.cpFirst = selUncpLim;
    selCur.cpLim   = selUncpLim;
    ImeClearInsert = FALSE;
    NoUndo();
    InvalidateRect(hWnd, (LPRECT)NULL, FALSE);
    SendIMEVKFLUSHKey(hWnd);
    HiddenTextTop = 0;              //IME rectangle top
    HiddenTextBottom = 0;           //IME rectangle bottom
}

#endif  //End IME_HIDDEN

SendIMEVKFLUSHKey(HWND hWnd)
{
    LPIMESTRUCT lpmem;
    HANDLE      hIMEBlock;
	WORD	wRet;

    /* Get comunication area with IME */
    hIMEBlock=GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
                        (DWORD)sizeof(IMESTRUCT));
    if(!hIMEBlock)  return;

    lpmem           = (LPIMESTRUCT)GlobalLock(hIMEBlock);
    lpmem->fnc      = IME_SENDVKEY;
    lpmem->wParam   = VK_DBE_FLUSHSTRING;
    lpmem->wCount   = 0;

    GlobalUnlock(hIMEBlock);
    wRet = MySendIMEMessageEx(hWnd,MAKELONG(hIMEBlock,NULL));

    GlobalFree(hIMEBlock);
	return wRet;
}

//New3.1 IR_STRING
LONG GetIRString(hWnd, lParam)
HANDLE    hWnd;
LONG      lParam;
{
    HANDLE hMem, hIme;
    LPSTR lpText, lpIme;
    UINT uLen;
    LONG lRet = 0L;

    hIme = LOWORD(lParam);

    if(lpIme = GlobalLock(hIme)) {
        uLen = lstrlen(lpIme);
        if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uLen+1) )) {
            if (lpText = GlobalLock(hMem)) {

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                //Cut Undetermine string
                if(selUncpLim > selUncpFirst) {
                    typeCP Undcp;
                    Undcp = selUncpLim - selUncpFirst;
                    Replace(docCur, selUncpFirst, Undcp, fnNil, fc0, fc0);
                    selCur.cpFirst = selUncpLim = selUncpFirst;
                }
#endif
                //ime string copy
                lstrcpy(lpText, lpIme);

                ForceImeBlock(hWnd, TRUE);
                PutImeString( hWnd, hMem );
                CmdInsIRString();
                ForceImeBlock(hWnd, FALSE);
                GlobalUnlock(hMem);
                lRet = 1L;
            }
            GlobalFree(hMem);
        }
        GlobalUnlock(hIme);
    }
    return lRet;
}

//New3.1 IR_STRINGEX

LONG GetIRStringEX(hWnd, lParam)
HANDLE    hWnd;
LONG      lParam;
{
    LPSTRINGEXSTRUCT lpString;
    HANDLE      hIme, hMem;
    LPSTR       lpImechbuf, lpText;
    UINT        uLen;
    LONG        lRet = (LONG)FALSE;

    if(NULL == (hIme = LOWORD(lParam))) {
        return lRet;
    }

    if (lpString = (LPSTRINGEXSTRUCT)GlobalLock(hIme)) {
        lpImechbuf = (LPSTR)lpString;
        lpImechbuf += lpString->uDeterminePos;

        //Undetermine string length
        if( lpString->uDeterminePos != 0)
            uLen = lstrlen(lpImechbuf);

        //Insert Determin string
        if( uLen != 0 ) {
            if (hMem = GlobalAlloc(GMEM_MOVEABLE, (LONG)(uLen+1))) {
                if (lpText = GlobalLock(hMem)) {

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                    //Cut Undetermine string
                    if(selUncpLim > selUncpFirst) {
                        typeCP Undcp;
                        Undcp = selUncpLim - selUncpFirst;
                        Replace(docCur, selUncpFirst, Undcp, fnNil, fc0, fc0);
                        selCur.cpFirst = selUncpLim = selUncpFirst;
                    }
#endif
                    //copy string from IME UNDETERMIN struct
                    lstrcpy(lpText, lpImechbuf);

                    ForceImeBlock(hWnd, TRUE);
                    PutImeString( hWnd, hMem );
                    CmdInsIRString();
                    ForceImeBlock(hWnd, FALSE);
                    GlobalUnlock(hMem);
                    lRet = (LONG)TRUE;
                }
                GlobalFree(hMem);
            }
        }
        GlobalUnlock(hIme);
    }
    return lRet;
}
#endif // JAPAN & DBCS_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\cmd.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* cmd.c -- key handling for WRITE */

#define NOCTLMGR
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOHDC
#define NOBRUSH
#define NOPEN
#define NOFONT
#define NOWNDCLASS
#define NOCOMM
#define NOSOUND
#define NORESOURCE
#define NOOPENFILE
#define NOWH
#define NOCOLOR
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "code.h"
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "debug.h"
#include "fmtdefs.h"
#include "winddefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "menudefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef  KOREA
#include <ime.h>
extern  BOOL fInterim; // MSCH bklee 12/22/94
#endif

int                     vfAltKey;
extern int              vfPictSel;
extern int              vfCommandKey;
extern int              vfShiftKey;
extern int              vfGotoKeyMode;
extern int              vfInsertOn;
extern struct WWD       rgwwd[];
extern struct SEL       selCur;         /* Current selection (i.e., sel in current ww) */
extern int vkMinus;

#ifdef JAPAN            //T-HIROYN Win3.1
int                     KeyAltNum = FALSE;
#endif

int fnCutEdit();
int fnCopyEdit();
int fnPasteEdit();
int fnUndoEdit();


FCheckToggleKeyMessage( pmsg )
register MSG *pmsg;
{   /* If the passed message is an up- or down- transition of a
       keyboard toggle key (e.g. shift), update our global flags & return
       TRUE; if not, return FALSE */

 switch ( pmsg->message ) {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        switch( pmsg->wParam ) {
            case VK_SHIFT:
            case VK_CONTROL:
            case VK_MENU:
                SetShiftFlags();
                return TRUE;

#if 0
            #ifdef DEBUG
            default:
            {
                char msg[100];
                wsprintf(msg,"%s\t0x%x\n\r",(LPSTR)((pmsg->message == WM_KEYDOWN) ?
                            "keydown" : "keyup"), pmsg->wParam);
                OutputDebugString(msg);
            }
            #endif
#endif
        }
#ifdef JAPAN //T-HIROYN
        if(vfAltKey){
            if(pmsg->wParam >= VK_NUMPAD0 && pmsg->wParam <= VK_NUMPAD9 ) {
                KeyAltNum = TRUE;
            }
        } else {
            KeyAltNum = FALSE;
        }
#endif
 }
return FALSE;
}




SetShiftFlags()
{
extern int vfShiftKey;     /* Whether shift is down */
extern int vfCommandKey;   /* Whether ctrl key is down */

MSG msg;

PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

vfShiftKey = GetKeyState( VK_SHIFT ) < 0;
vfCommandKey  = GetKeyState( VK_CONTROL ) < 0;
vfAltKey  = GetKeyState( VK_MENU ) < 0;
#if 0
#ifdef DEBUG
{
    char msg[100];
    wsprintf(msg,"%s\t%s\t%s\n\r",
            (LPSTR)(vfShiftKey ? "Shift":"OFF"),
            (LPSTR)(vfCommandKey  ? "Control":"OFF"),
            (LPSTR)(vfAltKey ? "Alt":"OFF"));
    OutputDebugString(msg);
}
#endif
#endif
}




KcAlphaKeyMessage( pmsg )
register MSG *pmsg;
{       /* If the passed message is a key-down transition for a key
           that is processed by the Alpha Mode loop, return a kc
           code for it.  If not, return kcNil.
           If the key is a virtual key that must be translated,
           return kcAlphaVirtual */
 int kc;


 if (pmsg->hwnd != wwdCurrentDoc.wwptr)
    return kcNil;

 kc = pmsg->wParam;
 switch (pmsg->message) {
 default:
    break;
 case WM_KEYDOWN:
#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  KcAlphaKeyMessage(WM_KEYDOWN)  kc=pmsg->wParam==%X\n\r",kc);
    CommSz(rgch);
    }
#endif

    if (vfAltKey)
        return kcAlphaVirtual;

    if (vfCommandKey)
        {   /* Alpha mode control keys */
        if (vfShiftKey && kc == (kkNonReqHyphen & ~wKcCommandMask))
            return kcNonReqHyphen;
        else if (kc == (kksPageBreak & ~wKcCommandMask))
            return KcFromKks( kksPageBreak );
        }

    else
        {   /* There are two classes of Alpha Mode virtual keys:
                (1) Keys that can successfully be filtered out
                    and processed at the virtual key level
                (2) Keys that must be translated first

               We assume here that there is NOT a third class of key
               that will cause synchronous messages to be sent to our
               window proc when TranslateMessage is called.  */

        switch (kc) {
            default:
                return kcAlphaVirtual;

            case VK_F1:     /* THIS IS A COPY OF THE ACCELERATOR TABLE, */
                            /* AND MUST BE UPDATED IN SYNC WITH THE TABLE */
            case VK_F2:
            case VK_F3:
            case VK_F4:
            case VK_F5:
            case VK_F6:
            case VK_F7:
            case VK_F8:
                return kcNil;

            case kcDelNext & ~wKcCommandMask:
                /* If selection, return kcNil, else return kcDelNext */
                return (selCur.cpFirst < selCur.cpLim) ? kcNil : kcDelNext;

            case kcDelPrev & ~wKcCommandMask:
                /* New standard for Win 3.0... Backspace key deletes
                   the selection if there is one (implemented by faking
                   a Delete keypress) ..pault 6/20/89 */
                if (selCur.cpFirst < selCur.cpLim)
                    {
                    pmsg->wParam = (kcDelNext & ~wKcCommandMask);
                    return(kcNil);
                    }
                /* else process as before... */

            case kcTab & ~wKcCommandMask:
            case kcReturn & ~wKcCommandMask:
                return kc | wKcCommandMask;
            }
        }
    break;

#ifdef KOREA    /* interim support by sangl 90.12.23 */
 case WM_INTERIM:
#endif
 case WM_CHAR:
#ifdef KOREA
      if(pmsg->message == WM_INTERIM) // MSCH bklee 12/22/94
           fInterim = TRUE;
      else fInterim = FALSE;
#endif

#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  KcAlphaKeyMessage(WM_CHAR)  returning kc==%X\n\r",kc);
    CommSz(rgch);
    }
#endif
#ifdef PRINTMERGE
    if (kc < ' ')
            /* CTRL-key. The print merge brackets are treated as commands,
               since they require special handling in AlphaMode().
               All others are directly inserted. */
        switch ( kc ) {
            case kcLFld & ~wKcCommandMask:
            case kcRFld & ~wKcCommandMask:
                kc |= wKcCommandMask;
                break;
            }
#endif

#ifdef JAPAN
    // inhibit form inputing Alt + Numkey T-HIROYN WIN3.1
    if(KeyAltNum) {
        _beep();
        KeyAltNum = FALSE;
        return kcNil;
    }
#endif
    return kc;
 }  /* end switch (msg.message) */

#ifdef DINPUT
    CommSz("  KcAlphaKeyMessage(not WM_CHAR or WM_KEYDOWN)  returning kc==kcNil");
#endif
 return kcNil;
}
#ifdef  KOREA
CHAR chDelete;
typeCP cpConversion;
extern int docCur;
extern CHAR *vpchFetch;
extern int IsInterim;
extern typeCP       cpMacCur;
#endif




FNonAlphaKeyMessage( pmsg, fAct )
register MSG *pmsg;
int fAct;           /* Whether to act on the passed key */
{
extern HMENU vhMenu;
extern HWND hParentWw;
int kc;
int message;


 if (pmsg->hwnd != wwdCurrentDoc.wwptr)
    return FALSE;

 message = pmsg->message;
 kc = pmsg->wParam | wKcCommandMask;

 /* Check for Alt-Bksp */
 if ((message == WM_SYSKEYDOWN) && (kc == (VK_BACK | wKcCommandMask)))
     /* Alt-Backspace = UNDO */
     {
     if (fAct)
        PhonyMenuAccelerator( EDIT, imiUndo, fnUndoEdit );
     return TRUE;
     }

 /* Only look at key down messages */

 if (message != WM_KEYDOWN)
    return FALSE;

#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  FNonAlphaKeyMessage(keydown)  kc==%X\n\r",kc);
    CommSz(rgch);
    }
#endif

 /* Translate CTRL keys by mapping valid kk & kks codes to valid kc codes */

 if ( vfCommandKey )
    {
    if (vfShiftKey)
        switch ( kc ) {     /* Handle CTRL-SHIFT keys */
        default:
            goto CtrlKey;
#if 0
#ifdef DEBUG
        case kksTest:
        case kksEatWinMemory:
        case kksFreeWinMemory:
        case kksEatMemory:
        case kksFreeMemory:
            kc = KcFromKks( kc );
            break;
#endif
#endif
        }
    else        /* Handle CTRL keys */
        {
CtrlKey:
        switch ( kc ) {
        case kkUpScrollLock:
        case kkDownScrollLock:
        case kkTopDoc:
        case kkEndDoc:
        case kkTopScreen:
        case kkEndScreen:
        case kkCopy:
#ifdef CASHMERE   /* These keys not supported by MEMO */
        case kkNonReqHyphen:
        case kkNonBrkSpace:
        case kkNLEnter:
#endif
        case kkWordLeft:
        case kkWordRight:
            kc = KcFromKk( kc );    /* Translate control code */
#ifdef DINPUT
    { char rgch[100];
    wsprintf(rgch,"  FNonAlphaKeyMessage, translated kc %X\n\r",kc);
    CommSz(rgch);
    }
#endif
            break;

        default:
#ifdef DINPUT
    CommSz("  FNonAlphaKeyMessage returning false, nonsupported kc\n\r");
#endif
            return FALSE;
        }
        }
    }   /* end of if (vfCommandKey) */


    /* Act on valid kc codes */

#ifdef DINPUT
    CommSz("  FNonAlphaKeyMessage processing valid kc codes\n\r");
#endif
    switch ( kc ) {
     /* ---- CURSOR KEYS ---- */
     case kcEndLine:
     case kcBeginLine:
     case kcLeft:
     case kcRight:
     case kcWordRight:
     case kcWordLeft:
        if (fAct)
            {
            ClearInsertLine();
            MoveLeftRight( kc );
            }
        break;

     case kcUp:
     case kcDown:
     case kcUpScrollLock:
     case kcDownScrollLock:
     case kcPageUp:
     case kcPageDown:
     case kcTopDoc:
     case kcEndDoc:
     case kcEndScreen:
     case kcTopScreen:
        if (fAct)
            {
            ClearInsertLine();
            MoveUpDown( kc );
            }
        break;

    case kcGoto:       /* Modifies next cursor key */
        if (!fAct)
            break;
        vfGotoKeyMode = true;
        goto NoClearGoto;

    /* Phony Menu Accelerator Keys */

    case kcNewUndo:
     {
     if (fAct)
        PhonyMenuAccelerator( EDIT, imiUndo, fnUndoEdit );
     return TRUE;
     }

    case kcCopy:
    case kcNewCopy:
        if (fAct)
            PhonyMenuAccelerator( EDIT, imiCopy, fnCopyEdit );
        break;

    case kcNewPaste:
    case VK_INSERT | wKcCommandMask:
        if (fAct && (vfShiftKey || (kc == kcNewPaste)))
        {
#if defined(OLE)
            vbObjLinkOnly = FALSE;
#endif
            PhonyMenuAccelerator( EDIT, imiPaste, fnPasteEdit );
        }
        break;

    case kcNewCut:
    case VK_DELETE | wKcCommandMask:
        if (vfShiftKey || (kc == kcNewCut))
            {   /* SHIFT-DELETE = Cut */
            if (fAct)
                PhonyMenuAccelerator( EDIT, imiCut, fnCutEdit );
            }
        else
            {   /* DELETE = Clear */
            if (fAct)
                fnClearEdit(FALSE);
            }
        break;

    case VK_ESCAPE | wKcCommandMask:
        /* The ESC key does: if editing a running head or foot, return to doc
                             else beep */
        if (!fAct)
            break;

        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
            {   /* Return to document from editing header/footer */
            extern HWND vhDlgRunning;

            SendMessage( vhDlgRunning, WM_CLOSE, 0, (LONG) 0 );
            return TRUE;
            }
        else
            _beep();
        break;

#ifdef  KOREA
    case VK_HANJA | wKcCommandMask:

        if(IsInterim)   break;

        if (selCur.cpFirst == cpMacCur) {
                _beep();
                break;
        }
        cpConversion = selCur.cpFirst;
        Select( cpConversion, cpConversion+1 );   // 2/9/93
        FetchCp( docCur, cpConversion, 0, fcmChars );
        chDelete = *vpchFetch;
        { HANDLE  hKs;
          LPIMESTRUCT  lpKs;
          LPSTR lp;

          hKs = GlobalAlloc (GMEM_MOVEABLE|GMEM_DDESHARE,(LONG)sizeof(IMESTRUCT));
          lpKs = (LPIMESTRUCT)GlobalLock(hKs);
          lpKs->fnc = IME_HANJAMODE;
          lpKs->wParam = IME_REQUEST_CONVERT;
          lpKs->dchSource = (WORD)( &(lpKs->lParam1) );
          lp = lpSource( lpKs );
          *lp++ = *vpchFetch++;
          *lp++ = *vpchFetch;
          *lp++ = '\0';
          GlobalUnlock(hKs);
          if(SendIMEMessage (hParentWw, MAKELONG(hKs,0)))
              selCur.cpLim = selCur.cpFirst + 2;
          else
              Select( cpConversion, cpConversion );   // 2/9/93

          GlobalFree(hKs);
        }
        break;
#endif       /* KOREA */

#if 0
#ifdef DEBUG
    case kcEatWinMemory:
        if (!fAct)
            break;
        CmdEatWinMemory();
        break;
    case kcFreeWinMemory:
        if (!fAct)
            break;
        CmdFreeWinMemory();
        break;
    case kcEatMemory:
        {
        if (!fAct)
            break;
        CmdEatMemory();
        break;
        }
    case kcFreeMemory:
        if (!fAct)
            break;
        CmdFreeMemory();
        break;
    case kcTest:
        if (!fAct)
            break;
        fnTest();
        break;
#endif
#endif
    default:
        return FALSE;
     }   /*  end of switch (kc) */

    vfGotoKeyMode = false;
NoClearGoto:
    return TRUE;
}





#ifdef DEBUG
ScribbleHex( dch, wHex, cDigits )
int dch;            /* Screen position at which to show Last digit (see fnScribble) */
unsigned wHex;      /* hex # to show*/
int cDigits;        /* # of digits to show */
{
  extern fnScribble( int dchPos, CHAR ch );

  for ( ; cDigits--; wHex >>= 4 )
    {
    int i=wHex & 0x0F;

    fnScribble( dch++, (i >= 0x0A) ? i + ('A' - 0x0A) : i + '0' );
    }
}
#endif  /* DEBUG */






#ifdef DEBUG
#ifdef OURHEAP
CHAR (**vhrgbDebug)[] = 0;
int     vrgbSize = 0;
#else
#define iHandleMax  100
HANDLE rgHandle[ iHandleMax ];
int iHandleMac;
unsigned cwEaten = 0;
#endif

CmdEatMemory()
{ /* For debugging purposes, eat up memory */
#ifdef OURHEAP       /* Restore this with a LocalCompact when are
                       operational under the Windows heap */
int **HAllocate();
int cwEat = cwHeapFree > 208 ? cwHeapFree - 208 : 20;

if (vrgbSize == 0)
        vhrgbDebug = (CHAR (**)[])HAllocate(cwEat);
else
        FChngSizeH(vhrgbDebug, cwEat + vrgbSize, true);
vrgbSize += cwEat;
CmdShowMemory();
#endif  /* OURHEAP */
}

CmdFreeMemory()
{ /* Free up the memory we stole */
#ifdef OURHEAP
if (vhrgbDebug != 0)
        FreeH(vhrgbDebug);
vhrgbDebug = (CHAR (**)[]) 0;
vrgbSize = 0;
CmdShowMemory();
#endif
}

extern CHAR     szMode[];
extern int      docMode;
extern int      vfSizeMode;

#ifdef OURHEAP
CmdShowMemory()
#else
CmdShowMemory(cw)
int cw;
#endif
{

extern CHAR szFree[];

CHAR *pch = szMode;

#ifdef OURHEAP
/* cch = */ ncvtu( cwHeapFree, &pch );
#else
ncvtu(cw, &pch);
#endif

blt( szFree, pch, CchSz( szFree ));
vfSizeMode = true;
/* docMode = -1; */
DrawMode();
}




CmdEatWinMemory()
{
#ifndef OURHEAP
unsigned cwEat;
int cPage;
int fThrowPage = TRUE;

extern int cPageMinReq;
extern int ibpMax;

while (true)
    {
    while ((cwEat = ((unsigned)LocalCompact((WORD)0) / sizeof(int))) > 0 &&
          iHandleMac < iHandleMax)
        {
        if ((rgHandle [iHandleMac] = (HANDLE)HAllocate(cwEat)) == hOverflow)
            goto AllocFail;
        else
            {
            ++iHandleMac;
            cwEaten += cwEat;
            CmdShowMemory(cwEaten);
            }

        if (iHandleMac >= iHandleMax)
            goto AllocFail;

        if ((rgHandle [iHandleMac] = (HANDLE)HAllocate(10)) == hOverflow)
            goto AllocFail;
        else
            {
            ++iHandleMac;
            cwEaten += 10;
            CmdShowMemory(cwEaten);
            }
        }

    if (iHandleMac >= iHandleMax)
        goto AllocFail;

    cPage = cPageUnused();
    Assert(cPage + 2 < ibpMax);
    if (fThrowPage)
        {
        /* figure out how many bytes we need to invoke the situation
        where we need to throw some pages out to get the space */
        cwEat = ((cPage+2) * 128) / sizeof(int);
        cPageMinReq = ibpMax - cPage - 2;
        }
    else
        {
        cwEat = ((cPage-2) * 128) / sizeof(int);
        cPageMinReq = ibpMax - cPage;
        }

    if ((rgHandle[ iHandleMac++ ] = (HANDLE)HAllocate(cwEat)) == hOverflow)
        {
        iHandleMac--;
        break;
        }
    cwEaten += cwEat;
    CmdShowMemory(cwEaten);
    }

AllocFail:  /* Allocation failed, or we ran out of slots */
    CmdShowMemory( cwEaten );
#endif
}




CmdFreeWinMemory()
{
#ifndef OURHEAP
unsigned cwFree = 0;

Assert(iHandleMac <= iHandleMax);

while (iHandleMac > 0)
    {
    HANDLE h = rgHandle[ iHandleMac - 1];

    if ( (h != NULL) && (h != hOverflow))
        {
        cwFree += (unsigned)LocalSize(h) / sizeof(int);
        FreeH( h );
        }
    iHandleMac--;
    }

cwEaten = 0;
CmdShowMemory(cwFree);
#endif
}
#endif  /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\cmacros2.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg FILE_TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\code.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* code.h */
typedef struct {
		int *fNew; 
		int bpc, cwFrame;
} ENV;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\createww.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* CreateWw.c -- WRITE window & document creation */




#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
//#define NOATOM
#define NOBITMAP
#define NOPEN
#define NODRAWTEXT
#define NOCOLOR
#define NOCREATESTRUCT
#define NOHDC
#define NOMB
#define NOMETAFILE
#define NOMSG
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOWH
#define NOWINOFFSETS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#include <windows.h>

#include "mw.h"
#include "dispdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "fontdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "code.h"
#include "prmdefs.h"
#if defined(OLE)
#include "obj.h"
#endif
#define PAGEONLY
#include "printdef.h"   /* printdefs.h */
/*
#include "dlgdefs.h"
*/

#ifdef  KOREA
#include    <ime.h>
#endif

#ifndef JAPAN                 //  added  10 Jun. 1992  by Hiraisi
/*
 *    These defines are not referrenced, and "dlgdefs.h" is included
 *  at the bottom of this file using JAPAN flag.          by Hiraisi
*/

    /* These defines replace dlgdefs.h to combat compiler heap overflows */
#define idiYes               IDOK
#define idiNo                3
#define idiCancel            IDCANCEL
#endif    //JAPAN

    /* These defines replace heapdefs.h and heapdata.h for the same
       irritating reason */
#define cwSaveAlloc         (128)
#define cwHeapMinPerWindow  (50)
#define cwHeapSpaceMin      (60)

/* E X T E R N A L S */

extern CHAR             (**vhrgbSave)[];
extern HANDLE           hParentWw;
extern HANDLE           hMmwModInstance;
extern struct WWD rgwwd[];
extern int wwMac;
extern struct FCB (**hpfnfcb)[];
extern struct DOD (**hpdocdod)[];
extern int docMac;
extern struct WWD *pwwdCur;
extern int fnMac;
extern CHAR stBuf[];

/* *** Following declarations used by ValidateHeaderFooter */
    /* Min, Max cp's for header, footer */
extern typeCP cpMinHeader;
extern typeCP cpMacHeader;
extern typeCP cpMinFooter;
extern typeCP cpMacFooter;
extern typeCP cpMinDocument;
extern typeCP vcpLimParaCache;
extern struct PAP vpapAbs;
    /* Current allowable cp range for display/edit/scroll */
extern typeCP cpMinCur;
extern typeCP cpMacCur;
    /* cpFirst and selection are saved in these during header/footer edit */
extern typeCP           cpFirstDocSave;
extern struct SEL       selDocSave;


short WCompSzC();
CHAR (**HszCreate())[];
struct FNTB **HfntbCreate();
#ifdef CASHMERE
struct SETB **HsetbCreate();
#else
struct SEP **HsepCreate();
#endif
struct PGTB **HpgtbCreate();


CHAR *PchFromFc( int, typeFC, CHAR * );
CHAR *PchGetPn( int, typePN, int *, int );
typeFC FcMacFromUnformattedFn( int );
int CchReadAtPage( int, typePN, CHAR *, int, int );


/* W W  N E W */
/* allocates and initializes a new wwd structure at wwMac.
ypMin, ypMax are estimates of the height of window used to allocate dl's.
wwMac++ is returned.
Errors: message is made and wwNil is returned.
remains to be initialized: xp, yp. Many fields must be reset if lower pane.
*/
WwNew(doc, ypMin, ypMax)
int doc, ypMin, ypMax;
{
    extern CHAR szDocClass[];
    struct EDL (**hdndl)[];
    register struct WWD *pwwd = &rgwwd[wwMac];
    int dlMax = (ypMax - ypMin) / dypAveInit;
    int cwDndl = dlMax * cwEDL;

#ifdef CASHMERE     /* WwNew is only called once in MEMO */
    if (wwMac >= wwMax)
        {
        Error(IDPMT2ManyWws);
        return wwNil;
        }
#endif

    bltc(pwwd, 0, cwWWDclr);

    if (!FChngSizeH( vhrgbSave,
                     cwSaveAlloc + wwMac * cwHeapMinPerWindow, false ) ||
        FNoHeap( pwwd->hdndl = (struct EDL (**)[]) HAllocate( cwDndl )) )
        {   /* Could not alloc addtl save space or dl array */
        return wwNil;
        }
    else
        bltc( *pwwd->hdndl, 0, cwDndl );

#ifdef SPLITTERS
    pwwd->ww = wwNil;
#endif /* SPLITTERS */

    /* contents of hdndl are init to 0 when allocated */
    pwwd->dlMac = pwwd->dlMax = dlMax;
    pwwd->ypMin = ypMin;
    pwwd->doc = doc;
    pwwd->wwptr = CreateWindow(
                    (LPSTR)szDocClass,
                    (LPSTR)"",
                    (WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE),
                    0, 0, 0, 0,
                    (HWND)hParentWw,
                    (HMENU)NULL,                /* use class menu */
                    (HANDLE)hMmwModInstance,    /* handle to window instance */
                    (LPSTR)NULL);               /* no params to pass on */
    if (pwwd->wwptr == NULL)
        return wwNil;

/* inefficient
    pwwd->cpFirst = cp0;
    pwwd->ichCpFirst = 0;
    pwwd->dcpDepend = 0;
    pwwd->fCpBad = false;
    pwwd->xpMin = 0;
    pwwd->xpMac = 0;
    pwwd->ypMac = 0;
    pwwd->fFtn = false;
    pwwd->fSplit= false;
    pwwd->fLower = false;
    pwwd->cpMin = cp0;
    pwwd->drElevator = 0;
    pwwd->fRuler = false;
    pwwd->sel.CpFirst = cp0;
    pwwd->sel.CpFirst = cp0;
*/

    pwwd->sel.fForward = true;
    pwwd->fDirty = true;
    pwwd->fActive = true;
    pwwd->cpMac = CpMacText(doc);
/* this is to compensate for the "min" in InvalBand */
    pwwd->ypFirstInval = ypMaxAll;

#ifdef JAPAN /*May 26,92 t-Yosho*/
{
    HDC hdc;
    hdc = GetDC(pwwd->wwptr);
    SelectObject(hdc,GetStocKObject(ANSI_VAR_FONT));
    ReleaseDC(pwwd->wwptr,hdc);
}
#endif

#ifdef  KOREA       /* for level 3, 90.12.12 by Sangl */
  { HANDLE  hKs;
    LPIMESTRUCT  lpKs;

    hKs = GlobalAlloc (GMEM_MOVEABLE|GMEM_DDESHARE,(LONG)sizeof(IMESTRUCT));
    lpKs = (LPIMESTRUCT)GlobalLock(hKs);
    lpKs->fnc = IME_SETLEVEL;
    lpKs->wParam = 3;
    GlobalUnlock(hKs);
    SendIMEMessage (pwwd->wwptr, MAKELONG(hKs,0));
    GlobalFree(hKs);
  }
#endif
    return wwMac++;
} /* end of  W w N e w  */




ChangeWwDoc( szDoc )
CHAR szDoc[];
{   /* Set up wwd fields for a new document to be held in wwdCurrentDoc.
       docCur is used as the document */
 extern HANDLE hParentWw;
 extern int docCur;
 extern struct SEL selCur;
 extern typeCP cpMinDocument;
 extern int vfInsEnd;
 extern int vfPrPages;
 extern int    vfDidSearch;
 extern typeCP cpWall;

 register struct WWD *pwwd = &rgwwd[wwDocument];

 pwwd->fDirty = true;

 ValidateHeaderFooter( docCur );

 pwwd->doc = docCur;
 pwwd->drElevator = 0;
 pwwd->ichCpFirst = 0;
 pwwd->dcpDepend = 0;
 pwwd->cpMin = pwwd->cpFirst = selCur.cpLim = selCur.cpFirst = cpMinDocument;
 selCur.fForward = TRUE;
 selCur.fEndOfLine = vfInsEnd = FALSE;
 pwwd->cpMac = CpMacText(docCur);
 TrashWw( wwDocument );

 SetScrollPos( pwwd->hVScrBar, pwwd->sbVbar,
               pwwd->drElevator = 0, TRUE);
 SetScrollPos( pwwd->hHScrBar, pwwd->sbHbar,
               pwwd->xpMin = 0, TRUE);

 NewCurWw(0, true);
 TrashCache();      /* Invalidate Scrolling cache */

 vfPrPages = FALSE;

 if (pwwd->fRuler)
     {
     ResetTabBtn();
     }

 SetTitle(szDoc);

/* Since we are changing document, ensure that we don't use parameters
                set by a search in a previous window by setting flag false */
 vfDidSearch = FALSE;
 cpWall = selCur.cpLim;
}




/* F N  C R E A T E  S Z */
int FnCreateSz(szT, cpMac, dty )
CHAR *szT;
typeCP cpMac;
int dty;
{             /* Create & Open a new file of the specified type. */
              /* If cpMac != cpNil, write an FIB to the file */
              /* if dty==dtyNetwork, generate a unique name in the current
                 directory and copy it to szT */
              /* WARNING: dty != dtyNetwork SUPPORT HAS BEEN REMOVED */

    int fn;
    struct FCB *pfcb; /* Be VERY careful of heap movement when using pfcb */
    struct FIB fib;
    CHAR (**hsz)[];
    CHAR sz[cchMaxFile];

    bltsz(szT, sz);
    sz[cchMaxFile - 1] = 0;

    if ((fn = FnAlloc()) == fnNil)
        return fnNil;

    pfcb = &(**hpfnfcb)[fn];
    pfcb->mdExt = pfcb->dty = dtyNormal;
    pfcb->mdFile = mdBinary;

    Assert( dty == dtyNetwork );

    if (!FCreateFile( sz, fn ))     /* Sets pfcb->hszFile, pfcb->rfn */
        return fnNil;

    FreezeHp();
    pfcb = &(**hpfnfcb)[fn];

        /* Copy unique filename to parm */
    bltsz( **pfcb->hszFile, szT );

#ifdef INEFFICIENT
    pfcb->fcMac = fc0;
    pfcb->pnMac = pn0;
#endif

    if (cpMac == cpNil)
        { /* Unformatted file */
#ifdef INEFFICIENT
        pfcb->fFormatted = false;
#endif
        MeltHp();
        }
    else
        { /* Formatted file; write FIB */
        bltbc(&fib, 0, cchFIB);
        pfcb->fFormatted = true;
#ifdef INEFFICIENT
        pfcb->pnChar = pfcb->pnPara = pfcb->pnFntb =
            pfcb->pnSep = pfcb->pnSetb = pfcb->pnBftb = pn0;
#endif
        MeltHp();
        fib.wIdent = wMagic;
        fib.dty = dtyNormal;
        fib.wTool = wMagicTool;
        fib.fcMac = cpMac + cfcPage;
        WriteRgch(fn, &fib, (int)cfcPage);
        }
    return fn;
} /* end of  F n C r e a t e S z  */





int DocCreate(fn, hszFile, dty)
int fn, dty;
CHAR (**hszFile)[];
{ /* Create a document */
extern int vfTextOnlySave;
struct FNTB **HfntbCreate();
struct TBD (**HgtbdCreate())[];
int doc;
int fFormatted, fOldWord;

struct DOD *pdod;
struct SEP **hsep = (struct SEP **)0;  /* MEMO only; for CASHMERE, use hsetb */
struct PGTB **hpgtb=(struct PGTB **)0;
struct FFNTB **hffntb=(struct FFNTB **)0;
struct TBD (**hgtbd)[]=(struct TBD (**)[])0;
struct FNTB **hfntb = (struct FNTB **) 0;
CHAR (**hszSsht)[];

fFormatted = (fn == fnNil) || (**hpfnfcb)[fn].fFormatted;
fOldWord = FALSE;

if ((doc = DocAlloc()) == docNil ||   /* HEAP MOVEMENT */
    !FInitPctb(doc, fn)) /* HEAP MOVEMENT */
    return docNil;

pdod = &(**hpdocdod)[doc];

pdod->fReadOnly = (fn != fnNil) && ((**hpfnfcb)[fn].mdFile == mdBinRO);
pdod->cref = 1;
pdod->fFormatted = fFormatted;
pdod->dty = dty;
pdod->fBackup = false;  /* Default: don't automatically make backup */
pdod->fDisplayable = TRUE;

switch(dty)
    { /* HEAP MOVEMENT */
case dtyHlp:
    if (FNoHeap(hpgtb = HpgtbCreate(fn)))
        goto ErrFree;
    if (FNoHeap(hffntb = HffntbCreateForFn(fn, &fOldWord)))
        goto ErrFree;
    break;

case dtyNormal:
    if (fn != fnNil && fFormatted)
        {
#ifdef FOOTNOTES
        if (FNoHeap(hfntb = HfntbCreate(fn)))
            goto ErrFree;
#endif
        if (FNoHeap(hsep = HsepCreate(fn)))
            goto ErrFree;
        if (FNoHeap(hpgtb = HpgtbCreate(fn)))
            goto ErrFree;
        if (FNoHeap(hgtbd = HgtbdCreate(fn)))
            goto ErrFree;
        }
    if (FNoHeap(hffntb = HffntbCreateForFn(fn, &fOldWord)))
        goto ErrFree;

#ifdef JAPAN                  //  added  10 Jun. 1992  by Hiraisi
{
    int fnCheckFacename(CHAR *, struct FFNTB **);
    int fontChg;   // This specifies whether facenames are changed or not.

    if( fn != fnNil && fFormatted ){
        fontChg = fnCheckFacename( *hszFile[0], hffntb );
        if( fontChg == docNil ){        // Changing facenames was cancelled.
            goto ErrFree;
        }
        else{
            if( fontChg == TRUE ){      // Facenames were changed.
                /* Flag wheter doc has been edited.    30 Jul. */
                (**hpdocdod)[doc].fDirty = TRUE;
            }
        }
    }
}
#endif    //JAPAN

    break;
case dtySsht:
    goto DtyCommon;
case dtyBuffer:
    if (fn != fnNil)
        {
#ifdef FOOTNOTES
        if (FNoHeap(hfntb = HfntbCreate(fn)))
            goto ErrFree;
#endif
        if (FNoHeap(hsep = HsepCreate(fn)))
            goto ErrFree;
        if (FNoHeap(hgtbd = HgtbdCreate(fn)))
            goto ErrFree;
        }
DtyCommon:
    hpgtb = 0;
    }

pdod = &(**hpdocdod)[doc];

pdod->hszFile = hszFile;
pdod->docSsht = docNil;
pdod->hfntb = hfntb;
pdod->hsep = hsep;
pdod->hpgtb = hpgtb;
pdod->hffntb = hffntb;
pdod->hgtbd = hgtbd;
if (fOldWord)
        if (!FApplyOldWordSprm(doc))
                goto ErrFree;

ApplyRHMarginSprm( doc );
vfTextOnlySave = !fFormatted;
return doc;

ErrFree:
        FreeH( hsep );
        FreeFfntb( hffntb );
        FreeH(hgtbd);
        FreeH(hpgtb);
#ifdef FOOTNOTES
        FreeH(hfntb);
#endif
        FreeH((**hpdocdod)[doc].hpctb);
        (**hpdocdod)[doc].hpctb = 0;

return docNil;
} /* end of  D o c C r e a t e  */




ApplyRHMarginSprm( doc )
int doc;
{   /* Apply a sprm to adjust paper-relative running head indents to
       be margin-relative */
extern typeCP cpMinDocument;
extern struct SEP vsepNormal;

ValidateHeaderFooter( doc );
if (cpMinDocument != cp0)
    {   /* Doc has running head/foot, apply sprm */
    CHAR rgb[ 2 + (2 * sizeof( int )) ];
    struct SEP **hsep = (**hpdocdod) [doc].hsep;
    struct SEP *psep = (hsep == NULL) ? &vsepNormal : *hsep;

    rgb[0] = sprmPRhcNorm;
    rgb[1] = 4;
    *((int *) (&rgb[2])) = psep->xaLeft;
    *((int *) (&rgb[2 + sizeof(int)])) = psep->xaMac -
                                         (psep->xaLeft + psep->dxaText);
    AddSprmCps( rgb, doc, cp0, cpMinDocument );
    }
}




int DocAlloc()
{
int doc;
struct DOD *pdod = &(**hpdocdod)[0];
struct DOD *pdodMac = pdod + docMac;

for (doc = 0; pdod < pdodMac; ++pdod, ++doc)
    if (pdod->hpctb == 0)
        return doc;
if (!FChngSizeH((int **)hpdocdod, cwDOD * ++docMac, false))
    {
    --docMac;
    return docNil;
    }
return docMac - 1;
} /* end of  D o c A l l o c  */

FInitPctb(doc, fn)
int doc, fn;
{ /* Initialize the piece table for a doc, given its initial fn */
struct PCTB **hpctb;
struct DOD *pdod;
struct PCTB *ppctb;
struct PCD *ppcd;
typeFC dfc;
typeCP cpMac;

hpctb = (struct PCTB **)HAllocate(cwPCTBInit);  /* HM */
if (FNoHeap(hpctb))
    return false;
pdod = &(**hpdocdod)[doc];
ppctb = *(pdod->hpctb = hpctb); /* Beware hp mvmt above */
ppcd = ppctb->rgpcd;
dfc = (fn != fnNil && (**hpfnfcb)[fn].fFormatted ? cfcPage : fc0);
cpMac = (fn == fnNil ? cp0 : (**hpfnfcb)[fn].fcMac - dfc);

ppctb->ipcdMax = cpcdInit;
ppctb->ipcdMac = (cpMac == cp0 ) ? 1 : 2; /* One real piece and one end piece */
ppcd->cpMin = cp0;

if ((pdod->cpMac = cpMac) != cp0)
    {
    ppcd->fn = fn;
    ppcd->fc = dfc;
    SETPRMNIL(ppcd->prm);
    ppcd->fNoParaLast = false;
    (++ppcd)->cpMin = cpMac;
    }

ppcd->fn = fnNil;
SETPRMNIL(ppcd->prm);
ppcd->fNoParaLast = true;

pdod->fDirty = false;
return true;
} /* end of  F I n i t P c t b  */

int FnAlloc()
{ /* Allocate an fn number */
int fn;
struct FCB *pfcb;

for (fn = 0 ; fn < fnMac ; fn++)
    if ((**hpfnfcb)[fn].rfn == rfnFree)
    goto DoAlloc;
if (!FChngSizeH(hpfnfcb, (fnMac + 1) * cwFCB, false))
    return fnNil;
fn = fnMac++;

DoAlloc:
bltc(pfcb = &(**hpfnfcb)[fn], 0, cwFCB);
pfcb->rfn = rfnFree;
return fn;
} /* end of  F n A l l o c  */



fnNewFile()
{       /* Open a new, fresh, untitled document in our MEMO window */
        /* Offer confirmation if the current doc is dirty & permit save */
 extern HANDLE hMmwModInstance;
 extern HANDLE hParentWw;
 extern int docCur;
 extern struct SEL selCur;
 extern typeCP cpMinDocument;
 extern int vfTextOnlySave, vfBackupSave;
 extern CHAR szUntitled[];

 if (FConfirmSave())    /* Allow the user to save if docCur is dirty */
    {

#if defined(OLE)
    if (ObjClosingDoc(docCur,szUntitled))
        return;
#endif

    KillDoc( docCur );

    docCur = DocCreate( fnNil, HszCreate( "" ), dtyNormal );
    Assert( docCur != docNil );
    ChangeWwDoc( "" );

#if defined(OLE)
    ObjOpenedDoc(docCur); // very unlikely to fail, not fatal if it does
#endif

#ifdef WIN30
    FreeUnreferencedFns();
#endif
    }
} /* end of  f n N e w F i l e  */







struct FFNTB **HffntbCreateForFn(fn, pfOldWord)
/* returns heap copy of ffntb (font names) for fn */

int fn, *pfOldWord;
{
struct FFNTB **hffntb;
typePN pn;
struct FCB *pfcb;
typePN pnMac;
#ifdef NEWFONTENUM
BOOL fCloseAfterward;
#endif

if (FNoHeap(hffntb = HffntbAlloc()))
        return(hffntb);
pfcb = &(**hpfnfcb)[fn];
pn = pfcb->pnFfntb;
if (fn == fnNil || !pfcb->fFormatted)
        {
#if WINVER >= 0x300
        /* WINBUG 8992: Clean up so don't lose alloc'd memory! ..pault 2/12/90 */
        FreeFfntb(hffntb);
#endif
        hffntb = HffntbNewDoc(FALSE);
        }
else if (pn != (pnMac=pfcb->pnMac))
        {   /* "normal" memo file - has a font table */
        CHAR *pch;
        int cch;
        int iffn;
        int iffnMac;

        /* Read the first page:
                bytes 0..1              iffnMac
                0..n sections of:
                    bytes 0..1          cbFfn
                    bytes 2..cbFfn+2    Ffn
                bytes x..x+1            0xFFFF  (end of page)
            OR  bytes x..x+1            0x0000  (end of font table) */

        pch = PchGetPn( fn, pn, &cch, FALSE );
        if (cch != cbSector)
            goto Error;
        iffnMac = *( (int *) pch);
        pch += sizeof (int);
#ifdef NEWFONTENUM
        /* Since we now support multiple charsets, but write 2 and write 1
           documents did not save these in their ffntb's, we have to do an
           extra step now in order to "infer" the proper charset values.  We
           enumerate all the possible fonts, and then as we read in each new
           document font we try to match it up with what the system knows
           about ..pault 10/18/89 */
        fCloseAfterward = FInitFontEnum(docNil, 32767, FALSE);
#endif

        for ( iffn = 0; ; )
            {
            /* Add ffn entries from one disk page to the font table */

            while ( TRUE )
                {
                int cb = *((int *) pch);

                if (cb == 0)
                    goto LRet;      /* Reached end of table */
                else if (cb == -1)
                    break;          /* Reached end of disk page */
                else
                    {
#ifdef NEWFONTENUM
                    /* Having added the chs field to the (RAM) FFN structure,
                       we now have trouble reading FFN's from the document 
                       directly.  And because Write was designed very early
                       without regard to variable charsets, we can't store 
                       the charset value along with the fontname, so we have
                       to infer it! ..pault */
                    CHAR rgbFfn[ibFfnMax];
                    struct FFN *pffn = (struct FFN *)rgbFfn;
                    pch += sizeof(int);

                    bltsz(pch + sizeof(BYTE), pffn->szFfn);
                    pffn->ffid = *((FFID *) pch);
                    pffn->chs = ChsInferred(pffn);
                    if (FtcAddFfn(hffntb, pffn) == ftcNil)
#else
                    if (FtcAddFfn( hffntb, pch += sizeof(int) ) == ftcNil)
#endif
                        {
Error:
#ifdef NEWFONTENUM
                        if (fCloseAfterward)
                            EndFontEnum();
#endif
                        FreeFfntb( hffntb );
                        return (struct FFNTB **) hOverflow;
                        }
                    iffn++;
                    if (iffn >= iffnMac)
                            /* Reached last item in table, by count */
                            /* This is so we can read old WRITE files, */
                            /* in which the table was not terminated by 0 */
                        goto LRet;
                    pch += cb;
                    }
                }   /* end while */

            /* Read the next page from the file. Page format is like the first
               ffntb page (see above) but without the iffnMac */

            if (++pn >= pnMac)
                break;
            pch = PchGetPn( fn, pn, &cch, FALSE );
            if (cch != cbSector)
                goto Error;
            }   /* end for */
        }
else
        {
        /* word file - create a simple font table that we can map word's
           fonts onto */

        /* temporarily we map them all onto one font - soon we'll have a set */
#if WINVER >= 0x300
        /* WINBUG 8992: Clean up so don't lose alloc'd memory! ..pault 2/12/90 */
        FreeFfntb(hffntb);
#endif
        hffntb = HffntbNewDoc(TRUE);
        *pfOldWord = TRUE;
        }

LRet:
#ifdef NEWFONTENUM
            if (fCloseAfterward)
                EndFontEnum();
#endif
return(hffntb);
}



struct FFNTB **HffntbNewDoc(fFullSet)
/* creates a font table with the default font for this doc */

int fFullSet;
{
struct FFNTB **hffntb;

hffntb = HffntbAlloc();
if (FNoHeap(hffntb))
        return(hffntb);

/* make sure we at least have a "standard" font */
#ifdef  KOREA    /* ROMAN as family of standard font(myoungjo). sangl 91.4.17 */
if (!FEnsurePffn(hffntb, PffnDefault(FF_ROMAN)))
#else
if (!FEnsurePffn(hffntb, PffnDefault(FF_DONTCARE)))
#endif
        {
        goto BadAdd;
        }

if (fFullSet)
        /* we need a full set of fonts for word ftc mapping */
        if (!FEnsurePffn(hffntb, PffnDefault(FF_MODERN)) ||
#ifdef  KOREA
            !FEnsurePffn(hffntb, PffnDefault(FF_DONTCARE)) ||
#else
            !FEnsurePffn(hffntb, PffnDefault(FF_ROMAN)) ||
#endif
            !FEnsurePffn(hffntb, PffnDefault(FF_SWISS)) ||
            !FEnsurePffn(hffntb, PffnDefault(FF_SCRIPT)) ||
            !FEnsurePffn(hffntb, PffnDefault(FF_DECORATIVE)))
        BadAdd:
                {
                FreeFfntb(hffntb);
                hffntb = (struct FFNTB **)hOverflow;
                }

return(hffntb);
}



CHAR * PchBaseNameInUpper(szName)
CHAR *szName;
{
    CHAR * pchStart = szName;
#ifdef DBCS
    CHAR * pchEnd = AnsiPrev( pchStart, pchStart + CchSz(szName) );
#else
    CHAR * pchEnd = pchStart + CchSz(szName) - 1;
#endif

    while (pchEnd >= pchStart)
        {
#ifdef DBCS
        if (*pchEnd == '\\' || *pchEnd == ':') {
            // T-HIROYN 1992.07.31 bug fix
            pchEnd++;
            break;
        }
        else if (!IsDBCSLeadByte(*pchEnd))
           *pchEnd = ChUpper(*pchEnd);
      {
        LPSTR lpstr = AnsiPrev( pchStart, pchEnd );
        if( pchEnd == lpstr )
            break;
        pchEnd = lpstr;
      }
#else
        if (*pchEnd == '\\' || *pchEnd == ':')
            break;
        else
           *pchEnd = ChUpper(*pchEnd);
        pchEnd--;
#endif
        }
#ifdef DBCS
    return(AnsiUpper(pchEnd));
#else
    return(pchEnd+1);
#endif
}


SetTitle(szSource)
CHAR *szSource;
{
extern CHAR szUntitled[];
extern int  vfIconic;
extern CHAR szAppName[];
extern CHAR szSepName[];

CHAR *pch = stBuf;
CHAR szDocName[cchMaxFile];

    pch += CchCopySz((PCH)szAppName, stBuf);
    pch += CchCopySz((PCH)szSepName, pch);

    if (szSource[0] == '\0')
        {
        CchCopySz( szUntitled, pch );
        }
    else
        { /* get the pointer to the base file name and convert to upper case */
        CchCopySz(szSource, szDocName);
        CchCopySz(PchBaseNameInUpper(szDocName), pch);
        }
    SetWindowText(hParentWw, (LPSTR)stBuf);
}



ValidateHeaderFooter( doc )
{       /* Look for a MEMO-style running header and/or footer in the document.
           We scan from the beginning of the document, taking the first
           contiguous sequence of running head paragraphs as the running
           head region, and the first contiguous sequence of running foot
           paragraphs as the running foot region. We break the process
           at the first non-running paragraph or when we have both runs
           Update values of cpMinDocument, cpMinFooter, cpMacFooter,
           cpMinHeader, cpMacHeader.
           These ranges INCLUDE the EOL (and Return, if CRLF) at the end of the
           header/footer
           If we are currently editing a header or footer in the passed doc,
           adjust the values of cpFirstDocSave, selDocSave to reflect the
           change */

 extern int docScrap;
 extern typeCP vcpFirstParaCache;
 extern typeCP vcpLimParaCache;

#define fGot        0
#define fGetting    1
#define fNotGot     2

 int fGotHeader=fNotGot;
 int fGotFooter=fNotGot;
 typeCP cpMinDocT=cpMinDocument;
 typeCP cpMinCurT = cpMinCur;
 typeCP cpMacCurT = cpMacCur;
 typeCP cp;

 if (doc == docNil || doc == docScrap)
    return;

 /* Want access to the entire doc cp range for this operation */

 cpMinCur = cp0;
 cpMacCur = (**hpdocdod) [doc].cpMac;

 cpMinDocument = cpMinFooter = cpMacFooter = cpMinHeader = cpMacHeader = cp0;

 for ( cp = cp0;
      (cp < cpMacCur) && (CachePara( doc, cp ), vpapAbs.rhc);
      cp = vcpLimParaCache )
    {
    int fBottom=vpapAbs.rhc & RHC_fBottom;

    if (fBottom)
        {
        if (fGotHeader == fGetting)
            fGotHeader = fGot;
        switch (fGotFooter) {
            case fGot:
                    /* Already have footer from earlier footer run */
                return;
            case fNotGot:
                cpMinFooter = vcpFirstParaCache;
                fGotFooter = fGetting;
                /* FALL THROUGH */
            case fGetting:
                cpMacFooter = cpMinDocument = vcpLimParaCache;
                break;
            }
        }
    else
        {
        if (fGotFooter == fGetting)
            fGotFooter = fGot;
        switch (fGotHeader) {
            case fGot:
                    /* Already have header from earlier header run */
                return;
            case fNotGot:
                cpMinHeader = vcpFirstParaCache;
                fGotHeader = fGetting;
                /* FALL THROUGH */
            case fGetting:
                cpMacHeader = cpMinDocument = vcpLimParaCache;
                break;
             }
        }
    }   /* end of for loop through paras */

    /* Restore saved cpMacCur, cpMinCur */
 cpMinCur = cpMinCurT;
 cpMacCur = cpMacCurT;

    /* Adjust saved cp's that refer to the document to reflect
       header/footer changes */
 if ((wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter) &&
     wwdCurrentDoc.doc == doc )
    {
    typeCP dcpAdjust=cpMinDocument - cpMinDocT;

    if (dcpAdjust != (typeCP) 0)
        {
        selDocSave.cpFirst += dcpAdjust;
        selDocSave.cpLim   += dcpAdjust;
        cpFirstDocSave += dcpAdjust;
        }
    }
}

#ifdef JAPAN                  //  added  10 Jun. 1992  by Hiraisi

#include "dlgdefs.h"
BOOL FAR PASCAL _export DialogCvtFont( HWND, UINT, WPARAM, LPARAM );

BOOL FAR PASCAL _export DialogCvtFont( hDlg, uMsg, wParam, lParam )
HWND   hDlg;
UINT   uMsg;
WPARAM wParam;
LPARAM lParam;
{
    switch (uMsg){
    case WM_INITDIALOG:
        {
        char szPrompt[cchMaxSz];
        CHAR *pch = stBuf;

        if( *pch == '\\' )
            pch++;
        MergeStrings(IDPMTFontChange, pch, szPrompt);
        SetDlgItemText(hDlg, idiChangeFont, (LPSTR)szPrompt);
        }
        break;
    case WM_COMMAND:
        switch (wParam){
        case IDOK:
            EndDialog(hDlg, FALSE);
            break;
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return(FALSE);
    }
    return(TRUE);
}

/*
 *    This function checks facenames and removes '@' from "@facename"(s)
 *  if facenames with '@' are found in doc of WRITE.
 *      Return : TRUE=deleted ,FALSE=not found ,docNil(-1)=cancelled
*/
int fnCheckFacename( sz, hffntb )
CHAR *sz;
struct FFNTB **hffntb;
{

    struct FFNTB *pffntb;
    struct FFN *pffn;
    int  ix, len;
    BOOL bChange, bRet;
    CHAR *szFfn;
    CHAR *pch = stBuf;
    FARPROC lpDialogCvtFont;

    pffntb = *hffntb;
    bChange = FALSE;
    for( ix = 0; ix < pffntb->iffnMac; ix++ ){
        pffn = *pffntb->mpftchffn[ix];
        szFfn = pffn->szFfn;
        if( *szFfn == '@' ){
            if( !bChange ){
                lpDialogCvtFont = MakeProcInstance(DialogCvtFont,
                                                   hMmwModInstance);
                CchCopySz(PchBaseNameInUpper(sz), pch);
                bRet = DialogBox( hMmwModInstance,
                                  MAKEINTRESOURCE(dlgChangeFont),
                                  hParentWw, lpDialogCvtFont);
                FreeProcInstance(lpDialogCvtFont);
                if( bRet )
                    return(docNil);

                bChange = TRUE;
            }
            len = CchCopySz( szFfn+1, pffn->szFfn);
            *(pffn->szFfn+len) = '\0';
        }
    }

    return(bChange);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\cmacros3.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg UTIL_TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\cmddefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define cchInsBlock     32      /* Length of quick insert block */

struct SEL
        {
        typeCP          cpFirst;
        typeCP          cpLim;
        unsigned        fForward : 1;     /* Only needs 1 bit */
        unsigned        fEndOfLine : 1;
        };

#define cwSEL   (sizeof (struct SEL) / sizeof (int))
#define cbSEL  (sizeof (struct SEL))

#define styNil          0
#define styChar         1
#define styWord         2
#define stySent         3
#define styPara         4
#define styLine         5
#define styDoc          6

#ifndef NOUAC
/* UNDO Action Codes: */
#define uacNil           0       /* Nothing to UNDO */
#define uacInsert        1       /* Insert text <--> UInsert */
#define uacReplNS        2       /* Replace text, no scrap <--> UReplNS */
#define uacDelNS         3       /* Delete text, no scrap <--> UDelNS */
#define uacMove          4       /* Move text <--> Move */
#define uacDelScrap      5       /* Delete to scrap <--> UDelScrap */
#define uacUDelScrap     6       /* Undo of Delete <--> DelScrap */
#define uacReplScrap     7       /* Replace with del to scrap
                                        <--> UReplScrap */
#define uacUReplScrap    8       /* Undo of ReplScrap <--> ReplScrap */
#define uacDelBuf        9      /* Delete to buffer <--> UDelBuf */
#define uacUDelBuf      10      /* Undo of DelBuf <--> DelBuf */
#define uacReplBuf      11      /* Replace with del to buf <--> UReplBuf */
#define uacUReplBuf     12      /* Undo of ReplBuf <--> ReplBuf */
#define uacCopyBuf      13      /* Copy to buf <--> UCopyBuf */
#define uacUInsert      14      /* undo of Insert <--> Insert */
#define uacUDelNS       15      /* undo of DelNS <--> DelNS */
#define uacUReplNS      16      /* undo of ReplNS <--> ReplNS */
#define uacUCopyBuf     17      /* Undo of CopyBuf <--> CopyBuf */
#define uacReplGlobal   18
#define uacFormatCStyle 19
#define uacChLook       20
#define uacChLookSect   21
#define uacFormatChar   22
#define uacFormatPara   23
#define uacGalFormatChar        24
#define uacGalFormatPara        25
#define uacFormatSection        26
#define uacGalFormatSection     27
#define uacFormatPStyle 28
#define uacFormatSStyle 29
#define uacFormatRHText 30
#define uacLookCharMouse 31
#define uacLookParaMouse 32
#define uacClearAllTab 33
#define uacFormatTabs 34
#define uacClearTab 35
#define uacOvertype 36
#define uacPictSel 37
#define uacInsertFtn 38
#define uacReplPic 39
#define uacUReplPic 40

#ifndef CASHMERE
#define uacRulerChange 41
#define uacRepaginate 42
#endif /* not CASHMERE */
#endif /* NOUAC */

#if defined(OLE)
#define uacObjUpdate  43
#define uacUObjUpdate  44
#endif

/* Units */
#define utInch          0
#define utCm            1
#define utP10           2
#define utP12           3
#define utPoint         4
#define utLine          5
#define utMax           6

#define czaInch         1440
#define czaP10          144
#define czaPoint        20
#define czaCm           567
#define czaP12          120

#define czaLine         240

#define ZaFromMm(mm)    (unsigned)MultDiv(mm, 14400, 254);

#ifdef	KOREA		/* Dum Write doesn't accept it's default value!! 90.12.29 */
#define FUserZaLessThanZa(zaUser, za)	((zaUser) + (7 * czaInch) / 1000 < (za))
#else
#define FUserZaLessThanZa(zaUser, za)   ((zaUser) + (5 * czaInch) / 1000 < (za))
#endif

/* Modes -- see menu.mod */
#define ifldEdit        0
#define ifldGallery     1

#define ecrSuccess      1
#define ecrCancelled    2
#define ecrMouseKilled  4

typeCP  CpFirstSty(), CpLastStyChar();

#define psmNil          0
#define psmCopy         1
#define psmMove         2
#define psmLookChar     3
#define psmLookPara     4
#define psmLooks        3

#define crcAbort        0
#define crcNo           1
#define crcYes          2

/* FWrite checks */
#define fwcNil          0
#define fwcInsert       1
#define fwcDelete       2
#define fwcReplace      3
#define fwcEMarkOK      4       /* Additive -- must be a bit */

/* Dialog item parsing variants */
#define wNormal 0x1
#define wBlank 0x2
#ifdef AUTO_SPACING
#define wAuto 0x4
#endif /* AUTO_SPACING */
#define wDouble 0x8
          /* wSpaces means treat string of all spaces as a null string */
#define wSpaces 0x10

/* page bound */
#define pgnMin 1
#define pgnMax 32767

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\dbcs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#ifdef DBCS

#define	cchDBCS		2
#define fkNonDBCS	((CHAR) 0)
#define fkDBCS1		((CHAR) 1)
#define fkDBCS2		((CHAR) 2)

#define MAKEWORD(_bHi, _bLo) ((((WORD) _bHi) << 8) | ((WORD) _bLo))

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\commdlg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#include <windows.h>
#include "mw.h"
#include "menudefs.h"
#include "str.h"
#include <commdlg.h>
#include "filedefs.h"
#include <dlgs.h>
#include "doslib.h"
#include "obj.h"

extern HANDLE   hMmwModInstance;
extern CHAR     szAppName[];
extern HWND     vhWndMsgBoxParent,hParentWw,vhWnd;
static OPENFILENAME    OFN;
static bSave;
FARPROC lpfnOFNHook=NULL;
BOOL FAR PASCAL fnOFNHook(HWND hDlg, unsigned msg, WORD wParam, LONG lParam) ;

#define hINSTANCE  hMmwModInstance

#define hDOCWINDOW vhWnd
#define hMAINWINDOW hParentWw
#define hPARENTWINDOW  ((vhWndMsgBoxParent == NULL) ? \
                    hParentWw : vhWndMsgBoxParent)

#define	CBPATHMAX	cchMaxFile
#define	CFILTERMAX	6			/* Max # filters */
#define CBFILTERSIZE  40
#define	CBFILTERMAX	(CBFILTERSIZE * CFILTERMAX)	/* Max # chars/filter */
#define CBMESSAGEMAX 80

static char fDefFileType;
#define SA_WORDTEXT 0
#define SA_TEXTONLY 1
#define SA_WORD     2
#define SA_OLDWRITE 3
#define SA_WRITE    4

static char *szDefExtensions[6];
static int   nTextOnly,nWordText,nWord,nOldWrite; // position in filterspec list box
static char  szNull[1] = "";
static char  szWild[3] = "*.";
static char	 szOpenFile[CBMESSAGEMAX];
static char	 szSaveFile[CBMESSAGEMAX];
static char  szFileName[CBPATHMAX];
static char  szLastDir[CBPATHMAX];
static char  szDefWriExtension[CBMESSAGEMAX];
static char  szDefDocExtension[CBMESSAGEMAX];
static char  szDefTxtExtension[CBMESSAGEMAX];
static char  szWriDescr[CBMESSAGEMAX];
static char  szDocDescr[CBMESSAGEMAX];
static char  szTxtDescr[CBMESSAGEMAX];
static char  szAllFilesDescr[CBMESSAGEMAX];
static char  szDocTxtDescr[CBMESSAGEMAX];
static char  szOldWriteDescr[CBMESSAGEMAX];
static char  szFilterSpec[CBFILTERMAX];
static char  szCustFilterSpec[CBFILTERSIZE];

static MakeFilterString(int iWhichOper);
int InitCommDlg(int iWhichOper);

int InitCommDlg(int iWhichOper) 
{
    OFN.lpstrDefExt         = NULL;
    OFN.lpstrFile           = szFileName;
    OFN.lpstrFilter         = szFilterSpec;
    OFN.lpstrCustomFilter   = szCustFilterSpec;

    switch(iWhichOper)
    {
        case 0:  // beginning of Write session
            OFN.lStructSize         = sizeof(OPENFILENAME);
            OFN.hInstance           = hINSTANCE;
            OFN.lCustData           = NULL;
            OFN.lpTemplateName      = NULL;
            OFN.lpstrFileTitle      = NULL;
            OFN.nMaxFileTitle       = 0;
            OFN.nMaxFile            = CBPATHMAX;
            OFN.lpstrInitialDir     = NULL;
            OFN.nMaxCustFilter      = CBFILTERSIZE;

            LoadString(hINSTANCE, IDSTROpenfile, szOpenFile, sizeof(szOpenFile));
            LoadString(hINSTANCE, IDSTRSavefile, szSaveFile, sizeof(szSaveFile));
            LoadString(hINSTANCE, IDSTRDefWriExtension, szDefWriExtension, sizeof(szDefWriExtension));
            LoadString(hINSTANCE, IDSTRDefDocExtension, szDefDocExtension, sizeof(szDefDocExtension));
            LoadString(hINSTANCE, IDSTRDefTxtExtension, szDefTxtExtension, sizeof(szDefTxtExtension));
            LoadString(hINSTANCE, IDSTRWriDescr, szWriDescr, sizeof(szWriDescr));
            LoadString(hINSTANCE, IDSTRDocDescr, szDocDescr, sizeof(szDocDescr));
            LoadString(hINSTANCE, IDSTRTxtDescr, szTxtDescr, sizeof(szTxtDescr));
            LoadString(hINSTANCE, IDSTRDocTextDescr, szDocTxtDescr, sizeof(szDocTxtDescr));
            LoadString(hINSTANCE, IDSTRAllFilesDescr, szAllFilesDescr, sizeof(szAllFilesDescr));
            LoadString(hINSTANCE, IDSTROldWriteDescr, szOldWriteDescr, sizeof(szOldWriteDescr));
                           
        return FALSE;

        case imiOpen:
            if ((lpfnOFNHook = MakeProcInstance(fnOFNHook, hINSTANCE)) == NULL)
                return TRUE;

            OFN.hwndOwner           = hPARENTWINDOW;
            OFN.Flags               = OFN_ENABLEHOOK|OFN_HIDEREADONLY|OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST;
            OFN.lpfnHook            = lpfnOFNHook;
            lstrcpy(szFileName,szWild);
            lstrcat(szFileName,szDefWriExtension);
            OFN.lpstrTitle          = szOpenFile;
            szCustFilterSpec[0] = '\0';
            
            fDefFileType = SA_WRITE; /* see MakeFilterSpec */
            MakeFilterString(iWhichOper);

        return FALSE;

        case imiSaveAs:
            /* read only will become the backup check box */
            if ((lpfnOFNHook = MakeProcInstance(fnOFNHook, hINSTANCE)) == NULL)
                return TRUE;

            OFN.hwndOwner           = hPARENTWINDOW;
            OFN.Flags               = OFN_ENABLEHOOK|OFN_PATHMUSTEXIST|OFN_OVERWRITEPROMPT;
            OFN.lpfnHook            = lpfnOFNHook;
            OFN.lpstrTitle          = szSaveFile;
            szCustFilterSpec[0] = '\0';
            MakeFilterString(iWhichOper);

        return FALSE;
    }

}

int DoCommDlg(int iWhichOper) 
/* returns whether file was retrieved */
/* iWhichOper is the imi* code from the menu */
{
    int iRetval;

    bSave =  iWhichOper == imiSaveAs;

    iRetval = !InitCommDlg(iWhichOper);

    if (!iRetval)
        goto end;

    LockData(0);
    switch(iWhichOper)
    {
        case imiOpen:
            iRetval = GetOpenFileName((LPOPENFILENAME)&OFN);
        break;
        case imiSaveAs:
            iRetval = GetSaveFileName((LPOPENFILENAME)&OFN);
        break;
    }
    UnlockData(0);

    if (CommDlgExtendedError())
    {
        iRetval = FALSE;
        Error(IDPMTNoMemory);
    }

    end:

    if (iRetval)
    {
        lstrcpy(szLastDir,szFileName);
        szLastDir[OFN.nFileOffset] = 0;
        OFN.lpstrInitialDir = szLastDir;
    }

    switch(iWhichOper)
    {
        case imiOpen:
        case imiSaveAs:
            if (lpfnOFNHook)
                FreeProcInstance(lpfnOFNHook);
            lpfnOFNHook = NULL;
        break;
    }

    return iRetval;
}

#include "docdefs.h"

BOOL FAR PASCAL fnOFNHook(HWND hDlg, unsigned msg, WORD wParam, LONG lParam) 
{
    static unsigned wmListBoxChange;
    static unsigned wmCheckShare;
    extern int         docCur;
    extern struct DOD      (**hpdocdod)[];

    switch (msg) 
    {
        case WM_INITDIALOG: 
            if (bSave)
            {
                char szTitle[CBMESSAGEMAX];

                LoadString(hINSTANCE, IDSTRBackup, szTitle, sizeof(szTitle));
                SetDlgItemText(hDlg,chx1,szTitle);

                CheckDlgButton(hDlg,chx1,OFN.Flags&OFN_READONLY);
                if (szFileName[0] == 0)
                    SetDlgItemText(hDlg,edt1,"");
            }
            else // open
                wmCheckShare = RegisterWindowMessage(SHAREVISTRING);
            wmListBoxChange = RegisterWindowMessage(LBSELCHSTRING);

        break;

        case WM_COMMAND:
            if (bSave)
                switch (wParam)
                {
                    case chx1:
                    /* handle checking the readonly button (I forget what does this do??)
                        (we've changed readonly to be a "Backup" button) */
                        return TRUE;
                    break;
                }
        break;

        default:
            if ((msg == wmListBoxChange) && (wParam == cmb1))
                /* file type selected, set the default extension */
                OFN.lpstrDefExt  = szDefExtensions[LOWORD(lParam)];
            else if ((msg == wmCheckShare) && !bSave)
            /* we want to be able to reopen current document */
            {
                if (!lstrcmpi((LPSTR)(**((**hpdocdod)[docCur].hszFile)),(LPSTR)lParam))
                    return OFN_SHAREFALLTHROUGH;
                else
                    return OFN_SHAREWARN;
            }
        break;

    }
    return FALSE;
}


static MakeFilterString(int iWhichOper)
/* Construct the filter string for the Open, Save dialogs */
/* assume fDefFileType is set */
{
    LPSTR lpStr = szFilterSpec;
    char **ppstr = szDefExtensions;
    int nCount=1;

    /* WRI */
    lstrcpy(lpStr, szWriDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, szDefWriExtension);
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = szDefWriExtension;
    ++nCount;

    if (iWhichOper == imiSaveAs)
    {
        /* Old WRI (without objects) */
        vcObjects = ObjEnumInDoc(docCur,NULL);

        if (vcObjects > 0)
        {
            lstrcpy(lpStr, szOldWriteDescr);
            lpStr += lstrlen(lpStr)+1;
            lstrcpy(lpStr, szWild);
            lstrcat(lpStr, szDefWriExtension);
            lpStr += lstrlen(lpStr)+1;
            *ppstr++ = szDefWriExtension;
            nOldWrite = nCount;
            ++nCount;
        }
        else if (fDefFileType == SA_OLDWRITE)
            fDefFileType = SA_WRITE;
    }

#ifndef JAPAN                  // added  09 Jun. 1992  by Hiraisi
    /*
     *  The reason is as follows.
     *      We don't show the MS-WORD document at list files of type in OPEN
     *    DIALOG and SAVE (AS) DIALOG in Japan because the file format of
     *    MS-WORD(JPN) differs from that of WRITE.
     *      But I modified only this part, because it is easy to restore when
     *    we show the MS-WORD document at file type lists in those dialogs.
    */
    /* DOC */
    lstrcpy(lpStr, szDocDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, szDefDocExtension);
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = szDefDocExtension;
    nWord = nCount;
    ++nCount;

    /* DOC, Text only */
    if (iWhichOper == imiSaveAs)
    {
        lstrcpy(lpStr, szDocTxtDescr);
        lpStr += lstrlen(lpStr)+1;
        lstrcpy(lpStr, szWild);
        lstrcat(lpStr, szDefDocExtension);
        lpStr += lstrlen(lpStr)+1;
        *ppstr++ = szDefDocExtension;
        nWordText = nCount;
        ++nCount;
    }
#endif // !JAPAN

    /* Text only */
    lstrcpy(lpStr, szTxtDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, szDefTxtExtension);
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = szDefTxtExtension;
    nTextOnly = nCount;
    ++nCount;

    /* All files */
    lstrcpy(lpStr, szAllFilesDescr);
    lpStr += lstrlen(lpStr)+1;
    lstrcpy(lpStr, szWild);
    lstrcat(lpStr, "*");
    lpStr += lstrlen(lpStr)+1;
    *ppstr++ = NULL;
    ++nCount;

    *lpStr = 0;

    switch(fDefFileType)
    {
        case SA_WORDTEXT:
            OFN.nFilterIndex = nWordText;
        break;
        case SA_TEXTONLY:
            OFN.nFilterIndex = nTextOnly;
        break;
        case SA_WORD    :
            OFN.nFilterIndex = nWord;
        break;
        case SA_OLDWRITE:
            OFN.nFilterIndex = nOldWrite;
        break;
        case SA_WRITE   :
            OFN.nFilterIndex = 1;
        break;
    }
    OFN.lpstrDefExt  = szDefExtensions[OFN.nFilterIndex - 1];
}


DoOpenFilenameGet(LPSTR lpstrFilenameBuf)
/* returns whether filename retrieved */
{
    int nRetval;

    if (nRetval = DoCommDlg(imiOpen))
        lstrcpy(lpstrFilenameBuf,(LPSTR)szFileName);
        
    return nRetval;
}

DoSaveAsFilenameGet(LPSTR lpstrDefault,LPSTR lpstrFilenameBuf,int *fBackup,int *fTextOnly,int *fWordFmt,int *fOldWriteFmt)
/* Returns whether filename retrieved.  Returns filename.  If readonly is checked,
   returns if readonly is checked in fBackup.  Returns file type selected in fTextOonly and
   fWordFmt. */
{
    int nRetval;

    lstrcpy(szFileName,lpstrDefault);

    /* see MakeFilterSpec */
    if (*fTextOnly && *fWordFmt)
        fDefFileType = SA_WORDTEXT;
    else if (*fTextOnly)
        fDefFileType = SA_TEXTONLY;
    else if (*fWordFmt)
        fDefFileType = SA_WORD;
    else if (*fOldWriteFmt)
        fDefFileType = SA_OLDWRITE;
    else
        fDefFileType = SA_WRITE;

    /* check or uncheck backup prompt */
    OFN.Flags |= (*fBackup) ? OFN_READONLY : 0;

    if (nRetval = DoCommDlg(imiSaveAs))
    {
        lstrcpy(lpstrFilenameBuf,(LPSTR)szFileName);

        if (OFN.nFilterIndex == 1)
        {
            *fTextOnly    = *fWordFmt = FALSE;
            *fOldWriteFmt = FALSE;
        }
        else if (OFN.nFilterIndex == nOldWrite)
        {
            *fTextOnly    = *fWordFmt = FALSE;
            *fOldWriteFmt = TRUE;
        }
        else if (OFN.nFilterIndex == nWord)
        {
            *fTextOnly  = *fOldWriteFmt = FALSE;
            *fWordFmt   = TRUE;
        }
        else if (OFN.nFilterIndex == nWordText)
        {
            *fTextOnly    = *fWordFmt   = TRUE;
            *fOldWriteFmt = FALSE;
        }
        else if (OFN.nFilterIndex == nTextOnly)
        {
            *fTextOnly  = TRUE;
            *fWordFmt   = *fOldWriteFmt = FALSE;
        }

        *fBackup = OFN.Flags & OFN_READONLY;
    }

    return nRetval;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\curskeys.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* curskeys.c-- cursor key movement subroutines */
/* Oct 4, 1984, KJS */

#define NOGDICAPMASKS
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOATOM
#define NOSYSCOMMANDS
#define NOCOMM
#define NOSOUND
#define NOMENUS
#define NOGDI
#define NOPEN
#define NOBRUSH
#define NOFONT
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "debug.h"
#include "fmtdefs.h"
#include "printdef.h"

struct DOD          (**hpdocdod)[];
extern typeCP       cpMinCur;
extern typeCP       cpMacCur;
extern struct PAP   vpapAbs;
extern int          vfSeeSel;
extern int          vfShiftKey;
extern struct FLI   vfli;
extern struct SEL   selCur;
extern int          wwCur;
extern struct WWD   rgwwd[];
extern struct WWD   *pwwdCur;    /* Current window descriptor */
extern int          docCur;
extern typeCP       vcpSelect;
extern int          vfSelAtPara;
extern int          vfLastCursor;
extern int          vfMakeInsEnd;
extern CHAR         *vpchFetch;

int vfSeeEdgeSel=FALSE; /* Whether Idle() should show edge of selection
                           even if selection is partially visible */

     /* Absolute x-position to try to achieve on up-down motions;
        used in this module only */
int vxpCursor;




MoveLeftRight( kc )
int kc;
{    /* Move or drag selection in left or right directions */
extern int vfInsEnd;
typeCP CpEdge();

extern int vfGotoKeyMode;
extern int xpRightLim;
int fDrag = vfShiftKey ;
int fFwdKey = FALSE;
int fForward = selCur.fForward;
int sty;
typeCP cp;

MSG msg;

PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

vfGotoKeyMode |= (GetKeyState( kcGoto & ~wKcCommandMask) < 0);

switch( kc ) {
    int dl;
    int xp;
    int xpJunk;

    default:
        Assert( FALSE );
        return;
    case kcNextPara:
        fFwdKey = TRUE;
    case kcPrevPara:
        sty = styPara;
        break;
    case kcWordRight:
        fFwdKey = TRUE;
    case kcWordLeft:
        sty = styWord;
        break;
    case kcEndLine:
        if (vfGotoKeyMode)
            {
            MoveUpDown( kcEndDoc );
            return;
            }
        xp = xpRightLim;
        goto GoDlXp;

    case kcBeginLine:
        if (vfGotoKeyMode)
            {
            MoveUpDown( kcTopDoc );
            return;
            }
        xp = xpSelBar - wwdCurrentDoc.xpMin;
GoDlXp:

        if (CpBeginLine( &dl, CpEdge() ) == selCur.cpFirst &&
            selCur.cpFirst > cpMinCur && vfInsEnd )
            {
            CpBeginLine( &dl, selCur.cpFirst - 1);
            }
        vcpSelect = cpNil;
        vfSelAtPara = false;
        SelectDlXp( dl, xp, styChar, fDrag );
        goto SeeSel;
    case kcRight:
        fFwdKey = TRUE;
    case kcLeft:
        sty = (vfGotoKeyMode) ? stySent : styChar;
        break;
 }

    /* Find cp to start extension from */
if (selCur.cpLim == selCur.cpFirst || fDrag)
       cp = fForward ? selCur.cpLim : selCur.cpFirst;
else
       cp = fFwdKey ? selCur.cpLim - 1 : selCur.cpFirst + 1;

/* Catch attempts to run off the document start or end */

if (fFwdKey)
    {
    if (cp == cpMacCur)
        {
        _beep();
        return;
        }
    }
else if (cp == cpMinCur)
    {
    _beep();
    return;
    }

if (fFwdKey)
    {
    if (cp >= cpMacCur)
            /* If at end, stay at end.  */
        cp = cpMacCur;
    else
        {
        cp = CpLimSty( cp, sty );
        }
    }
 else
    {
    if (cp > cpMinCur)
            /* So we go back to the PREVIOUS sty unit */
        cp--;
    cp = CpFirstSty( cp, sty );
    }

if (fDrag)
        { /* Drag selection edge to new bound. */
/* If selection flips, keep one sty unit selected EXCEPT if it's styChar;
   when dragging by char, the selection can become an insertion point */

        ChangeSel( cp, sty == styChar ? styNil : sty );
        }
else
        {
        Select(cp, cp);
        if (!fFwdKey)
                selCur.fForward = false;
        }

SeeSel:

vfSeeSel = true;    /* Tell Idle to scroll the selection into view */
vfSeeEdgeSel = true;  /* And the edge of it even if it's already partly visible */
return;
}




/* M O V E  U P  D O W N */
MoveUpDown(kc)
int kc;
{ /* Move the selection in direction of kc, in up or down directions */

  /* Our goal with up-and-down motions is to keep (if applicable) an */
  /* absolute x-position to which the cursor tends to go if there is */
  /* text on the line at that position.  We set this position (vxpCursor) */
  /* when we process the first up/down key, and hang onto it thereafter */
  /* A global flag, vfLastCursor, tells us whether we should use the */
  /* last calculated setting of vxpCursor or generate a new one.  vxpCursor */
  /* is set below and cleared in Select() and AlphaMode() */

extern int vfGotoKeyMode;
int fDrag = vfShiftKey;
int dl;
typeCP cpT;
struct EDL (**hdndl)[] = wwdCurrentDoc.hdndl;
register struct EDL *pedl;
int dipgd;
int xpNow;

MSG msg;

PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

vfGotoKeyMode |= (GetKeyState( kcGoto & ~wKcCommandMask) < 0);

 /* Compute dl, vxpCursor for selection starting point */

 switch (kc)
    {
    default:
        Assert( FALSE );
        break;
    case kcUp:
        if (vfGotoKeyMode)
            {   /* GOTO-UP is Prev Para */
            MoveLeftRight( kcPrevPara );
            return;
            }
    case kcPageUp:
    case kcUpScrollLock:
    case kcTopScreen:
    case kcTopDoc:
        cpT = selCur.fForward && fDrag ? selCur.cpLim : selCur.cpFirst;
        break;
    case kcDown:
        if (vfGotoKeyMode)
            {   /* GOTO-DOWN is Next Para */
            MoveLeftRight( kcNextPara );
            return;
            }
    case kcPageDown:
    case kcDownScrollLock:
    case kcEndScreen:
    case kcEndDoc:
        cpT = selCur.fForward || !fDrag ? selCur.cpLim : selCur.cpFirst;
        break;
    }

 CpToDlXp( cpT, &dl, (vfLastCursor) ? &xpNow : &vxpCursor );


 /* HACK: If the guy is dragging up/down and is on the first/last line of
    the doc but not right at the start/end of the doc, extend him to
    the start/end of the doc */

 if (fDrag && !vfGotoKeyMode)
    {
    switch (kc) {
       case kcUp:
 /* Special fix for dragging upward: if we are seeking up to a position
    that is equivalent in cp space to where we are now, force a decrement
    of the source dl so we really go up a line */

        if (vfLastCursor && xpNow <= xpSelBar && vxpCursor > xpSelBar &&
                                                 cpT > cpMinCur)
            {
            CpToDlXp( CpFirstSty( cpT - 1, styChar), &dl, &xpNow );
            }
       case kcPageUp:
       case kcUpScrollLock:
            if (wwdCurrentDoc.cpFirst == cpMinCur && cpT > cpMinCur)
                if (dl == 0 || kc == kcPageUp)
                    {
                    MoveUpDown( kcTopDoc );
                    return;
                    }
            break;
        case kcPageDown:
        case kcDown:
        case kcDownScrollLock:
            {
            typeCP cpLimDl;

            pedl = &(**hdndl) [dl];
            cpLimDl = pedl->cpMin + pedl->dcpMac;
            if (cpLimDl >= cpMacCur && cpT >= pedl->cpMin && cpT < cpMacCur)
                {
                MoveUpDown( kcEndDoc );
                return;
                }
            break;
            }
        }
    }

 /* Do the cursor movement, scrolling if necessary */
 switch (kc)
    {
    case kcPageUp:
        if (vfGotoKeyMode)
            {   /* Go to previous printed page */
            extern int vipgd;
            extern int rgval[];
            struct PGTB **hpgtb;
            int ipgd;

            dipgd = -1;

            CachePage( docCur, selCur.cpFirst );
            if (vipgd != iNil)
                {
                hpgtb = (**hpdocdod) [docCur].hpgtb;
                if ((**hpgtb).rgpgd [vipgd].cpMin != selCur.cpFirst)
                        /* Not at page start; go there first */
                    dipgd++;
                }

GoPage:     CachePage( docCur, selCur.cpFirst ); /*validate vipgd*/
            hpgtb = (**hpdocdod)[docCur].hpgtb;
            if ((vipgd == iNil) ||
                ((ipgd = vipgd + dipgd) < 0) ||
                (ipgd >= (**hpgtb).cpgd))
                {   /*Whole doc on one page || run off either end*/
                _beep();
                }
            else
                {
                rgval [0] = (**hpgtb).rgpgd[ipgd].pgn;
                CmdJumpPage();  /* rgval [0] is a parm to CmdJumpPage */
                }
            return;
            }
        ScrollUpDypWw();
        break;
    case kcPageDown:
        if (vfGotoKeyMode)
            {   /* Go to next printed page */
            dipgd = 1;
            goto GoPage;
            }

        /* Special case for extending selection one page down from the
           top line of the ww -- extend to the NEXT line so we don't
           end up without any part of the selection on the screen */

        ScrollDownCtr( 100 );   /* 100 > tr's in a page */
        vcpSelect = cpNil;
        vfSelAtPara = false;
        SelectDlXp( dl, (**hdndl)[dl].fGraphics ? 0 : vxpCursor, styChar, fDrag );
        if (fDrag && (dl == 0) && selCur.cpLim == wwdCurrentDoc.cpFirst)
            {
            MoveUpDown( kcDown );
            }
        goto DontSelect;

    case kcUpScrollLock:
    case kcUp:
        UpdateWw(wwCur, false);

        pedl = &(**hdndl) [dl];

        if ( fDrag && (selCur.fForward ? selCur.cpLim : selCur.cpFirst) ==
                                     pedl->cpMin && pedl->cpMin > cpMinCur)
            {   /* Up into picture == left */
            CachePara( docCur, pedl->cpMin - 1 );
            if (vpapAbs.fGraphics)
                {
                MoveLeftRight( kcLeft );
                return;
                }
            }

        if ((pedl->cpMin == cpMinCur) && (pedl->ichCpMin == 0))
            {       /* At beginning of doc or area */
            int xpT;

            _beep();
            CpToDlXp(cpMinCur, &dl, &xpT);
            goto DoSelect;
            }
        else if ( (dl == 0) || (kc == kcUpScrollLock) )
            {    /* At top of screen OR keep posn */
            ScrollUpCtr( 1 );
            UpdateWw(wwCur, false);
            }
        else
            {
            --dl;
            }
        break;

    case kcDownScrollLock:
    case kcDown:
        UpdateWw(wwCur, false);
        pedl = &(**hdndl)[dl];
        {
        int xpT;
        typeCP cp;

        cp = pedl->cpMin + pedl->dcpMac;

        if (selCur.cpFirst < selCur.cpLim && selCur.fForward &&
            pedl->cpMin == selCur.cpLim &&
            cp < cpMacCur &&
            (!fDrag ||
               ((vxpCursor > pedl->xpLeft + xpSelBar) &&
                (pedl->dcpMac > ccpEol))))
            {   /* In this case, it thinks we are at the start of the
                   next line; incrementing/scrolling is unnecessary */
            goto DoSelect;
            }

        if (pedl->fGraphics)
            {   /* Special for pictures */
            MoveLeftRight( kcRight );

            if (!fDrag)
                {
                extern struct PAP vpapAbs;

                CachePara( docCur, selCur.cpFirst );
                if (vpapAbs.fGraphics)
                    {
                    vfShiftKey = TRUE;
                    MoveLeftRight( kcRight );
                    SetShiftFlags();
                    }
                }
            goto DontSelect;
            }

        if (cp > cpMacCur)
            {
            if (selCur.cpLim == selCur.cpFirst || selCur.cpLim == cpMacCur)
                    /* test is because CpToDlXp cannot account for
                       selection extending to end of next-to-last line */
                _beep();
            CpToDlXp(cpMacCur, &dl, &xpT);
            goto DoSelect;
            }
        if ( (dl >= wwdCurrentDoc.dlMac - 2) || (kc == kcDownScrollLock) )
            {   /* within one line of window end */
            ScrollDownCtr( 1 );
            UpdateWw(wwCur, false);
            }
        else
            dl++;
        }
        break;

    case kcTopScreen:
        dl = 0;
        break;
    case kcEndScreen:
        dl = wwdCurrentDoc.dlMac - 1;
        if ( dl > 0 && (**wwdCurrentDoc.hdndl) [dl].yp >= wwdCurrentDoc.ypMac)
            {   /* Back up if last (and not only) dl is partially clipped */
            dl--;
            }
        break;
    case kcTopDoc:
        CpToDlXp(cpMinCur, &dl, &vxpCursor);
        break;
    case kcEndDoc:
        CpToDlXp(cpMacCur, &dl, &vxpCursor);
        break;

    default:
        return;
    }

DoSelect:              /* select at/to position vxpCursor on line dl */
 vcpSelect = cpNil;
 vfSelAtPara = false;
 SelectDlXp( dl, (**hdndl)[dl].fGraphics ? 0 : vxpCursor, styChar, fDrag );
DontSelect:
 vfLastCursor = true;    /* don't recalc vxpCursor next time */
}




/* C P  T O  D L  X P */
CpToDlXp(cp, pdl, pxp)
typeCP cp;
int *pdl, *pxp;
{ /* Transform cp into cursor coordinates */
extern int vfInsEnd;
typeCP cpBegin;
int dcp;
int xp;

 if (!vfInsEnd)
    PutCpInWwHz(cp);

 cpBegin = CpBeginLine(pdl, cp);
 ClearInsertLine();
 if ( (cp == selCur.cpFirst) && (cp == selCur.cpLim) && vfInsEnd &&
      cp > cpMinCur)
    {   /* cp indicates we are at line beginning, but we are really
           kludged at the end of the previous line */
    CpToDlXp( cp - 1, pdl, pxp );
    PutCpInWwHz( cp - 1 );
    return;
    }

 dcp = (int) (cp - cpBegin);
 FormatLine(docCur, cpBegin, 0, cpMacCur, flmSandMode);
 xp = DxpDiff(0, dcp, &xp) + vfli.xpLeft;
 *pxp = xp + (xpSelBar - wwdCurrentDoc.xpMin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\debug.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef DEBUG

#ifdef SCRIBBLE
#define Scribble(a, b) fnScribble(a, b)
#else /* not SCRIBBLE */
#define Scribble(a, b)
#endif /* not SCRIBBLE */

#else /* not DEBUG */
#define Scribble(a, b)
#endif /* not DEBUG */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\debug.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* DEBUG.C -- Diagnostic routines for WRITE */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOATOM
#define NODRAWTEXT
#define NOMETAFILE
#define NOOPENFILE
#define NOWH
#define NOWINOFFSETS
#define NOOPENFILE
#define NORECT
#define NOSOUND
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "prmdefs.h"
#include "editdefs.h"
#include "docdefs.h"

extern struct WWD rgwwd[];


extern beep();
extern toggleProf();

#ifdef DEBUG

BOOL fDebugOut = TRUE;

fnTest()
{
beep();
TestFormat();
beep();
beep();
dbgWait();      /* for use by symdeb to check variables */
}

TestFormat()
{
     //toggleProf();
}

dbgWait()
{
}


/* --- Integrity check for all piece tables in all docs --- */

CheckPctb()
{
extern int fnMac;
extern int fPctbCheck;
extern struct DOD (**hpdocdod) [];
extern struct FCB (**hpfnfcb) [];
extern int docMac;
int doc;
struct PCTB **hpctb;
struct PCTB *ppctb;
struct DOD *pdod;
struct PCD *ppcd;
int ipcd;

if (!fPctbCheck)
    return;

for ( doc = 0, pdod = &(**hpdocdod) [0] ; doc < docMac; doc++, pdod++ )
    if ((hpctb = pdod->hpctb) != 0)
        {   /* Doc entry is nonempty -- check it */
        ppctb = *hpctb;

            /* # pieces used does not exceed # allocated */
        Assert( ppctb->ipcdMac <= ppctb->ipcdMax );
        Assert( ppctb->ipcdMac >= 1 );

#ifndef OURHEAP
            /* handle contains enough space for pieces */
        Assert( LocalSize( (HANDLE)hpctb ) >= sizeof (struct PCTB)  +
                (sizeof (struct PCD) * (ppctb->ipcdMax - cpcdInit)));
#endif

        /* Now check the contents of the pieces */

        {

            /* cpMin of first piece is always 0 for nonnull piece table */
        Assert( ppctb->rgpcd [0].cpMin == cp0 || ppctb->rgpcd [0].fn == fnNil);

        for ( ipcd = 0, ppcd = &(ppctb->rgpcd [0]); ipcd < ppctb->ipcdMac;
              ipcd++, ppcd++ )
            {
            int fn = ppcd->fn;
            typeFC fc = ppcd->fc;
            unsigned sprm;
            struct FCB *pfcb;

            if (fn == fnNil)
                {   /* end piece */

                    /* first piece with fnNil is in fact the end piece */
                /* Assert( ipcd == ppctb->ipcdMac - 1 ); */
                    /* end piece is intact */
                Assert( bPRMNIL(ppcd->prm) );
                break;
                }

            if (ipcd > 0)
                    /* Pieces are in ascending cp order */
                Assert(ppcd->cpMin > (ppcd-1)->cpMin);

                /* fn is valid */
            Assert( (fn >= 0 && fn < fnMac) || fn == fnInsert );
            pfcb = &(**hpfnfcb) [fn];
                /* fn does not point to an unallocated fcb entry */
            Assert( pfcb->rfn != rfnFree );
                /* fc is reasonable for the fn */
            Assert( fc >= 0 );
            Assert( fc + (ppcd+1)->cpMin - ppcd->cpMin <= pfcb->fcMac );

                /* prm is a valid value */
            Assert( bPRMNIL(ppcd->prm) ||
                    (((struct PRM *) &ppcd->prm)->fComplex) ||
                    ((sprm = ((struct PRM *) &ppcd->prm)->sprm) > 0 &&
                    sprm < sprmMax) );
            }
        }

        }
}



/*      COMM Output routines        */

#define cchSzCommMax    100

static CHAR szCRLF[] = "\r\n";
BOOL vfCommDebug = fTrue;       /* True for AUX, False for LPT */

#if WINVER < 0x300
/* This method isn't quite working under Win 3.0 ..pault */
void CommSz( CHAR * );          /* Main string output, defined in doslib.asm */
#else
void CommSz( psz )
register CHAR *psz;
{
    CHAR szT[512];
    char *pszT;

    if (fDebugOut)
        {
        /* The following loops essentially copies psz to szT
           but with the addition that chars > 127 are changed 
           to a representation readable on a dumb terminal, i.e.
           ASCII 164 shows up as '{164}' ..pault */

        for (pszT = szT; ; psz++)
            {
            if (*psz < 128)
                *(pszT++) = *psz;
            else
                {
                *(pszT++) = '{';
                ncvtu((int) *psz, &pszT);
                *(pszT++) = '}';
                }
            if (*psz == '\0')   /* finally copied null terminator */
                break;
            }

        OutputDebugString( (LPSTR) szT );
        }
}
#endif


CommSzNum( sz, num )
CHAR *sz;
int num;
{
CHAR szBuf[ cchSzCommMax ];
CHAR *pch = szBuf;

Assert( CchSz( sz ) <= cchSzCommMax );

pch = &szBuf[ CchCopySz( sz, szBuf ) ];
ncvtu( num, &pch );

CchCopySz( szCRLF, pch );

CommSz( szBuf );
}


/* This is extremely useful when displaying coordinates 
   when the values are not in contiguous locations */
CommSzNumNum( sz, num, num2 )
CHAR *sz;
int num, num2;
{
CHAR szBuf[ cchSzCommMax ];
CHAR *pch = szBuf;

Assert( CchSz( sz ) <= cchSzCommMax );

pch = &szBuf[ CchCopySz( sz, szBuf ) ];
ncvtu( num, &pch );
*(pch++) = ' ';
ncvtu( num2, &pch );

CchCopySz( szCRLF, pch );

CommSz( szBuf );
}


CommSzRgNum( sz, rgw, cw)
CHAR *sz;
int *rgw;
int cw;
{
CHAR szBuf[ cchSzCommMax ];
CHAR *pch = szBuf;

Assert( CchSz( sz ) <= cchSzCommMax );

pch = &szBuf[ CchCopySz( sz, szBuf ) ];
for ( ; cw > 0; cw--)
    {
    ncvtu( *(rgw++), &pch );
    *(pch++) = ' ';
    }

CchCopySz( szCRLF, pch );

CommSz( szBuf );
}


CommSzSz( sz1, sz2 )
CHAR *sz1, *sz2;
{
CHAR szBuf[ cchSzCommMax ];
int cch;

Assert( CchSz( sz1 ) + CchSz( sz2 ) - 1 <= cchSzCommMax );

cch = CchCopySz( sz1, szBuf );
cch += CchCopySz( sz2, &szBuf[ cch ] );
CchCopySz( szCRLF, &szBuf[ cch ] );

CommSz( szBuf );
}



/* ASSERT */

Do_Assert(pch, line, f)
PCH pch;
int line;
BOOL f;
{
 extern HWND    vhWndMsgBoxParent;
 extern FARPROC lpDialogAlert;
 static CHAR szAssert[] = "Assertion failure in ";
 static CHAR szLine[] = " at line ";


if (f)
     return;
 else
    {
#ifdef OURHEAP
    extern int cHpFreeze;
    int cHpFreezeT = cHpFreeze;
#endif
    CHAR szAlertMsg[50];
    PCH pchtmp;
    int  cch;
    int  idi;
    HWND hWndParent = (vhWndMsgBoxParent == NULL) ?
                               wwdCurrentDoc.wwptr : vhWndMsgBoxParent;

    bltbc((PCH)szAlertMsg, 0, 50);
    bltbyte((PCH)szAssert, (PCH)szAlertMsg, 21);
    pchtmp = (PCH)&szAlertMsg[21];
    bltbyte((PCH)pch, pchtmp, (cch = CchSz(pch) - 1));
    pchtmp += cch;
    bltbyte((PCH)szLine, pchtmp, 9);
    pchtmp += 9;
    ncvtu(line, (PCH)&pchtmp) - 1;
#ifdef OURHEAP
    cHpFreeze = 0;  /* So we don't panic in MdocLoseFocus */
#endif

    do
        {
        idi = MessageBox( hWndParent, (LPSTR) szAlertMsg,
                          (LPSTR)"Assert",
                          MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);
        switch (idi) {
            default:
            case IDABORT:
            case IDCANCEL:
                FatalExit( line );
                break;

            case IDIGNORE:
#ifdef OURHEAP
                cHpFreeze = cHpFreezeT;
#endif
                return;
            case IDRETRY:
                break;
            }
        }  while (idi == IDRETRY);
    }   /* end else */
} /* end of _Assert */


ShowDocPcd(szID, doc)
    CHAR    *szID;
    int     doc;
{
    struct PCTB **hpctb;
    struct PCD  *ppcdCur, *ppcdMac;
    extern struct DOD (**hpdocdod)[];

    hpctb = (**hpdocdod)[doc].hpctb;
    ppcdCur = &(**hpctb).rgpcd[0];
    ppcdMac = &(**hpctb).rgpcd[(**hpctb).ipcdMac];
    for (; ppcdCur < ppcdMac; ppcdCur++)
        {
        ShowPpcd(szID, ppcdCur);
        }
}


ShowPpcd(szID, ppcd)
    CHAR        *szID;
    struct PCD  *ppcd;
{
    /* Dump a given piece descriptor on COM1: along with a
       given an ID string.  */
    CommSz(szID);
    CommSz("\r\n");

    CommSzNum("ppcd: ", (int) ppcd);
    CommSzNum("cpMin: ", (int) (ppcd->cpMin));
    CommSzSz("fNoParaLast: ", (ppcd->fNoParaLast) ? "TRUE" : "FALSE");
    CommSzNum("fn: ", (int) (ppcd->fn));
    CommSzNum("fc: ", (int) (ppcd->fc));
    CommSzNum("prm: ", (int) *((int *) &(ppcd->prm)));
}



#endif      /* DEBUG */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\diaalert.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOSCALABLEFONT
#define NOSYSPARAMSINFO
#define NODBCS
#define NODRIVERS
#define NODEFERWINDOWPOS
#define NOPROFILER
#define NOHELP
#define NOKEYSTATES
#define NOWINMESSAGES
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCOMM
#define NODRAWTEXT
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#define NOBITMAP
#define NOKEYSTATE
#define NOMENUS
#define NOMETAFILE
#define NOPEN
#define NOOPENFILE
#define NORASTEROPS
#define NORECT
#define NOSCROLL
#define NOSHOWWINDOW
#define NOSOUND
#define NOSYSCOMMANDS
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOVIRTUALKEYCODES
#define NOWH
#define NOWINOFFSETS
#define NOWINSTYLES
#define NOUAC
#define NOIDISAVEPRINT
#define NOSTRUNDO
#define NOCTLMGR
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "code.h"
#include "debug.h"
#include "dlgdefs.h"
#include "str.h"
#include "propdefs.h"
#include "wwdefs.h"

extern struct WWD   rgwwd[];
extern int             utCur;
extern int             vfInitializing;
extern CHAR            szAppName[];
extern struct FCB      (**hpfnfcb)[];
extern struct BPS      *mpibpbps;
extern int             ibpMax;
extern typeTS          tsMruBps;
extern int             vfSysFull;
extern int             ferror;
extern int             vfnWriting;
extern int             vibpWriting;
extern HANDLE          hMmwModInstance;
extern HWND            vhWndMsgBoxParent;
extern int             vfMemMsgReported;
extern int             vfDeactByOtherApp;
extern MSG             vmsgLast;
extern HWND            vhDlgFind;
extern HWND            vhDlgChange;
extern HWND            vhDlgRunningHead;
extern HANDLE          hParentWw;


#ifdef JAPAN //01/21/93
extern BOOL			   FontChangeDBCS;
HANDLE hszNoMemorySel = NULL;
#endif
HANDLE hszNoMemory = NULL;
HANDLE hszDirtyDoc = NULL;
HANDLE hszCantPrint = NULL;
HANDLE hszPRFAIL = NULL;
HANDLE hszCantRunM = NULL;
HANDLE hszCantRunF = NULL;
HANDLE hszWinFailure = NULL;
BOOL vfWinFailure = FALSE;
#ifdef INEFFLOCKDOWN
FARPROC lpDialogBadMargins;
#endif

#define FInModeless(hWnd) (hWnd == vhDlgFind || hWnd == vhDlgChange || \
 hWnd == vhDlgRunningHead)

CHAR *PchFillPchId( CHAR *, int, int );
NEAR WaitBeforePostMsg(int);

#ifdef CANCELMSG    /* During debug, permit an abort for stack traces */
#define MB_MESSAGE        (MB_OKCANCEL | MB_APPLMODAL | MB_ICONASTERISK)
#define MB_ERROR          (MB_OKCANCEL | MB_APPLMODAL | MB_ICONEXCLAMATION)
#define MB_TROUBLE        (MB_OKCANCEL | MB_APPLMODAL | MB_ICONHAND)
#else
#define MB_MESSAGE        (MB_OK | MB_APPLMODAL | MB_ICONASTERISK)
#define MB_ERROR          (MB_OK | MB_APPLMODAL | MB_ICONEXCLAMATION)
#define MB_TROUBLE        (MB_OK | MB_APPLMODAL | MB_ICONHAND)
#endif
#define MB_DEFYESQUESTION (MB_YESNOCANCEL | MB_APPLMODAL | MB_ICONHAND)
#define MB_DEFNOQUESTION  (MB_YESNOCANCEL | MB_DEFBUTTON2 | MB_APPLMODAL | MB_ICONHAND)


ErrorLevel(IDPMT idpmt)
{

/* A long story.  But to fix Winbug #1097, we need to take special
   exception for this error message -- when this is displayed in a
   low mem situation, this must be system modal (match params used
   in FRenderAll() ...pault */
if (idpmt == IDPMTClipLarge)
    return(MB_OK | MB_SYSTEMMODAL | MB_ICONHAND);

else
    switch (idpmt & MB_ERRMASK)
    {
    case MB_ERRASTR:             /*  *  level  */
        return(MB_MESSAGE);
    case MB_ERREXCL:             /*  !  level  */
        return(MB_ERROR);
    case MB_ERRQUES:             /*  ?  level  */
        return(MB_DEFYESQUESTION);
    case MB_ERRHAND:             /*  HAND  level  */
        return(MB_TROUBLE);
    default:
        Assert(FALSE);
    }
}


int far Abort(response)
int response;
{
        for( ; ; );
}

#ifdef DEBUG
ErrorWithMsg(IDPMT idpmt, CHAR *szMessage)
{
#ifdef REALDEBUG
        extern int vfOutOfMemory;
        CHAR szBuf[cchMaxSz];
        int errlevel = ErrorLevel(idpmt);
        BOOL fDisableParent = FALSE;
        register HWND hWndParent = (vhWndMsgBoxParent == NULL) ?
          hParentWw : vhWndMsgBoxParent;

        Assert(IsWindow(hWndParent));

        if (idpmt == IDPMTNoMemory)
            {
            vfOutOfMemory = TRUE;
            if (vfMemMsgReported)
                {
                return;
                }
            vfMemMsgReported = TRUE;
            }
        if (ferror)
            return;

        ferror = TRUE;

        if (vfInitializing)
            return;

        CchCopySz( szMessage, PchFillPchId( szBuf, idpmt, sizeof(szBuf) ) );
        if (vfDeactByOtherApp && !InSendMessage())
            WaitBeforePostMsg(errlevel);

/* force user to answer the error msg */
        if (hWndParent != NULL && FInModeless(hWndParent))
            {
            EnableExcept(hWndParent, FALSE);
            }
        else
            {
            if (hWndParent != NULL && !IsWindowEnabled(hWndParent))
                {
                EnableWindow(hWndParent, TRUE);
                fDisableParent = TRUE;
                }
            EnableOtherModeless(FALSE);
            }

        if (MessageBox(hWndParent, (LPSTR)szBuf,
                       (LPSTR)NULL, errlevel) == IDCANCEL)
                /* A debugging feature -- show stack trace if he hit "cancel" */
            FatalExit( 0 );

        if (hWndParent != NULL && FInModeless(hWndParent))
            {
            EnableExcept(hWndParent, TRUE);
            }
        else
            {
            if (fDisableParent)
                {
                EnableWindow(hWndParent, FALSE);
                }
            EnableOtherModeless(TRUE);
            }
#else
 Error( idpmt );
#endif
}
#endif /* DEBUG */

void Error(IDPMT idpmt)
{
 extern int vfOutOfMemory;
 CHAR szBuf [cchMaxSz];
 HANDLE hMsg;
 LPCH lpch;
 static int nRecurse=0;
 int errlevel = ErrorLevel(idpmt);
 register HWND hWndParent = (vhWndMsgBoxParent == NULL) ? hParentWw :
                                                          vhWndMsgBoxParent;

 if (nRecurse)
    return;

 ++nRecurse;

 Assert((hWndParent == NULL) || IsWindow(hWndParent));

 if (idpmt == IDPMTNoMemory)
    {
    vfOutOfMemory = TRUE;
    if (vfMemMsgReported)
        {
        goto end;
        }
    vfMemMsgReported = TRUE;
    }

 if (!ferror && !vfInitializing)
    {
    CloseEveryRfn( FALSE );
    switch (idpmt)
        {
    case IDPMTNoMemory:
#ifdef JAPAN //01/21/93
		if(FontChangeDBCS)
	        hMsg = hszNoMemorySel;
		else
    	    hMsg = hszNoMemory;
#else
        hMsg = hszNoMemory;
#endif
GetMsg:
        if (hMsg == NULL || (lpch = GlobalLock(hMsg)) == NULL)
            {
            goto end;
            }
        bltbx(lpch, (LPCH)szBuf, LOWORD(GlobalSize(hMsg)));
        GlobalUnlock(hMsg);
        break;
    case IDPMTCantPrint:
        hMsg = hszCantPrint;
        goto GetMsg;
    case IDPMTPRFAIL:
        hMsg = hszPRFAIL;
        goto GetMsg;
    case IDPMTCantRunM:
        hMsg = hszCantRunM;
        goto GetMsg;
    case IDPMTCantRunF:
        hMsg = hszCantRunF;
        goto GetMsg;
    case IDPMTWinFailure:
        hMsg = hszWinFailure;
        goto GetMsg;
    default:
        PchFillPchId( szBuf, idpmt, sizeof(szBuf) );
        break;
        }
    if (vfDeactByOtherApp && !InSendMessage())
        {
        WaitBeforePostMsg(errlevel);
        }

#ifdef CANCELMSG
    if (IdPromptBoxSz( hWndParent, szBuf, errlevel ) == IDCANCEL)
        {
        /* A debugging feature -- show stack trace if he hit "cancel" */
        FatalExit( 100 );
        }
#else
    IdPromptBoxSz( hWndParent, szBuf, errlevel );
#endif
    }

 if (errlevel != MB_MESSAGE)
    {
    ferror = TRUE;
    }

    end:
    --nRecurse;
}
/* end of  E r r o r  */


IdPromptBoxSz( hWndParent, sz, mb )
HWND hWndParent;
CHAR sz[];
int mb;
{   /* Put up a message box with string sz. mb specifies buttons to display,
       "level" of message (HAND, EXCL, etc.).
       hWndParent is the parent of the message box.
       Returns the id of the button selected by the user */

 int id;
 BOOL fDisableParent = FALSE;
 extern int  wwMac;
 int  wwMacSave=wwMac;

 Assert((hWndParent == NULL) || IsWindow(hWndParent));

 if ((mb == MB_ERROR) || (mb == MB_TROUBLE))
    {
    extern int ferror;
    extern int vfInitializing;

    if (ferror)
        return;
    ferror = TRUE;
    if (vfInitializing)
        return;
    }

 CloseEveryRfn( FALSE );    /* Protect against disk swap while in message box */

 /* don't allow painting doc, it may be in an unpaintable state (5.8.91) v-dougk */
 if (mb == MB_TROUBLE)
    wwMac=0;

 /* force user to answer the msg */
 if (hWndParent != NULL && FInModeless(hWndParent))
    {
    EnableExcept(hWndParent, FALSE);
    }
 else
    {
    if (hWndParent != NULL && !IsWindowEnabled(hWndParent))
        {
        EnableWindow(hWndParent, TRUE);
        fDisableParent = TRUE;
        }
    EnableOtherModeless(FALSE);
    }

 /* We almost ALWAYS want the parent window to be passed to MessageBox
    except in a couple RARE cases where even Write's main text window
    hasn't yet gotten displayed.  In that case we'll rip out of Windows
    if we DO tell MessageBox about it... so NULL is the prescribed hwnd
    to pass ..pault */

 id = MessageBox((hWndParent == hParentWw && !IsWindowVisible(hWndParent)) ?
                  NULL : hWndParent, (LPSTR)sz, (LPSTR)szAppName, mb);

 if (hWndParent != NULL && FInModeless(hWndParent))
    {
    EnableExcept(hWndParent, TRUE);
    }
 else
    {
    if (fDisableParent)
        {
        EnableWindow(hWndParent, FALSE);
        }
    EnableOtherModeless(TRUE);
    }

 wwMac = wwMacSave;
 return id;
}




WinFailure()
{
    /* Windows has run out of memory.  All we can do is discard all of our
    Windows objects and pray the problem goes away.  At the very worst, the
    might be stuck with a saved document and unable to edit. */
    /* FM 9/4/87 - Take out the call to FreeMemoryDC, hopefully to allow
       Write to continue formatting lines. */

    extern int vfOutOfMemory;

    vfOutOfMemory = TRUE;
    if (!vfWinFailure)
        {
        Error(IDPMTWinFailure);
        vfWinFailure = TRUE;
        }
}


#ifdef DEBUG
DiskErrorWithMsg(idpmt, szMessage)
IDPMT idpmt;
CHAR  *szMessage;
#else
DiskError(idpmt)
IDPMT idpmt;
#endif
{ /* Description:  Given an error message descriptor,
                   outputs an Alert Box. If the message indicates a serious disk
                   error, all files are closed and a flag set so that
                   the user will be restricted to the "Save" option only.
     Returns:      nothing
  */
 extern HWND hParentWw;
 extern int vfDiskError;
 extern int vfInitializing;
 int errlevel = ErrorLevel( idpmt );
 CHAR rgch[cchMaxSz];
 CHAR *pch, *PchFillPchId();
 register HWND hWndParent = (vhWndMsgBoxParent == NULL) ? hParentWw : vhWndMsgBoxParent;

 Assert( (hWndParent == NULL) || IsWindow(hWndParent));

 if (idpmt == IDPMTSDE || idpmt == IDPMTSDE2)
        /* Serious disk error, put the guy in "SAVE-ONLY" state */
    if (!vfDiskError)
        {
        vfDiskError = TRUE;
        CloseEveryRfn( TRUE );
        }

 if (ferror || vfInitializing)
        /* Only report one error per operation */
        /* Don't report errors during inz; FInitWinInfo handles them */
    return;

 CloseEveryRfn( FALSE );    /* Close floppy files so the guy can change
                               disks while in the message box. */
 pch = PchFillPchId( rgch, idpmt, sizeof(rgch) );

#ifdef REALDEBUG    /* Only enable extra message if really debugging */
 CchCopySz( szMessage, pch );
#endif
 if (vfDeactByOtherApp && !InSendMessage())
     WaitBeforePostMsg(errlevel);

#ifdef CANCELMSG
 if (IdPromptBoxSz( hWndParent, rgch, errlevel ) == IDCANCEL)
        /* A debugging feature -- show stack trace if he hit "cancel" */
    FatalExit( 0 );
#else
 IdPromptBoxSz( hWndParent, rgch, errlevel );
#endif
 ferror = TRUE;
}
/* end of  D i s k E r r o r  */


ErrorBadMargins(hWnd, xaLeft, xaRight, yaTop, yaBottom)
HWND hWnd;
unsigned xaLeft;
unsigned xaRight;
unsigned yaTop;
unsigned yaBottom;
    {
    /* Warn the user that the margins for this page must be xaLeft, xaRight,
    yaTop, and yaBottom. */

    extern CHAR *vpDlgBuf;
    extern HANDLE hMmwModInstance;
    extern int vfDeactByOtherApp;

    unsigned rgzaMargin[4];
#ifndef INEFFLOCKDOWN
    extern BOOL far PASCAL DialogBadMargins(HWND, unsigned, WORD, LONG);
    FARPROC lpDialogBadMargins;

    if (!(lpDialogBadMargins = MakeProcInstance(DialogBadMargins, hMmwModInstance)))
        {
        WinFailure();
        return;
        }
#endif

    /* These values are kept on the stact to cut down on static variables. */
    rgzaMargin[0] = xaLeft;
    rgzaMargin[1] = xaRight;
    rgzaMargin[2] = yaTop;
    rgzaMargin[3] = yaBottom;
    vpDlgBuf = (CHAR *)&rgzaMargin[0];

    if (vfDeactByOtherApp && !InSendMessage())
        WaitBeforePostMsg(MB_ERROR);

    /* Create the "error" dialog box. */
    DialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgBadMargins), hWnd,
      lpDialogBadMargins);

#ifndef INEFFLOCKDOWN
    FreeProcInstance(lpDialogBadMargins);
#endif
    }


BOOL far PASCAL DialogBadMargins(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles the messages for the Bad Margins dialog box. */

    extern CHAR *vpDlgBuf;
    extern HWND vhWndMsgBoxParent;

    int idi;
    unsigned *prgzaMargin = (unsigned *)vpDlgBuf;

    switch (message)
    {
    case WM_INITDIALOG:
    /* Disable modeless dialog boxes. */
    EnableOtherModeless(FALSE);

    /* Set the values of the margins on the dialog box. */
    for (idi = idiBMrgLeft; idi <= idiBMrgBottom; idi++, prgzaMargin++)
        {
        CHAR szT[cchMaxNum];
        CHAR *pch = &szT[0];

        CchExpZa(&pch, *prgzaMargin, utCur, cchMaxNum);
        SetDlgItemText(hDlg, idi, (LPSTR)szT);
        }
    return (TRUE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
    if (wParam == idiOk)
        {
        /* Destroy the tabs dialog box and enable any existing modeless
        dialog boxes.*/
        OurEndDialog(hDlg, NULL);
        return (TRUE);
        }
    }
    return (FALSE);
    }


/******************* ERROR SITUATION ROUTINES **************************/




FGrowRgbp(cbp)
int cbp;
{
#ifdef CKSM
#ifdef DEBUG
extern unsigned (**hpibpcksm) [];
extern int ibpCksmMax;
#endif
#endif
extern CHAR       (*rgbp)[cbSector];
extern CHAR       *rgibpHash;
extern int        fIbpCheck;
extern int        vcCount;

int ibpMaxNew = ibpMax + cbp;
int iibpHashMaxNew;
int cbNew;
extern int ibpMaxFloat;

if (ibpMaxNew > ibpMaxFloat)
    return(FALSE);

iibpHashMaxNew = ibpMaxNew * 2 + 1;
cbNew = ibpMaxNew * cbSector * sizeof(CHAR) +
        ((iibpHashMaxNew * sizeof(CHAR) + sizeof(int) - 1) & ~1) +
        ((ibpMaxNew * sizeof(struct BPS) + sizeof(int) - 1) & ~1);

if (LocalReAlloc((HANDLE)rgbp, cbNew, LPTR) == (HANDLE)NULL
#ifdef CKSM
#ifdef DEBUG
    || !FChngSizeH( hpibpcksm, ibpMaxNew, FALSE )
#endif
#endif
    )
    {
    if (cbp == 1)
        {
#ifdef CHIC
        CommSzNum("Can't grow any more, current ibpMax = ", ibpMax);
#endif
        vcCount = 1024; /* so that we wait for a longer period before attemp again */
        }
    return(FALSE);
    }
else
    {
    int cbRgbpTotalNew = ibpMaxNew * cbSector;
    int cbHashOrg = (iibpHashMax * sizeof(CHAR) + sizeof(int) - 1) & ~1;
    int cbHashTotalNew = (iibpHashMaxNew * sizeof(CHAR) + sizeof(int) - 1) & ~1;
    int cbBpsOrg = (ibpMax * sizeof(struct BPS) + sizeof(int) - 1) & ~1;
    int ibp;
    struct BPS *pbps;
    CHAR *pNew;

    /* blt tail end stuff first, in the following order --
       mpibpbps, rgibpHash */

    pNew = (CHAR *)rgbp + cbRgbpTotalNew + cbHashTotalNew;
    bltbyte((CHAR*)mpibpbps, pNew, cbBpsOrg);
    mpibpbps =  (struct BPS *)pNew;

    pNew = (CHAR *)rgbp + cbRgbpTotalNew;
    bltbyte((CHAR *)rgibpHash, pNew, cbHashOrg);
    rgibpHash = pNew;

    for (ibp = 0, pbps = &mpibpbps[0]; ibp < ibpMaxNew; ibp++, pbps++)
        {
        if (ibp >= ibpMax)
            {
            /* initialize new bps */
            pbps->fn = fnNil;
            pbps->ts = tsMruBps - (ibpMax * 4);
            }
        pbps->ibpHashNext = ibpNil;
        }
    ibpMax = ibpMaxNew;
    iibpHashMax = iibpHashMaxNew;
#ifdef CKSM
#ifdef DEBUG
    ibpCksmMax = ibpMax;
#endif
#endif
    RehashRgibpHash();
#ifdef CHIC
    CommSzNum("ibpMax = ", ibpMax);
#endif
    return(TRUE);
    }
}


FStillOutOfMemory()
{
/* Return FALSE if there is enough memory available to pop us out of the "out of
memory" state; TRUE otherwise */

extern HANDLE vhReservedSpace;

/* If we have had to give up our reserved space block, re-establish it BEFORE
testing memory availability */

    //return vfWinFailure;

if (vhReservedSpace == NULL && (vhReservedSpace = LocalAlloc(LHND, cbReserve))
  == NULL)
    {
    /* Nothing we can do. */
    return (TRUE);
    }

/* OK, we have our reserve block, but do we have any other memory?  (The use of
cbReserve here is abritrary.) */
if (LocalCompact(0) < cbReserve)
    {
    HANDLE hBuf = LocalAlloc(LMEM_MOVEABLE, cbReserve);

    if (hBuf == NULL)
        {
        return(TRUE);
        }
    else
        {
        LocalFree(hBuf);
        if (GlobalCompact(0) < cbReserve)
            {
            HANDLE hBuf = GlobalAlloc(GMEM_MOVEABLE, cbReserve);

            if (hBuf == NULL)
                {
                return(TRUE);
                }
            else
                {
                GlobalFree(hBuf);
                return(FALSE);
                }
            }
        }
    }


return(FALSE);
}



IbpFindSlot(fn)
int fn;
{ /*
        Description:    Called from IbpEnsureValid (file.c) when a disk
                        full error is generated while trying to write out
                        scratch file records.  A buffer slot for a piece of
                        file fn must be found
                        which is either non-dirty or is dirty but does
                        not contain scratch file information.  We search
                        for the least recently used slot with the above
                        requirements.
                        If fn == fnScratch, we are trying to find a buffer
                        slot for a scratch file page.  We may not put it in
                        the beginning cbpMustKeep slots.
        Returns:        ibp (slot #).
  */
        int ibpOuterLoop;
        int ibpNextTry;
        int ibpStart;
        typeTS ts, tsLastTry = 0;
        int ibp;

#ifdef DEBUG
                Assert(vfSysFull);
#endif
        if (fn == fnScratch) ibpStart = cbpMustKeep;
                else ibpStart = 0;

        /* In LRU timestamp order, we are looking for any slot */
        /* which is non dirty or is dirty but is not part of the */
        /* scratch file. */
        for (ibpOuterLoop = ibpStart; ibpOuterLoop < ibpMax; ibpOuterLoop++)
                {
                struct BPS *pbps = &mpibpbps[ibpStart];
                typeTS tsNextTry = -1;/* largest possible timestamp */
                for(ibp = ibpStart; ibp < ibpMax; ibp++, pbps++)
                        {
                        ts = pbps->ts - (tsMruBps + 1);
                        if ((ts <= tsNextTry) && (ts > tsLastTry))
                                {
                                tsNextTry = ts;
                                ibpNextTry = ibp;
                                }
                        }
                if (mpibpbps[ibpNextTry].fDirty == fFalse) break;
                if (mpibpbps[ibpNextTry].fn != fnScratch)
                        {
                        FFlushFn(mpibpbps[ibpNextTry].fn);
                                        /* We need not check a return value.
                                           If the flush failed, vfDiskFull
                                           will get set */
                        break;
                        }
                else tsLastTry = tsNextTry;
                }

        if (ibpOuterLoop < ibpMax)
                {
                if (fn == vfnWriting) vibpWriting = ibpNextTry;
                return(ibpNextTry);
                }
#ifdef DEBUG
                Assert(FALSE);  /* there just had to be some slot available */
                                /* not used by the scratch file */
#endif
} /* end IbpFindSlot */


NEAR WaitBeforePostMsg(errlevel)
int errlevel;
{
extern int flashID;
extern HWND hwndWait;
BOOL fParentEnable = IsWindowEnabled(hParentWw) || hwndWait;

    MessageBeep(errlevel);

    Diag(CommSzNum("WAITBEFOREPOSTMSG: vfDeactByOtherApp==",vfDeactByOtherApp));
    if (!fParentEnable)
        EnableWindow(hParentWw, TRUE); /* make sure parent window is enabled
                                      to let the user click in it */
    flashID = SetTimer(hParentWw, NULL, 500, (FARPROC)NULL);
    while (vfDeactByOtherApp)
        {
        if (PeekMessage((LPMSG)&vmsgLast, (HWND)NULL, NULL, NULL, PM_REMOVE))
            {
            if (vfDeactByOtherApp)
                {
                TranslateMessage( (LPMSG)&vmsgLast);
                DispatchMessage((LPMSG)&vmsgLast);
                }
            }
        }

    if (!fParentEnable)
        EnableWindow(hParentWw, FALSE); /* reset */
}


EnableExcept(hWnd, fEnable)
HWND hWnd;
BOOL fEnable;
{ /* Enable hParentWw and all modeless except hWnd according to fEnable */
extern HWND   vhDlgChange;
extern HWND   vhDlgFind;
extern HWND   vhDlgRunningHead;
extern HWND   hParentWw;

    if (hWnd != vhDlgChange && IsWindow(vhDlgChange))
        {
        EnableWindow(vhDlgChange, fEnable);
        }
    if (hWnd != vhDlgFind && IsWindow(vhDlgFind))
        {
        EnableWindow(vhDlgFind, fEnable);
        }
    if (hWnd != vhDlgRunningHead && IsWindow(vhDlgRunningHead))
        {
        EnableWindow(vhDlgRunningHead, fEnable);
        }
    EnableWindow(hParentWw, fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\diadiv.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "docdefs.h"
#include "str.h"
#include "printdef.h"


extern HCURSOR vhcArrow;
extern int     vfCursorVisible;

extern int utCur;  /* current conversion unit */


BOOL far PASCAL DialogTabs(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles input to the Tabs dialog box. */

    extern struct DOD (**hpdocdod)[];
    extern int docCur;
    extern int vdocParaCache;
    extern HWND vhWndMsgBoxParent;
    extern int ferror;

    struct TBD (**hgtbd)[];
    int idi;

    switch (message)
    {
    case WM_INITDIALOG:
        /* Disable modeless dialog boxes. */
        EnableOtherModeless(FALSE);

        /* Set up the fields for each of the tabs. */
        hgtbd = (**hpdocdod)[docCur].hgtbd;
        if (hgtbd != NULL)
        {
        struct TBD *ptbd;
        unsigned dxa;
        CHAR szT[cchMaxNum];
        CHAR *pch;

        for (ptbd = &(**hgtbd)[0], idi = idiTabPos0; (dxa = ptbd->dxa) != 0;
          ptbd++, idi++)
            {
            pch = &szT[0];
            CchExpZa(&pch, dxa, utCur, cchMaxNum);
            SetDlgItemText(hDlg, idi, (LPSTR)szT);
            CheckDlgButton(hDlg, idi + (idiTabDec0 - idiTabPos0), ptbd->jc
              == (jcTabDecimal - jcTabMin));
            }
        }
        break;

    case WM_SETVISIBLE:
        if (wParam)
            EndLongOp(vhcArrow);
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
            the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            struct TBD rgtbd[itbdMax];
            struct TBD *ptbdLast;

        case idiOk:
            /* Sort the new tab descriptors. */
            bltc(rgtbd, 0, itbdMax * cwTBD);
            ptbdLast = &rgtbd[itbdMax - 1];
            for (idi = idiTabPos0; idi <= idiTabPos11; idi++)
                {
                unsigned dxa;
                unsigned dxaTab;
                struct TBD *ptbd;

                /* If an invalid position was entered, then punt. */
                if (!FPdxaPosBIt(&dxa, hDlg, idi))
                    {
                    ferror = FALSE;
                    return (TRUE);
                    }

                /* Ignore blank tabs or tabs at zero. */
                if (dxa == valNil || dxa == 0)
                    {
                    continue;
                    }

                for (ptbd = &rgtbd[0]; (dxaTab = ptbd->dxa) != 0; ptbd++)
                    {
                    /* If there is already a tab at this position, then ignore
                    the new tab. */
                    if (dxa == dxaTab)
                    {
                    goto GetNextTab;
                    }
        
                    /* If the new tab position is smaller than the current tab,
                    then make room for the new tab. */
                    if (dxa < dxaTab)
                        {
                        bltbyte(ptbd, ptbd + 1, (unsigned)ptbdLast - (unsigned)ptbd);
                        break;
                        }
                    }

                /* Put the tab into rgtbd. */
                ptbd->dxa = dxa;
                ptbd->jc = (IsDlgButtonChecked(hDlg, idi + (idiTabDec0 -
                  idiTabPos0)) ? jcTabDecimal : jcTabLeft) - jcTabMin;
GetNextTab:;
                }

                /* Set up the undo stuff. */
                SetUndo(uacFormatTabs, docCur, cp0, cp0, docNil, cpNil, cpNil, 0);

                /* Ensure that this document has a tab-stop table. */
                if ((hgtbd = (**hpdocdod)[docCur].hgtbd) == NULL)
                    {
                    if (FNoHeap(hgtbd = (struct TBD (**)[])HAllocate(itbdMax *
                          cwTBD)))
                        {
                        goto DestroyDlg;
                        }
                    (**hpdocdod)[docCur].hgtbd = hgtbd;
                    }
                blt(rgtbd, &(**hgtbd)[0], itbdMax * cwTBD);

                /* Changing the tabs makes everything dirty. */
                (**hpdocdod)[docCur].fDirty = TRUE;
                vdocParaCache = docNil;
                TrashAllWws();

        case idiCancel:
DestroyDlg:
            /* Destroy the tabs dialog box and enable any existing modeless
            dialog boxes.*/
            OurEndDialog(hDlg, NULL);
            break;

        case idiTabClearAll:
            /* Clear all of the tabs. */
            for (idi = idiTabPos0; idi <= idiTabPos11; idi++)
                {
                SetDlgItemText(hDlg, idi, (LPSTR)"");
                CheckDlgButton(hDlg, idi + (idiTabDec0 - idiTabPos0), FALSE);
                }
            break;

        case idiTabDec0:
        case idiTabDec1:
        case idiTabDec2:
        case idiTabDec3:
        case idiTabDec4:
        case idiTabDec5:
        case idiTabDec6:
        case idiTabDec7:
        case idiTabDec8:
        case idiTabDec9:
        case idiTabDec10:
        case idiTabDec11:
            CheckDlgButton(hDlg, wParam, !IsDlgButtonChecked(hDlg, wParam));
            break;

        default:
            return(FALSE);
        }
        break;

    case WM_CLOSE:
        goto DestroyDlg;

    default:
        return(FALSE);
    }
    return(TRUE);
}
/* end of DialogTabs */


BOOL far PASCAL DialogDivision(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles input to the Division dialog box. */

    extern struct DOD (**hpdocdod)[];
    extern int docCur;
    extern struct SEP vsepNormal;
    extern int vdocSectCache;
    extern BOOL vfPrinterValid;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern HWND vhWndMsgBoxParent;
    extern typeCP cpMinDocument;
    extern int ferror;

    struct SEP **hsep = (**hpdocdod)[docCur].hsep;
    register struct SEP *psep;
    CHAR szT[cchMaxNum];
    CHAR *pch = &szT[0];

#ifdef KINTL /* Kanji/International version */
static int iRBDown;
static int utInit;
#endif

    switch (message)
    {
    case WM_INITDIALOG:

#ifdef KINTL /* Kanji/International version */
       /* base initial setting on value in utCur */

        utInit = utCur;  /* for testing at ok */
            if (utCur == utCm)
                iRBDown = idiDivCm;
            else
                iRBDown = idiDivInch;

        CheckDlgButton(hDlg, iRBDown, TRUE);

#endif


        EnableOtherModeless(FALSE);

        /* Get a pointer to the section properties. */
        psep = (hsep == NULL) ? &vsepNormal : *hsep;

        /* Initialize the starting page number. */
        if (psep->pgnStart != pgnNil)
            {
            szT[ncvtu(psep->pgnStart, &pch)] = '\0';
            SetDlgItemText(hDlg, idiDivPNStart, (LPSTR)szT);
            pch = &szT[0];
            }
        else
            {
            SetDlgItemText(hDlg, idiDivPNStart, (LPSTR)"1");
            }
        SelectIdiText(hDlg, idiDivPNStart);

        /* Initialize the margins. */
#ifdef DMARGINS
        CommSzNum("Left Twips: ", psep->xaLeft);
        CommSzNum("Right Twips: ", psep->xaMac - psep->dxaText - psep->xaLeft);
        CommSzNum("Top Twips: ", psep->yaTop);
        CommSzNum("Bottom Twips: ", psep->yaMac - psep->dyaText - psep->yaTop);
#endif /* DEBUG */

#ifdef	KOREA
        if (vfPrinterValid)
                CchExpZa(&pch, imax(psep->xaLeft, dxaPrOffset), utCur,cchMaxNum);
        else
                CchExpZa(&pch, psep->xaLeft, utCur, cchMaxNum);
#else
        CchExpZa(&pch, psep->xaLeft, utCur, cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivLMarg, (LPSTR)szT);
        pch = &szT[0];
#ifdef	KOREA		/* 90.12.29 sangl */
        if ( vfPrinterValid )
                CchExpZa (&pch, imax(psep->xaMac - psep->dxaText - psep->xaLeft,
                  vsepNormal.xaMac - dxaPrOffset - dxaPrPage), utCur, cchMaxNum);
        else
                CchExpZa(&pch, psep->xaMac - psep->dxaText - psep->xaLeft, utCur,
                  cchMaxNum);
#else
        CchExpZa(&pch, psep->xaMac - psep->dxaText - psep->xaLeft, utCur,
          cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivRMarg, (LPSTR)szT);
        pch = &szT[0];
#ifdef	KOREA		/* 90.12.29 sangl */
        if (vfPrinterValid)
          CchExpZa(&pch, imax( psep->yaTop, dyaPrOffset), utCur, cchMaxNum);
        else
          CchExpZa(&pch, psep->yaTop, utCur, cchMaxNum);
#else
        CchExpZa(&pch, psep->yaTop, utCur, cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivTMarg, (LPSTR)szT);
        pch = &szT[0];
#ifdef	KOREA	/* 90.12.29 sangl */
        if (vfPrinterValid)
           CchExpZa(&pch, imax(psep->yaMac - psep->dyaText - psep->yaTop,
            vsepNormal.yaMac - dyaPrOffset - dyaPrPage), utCur, cchMaxNum);
        else
           CchExpZa(&pch, psep->yaMac - psep->dyaText - psep->yaTop, utCur,
            cchMaxNum);
#else
        CchExpZa(&pch, psep->yaMac - psep->dyaText - psep->yaTop, utCur,
          cchMaxNum);
#endif

        SetDlgItemText(hDlg, idiDivBMarg, (LPSTR)szT);
        break;

    case WM_SETVISIBLE:
        if (wParam)
            EndLongOp(vhcArrow);
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
            the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            int pgn;
            int iza;
            int za[4];
            int zaMin[4];
            int dza;
            int *pza;
            int dxaMax;
            int dyaMax;

        case idiOk:
            /* Is the page number valid? */
            if (!WPwFromItW3Id(&pgn, hDlg, idiDivPNStart, pgnMin, pgnMax,
                       wNormal, IDPMTNPI))
                {
                ferror = FALSE; /* minor error, stay in dialog */
                break;
                }

        /* Determine the minimum margins of the page. */
            if (vfPrinterValid)
                {
                zaMin[0] = dxaPrOffset;
                zaMin[1] = imax(0, vsepNormal.xaMac - dxaPrOffset - dxaPrPage);
                zaMin[2] = dyaPrOffset;
                zaMin[3] = imax(0, vsepNormal.yaMac - dyaPrOffset - dyaPrPage);
                }
            else
                {
                zaMin[0] = zaMin[1] = zaMin[2] = zaMin[3] = 0;
                }

            /* Are the margins valid? */
            for (iza = 0; iza < 4; iza++)
                {
                /* Is the margin a positive measurement? */
                if (!FPdxaPosIt(&za[iza], hDlg, iza + idiDivLMarg
                        ))
                    {
                    ferror = FALSE; /* minor error, stay in dialog */
                    return (TRUE);
                    }

                /* Is it less than the minimum? */
                if (FUserZaLessThanZa(za[iza], zaMin[iza]))
                    {
                    ErrorBadMargins(hDlg, zaMin[0], zaMin[1], zaMin[2],
                      zaMin[3]);
                    SelectIdiText(hDlg, iza + idiDivLMarg);
                    SetFocus(GetDlgItem(hDlg, iza + idiDivLMarg));
                    return (TRUE);
                    }
                }
#ifdef DMARGINS
            CommSzNum("New Left Twips: ", za[0]);
            CommSzNum("New Right Twips: ", za[1]);
            CommSzNum("New Top Twips: ", za[2]);
            CommSzNum("New Bottom Twips: ", za[3]);
#endif /* DEBUG */

            /* Ensure that this document has a valid section property
                descriptor. */
            if (hsep == NULL)
                {
                if (FNoHeap(hsep = (struct SEP **)HAllocate(cwSEP)))
                    {
                    goto DestroyDlg;
                    }
                blt(&vsepNormal, *hsep, cwSEP);
                (**hpdocdod)[docCur].hsep = hsep;
                }
            psep = *hsep;

            /* Are the combined margins longer or wider than the page? */
            pza = &za[0];
            dxaMax = psep->xaMac - dxaMinUseful;
            dyaMax = psep->yaMac - dyaMinUseful;
            if ((dza = *pza) > dxaMax || (dza += *(++pza)) > dxaMax ||
              (dza = *(++pza)) > dyaMax || (dza += *(++pza)) > dyaMax)
                {
                Error(IDPMTMTL);
                ferror = FALSE; /* minor error, stay in dialog */
                SelectIdiText(hDlg, (int)(idiDivLMarg + (pza - &za[0])));
                SetFocus(GetDlgItem(hDlg, (int)(idiDivLMarg + (pza - &za[0]))));
                return (FALSE);
                }

            /* If the margins have changed, then set the new values. */
            if (psep->pgnStart != pgn || psep->xaLeft != za[0] || psep->dxaText
              != psep->xaMac - za[0] - za[1] || psep->yaTop != za[2] ||
              psep->dyaText != psep->yaMac - za[2] - za[3])
                {
                /* Set up the undo stuff. */
                SetUndo(uacFormatSection, docCur, cp0, cp0, docNil, cpNil,
                  cpNil, 0);
                    
                /* Reset psep in case some heap movement has taken place. */
                psep = *hsep;

                if (psep->pgnStart != pgn)
                    {
                    /* Renumber the page table. */
                    extern int docMode;
                    register struct PGTB **hpgtb = (**hpdocdod)[docCur].hpgtb;
                    register struct PGD *ppgd;
                    int ipgd;
                    int cpgdMac;

                    /* Initialize page table if it does not already exist. */
                    if (hpgtb == NULL)
                    {
                    if (FNoHeap(hpgtb =
                      (struct PGTB **)HAllocate(cwPgtbBase + cpgdChunk *
                          cwPGD)))
                        {
                        NoUndo();
                        return(TRUE);
                        }
                    (**hpgtb).cpgdMax = cpgdChunk;
                    (**hpgtb).cpgd = 1;
                    (**hpgtb).rgpgd[0].cpMin = cpMinDocument;

                    /* Reset psep because of heap movement. */
                    psep = *hsep;
                    }

                /* Save the starting page number in the section properties.
                */
                psep->pgnStart = pgn;

                /* Update the page table with the new starting page number.
                */
                for (ipgd = 0, cpgdMac = (**hpgtb).cpgd, ppgd =
                     &((**hpgtb).rgpgd[0]) ; ipgd < cpgdMac; ipgd++, ppgd++)
                    {
                    ppgd->pgn = pgn++;
                    }

                /* Force the page info window to be repainted. */
                docMode = docNil;
                }

            /* Set the new section properties. */
            psep->dxaText = psep->xaMac - (psep->xaLeft = za[0]) - za[1];
            psep->dyaText = psep->yaMac - (psep->yaTop = za[2]) - za[3];

            /* Invalidate the section cache. */
            vdocSectCache = docNil;
            TrashAllWws();

            /* Mark the document as dirty. */
            (**hpdocdod)[docCur].fDirty = TRUE;
            }

#ifdef KINTL     /* Kanji/International version */
             /* redraw ruler if visible and units changed */
        if (utInit != utCur) {
        ReframeRuler();
        }
#endif

        goto DestroyDlg;

    case idiCancel:

#ifdef KINTL /* International version */
        utCur = utInit;  /* restore units at actual cancel */
#endif     /* KINTL */

DestroyDlg:
        OurEndDialog(hDlg, TRUE);
        break;

#ifdef KINTL /* International version */
    {
         int margin;

/* Maximum number of characters in the edit control */
#define cchMaxEditText 64

    case idiDivInch:
        utCur = utInch;
        goto SetUnits;
    case idiDivCm:
        utCur = utCm;
       /* measurment button fall into this code */
SetUnits:
        /* set up buttons appropriately */
#ifdef INTL
        CheckRadioButton(hDlg, idiDivInch, idiDivCm, wParam);
#else /* KANJI */
        CheckRadioButton(hDlg, idiDivInch, idiDivCch, wParam);
#endif

        if (wParam != iRBDown) {
            /* reevaluate margin values based on new units */
            iRBDown = wParam;

            /* want most recently entered value from screen into
               twips, then convert using current unit scale */

            szT[0] = GetDlgItemText(hDlg, idiDivLMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivLMarg, (LPSTR)szT);
                }

            szT[0] = GetDlgItemText(hDlg, idiDivRMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivRMarg, (LPSTR)szT);
                }

            szT[0] = GetDlgItemText(hDlg, idiDivTMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivTMarg, (LPSTR)szT);
                }

            szT[0] = GetDlgItemText(hDlg, idiDivBMarg,
                        (LPSTR) &szT[1], cchMaxNum);
            if (FZaFromSs (&margin, szT+1, *szT, utCur))
                {
                pch = &szT[0];
                CchExpZa(&pch, margin, utCur, cchMaxNum);
                SetDlgItemText(hDlg, idiDivBMarg, (LPSTR)szT);
                }
            }

        break;
        }
#endif     /* KINTL */


    default:
        return (FALSE);
        }
    break;

    default:
    return (FALSE);
    }
    return (TRUE);
} /* end of DialogDivision */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\diachgpr.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1990 Microsoft Corporation */
/************************************************************/

/* This file contains the routines for the change printer dialog box. */


#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOCLIPBOARD
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOWH
#define NOWNDCLASS
#define NOSOUND
#define NOCOLOR
#define NOSCROLL
#define NOCOMM
#include <windows.h>
#ifdef EXTDEVMODESUPPORT
#include <drivinit.h>   /* new for win 3.0 and extdevicemode pr.drv. calls */
#endif
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "machdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "printdef.h"
#include "str.h"

extern CHAR  szExtDrv[];
extern CHAR  szDeviceMode[];
extern CHAR  szNone[];
extern HWND             vhWnd;
#ifdef EXTDEVMODESUPPORT
extern CHAR  szExtDevMode[];
extern HANDLE hDevmodeData;
#endif

BOOL far PASCAL DialogPrinterSetup( hDlg, message, wParam, lParam )
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
   {
    extern CHAR *vpDlgBuf;
    extern HWND hParentWw;
    extern CHAR szDevices[];
    extern CHAR stBuf[];
    extern HDC vhDCPrinter;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern BOOL vfPrinterValid;
    extern HANDLE hMmwModInstance;
    extern BOOL vfPrDefault;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;
    extern HCURSOR vhcIBeam;
    extern HWND vhWndMsgBoxParent;

    void BuildPrSetupSz(CHAR *, CHAR *, CHAR *);

    CHAR (***phszPr)[] = (CHAR (***)[])vpDlgBuf;
    BOOL *pfOkEnabled = (BOOL *)(phszPr + 3);
    CHAR stKeyName[cchMaxIDSTR];
    CHAR szPrinters[cchMaxProfileSz];
    CHAR *pchPrinters;
    CHAR szDevSpec[cchMaxProfileSz];
    CHAR szListEntry[cchMaxProfileSz];
    CHAR *pchPort;
    CHAR *pchDriver;
    CHAR chNull = '\0';
    int  iPrinter;
    BOOL fSingleClick;

    switch (message)
      {
      case WM_INITDIALOG:
        /* Disable any modeless dialog boxes. */
        EnableOtherModeless(FALSE);

        /* Save away the heap strings that describe the current printer. */
        *phszPr++ = hszPrinter;
        *phszPr++ = hszPrDriver;
        *phszPr = hszPrPort;

        /* Get a string that holds all of the printer names. */
        GetProfileString((LPSTR)szDevices, (LPSTR)NULL, (LPSTR)&chNull,
          (LPSTR)szPrinters, cchMaxProfileSz);

        /* There must be two nulls at the end of the list. */
        szPrinters[cchMaxProfileSz - 1] = szPrinters[cchMaxProfileSz - 2] =
          '\0';

        /* Parse out the names of the printers. */
        pchPrinters = &szPrinters[0];
        while (*pchPrinters != '\0')
            {
            /* Get the corresponding printer driver and port. */
            GetProfileString((LPSTR)szDevices, (LPSTR)pchPrinters,
              (LPSTR)&chNull, (LPSTR)szDevSpec, cchMaxProfileSz);
            szDevSpec[cchMaxProfileSz - 1] = '\0';

            /* If there is no driver for this printer, then it cannot be added
            to the list. */
            if (szDevSpec[0] != '\0')
                {
                /* Parse the ports and the driver. */
                int cPort = ParseDeviceSz(szDevSpec, &pchPort, &pchDriver);
                int iPort;

                for (iPort = 0; iPort < cPort; iPort++)
                    {
                    /* Contruct the list box entry. */
                    BuildPrSetupSz(szListEntry, pchPrinters, pchPort);

                    /* Put the string in the list box 
                       provided printer is not on "None" */

                    if (!FSzSame(pchPort, szNone))
                        SendDlgItemMessage(hDlg, idiPrterName, LB_ADDSTRING, 
                                           0, (LONG)(LPSTR)szListEntry);

                    /* Bump the pointer to the next port in the list. */
                    pchPort += CchSz(pchPort);
                    }
                }

            /* Skip to the next printer in the list. */
            while (*pchPrinters++) ;
            }

        /* Select the current printer. */
        if (!(*pfOkEnabled = hszPrinter != NULL && hszPrPort != NULL &&
          (BuildPrSetupSz(szListEntry, &(**hszPrinter)[0], &(**hszPrPort)[0]),
          SendDlgItemMessage(hDlg, idiPrterName, LB_SELECTSTRING, -1,
          (LONG)(LPSTR)szListEntry) >= 0)))
            {
            EnableWindow(GetDlgItem(hDlg, idiOk), FALSE);
            }
        return(fTrue); /* we processed the message */

      case WM_SETVISIBLE:
        if (wParam)
            {
            EndLongOp(vhcArrow);
            }
        break; /* to return false below */

      case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        break; /* to return false below */

      case WM_COMMAND:
        fSingleClick = FALSE;
        switch (wParam)
          {
          case idiPrterName:
            if (HIWORD(lParam) == 1)    /* remember single mouse clicks */
                {
                fSingleClick = fTrue;
                }
            else if (HIWORD(lParam) != 2)  /* 2 is a double mouse click */
                break; /* LBNmsg (listbox notification) we don't handle */

          case idiPrterSetup:
          case idiOk:
            /* If none of the printers is currently selected... */
            if ((iPrinter = SendDlgItemMessage(hDlg, idiPrterName, LB_GETCURSEL,
              0, 0L)) == -1)
                {
                /* Disable the "OK" button. */
                if (*pfOkEnabled)
                    {
                    EnableWindow(GetDlgItem(hDlg, idiOk), FALSE);
                    *pfOkEnabled = FALSE;
                    }
                return(fTrue); /* we processed the message */
                }
            else
                {
                CHAR *index(CHAR *, int);
                CHAR *bltbyte(CHAR *, CHAR *, int);

                CHAR *pch;
                CHAR szDriver[cchMaxFile];
                HANDLE hDriver;
                FARPROC lpfnDevMode;
#ifdef EXTDEVMODESUPPORT
                BOOL fExtDevModeSupport = fTrue; /* assume until told otherwise */
#endif                
                int cwsz;

                if (fSingleClick)
                    {
                    /* If this is just a single mouse-click, then just update the
                    status of the "OK" button. */
                    if (!*pfOkEnabled)
                        {
                        EnableWindow(GetDlgItem(hDlg, idiOk), TRUE);
                        *pfOkEnabled = TRUE;
                        }
                    return(fTrue); /* we processed the message */
                    }
                
                /* Let the user know that this may take a while. */
                StartLongOp();

                /* Get the printer's name, it's port, and it's driver. */
                SendDlgItemMessage(hDlg, idiPrterName, LB_GETTEXT, iPrinter,
                  (LONG)(LPSTR)szListEntry);

                /* Parse the port name out of the list entry. */
                pchPort = &szListEntry[0] + CchSz(szListEntry) - 1;
                while (*(pchPort - 1) != ' ')
                    {
                    pchPort--;
                    }

                /* Parse the name of the printer out of the list entry. */
                pch = &szListEntry[0];
                FillStId(stBuf, IDSTROn, sizeof(stBuf));
                for ( ; ; )
                    {
                    if ((pch = index(pch, ' ')) != 0 && FRgchSame(pch,
                      &stBuf[1], stBuf[0]))
                        {
                        *pch = '\0';
                        break;
                        }
                    pch++;
                    }

                /* Get the driver name for this printer. */
                GetProfileString((LPSTR)szDevices, (LPSTR)szListEntry,
                 (LPSTR)&chNull, (LPSTR)szDevSpec, cchMaxProfileSz);
                ParseDeviceSz(szDevSpec, &pch, &pchDriver);

                /* Update the heap strings describing the printer. */
                if (hszPrinter != *phszPr)
                    {
                    FreeH(hszPrinter);
                    }
                if (FNoHeap(hszPrinter = (CHAR (**)[])HAllocate(cwsz =
                  CwFromCch(CchSz(szListEntry)))))
                    {
                    hszPrinter = NULL;
Error:
                    EndLongOp(vhcIBeam);
                    goto DestroyDlg;
                    }
                blt(szListEntry, *hszPrinter, cwsz);
                if (hszPrDriver != *(phszPr + 1))
                    {
                    FreeH(hszPrDriver);
                    }
                if (FNoHeap(hszPrDriver = (CHAR (**)[])HAllocate(cwsz =
                  CwFromCch(CchSz(pchDriver)))))
                    {
                    hszPrDriver = NULL;
                    goto Error;
                    }
                blt(pchDriver, *hszPrDriver, cwsz);
                if (hszPrPort != *(phszPr + 2))
                    {
                    FreeH(hszPrPort);
                    }
                if (FNoHeap(hszPrPort = (CHAR (**)[])HAllocate(cwsz =
                  CwFromCch(CchSz(pchPort)))))
                    {
                    hszPrPort = NULL;
                    goto Error;
                    }
                blt(pchPort, *hszPrPort, cwsz);

                /* Get the name of the driver, complete with extension. */
                bltbyte(szExtDrv, 
                            bltbyte(pchDriver, szDriver, CchSz(pchDriver) - 1), 
                                CchSz(szExtDrv));

                /* That's all we need for Setup ..pault */
                if (wParam != idiPrterSetup)
                    goto LSetupDone;
                
                /* The driver is not resident; attempt to load it. */
                if ((hDriver = LoadLibrary((LPSTR)szDriver)) <= 32)
                    {
                    if (hDriver != 2)
                        {
                        /* If hDriver is 2, then the user has cancelled a dialog
                        box; there's no need to put up another. */
                        Error(IDPMTBadPrinter);
                        }
Abort:
                    EndLongOp(vhcArrow);
                    return (TRUE);  /* True means we processed the message */
                    }

#ifdef EXTDEVMODESUPPORT
                /* First see if ExtDeviceMode is supported (Win 3.0 drivers) */
                if ((lpfnDevMode = GetProcAddress(hDriver,
                       (LPSTR)szExtDevMode)) == NULL)
                    {
                    fExtDevModeSupport = fFalse;
#else
                    {
#endif
                    /* Otherwise get the driver's DeviceMode() entry. */
                    if ((lpfnDevMode = GetProcAddress(hDriver,
                           (LPSTR)szDeviceMode)) == NULL)
                        {
                        /* No can do, eh? */
                        Error(IDPMTBadPrinter);
LUnloadAndAbort:
                        FreeLibrary(hDriver);
                        goto Abort;
                        }
                    }

#ifdef EXTDEVMODESUPPORT
                /* Actual calls to the device modes setup. 
                   Much of this new ExtDevModeSupport stuff 
                   borrowed from MULTIPAD ..pault */

                if (fExtDevModeSupport)
                    {
                    int     cb;
                    int     wId;
                    HANDLE  hT;
                    LPDEVMODE lpOld, lpNew;
                    BOOL    flag;    /* devmode mode param */

                    /* pop up dialog for user */
                    flag = DM_PROMPT|DM_COPY;

                    if (hDevmodeData != NULL)
                        {
                        NPDEVMODE npOld;

                        /* Modify the user's last print settings */

                        flag |= DM_MODIFY;
                        lpOld = (LPDEVMODE)(npOld = (NPDEVMODE)LocalLock(hDevmodeData));
                        
                        /* Check to see if they're using the same printer 
                           driver as last time.  If so, let them modify all
                           of their previous settings.  If not, we tell  
                           ExtDevMode to save as many of the hardware-
                           independent settings as it can (e.g. copies) */
                    
                        if (!FSzSame(szListEntry, npOld->dmDeviceName))
                            {
                            npOld->dmDriverVersion = NULL;
                            npOld->dmDriverExtra = NULL;
                            bltsz(szListEntry, npOld->dmDeviceName);
                            }
                        }
                    else
                        /* We haven't done a printer setup yet this session */
                        lpOld = NULL;
            
                    /* how much space do we need for the data? */
                    cb = (*lpfnDevMode)(hDlg, hDriver, (LPSTR)NULL, 
                            (LPSTR)szListEntry, (LPSTR)pchPort,
                            (LPDEVMODE)NULL, (LPSTR)NULL, 0);

                    if ((hT = LocalAlloc(LHND, cb)) == NULL)
                        goto LUnloadAndAbort;
                    lpNew = (LPDEVMODE)LocalLock(hT);

                    /* post the device mode dialog.  0 flag iff user hits OK button */
                    wId = (*lpfnDevMode)(hDlg, hDriver, (LPDEVMODE)lpNew,
                            (LPSTR)szListEntry, (LPSTR)pchPort, 
                            (LPDEVMODE)lpOld, (LPSTR)NULL, flag);
                    if (wId == IDOK)
                        flag = 0;

                    /* unlock the input structures */
                    LocalUnlock(hT);
                    if (hDevmodeData != NULL)
                        LocalUnlock(hDevmodeData);

                    /* if the user hit OK and everything worked, free the original init
                     * data and retain the new one.  Otherwise, toss the new buffer
                     */
                    if (flag != 0)
                        {
                        LocalFree(hT);
                        goto LUnloadAndAbort;
                        }
                    else
                        {
                        if (hDevmodeData != NULL)
                            LocalFree(hDevmodeData);
                        hDevmodeData = hT;
                        }
                    }
                    
                else /* older Win 2.0 driver, make DeviceMode call */
                    {
                    if (hDevmodeData != NULL)
                        {
                        /* We'd opened a Win3 printer driver before; now discard */
                        LocalFree(hDevmodeData);
                        hDevmodeData = NULL;
                        }
#else /* ifdef EXTDEVMODESUPPORT */
                    {
#endif /* else-def-EXTDEVMODESUPPORT */     
                    if (!(*lpfnDevMode)(hDlg, hDriver, (LPSTR)szListEntry,
                         (LPSTR)pchPort))
                        goto LUnloadAndAbort;
                    }
                FreeLibrary(hDriver);
LSetupDone:
                /* Let the user know the waiting is over. */
                EndLongOp(vhcIBeam);

                /* Printer setup should take us back to printer choices! */
                if (wParam == idiPrterSetup)
                    {
                    return (TRUE);  /* True means we processed the message */
                    }
                
                /* Previously we freed these guys before returning 
                   and that fouled up our heap ..pault */
                FreeH(*phszPr++);
                FreeH(*phszPr++);
                FreeH(*phszPr);

                vfPrDefault = FALSE;

#ifdef WIN30
                /* Need to indicate to FormatLine and Friends here
                   that we (may) have a different font pool to work
                   with and we should look at the new ones!  Invalidating
                   the window will cause FormatLine to be called, and 
                   when it hits the null printer dc it'll force a call 
                   to GetPrinterDC ..pault */
                
                FreePrinterDC();
                InvalidateRect(vhWnd, (LPRECT) NULL, fFalse);
#endif
                
                goto DestroyDlg;
                }

          case idiCancel:
            hszPrinter = *phszPr++;
            hszPrDriver = *phszPr++;
            hszPrPort = *phszPr;

DestroyDlg:
            /* Close the dialog box and enable any modeless dialog boxes. */
            OurEndDialog(hDlg, NULL);
            return(fTrue);  /* we processed the message */
            }
      }
    
    return(fFalse); /* if we got here we didn't process the message */
    }


void BuildPrSetupSz(szPrSetup, szPrinter, szPort)
CHAR *szPrSetup;
CHAR *szPrinter;
CHAR *szPort;
    {
    /* This routine pieces together the string for the Change Printers list box.
    szPrinter is the name of the printer, and szPort, the name of the port.  It
    is assumed that the setup string, szPrSetup, is large enough to hold the
    string created by this routine. */

    extern CHAR stBuf[];
    extern CHAR szNul[];

    CHAR *bltbyte(CHAR *, CHAR *, int);
    CHAR ChUpper(CHAR);

    register CHAR *pch;

    pch = bltbyte(szPrinter, szPrSetup, CchSz(szPrinter) - 1);
    FillStId(stBuf, IDSTROn, sizeof(stBuf));
    pch = bltbyte(&stBuf[1], pch, stBuf[0]);

    /* If the port name is not "None", then raise the port name to all capitals.
    */
    bltbyte(szPort, pch, CchSz(szPort));
    if (WCompSz(pch, szNul) != 0)
        {
        while (*pch != '\0')
            {
            *pch++ = ChUpper(*pch);
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\diaprint.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1990 Microsoft Corporation */
/************************************************************/

/* This file contains the dialog box routines for the print dialog box and the
printer initialization code. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOCLIPBOARD
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOWH
#define NOWNDCLASS
#define NOSOUND
#define NOCOLOR
#define NOSCROLL
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "dlgdefs.h"
#include "str.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "propdefs.h"


fnPrPrinter()
    {
    /* This routine is the outside world's interface to the print code. */

    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
    extern int docCur;
    CHAR rgbDlgBuf[sizeof(int) + 2 * sizeof(BOOL)];
#ifdef INEFFLOCKDOWN    
    extern FARPROC lpDialogPrint;
#else
    BOOL far PASCAL DialogPrint(HWND, unsigned, WORD, LONG);
    FARPROC lpDialogPrint;
    if (!(lpDialogPrint = MakeProcInstance(DialogPrint, hMmwModInstance)))
        {
        WinFailure();
        return;
        }
#endif

    vpDlgBuf = &rgbDlgBuf[0];
    switch (OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgPrint), hParentWw,
      lpDialogPrint))
        {
    case idiOk:
        /* Force all of the windows to clean up their act. */
        DispatchPaintMsg();

        /* At this point, we have the following :
            vfPrPages = true if print page range else print all pages
            vpgnBegin = starting page number (if vfPrPages)
            vpgnEnd   = ending page number (if vfPrPages)
            vcCopies  = number of copies to print */
        PrintDoc(docCur, TRUE);
        break;

    case -1:
        /* We didn't even have enough memory to create the dialog box. */
#ifdef WIN30
        WinFailure();
#else
        Error(IDPMTNoMemory);
#endif
        break;
        }
#ifndef INEFFLOCKDOWN    
    FreeProcInstance(lpDialogPrint);
#endif
    }


BOOL far PASCAL DialogPrint( hDlg, message, wParam, lParam )
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine handles input to the Print dialog box. */
    extern CHAR *vpDlgBuf;
    extern int vfPrPages;       /* true if print page range */
    extern int vpgnBegin;       /* starting page number to print */
    extern int vpgnEnd;         /* ending page number to print */
    extern int vcCopies;        /* nubmer of copies to print */
    extern BOOL vfPrinterValid;
    extern HDC vhDCPrinter;
    extern int vfDraftMode;
    extern HWND vhWndMsgBoxParent;
    extern ferror;
    extern HCURSOR vhcArrow;
    extern int vfCursorVisible;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];

    int *pidiRBDown = (int *)vpDlgBuf;
    BOOL *pfDraftMode = (BOOL *)(vpDlgBuf + sizeof(int));
    BOOL *pfDraftSupport = (BOOL *)(vpDlgBuf + sizeof(int) + sizeof(BOOL));
    int iEscape;
    CHAR szPrDescrip[cchMaxProfileSz];

    switch (message)
        {
    case WM_INITDIALOG:
        BuildPrSetupSz(szPrDescrip, &(**hszPrinter)[0], &(**hszPrPort)[0]);
        SetDlgItemText(hDlg, idiPrtDest, (LPSTR)szPrDescrip);
        SetDlgItemText(hDlg, idiPrtCopies, (LPSTR)"1");
        SelectIdiText(hDlg, idiPrtCopies);
        if (vfPrPages)
            {
            *pidiRBDown = idiPrtFrom;
            SetDlgItemInt(hDlg, idiPrtPageFrom, vpgnBegin, TRUE);
            SetDlgItemInt(hDlg, idiPrtPageTo, vpgnEnd, TRUE);
            }
        else
            {
            *pidiRBDown = idiPrtAll;
            }

        iEscape = DRAFTMODE;
        if (*pfDraftSupport = vfPrinterValid && vhDCPrinter && 
            Escape(vhDCPrinter, QUERYESCSUPPORT, sizeof(int), 
                   (LPSTR)&iEscape, (LPSTR)NULL))
            {
            CheckDlgButton(hDlg, idiPrtDraft, *pfDraftMode = vfDraftMode);
            }
        else
            {
            EnableWindow(GetDlgItem(hDlg, idiPrtDraft), FALSE);
            if (!vhDCPrinter) /* we've got a timing thing whereby they
                                 managed to get into the print dialog
                                 inbetween the time printer.setup had
                                 unhooked the old printer and the hookup
                                 of the new one!  ..pault */
            EnableWindow(GetDlgItem(hDlg, idiOk), FALSE);
            }

        CheckDlgButton(hDlg, *pidiRBDown, TRUE);
        EnableOtherModeless(FALSE);
        break;

    case WM_SETVISIBLE:
        if (wParam)
            {
            EndLongOp(vhcArrow);
            }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        return (FALSE);

    case WM_COMMAND:
        switch (wParam)
            {
            BOOL fPages;
            int pgnBegin;
            int pgnEnd;
            int cCopies;

        case idiOk:
            if (fPages = (*pidiRBDown == idiPrtFrom))
                {
                /* Get the range of pages to print. */
                if (!WPwFromItW3Id(&pgnBegin, hDlg, idiPrtPageFrom,
                    pgnMin, pgnMax, wNormal, IDPMTNPI))
                    {
                    /* Reset error condition, so as to report any further error.
                    */
                    ferror = FALSE;
                    return(TRUE);
                    }
                if (!WPwFromItW3Id(&pgnEnd, hDlg, idiPrtPageTo,
                    pgnMin, pgnMax, wNormal, IDPMTNPI))
                    {
                    /* Reset error condition, so as to report any further error.
                    */
                    ferror = FALSE;
                    return(TRUE);
                    }
                }

            /* Get the number of copies to print. */
            if (!WPwFromItW3IdFUt(&cCopies, hDlg, idiPrtCopies, 1, 32767,
              wNormal, IDPMTNPI, FALSE, 0
            ))
                {
                /* Reset error condition, so as to report any further error. */
                ferror = FALSE;
                return(TRUE);
                }

        /* If we have gotten this far, then everything must be okey-dokey.
        */
            vfDraftMode = *pfDraftSupport ? *pfDraftMode : FALSE;
            if (vfPrPages = fPages)
                {
                vpgnBegin = pgnBegin;
                vpgnEnd = pgnEnd;
                }
            vcCopies = cCopies;

        case idiCancel:
            OurEndDialog(hDlg, wParam);
            break;

        case idiPrtPageFrom:
        case idiPrtPageTo:
            if (HIWORD(lParam) == EN_CHANGE)
                {
                if (SendMessage(LOWORD(lParam), WM_GETTEXTLENGTH, 0, 0L) &&
                  *pidiRBDown != idiPrtFrom)
                    {
                    CheckDlgButton(hDlg, *pidiRBDown, FALSE);
                    CheckDlgButton(hDlg, *pidiRBDown = idiPrtFrom, TRUE);
                    }
                return(TRUE);
                }
            return(FALSE);

        case idiPrtAll:
        case idiPrtFrom:
            CheckDlgButton(hDlg, *pidiRBDown, FALSE);
            CheckDlgButton(hDlg, *pidiRBDown = wParam, TRUE);

	    // set focus to the edit field automatically

	    if (wParam == idiPrtFrom)
	    	SetFocus(GetDlgItem(hDlg, idiPrtPageFrom));

            break;

        case idiPrtDraft:
            CheckDlgButton(hDlg, wParam, *pfDraftMode = !(*pfDraftMode));
            break;

        default:
            return(FALSE);
            }
        break;

    default:
        return(FALSE);
        }
    return(TRUE);
    }


BOOL FInitHeaderFooter(fHeader, ppgn, phrgpld, pcpld)
BOOL fHeader;
unsigned *ppgn;
struct PLD (***phrgpld)[];
int *pcpld;
    {
    /* This routine initializes the array of print line descriptors used in
    positioning the header/footer on the printed page.  FALSE is returned if an
    error occurs; TRUE otherwise. */

    extern typeCP cpMinHeader;
    extern typeCP cpMacHeader;
    extern typeCP cpMinFooter;
    extern typeCP cpMacFooter;
    extern int docCur;
    extern struct PAP vpapAbs;
    extern struct SEP vsepAbs;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern int dxpPrPage;
    extern int dxaPrPage;
    extern int dypPrPage;
    extern int dyaPrPage;
    extern struct FLI vfli;
    extern int vfOutOfMemory;

    typeCP cpMin;
    typeCP cpMac;

    /* Get the cpMin and the cpMac for the header/footer. */
    if (fHeader)
        {
        cpMin = cpMinHeader;
        cpMac = cpMacHeader;
        }
    else
        {
        cpMin = cpMinFooter;
        cpMac = cpMacFooter;
        }

    /* Is there a header/footer. */
    if (cpMac - cpMin > ccpEol)
        {
        int cpld = 0;
        int cpldReal = 0;
        int cpldMax;
        int xp;
        int yp;
        int ichCp = 0;
        typeCP cpMacDoc = CpMacText(docCur);

        /* Compute the page number of the start of the headers/footers. */
        CacheSect(docCur, cpMin);
        if ((*ppgn = vsepAbs.pgnStart) == pgnNil)
            {
            *ppgn = 1;
            }

        /* Does the header/footer appear on the first page. */
        CachePara(docCur, cpMin);
        if (!(vpapAbs.rhc & RHC_fFirst))
            {
            (*ppgn)++;
            }

        /* Calculate the bounds of the header/footer in pixels. */
        xp = MultDiv(vsepAbs.xaLeft - dxaPrOffset, dxpPrPage, dxaPrPage);
        yp = fHeader ? MultDiv(vsepAbs.yaRH1 - dyaPrOffset, dypPrPage,
          dyaPrPage) : 0;

        /* Initialize the array of print line descriptors for the header/footer.
        */
        if (FNoHeap(*phrgpld = (struct PLD (**)[])HAllocate((cpldMax = cpldRH) *
          cwPLD)))
            {
            *phrgpld = NULL;
            return (FALSE);
            }

        /* We now have to calculate the array of print line descriptors for the
        header/footer. */
        cpMac -= ccpEol;
        while (cpMin < cpMac)
            {
            /* Format this line of the header/footer for the printer. */
            FormatLine(docCur, cpMin, ichCp, cpMacDoc, flmPrinting);

            /* Bail out if an error occurred. */
            if (vfOutOfMemory)
                {
                return (FALSE);
                }

            /* Is the array of print line descriptors big enough? */
            if (cpld >= cpldMax && !FChngSizeH(*phrgpld, (cpldMax += cpldRH) *
              cwPLD, FALSE))
                {
                return (FALSE);
                }

            /* Fill the print line descriptor for this line. */
                {
                register struct PLD *ppld = &(***phrgpld)[cpld++];

                ppld->cp = cpMin;
                ppld->ichCp = ichCp;
                ppld->rc.left = xp + vfli.xpLeft;
                ppld->rc.right = xp + vfli.xpReal;
                ppld->rc.top = yp;
                ppld->rc.bottom = yp + vfli.dypLine;
                }

            /* Keep track of the non-blank lines in the header/footer */
            if ((vfli.ichReal > 0) || vfli.fGraphics)
                {
                cpldReal = cpld;
                }

            /* Bump the counters. */
            cpMin = vfli.cpMac;
            ichCp = vfli.ichCpMac;
            yp += vfli.dypLine;
            }

        /* If this is a footer, then we have to move the positions of the lines
        around so that the footer ends where the user has requested. */
        if (!fHeader && cpldReal > 0)
            {
            register struct PLD *ppld = &(***phrgpld)[cpldReal - 1];
            int dyp = MultDiv(vsepAbs.yaRH2 - dyaPrOffset, dypPrPage, dyaPrPage)
              - ppld->rc.bottom;
            int ipld;

            for (ipld = cpldReal; ipld > 0; ipld--, ppld--)
                {
                ppld->rc.top += dyp;
                ppld->rc.bottom += dyp;
                }
            }

        /* Record the number of non-blank lines in the head/footer. */
        *pcpld = cpldReal;
        }
    else
        {
        /* Indicate there is no header/footer. */
        *ppgn = pgnNil;
        *phrgpld = NULL;
        *pcpld = 0;
        }
    return (TRUE);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\diasubs.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NORASTEROPS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDI
#define NOSCROLL
#define NOOPENFILE
#define NOWNDCLASS
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOICON
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOPEN
#define NOBRUSH
#define NODRAWTEXT
#define NOFONT
#define NOMETAFILE
#define NOSOUND
#define NOCOLOR
#define NOCOMM

#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "str.h"
#include "editdefs.h"
#define NOKCCODES
#include "ch.h"
#include "dlgdefs.h"

/*extern int		  idstrUndoBase;*/
extern struct UAB	vuab;
extern int		vfCursorVisible;
extern HCURSOR		vhcArrow;


#ifdef BOGUS /* use WPwFromItW3Id */
BOOL FValidIntFromDlg(hDlg, idi, fSigned, wMin, wMax, pw, idpmt)
HANDLE hDlg;	       /* handle to dialog box */
int    idi;	       /* id of control in dialog box */
BOOL   fSigned;        /* check for sign if true */
int    wMin, wMax;     /* range of valid integer value */
int *  pw;	       /* location to put the int */
int    idpmt;	       /* error message number */
{
    REG1 int wVal;
    BOOL fValOk;

    *pw = wVal = GetDlgItemInt(hDlg, idi, (BOOL far *)&fValOk, fSigned);
    if (fValOk)
	{ /* check range */
	if ((wVal < wMin) || (wVal > wMax))
	    fValOk = false;
	}
    if (!fValOk)
	{
	Error(idpmt);
	SelectIdiText(hDlg, idi);
	SetFocus(GetDlgItem(hDlg, idi));
	}
    return fValOk;
} /* FValidIntFromDlg */
#endif


FPwPosIt(pw, hDlg, it)
HWND hDlg; /* handle to desired dialog box */
int *pw;
int it;
{
    /*-------------------------------------------------------------------
	Purpose:    Positive integer dialog item.
    --------------------------------------------------------------mck--*/
    return(WPwFromItW3IdFUt(pw, hDlg, it, 0, 32767, wNormal, IDPMTNPI, fFalse, 0));
}


WPwFromItW3Id(pw, hDlg, it, wMin, wMax, wMask, id)
HWND hDlg;  /* handle to desired dialog box */
int *pw;    /* Return value */
int it;     /* Item number */
int wMin;   /* Smallest and largest allowed values */
int wMax;
int wMask;  /* Bit mask for allowed variations */
int id;     /* Id of error string if bad */
{
    /*-------------------------------------------------------------------
	Purpose:    General integer dialog item.
    --------------------------------------------------------------mck--*/
    return(WPwFromItW3IdFUt(pw, hDlg, it, wMin, wMax, wMask, id, fFalse, 0));
}

FPdxaPosIt(pdxa, hDlg, it)
HWND hDlg; /* handle to desired dialog box */
int *pdxa;
int it;
{
    /*-------------------------------------------------------------------
	Purpose:    Positive dxa dialog item.
    --------------------------------------------------------------mck--*/
    extern int utCur;

    return(WPwFromItW3IdFUt(pdxa, hDlg, it, 0, 32767, wNormal, IDPMTNPDXA, fTrue, utCur));
}

FPdxaPosBIt(pdxa, hDlg, it)
HWND hDlg; /* handle to desired dialog box */
int *pdxa;
int it;
{
    /*-------------------------------------------------------------------
	Purpose:    Positive dxa dialog item (blank allowed).
    --------------------------------------------------------------mck--*/
    extern int utCur;

    return(WPwFromItW3IdFUt(pdxa, hDlg, it, 0, 32767, wBlank | wSpaces, IDPMTNPDXA, fTrue, utCur));
}

WPdxaFromItDxa2WId(pdxa, hDlg, it, dxaMin, dxaMax, wMask, id)
HWND hDlg;    /* handle to desired dialog box */
int *pdxa;    /* Return value */
int it;       /* Dialog item number */
int dxaMin;   /* Range of allowable measurements */
int dxaMax;
int wMask;    /* Bit mask for allowed variations */
int id;       /* Error id */
{
    /*-------------------------------------------------------------------
	Purpose:    General dxa dialog item.
    --------------------------------------------------------------mck--*/
    extern int utCur;

    return(WPwFromItW3IdFUt(pdxa, hDlg, it, dxaMin, dxaMax, wMask, id, fTrue, utCur));
}

WPwFromItW3IdFUt(pw, hDlg, it, wMin, wMax, wMask, id, fDxa, ut)
int *pw;      /* Return value */
HWND hDlg;    /* handle to desired dialog box */
int it;       /* Item number */
int wMin;     /* Smallest and largest allowed values */
int wMax;
int wMask;    /* Bit mask for allowed variations */
int id;       /* Id of error string if out of range */
int fDxa;     /* Parse as dxa (otherwise int) */
int ut;       /* Units to use as default if fDxa */
{
    /*-------------------------------------------------------------------
	Purpose:    Parse the item in the current dialog.  Must be a valid
		    integer or dxa in the given range.
	Method:     - Get the text string.
		    - Try parse as "".
		    - Try parse as string of all spaces
		    - Parse as a int/dxa (generic error if can't).
		    - Test for ".5".
		    - Compare with min and max.
		    - Try parse as "Auto".
		    - If out of bounds, use id to put up specific error
		      (with strings of min and max as parameters).
	Returns:    The return value may be used as a boolean or as a word.
		    fFalse (0) -> not parsed
		    wNormal (1) -> parsed normally
		    wBlank (2) -> parsed a null line
					   (*pw is valNil)
		    wAuto (4) -> parsed as "Auto" (*pw is 0)
		    wSpaces (16) -> parsed a line of all
					   spaces (*pw is valNil)

		    !fDxa only:
		    wDouble (8) -> parsed with ".5" trailing

	Note:	     The interval [wMin..wMax] is closed.
	Note:	     Return value is doubld the parsed value when wDouble.
	Note:	     When wDouble, 2*wMin and 2*wMax must be valid ints.
	Note:	     Numbers ending in .5 may have no trailing spaces.
	History:
	     6/18/86:	 Adapted for trailing kanji spaces --- yxy
	    07/03/85:	 Added wSpaces return
	    10/23/84:	 Fixed wAuto to return with *pw == 0.
	    10/ 5/84:	 Added ut parameter.
	    10/ 5/84:	 Added wMask and combined dxa and w parsing.
	     9/26/84:	 Created.
    --------------------------------------------------------------mck--*/

    CHAR *pch;		/* Parse pointer */
    CHAR *pchEnd;	/* End of buffer */
    CHAR *pchError;	/* Position of parse error */
    int fParsed;	/* Parses as number/dxa */
    int fOverflow = fFalse; /* True if the number is parsed but it overflow */
    int wGood = wNormal;/* return after good range check */
    CHAR stItem[32];
#ifdef AUTO_SPACING
    CHAR szAuto[32];	/* Hold "Auto" string */
#endif

    /* Get the dialog text */
    stItem[0] = GetDlgItemText(hDlg, it, (LPSTR)&stItem[1], sizeof(stItem)-1);

    /* See if blank (null line) */
    if (wMask & wBlank && stItem[0] == 0)
	{
	*pw = valNil;
	return(wBlank);
	}

    pch = &stItem[1];

    /* See if all spaces  */
    if (wMask & wBlank && wMask & wSpaces)
	{
	int fAllSpaces = fTrue;

	while (*pch != 0)
	   if (*pch++ != ' ')
	       {
	       fAllSpaces = fFalse;
	       break;
	       }
	if (fAllSpaces == fTrue)
	    {
	    *pw = valNil;
	    return(wSpaces);
	    }
	}

    pch = &stItem[1];
    pchEnd = pch + stItem[0];

    /* It parses as a number ... */
    fParsed = fDxa ? FZaFromSs(pw, stItem+1, *stItem, ut)
		   : FPwParsePpchPch(pw, &pch, pchEnd, &fOverflow);

    if (!fDxa && wMask & wDouble)
	{
	(*pw) *= 2;
	wMin *= 2;
	wMax *= 2;
	if (!fParsed)
	    {
	    /* Check if ".5" was reason for bad parse. */
	    if (pch != pchEnd && *pch == '.')
	       {
		pch++;
		/* Allow "ddddd.0*" */
		pchError = pch;
		if (FAllZeroPpchPch(&pchError, pchEnd))
		    fParsed = fTrue;
		/* Allow "ddddd.50*" */
		else if (pch != pchEnd && *pch == '5' &&
			 (pch++, FAllZeroPpchPch(&pch, pchEnd)))
		    {
		    (*pw)++;
		    fParsed = fTrue;
		    wGood = wDouble;
		    }
		/* Mark furthest error condition */
		else if (pchError > pch)
		    pch = pchError;
		}
	    }
	}

    if (fParsed && !fOverflow)
	{
	/* ... and in range */
	if (*pw >= wMin && *pw <= wMax)
	    return(wGood);
#ifdef ENABLE
	/* ... but out of range - no matter what, we will use the supplied
	   id for the error message to be consistant */
	else
	    {
	    SelectIdiText(hDlg, it);
	    SetFocus(GetDlgItem(hDlg, it));
	    Error(id);
	    return(fFalse);
	    }
#endif /* ENABLE */
	}

#ifdef AUTO_SPACING
    /* Invariant: Field does not parse as a number */

    /* Try "Auto" */
    if (wMask & wAuto)
	{
	pch = PchFillPchId(szAuto, IDSTRVaries, sizeof(szAuto));
	*pch = '\0';
	stItem[stItem[0]+1] = '\0';
	if (WCompSz(szAuto, &stItem[1]) == 0)
	    {
	    *pw = 0;
	    return(wAuto);
	    }
	}
#endif /* AUTO_SPACING */

    /* All attempts failed - show user where he went wrong vis the attempted
       number parse. */
    {
    unsigned cchStart = fParsed ? 0 : pch - &stItem[1];
    unsigned cchEnd = 32767;
    int idError = fDxa ? IDPMTNOTDXA : IDPMTNOTNUM;

    if (fParsed)
	idError = id; /* reset idError if we just overflow or fail the range test */
    SendDlgItemMessage(hDlg, it, EM_SETSEL, (WORD)NULL, MAKELONG(cchStart, cchEnd));
    SetFocus(GetDlgItem(hDlg, it));
    Error(idError);
    return(fFalse);
    }
}

FAllZeroPpchPch(ppch, pchMax)
CHAR **ppch;	    /* Bound of character buffer */
CHAR *pchMax;
{
    /*-------------------------------------------------------------------
	Purpose:    Make sure all characters in buffer are spaces or 0's.
	Returns:    *ppch contains first bad character if fFalse returned.
	History:
	     6/18/86:	 Adapted for Kanji chars --- yxy
	    10/ 9/84:	 Created.
    --------------------------------------------------------------mck--*/
    CHAR *pch = *ppch;

    while (pch < pchMax) {
	if (*pch == '0' || *pch == ' ')
	    pch++;
	else {
	    *ppch = pch;
	    return(fFalse);
	}
    }
    return(fTrue);
}

FPwParsePpchPch(pw, ppch, pchMax, pfOverflow)
int *pw;
CHAR **ppch;
CHAR *pchMax;
int *pfOverflow;
{
    /*-------------------------------------------------------------------
	Purpose:    Parse a number in the given buffer.
	Method:        Scan for digits and ignore white space.
	Returns:    Character pointer past last one read in *ppch.
		    Number parsed is returned.	Note that if only a prefix is
		    a valid number we return false, with *ppch set to the
		    first offending character.
	Modification History:
	    06/18/86 ---- Adapted for a kanji space char. --- yxy
    --------------------------------------------------------------mck--*/
#define smInit 0
#define smDig 1
#define smBody 2

    CHAR *pch = *ppch;	    /* Local buffer pointer */
    unsigned int ch;	    /* Character being examined */
    int fNeg = fFalse;
    DWORD dwNum = 0L;
    int fError = fFalse;
    int sm = smInit;

    *pfOverflow = fFalse;
    while (!fError && !(*pfOverflow) && pch < pchMax) {
	ch = *pch;
	if (ch == chSpace)
	    pch++;
	else
	    switch (sm) {
	case smInit:
	    if (ch == '-') {
		fNeg = fTrue;
		pch++;
	    }
	    sm = smDig;
	    break;
	case smDig:
	    if (isdigit(ch))
		sm = smBody;
	    else
		fError = fTrue;
	    break;
	case smBody:
	    if (isdigit(ch)) {
		/* Overflow? */
		if ((dwNum = 10*dwNum + WFromCh(ch)) > 0x7FFF)
		    *pfOverflow = fTrue;
		else
		    pch++;
	    }
	    else
		fError = fTrue;
	    break;
	}
    }

    *ppch = pch;
    *pw = (int)(fNeg ? -dwNum : dwNum);
    return(!fError);
}


EnableOtherModeless(fEnable)
BOOL fEnable;
{
extern HWND   vhDlgChange;
extern HWND   vhDlgFind;
extern HWND   vhDlgRunningHead;

/* Disable or enable other modeless dialog boxes according to fEnable */

if (IsWindow(vhDlgFind))
    {
    EnableWindow(vhDlgFind, fEnable);
    }
if (IsWindow(vhDlgChange))
    {
    EnableWindow(vhDlgChange, fEnable);
    }
if (IsWindow(vhDlgRunningHead))
    {
    EnableWindow(vhDlgRunningHead, fEnable);
    }
}


SelectIdiText(hDlg, idi)
HWND hDlg;
int  idi;
{ /* For the dialog box with handle hDlg, highlight the text of the control
     with ID idi */
    unsigned cchStart = 0;
    unsigned cchEnd = 0x7fff;
    SendDlgItemMessage(hDlg, idi, EM_SETSEL, (WORD)NULL, MAKELONG(cchStart, cchEnd));
} /* end of SelectIdiText */


#ifdef ENABLE
SetRgvalAgain(rgvalLocal, uac)
VAL    rgvalLocal[];
int    uac;
    {
    extern VAL rgvalAgain[];

    blt(rgvalLocal, rgvalAgain, ivalMax * cwVal);
    switch (vuab.uac = uac)
	{
    case uacFormatPara:
    case uacFormatChar:
    case uacFormatSection:
/*	  idstrUndoBase = IDSTRUndoBase;*/
/*	  SetUndoMenuStr(IDSTRUndoCom);*/
	SetUndoMenuStr(IDSTRUndoBase);
	break;
	}
    }
#endif


#ifdef CASHMERE
PushRadioButton(hDlg, idiFirst, idiLast, idiPushed)
HWND hDlg;
int idiFirst, idiLast, idiPushed;
{
    /*
    Push radio button idiPushed and unpush all others in the radio group
    bounded by idiFirst and idiLast.
    */
    int idi;

    for (idi = idiFirst; idi <= idiLast; idi++)
	CheckDlgButton(hDlg, idi, idi == idiPushed);
}


SetRadValue(hDlg, idiFirst, idiLast, idiRad)
HWND hDlg;
int  idiFirst, idiLast, idiRad;
{
    /*
    Set the (zero-based) idiRad'th item in the radio group
    bounded by idiFirst and idiLast.
    */
    PushRadioButton(hDlg, idiFirst, idiLast, idiFirst + idiRad);
}

#endif /* CASHMERE */


#ifdef ENABLE
BOOL far PASCAL DialogConfirm(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This is the Dialog function for all dialog boxes with only "Yes", "No",
    and "Cancel" boxes; this includes:	Save Large Scrap */

    extern HWND vhWndMsgBoxParent;

    switch (message)
	{
    case WM_INITDIALOG:
	EnableOtherModeless(FALSE);
	break;

    case WM_SETVISIBLE:
	if (wParam)
	    EndLongOp(vhcArrow);
	return(FALSE);

    case WM_ACTIVATE:
	if (wParam)
	    {
	    vhWndMsgBoxParent = hDlg;
	    }
	if (vfCursorVisible)
	    ShowCursor(wParam);
	return(FALSE); /* so that we leave the activate message to
	the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
	switch (wParam)
	    {
	    /* The default button is NO, make sure the call routine realized
	   that idiOk should be treated as idiNo. */
	case idiOk:
	case idiCancel:
	case idiYes:
	case idiNo:
	    OurEndDialog(hDlg, wParam);
	    break;
	default:
	    Assert(FALSE);
	    break;
	    }
	break;

    default:
	return(FALSE);
	}
    return(TRUE);
    } /* end of DialogConfirm */
#endif /* ENABLE */


#ifndef WIN30
/* DialogBox has been fixed so it automatically brings up the hourglass! */

OurDialogBox(hInst, lpstr, hWndParent, lpProc)
HANDLE hInst;
LPSTR lpstr;
HWND hWndParent;
FARPROC lpProc;
{
StartLongOp();
return(DialogBox(hInst, lpstr, hWndParent, lpProc));
}
#endif


OurEndDialog(hDlg, wParam)
    {
    /* This routine does the same standard things Write does everytime it closes
    a dialog box. */

    extern HWND hParentWw;
    extern long ropErase;
    extern HWND vhWndMsgBoxParent;
    extern HCURSOR vhcIBeam;

    RECT rc;
    POINT pt;

#ifdef NO_NEW_CALL
    /* Close down the dialog box and erase it from the screen.	We tried to let
    Windows do the erasing, but...  Its a long story. */
    GetWindowRect(hDlg, (LPRECT)&rc);
    pt.x = pt.y = 0;
    ClientToScreen(hParentWw, (LPPOINT)&pt);
#endif

    EndDialog(hDlg, wParam);

#ifdef NO_NEW_CALL
    PatBlt(GetDC(hParentWw), rc.left - pt.x, rc.top - pt.y, rc.right - rc.left,
      rc.bottom - rc.top, ropErase);
#endif

    /* Enable any existing dialog boxes and indicate that any error messages
    belong to the document window. */
    EnableOtherModeless(TRUE);
    vhWndMsgBoxParent = (HWND)NULL;
#ifndef WIN30
    EndLongOp(vhcIBeam);    /* See StartLongOp() above */
#endif
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\diarepag.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the dialog routines for the repagination code. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "editdefs.h"
#include "printdef.h"
#include "docdefs.h"
#include "dlgdefs.h"
#include "propdefs.h"
#define NOKCCODES
#include "ch.h"
#include "str.h"

#ifndef INEFFLOCKDOWN
BOOL far PASCAL DialogRepaginate(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogSetPage(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogPageMark(HWND, unsigned, WORD, LONG);
#endif

fnRepaginate()
    {
    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
#ifdef INEFFLOCKDOWN    
    extern FARPROC lpDialogRepaginate;
#else
    FARPROC lpDialogRepaginate = MakeProcInstance(DialogRepaginate, hMmwModInstance);
#endif
    extern BOOL vfPrErr;
    extern int vfRepageConfirm;
    extern struct SEL selCur;
    extern int docCur;
    extern int vfSeeSel;
    extern int vfOutOfMemory;

    CHAR rgbDlgBuf[sizeof(BOOL)];
    struct SEL selSave;

#ifndef INEFFLOCKDOWN
    if (!lpDialogRepaginate)
        {
        WinFailure();
        return;
        }
#endif    
    /* Create the repaginate dialog box. */
    vpDlgBuf = &rgbDlgBuf[0];
    switch (OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgRepaginate),
      hParentWw, lpDialogRepaginate))
        {
    case idiOk:
        /* Use the print code to repaginate a document. */
        DispatchPaintMsg();

	/* If memory failure occurred, then punt. */
	if (!vfOutOfMemory)
	    {
	    if (vfRepageConfirm)
		{
		/* Save the selection so we can restore it if an error occurs.
		*/
		bltbyte(&selCur, &selSave, sizeof(struct SEL));

		/* Set up the undo block. */
		SetUndo(uacRepaginate, docCur, cp0, CpMacText(docCur), docNil,
		  cpNil, cpNil, 0);
		}

	    /* Repaginate the document. */
	    PrintDoc(docCur, FALSE);

	    if (vfRepageConfirm && vfPrErr)
		{
		/* An error occurred; therefore, set the world back to the way
		we found it. */
		CmdUndo();

		/* Reset the selection. */
		ClearInsertLine();
		Select(selSave.cpFirst, selSave.cpLim);
		vfSeeSel = TRUE;

		/* Sorry, but docUndo has been clobbered and there is no way to
		reset it. */
		NoUndo();
		}
	    }
        break;

    case -1:
        /* We didn't even have enough memory to create the dialog box. */
#ifdef WIN30
        WinFailure();
#else
        Error(IDPMTNoMemory);
#endif
        break;
        }
#ifndef INEFFLOCKDOWN
    if (lpDialogRepaginate)
        FreeProcInstance(lpDialogRepaginate);
#endif
    }


BOOL far PASCAL DialogRepaginate(hDlg, code, wParam, lParam)
HWND hDlg;
unsigned code;
WORD wParam;
LONG lParam;
    {
    extern CHAR *vpDlgBuf;
    extern BOOL vfRepageConfirm;
    extern HWND vhWndMsgBoxParent;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;

    BOOL *pfConfirm = (BOOL *)vpDlgBuf;

    switch (code)
        {
    case WM_INITDIALOG:
        EnableOtherModeless(FALSE);
        CheckDlgButton(hDlg, idiRepageConfirm, *pfConfirm = vfRepageConfirm);
        break;

    case WM_SETVISIBLE:
        if (wParam)
	    {
            EndLongOp(vhcArrow);
	    }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            }
         if (vfCursorVisible)
             {
             ShowCursor(wParam);
             }
         return(FALSE);

    case WM_COMMAND:
        switch (wParam)
            {
        case idiOk:
            vfRepageConfirm = IsDlgButtonChecked(hDlg, idiRepageConfirm);
        case idiCancel:
            OurEndDialog(hDlg, wParam);
            break;

        case idiRepageConfirm:
            CheckDlgButton(hDlg, idiRepageConfirm, *pfConfirm = !*pfConfirm);
            break;

        default:
            return(FALSE);
            break;
            }
        break;

    default:
        return(FALSE);
        }
    return(TRUE);
    }


BOOL FSetPage()
    {
    /* This routine prompts the user for a new position for each page break.
    The variable ipldCur is set to point to the print line the user wants as
    the first line of the next page.  TRUE is returned if the user hits the
    "Confirm" button on the dialog box; FALSE if the "Cancel" button is hit. */

    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
    extern int docCur;
#ifdef INEFFLOCKDOWN
    extern FARPROC lpDialogSetPage;
#else
    FARPROC lpDialogSetPage = MakeProcInstance(DialogSetPage, hMmwModInstance);
#endif
    extern int vfOutOfMemory;
    extern int vfPrErr;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;
    typeCP cp;

#ifndef INEFFLOCKDOWN
    if (!lpDialogSetPage)
        goto LSPErr;
#endif

    /* Show the user where we think the page break should be.  The AdjustCp()
    call is a kludge to force the redisplay of the first line of the page. */
    AdjustCp(docCur, cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp, (typeCP)1,
      (typeCP)1);
    ClearInsertLine();
    Select(cp, CpLimSty(cp, styLine));
    PutCpInWwHz(cp);
    if (vfOutOfMemory)
	{
Abort:
	/* If memory failure occurred, then punt. */
	vfPrErr = TRUE;
        return (FALSE);
        }

    /* Now, we can create the Set Page dialog box. */
    if (DialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgSetPage), hParentWw,
      lpDialogSetPage) == -1)
        {
        /* We didn't even have enough memory to create the dialog box. */
LSPErr:        
        Error(IDPMTPRFAIL);
        goto Abort;
        }

#ifndef INEFFLOCKDOWN
    if (lpDialogSetPage)
        FreeProcInstance(lpDialogSetPage);
#endif
    
    /* Make sure all the windows have been refreshed. */
    DispatchPaintMsg();

    StartLongOp();
    if (vfOutOfMemory)
        {
        goto Abort;
        }

    /* If the user wishes to cancel the repagination, then the flag fCancel was
    set by the routine handling the message for the dialog box. */
    return (!ppdb->fCancel);
    }


BOOL far PASCAL DialogSetPage(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine processes message sent to the Set Page dialog box.  The only
    messages that are processed are up and down buttons, and confirm and cancel
    commands. */

    extern CHAR *vpDlgBuf;
    extern int docCur;
    extern typeCP vcpFirstParaCache;
    extern struct PAP vpapAbs;
    extern HWND hParentWw;
    extern HWND vhWndMsgBoxParent;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;

    register struct PDB *ppdb = (struct PDB *)vpDlgBuf;
    typeCP cp;

    switch (message)
        {
    case WM_COMMAND:
        switch (wParam)
            {
        case idiRepUp:
            /* Move the page mark towards the beginning of the document one
            line, if possible. */
            if (ppdb->ipldCur == 1)
                {
                beep();
                return (TRUE);
                }
            else
                {
                ppdb->ipldCur--;
                goto ShowMove;
                }

        case idiRepDown:
            /* Move the page mark towards the end of the document one line, if
            possible. */
            if (ppdb->ipldCur == ppdb->ipld)
                {
                beep();
                }
            else
                {
                ppdb->ipldCur++;
ShowMove:
                /* Reflect the movement of the page on the screen. */
                cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp;
                Select(cp, CpLimSty(cp, styLine));
                PutCpInWwHz(cp);
                }
            break;

        case idiCancel:
CancelDlg:
            /* Let the repaginate routine know that the user wishes to cancel
            it. */
            ppdb->fCancel = TRUE;

        case idiOk:
            /* Take down the dialog box. */
	    EnableWindow(hParentWw, TRUE);
            EndDialog(hWnd, NULL);
	    EnableWindow(hParentWw, FALSE);
            vhWndMsgBoxParent = (HWND)NULL;
            EndLongOp(vhcArrow);

            /* Save the changes made by the user. */
            if (!ppdb->fCancel && ppdb->ipldCur != ppdb->ipld)
                {
                /* The user has moved the page break; therefore, insert a new
                page break. */
                CHAR rgch[1];

                rgch[0] = chSect;
                CachePara(docCur, cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp++);
                InsertRgch(docCur, cp, rgch, 1, NULL, cp == vcpFirstParaCache ?
                  &vpapAbs : NULL);

                /* Erase the old page mark from the screen. */
                AdjustCp(docCur, (**ppdb->hrgpld)[ppdb->ipld].cp, (typeCP)1,
                  (typeCP)1);

                /* Ensure that the page table is correct. */
                (**ppdb->hpgtb).rgpgd[ppdb->ipgd].cpMin = cp + 1;
                }

            /* Change the selection to an insertion bar. */
            cp = (**ppdb->hrgpld)[ppdb->ipldCur].cp;
            Select(cp, cp);
            break;
            }

    case WM_SETVISIBLE:
        if (wParam)
            {
            EndLongOp(vhcArrow);
            }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hWnd;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_INITDIALOG:
        return (TRUE);

    case WM_CLOSE:
        goto CancelDlg;
        }

    return (FALSE);
    }


BOOL FPromptPgMark(cp)
typeCP cp;
    {
    /* This routine prompts the user to either remove or keep the page mark at
    cp.  The flag fRemove is set to TRUE if the user wishes to remove the mark;
    FALSE if he wishes to keep it.  FALSE is returned if the user decides to
    cancel the repagination; TRUE if he does not. */

    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern CHAR *vpDlgBuf;
    extern int docCur;
#ifdef INEFFLOCKDOWN
    extern FARPROC lpDialogPageMark;
#else
    FARPROC lpDialogPageMark = MakeProcInstance(DialogPageMark, hMmwModInstance);
#endif
    extern int vfOutOfMemory;
    extern int vfPrErr;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;
#ifndef INEFFLOCKDOWN
    if (!lpDialogPageMark)
        goto LPPMErr;
#endif

    /* This is a kludge to remove a possible page indicator on the line after
    the page mark. */
    AdjustCp(docCur, cp + 1, (typeCP)1, (typeCP)1);

    /* Show the user the page mark in question. */
    ClearInsertLine();
    Select(cp, cp + 1);
    PutCpInWwHz(cp);
    if (vfOutOfMemory)
	{
Abort:
	/* If memory failure occurred, then punt. */
	vfPrErr = TRUE;
#ifndef INEFFLOCKDOWN
        if (lpDialogPageMark)
            FreeProcInstance(lpDialogPageMark);
#endif
        return (FALSE);
        }

    /* Now, we can create the Page Mark dialog box. */
    if (DialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgPageMark), hParentWw,
      lpDialogPageMark) == -1)
        {
LPPMErr:        
        /* We didn't even have enough memory to create the dialog box. */
        Error(IDPMTPRFAIL);
	goto Abort;
        }
    StartLongOp();

    /* Make sure all the windows have been refreshed. */
    DispatchPaintMsg();
    if (vfOutOfMemory)
	{
	goto Abort;
        }

    /* Make the change requested by the user. */
    if (!ppdb->fCancel)
        {
        if (ppdb->fRemove)
            {
            /* Remove the page mark as the user has requested. */
            Replace(docCur, cp, (typeCP)1, fnNil, fc0, fc0);
            }
        else
            {
            /* This is a kludge to force the first line after the page mark to
            be redisplayed. */
            AdjustCp(docCur, cp + 1, (typeCP)1, (typeCP)1);

            /* Change the selection to a insertion bar. */
            Select(cp, cp);
            }
        }

#ifndef INEFFLOCKDOWN
    if (lpDialogPageMark)
        FreeProcInstance(lpDialogPageMark);
#endif
    /* If the user wishes to cancel the repagination, then the flag fCancel was
    set by the routine handling the message for the dialog box. */
    return (!ppdb->fCancel);
    }


BOOL far PASCAL DialogPageMark(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* The routine handles messages sent to the Page Mark dialog box.  The only
    meassages of interest are when either the "Cancel", "Keep", or "Remove"
    buttons are hit. */

    extern CHAR *vpDlgBuf;
    extern HWND hParentWw;
    extern HWND vhWndMsgBoxParent;
    extern int vfCursorVisible;
    extern HCURSOR vhcArrow;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;

    switch (message)
        {
    case WM_SETVISIBLE:
        if (wParam)
	    {
            EndLongOp(vhcArrow);
	    }
        return(FALSE);

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hWnd;
            }
        if (vfCursorVisible)
            {
            ShowCursor(wParam);
            }
        return(FALSE);

    case WM_INITDIALOG:
        return(TRUE);

    case WM_COMMAND:
        switch (wParam)
            {
        case idiCancel:
            ppdb->fCancel = TRUE;
            break;

        case idiKeepPgMark:
            ppdb->fRemove = FALSE;
            break;

        case idiRemovePgMark:
            ppdb->fRemove = TRUE;
            break;

        default:
            return (FALSE);
            }
        break;

    case WM_CLOSE:
        ppdb->fCancel = TRUE;
        break;

    default:
        return (FALSE);
        }

    /* Take down the dialog box. */
    EnableWindow(hParentWw, TRUE);
    EndDialog(hWnd, NULL);
    EnableWindow(hParentWw, FALSE);
    vhWndMsgBoxParent = (HWND)NULL;
    EndLongOp(vhcArrow);
    return (TRUE);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\diapara.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* DiaPara.c -- Paragraph Format dialog box specific routines */
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#define NOSCROLL
#define NOCOLOR
#define NOBITMAP
#define NOFONT
#define NODRAWTEXT
#define NOMSG
#define NOWNDCLASS
#define NOKEYSTATE
#define NORASTEROPS
#define NOGDI
#define NOBRUSH
#define NOPEN
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "editdefs.h"
#include "dlgdefs.h"
#include "dispdefs.h"
#include "str.h"
#include "wwdefs.h"

extern struct WWD *pwwdCur;
extern HANDLE hParentWw;
extern struct PAP vpapAbs;
extern struct PAP *vppapNormal;
extern int rgval[];
extern typeCP cpMacCur;
extern int utCur;
extern struct SEL selCur; /* Current selection (i.e., sel in current ww */
extern int docCur; /* Document in current ww */
extern CHAR stBuf[];
extern HWND vhWndMsgBoxParent;
extern int vfCursorVisible;
extern HCURSOR vhcArrow;

#ifdef RULERALSO /* enable out because no need to bring ruler up when tab or indents is invoked */
extern int docRulerSprm;
extern struct TBD rgtbdRuler[];
extern HWND vhDlgIndent;
extern BOOL vfDisableMenus;
extern int vfTabsChanged;
extern int vfTempRuler;
extern struct WWD rgwwd[];
#endif


#ifdef CASHMERE
/* D O	F O R M A T  P A R A */
DoFormatPara(rgval)
VAL rgval[];
	/* add para sprms */

	int val, ival;
	int *pval;
	int sprm;
	struct PAP *ppap;
	typeCP dcp;
	typeCP cpFirst, cpLim;
	struct SEL selSave;
/* this temp array is used to assemble sprm values */
	CHAR rgb[cchTBD * itbdMax + 2/* >> cwPAPBase */];
	int rgw[cwPAPBase];
	ppap = (struct PAP *)&rgw[0];

	if (!FWriteCk(fwcNil))
		return; /* Check for munging end mark in footnote window */

	if (docRulerSprm != docNil) ClearRulerSprm();
	ExpandCurSel(&selSave);

	dcp = (cpLim = selCur.cpLim) - (cpFirst = selCur.cpFirst);
	if (cpLim > cpMacCur)
		{
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp - ccpEol, 0);
		InsertEolInsert(docCur, cpMacCur);
		}
	else
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp, 0);
/* reset adjusted selCur */
	selCur.cpFirst = cpFirst;
	selCur.cpLim = cpLim;


/* any gray fields ? */
	for (ival = 0; ival <= 8; ival++)
		if (rgval[ival] == valNil)
			{
/* yes. generate sprms for any that are not gray */
			for (ival = 0; ival <= 8; ival++)
				if ((val = rgval[ival]) != valNil)
					{
					switch(ival)
						{
					case 0:
						sprm = sprmPJc;
						goto LPara1;
					case 1:
						val = !val;
						sprm = sprmPKeep;
						goto LPara1;
					case 2:
						sprm = sprmPLMarg;
						break;
					case 3:
						sprm = sprmPFIndent;
						break;
					case 4:
						sprm = sprmPRMarg;
						break;
					case 5:
						sprm = sprmPDyaLine;
						break;
					case 6:
						sprm = sprmPDyaBefore;
						break;
					case 7:
						sprm = sprmPDyaAfter;
						break;
					case 8:
						val = !val;
						sprm = sprmPKeepFollow;
						goto LPara1;
						}
/* we come here with one word value */
					bltbyte(&val, &rgb[1], cchINT);
					goto LPara2;
/* we come here with one char value */
LPara1: 	    rgb[1] = val;
LPara2: 	    rgb[0] = sprm;
					AddSprm(rgb);
					}
			goto ParaCommon;
			}
/* otherwise generate a sprm that applies all properties except the tabs */
	blt(vppapNormal, ppap, cwPAPBase);
	pval = &rgval[0];
	ppap->jc = *pval++;
	ppap->fKeep = !*pval++;
	ppap->dxaLeft = *pval++;
	ppap->dxaLeft1 = *pval++;
	ppap->dxaRight = *pval++;
	ppap->dyaLine = *pval++;
	ppap->dyaBefore = *pval++;
	ppap->dyaAfter = *pval++;
	ppap->fKeepFollow = !*pval++;
	bltbyte(ppap, &rgb[2], cwPAPBase * cchINT);
	rgb[1] = cwPAPBase * cchINT;
/* we have: sprm, rgb[1 - n] set up */
	rgb[0] = sprmPSame;
	CachePara(docCur, selCur.cpFirst);
	if (CchDiffer(&vpapAbs, ppap, cwPAPBase * cchINT))
		AddSprm(rgb);
ParaCommon: ;
	if (vfTabsChanged)
		{
		int itbd;
		int cchRgtbd;
/* some tab changes were also made in the ruler */
		for (itbd = 0; rgtbdRuler[itbd].dxa != 0; itbd++);
		bltbyte((CHAR *)rgtbdRuler, &rgb[2], cchRgtbd = cwTBD * cchINT * itbd);
		rgb[1] = cchRgtbd;
		rgb[0] = sprmPRgtbd;
		AddSprm(rgb);
		}
	EndLookSel(&selSave, fTrue);
	SetRgvalAgain(rgval, uacFormatPara);
}

#else			      /* MEMO, not CASHMERE */

/* D O	F O R M A T  P A R A */
DoFormatPara(rgval)
VAL rgval[];
{
	/* add para sprms */

	int val, ival;
	int *pval;
	int sprm;
	struct PAP *ppap;
	typeCP dcp;
	typeCP cpFirst, cpLim;
	struct SEL selSave;
/* this temp array is used to assemble sprm values */
	CHAR rgb[cchTBD * itbdMax + 2/* >> cwPAPBase */];
	int rgw[cwPAPBase];
	ppap = (struct PAP *)&rgw[0];

	if (!FWriteOk( fwcNil ))
	    return;

#ifdef ENABLE /* no ClearRulerSprm yet */
	if (docRulerSprm != docNil) ClearRulerSprm();
#endif
	ExpandCurSel(&selSave);

	dcp = (cpLim = selCur.cpLim) - (cpFirst = selCur.cpFirst);
	if (cpLim > cpMacCur)
		{
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp - ccpEol, 0);
		InsertEolInsert(docCur, cpMacCur);
		}
	else
		SetUndo(uacReplNS, docCur, cpFirst, dcp,
			docNil, cpNil, dcp, 0);
/* reset adjusted selCur */
	selCur.cpFirst = cpFirst;
	selCur.cpLim = cpLim;

	for (ival = 0; ival <= 2; ival++)
		if ((val = rgval[ival]) != valNil)
			{
			switch(ival)
				{
				case 0:
					sprm = sprmPLMarg;
					break;
				case 1:
					sprm = sprmPFIndent;
					break;
				case 2:
					sprm = sprmPRMarg;
					break;
				}
/* we come here with one word value */
			bltbyte(&val, &rgb[1], cchINT);
			rgb[0] = sprm;
			AddSprm(rgb);
			}

#ifdef RULERALSO /* tabs in format para dialog box */
	if (vfTabsChanged)
		{
		int itbd;
		int cchRgtbd;
/* some tab changes were also made in the ruler */
		for (itbd = 0; rgtbdRuler[itbd].dxa != 0; itbd++);
		bltbyte((CHAR *)rgtbdRuler, &rgb[2], cchRgtbd = cwTBD * cchINT * itbd);
		rgb[1] = cchRgtbd;
		rgb[0] = sprmPRgtbd;
		AddSprm(rgb);
		}
#endif

	EndLookSel(&selSave, fTrue);
#ifdef ENABLE
	SetRgvalAgain(rgval, uacFormatPara);
#endif
} /* end of DoFormatPara */
#endif /* MEMO, not CASHMERE */


/* P U T  P A R A  N U M */
/* convert n according to unit ut, and leave result in stBuf */
PutParaNum(n, ut)
int n, ut;
	{
	CHAR *pch = &stBuf[1];
	stBuf[0] = CchExpZa(&pch, n, ut, cchMaxNum);
	}


BOOL far PASCAL DialogParaFormats( hDlg, message, wParam, lParam )
HWND	hDlg;			/* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
    /* This routine handles input to the Paragraph Formats dialog box. */
    extern struct SEP vsepNormal;
    extern int ferror;
    unsigned dxaText;
    int wLowLim;
    int i;
    TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP */

    switch (message)
		{
		case WM_INITDIALOG:
#ifdef RULERALSO /* enable out because no need to bring ruler up */
			InitSpecialDialog(&vhDlgIndent, hDlg);
#else
			EnableOtherModeless(FALSE);
#endif
			GetRgtsvPapSel(rgtsv);	/* get paragraph properties */

			  /* note the following loop assumes that the
			     itsv Indent codes are in the same order as
			     the idiPar Indent codes */

			for (i = 0; i < 3; i++)
			    if (rgtsv[itsvLIndent + i].fGray == 0)
				{
				PutParaNum(rgtsv[itsvLIndent + i].wTsv, utCur);
				SetDlgItemText(hDlg, (idiParLfIndent + i),
				      (LPSTR)&stBuf[1]);
				}

			SelectIdiText(hDlg, idiParLfIndent);
			break;

	       case WM_SETVISIBLE:
		       if (wParam)
			   EndLongOp(vhcArrow);
		       return(FALSE);

	       case WM_ACTIVATE:
			if (wParam)
			    vhWndMsgBoxParent = hDlg;
			if (vfCursorVisible)
			    ShowCursor(wParam);
			return(FALSE); /* so that we leave the activate message to
			the dialog manager to take care of setting the focus right */

		case WM_COMMAND:
			switch (wParam)
			{
			case idiOk:
			/* Get xaLeft, First line, and xaRight */
				if (!WPdxaFromItDxa2WId(&rgval[0], hDlg, idiParLfIndent, 0, dxaText = vsepNormal.dxaText,
					wBlank | wSpaces, IDPMTNOTDXA))
					{
					ferror = FALSE; /* minor error, stay in dialog */
					break;
					}
				if (rgval[0] == valNil)
					wLowLim = 0;
				else
					wLowLim = (int) -rgval[0];
				if (!WPdxaFromItDxa2WId(&rgval[1], hDlg, idiParFirst, wLowLim, dxaText,
					wBlank | wSpaces, IDPMTNOTDXA) ||
				    !WPdxaFromItDxa2WId(&rgval[2], hDlg, idiParRtIndent, 0, dxaText,
					wBlank | wSpaces, IDPMTNOTDXA))
					{
					ferror = FALSE; /* minor error, stay in dialog */
					break;
					}
/* we have in rgval:
	0	xaLeft
	1	xaLeft1
	2	xaRight */
				DoFormatPara(rgval);
				/* FALL THROUGH */
			case idiCancel:
#ifdef RULERALSO /* enable out because no need to bring up ruler */
				CancelSpecialDialog(&vhDlgIndent);
#else
				OurEndDialog(hDlg, TRUE);
#endif
				break;
			default:
				return(FALSE);
			}
			break;

		case WM_CLOSE:
#ifdef RULERALSO /* enable out because no need to bring up ruler */
			CancelSpecialDialog(&vhDlgIndent);
#else
			OurEndDialog(hDlg, TRUE);
#endif
			break;

		default:
			return(FALSE);
		}
    return(TRUE);
}
/* end of DialogParaFormats */


#ifdef RULERALSO/* no need to bring up ruler when tab or indent dialog box was invoked */
InitSpecialDialog(phDlg, hDlg)
HANDLE *phDlg;
HANDLE hDlg;
{
/* Special dialog box is a modal dialog box that needs to invoke a ruler if
   not already there.  Since the ruler is a child window, the parent has to
   be enabled and other children except the ruler and/or modeless dialog
   boxes has to be disabled.  Top level menu and the system menu have to
   be locked.

   phDlg : address of the global handle to store the special
	   dialog created (ptr to either vhDlgIndent or vhDlgTab)
	   Ruler relies on these global handle to see if need to
	   update any dialog's items when tabs or indents are moved.
   hDlg  : handle to the special dialog box created.
*/

	*phDlg = hDlg;
	EnableOtherModeless(FALSE); /* disable other modeless dialogs */
	EnableWindow(hParentWw, TRUE);
	EnableWindow(wwdCurrentDoc.wwptr, FALSE);
	if (!pwwdCur->fRuler)
		{
		vfTempRuler = TRUE;
		pwwdCur->fRuler = TRUE;
		CreateRuler();
		}
	else
		UpdateRuler();
	vfTabsChanged = FALSE;
	vfDisableMenus = TRUE;
} /* InitSpecialDialog */


CancelSpecialDialog(phDlg)
HANDLE * phDlg;
{
/* Destroy the special dialog box involves destroying the ruler if it is
   invoked by the creation of the dialog box, then enable the children
   and/or any modeless dialogs that were disabled in InitSpecialDialog.
   System menu and the top level menu has to be unlocked.
   The last thing is to reset the global dialog handle (vhDlgTab or
   vhDlgIndent).  Ruler relies on these global handle to see if need to
   update any dialog's items when tabs or indents are moved.

   phDlg : address of the global handle that stores the special
	   dialog created (ptr to either vhDlgIndent or vhDlgTab)
*/
HANDLE hDlg = *phDlg;

	if (vfTempRuler)
		{
		DestroyRuler();
		vfTempRuler = FALSE;
		pwwdCur->fRuler = FALSE;
		}
	else
		UpdateRuler();
	EndDialog(hDlg, TRUE);
	EnableWindow(wwdCurrentDoc.wwptr, TRUE);
	EnableOtherModeless(TRUE); /* enable other modeless dialogs */
	*phDlg = (HANDLE)NULL;
	vfDisableMenus = FALSE;

} /* CancelSpecialDialog */
#endif /* RULERALSO -- no need to bring up ruler when tab or indent dialog box is invoked */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\disp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* disp.c -- MW display routines */

#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
//#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NOWH
#define NOWINOFFSETS
#define NOMETAFILE
#define NOMB
#define NODRAWTEXT
#include <windows.h>

#define NOUAC
#include "mw.h"
#include "debug.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#define NOKCCODES       /* Removes all kc code defines */
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "macro.h"
#include "printdef.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif
#ifdef DBCS
#include "dbcs.h"
#endif

#ifdef CASHMERE     /* No VisiMode in WinMemo */
extern int              vfVisiMode;
#endif /* CASHMERE */

extern int              vcchBlted;
extern int              vidxpInsertCache;
extern int              vdlIns;
extern int              vfInsLast;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern int              rgval[];
extern struct DOD       (**hpdocdod)[];
extern typeCP           cpMacCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur, wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern int              docCur;
extern struct CHP       (**vhgchpFormat)[];
extern int              vichpFormat;
extern typeCP           cpMinCur;
extern typeCP           cpMinDocument;
extern int              vfInsertOn;
extern int              vfTextBltValid;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern unsigned         vpgn;
extern struct SEP       vsepAbs;
extern CHAR             stBuf[];
extern typeCP           CpEdge();
extern typeCP           CpMacText();
extern int              vdocPageCache;
extern int              vfPictSel;
extern int              vfAwfulNoise;
extern int              vfSkipNextBlink;
extern int              dypMax;
extern HDC              vhMDC;
extern HWND             vhWndPageInfo;
extern struct FMI       vfmiScreen;
extern int              docScrap;
extern long             rgbBkgrnd;
extern long             ropErase;
extern BOOL             vfMonochrome;
extern int              dxpbmMDC;
extern int              dypbmMDC;
extern HBITMAP          hbmNull;
extern int              vfOutOfMemory;
extern int              vfSeeSel;
extern int              vfInsEnd;   /* Is insert point at end-of-line? */
extern int              vipgd;
extern typeCP           vcpMinPageCache;
extern typeCP           vcpMacPageCache;
/* actual position of the cursor line */
extern int              vxpCursLine;
extern int              vypCursLine;

extern int              vdypCursLine;
extern int              vfScrollInval; /* means scroll did not take and UpdateWw must be repeated */
extern BOOL             vfDead;
extern HRGN             vhrgnClip;


/* G L O B A L S
int dlsMac = 0;*/
#ifdef DBCS
int donteat = 0;	/* propagate not to eat message */
#endif


/* D I S P L A Y  F L I */
/* Display formatted line in window ww at line dl */


DisplayFli(ww, dl, fDontDisplay)
int ww;
int dl;
int fDontDisplay; /* True if we set up dl info but don't display */
    {
#ifdef	KOREA  // jinwoo: 92, 9, 28
 /* process Subscript separatedly from descent */
#ifdef NODESC
    extern int isSubs;
#endif
#endif
    typeCP dcp;
    typeCP dcpMac;
    struct WWD *pwwd = &rgwwd[ww];
    HDC hDC = pwwd->hDC;
    int xp;                     /* Current xp to write text */
    int yp;                     /* Current yp to write text */
    int xpMin = pwwd->xpMin;    /* Minimum xp in window */
    int xpMac = pwwd->xpMac;    /* Maximum xp in window */
    int ypLine;                 /* Screen yp for current line */
    int dxp;                    /* Width of current run */
    int dyp;                    /* Line height */
    int dxpExtra;               /* Width of pad for each space */
    typeCP cpMin;
    typeCP cpMac;
    int xpSel;                  /* xp of the start of the selection */
    int dxpSel = 0;             /* Width of the selection. */
    CHAR chMark = '\0';         /* style character */
    struct CHP *pchp;
    BOOL fTabsKludge = (vfli.ichLastTab >= 0);
    BOOL fInsertOn = FALSE;
    int cBreakRun;              /* break characters in run (no relation to Dick or Jane) */

#ifdef SMFONT
    RECT rcOpaque;
#endif /* SMFONT */

#ifdef DDISP
    CommSzNumNum("    DisplayFli: dl/fDontDisplay ", dl, fDontDisplay);
#endif
    Assert(ww >= 0 && ww < wwMax);
#ifdef SMFONT
    Assert(!fDontDisplay || vfli.fGraphics)
#endif /* SMFONT */
    Scribble(5,'D');

    /* Fill up EDL and set some useful locals */
        {
        register struct EDL *pedl = &(**pwwd->hdndl)[dl];

        if (dl == vdlIns)
            {
            /* Overwriting chars blted during fast insert; reset blt count */
            vcchBlted = 0;
            vidxpInsertCache = -1;
            }

        pedl->xpLeft = vfli.xpLeft;
        pedl->xpMac = vfli.xpReal;
        cpMin = pedl->cpMin = vfli.cpMin;
        pedl->dcpMac = (cpMac = vfli.cpMac) - cpMin;
        dyp = pedl->dyp = vfli.dypLine;
        pedl->ichCpMin = vfli.ichCpMin;
        pedl->dcpDepend = (cpMin == cpMac) ? 0xff : vfli.dcpDepend;
        pedl->fValid = TRUE;
        pedl->fGraphics = vfli.fGraphics;
        pedl->fSplat = vfli.fSplat;

        /* The position of current line equals the position of the previous line
        + height of this line. */
#ifdef SMFONT
        pedl->yp = rcOpaque.bottom = dyp + (ypLine = rcOpaque.top = (dl == 0 ?
          pwwd->ypMin : (pedl - 1)->yp));
#else /* not SMFONT */
        pedl->yp = dyp + (ypLine = (dl == 0 ? pwwd->ypMin :
          (pedl - 1)->yp));
#endif /* SMFONT */

        if (pedl->fIchCpIncr = (vfli.ichCpMac != 0))
            {
            /* Look at final text column */
            ++cpMac;

            /* Since this is true, we can compress pedl->ichCpMac to 1 bit. */
            Assert(vfli.ichCpMac == pedl->ichCpMin + 1);
            }
        }

    if (vfli.doc == docNil)
        {
        /* This is the space beyond the end mark. */
        PatBlt(hDC, 0, ypLine, xpMac, dyp, ropErase);
        goto Finished;
        }

    /* Is there a character in the "style bar"? */
    if (cpMin != cpMac)
        {

#ifdef CASHMERE
        /* This line is not completely empty (not after the end mark); check for
        painting marks on the style bar. */
        if (cpMin == vcpFirstParaCache && vpapAbs.rhc != 0)
            {
            /* This is a running-head. */
            chMark = chStatRH;
            }
        else if ((**hpdocdod)[vfli.doc].hpgtb != 0)
#else /* not CASHMERE */
        if (vpapAbs.rhc == 0 && (**hpdocdod)[vfli.doc].hpgtb != 0)
#endif /* CASHMERE */

            {
            if (vdocPageCache != vfli.doc || cpMac > vcpMacPageCache || cpMac <=
              vcpMinPageCache)
                {
                CachePage(vfli.doc, cpMac - 1);
                }

            /* We are now guaranteed that cpMac is within the cached page. */
            if (cpMin <= vcpMinPageCache && (!vfli.fGraphics || vfli.ichCpMin ==
              0))
                {
                /* This is the first line of new page; show page mark. */
                chMark = chStatPage;
                }
            }
        }

#ifdef SMFONT
#ifdef DDISP
    /* black out this line to test how efficiently/correctly we
       overwrite pixels from previously-resident lines of text */
    PatBlt(hDC, 0, ypLine, xpMac, dyp, BLACKNESS);
    { long int i; for (i=0; i < 500000; i++) ; }
#endif
    
    /* Calculate dcpMac now, so we might be able to know how much to erase. */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;

    /* Erase any character that might be in the style bar. */
    dxp = xpSelBar + 1;
    if (!vfli.fGraphics)
        {
        dxp = xpMac; // clear the whole line 
        }
    PatBlt(hDC, 0, ypLine, dxp, dyp, ropErase);

    /* If this is graphics then go draw any characters in the style bar. */
    if (vfli.fGraphics)
        {
        goto DrawMark;
        }

    /* If there are no "real" characters on this line then we can skip alot of
    this. */
    if (dcpMac == 0)
        {
        goto EndLine2;
        }
#else /* not SMFONT */
    if (vfli.fGraphics || fDontDisplay)
        {
        /* Erase any character that might be in the style bar. */
        PatBlt(hDC, 0, ypLine, xpSelBar, dyp, ropErase);
        goto DrawMark;
        }
#endif /* SMFONT */

    ValidateMemoryDC();
    if (vhMDC == NULL)
        {
Error:
        /* Notify the user that an error has occured and simply erase this line.
        */
        WinFailure();
        PatBlt(hDC, xpSelBar, ypLine, xpMac - xpSelBar, dyp, ropErase);
        goto Finished;
        }

#ifndef SMFONT
    /* Create a new bitmap for the memory DC if the current bitmap is not big
    enough. */
    if (xpMac > dxpbmMDC || dyp > dypbmMDC)
        {
        HBITMAP hbm;

        /* If there is an old bitmap, then delete it. */
        if (dxpbmMDC != 0 || dypbmMDC != 0)
            {
            DeleteObject(SelectObject(vhMDC, hbmNull));
            }

        /* Create the new bitmap and select it in. */
        if ((hbm = CreateBitmap(dxpbmMDC = xpMac, dypbmMDC = dyp, 1, 1,
          (LPSTR)NULL)) == NULL)
            {
            /* There should be a graceful way to recover if the bitmap is ever
            NULL (e.g we don't have enough memory for it). */
            dxpbmMDC = dypbmMDC = 0;
            goto Error;
            }
        SelectObject(vhMDC, hbm);
        }

    /* Erase the are of the bitmap we are going to use. */
    PatBlt(vhMDC, xpSelBar, 0, xpMac, dyp, vfMonochrome ? ropErase : WHITENESS);
#endif /* not SMFONT */

    /* Initialize some of the variables we'll need. */
    pchp = &(**vhgchpFormat)[0];
#ifdef SMFONT
    xp = rcOpaque.left = rcOpaque.right = vfli.xpLeft + xpSelBar - xpMin + 1;
#else /* not SMFONT */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;
    xp = vfli.xpLeft + xpSelBar - xpMin + 1;
#endif /* SMFONT */
    dxpExtra = fTabsKludge ? 0 : vfli.dxpExtra;

#ifdef SMFONT
    /* If we are horizontally scrolled, then set the clip area to the area
    outside of the selection bar. */
    if (xpMin != 0)
        {
        IntersectClipRect(hDC, xpSelBar, rcOpaque.top, xpMac, rcOpaque.bottom);
        }
#endif /* SMFONT */

    for (dcp = 0; dcp < dcpMac; pchp++)
        {
        /* For all runs do: */
        int ichFirst;   /* First character in the current run */
        int cchRun;     /* Number of characters in the current run */

        dcp = ichFirst = pchp->ichRun;
        dcp += pchp->cchRun;
        if (dcp > dcpMac)
            {
            dcp = dcpMac;
            }
        cchRun = dcp - ichFirst;

        /* Compute dxp = sum of width of characters in current run (formerly
        DxaFromIcpDcp). */
            {
            register int *pdxp;
            register int cchT = cchRun;
            PCH pch = vfli.rgch + ichFirst;

            dxp = cBreakRun = 0;
            pdxp = &vfli.rgdxp[ichFirst];
            while (cchT-- > 0)
                {
                dxp += *pdxp++;
                if (*pch++ == chSpace)
                    ++cBreakRun;
                }
#ifdef DDISP
            CommSzNum("  dxp=",dxp);
#endif
            }

        if (dxp > 0)
            {
            int cchDone;
            PCH pch = &vfli.rgch[ichFirst];

#ifdef	KOREA	//920525 KDLEE;  jinwoo: 92, 9, 28
#ifdef NODESC
	    TEXTMETRIC tm;
#endif
#endif  //KOREA
            LoadFont(vfli.doc, pchp, mdFontScreen);
#ifdef	KOREA	      //KDLEE 920525;  jinwoo: 92, 9, 28
#ifdef NODESC
	    GetTextMetrics (vhMDC, (LPTEXTMETRIC)&tm);

	    if (tm.tmCharSet==HANGEUL_CHARSET)
		yp = dyp - (vfli.dypBase/3) -((pchp->hpsPos != 0 ? (pchp->hpsPos <
			hpsNegMin ? ypSubSuper : -ypSubSuper) : 0)) -
			vfmiScreen.dypBaseline - (isSubs ? ypSubSuper : 0);
	    else
		yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
			hpsNegMin ? ypSubSuper : -ypSubSuper) :  0))) -
			vfmiScreen.dypBaseline - (isSubs ? ypSubSuper : 0);
#else	/* NODESC */
            yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
              hpsNegMin ? ypSubSuper : -ypSubSuper) : 0))) -
              vfmiScreen.dypBaseline;
#endif	/* NODESC */
#else   /* KOREA */

            yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
              hpsNegMin ? ypSubSuper : -ypSubSuper) : 0))) -
              vfmiScreen.dypBaseline;
#endif // KOREA  jinwoo: 92, 9, 28


            /* Note: tabs and other special characters are guaranteed to come at
            the start of a run. */
            SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);
#ifdef SMFONT
            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* SMFONT */
            cchDone = 0;
            while (cchDone < cchRun)
                {
                int cch;

                /* Does the wide-space zone begin in this run? */
                if (vfli.fAdjSpace && (vfli.ichFirstWide < ichFirst + cchRun) &&
                  (ichFirst + cchDone <= vfli.ichFirstWide))
                    {
                    int cchDoneT = cchDone;

                    /* Is this the beginning of the wide-space zone? */
                    if (ichFirst + cchDone == vfli.ichFirstWide)
                        {
                        /* Reset the width of the spaces. */
                        SetTextJustification(vhMDC, ++dxpExtra * cBreakRun, cBreakRun);
#ifdef SMFONT
                        SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* SMFONT */
                        cch = cchRun - cchDone;
                        cchDone = cchRun;
                        }
                    else
                        {
                        cchDone = cch = vfli.ichFirstWide - ichFirst;
                        }

                    /* This run is cut short because of a wide space, so we need
                    to calculate a new width. */
                        {
                        register int *pdxp;
                        register int cchT = cch;
                        PCH pch = &vfli.rgch[ichFirst + cchDoneT];

                        dxp = 0;
                        pdxp = &vfli.rgdxp[ichFirst + cchDoneT];
                        while (cchT-- > 0)
                            {
                            dxp += *pdxp++;
                            if (*pch++ == chSpace)
                                ++cBreakRun;
                            }
                        }
                    }
                else
                    {
                    cchDone = cch = cchRun;
                    }

                while (cch > 0)
                    {
                    switch (*pch)
                        {
                        CHAR ch;
                        int dxpT;

                    case chTab:

#ifdef CASHMERE
                        /* chLeader contains tab leader character (see
                        FormatLine) */
                        if ((ch = pchp->chLeader) != chSpace)
                            {
                            int cxpTab;
                            CHAR rgch[32];
                            int dxpLeader = CharWidth(ch);
                            int xpT = xp;
                            int iLevelT = SaveDC(vhMDC);

                            SetBytes(&rgch[0], ch, 32);
                            dxpT = vfli.rgdxp[ichFirst];
                            cxpTab = ((dxpT + dxpLeader - 1) / dxpLeader + 31)
                              >> 5;

                            xp += dxpT;

                            while (cxpTab-- > 0)
                                {
                                TextOut(vhMDC, xpT, yp, (LPSTR)rgch, 32);
                                xpT += dxpLeader << 5;
                                }
                            RestoreDC(vhMDC, iLevelT);
                            }
                        else
#endif /* CASHMERE */

                            {
#ifdef SMFONT
                            /* Expand the opaque rectangle to include the tab.
                            */
                            rcOpaque.right += vfli.rgdxp[ichFirst];
#endif /* SMFONT */
                            xp += vfli.rgdxp[ichFirst];
                            }

                        if (fTabsKludge && ichFirst >= vfli.ichLastTab)
                            {
                            SetTextJustification(vhMDC, (dxpExtra =
                              vfli.dxpExtra) * cBreakRun, cBreakRun);
#ifdef SMFONT
                            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* SMFONT */
                            fTabsKludge = FALSE;
                            }
                        dxp -= vfli.rgdxp[ichFirst];
                        pch++;
                        cch--;
                        goto EndLoop;

#ifdef CASHMERE
                    case schPage:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpPgn(&stBuf[1], vpgn, vsepAbs.nfcPgn,
                          flmSandMode, ichMaxLine);
                        goto DrawSpecial;

                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpFtn(&stBuf[1], cpMin + ichFirst,
                          flmSandMode, ichMaxLine);
DrawSpecial:
#else /* not CASHMERE */
                    case schPage:
                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = *pch == schPage && (wwdCurrentDoc.fEditHeader
                          || wwdCurrentDoc.fEditFooter) ? CchExpPgn(&stBuf[1],
                          vpgn, 0, flmSandMode, ichMaxLine) :
                          CchExpUnknown(&stBuf[1], flmSandMode, ichMaxLine);
#endif /* not CASHMERE */

#ifdef SMFONT
                        /* Calculate the opaque rectangle. */
                        rcOpaque.right += vfli.rgdxp[ichFirst] +
                          vfmiScreen.dxpOverhang;

                        TextOut(hDC, xp, ypLine+yp, &stBuf[1], stBuf[0]);
#else /* not SMFONT */
                        TextOut(vhMDC, xp, yp, (LPSTR)&stBuf[1], stBuf[0]);
#endif /* SMFONT */
                        break;

                    default:
                        goto EndLoop;
                        }

                    dxp -= vfli.rgdxp[ichFirst];
#ifdef SMFONT
                    /* End the line if no more will fit into the window. */
                    if ((xp += vfli.rgdxp[ichFirst++]) >= xpMac) {
                        goto EndLine;
                    }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
#else /* not SMFONT */
                    xp += vfli.rgdxp[ichFirst++];
#endif /* SMFONT */
                    pch++;
                    cch--;
                    }
EndLoop:

#ifdef SMFONT
                if (cch == 0)
                    {
                    Assert(dxp == 0);
                    }
                else
                    {
                    /* Calculate the opaque rectangle. */
                    rcOpaque.right += dxp + vfmiScreen.dxpOverhang;

#if 0
            {
                char msg[180];
                wsprintf(msg,"putting out %d characters\n\r",cch);
                OutputDebugString(msg);
            }
#endif
                    /* Output cch characters starting at pch */
                    TextOut(hDC, xp, ypLine+yp, pch, cch);

                    /* End the line if no more will fit into the window. */
                    if ((xp += dxp) >= xpMac)
                        {
                        goto EndLine;
                        }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
                    pch += cch;
                    }
#else /* not SMFONT */
                /* Output cch characters starting at pch */
                TextOut(vhMDC, xp, yp, (LPSTR)pch, cch);
                xp += dxp;
                pch += cch;
#endif /* SMFONT */
                } /* end while (cchDone<cchRun) */
            } /* end if (dxp>0) */
        } /* end for dcp=0..dcpMac */

#ifdef SMFONT
EndLine:
    /* Restore the clip region if need be. */
    if (xpMin != 0)
        {
        SelectClipRgn(hDC, NULL);
        }
EndLine2:
#endif /* SMFONT */

#ifdef CASHMERE
    if (vfVisiMode)
        {
        AddVisiSpaces(ww, &(**pwwd->hdndl)[dl], vfli.dypBase, vfli.dypAfter +
          vfli.dypFont);
        }
#endif /* CASHMERE */

    vfTextBltValid = FALSE;

    if ((ww == wwCur) && (pwwd->doc != docScrap) && !vfSelHidden &&
      (selCur.cpLim >= cpMin))
        {
        if (selCur.cpFirst <= cpMac)
            {
            /* Show selection */
            int xpFirst;
            int xpLim;

#ifdef ENABLE
            if (vfli.fSplatNext && selCur.cpFirst == selCur.cpLim &&
                selCur.cpFirst == cpMac)
                {
                vfInsEnd = TRUE;
                ClearInsertLine();
                }
            vfInsertOn = FALSE;
#endif /* ENABLE */

            if (selCur.cpFirst <= cpMin && selCur.cpLim >= cpMac)
                {
                xpFirst = vfli.xpLeft;
                xpLim = vfli.xpReal;
                }
            else if (selCur.cpFirst < cpMac || (selCur.cpLim == cpMac &&
              vfInsEnd))
                {
                typeCP cpBegin = CpMax(cpMin, selCur.cpFirst);
                typeCP cpEnd = CpMin(cpMac, selCur.cpLim);

                dxp = DxpDiff((int)(cpBegin - cpMin), (int)(cpEnd - cpBegin),
                  &xpFirst);
                xpLim = min(xpMin + vfli.xpReal, xpFirst + dxp);
                }
            else
                {
                goto DidntHighlight;
                }

            xpSel = xpSelBar + max(xpFirst - xpMin, 0);
            if (xpLim > xpFirst)
                {
                /* Set highlighting at desired screen position. */
                dxpSel = max(xpLim - max(xpFirst, xpMin), 0);
                }
            else if (selCur.cpFirst == selCur.cpLim && ((selCur.cpLim != cpMac)
              ^ vfInsEnd))
                {
                vfInsertOn = FALSE; /* Because we redisplayed insert pt line */

#ifdef CASHMERE
                vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
                vypCursLine = ypLine + dyp - vfli.dypAfter;
#else /* not CASHMERE */
                vdypCursLine = vfli.dypFont;
                vypCursLine = ypLine + dyp;
#endif /* not CASHMERE */

                vxpCursLine = xpSel;

                /* Start blinking in a while */
                vfSkipNextBlink = TRUE;

                fInsertOn = xpFirst >= xpMin;
                }

DidntHighlight:;
            }
        }

#ifdef SMFONT
    /* Invert the selection */
    if (dxpSel != 0) {
        PatBlt(hDC, xpSel, ypLine, dxpSel, dyp, DSTINVERT);
    }
#else /* not SMFONT */
    /* Blt the line of text onto the screen. */
    PatBlt(vhMDC, 0, 0, xpSelBar, dyp, vfMonochrome ? ropErase : WHITENESS);
    if (dxpSel == 0)
        {
        BitBlt(hDC, 0, ypLine, xpMac, dyp, vhMDC, 0, 0, SRCCOPY);
        }
    else
        {
        BitBlt(hDC, 0, ypLine, xpSel, dyp, vhMDC, 0, 0, SRCCOPY);
        BitBlt(hDC, xpSel, ypLine, dxpSel, dyp, vhMDC, xpSel, 0, NOTSRCCOPY);
        xpSel += dxpSel;
        BitBlt(hDC, xpSel, ypLine, xpMac - xpSel, dyp, vhMDC, xpSel, 0,
          SRCCOPY);
        }
#endif /* SMFONT */

    /* Draw the insertion bar if necessary. */
    if (fInsertOn)
        {
        DrawInsertLine();
        }

DrawMark:
    /* Draw the character in the style bar if necessary. */
    if (chMark != '\0')
        {
#ifdef SYSENDMARK
        struct CHP         chpT;
        extern struct CHP  vchpNormal;

        blt(&vchpNormal, &chpT, cwCHP);
        chpT.ftc     = ftcSystem;
        chpT.ftcXtra = 0;
        chpT.hps     = hpsDefault;

        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, &chpT, mdFontScreen);

        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline, 
                (LPSTR)&chMark, 1);
#else /* ifdef SYSENDMARK */
        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, NULL, mdFontScreen);
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
          (LPSTR)&chMark, 1);
#endif /* if-else-def SYSENDMARK */
        }

    if (vfli.fGraphics)
        {
        DisplayGraphics(ww, dl, fDontDisplay);
        }

Finished:
    Scribble(5,' ');
    }


/* D X P  D I F F */
DxpDiff(dcpFirst, dcp, pdxpFirst)
int dcpFirst;
int dcp;
int *pdxpFirst;
{
#if 1
    register int *pdxp = &vfli.rgdxp[0];
    register int cch;
    int dxp = vfli.xpLeft;
#ifdef ENABLE   /* Not used */
    int ichLim = dcpFirst + dcp;
#endif


    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        //Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    for (cch = 0; cch < dcpFirst; ++cch)
        {
        dxp += *pdxp++;
        }
    *pdxpFirst = dxp;
    dxp = 0;
    for (cch = 0; cch < dcp; ++cch)
        {
        dxp += *pdxp++;
        }
    return dxp;
#else

    int dxp;
    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    /* first get space up to first character */
    *pdxpFirst = LOWORD(GetTextExtent(hDC,vfli.rgch,dcpFirst)) + vfli.xpLeft;

    /* now get space between first and first+dcp */
    dxp = LOWORD(GetTextExtent(hDC,vfli.rgch+dcpFirst,dcp));
    return dxp;
#endif
}


UpdateDisplay(fAbortOK)
int fAbortOK;
{
    int ww;

    if (wwMac <= 0)
        {
        return;
        }

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ww++)
        if ( rgwwd[ww].doc != docScrap )
            {
            UpdateWw(ww, fAbortOK);
            if (rgwwd[ww].fDirty || vfOutOfMemory)
                {
                return; /* update has been interrupted */
                }
            }
#else /* not CASHMERE */
    UpdateWw(wwDocument, fAbortOK);
    if (wwdCurrentDoc.fDirty || vfOutOfMemory)
        {
        /* Update has been interrupted */
        return;
        }
#endif /* not CASHMERE */

    if (wwdCurrentDoc.fRuler)
        {
        UpdateRuler();
        }
}


/* U P D A T E  W W */
UpdateWw(ww, fAbortOK)
int ww, fAbortOK;
{ /* Redisplay ww as necessary */
    extern int vfWholePictInvalid;
    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlOld, dlNew;
    int doc;
    int ichCp;
    struct EDL *pedlNew;
    register struct EDL *pedl;
    struct EDL (**hdndl)[]=pwwd->hdndl;
    int dypDiff;
    int ypTop;
    int ypFirstInval;
    int dr;
    int fLastNotShown;
    typeCP cp, cpMacWw;

    if (!pwwd->fDirty)
        {
        return;
        }

	if (!((**hpdocdod)[pwwd->doc].fDisplayable))
        return;

    if (fAbortOK && FImportantMsgPresent())
        return;

#if 0  // how to get first and last cp's in invalid rect?
#if defined(OLE)
    /* 
        Load visible objects.  Do it now rather than in DisplayGraphics()
        because here it has less chance of disrupting the state variables
        upon which UpdateWw depends.
    */
    ObjEnumInRange(docCur,cpMinCur,cpMacCur,ObjLoadObjectInDoc);
#endif
#endif

    dlMac = pwwd->dlMac;
    ypTop = pwwd->ypMin;

    Assert( ww >= 0 && ww < wwMax );
    vfli.doc = docNil;  /* An aid to Fast Insert */

    UpdateInvalid();    /* InvalBand for what Windows considers to be invalid */
    ypFirstInval = pwwd->ypFirstInval;

#ifndef CASHMERE
    Assert( ww == wwCur );  /* A MEMO-only assumption */
#endif /* CASHMERE */

    Scribble(5, 'U');

    ValidateMemoryDC();      /* to do any update, we need a good memory DC */
    if (vhMDC == NULL)
        {
        WinFailure();
        return;
        }

    doc = pwwd->doc;
    vfli.doc = docNil;

    if (pwwd->fCpBad)
        {
/* cp first displayed has not been blessed */

#ifdef CASHMERE     /* Must do this if ww != wwCur assertion is FALSE */
        int wwT = wwCur;
        if (ww != wwCur && wwCur >= 0)
/* CtrBackTrs cache is only good for wwCur. Treat != case */
            {
            if (pwwdCur->fDirty) /* Do wwCur first, saving cache */
                UpdateWw(wwCur, fAbortOK);

            if (fAbortOK && FImportantMsgPresent())
                return;

            ChangeWw(ww, false);
            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            ChangeWw(wwT, false);
            }
        else
#endif /* CASHMERE */

            {
            if (fAbortOK && FImportantMsgPresent())
                return;

            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            }
        }

/* check for cpMin accessible in this ww */
RestartUpdate:
    vfWholePictInvalid = fTrue; /* Tells DisplayGraphics to
                                   abandon accumulated partial pict rect */
    fLastNotShown = fFalse;
    cp = CpMax(pwwd->cpMin, pwwd->cpFirst);
    cpMacWw = pwwd->cpMac;
    ichCp = pwwd->ichCpFirst;

        /* Note test for dlNew==0 that guarantees that there will be at least
           one dl -- this was added for WRITE because we do not have
           the ability to enforce a minimum window size */

    for (dlNew = dlOld = 0; ypTop < pwwd->ypMac || (dlNew == 0) ; dlNew++)
        /* we have: cp, ichCP: pints to text desired on the coming line dlNew
         ypTop: desired position for top of dlNew -1
         dlOld: next line to be considered for re-use
        */
        /* check for having to extend dndl array */
        {
        if (dlNew >= (int)pwwd->dlMax)
            {
/* extend the array with uninitialized dl's, increment max, break if no space.
We assume that dlMac(Old) was <= dlMax, so the dl's will not be looked at
but used only to store new lines */
#define ddlIncr 5

            if (!FChngSizeH(hdndl, (pwwd->dlMax + ddlIncr) * cwEDL, fFalse))
                break;
            pwwd->dlMax += ddlIncr;
            }
/* discard unusable dl's */
        for (; dlOld < dlMac; dlOld++)
            { /* Set dlOld and pedl to the next good dl */
            int ypTopOld, ypOld;

                /* Re-entrant Heap Movement */
            if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
                goto RetInval;

            pedl = &(**hdndl)[dlOld];
            ypOld = pedl->yp;

/* loop if: invalid, passed over in cp space, passed over in dl space,
passed over in yp space,
in invalid band, passed over in ich space */
            if (!pedl->fValid || dlOld < dlNew || pedl->cpMin < cp
                || (ypTopOld = (ypOld - pedl->dyp)) < ypTop
                || (ypOld >= ypFirstInval && ypTopOld <= pwwd->ypLastInval)
                || (pedl->cpMin == cp && pedl->ichCpMin < ichCp))
                continue;
/* now we have dlOld, an acceptable if not necessarily useful dl.
now compute dlNew either from scratch or by re-using dlOld. To be
re-useable, dlOld must have right cp/ichCp pair, plus be totally on screen
or, if it is a partial line, it must stay still or move down - not up */
            if (pedl->cpMin == cp && pedl->ichCpMin == ichCp &&
                (ypOld <= pwwd->ypMac || ypTopOld <= ypTop))
                {
/* Re-use this dl */
                int yp = ypTop;
                if (fLastNotShown)
                    {
                        /* HEAP MOVEMENT */
                    DisplayFli(ww, dlNew - 1, fLastNotShown = fFalse);
                    pedl = &(**hdndl)[dlOld];
                    }

                cp = pedl->cpMin + pedl->dcpMac;
                ichCp = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                ypTop += pedl->dyp;
                if (dlOld != dlNew || ypTopOld != yp)
                    {
                    DypScroll(ww, dlOld, dlNew - dlOld, yp);
                    if (vfScrollInval)
                        {
                        /* There was a popup; invalid region might have changed */
                        /* fLastNotShown test is for interrupting picture display */
                        /* before we've really displayed it */

                        (**hdndl) [dlOld].fValid = fFalse;
                        goto Restart1;
                        }
                    dlMac += dlNew - dlOld;
                    }
                dlOld = dlNew + 1;
                goto NextDlNew;
                }
            break;
            }
/* cpMin > cp, the line is not anywhere so it will have to be formatted
from scratch */

        if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
            goto RetInval;

        FormatLine(doc, cp, ichCp, cpMacWw, flmSandMode);  /* Creates vfli */

    if (vfOutOfMemory)
            goto RetInval;

        ichCp = vfli.ichCpMac;
        cp = vfli.cpMac;
/* advance invalid band so that update can resume after an interruption */
        pwwd->ypFirstInval = (ypTop += vfli.dypLine);
        pedl = &(**hdndl)[dlOld];
        if (dlOld < dlMac && pedl->cpMin == cp && pedl->ichCpMin == ichCp)
            {
            int dlT = dlOld;

/* line at dlOld is a valid, existing line that will abutt the line just about
to be displayed. */
            if (dlOld == dlNew && pedl->yp - pedl->dyp <= ypTop)
/* the line about to be overwritten will be re-used in the next loop.
Hence, it is worthwhile to save this line and its dl */
                DypScroll(ww, dlOld++, 1, ypTop);
            else
/* Move the next line to its abutting position. We know that it has not yet been
overwritten (yp, dlOld all > than ypTop, dlNew) */
                DypScroll(ww, dlOld, 0, ypTop);

            if (vfScrollInval)
                {
                /* There was a popup; invalid region might have changed */
                /* fLastNotShown test is for interrupting picture display */
                /* before we've really displayed it */

                (**hdndl) [dlT].fValid = fFalse;
Restart1:
                if (fLastNotShown)
                    {
                    pwwd->ypFirstInval = pwwd->ypMin;
                    }

                ypFirstInval = pwwd->ypFirstInval;
                ypTop = pwwd->ypMin;
                goto RestartUpdate;
                }
            }

/* true in 3rd param means put off picture redisplay till later */
/* condition: graphics & not last in picture & not last in y space and
not in front of a invalid or valid transition in the picture */
        DisplayFli(ww, dlNew, fLastNotShown = 
                  (vfli.fGraphics && vfli.ichCpMac!=0 && ypTop < pwwd->ypMac));
NextDlNew:;
        }
Break1:
    pwwd->dlMac = dlNew;

#ifdef CASHMERE
/* condition is here to avoid swapping */
    if (pwwd->fSplit && rgwwd[pwwd->ww].fFtn)
        CalcFtnLimits(pwwd);
#endif /* CASHMERE */

    SetCurWwVScrollPos();    /* Set Scroll bar position */
    vfTextBltValid = false;

/* reset invalid indications */
    pwwd->fDirty = false;
    pwwd->ypFirstInval = ypMaxAll;
    pwwd->ypLastInval = 0; /* so that max in InvalBand will work */
    Scribble(5, ' ');
    goto Validate;

/* Before returning from an interrupt, invalidate lines that were overwritten
within the present update. */
RetInval:
    Scribble(5, ' ');
    for (; dlOld < dlMac; dlOld++)
        {
        pedl = &(**hdndl)[dlOld];
        if ((pedl->yp - pedl->dyp) < ypTop)
            pedl->fValid = fFalse;
        else
            break;
        }
Validate: ;

#ifdef ENABLE   /* We will let UpdateInvalid handle this in case
                   further invalidation occurred during the update */

    {           /* Tell Windows that the part we updated is valid */
    RECT rc;

    rc.left = 0;
    rc.top = pwwd->ypMin;
    rc.right = pwwd->xpMac;
    rc.bottom = imin( pwwd->ypMac, ypTop );
    ValidateRect( pwwd->wwptr, (LPRECT)&rc );
    }
#endif
}




/* D Y P  S C R O L L */
DypScroll(ww, dlFirst, ddl, ypTo)
int ww, dlFirst, ddl, ypTo;
{
/* Scroll dl's in a window, from dlFirst to end, down ddl lines (or up -ddl).
Bitmap is moved from top of dlFirst to ypTo.   The yp's of the dl's are updated.
Returns the amount scrolled. (positive means down). */

    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlT;
    int ypFrom;
    int dypChange;
    int cdlBelow;
    struct EDL *pedl;
    struct EDL *pedlT;

    /* Do not call procedures while dndl is loaded up to avoid heap movement */
    struct EDL *dndl = &(**(pwwd->hdndl))[0];

    Assert( ww >= 0 && ww < wwMax );

    vfScrollInval = fFalse;

    /* Number of dl's below (and including) the first one to be scrolled */
    cdlBelow = pwwd->dlMac - dlFirst;
    pwwd->dlMac = min(pwwd->dlMac + ddl, pwwd->dlMax);
    cdlBelow = max(0, min(cdlBelow, pwwd->dlMac - ddl - dlFirst));

    pedlT = &dndl[dlFirst];
    ypFrom = pedlT->yp - pedlT->dyp;

    /* Length of area to be moved */
    dypChange = ypTo - ypFrom;

    if (cdlBelow > 0)
        {
        int dlTo = dlFirst + ddl;
        int ypMac = pwwd->ypMac;

        pedlT = &dndl[dlTo];
        if (ddl != 0)
            {
            blt(&dndl[dlFirst], pedlT, cwEDL * cdlBelow);
            }

        for (dlT = dlTo; dlT < pwwd->dlMac; ++dlT, ++pedlT)
            {
            if (dypChange < 0 && pedlT->yp > ypMac)
                {
                /* Invalidate dl's that are pulled in from the ozone below ypMac
                */
                pedlT->fValid = fFalse;
                }
            else
                {
                pedlT->yp += dypChange;
                }
            }
        }

    if (dypChange != 0)
        {
        RECT rc;

        SetRect( (LPRECT)&rc, 0, min(ypFrom, ypTo),
                              pwwd->xpMac, pwwd->ypMac );
        Assert( ww == wwCur );      /* A MEMO-only assumption */
        ScrollCurWw( &rc, 0, dypChange );
        }

    return dypChange;
}




FImportantMsgPresent()
{
    /*  If the next message is important enough to interrupt a screen update, we
        return TRUE; if it can wait, we return FALSE */

    BOOL fToggledKey;
    extern MSG vmsgLast;

#ifdef DEBUG
    unsigned wHeapVal = *(pLocalHeap + 1);

    Assert( wHeapVal == 0 );   /* Heap should not be frozen */
#endif

#ifdef DBCS
 if( donteat )
     return TRUE;
#endif

while (PeekMessage((LPMSG) &vmsgLast, NULL, NULL, NULL, PM_NOREMOVE))
    {

    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
    {
        if (vmsgLast.wParam == VK_CONTROL)
        {
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            SetShiftFlags();
        }
        return TRUE;
    }
    /* Filter uninteresting or easily handled events */
    else if (fToggledKey = FCheckToggleKeyMessage(&vmsgLast) || 
       (vmsgLast.message == WM_KEYUP && vmsgLast.hwnd == wwdCurrentDoc.wwptr))
        {

        /* This is so the Windows keyboard interface mechanism will see toggle
        key and key-up transitions */
        GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
#ifdef WIN30        
        /* PeekMessage has been changed in Win 3.0 so that GetKeyState()
           called from FCheckToggleKeyMessage() is really only valid if 
           you've done a PeekMessage(...,PM_REMOVE) or GetMessage() first.
           That is, while the FCheckToggleKeyMessage() call might succeed
           above, it will NOT have set the vfShiftKey/vfCommandKey flags
           correctly -- so we do it here ..pault */
        if (fToggledKey)
            FCheckToggleKeyMessage(&vmsgLast);
#endif
        if (vmsgLast.hwnd != wwdCurrentDoc.wwptr)
            {
            /* Just in case a modeless dialog's window proc cares */
            TranslateMessage((LPMSG)&vmsgLast);
            DispatchMessage((LPMSG)&vmsgLast);
            }
#ifdef DBCS
#ifdef KOREA	      /* 90.12.23 by sangl */	// jinwoo: 92, 9, 28
        if (vmsgLast.message == WM_CHAR || vmsgLast.message == WM_KEYDOWN
                || vmsgLast.message == WM_INTERIM) {
#else  /* KOREA */
        if (vmsgLast.message == WM_CHAR || vmsgLast.message == WM_KEYDOWN ) {
#endif  //KOREA   920525 KDLEE;  jinwoo: 92, 9, 28
            donteat = TRUE;
            return( TRUE );
        } /* else Ok, you are KEYUP message. do normal */
#endif
        }
    else
        {
        switch (vmsgLast.message)
            {
        case WM_MOUSEMOVE:
            /* Process mouse move messages immediately; they are not really
            important.  NOTE: This assumes that we have not captured all mouse
            events; in which case, they are important. */
            DispatchMessage((LPMSG)&vmsgLast);

        case WM_TIMER:
        case WM_SYSTIMER:
            /* Remove timer and mouse move messages from the queue. */
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            break;

        default:
            Assert( *(pLocalHeap+1) == 0 ); /* Heap should still not be frozen */
            return (TRUE);
            }
        }
    }


Assert( *(pLocalHeap + 1) == 0 );   /* Heap should still not be frozen */
return (FALSE);
}


/* C P  B E G I N  L I N E */
typeCP CpBeginLine(pdl, cp)
int *pdl;
typeCP cp;
    { /* return the cp and dl containing cp */
    int dlMin, dlLim;
    typeCP cpGuess;
    struct EDL *dndl;

    do
        {
        UpdateWw(wwCur, false);
        PutCpInWwVert(cp); /* Ensure cp on screen */
        } while (pwwdCur->fDirty && !vfOutOfMemory);

    dndl = &(**(pwwdCur->hdndl))[0];
    dlMin = 0;
    dlLim = pwwdCur->dlMac;
    while (dlMin + 1 < dlLim)
        { /* Binary search the ww */
        int dlGuess = (dlMin + dlLim) >> 1;
        struct EDL *pedl = &dndl[dlGuess];
        if ((cpGuess = pedl->cpMin) <= cp && (cpGuess != cp || pedl->ichCpMin == 0))
            { /* guess is low or right */
            dlMin = dlGuess;
            if (cp == cpGuess && pedl->cpMin + pedl->dcpMac != cp)
                break;  /* Got it right */
            }
        else  /* Guess is high */
            dlLim = dlGuess;
        }
    *pdl = dlMin;
    return dndl[dlMin].cpMin;
}




/* T O G G L E  S E L */
ToggleSel(cpFirst, cpLim, fOn)
typeCP cpFirst, cpLim; /* selection bounds */
int fOn;
{ /* Flip selection highlighting on and off */
    extern int vfPMS;
    struct EDL *pedl;
    int dlT;
    int xpMin;
    int dxpRoom;
    int xpFirst;
    int xpLim;
    int fInsertPoint = (cpFirst == cpLim);

    if (vfSelHidden || cpFirst > cpLim || cpLim < /*cp0*/ cpMinCur || vfDead)
        return;

    if ( vfPictSel && vfPMS &&
         (CachePara( docCur, cpFirst ), vpapAbs.fGraphics) &&
         (vcpLimParaCache == cpLim) )
        {   /* Don't show inversion if we're moving or sizing a picture */
        return;
        }

    dxpRoom = pwwdCur->xpMac - xpSelBar;
    xpMin = pwwdCur->xpMin;

    for (dlT = 0; dlT < pwwdCur->dlMac; dlT++)
        {
        typeCP cpMin, cpMac; /* line bounds */
        pedl = &(**(pwwdCur->hdndl))[dlT];
        if (!pedl->fValid)
            continue;
        cpMin = pedl->cpMin;
        if (cpMin > cpLim || cpMin > cpMacCur || (cpMin == cpLim && cpLim != cpFirst))
            break;
        cpMac = cpMin + pedl->dcpMac;
        if (cpFirst <= cpMin && cpLim >= cpMac)
            {
/* entire line is highlighted */
            xpFirst = pedl->xpLeft;
            if (pedl->fGraphics && cpLim == cpMac && cpMin == cpMac)
                /* Special kludge for graphics paras */
                xpLim = xpFirst;
            else
                xpLim = pedl->xpMac;
            }
        else if (fInsertPoint && cpFirst == cpMac && vfInsEnd)
            { /* Special kludge for an insert point at the end of a line */
            xpLim = xpFirst = pedl->xpMac;
            }
        else if (cpFirst < cpMac)
            {
            /* Bite the bullet */
            int dxp;
            typeCP  cpBegin = CpMax(cpMin, cpFirst);
            typeCP  cpEnd = CpMin(cpMac, cpLim);

            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            dxp = DxpDiff((int) (cpBegin - cpMin),
                (int) (cpEnd - cpBegin), &xpFirst);
            xpLim = xpFirst + dxp;
/* reload pedl because procedures were called */
            pedl = &(**(pwwdCur->hdndl))[dlT];
            }
        else
            continue;
/* now we have: pedl valid, xpFirst, xpLast describe highlight */
         /* xpFirst = max(xpFirst, xpMin); */
        xpLim = min(xpLim, xpMin + pedl->xpMac);
        if (xpLim > xpFirst)
            {
            if (xpLim > xpMin)
                {
                RECT rc;
                rc.top = pedl->yp - pedl->dyp;
                rc.left = xpSelBar + max(xpFirst - xpMin, 0);
                rc.bottom = pedl->yp;
                rc.right = xpSelBar + xpLim - xpMin;
                InvertRect( wwdCurrentDoc.hDC, (LPRECT)&rc);
                }
            }
/* ToggleSel modified 7/28/85 -- added explicit check for fInsertPoint, since
   the xpLim == xpFirst test sometimes succeeded bogusly when a selection
   was extended backwards. BL */
        else if (fInsertPoint && (xpLim == xpFirst))     /* Insertion point */
            {
            /* vfli should usually be cached already, so will be fast. */
            int yp = pedl->yp;
            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            if (fOn ^ vfInsertOn)
                {
                if (!vfInsertOn)
                    {
                    vxpCursLine = xpSelBar + xpFirst - xpMin;
                    vypCursLine = yp - vfli.dypAfter;
                    vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);

                        /* Start blinking in a while */
                    vfSkipNextBlink = TRUE;
                    }
                DrawInsertLine();
                }
            return;
            }
        }
}




/* T R A S H  W W */
TrashWw(ww)
{ /* Invalidate all dl's in ww */
    Assert( ww >= 0 && ww < wwMax );
    InvalBand(&rgwwd[ww], 0, ypMaxAll);
}




/* I N V A L  B A N D */
/* invalidate the band ypFirst, ypLast inclusive */
InvalBand(pwwd, ypFirst, ypLast)
struct WWD *pwwd; int ypFirst, ypLast;
    {
/* this covers some peculiar rects received from update event after a
window resize by 1 pixel. CS */
    if (ypLast < 0 || ypFirst == ypLast) return;

    pwwd->fDirty = true;
    pwwd->ypFirstInval = min(pwwd->ypFirstInval, ypFirst);
    pwwd->ypLastInval = max(ypLast, pwwd->ypLastInval);
    }




/* T R A S H  A L L  W W S */
TrashAllWws()
{ /* trash them all */
    int     ww;

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ++ww)
        TrashWw(ww);
#else
    TrashWw( wwDocument );
#endif
    vfli.doc = docNil;  /* Mark vfli invalid */
}


/* T U R N  O F F  S E L */
TurnOffSel()
{ /* Remove sel highlighting from screen */
/* HideSel has no effect */
    if (!vfSelHidden)
        {
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfSelHidden = true;
        }
}


/* D R A W  I N S E R T  L I N E */
DrawInsertLine()
{       /* Draw (in Xor mode) a vertical bar at screen position v*CursLine */
        /* Toggles both the display and the vfInsertOn flag */
        /* Adjustments in cursor draw must be reflected in DisplayFli, above */

            /* Last-minute correction for a bug: assure that the insert line
               does not extend above ypMin */
        if (!vfInsertOn && vdypCursLine > vypCursLine - wwdCurrentDoc.ypMin)
            vdypCursLine = vypCursLine - wwdCurrentDoc.ypMin;

            /* Tell GDI to invert the caret line */
        PatBlt( wwdCurrentDoc.hDC, vxpCursLine, vypCursLine - vdypCursLine,
                      2, vdypCursLine , DSTINVERT );
        vfInsertOn = 1 - vfInsertOn;
}




/* C L E A R  I N S E R T  L I N E */
ClearInsertLine()
{
 if ( vfInsertOn) DrawInsertLine();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\dispdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Originally, this file contained nothing but screen constants, but these
constants had to become variables to account for all different display devices.
*/

/* size of lines for dnMax estimation purposes */
extern int dypAveInit;

/* width of the selection bar area to the left of lines */
extern int xpSelBar;

extern int dxpScrlBar;
extern int dypScrlBar;
extern int dxpInfoSize;

#define xaRightMax 31680
extern int xpRightMax;
extern int xpMinScroll;
extern int xpRightLim;

/* these define the initial window size and amount of white space above
the first line */
extern int ypMaxWwInit;

/* should be > than largest window height + height of blank line after
the endmark */
extern int ypMaxAll;            /* used for invalidation */
extern int dypWwInit;

extern int dypBand;             /* formerly dpxyLineSizeMin */

extern int dypRuler;

extern int ypSubSuper;

/* number of quanta in elevator control */
#define drMax           256

#define ctcAuto         10
#define ctrAuto         4

#define cxpAuto         72


/* DL structure revised, 3 Sept KJS, CS */
/*                      14 Nov 89 ..pault  (changed dcpMac from int to 
                                            typeCP because we experienced
                                            wraparound when sizing large
                                            graphics objects) */
struct EDL
        {
        unsigned char           dcpDepend : 8;
        unsigned char           ichCpMin : 8;
        unsigned                fValid : 1;
#ifdef CASHMERE
        unsigned                fStyleInfo : 1;
#else
        unsigned                fSplat: 1;
#endif
        unsigned                fGraphics : 1;
        unsigned                fIchCpIncr : 1;
        unsigned                xpLeft : 12;
        typeCP                  dcpMac;         /* representing cpMac */
        typeCP                  cpMin;
        int                     xpMac;
        int                     dyp;            /* height of the dl */
        int                     yp;             /* position of the dl */
        };

#define cchEDL          (sizeof (struct EDL))
#define cwEDL           (cchEDL / sizeof(int))

#define cedlInit        20

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\docdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

//#define prmNil	0
#define docNil	(-1)
#define cpNil	((typeCP) -1)
#define cpMax	((typeCP) 2147483647)
#define fcNil	((typeFC) -1)
#define cp0	((typeCP) 0)
#define fnNil	(32767)
#define fc0	((typeFC) 0)
#define tcMax	255

#ifdef SAND
#define xaMax	9500
#endif

#define pn0	((typePN) 0)

#define cdocInit	4
#define cwExpand	256
#define cchMaxExpand	(cwExpand * sizeof (int))

/* FetchCp Modes */
#define fcmChars	1
#define fcmProps	2
#define fcmBoth 	(fcmChars + fcmProps)
#define fcmNoExpand	4
#define fcmParseCaps	8	/* Return separate runs for U&lc if sm. caps*/

/* Document types -- two bits only */
#define dtyNormal	0
#define dtyBuffer	1
#define dtySsht 	2
#define dtyPrd		3
#define dtySystem	4	/* Never written; smashed to dtyNormal */
#define dtyHlp		5	/* Never written */
#define dtyNormNoExt	6   /* Never written */

#ifdef INTL  /* international version */
#define dtyWordDoc	6	/* when saving in Word format */
#endif	/* international version */

#define dtyNetwork	7	/* Never written; smashed to dtyNormal */

#define dtyAny		0


struct DOD
	{ /* Document descriptor */
	struct PCTB	**hpctb;	/* Piece table */
	typeCP		cpMac;		/* Number of lexemes in doc */

	unsigned       fFormatted : 1; /* Default save is formatted */
	unsigned       fDirty : 1;     /* Document has been edited */
	unsigned       fAbsLooks : 1;  /* Absolute looks applied */
	unsigned       fBackup : 1;    /* Make auto backup of file? */
	unsigned       fReadOnly: 1;   /* Read only doc (no edits allowed)? */
	unsigned       fDisplayable : 1;
	unsigned       : 4;
	unsigned       dty : 2;        /* Document type */
	unsigned       cref : 4;       /* Reference count */

	CHAR		(**hszFile)[];	/* Document name */
	struct FNTB	**hfntb;	/* Footnote table */
#ifdef CASHMERE
	struct SETB	**hsetb;	/* Section table */
#else
	struct SEP	**hsep; 	/* Section properties */
#endif
	int		docSsht;	/* Style sheet if dty == dtySsht */
	struct PGTB	**hpgtb;	/* Page table (for Jump Page) */
	struct FFNTB	**hffntb;	/* font name table */

	struct TBD	(**hgtbd)[];	/* Table of tab stops */

#ifdef SAND
	int		vref;		/* Volume that this document is on */
#endif /* SAND */
	};

#define cwDOD (sizeof (struct DOD) / sizeof (int))
#define cbDOD (sizeof (struct DOD))

struct FNTB **HfntbGet();

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\dlgdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the definition of the numerical indexes to the dialog
items (idi) used by Windows Memo. */
/* IDOK and IDCANCEL are defined in windows.h
   windows dialog manager returns :
   IDOK if the <Return> key is hit
   IDCANCEL if the <ESC> key is hit
   As a rule, the default button should be assigned idiOk
*/

#define idiNil                  -1

#define idiOk                   IDOK
#define idiCancel               IDCANCEL
#define idiYes                  IDYES
#define idiNo                   IDNO

#ifndef NOIDISAVEPRINT      /* Another tool to avoid compiler heap overflow */
#define idiAbort                idiOk
#define idiRetry                3
#define idiIgnore               idiCancel
#define idiMessage              4

#define idiSavDir               3
#define idiSavFile              4
#define idiSavBackup            5
#define idiSavTextOnly          6
#define idiSavWordFmt           7
#define idiSavDirLB             8

#define idiOpenDir              3
#define idiOpenFile             4
#define idiOpenFileLB           5
#define idiOpenDirLB            6

#define idiPrterName            3
#define idiPrterSetup           4
#define idiRepageConfirm        3

#define idiGtoPage              3

#define idiPrtAll               6
#define idiPrtFrom              7
#define idiPrtPageFrom          8
#define idiPrtPageTo            9
#define idiPrtCopies            10
#define idiPrtDraft             11
#define idiPrtDest      12

#define idiPrCancelName    100     /* For the filename in CancelPrint dlg */

/* interactive repaginating */
#define idiKeepPgMark           idiOk
#define idiRemovePgMark         4
#define idiRepUp                5
#define idiRepDown              6

#endif  /* NOIDISAVEPRINT */

#ifndef NOIDIFORMATS
#define idiChrFontName          3
#define idiChrLBFontName        4
#define idiChrFontSize          5
#define idiChrLBFontSize        6

#define idiParLfIndent          3
#define idiParFirst             4
#define idiParRtIndent          5
/*#define idiParLineSp          6
#define idiParSpBefore          7
#define idiParSpAfter           8
#define idiParLeft              9
#define idiParCentered          10
#define idiParRight             11
#define idiParJustified         12
#define idiParKeepNext          13
#define idiParKeepTogether      14 */

#define idiTabClearAll          3
#define idiTabPos0              4
#define idiTabPos1              5
#define idiTabPos2              6
#define idiTabPos3              7
#define idiTabPos4              8
#define idiTabPos5              9
#define idiTabPos6              10
#define idiTabPos7              11
#define idiTabPos8              12
#define idiTabPos9              13
#define idiTabPos10             14
#define idiTabPos11             15
#define idiTabDec0              16
#define idiTabDec1              17
#define idiTabDec2              18
#define idiTabDec3              19
#define idiTabDec4              20
#define idiTabDec5              21
#define idiTabDec6              22
#define idiTabDec7              23
#define idiTabDec8              24
#define idiTabDec9              25
#define idiTabDec10             26
#define idiTabDec11             27

#define idiRHInsertPage         3
#define idiRHClear              4
#define idiRHDx                 5
#define idiRHFirst              6
#define idiRHDxText             7
#define idiRHLines              8

#define idiDivPNStart           3
#define idiDivLMarg             4
#define idiDivRMarg             5
#define idiDivTMarg             6
#define idiDivBMarg             7

#ifdef INTL

#define idiDivInch              8
#define idiDivCm                9

#endif   /* INTERNATIONAL */


#endif  /* NOIDIFORMATS */

#define idiFind                 7
#define idiChangeThenFind       9
#define idiChange               3
#define idiChangeAll            4

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
#define idiDistinguishDandS             10
#endif

#define idiWholeWord            5
#define idiMatchCase            6
#define idiFindNext             idiOk
#define idiChangeTo             8

#define idiHelp                 3
#define idiHelpTopics           3
#define idiHelpNext             4
#define idiHelpPrev             5
#define idiHelpName             6
#define idiMemFree              7
#define idiHelpScroll           8

#define idiBMrgLeft             3
#define idiBMrgRight            4
#define idiBMrgTop              5
#define idiBMrgBottom           6

#define idiConvertPrompt    99

#ifdef JAPAN                  // added  09 Jun. 1992  by Hiraisi
#define idiChangeFont    101
#endif

/* Dialog Box ID's (substitite for Template Name strings) */

#define dlgOpen                 1
#define dlgSaveAs               2
/* #define dlgSaveScrap            3 */

  /* dlgWordCvt takes the position of the commented out Save Scrap box */
#define dlgWordCvt              3

#define dlgHelp                 4
#define dlgHelpInner            22
#define dlgPrint                5
#define dlgCancelPrint          6
#define dlgRepaginate           7
#define dlgCancelRepage         8
#define dlgSetPage              9
#define dlgPageMark             10
#define dlgPrinterSetup         11
#define dlgFind                 12
#define dlgChange               13
#define dlgGoTo                 14
#define dlgCharFormats          15
#define dlgParaFormats          16
#define dlgRunningHead          17
#define dlgFooter               18
#define dlgTabs                 19
#define dlgDivision             20
#define dlgBadMargins           21

#ifdef JAPAN                  // added  09 Jun. 1992  by Hiraisi
#define dlgChangeFont           23
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\doc.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* doc.c -- MW document processing routines (non-resident) */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOHDC
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "editdefs.h"
#include "docdefs.h"
#include "fontdefs.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "str.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#define NOKCCODES
#include "ch.h"
#include "stcdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "macro.h"


extern struct DOD (**hpdocdod)[];
extern int     docMac;
extern int     docScrap;
extern int     docUndo;
#ifdef STYLES
#ifdef SAND
extern CHAR    szSshtEmpty[];
#else
extern CHAR    szSshtEmpty[];
#endif
#endif

/* E X T E R N A L S */
extern int docRulerSprm;
extern int              vfSeeSel;
extern struct SEP       vsepNormal;
extern struct CHP       vchpNormal;
extern int              docCur;
extern struct FLI       vfli;
extern int              vdocParaCache;
extern struct FCB       (**hpfnfcb)[];
extern struct UAB       vuab;
extern typeCP           cpMacCur;
extern struct SEL       selCur;
extern int              vdocExpFetch;
extern CHAR             (**hszSearch)[];
extern typeCP           vcpFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern struct CHP       vchpFetch;
#ifdef STYLES
extern struct PAP       vpapCache;
extern CHAR             mpusgstcBase[];
#endif
extern int              vrefFile;


struct PGTB **HpgtbCreate();


#ifdef ENABLE       /* This is never called */
int DocFromSz(sz, dty)
CHAR sz[];
/* Return doc if one with that name exists already */
{
int doc;
struct DOD *pdod = &(**hpdocdod)[0];
struct DOD *pdodMac = pdod + docMac;

if (sz[0] == 0)
        return docNil;

for (doc = 0; pdod < pdodMac; ++pdod, ++doc)
        if (pdod->hpctb != 0 && pdod->dty == dty &&
            FSzSame(sz, **pdod->hszFile)
#ifdef SAND
                                      && (pdod->vref == vrefFile)
#endif
                                                                  )
                {
                ++pdod->cref;
                return doc;
                }
return docNil;
}
#endif


KillDoc(doc)
int doc;
{ /* Wipe this doc, destroying any changes since last save */
extern int vdocBitmapCache;

if (doc == docScrap)
        return;         /* Can't be killed no-how */

if (--(**hpdocdod)[doc].cref == 0)
        {
        struct FNTB **hfntb;
#ifdef CASHMERE
        struct SETB **hsetb;
#else
        struct SEP **hsep;
#endif
        struct FFNTB **hffntb;
        struct TBD (**hgtbd)[];
        CHAR (**hsz)[];
        int docSsht;

        SmashDocFce( doc );

        /* Kill style sheet doc if there is one. */
        if ((docSsht = (**hpdocdod)[doc].docSsht) != docNil)
                KillDoc(docSsht);

        /* Free piece table, filename, and footnote (or style) table */
        FreeH((**hpdocdod)[doc].hpctb);
        (**hpdocdod)[doc].hpctb = 0; /* To show doc free */
        if ((hsz = (**hpdocdod)[doc].hszFile) != 0)
                FreeH(hsz);
        if ((hfntb = (**hpdocdod)[doc].hfntb) != 0)
                FreeH(hfntb);
#ifdef CASHMERE
        if ((hsetb = (**hpdocdod)[doc].hsetb) != 0)
                FreeH(hsetb);
#else
        if ((hsep = (**hpdocdod)[doc].hsep) != 0)
                FreeH(hsep);
#endif

        if ((hgtbd = (**hpdocdod)[doc].hgtbd) != 0)
                FreeH( hgtbd );
        if ((hffntb = (**hpdocdod)[doc].hffntb) != 0)
                FreeFfntb(hffntb);

        if (doc == vdocBitmapCache)
            FreeBitmapCache();

        InvalidateCaches(doc);
        if (docCur == doc)
                docCur = docNil;
        if (docRulerSprm == doc)
                docRulerSprm = docNil;
        if (vuab.doc == doc || vuab.doc2 == doc)
                NoUndo();
        }
}



#ifdef STYLES
struct SYTB **HsytbCreate(doc)
int doc;
{ /* Create a map from stc to cp for a style sheet */
typeCP cp, *pcp;
struct SYTB **hsytb;
typeCP cpMac;
int stc, usg, stcBase, stcMin;
int ch, cch, cchT;
int *pbchFprop, *mpstcbchFprop;
CHAR *pchFprop, *grpchFprop;
int iakd, iakdT, cakd, cakdBase;
struct AKD *rgakd, *pakd;
#ifdef DEBUG
int cakdTotal;
#endif

CHAR    rgch[3];
CHAR    mpchcakc[chMaxAscii];
typeCP  mpstccp[stcMax];

/* First, clear out the stc-->cp map by filling with cpNil. */
for (stc = 0, pcp = &mpstccp[0]; stc < stcMax; stc++, pcp++)
        *pcp = cpNil;
bltbc(mpchcakc, 0, chMaxAscii);

/* Now go through all entries in the style sheet.  In this pass,
    check for duplicates (and return 0 if in gallery mode), fill
    mpstccp with appropriate entries for all defined stc's, and
    count the length of all the styles so we can allocate the heap
    block later. */
cpMac = (**hpdocdod)[doc].cpMac;
for (cp = 0, cch = 0, cakd = 1, cakdBase = 1; cp < cpMac; cp += ccpSshtEntry)
        {
        FetchRgch(&cchT, rgch, doc, cp, cpMac, 3);
        stc = rgch[0]; /* stc is first cp of entry */
#ifdef DEBUG
        Assert(stc < stcMax);
#endif
        if (mpstccp[stc] != cpNil && doc == docCur)
                { /* Repeated entry */
                Error(IDPMTStcRepeat);
                goto ErrRet;
                }
        mpstccp[stc] = cp;
        if (stc < stcSectMin)
                {
                FetchCp(doc, cp, 0, fcmProps);
                cch += CchDiffer(&vchpFetch, &vchpNormal, cchCHP) + 1;
                }
        if (stc >= stcParaMin)
                {
                CachePara(doc, cp);
                if (stc >= stcSectMin)
                        cch += CchDiffer(&vpapCache, &vsepNormal, cchSEP) + 1;
                else
                        cch += CchDiffer(&vpapCache, &vpapStd, cchPAP) + 1;
                }
        ch = rgch[1];
        if (ch != ' ')
                { /* Define an alt-key code for this style */
                ++cakd;
                if (rgch[2] == ' ')
                        {
                        if (mpchcakc[ch]-- != 0)
                                {
                                Error(IDPMTAkcRepeat);
                                goto ErrRet;
                                }
                        ++cakdBase;
                        }
                else
                        {
                        ++mpchcakc[ch];  /* increment before switch to avoid
                                                the increment being taken
                                                as for an int. */
                        switch (mpchcakc[ch])
                                {
                        case 0:
                                Error(IDPMTAkcRepeat);
                                goto ErrRet;
                        case 1:
                                ++cakdBase;
                                ++cakd;
                                }
                        }
                }
        }

/* Now allocate the heap block, using the total we got above. */
/* HEAP MOVEMENT */
hsytb = (struct SYTB **) HAllocate(cwSYTBBase + cwAKD * cakd +
    CwFromCch(cch));

if (FNoHeap(hsytb))
        return hOverflow;

/* Now go through the stc-->cp map, filling in the stc-->fprop map
    in the sytb.  For each stc that isn't defined, determine which
    stc to alias it to (either the first of the usage or, if that
    one isn't defined, the first one of the first usage). Copy the
    actual CHP's, PAP's, and SEP's into grpchFprop. */
mpstcbchFprop = (**hsytb).mpstcbchFprop;
rgakd = (struct AKD *) (grpchFprop = (**hsytb).grpchFprop);
pchFprop = (CHAR *) &rgakd[cakd];
pcp = &mpstccp[0];
pbchFprop = &mpstcbchFprop[0];
*pbchFprop = bNil;
#ifdef DEBUG
cakdTotal = cakd;
#endif
for (stc = 0, usg = 0, stcBase = 0, stcMin = 0, iakd = 0;
   stc < stcMax;
      stc++, pcp++, pbchFprop++)
        {
        if (stc >= mpusgstcBase[usg + 1])
                { /* Crossed a usage or class boundary */
                *pbchFprop = bNil;
                stcBase = mpusgstcBase[++usg];
                if (stcBase == stcParaMin || stcBase == stcSectMin)
                        { /* Update the base; make std if none defined */
                        stcMin = stcBase;
                        }
                }
        if ((cp = *pcp) == cpNil)
                { /* No style defined; take first for usg or, failing
                     that, first style of this class. */
                if ((*pbchFprop = mpstcbchFprop[stcBase]) == bNil)
                        *pbchFprop = mpstcbchFprop[stcMin];
                }
        else
                { /* New style; copy the looks and bump the pointers */
                /* Char stc's have just FCHP; para has FPAP followed by
                        FCHP; sect has FSEP. */
                *pbchFprop = pchFprop - grpchFprop;
                if (stc >= stcParaMin)
                        { /* Para or sect */
                        CachePara(doc, cp);
                        if (stc >= stcSectMin)
                                cchT = CchDiffer(&vpapCache, &vsepNormal, cchSEP);
                        else
                                cchT = CchDiffer(&vpapCache, &vpapStd, cchPAP);
                        if ((*pchFprop++ = cchT) != 0)
                                bltbyte(&vpapCache, pchFprop, cchT);
                        pchFprop += cchT;
                        }
                if (stc < stcSectMin)
                        { /* Char or para */
                        FetchCp(doc, cp, 0, fcmProps);
                        cchT = CchDiffer(&vchpFetch, &vchpNormal, cchCHP);
                        if ((*pchFprop++ = cchT) != 0)
                                bltbyte(&vchpFetch, pchFprop, cchT);
                        pchFprop += cchT;
                        }
                /* Insert element in akd table */
                FetchRgch(&cchT, rgch, doc, cp, cpMac, 3);
                if ((ch = rgch[1]) == ' ')
                        continue;
                if (rgch[2] == ' ')
                        { /* Single-key akc */
                        pakd = &rgakd[iakd++];
                        pakd->ch = ch;
                        pakd->fMore = false;
                        pakd->ustciakd = stc;
                        }
                else
                        { /* Two-char akc */
                        for (iakdT = 0; iakdT < iakd; iakdT++)
                                if (rgakd[iakdT].ch == ch)
                                        {
                                        pakd = &rgakd[rgakd[iakdT].ustciakd +
                                            --mpchcakc[ch]];
                                        pakd->ch = rgch[2];
                                        pakd->fMore = true;
                                        pakd->ustciakd = stc;
                                        do
                                                if ((++pakd)->ch == rgch[2])
                                                        {
                                                        Error(IDPMTAkcRepeat);
                                                        FreeH(hsytb);
                                                        goto ErrRet;
                                                        }
                                            while (pakd->fMore);
                                        goto NextStc;
                                        }
                        pakd = &rgakd[iakd++];
                        pakd->ch = ch;
                        pakd->fMore = true;
                        pakd->ustciakd = (cakd -= mpchcakc[ch]);
                        pakd = &rgakd[cakd + --mpchcakc[ch]];
                        pakd->ch = rgch[2];
                        pakd->fMore = false;
                        pakd->ustciakd = stc;
                        }
                }
NextStc: ;
        }

pakd = &rgakd[iakd++];
pakd->ch = ' ';
pakd->fMore = false;
pakd->ustciakd = stcNormal;

#ifdef DEBUG
Assert(grpchFprop + cchAKD * cakdTotal + cch == pchFprop && iakd == cakd);
#endif
return hsytb;

ErrRet:
Select(cp, cp + ccpSshtEntry);
vfSeeSel = true;
return 0;
}
#endif /* STYLES */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\doprm.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* doprm.c -- MW Property modifying routines */
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NOATOM
#define NOMETAFILE
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOPEN
#define NOBITMAP
#define NOCOLOR
#define NODRAWTEXT
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NORESOURCE
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "macro.h"
#include "dispdefs.h"
#include "fontdefs.h"

/* E X T E R N A L S */
extern int		rgxaRulerSprm[];
extern struct PAP	*vppapNormal;
extern struct CHP	vchpNormal;
extern CHAR		dnsprm[];
extern struct CHP      vchpNormal;
extern struct SEP      vsepStd;
extern struct SEP      vsepNormal;

#ifdef CASHMERE
extern struct TBD	rgtbdRulerSprm[];
#endif

/* List of approved font sizes, in half points */
#ifdef INTL
int rghps[csizeApprovedMax] = {8, 12, 16, 20, 24, 28, 36, 48, 60, 72, 96, 144, 254};
#else
int rghps[csizeApprovedMax] = {8, 12, 16, 20, 24, 32, 40, 48, 60, 72, 96, 144, 254};
#endif /* if-else-def INTL */

CHAR *PchFromFc();


/* D O	P R M */
DoPrm(struct CHP *pchp, struct PAP *ppap, struct PRM prm)
	{ /* Apply prm to char and para properties */
	if (bPRMNIL(prm))
		return;
	if (((struct PRM *) &prm)->fComplex)
		{
		int	cch;
		CHAR	*pfsprm;
		struct FPRM *pfprm = (struct FPRM *) PchFromFc(fnScratch,
			fcSCRATCHPRM(prm), &cch);

		cch = pfprm->cch;
		pfsprm = pfprm->grpfsprm;

		while (cch > 0)
			{
			int cchT;
			int sprm;

			DoSprm(pchp, ppap, sprm = *pfsprm, pfsprm + 1);
			if ((cchT = (dnsprm[sprm] & ESPRM_cch)) == 0)
				cchT = CchPsprm(pfsprm);
			cch -= cchT;
			pfsprm += cchT;
			}
		}
	else
/* Simple prm; single sprm */
		DoSprm(pchp, ppap, ((struct PRM *) &prm)->sprm,
				&((struct PRM *) &prm)->val);
}

/* D O	S P R M */
/* Apply a single property modifier to para/char prop */
DoSprm(pchp, ppap, sprm, pval)
struct CHP *pchp;
struct PAP *ppap;
int	    sprm;
CHAR	   *pval;
	{
	int *pvalTo;
	int val = *pval;

#ifdef DEBUG
	Assert(sprm > 0 && sprm < sprmMax);
#endif
	if ((dnsprm[sprm] & ESPRM_sgc) != sgcChar)
		{
		if (ppap != 0)
			{
			struct TBD *ptbd;
			int rhc;
			int fGraphics;

			ppap->fStyled = fFalse;
			switch (sprm)
				{
			case sprmPLMarg:
				pvalTo = &ppap->dxaLeft;
				break;
			case sprmPRMarg:
				pvalTo = &ppap->dxaRight;
				break;
			case sprmPFIndent:
				pvalTo = &ppap->dxaLeft1;
				break;
			case sprmPJc:
				ppap->jc = val;
				return;
#ifdef CASHMERE
			case sprmPRuler:
/* Ruler and Ruler1 rely on the fact that rgxaRulerSprm and PAP both
align R, L, L1 in that order.
Ruler: apply the current state of the ruler */
				blt(&rgxaRulerSprm[0], &ppap->dxaRight, 3);
				blt(&rgtbdRulerSprm[0], ppap->rgtbd, itbdMax * cwTBD);
				return;
			case sprmPRuler1:
/* as Ruler, except information is at pval+1 and pval+"7" */
				bltbyte((CHAR *)(pval + 1), &ppap->dxaRight, 3 * cchINT);
/* append terminating 0 word to tab table */
				bltc(bltbyte((CHAR *)(pval + 1 + (3 * cchINT)), ppap->rgtbd,
					val - (3 * cchINT)), 0, cchINT);
				return;
			case sprmPRgtbd:
				bltc(bltbyte(pval + 1, ppap->rgtbd,
					val), 0, cchINT);
				return;
			case sprmPKeep:
				ppap->fKeep = val;
				return;
			case sprmPKeepFollow:
				ppap->fKeepFollow = val;
				return;
#endif
			case sprmPDyaLine:
				pvalTo = &ppap->dyaLine;
				break;
#ifdef CASHMERE
			case sprmPDyaBefore:
				pvalTo = &ppap->dyaBefore;
				break;
			case sprmPDyaAfter:
				pvalTo = &ppap->dyaAfter;
				break;
#endif
			case sprmPRhc:
				ppap->rhc = val;
				return;
			case sprmPRhcNorm:
				/* (int) dxaLeftAdj + (int) dxaRightAdj */
				Assert(*pval == 4);
				pval++; /* skip over cch */
				ppap->dxaLeft = imax( 0,
					 ppap->dxaLeft - *(int *) pval);
				ppap->dxaRight = imax( 0,
					 ppap->dxaRight - *((int *) pval + 1));
				return;
			case sprmPNormal:
				rhc = ppap->rhc;
				fGraphics = ppap->fGraphics;
				blt(vppapNormal, ppap, cwPAPBase);
				goto LSame;
			case sprmPSame:
				rhc = ppap->rhc;
				fGraphics = ppap->fGraphics;
/* note: tab terminating 0 MUST be part of value if tab table is to be changed */
				bltbyte(pval + 1, ppap, val - 1);
LSame:				ppap->rhc = rhc;
				ppap->fGraphics = fGraphics;
				return;
#ifdef CASHMERE
			case sprmPNest:
				if (ppap->rgtbd[0].dxa != 0 &&
				    ppap->rgtbd[0].dxa == ppap->dxaLeft &&
				    ppap->rgtbd[1].dxa == 0)
					ppap->rgtbd[0].dxa += dxaNest;
				ppap->dxaLeft += dxaNest;
				return;
			case sprmPUnNest:
				if (ppap->rgtbd[0].dxa != 0 &&
				    ppap->rgtbd[0].dxa == ppap->dxaLeft &&
				    ppap->rgtbd[1].dxa == 0)
					ppap->rgtbd[0].dxa -= dxaNest;
				ppap->dxaLeft = max(0, (int)(ppap->dxaLeft - dxaNest));
				return;
			case sprmPHang:
				ppap->dxaLeft = umin(ppap->dxaLeft + cxaInch, xaRightMax - cxaInch);
				ppap->dxaLeft1 = -cxaInch;
				ptbd = &ppap->rgtbd[0];
				SetWords(ptbd, 0, cwTBD * 2);
				ptbd->dxa = ppap->dxaLeft;
				/* Inefficient:
				ptbd->tlc = tlcWhite;
				ptbd->jc = jcLeft;
				++ptbd->dxa = 0 */
				return;
#endif
			default:
				Assert(FALSE);
				return;
				}
	/* common portion for those transferring a single word */
			bltbyte(pval, pvalTo, cchINT);
			}
		return;
		}
	else
		{
		if (pchp != 0)
			{
			int fSpecial;
			int ftc, hps;

			pchp->fStyled = fFalse;
			switch (sprm)
				{
			/* CHARACTER sprm's */
			case sprmCBold:
				pchp->fBold = val;
				return;
			case sprmCItalic:
				pchp->fItalic = val;
				return;
			case sprmCUline:
				pchp->fUline = val;
				return;
#ifdef CASHMERE
			case sprmCOutline:
				pchp->fOutline = val;
				return;
			case sprmCShadow:
				pchp->fShadow = val;
				return;
			case sprmCCsm:
				pchp->csm = val;
				return;
#endif
			case sprmCPos:
		/* If going in or out of sub/superscript, alter font size */
				if (pchp->hpsPos == 0 && val != 0)
					pchp->hps = HpsAlter(pchp->hps, -1);
				else if (pchp->hpsPos != 0 && val == 0)
					pchp->hps = HpsAlter(pchp->hps, 1);
				pchp->hpsPos = val;
				return;
			case sprmCFtc:
			case sprmCChgFtc:
				pchp->ftc = val & 0x003f;
				pchp->ftcXtra = (val & 0x00c0) >> 6;
				return;
			case sprmCHps:
				pchp->hps = val;
				return;
			case sprmCChgHps:
				pchp->hps = HpsAlter(pchp->hps,
					val >= 128 ? val - 256 : val); /* sign extend from char to int */
				return;
			case sprmCSame:
				fSpecial = pchp->fSpecial;
				bltbyte(pval, pchp, cchCHP);
				pchp->fSpecial = fSpecial;
				return;
			case sprmCPlain:
				fSpecial = pchp->fSpecial;
				ftc = FtcFromPchp(pchp);
				hps = pchp->hps;
		/* If we used to be sub/superscript, increase font size */
				if (pchp->hpsPos != 0)
					hps = HpsAlter(hps, 1);
				blt(&vchpNormal, pchp, cwCHP);
				pchp->fSpecial = fSpecial;
				pchp->ftc = ftc & 0x003f;
				pchp->ftcXtra = (ftc & 0x00c0) >> 6;
				pchp->hps = hps;
				return;
			case sprmCMapFtc:
				/* val is ftcMac for mapping */
				/* pval+1 points to ftcMac mapping bytes */
				ftc = pchp->ftc + (pchp->ftcXtra << 6);
				Assert(ftc < val);
				ftc = *(pval + 1 + ftc);
				pchp->ftc = ftc & 0x003f;
				pchp->ftcXtra = (ftc & 0x00c0) >> 6;
				return;
			case sprmCOldFtc:
				ftc = pchp->ftc + (pchp->ftcXtra << 6);
				ftc = FtcMapOldFtc(ftc, pval);
				pchp->ftc = ftc & 0x003f;
				pchp->ftcXtra = (ftc & 0x00c0) >> 6;
				return;
			default:
				Assert(FALSE);
				return;
				}
			}
		}
}

/* C C H  P S P R M */
/* returns length of sprm's that are of variable or large size.
(cch = (esprm & ESPRM_cch)) == 0 must be checked before calling.*/
CchPsprm(psprm)
CHAR *psprm;
{
	return (*psprm == sprmCSame ? cchCHP + 1 :
/* PSame, PRgtbd, PRuler1, CMapFtc, COldFtc: */
		*(psprm + 1) + 2);
}

int HpsAlter(hps, ialter)
int	hps, ialter;
{	/* Return the hps of the approved font size that is ialter steps
		away from the given size. I.e.: if ialter is -1, then return
		the next smaller size. If alter is 0, return hps.  */
        /* return 0 if request exceeds limits (11.15.91) v-dougk */
int isize;

if (ialter == 0)
	return hps;

/* Find the size just larger than the given size. */
if (ialter > 0)
	{
	    for (isize = 0; isize < csizeApprovedMax - 1; ++isize)
		    if (rghps[isize] > hps) break;
	    isize = min(csizeApprovedMax - 1, isize + ialter - 1);
	    return max(hps, rghps[isize]);
	}
else
	{
	for (isize = 0; isize < csizeApprovedMax; ++isize)
		if (rghps[isize] >= hps) break;
	isize = max(0, isize + ialter);
	return min(hps, rghps[isize]);
	}
}

BOOL CanChangeFont(int howmuch)
{
    extern struct CHP vchpSel;
    extern struct SEL       selCur;
    int hps;

    if (selCur.cpFirst != selCur.cpLim)
        return TRUE;

    hps = HpsAlter(vchpSel.hps, howmuch);
    return ((hps <= rghps[csizeApprovedMax-1]) && 
            (hps >= rghps[0]));
}

FtcMapOldFtc(ftc, ftctb)
/* maps an old word font code into one of our selection */

int ftc;
CHAR *ftctb;
{
#ifdef WIN30
int iftc = iftcSwiss;   /* Default to SOMEthing! ..pault */
#else
int iftc ;
#endif

if (ftc == 8)
	/* helvetica */
	iftc = iftcSwiss;
else if (ftc < 16)
	iftc = iftcModern;
else if (ftc < 32)
	iftc = iftcRoman;
else if (ftc < 40)
	iftc = iftcScript;
else if (ftc < 48)
	iftc = iftcDecorative;
Assert(iftc < *ftctb);
return(*(ftctb + 1 + iftc));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\doslib.asm ===
TITLE   doslib - DOS access library routines

; Windows Write, Copyright 1985-1992 Microsoft Corporation
; =====================================================================
;   This file contains DOS access routines.
;   These routines are general, simple calls to DOS and
;   are likely to be generally useful.  They assume /PLM calling
;   is used.
;   FAR calls are used throughout
;
;
;   NOTE: DOSLIB.H CONTAINS A C HEADER DEFINING THE FUNCTIONS IN THIS
;   MODULE.  IT MUST BE UPDATED WHENEVER A FUNCTION IS ADDED OR AN INTERFACE
;   CHANGES
; =====================================================================


; =====================================================================
;   cmacros2.inc is a special version of cmacros.inc in which the only
;   difference is that it defines the segment for assembly code to
;   be FILE_TEXT instead of _TEXT.
;   This is done so that functions in FILE.C will
;   not call intermodule and subject themselves to possible file closure
;   when calling DOS functions.
; =====================================================================
include cmacros2.inc

sBegin  DATA
ifdef DEBUG
EXTRN   vfCommDebug:WORD
endif
sEnd    DATA


cchMaxFile  EQU     128
EXTRN   ANSITOOEM:FAR

sBegin      CODE
            assumes CS,CODE

; ---------------------------------------------------------------------
; int FAR CchCurSzPath( szPath, bDrive )
; PSTR szPath;
; int bDrive;
;
; Copy the current path name for the current drive into szPath
; szPath must have 67 bytes of storage
;
; bDrive is 0=default, 1=A, 2=B,...
;
; Returned cch includes the terminating '\0'
; Form of returned string is e.g. "C:\WINDOWS\BIN\" (0-terminated)
; String is guaranteed to: (1) Include the drive letter, colon, and leading "\"
;                          (2) End with a backslash
;
; 0 = an error occurred, nonzero = success
; the path string will be NULL if an error occurred
; An error should really not be possible, since the default drive ought to be
; valid
; ---------------------------------------------------------------------

cProc       CchCurSzPath, <FAR, PUBLIC>, <SI>
parmDP      <szPath>
parmB       <bDrive>
cBegin      CchCurSzPath

            mov     al,bDrive
            mov     dl,al
            cmp     al,0
            jz      cspDFLTDRV  ; default drive
            dec     al
            jmp     cspGOTDRV   ; not default drive

cspDFLTDRV:
            mov     ah,19h      ; Get current drive
            int     21h

            ; now we have al: 0=A, 1=B, ....
            ;             dl: 0=default, 1=A, 2=B

cspGOTDRV:                      ; Put "X:\" at front of szPath
            add     al,'A'
            mov     si,szPath
            mov     [si],al
            mov     BYTE PTR [si+1],':'
            mov     BYTE PTR [si+2],'\'  ; Leave si pointing at szPath

            add     si,3        ; Rest of path goes at SzPath+3
            mov     ah,47h
            int     21h
            mov     si,szPath
            jc      cspERR      ; error -- return negative of err code in AX

            dec     si          ; Path was OK - find null terminator
cspLOOP:    inc     si
            cmp     al,[si]
            jnz     cspLOOP

            cmp     BYTE PTR [si-1],'\' ; Append backslash if needed
            jz      cspSTROK            ; not needed, string is already OK
            mov     BYTE PTR [si],'\'
            inc     si
            mov     BYTE PTR [si],0
cspSTROK:                               ; now we are guaranteed a good string
            mov     ax,si               ; determine string length
            sub     ax,szPath
            inc     ax
            jmp     cspRET

cspERR:     mov     BYTE PTR [si],0         ;  error -- NULL path string
            neg     ax
cspRET:
cEnd        CchCurSzPath


ifdef ENABLE
;-----------------------------------------------------------------------------
; DOSHND FAR WCreateNewSzFfname( szFfname, attrib )
;
; Create specified file, leave open for read/write, return handle
; filename is an ffname, with drive and path. Uses the NEW
; DOS 3.0 CREATE call which fails if the file exists. Caller has
; responsibility for assuring DOS version number sufficiently high
;
; returned handle is negative if there was an error
; the value will be the negative of the error code returned in AX
;-----------------------------------------------------------------------------

cProc WCreateNewSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>
parmW   <attrib>
cBegin WCreateNewSzFfname

    mov     dx,szFfname
    mov     cx,attrib
    mov     ah,5bh
    int     21h
    jnc     cnsfdone
    neg     ax          ; error - return the negative of the error code
cnsfdone:
cEnd WCreateNewSzFfname

;-----------------------------------------------------------------------------
; DOSHND FAR WCreateSzFfname( szFfname, attrib )
;
; Create specified file, leave open for read/write, return handle
; filename is an ffname, with drive and path
;
; returned handle is negative if there was an error
; the value will be the negative of the error code returned in AX
;-----------------------------------------------------------------------------

cProc WCreateSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>
parmW   <attrib>
cBegin WCreateSzFfname

    mov     dx,szFfname
    mov     cx,attrib
    mov     ah,3ch
    int     21h
    jnc     csfdone
    neg     ax          ; error - return the negative of the error code
csfdone:
cEnd WCreateSzFfname
endif

;-----------------------------------------------------------------------------
; int DosxError()
;
; Return a DOS extended error code
;-----------------------------------------------------------------------------

cProc DosxError, <FAR, PUBLIC>
cBegin DosxError
    mov     ah,59h
    mov     bx,0    ; bug fix, 10/2/86, BryanL
    int     21h
cEnd DosxError


;-----------------------------------------------------------------------------
; WORD WDosVersion()
;
; Return a word indicating DOS version, major in low 8 bits, minor in high 8
;-----------------------------------------------------------------------------

cProc WDosVersion, <FAR, PUBLIC>
cBegin WDosVersion
    mov     ah,30h
    int     21h
cEnd WDosVersion


;-----------------------------------------------------------------------------
; WORD DaGetFileModeSz(sz)
;
; Return a word indicating attributes of file sz (EXPECTED IN ANSI);
; 0xFFFF if it fails.
;-----------------------------------------------------------------------------

cProc DaGetFileModeSz, <FAR, PUBLIC>
parmDP  <sz>
localV  <szOem>,cchMaxFile

cBegin DaGetFileModeSz
    ; Convert filename from ANSI set to OEM Set

    push    ds
    push    sz
    push    ds
    lea     ax,szOem
    push    ax
    call    ANSITOOEM

    lea     dx,szOem
    mov     ax,4300h

    int     21h
    mov     ax, cx
    jnc     daNoErr
    mov     ax, 0ffffh      ; error -- return 0xFFFF
daNoErr:
cEnd DaGetFileModeSz

; WRITE uses OpenFile instead
ifdef ENABLE
;-----------------------------------------------------------------------------
; DOSHND FAR WOpenSzFfname( szFfname, openmode )
;
; Open specified file in specified mode, return a handle or
; the negative of an error code if the open failed
;-----------------------------------------------------------------------------

cProc WOpenSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>
parmB   <openmode>
cBegin WOpenSzFfname

    mov     dx,szFfname
    mov     al,openmode
    mov     ah,3dh

    int     21h
    jnc     osfdone
    neg     ax          ; error - return the negative of the error code
osfdone:
cEnd WOpenSzFfname

endif

;-----------------------------------------------------------------------------
; int FAR FCloseDoshnd( doshnd )
;
; Close file given DOS handle, return 0 = error, nonzero = no error
;-----------------------------------------------------------------------------

cProc FCloseDoshnd, <FAR, PUBLIC>
parmW   <doshnd>
cBegin FCloseDoshnd

    mov     bx,doshnd
    mov     ah,3eh

    int     21h
    mov     ax,0000
    jc      cdhskip     ; error, leave a zero in ax
    inc     ax
cdhskip:
cEnd FCloseDoshnd

;-----------------------------------------------------------------------------
; int FAR FpeDeleteSzFfname( szFfname )
;
; Delete specified file, return < 0=failure, 0=success
;-----------------------------------------------------------------------------

cProc FpeDeleteSzFfname, <FAR, PUBLIC>
parmDP  <szFfname>

localV  <szOem>,cchMaxFile

cBegin FpeDeleteSzFfname

    ; Convert filename from ANSI set to OEM Set

    push    ds
    push    szFfname
    push    ds
    lea     ax,szOem
    push    ax
    call    ANSITOOEM

    lea     dx,szOem
    mov     ah,41h

    int     21h
    jc      dsfskip     ; error - return the negative of the error code
    mov     ax,0ffffh
dsfskip:
    neg     ax
cEnd FpeDeleteSzFfname

;-----------------------------------------------------------------------------
; int FAR FpeRenameSzFfname( szCur, szNew )
;
; Rename file szCur to szNew, return < 0=failure, 0=success
;-----------------------------------------------------------------------------

cProc FpeRenameSzFfname, <FAR, PUBLIC>, <ES,DI>
parmDP  <szCur>
parmDP  <szNew>

localV  <szCurOem>,cchMaxFile
localV  <szNewOem>,cchMaxFile

cBegin FpeRenameSzFfname

    ; Convert filenames to Oem char set

    push    ds
    push    szCur
    push    ds
    lea     ax,szCurOem
    push    ax
    call    ANSITOOEM
    push    ds
    push    szNew
    push    ds
    lea     ax, szNewOem
    push    ax
    call    ANSITOOEM

    lea     dx,szCurOem   ; old filename in ds:dx
    push    ds            ; new filename in es:di
    pop     es
    lea     di,szNewOem
    mov     ah,56h

    int     21h
    jc      rnfskip     ; error - return the negative of the error code
    mov     ax,0ffffh
rnfskip:
    neg     ax
cEnd FpeRenameSzFfname

;-----------------------------------------------------------------------------
; int CchReadDoshnd ( doshnd, lpchBuffer, bytes )
;
; Read bytes from an open file, place into buffer
; Returns # of bytes read (should be == bytes unless EOF or error)
; If an error occurs, returns the negative of the error code
;-----------------------------------------------------------------------------

cProc CchReadDoshnd, <FAR, PUBLIC>, <DS>
parmW   <doshnd>
parmD   <lpchBuffer>
parmW   <bytes>
cBegin CchReadDoshnd

    mov     bx,doshnd
    lds     dx,lpchBuffer
    mov     cx,bytes
    mov     ah,3fh

    int     21h
    jnc     crdone

    neg     ax          ; error - return value is the negative of the error code
crdone:
cEnd CchReadDoshnd




;-----------------------------------------------------------------------------
; int CchWriteDoshnd ( doshnd, lpchBuffer, bytes )
;
; Write bytes from an open file, place into buffer
; Returns # of bytes read (should be == bytes unless EOF or error)
; If an error occurs, returns the negative of the error code
; Disk full is not an "error"; detect it by return code != bytes
;-----------------------------------------------------------------------------

cProc CchWriteDoshnd, <FAR, PUBLIC>,<DS>
parmW   <doshnd>
parmD   <lpchBuffer>
parmW   <bytes>
cBegin CchWriteDoshnd

    mov     bx,doshnd
    lds     dx,lpchBuffer
    mov     cx,bytes
    mov     ah,40h

    int     21h
    jnc     cwdone

    neg     ax              ; error: return the negative of the error code
cwdone:

cEnd CchWriteDoshnd




;-----------------------------------------------------------------------------
; long DwSeekDw ( doshnd, dwSeekpos, bSeekfrom )
;
; Seek to requested position in file
; bSeekfrom is:  0 = seek relative to beginning of file
;                1 = seek relative to current pointer location
;                2 = seek relative to end of file
;
; Returns the new location of the read/write pointer (a long)
; If an error occurs, returns the negative of the error code (long)
;-----------------------------------------------------------------------------

cProc DwSeekDw, <FAR, PUBLIC>
parmW   <doshnd>
parmD   <dwSeekpos>
parmB   <bSeekfrom>
cBegin DwSeekDw

    mov     bx,doshnd
    mov     cx,SEG_dwSeekpos
    mov     dx,OFF_dwSeekpos
    mov     al,bSeekfrom
    mov     ah,42h

    int     21h
    jnc     seekdone

    neg     ax              ; Error: return the negative of the error code
    mov     dx,0ffffH

seekdone:

cEnd DwSeekDw


; WRITE does not use these currently

ifdef ENABLE
;-----------------------------------------------------------------------------
; int FAR FFirst(pb, szFileSpec, attrib)
; Get first directory entry, place in buffer at pb. (buffer must contain
;                                                    43 bytes of storage)
; attrib specifies attribute per MSDOS spec.
; szFileSpec is filename specification
; Returns 0=no error, nonzero = error
;-----------------------------------------------------------------------------

cProc FFirst, <FAR, PUBLIC>, <SI, DI>
parmDP  <pb, szFileSpec>
parmW   <attrib>
cBegin FFirst

    mov     dx,pb       ; set dta to pb
    mov     ah,1ah
    int     21h

    mov     cx,attrib   ; get first directory record, place in *pb
    mov     dx,szFileSpec
    mov     ah,4eh
    int     21h
    jc     ffdone
    xor     ax,ax

ffdone:
cEnd FFirst


;-----------------------------------------------------------------------------
; int FAR FNext(pb)
; Get next directory entry, place in buffer at pb.
; Return 0= found match OK, nonzero = error or no more matches
;-----------------------------------------------------------------------------

cProc FNext, <FAR, PUBLIC>, <SI, DI>
parmDP  <pb>
cBegin FFirst

    mov     dx,pb       ; set dta to pb
    mov     ah,1ah
    int     21h

    mov     ah,4fh
    int     21h
    jc     fndone
    xor     ax,ax

fndone:
cEnd FNext

endif

ifdef OLDDEBUG
  /* This method isn't quite working under Win 3.0 ..pault */
;-----------------------------------------------------------------------------
; void CommSz( sz ) - put out string to AUX device
;
; For debugging
;-----------------------------------------------------------------------------

cProc CommSz, <FAR, PUBLIC>
parmDP  <sz>
cBegin CommSz

CommSz1:
    mov     bx, sz          ; if ((dl = *(sz++)) == 0)  goto CommSz2
    inc     sz
    mov     dl, [bx]
    cmp     dl, 0
    jz      CommSz2

    call    DebugOutput     ; Output dl to AUX or LPT device

    jmp     CommSz1

CommSz2:

cEnd CommSz

;-----------------------------------------------------------------------------
; static void DebugOutput - put character to AUX or LPT device
;                   if (vfCommDebug)
;                        output to AUX port
;                   else output to LPT port
;   input:  dl = character
;   output: none. Uses ah
;
;-----------------------------------------------------------------------------

            assumes ds,DATA
DebugOutput PROC    NEAR

    mov     ah,4            ; Assume AUX device
    test    vfCommDebug,0ffh
    jnz     DebugOut1
    inc     ah              ; Change to LPT device
DebugOut1:
    int     21h             ; Output character
    ret

DebugOutput ENDP

endif ;DEBUG

sEnd        CODE



            END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\doslib.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*  Include file with headers for functions in DOSLIB.ASM */

typedef unsigned DOSHND;        /* DOS handle */
typedef DOSHND typeOSFN;        /* General WRITE type for OS file handle */
struct TIM {                    /* Time structure returned by OsTime */
    CHAR minutes, hour, hsec, sec;
    };

int CchCurSzPath( CHAR *, CHAR );

#ifdef ENABLE   /* We are not currently using these */
int FFirst( CHAR near *, PSTR, int );
int FNext( CHAR near * );
DOSHND  WOpenSzFfname( CHAR *, int );
#endif

WORD    DaGetFileModeSz(CHAR *);
void    OsTime( struct TIM * );     /* NOTE: function moved to lib.asm */
DOSHND  WCreateNewSzFfname( CHAR *, int );
DOSHND  WCreateSzFfname( CHAR *, int );
int     CchReadDoshnd( DOSHND, CHAR FAR *, int );
int     CchWriteDoshnd( DOSHND, CHAR FAR *, int );
int     FCloseDoshnd( DOSHND );
WORD    WDosVersion( void );
int     DosxError( void );
long    DwSeekDw( DOSHND, long, int );
int     FpeDeleteSzFfname( CHAR * );
int     FpeRenameSzFfname( CHAR *, CHAR * );


#define DA_NORMAL       0x00    /* DOS File Attribute */
#define DA_READONLY     0x01    /* DOS File Attribute for read-only file */
#define DA_NIL          0xFFFF  /* Error DA */
#define dosxSharing     32      /* Extended error code for sharing viol. */
#define nErrNoAcc       5       /* OpenFile error code for Access Denied */
#define nErrFnf         2       /* OpenFile error code for File Not Found */
#define bSHARE_DENYRDWR 0x10    /* Sharing Open mode for exclusive use */

/* Error condition returned by "CCH" returning DOS functions, e.g. read */

#define FIsErrCchDisk(cch)   ((int)(cch) < 0)

#define cchDiskHardError    -1      /* Bogus error code, not returned by DOS */
#define fpeHardError        -1      /* also */

/* Error condition returned by functions that return DOS handles */

#define FIsErrDoshnd(doshnd)        ((int)(doshnd) < 0)

/* DOS Error codes */
/* These are the negative of the codes returned in AX by DOS functions */
#define fpeFnfError      -2      /* File Not Found */
#define fpeBadPathError  -3      /* Bad Path (path not found) */
#define fpeNoHndError    -4      /* No Handles Available */
#define fpeNoAccError    -5      /* Access Denied */
#define fpeBadHndError   -6      /* Bad handle passed in */
#define fpeNoDriveError  -15     /* Non-existent drive passed in */
#define fpeExistError    -80     /* File exists */

/* Seek-from type codes passed to DOS function 42H */

#define SF_BEGINNING    0       /* Seek from beginning of file */
#define SF_CURRENT      1       /* Seek from current file pointer */
#define SF_END          2       /* Seek from end of file */

/* Error test for seek position */

#define FIsErrDwSeek(dw)    ((long)(dw) < (long)0)

/* Error test for fpe-returning functions */

#define FIsErrFpe(fpe)     ((int)(fpe) < 0)

/* Tests whether an error is a hardware error.  Hardware errors are caught
   and prompted for by Windows, so we should not duplicate those prompts.
   Chrisp says these DOS 3.0 error codes are generated by Windows for all
   supported versions of DOS
   fpe is WRITE's error type; ofe is the unadulturated error returned by
   DOS or OpenFile */

#define ofeCaughtFirst      19
#define ofeCaughtLast       27

#define FIsCaughtOfe(ofe)   (((ofe)>=ofeCaughtFirst)&&((ofe)<=ofeCaughtLast))
#define FIsCaughtFpe(fpe)   FIsCaughtOfe(-(fpe))
#define FIsCaughtDwSeekErr(dw)  FIsCaughtFpe((int)(dw))

#define FpeFromCchDisk(cch) (cch)

#define fpeNoErr            0

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\d_disp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* disp.c -- MW display routines */

#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOWINSTYLES
//#define NOVIRTUALKEYCODES

#ifndef DBCS
#define NOSYSMETRICS
#endif

#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NOWH
#define NOWINOFFSETS
#define NOMETAFILE

#ifndef DBCS
#define NOMB
#endif

#define NODRAWTEXT
#include <windows.h>

#define NOUAC
#include "mw.h"
#include "debug.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#define NOKCCODES       /* Removes all kc code defines */
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "macro.h"
#include "printdef.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef DBCS
#include "dbcs.h"
#include "kanji.h"
#endif

#ifdef  DBCS_IME
#include    <ime.h>

#ifdef  JAPAN
#include "prmdefs.h"    //IME3.1J
BOOL    ConvertEnable = FALSE;
BOOL    bClearCall = TRUE;
#endif      /* JAPAN */
#endif      /* DBCS_IME */

#ifdef CASHMERE     /* No VisiMode in WinMemo */
extern int              vfVisiMode;
#endif /* CASHMERE */

extern int              vcchBlted;
extern int              vidxpInsertCache;
extern int              vdlIns;
extern int              vfInsLast;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern int              rgval[];
extern struct DOD       (**hpdocdod)[];
extern typeCP           cpMacCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur, wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern int              docCur;
extern struct CHP       (**vhgchpFormat)[];
extern int              vichpFormat;
extern typeCP           cpMinCur;
extern typeCP           cpMinDocument;
extern int              vfInsertOn;
extern int              vfTextBltValid;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern unsigned         vpgn;
extern struct SEP       vsepAbs;
extern CHAR             stBuf[];
extern typeCP           CpEdge();
extern typeCP           CpMacText();
extern int              vdocPageCache;
extern int              vfPictSel;
extern int              vfAwfulNoise;
extern int              vfSkipNextBlink;
extern int              dypMax;
extern HDC              vhMDC;
extern HWND             vhWndPageInfo;
extern struct FMI       vfmiScreen;
extern int              docScrap;
extern long             rgbBkgrnd;
extern long             ropErase;
extern BOOL             vfMonochrome;
extern int              dxpbmMDC;
extern int              dypbmMDC;
extern HBITMAP          hbmNull;
extern int              vfOutOfMemory;
extern int              vfSeeSel;
extern int              vfInsEnd;   /* Is insert point at end-of-line? */
extern int              vipgd;
extern typeCP           vcpMinPageCache;
extern typeCP           vcpMacPageCache;
/* actual position of the cursor line */
extern int              vxpCursLine;
extern int              vypCursLine;

extern int              vdypCursLine;
extern int              vfScrollInval; /* means scroll did not take and UpdateWw must be repeated */
extern BOOL             vfDead;
extern HRGN             vhrgnClip;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
extern typeCP selUncpFirst;
extern typeCP selUncpLim;
extern HANDLE hImeUnAttrib;
extern int    vfImeHidden;

int     HiddenTextTop = 0;
int     HiddenTextBottom = 0;
//if TRUE we are managing IR_UNDETERMINE
BOOL    whileUndetermine = FALSE;   //12/28/92
LPSTR   Attrib;
WORD    AttribPos = 0;

#define IMEDEFCOLORS         6     // IME Define colors
#define IMESPOT              0     // IME Spot background color
#define IMESPOTTEXT          1     // IME Spot text color
#define IMEINPUT             2     // IME Input background color
#define IMEINPUTTEXT         3     // IME Input text color
#define IMEOTHER             4     // IME Other background color
#define IMEOTHERTEXT         5     // IME Other text color

COLORREF   rgbIMEHidden[IMEDEFCOLORS] = {0L,0L,0L,0L,0L,0L};

#endif


/* G L O B A L S
int dlsMac = 0;*/
#ifdef DBCS
int donteat = 0;    /* propagate not to eat message */
#endif


#if defined(TAIWAN) || defined(PRC)    //Daniel/MSTC, 1993/02/25, for jcBoth
#define FKana(_ch) FALSE
#endif


/* D I S P L A Y  F L I */
/* Display formatted line in window ww at line dl */


DisplayFli(ww, dl, fDontDisplay)
int ww;
int dl;
int fDontDisplay; /* True if we set up dl info but don't display */
    {
    typeCP dcp;
    typeCP dcpMac;
    struct WWD *pwwd = &rgwwd[ww];
    HDC hDC = pwwd->hDC;
    int xp;                     /* Current xp to write text */
    int yp;                     /* Current yp to write text */
    int xpMin = pwwd->xpMin;    /* Minimum xp in window */
    int xpMac = pwwd->xpMac;    /* Maximum xp in window */
    int ypLine;                 /* Screen yp for current line */
    int dxp;                    /* Width of current run */
    int dyp;                    /* Line height */
    int dxpExtra;               /* Width of pad for each space */
    typeCP cpMin;
    typeCP cpMac;
    int xpSel;                  /* xp of the start of the selection */
    int dxpSel = 0;             /* Width of the selection. */
    CHAR chMark = '\0';         /* style character */
    struct CHP *pchp;
    BOOL fTabsKludge = (vfli.ichLastTab >= 0);
    BOOL fInsertOn = FALSE;
    int cBreakRun;              /* break characters in run (no relation to Dick or Jane) */

#ifdef SMFONT
    RECT rcOpaque;
#endif /* SMFONT */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
    extern int vfWordWrap;    /* WordWrap flag : TRUE=ON, FALSE=OFF */
    extern int iNonWideSpaces;
    int iRun;
    typeCP RealcpFirst;

#elif defined(TAIWAN) || defined(PRC)
    extern int vfWordWrap;    /* WordWrap flag : TRUE=ON, FALSE=OFF */
    extern int iNonWideSpaces;
    int iRun;
    typeCP RealcpFirst;
#endif

#ifdef DDISP
    CommSzNumNum("    DisplayFli: dl/fDontDisplay ", dl, fDontDisplay);
#endif
    Assert(ww >= 0 && ww < wwMax);
#ifdef SMFONT
    Assert(!fDontDisplay || vfli.fGraphics)
#endif /* SMFONT */
    Scribble(5,'D');

    /* Fill up EDL and set some useful locals */
        {
        register struct EDL *pedl = &(**pwwd->hdndl)[dl];

        if (dl == vdlIns)
            {
            /* Overwriting chars blted during fast insert; reset blt count */
            vcchBlted = 0;
            vidxpInsertCache = -1;
            }

        pedl->xpLeft = vfli.xpLeft;
        pedl->xpMac = vfli.xpReal;
        cpMin = pedl->cpMin = vfli.cpMin;
#ifdef JAPAN
        RealcpFirst = cpMin;
#endif
        pedl->dcpMac = (cpMac = vfli.cpMac) - cpMin;
        dyp = pedl->dyp = vfli.dypLine;
        pedl->ichCpMin = vfli.ichCpMin;
        pedl->dcpDepend = (cpMin == cpMac) ? 0xff : vfli.dcpDepend;
        pedl->fValid = TRUE;
        pedl->fGraphics = vfli.fGraphics;
        pedl->fSplat = vfli.fSplat;

        /* The position of current line equals the position of the previous line
        + height of this line. */
#ifdef SMFONT
        pedl->yp = rcOpaque.bottom = dyp + (ypLine = rcOpaque.top = (dl == 0 ?
          pwwd->ypMin : (pedl - 1)->yp));
#else /* not SMFONT */
        pedl->yp = dyp + (ypLine = (dl == 0 ? pwwd->ypMin :
          (pedl - 1)->yp));
#endif /* SMFONT */

        if (pedl->fIchCpIncr = (vfli.ichCpMac != 0))
            {
            /* Look at final text column */
            ++cpMac;

            /* Since this is true, we can compress pedl->ichCpMac to 1 bit. */
            Assert(vfli.ichCpMac == pedl->ichCpMin + 1);
            }
        }

    if (vfli.doc == docNil)
        {
        /* This is the space beyond the end mark. */
        PatBlt(hDC, 0, ypLine, xpMac, dyp, ropErase);
        goto Finished;
        }

    /* Is there a character in the "style bar"? */
    if (cpMin != cpMac)
        {

#ifdef CASHMERE
        /* This line is not completely empty (not after the end mark); check for
        painting marks on the style bar. */
        if (cpMin == vcpFirstParaCache && vpapAbs.rhc != 0)
            {
            /* This is a running-head. */
            chMark = chStatRH;
            }
        else if ((**hpdocdod)[vfli.doc].hpgtb != 0)
#else /* not CASHMERE */
        if (vpapAbs.rhc == 0 && (**hpdocdod)[vfli.doc].hpgtb != 0)
#endif /* CASHMERE */

            {
            if (vdocPageCache != vfli.doc || cpMac > vcpMacPageCache || cpMac <=
              vcpMinPageCache)
                {
                CachePage(vfli.doc, cpMac - 1);
                }

            /* We are now guaranteed that cpMac is within the cached page. */
            if (cpMin <= vcpMinPageCache && (!vfli.fGraphics || vfli.ichCpMin ==
              0))
                {
                /* This is the first line of new page; show page mark. */
                chMark = chStatPage;
                }
            }
        }

#ifdef SMFONT
#ifdef DDISP
    /* black out this line to test how efficiently/correctly we
       overwrite pixels from previously-resident lines of text */
    PatBlt(hDC, 0, ypLine, xpMac, dyp, BLACKNESS);
    { long int i; for (i=0; i < 500000; i++) ; }
#endif

    /* Calculate dcpMac now, so we might be able to know how much to erase. */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;

    /* Erase any character that might be in the style bar. */
    dxp = xpSelBar + 1;
    if (!vfli.fGraphics)
        {
        dxp = xpMac; // clear the whole line
        }
    PatBlt(hDC, 0, ypLine, dxp, dyp, ropErase);

    /* If this is graphics then go draw any characters in the style bar. */
    if (vfli.fGraphics)
        {
        goto DrawMark;
        }

    /* If there are no "real" characters on this line then we can skip alot of
    this. */
    if (dcpMac == 0)
        {
        goto EndLine2;
        }
#else /* not SMFONT */
    if (vfli.fGraphics || fDontDisplay)
        {
        /* Erase any character that might be in the style bar. */
        PatBlt(hDC, 0, ypLine, xpSelBar, dyp, ropErase);
        goto DrawMark;
        }
#endif /* SMFONT */

    ValidateMemoryDC();
    if (vhMDC == NULL)
        {
Error:
        /* Notify the user that an error has occured and simply erase this line.
        */
        WinFailure();
        PatBlt(hDC, xpSelBar, ypLine, xpMac - xpSelBar, dyp, ropErase);
        goto Finished;
        }

#ifndef SMFONT
    /* Create a new bitmap for the memory DC if the current bitmap is not big
    enough. */
    if (xpMac > dxpbmMDC || dyp > dypbmMDC)
        {
        HBITMAP hbm;

        /* If there is an old bitmap, then delete it. */
        if (dxpbmMDC != 0 || dypbmMDC != 0)
            {
            DeleteObject(SelectObject(vhMDC, hbmNull));
            }

        /* Create the new bitmap and select it in. */
        if ((hbm = CreateBitmap(dxpbmMDC = xpMac, dypbmMDC = dyp, 1, 1,
          (LPSTR)NULL)) == NULL)
            {
            /* There should be a graceful way to recover if the bitmap is ever
            NULL (e.g we don't have enough memory for it). */
            dxpbmMDC = dypbmMDC = 0;
            goto Error;
            }
        SelectObject(vhMDC, hbm);
        }

    /* Erase the are of the bitmap we are going to use. */
    PatBlt(vhMDC, xpSelBar, 0, xpMac, dyp, vfMonochrome ? ropErase : WHITENESS);
#endif /* not SMFONT */

    /* Initialize some of the variables we'll need. */
    pchp = &(**vhgchpFormat)[0];
#ifdef SMFONT
    xp = rcOpaque.left = rcOpaque.right = vfli.xpLeft + xpSelBar - xpMin + 1;
#else /* not SMFONT */
    dcpMac = vfli.fSplat ? vfli.ichMac : vfli.ichReal;
    xp = vfli.xpLeft + xpSelBar - xpMin + 1;
#endif /* SMFONT */
    dxpExtra = fTabsKludge ? 0 : vfli.dxpExtra;

#ifdef SMFONT
    /* If we are horizontally scrolled, then set the clip area to the area
    outside of the selection bar. */
    if (xpMin != 0)
        {
        IntersectClipRect(hDC, xpSelBar, rcOpaque.top, xpMac, rcOpaque.bottom);
        }
#endif /* SMFONT */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
    iRun = 0;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
    iRun = 0;
#endif

    for (dcp = 0; dcp < dcpMac; pchp++)
        {
        /* For all runs do: */
        int ichFirst;   /* First character in the current run */
        int cchRun;     /* Number of characters in the current run */

        dcp = ichFirst = pchp->ichRun;
        dcp += pchp->cchRun;
        if (dcp > dcpMac)
            {
            dcp = dcpMac;
            }
        cchRun = dcp - ichFirst;

        /* Compute dxp = sum of width of characters in current run (formerly
        DxaFromIcpDcp). */
            {
            register int *pdxp;
            register int cchT = cchRun;
            PCH pch = vfli.rgch + ichFirst;

            dxp = cBreakRun = 0;
            pdxp = &vfli.rgdxp[ichFirst];
            while (cchT-- > 0)
                {
                dxp += *pdxp++;
                if (*pch++ == chSpace)
                    ++cBreakRun;
                }

#ifdef DDISP
            CommSzNum("  dxp=",dxp);
#endif
            }

        if (dxp > 0)
            {
            int cchDone;
            PCH pch = &vfli.rgch[ichFirst];
#ifdef JAPAN                  //  added  08 Jul. 1992  by Hiraisi
            int *pdxpT = &vfli.rgdxp[ichFirst];
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
            int *pdxpT = &vfli.rgdxp[ichFirst];
#endif

            LoadFont(vfli.doc, pchp, mdFontScreen);
            yp = (dyp - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
              hpsNegMin ? ypSubSuper : -ypSubSuper) : 0))) -
              vfmiScreen.dypBaseline;

            /* Note: tabs and other special characters are guaranteed to come at
            the start of a run. */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
            if( vpapAbs.jc != jcBoth || fTabsKludge )
                SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);

#elif defined(TAIWAN) || defined(PRC) // Daniel/MSTC, 1993/02/25, for jcBoth
            if( vpapAbs.jc != jcBoth)
                SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);

#else
            SetTextJustification(vhMDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */

#ifdef SMFONT
#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
            if( vpapAbs.jc != jcBoth || fTabsKludge )
                SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
            if( vpapAbs.jc != jcBoth)
                SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#else
            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
#endif /* SMFONT */

            cchDone = 0;
            while (cchDone < cchRun)
                {
                int cch;

                /* Does the wide-space zone begin in this run? */
                if (vfli.fAdjSpace && (vfli.ichFirstWide < ichFirst + cchRun) &&
                  (ichFirst + cchDone <= vfli.ichFirstWide))
                    {
                    int cchDoneT = cchDone;

                    /* Is this the beginning of the wide-space zone? */
                    if (ichFirst + cchDone == vfli.ichFirstWide)
                        {
                        /* Reset the width of the spaces. */

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(vhMDC, ++dxpExtra * cBreakRun,
                                                 cBreakRun);
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(vhMDC, ++dxpExtra * cBreakRun,
                                                 cBreakRun);

#else
                        SetTextJustification(vhMDC, ++dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */

#ifdef SMFONT
#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                 cBreakRun);

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        if( vpapAbs.jc != jcBoth)
                            SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                 cBreakRun);


#else
                        SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
#endif /* SMFONT */

                        cch = cchRun - cchDone;
                        cchDone = cchRun;
                        }
                    else
                        {
                        cchDone = cch = vfli.ichFirstWide - ichFirst;
                        }

                    /* This run is cut short because of a wide space, so we need
                    to calculate a new width. */
                        {
                        register int *pdxp;
                        register int cchT = cch;
                        PCH pch = &vfli.rgch[ichFirst + cchDoneT];

                        dxp = 0;
                        pdxp = &vfli.rgdxp[ichFirst + cchDoneT];
                        while (cchT-- > 0)
                            {
                            dxp += *pdxp++;
                            if (*pch++ == chSpace)
                                ++cBreakRun;
                            }
                        }
                    }
                else
                    {
                    cchDone = cch = cchRun;
                    }

                while (cch > 0)
                    {
                    switch (*pch)
                        {
                        CHAR ch;
                        int dxpT;

                    case chTab:

#ifdef CASHMERE
                        /* chLeader contains tab leader character (see
                        FormatLine) */
                        if ((ch = pchp->chLeader) != chSpace)
                            {
                            int cxpTab;
                            CHAR rgch[32];
                            int dxpLeader = CharWidth(ch);
                            int xpT = xp;
                            int iLevelT = SaveDC(vhMDC);

                            SetBytes(&rgch[0], ch, 32);
                            dxpT = vfli.rgdxp[ichFirst];
                            cxpTab = ((dxpT + dxpLeader - 1) / dxpLeader + 31)
                              >> 5;

                            xp += dxpT;

                            while (cxpTab-- > 0)
                                {
                                TextOut(vhMDC, xpT, yp, (LPSTR)rgch, 32);
                                xpT += dxpLeader << 5;
                                }
                            RestoreDC(vhMDC, iLevelT);
                            }
                        else
#endif /* CASHMERE */

                            {
#ifdef SMFONT
                            /* Expand the opaque rectangle to include the tab.
                            */
                            rcOpaque.right += vfli.rgdxp[ichFirst];
#endif /* SMFONT */
                            xp += vfli.rgdxp[ichFirst];
                            }

                        if (fTabsKludge && ichFirst >= vfli.ichLastTab)
                            {

#ifdef JAPAN                 //  added  19 Jun. 1992  by Hiraisi
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(vhMDC, (dxpExtra =
                                  vfli.dxpExtra) * cBreakRun, cBreakRun);
                            else
                                dxpExtra = vfli.dxpExtra;

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(vhMDC, (dxpExtra =
                                  vfli.dxpExtra) * cBreakRun, cBreakRun);
                            else
                                dxpExtra = vfli.dxpExtra;

#else
                            SetTextJustification(vhMDC, (dxpExtra =
                              vfli.dxpExtra) * cBreakRun, cBreakRun);
#endif /* JAPAN */

#ifdef SMFONT
#ifdef JAPAN                 //  added  19 Jun. 1992  by Hiraisi
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                     cBreakRun);

#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(hDC, dxpExtra * cBreakRun,
                                                     cBreakRun);
#else
                            SetTextJustification(hDC, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
#endif /* SMFONT */

                            fTabsKludge = FALSE;
                            }
                        dxp -= vfli.rgdxp[ichFirst];
                        pch++;
                        cch--;
#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                        iRun++;
                        pdxpT++;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        iRun++;
                        pdxpT++;
#endif
                        goto EndLoop;

#ifdef CASHMERE
                    case schPage:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpPgn(&stBuf[1], vpgn, vsepAbs.nfcPgn,
                          flmSandMode, ichMaxLine);
                        goto DrawSpecial;

                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpFtn(&stBuf[1], cpMin + ichFirst,
                          flmSandMode, ichMaxLine);
DrawSpecial:
#else /* not CASHMERE */
                    case schPage:
                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = *pch == schPage && (wwdCurrentDoc.fEditHeader
                          || wwdCurrentDoc.fEditFooter) ? CchExpPgn(&stBuf[1],
                          vpgn, 0, flmSandMode, ichMaxLine) :
                          CchExpUnknown(&stBuf[1], flmSandMode, ichMaxLine);
#endif /* not CASHMERE */

#ifdef SMFONT
                        /* Calculate the opaque rectangle. */
                        rcOpaque.right += vfli.rgdxp[ichFirst] +
                          vfmiScreen.dxpOverhang;

                        TextOut(hDC, xp, ypLine+yp, &stBuf[1], stBuf[0]);
#else /* not SMFONT */
                        TextOut(vhMDC, xp, yp, (LPSTR)&stBuf[1], stBuf[0]);
#endif /* SMFONT */
                        break;

#ifdef  DBCS
#if !defined(JAPAN) && !defined(KOREA)
/* Write ver3.1j endmark is 1charcter t-yoshio May 26,92*/
            case chMark1:
            if(*(pch+1) == chEMark)
            {   /* This run only contains EndMark */
                        rcOpaque.right += dxp + vfmiScreen.dxpOverhang;
#if defined (TAIWAN) || defined(PRC)  // solve italic font overhang truncation problem, MSTC - pisuih, 2/19/93
            TextOut(hDC, xp, (yp>0?(ypLine+yp):ypLine), (LPSTR)pch, cch );
#else
            ExtTextOut(hDC, xp, (yp>0?(ypLine+yp):ypLine),
                   2, (LPRECT)&rcOpaque,(LPSTR)pch, cch, (LPSTR)NULL);
#endif
            pch += cch;
            cch = 0;
            xp += dxp;
                        rcOpaque.left
                        = (rcOpaque.right = xp) + vfmiScreen.dxpOverhang;
            }
              /* else fall through */
#endif /*JAPAN*/
#endif
                    default:
                        goto EndLoop;
                        }

                    dxp -= vfli.rgdxp[ichFirst];
#ifdef SMFONT
                    /* End the line if no more will fit into the window. */
                    if ((xp += vfli.rgdxp[ichFirst++]) >= xpMac) {
                        goto EndLine;
                    }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
#else /* not SMFONT */
                    xp += vfli.rgdxp[ichFirst++];
#endif /* SMFONT */
                    pch++;
                    cch--;
#ifdef JAPAN                  //  added  09 Jul. 1992  by Hiraisi
                    pdxpT++;
#endif
                    }
EndLoop:

#ifdef SMFONT
                if (cch == 0)
                    {
                    Assert(dxp == 0);
                    }
                else
                    {
                    /* Calculate the opaque rectangle. */
                    rcOpaque.right += dxp + vfmiScreen.dxpOverhang;

#if 0
            {
                char msg[180];
                wsprintf(msg,"putting out %d characters\n\r",cch);
                OutputDebugString(msg);
            }
#endif

#ifdef JAPAN                  //  added  19 Jun. 1992  by Hiraisi
                    if( vpapAbs.jc == jcBoth&&!fTabsKludge ) {
                        CHAR *ptr1, *ptr2;
                        int  len,   cnt;
                        int  iExtra, iSpace, iWid;
                        BOOL bFlag;

                        typeCP RealcpEnd;

                        ptr2 = pch;

                        for( cnt=0 ; cnt < cch ; ) {
                            ptr1 = ptr2;
                            iExtra = dxpExtra;
                            iWid = len = 0;
                            bFlag = TRUE;
                            if( IsDBCSLeadByte(*ptr2) ) {
                                for( ; cnt < cch ; ) {
                                    iWid += *pdxpT;
                                    pdxpT += 2;
                                    cnt += 2;
                                    len += 2;
                                    iRun += 2;
                                    ptr2 += 2;
                                    if( --iNonWideSpaces == 0 ) {
                                        dxpExtra++;
                                        break;
                                    }
                                    if( iRun == dcp - 2 )
                                        break;
                                    if( iRun == dcp ) { /* lastDBC(maybe) */
                                        iExtra = 0;
                                        break;
                                    }
                                    if( !IsDBCSLeadByte(*ptr2) )
                                        break;
                                }
                            }
                            else {
                                if( FKana( (int)*ptr2) ) {
                                    for( ; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        ptr2++;
                                        if( --iNonWideSpaces == 0 ) {
                                            dxpExtra++;
                                            break;
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* last SBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( !FKana( (int)*ptr2) )
                                            break;
                                    }
                                }
                                else {
                                    for( bFlag = FALSE,iSpace = 0; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        if( *ptr2++ == chSpace || !vfWordWrap ) {
                                            iSpace++;
                                            if( --iNonWideSpaces == 0 ) {
                                                dxpExtra++;
                                                break;
                                            }
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* lastSBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( IsDBCSLeadByte(*ptr2 ) ||
                                            FKana((int)*ptr2) )
                                            break;
                                    }
                                }
                            }
                            if( vfWordWrap && !bFlag ) {
                                SetTextCharacterExtra( hDC, 0 );
                                SetTextJustification( hDC,
                                                      iExtra*iSpace,iSpace);
                            }
                            else {
                                SetTextJustification(hDC,0,0);
                                SetTextCharacterExtra(hDC,iExtra);
                            }
                        /*-TextOut-*/
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                             /*Undetermine*/
                             if( (selUncpFirst != selUncpLim) &&
                                 *ptr1 != chEMark) {
                                 RealcpEnd = RealcpFirst + len;
                                 UndetermineString(hDC, xp, ypLine+yp, ptr1,
                                  len, RealcpFirst, RealcpEnd);
                             } else
                                 TextOut(hDC,xp,ypLine+yp,ptr1,len);
#else
                             TextOut(hDC,xp,ypLine+yp,ptr1,len);
#endif
                             RealcpFirst+=len;
                             xp+=iWid;
                         }
                    }
                    else{
                        iRun += cch;
                        SetTextCharacterExtra( hDC, 0 );
                        /*Undetermine*/
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
                        if((selUncpFirst != selUncpLim) && *pch != chEMark)
                           UndetermineString( hDC, xp, ypLine+yp,
                           pch, cch, RealcpFirst, RealcpFirst+cch );
                        else
                        /* Output cch characters starting at pch */
                            TextOut(hDC, xp, ypLine+yp, pch, cch);
#else
                        /* Output cch characters starting at pch */
                        TextOut(hDC, xp, ypLine+yp, pch, cch);
#endif
                        /* End the line if no more will fit into the window. */
                        xp += dxp;
                        RealcpFirst+=cch;
                    }
                    if (xp >= xpMac)


#elif defined(TAIWAN)  || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                    if( vpapAbs.jc == jcBoth) { //&& !fTabsKludge ) {
                        CHAR *ptr1, *ptr2;
                        int  len,   cnt;
                        int  iExtra, iSpace, iWid;
                        BOOL bFlag;

                        typeCP RealcpEnd;

                        ptr2 = pch;

                        for( cnt=0 ; cnt < cch ; ) {
                            ptr1 = ptr2;
                            iExtra = dxpExtra;
                            iWid = len = 0;
                            bFlag = TRUE;
                            if( IsDBCSLeadByte(*ptr2) ) {
                                for( ; cnt < cch ; ) {
                                    iWid += *pdxpT;
                                    pdxpT += 2;
                                    cnt += 2;
                                    len += 2;
                                    iRun += 2;
                                    ptr2 += 2;
                                    if( --iNonWideSpaces == 0 ) {
                                        dxpExtra++;
                                        break;
                                    }
                                    if( iRun == dcp - 2 )
                                        break;
                                    if( iRun == dcp ) { /* lastDBC(maybe) */
                                        iExtra = 0;
                                        break;
                                    }
                                    if( !IsDBCSLeadByte(*ptr2) )
                                        break;
                                }
                            }
                            else {
                                if( FKana( (int)*ptr2) ) {
                                    for( ; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        ptr2++;
                                        if( --iNonWideSpaces == 0 ) {
                                            dxpExtra++;
                                            break;
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* last SBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( !FKana( (int)*ptr2) )
                                            break;
                                    }
                                }
                                else {
                                    for( bFlag = FALSE,iSpace = 0; cnt < cch ; ) {
                                        iWid += *pdxpT++;
                                        cnt++;
                                        len++;
                                        iRun++;
                                        if( *ptr2++ == chSpace || !vfWordWrap ) {
                                            iSpace++;
                                            if( --iNonWideSpaces == 0 ) {
                                                dxpExtra++;
                                                break;
                                            }
                                        }
                                        if( iRun == dcp - 1 )
                                            break;
                                        if( iRun == dcp ) { /* lastSBC(maybe) */
                                            iExtra = 0;
                                            break;
                                        }
                                        if( IsDBCSLeadByte(*ptr2 ) ||
                                            FKana((int)*ptr2) )
                                            break;
                                    }
                                }
                            }
                            if( vfWordWrap && !bFlag ) {
                                SetTextCharacterExtra( hDC, 0 );
                                SetTextJustification( hDC,
                                                      iExtra*iSpace,iSpace);
                            }
                            else {
                                SetTextJustification(hDC,0,0);
                                SetTextCharacterExtra(hDC,iExtra);
                            }
                        /*-TextOut-*/
//#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//                             /*Undetermine*/
//                             if( (selUncpFirst != selUncpLim) &&
//                                 *ptr1 != chEMark) {
//                                 RealcpEnd = RealcpFirst + len;
//                                 UndetermineString(hDC, xp, ypLine+yp, ptr1,
//                                  len, RealcpFirst, RealcpEnd);
//                             } else
//                                 TextOut(hDC,xp,ypLine+yp,ptr1,len);
//#else
                             TextOut(hDC,xp,ypLine+yp,ptr1,len);
//#endif
                             RealcpFirst+=len;
                             xp+=iWid;
                         }
                    }
                    else{
                        iRun += cch;
                        SetTextCharacterExtra( hDC, 0 );
                        /*Undetermine*/
//#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//                        if((selUncpFirst != selUncpLim) && *pch != chEMark)
//                           UndetermineString( hDC, xp, ypLine+yp,
//                           pch, cch, RealcpFirst, RealcpFirst+cch );
//                        else
//                        /* Output cch characters starting at pch */
//                            TextOut(hDC, xp, ypLine+yp, pch, cch);
//#else
                        /* Output cch characters starting at pch */
                        TextOut(hDC, xp, ypLine+yp, pch, cch);
//#endif
                        /* End the line if no more will fit into the window. */
                        xp += dxp;
                        RealcpFirst+=cch;
                    }
                    if (xp >= xpMac)

#else
                    /* Output cch characters starting at pch */
#if defined(KOREA)
            if ((cch == 1) && (pch[0] == chEMark))
            {
                int iPrevBkMode;
                iPrevBkMode = SetBkMode(hDC, OPAQUE);
                TextOut(hDC, xp, ypLine+yp, pch, cch);
                SetBkMode(hDC, iPrevBkMode);
            }
            else
                TextOut(hDC, xp, ypLine+yp, pch, cch);
#else
                    TextOut(hDC, xp, ypLine+yp, pch, cch);
#endif
                    /* End the line if no more will fit into the window. */
                    if ((xp += dxp) >= xpMac)
#endif    // JAPAN

                        {
                        goto EndLine;
                        }
                    rcOpaque.left = (rcOpaque.right = xp) +
                      vfmiScreen.dxpOverhang;
                    pch += cch;
                    }
#else /* not SMFONT */
                /* Output cch characters starting at pch */
                TextOut(vhMDC, xp, yp, (LPSTR)pch, cch);
                xp += dxp;
                pch += cch;
#endif /* SMFONT */
                } /* end while (cchDone<cchRun) */
            } /* end if (dxp>0) */
        } /* end for dcp=0..dcpMac */

#ifdef SMFONT
EndLine:
    /* Restore the clip region if need be. */
    if (xpMin != 0)
        {
        SelectClipRgn(hDC, NULL);
        }
EndLine2:
#endif /* SMFONT */

#ifdef CASHMERE
    if (vfVisiMode)
        {
        AddVisiSpaces(ww, &(**pwwd->hdndl)[dl], vfli.dypBase, vfli.dypAfter +
          vfli.dypFont);
        }
#endif /* CASHMERE */

    vfTextBltValid = FALSE;

    if ((ww == wwCur) && (pwwd->doc != docScrap) && !vfSelHidden &&
      (selCur.cpLim >= cpMin))
        {
        if (selCur.cpFirst <= cpMac)
            {
            /* Show selection */
            int xpFirst;
            int xpLim;

#ifdef ENABLE
            if (vfli.fSplatNext && selCur.cpFirst == selCur.cpLim &&
                selCur.cpFirst == cpMac)
                {
                vfInsEnd = TRUE;
                ClearInsertLine();
                }
            vfInsertOn = FALSE;
#endif /* ENABLE */

            if (selCur.cpFirst <= cpMin && selCur.cpLim >= cpMac)
                {
                xpFirst = vfli.xpLeft;
                xpLim = vfli.xpReal;
                }
            else if (selCur.cpFirst < cpMac || (selCur.cpLim == cpMac &&
              vfInsEnd))
                {
                typeCP cpBegin = CpMax(cpMin, selCur.cpFirst);
                typeCP cpEnd = CpMin(cpMac, selCur.cpLim);

                dxp = DxpDiff((int)(cpBegin - cpMin), (int)(cpEnd - cpBegin),
                  &xpFirst);
                xpLim = min(xpMin + vfli.xpReal, xpFirst + dxp);
                }
            else
                {
                goto DidntHighlight;
                }

            xpSel = xpSelBar + max(xpFirst - xpMin, 0);
            if (xpLim > xpFirst)
                {
                /* Set highlighting at desired screen position. */
                dxpSel = max(xpLim - max(xpFirst, xpMin), 0);
                }
            else if (selCur.cpFirst == selCur.cpLim && ((selCur.cpLim != cpMac)
              ^ vfInsEnd))
                {
                vfInsertOn = FALSE; /* Because we redisplayed insert pt line */

#ifdef CASHMERE
                vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
                vypCursLine = ypLine + dyp - vfli.dypAfter;
#else /* not CASHMERE */

#ifdef  DBCS    // Some double byte fonts have bigger character
                // face than the line hight.
                vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
#else
                vdypCursLine = vfli.dypFont;
#endif

                vypCursLine = ypLine + dyp;
#endif /* not CASHMERE */

                vxpCursLine = xpSel;

                /* Start blinking in a while */
                vfSkipNextBlink = TRUE;

                fInsertOn = xpFirst >= xpMin;
                }

DidntHighlight:;
            }
        }

#ifdef SMFONT
    /* Invert the selection */
    if (dxpSel != 0) {
        PatBlt(hDC, xpSel, ypLine, dxpSel, dyp, DSTINVERT);
    }
#else /* not SMFONT */
    /* Blt the line of text onto the screen. */
    PatBlt(vhMDC, 0, 0, xpSelBar, dyp, vfMonochrome ? ropErase : WHITENESS);
    if (dxpSel == 0)
        {
        BitBlt(hDC, 0, ypLine, xpMac, dyp, vhMDC, 0, 0, SRCCOPY);
        }
    else
        {
        BitBlt(hDC, 0, ypLine, xpSel, dyp, vhMDC, 0, 0, SRCCOPY);
        BitBlt(hDC, xpSel, ypLine, dxpSel, dyp, vhMDC, xpSel, 0, NOTSRCCOPY);
        xpSel += dxpSel;
        BitBlt(hDC, xpSel, ypLine, xpMac - xpSel, dyp, vhMDC, xpSel, 0,
          SRCCOPY);
        }
#endif /* SMFONT */

    /* Draw the insertion bar if necessary. */
    if (fInsertOn)
        {
        DrawInsertLine();
        }
#if defined(JAPAN) & defined(DBCS_IME)    // Set a flag for IME management.
    else
    {
        bClearCall = TRUE;
    }
#endif

DrawMark:
    /* Draw the character in the style bar if necessary. */
    if (chMark != '\0')
        {
#ifdef SYSENDMARK

#ifdef  DBCS    // prepare buf for double-byte end mark.
        CHAR               rgch[cchKanji];
#endif

        struct CHP         chpT;
        extern struct CHP  vchpNormal;

        blt(&vchpNormal, &chpT, cwCHP);
        chpT.ftc     = ftcSystem;
        chpT.ftcXtra = 0;
        chpT.hps     = hpsDefault;

        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, &chpT, mdFontScreen);

#ifdef  DBCS    // we use double byte end mark.
#if defined(JAPAN) || defined(KOREA)  /*t-yoshio May 26,92*/
#if defined(KOREA)
            {
                int iPrevBkMode;
                iPrevBkMode = SetBkMode(hDC, OPAQUE);
                TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
                        (LPSTR)&chMark, 1);
                SetBkMode(hDC, iPrevBkMode);
            }
#else
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
                (LPSTR)&chMark, 1);
#endif
#else
        rgch[0] = chMark1;
        rgch[1] = chMark;

    rcOpaque.left = 0;
    rcOpaque.right = DxpFromCh(chMark1,FALSE);
    rcOpaque.top = ypLine;
    rcOpaque.bottom = ypLine+dyp;

    /* When this line string is lower than system font,it remains dust,
        so we must clip this mark. */
    ExtTextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
            ETO_CLIPPED, (LPRECT)&rcOpaque,(LPSTR)rgch, cchKanji, (LPSTR)NULL);
#endif /*JAPAN*/
#else

        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
                (LPSTR)&chMark, 1);
#endif  /* DBCS */

#else /* ifdef SYSENDMARK */

/*T-HIROYN sync 3.0 disp.c */
#if 0
        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, NULL, mdFontScreen);
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
          (LPSTR)&chMark, 1);
#endif
#if defined(JAPAN) || defined(KOREA)     /* KenjiK '90-10-26 */
        /* Draw the style character in the standard font. */
        {
        CHAR    rgch[cchKanji];

            LoadFont(vfli.doc, NULL, mdFontScreen);
            rgch[0] = chMark1;
            rgch[1] = chMark;
#if defined(KOREA)
            {
                int iPrevBkMode;
                iPrevBkMode = SetBkMode(hDC, OPAQUE);
        ExtTextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,ETO_CLIPPED, (LPRECT)&rcOpaque,(LPSTR)rgch, cchKanji, (LPSTR)NULL);
                SetBkMode(hDC, iPrevBkMode);
            }
#else
        ExtTextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,ETO_CLIPPED, (LPRECT)&rcOpaque,(LPSTR)rgch, cchKanji, (LPSTR)NULL);
#endif
    }
#else   /* JAPAN */
        /* Draw the style character in the standard font. */
        LoadFont(vfli.doc, NULL, mdFontScreen);
        TextOut(hDC, 0, ypLine + dyp - vfli.dypBase - vfmiScreen.dypBaseline,
          (LPSTR)&chMark, 1);
#endif  /* JAPAN */

#endif /* if-else-def SYSENDMARK */
        }

    if (vfli.fGraphics)
        {
        DisplayGraphics(ww, dl, fDontDisplay);
        }

Finished:
    Scribble(5,' ');
    }


/* D X P  D I F F */
DxpDiff(dcpFirst, dcp, pdxpFirst)
int dcpFirst;
int dcp;
int *pdxpFirst;
{
#if 1
    register int *pdxp = &vfli.rgdxp[0];
    register int cch;
    int dxp = vfli.xpLeft;
#ifdef ENABLE   /* Not used */
    int ichLim = dcpFirst + dcp;
#endif

    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        //Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    for (cch = 0; cch < dcpFirst; ++cch)
        {
        dxp += *pdxp++;
        }
    *pdxpFirst = dxp;
    dxp = 0;
    for (cch = 0; cch < dcp; ++cch)
        {
        dxp += *pdxp++;
        }
    return dxp;
#else

    int dxp;
    if (dcp > vfli.ichMac - dcpFirst)
        {   /* This should not be, but is when we have a CR */
        Assert( dcpFirst < vfli.ichMac );
        dcp = vfli.ichMac - dcpFirst;
        }

    /* first get space up to first character */
    *pdxpFirst = LOWORD(GetTextExtent(hDC,vfli.rgch,dcpFirst)) + vfli.xpLeft;

    /* now get space between first and first+dcp */
    dxp = LOWORD(GetTextExtent(hDC,vfli.rgch+dcpFirst,dcp));
    return dxp;
#endif
}


UpdateDisplay(fAbortOK)
int fAbortOK;
{
    int ww;

    if (wwMac <= 0)
        {
        return;
        }

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ww++)
        if ( rgwwd[ww].doc != docScrap )
            {
            UpdateWw(ww, fAbortOK);
            if (rgwwd[ww].fDirty || vfOutOfMemory)
                {
                return; /* update has been interrupted */
                }
            }
#else /* not CASHMERE */
    UpdateWw(wwDocument, fAbortOK);
    if (wwdCurrentDoc.fDirty || vfOutOfMemory)
        {
        /* Update has been interrupted */
        return;
        }
#endif /* not CASHMERE */

    if (wwdCurrentDoc.fRuler)
        {
        UpdateRuler();
        }
}


/* U P D A T E  W W */
UpdateWw(ww, fAbortOK)
int ww, fAbortOK;
{ /* Redisplay ww as necessary */
    extern int vfWholePictInvalid;
    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlOld, dlNew;
    int doc;
    int ichCp;
    struct EDL *pedlNew;
    register struct EDL *pedl;
    struct EDL (**hdndl)[]=pwwd->hdndl;
    int dypDiff;
    int ypTop;
    int ypFirstInval;
    int dr;
    int fLastNotShown;
    typeCP cp, cpMacWw;

    if (!pwwd->fDirty)
        {
        return;
        }

    if (!((**hpdocdod)[pwwd->doc].fDisplayable))
        return;

    if (fAbortOK && FImportantMsgPresent())
        return;

#if 0  // how to get first and last cp's in invalid rect?
#if defined(OLE)
    /*
        Load visible objects.  Do it now rather than in DisplayGraphics()
        because here it has less chance of disrupting the state variables
        upon which UpdateWw depends.
    */
    ObjEnumInRange(docCur,cpMinCur,cpMacCur,ObjLoadObjectInDoc);
#endif
#endif

    dlMac = pwwd->dlMac;
    ypTop = pwwd->ypMin;

    Assert( ww >= 0 && ww < wwMax );
    vfli.doc = docNil;  /* An aid to Fast Insert */

    UpdateInvalid();    /* InvalBand for what Windows considers to be invalid */
    ypFirstInval = pwwd->ypFirstInval;

#ifndef CASHMERE
    Assert( ww == wwCur );  /* A MEMO-only assumption */
#endif /* CASHMERE */

    Scribble(5, 'U');

    ValidateMemoryDC();      /* to do any update, we need a good memory DC */
    if (vhMDC == NULL)
        {
        WinFailure();
        return;
        }

    doc = pwwd->doc;
    vfli.doc = docNil;

    if (pwwd->fCpBad)
        {
/* cp first displayed has not been blessed */

#ifdef CASHMERE     /* Must do this if ww != wwCur assertion is FALSE */
        int wwT = wwCur;
        if (ww != wwCur && wwCur >= 0)
/* CtrBackTrs cache is only good for wwCur. Treat != case */
            {
            if (pwwdCur->fDirty) /* Do wwCur first, saving cache */
                UpdateWw(wwCur, fAbortOK);

            if (fAbortOK && FImportantMsgPresent())
                return;

            ChangeWw(ww, false);
            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            ChangeWw(wwT, false);
            }
        else
#endif /* CASHMERE */

            {
            if (fAbortOK && FImportantMsgPresent())
                return;

            CtrBackDypCtr( 0, 0 );  /* Validate pwwdCur->cpFirst */
            }
        }

/* check for cpMin accessible in this ww */
RestartUpdate:
    vfWholePictInvalid = fTrue; /* Tells DisplayGraphics to
                                   abandon accumulated partial pict rect */
    fLastNotShown = fFalse;
    cp = CpMax(pwwd->cpMin, pwwd->cpFirst);
    cpMacWw = pwwd->cpMac;
    ichCp = pwwd->ichCpFirst;

        /* Note test for dlNew==0 that guarantees that there will be at least
           one dl -- this was added for WRITE because we do not have
           the ability to enforce a minimum window size */

    for (dlNew = dlOld = 0; ypTop < pwwd->ypMac || (dlNew == 0) ; dlNew++)
        /* we have: cp, ichCP: pints to text desired on the coming line dlNew
         ypTop: desired position for top of dlNew -1
         dlOld: next line to be considered for re-use
        */
        /* check for having to extend dndl array */
        {
        if (dlNew >= (int)pwwd->dlMax)
            {
/* extend the array with uninitialized dl's, increment max, break if no space.
We assume that dlMac(Old) was <= dlMax, so the dl's will not be looked at
but used only to store new lines */
#define ddlIncr 5

            if (!FChngSizeH(hdndl, (pwwd->dlMax + ddlIncr) * cwEDL, fFalse))
                break;
            pwwd->dlMax += ddlIncr;
            }
/* discard unusable dl's */
        for (; dlOld < dlMac; dlOld++)
            { /* Set dlOld and pedl to the next good dl */
            int ypTopOld, ypOld;

                /* Re-entrant Heap Movement */
            if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
                goto RetInval;

            pedl = &(**hdndl)[dlOld];
            ypOld = pedl->yp;

/* loop if: invalid, passed over in cp space, passed over in dl space,
passed over in yp space,
in invalid band, passed over in ich space */
            if (!pedl->fValid || dlOld < dlNew || pedl->cpMin < cp
                || (ypTopOld = (ypOld - pedl->dyp)) < ypTop
                || (ypOld >= ypFirstInval && ypTopOld <= pwwd->ypLastInval)
                || (pedl->cpMin == cp && pedl->ichCpMin < ichCp))
                continue;
/* now we have dlOld, an acceptable if not necessarily useful dl.
now compute dlNew either from scratch or by re-using dlOld. To be
re-useable, dlOld must have right cp/ichCp pair, plus be totally on screen
or, if it is a partial line, it must stay still or move down - not up */
            if (pedl->cpMin == cp && pedl->ichCpMin == ichCp &&
                (ypOld <= pwwd->ypMac || ypTopOld <= ypTop))
                {
/* Re-use this dl */
                int yp = ypTop;
                if (fLastNotShown)
                    {
                        /* HEAP MOVEMENT */
                    DisplayFli(ww, dlNew - 1, fLastNotShown = fFalse);
                    pedl = &(**hdndl)[dlOld];
                    }

                cp = pedl->cpMin + pedl->dcpMac;
                ichCp = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                ypTop += pedl->dyp;
                if (dlOld != dlNew || ypTopOld != yp)
                    {
                    DypScroll(ww, dlOld, dlNew - dlOld, yp);
                    if (vfScrollInval)
                        {
                        /* There was a popup; invalid region might have changed */
                        /* fLastNotShown test is for interrupting picture display */
                        /* before we've really displayed it */

                        (**hdndl) [dlOld].fValid = fFalse;
                        goto Restart1;
                        }
                    dlMac += dlNew - dlOld;
                    }
                dlOld = dlNew + 1;
                goto NextDlNew;
                }
            break;
            }
/* cpMin > cp, the line is not anywhere so it will have to be formatted
from scratch */

        if (fAbortOK && !fLastNotShown && FImportantMsgPresent())
            goto RetInval;

        FormatLine(doc, cp, ichCp, cpMacWw, flmSandMode);  /* Creates vfli */

    if (vfOutOfMemory)
            goto RetInval;

        ichCp = vfli.ichCpMac;
        cp = vfli.cpMac;
/* advance invalid band so that update can resume after an interruption */
        pwwd->ypFirstInval = (ypTop += vfli.dypLine);
        pedl = &(**hdndl)[dlOld];
        if (dlOld < dlMac && pedl->cpMin == cp && pedl->ichCpMin == ichCp)
            {
            int dlT = dlOld;

/* line at dlOld is a valid, existing line that will abutt the line just about
to be displayed. */
            if (dlOld == dlNew && pedl->yp - pedl->dyp <= ypTop)
/* the line about to be overwritten will be re-used in the next loop.
Hence, it is worthwhile to save this line and its dl */
                DypScroll(ww, dlOld++, 1, ypTop);
            else
/* Move the next line to its abutting position. We know that it has not yet been
overwritten (yp, dlOld all > than ypTop, dlNew) */
                DypScroll(ww, dlOld, 0, ypTop);

            if (vfScrollInval)
                {
                /* There was a popup; invalid region might have changed */
                /* fLastNotShown test is for interrupting picture display */
                /* before we've really displayed it */

                (**hdndl) [dlT].fValid = fFalse;
Restart1:
                if (fLastNotShown)
                    {
                    pwwd->ypFirstInval = pwwd->ypMin;
                    }

                ypFirstInval = pwwd->ypFirstInval;
                ypTop = pwwd->ypMin;
                goto RestartUpdate;
                }
            }

/* true in 3rd param means put off picture redisplay till later */
/* condition: graphics & not last in picture & not last in y space and
not in front of a invalid or valid transition in the picture */
        DisplayFli(ww, dlNew, fLastNotShown =
                  (vfli.fGraphics && vfli.ichCpMac!=0 && ypTop < pwwd->ypMac));
NextDlNew:;
        }
Break1:
    pwwd->dlMac = dlNew;

#ifdef CASHMERE
/* condition is here to avoid swapping */
    if (pwwd->fSplit && rgwwd[pwwd->ww].fFtn)
        CalcFtnLimits(pwwd);
#endif /* CASHMERE */

    SetCurWwVScrollPos();    /* Set Scroll bar position */
    vfTextBltValid = false;

/* reset invalid indications */
    pwwd->fDirty = false;
    pwwd->ypFirstInval = ypMaxAll;
    pwwd->ypLastInval = 0; /* so that max in InvalBand will work */
    Scribble(5, ' ');
    goto Validate;

/* Before returning from an interrupt, invalidate lines that were overwritten
within the present update. */
RetInval:
    Scribble(5, ' ');
    for (; dlOld < dlMac; dlOld++)
        {
        pedl = &(**hdndl)[dlOld];
        if ((pedl->yp - pedl->dyp) < ypTop)
            pedl->fValid = fFalse;
        else
            break;
        }
Validate: ;

#ifdef ENABLE   /* We will let UpdateInvalid handle this in case
                   further invalidation occurred during the update */

    {           /* Tell Windows that the part we updated is valid */
    RECT rc;

    rc.left = 0;
    rc.top = pwwd->ypMin;
    rc.right = pwwd->xpMac;
    rc.bottom = imin( pwwd->ypMac, ypTop );
    ValidateRect( pwwd->wwptr, (LPRECT)&rc );
    }
#endif
}




/* D Y P  S C R O L L */
DypScroll(ww, dlFirst, ddl, ypTo)
int ww, dlFirst, ddl, ypTo;
{
/* Scroll dl's in a window, from dlFirst to end, down ddl lines (or up -ddl).
Bitmap is moved from top of dlFirst to ypTo.   The yp's of the dl's are updated.
Returns the amount scrolled. (positive means down). */

    register struct WWD *pwwd = &rgwwd[ww];
    int dlMac;
    int dlT;
    int ypFrom;
    int dypChange;
    int cdlBelow;
    struct EDL *pedl;
    struct EDL *pedlT;

    /* Do not call procedures while dndl is loaded up to avoid heap movement */
    struct EDL *dndl = &(**(pwwd->hdndl))[0];

    Assert( ww >= 0 && ww < wwMax );

    vfScrollInval = fFalse;

    /* Number of dl's below (and including) the first one to be scrolled */
    cdlBelow = pwwd->dlMac - dlFirst;
    pwwd->dlMac = min(pwwd->dlMac + ddl, pwwd->dlMax);
    cdlBelow = max(0, min(cdlBelow, pwwd->dlMac - ddl - dlFirst));

    pedlT = &dndl[dlFirst];
    ypFrom = pedlT->yp - pedlT->dyp;

    /* Length of area to be moved */
    dypChange = ypTo - ypFrom;

    if (cdlBelow > 0)
        {
        int dlTo = dlFirst + ddl;
        int ypMac = pwwd->ypMac;

        pedlT = &dndl[dlTo];
        if (ddl != 0)
            {
            blt(&dndl[dlFirst], pedlT, cwEDL * cdlBelow);
            }

        for (dlT = dlTo; dlT < pwwd->dlMac; ++dlT, ++pedlT)
            {
            if (dypChange < 0 && pedlT->yp > ypMac)
                {
                /* Invalidate dl's that are pulled in from the ozone below ypMac
                */
                pedlT->fValid = fFalse;
                }
            else
                {
                pedlT->yp += dypChange;
                }
            }
        }

    if (dypChange != 0)
        {
        RECT rc;

        SetRect( (LPRECT)&rc, 0, min(ypFrom, ypTo),
                              pwwd->xpMac, pwwd->ypMac );
        Assert( ww == wwCur );      /* A MEMO-only assumption */
        ScrollCurWw( &rc, 0, dypChange );
        }

    return dypChange;
}




FImportantMsgPresent()
{
/* If the next message is important enough to interrupt a screen update, we
   return TRUE; if it can wait, we return FALSE */

    BOOL fToggledKey;
    extern MSG vmsgLast;

#ifdef DEBUG
    unsigned wHeapVal = *(pLocalHeap + 1);

    Assert( wHeapVal == 0 );   /* Heap should not be frozen */
#endif

#ifdef DBCS
 if( donteat )
     return TRUE;
#endif

while (PeekMessage((LPMSG) &vmsgLast, NULL, NULL, NULL, PM_NOREMOVE))
    {
#if defined(JAPAN) & defined(DBCS_IME)
/*  If IME Cnv window open,we have to avoid ourselves to get into AlphaMode.
** So we do getmessage here to fill vmsgLast with app queue message.
*/
    extern BOOL bImeCnvOpen;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    if( bImeCnvOpen || vfImeHidden) {
#else
    if( bImeCnvOpen ) {
#endif  //JAPAN & IME_HIDDEN
        GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
        donteat = TRUE;
        return  TRUE;
    }
#endif

/*T-HIROYN sync 3.1 disp.c */
#if 0
    /* Filter uninteresting or easily handled events */
    if (fToggledKey = FCheckToggleKeyMessage(&vmsgLast) ||
       (vmsgLast.message == WM_KEYUP && vmsgLast.hwnd == wwdCurrentDoc.wwptr))
        {

    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
            return TRUE;
#endif

#ifdef JAPAN  // 03/22/93
#ifdef PENWIN // 03/22/93
    if (((vmsgLast.message == WM_KEYDOWN) || (vmsgLast.message == WM_KEYUP)
        || (vmsgLast.message == WM_SYSKEYDOWN) || (vmsgLast.message == WM_SYSKEYUP))
        && ((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
#else //PENWIN
    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
#endif
#elif defined(KOREA)
#define VK_PROCESSKEY 0xE5 // New finalize message. bklee.
// bug #3191, In HWin3.1, WM_NCLBUTTONDOWN message is reached this if statement. 
// Because HTBOTTOMDOWN's value is same with VK_CONTROL's, we can't resize write window
    if (((vmsgLast.message == WM_KEYDOWN) || (vmsgLast.message == WM_KEYUP)
        || (vmsgLast.message == WM_SYSKEYDOWN) || (vmsgLast.message == WM_SYSKEYUP))
        && ((vmsgLast.wParam == VK_MENU) ||
            (vmsgLast.wParam == VK_CONTROL) ||
            (vmsgLast.wParam == VK_PROCESSKEY) ))
#else //JAPAN
    if (((vmsgLast.wParam == VK_MENU) || (vmsgLast.wParam == VK_CONTROL)))
#endif
    {
        if (vmsgLast.wParam == VK_CONTROL)
        {
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            SetShiftFlags();
        }
        return TRUE;
    }
    /* Filter uninteresting or easily handled events */
    else if (fToggledKey = FCheckToggleKeyMessage(&vmsgLast) ||
       (vmsgLast.message == WM_KEYUP && vmsgLast.hwnd == wwdCurrentDoc.wwptr))
        {

        /* This is so the Windows keyboard interface mechanism will see toggle
        key and key-up transitions */
        GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
#ifdef WIN30
        /* PeekMessage has been changed in Win 3.0 so that GetKeyState()
           called from FCheckToggleKeyMessage() is really only valid if
           you've done a PeekMessage(...,PM_REMOVE) or GetMessage() first.
           That is, while the FCheckToggleKeyMessage() call might succeed
           above, it will NOT have set the vfShiftKey/vfCommandKey flags
           correctly -- so we do it here ..pault */
        if (fToggledKey)
            FCheckToggleKeyMessage(&vmsgLast);
#endif
        if (vmsgLast.hwnd != wwdCurrentDoc.wwptr)
            {
            /* Just in case a modeless dialog's window proc cares */
            TranslateMessage((LPMSG)&vmsgLast);
            DispatchMessage((LPMSG)&vmsgLast);
            }
#ifdef DBCS /* I hate it */
    if (vmsgLast.message == WM_CHAR
#ifdef  JAPAN
        //  We've been reported by one of OEM about LED not disapearing
        // problem.
        //  they know it is bug of write. So I added this code from win2.x
        // write source.    27 sep 91 Yutakan
       ||  (vmsgLast.message == WM_KEYUP && vmsgLast.wParam == VK_KANA)
#endif
#ifdef  KOREA
       || vmsgLast.message == WM_INTERIM
#endif
       || vmsgLast.message == WM_KEYDOWN) {

            donteat = TRUE;
            return( TRUE );
        } /* else Ok, you are KEYUP message. do normal */
#endif
        }
    else
        {
        switch (vmsgLast.message)
            {
        case WM_MOUSEMOVE:
#ifdef  KOREA
    case WM_NCMOUSEMOVE:
#endif
            /* Process mouse move messages immediately; they are not really
            important.  NOTE: This assumes that we have not captured all mouse
            events; in which case, they are important. */
            DispatchMessage((LPMSG)&vmsgLast);

        case WM_TIMER:
        case WM_SYSTIMER:
            /* Remove timer and mouse move messages from the queue. */
            GetMessage((LPMSG) &vmsgLast, NULL, NULL, NULL);
            break;

        default:
            Assert( *(pLocalHeap+1) == 0 ); /* Heap should still not be frozen */
            return (TRUE);
            }
        }
    }


Assert( *(pLocalHeap + 1) == 0 );   /* Heap should still not be frozen */
return (FALSE);
}


/* C P  B E G I N  L I N E */
typeCP CpBeginLine(pdl, cp)
int *pdl;
typeCP cp;
    { /* return the cp and dl containing cp */
    int dlMin, dlLim;
    typeCP cpGuess;
    struct EDL *dndl;

    do
        {
        UpdateWw(wwCur, false);
        PutCpInWwVert(cp); /* Ensure cp on screen */
        } while (pwwdCur->fDirty && !vfOutOfMemory);

    dndl = &(**(pwwdCur->hdndl))[0];
    dlMin = 0;
    dlLim = pwwdCur->dlMac;
    while (dlMin + 1 < dlLim)
        { /* Binary search the ww */
        int dlGuess = (dlMin + dlLim) >> 1;
        struct EDL *pedl = &dndl[dlGuess];
        if ((cpGuess = pedl->cpMin) <= cp && (cpGuess != cp || pedl->ichCpMin == 0))
            { /* guess is low or right */
            dlMin = dlGuess;
            if (cp == cpGuess && pedl->cpMin + pedl->dcpMac != cp)
                break;  /* Got it right */
            }
        else  /* Guess is high */
            dlLim = dlGuess;
        }
    *pdl = dlMin;
    return dndl[dlMin].cpMin;
}




/* T O G G L E  S E L */
ToggleSel(cpFirst, cpLim, fOn)
typeCP cpFirst, cpLim; /* selection bounds */
int fOn;
{ /* Flip selection highlighting on and off */
    extern int vfPMS;
    struct EDL *pedl;
    int dlT;
    int xpMin;
    int dxpRoom;
    int xpFirst;
    int xpLim;
    int fInsertPoint = (cpFirst == cpLim);

    if (vfSelHidden || cpFirst > cpLim || cpLim < /*cp0*/ cpMinCur || vfDead)
        return;

    if ( vfPictSel && vfPMS &&
         (CachePara( docCur, cpFirst ), vpapAbs.fGraphics) &&
         (vcpLimParaCache == cpLim) )
        {   /* Don't show inversion if we're moving or sizing a picture */
        return;
        }

    dxpRoom = pwwdCur->xpMac - xpSelBar;
    xpMin = pwwdCur->xpMin;


    for (dlT = 0; dlT < pwwdCur->dlMac; dlT++)
        {
        typeCP cpMin, cpMac; /* line bounds */
        pedl = &(**(pwwdCur->hdndl))[dlT];
        if (!pedl->fValid)
            continue;
        cpMin = pedl->cpMin;
        if (cpMin > cpLim || cpMin > cpMacCur || (cpMin == cpLim && cpLim != cpFirst))
            break;
        cpMac = cpMin + pedl->dcpMac;
        if (cpFirst <= cpMin && cpLim >= cpMac)
            {
/* entire line is highlighted */
            xpFirst = pedl->xpLeft;
            if (pedl->fGraphics && cpLim == cpMac && cpMin == cpMac)
                /* Special kludge for graphics paras */
                xpLim = xpFirst;
            else
                xpLim = pedl->xpMac;
            }
        else if (fInsertPoint && cpFirst == cpMac && vfInsEnd)
            { /* Special kludge for an insert point at the end of a line */
            xpLim = xpFirst = pedl->xpMac;
            }
        else if (cpFirst < cpMac)
            {
            /* Bite the bullet */
            int dxp;
            typeCP  cpBegin = CpMax(cpMin, cpFirst);
            typeCP  cpEnd = CpMin(cpMac, cpLim);

            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            dxp = DxpDiff((int) (cpBegin - cpMin),
                (int) (cpEnd - cpBegin), &xpFirst);
            xpLim = xpFirst + dxp;
/* reload pedl because procedures were called */
            pedl = &(**(pwwdCur->hdndl))[dlT];
            }
        else
            continue;
/* now we have: pedl valid, xpFirst, xpLast describe highlight */
         /* xpFirst = max(xpFirst, xpMin); */
        xpLim = min(xpLim, xpMin + pedl->xpMac);
        if (xpLim > xpFirst)
            {
            if (xpLim > xpMin)
                {
                RECT rc;
                rc.top = pedl->yp - pedl->dyp;
                rc.left = xpSelBar + max(xpFirst - xpMin, 0);
                rc.bottom = pedl->yp;
                rc.right = xpSelBar + xpLim - xpMin;
                InvertRect( wwdCurrentDoc.hDC, (LPRECT)&rc);
                }
            }
/* ToggleSel modified 7/28/85 -- added explicit check for fInsertPoint, since
   the xpLim == xpFirst test sometimes succeeded bogusly when a selection
   was extended backwards. BL */
        else if (fInsertPoint && (xpLim == xpFirst))     /* Insertion point */
            {
            /* vfli should usually be cached already, so will be fast. */
            int yp = pedl->yp;

            FormatLine(docCur, cpMin, pedl->ichCpMin, cpMacCur, flmSandMode);
            if (fOn ^ vfInsertOn)
                {
                if (!vfInsertOn)
                    {
                    vxpCursLine = xpSelBar + xpFirst - xpMin;
                    vypCursLine = yp - vfli.dypAfter;
                    vdypCursLine = min(vfli.dypFont, vfli.dypLine - vfli.dypAfter);
                        /* Start blinking in a while */
                    vfSkipNextBlink = TRUE;
                    }
                DrawInsertLine();
                }
            return;
            }
        }
}




/* T R A S H  W W */
TrashWw(ww)
{ /* Invalidate all dl's in ww */
    Assert( ww >= 0 && ww < wwMax );
    InvalBand(&rgwwd[ww], 0, ypMaxAll);
}




/* I N V A L  B A N D */
/* invalidate the band ypFirst, ypLast inclusive */
InvalBand(pwwd, ypFirst, ypLast)
struct WWD *pwwd; int ypFirst, ypLast;
    {
/* this covers some peculiar rects received from update event after a
window resize by 1 pixel. CS */
    if (ypLast < 0 || ypFirst == ypLast) return;

    pwwd->fDirty = true;
    pwwd->ypFirstInval = min(pwwd->ypFirstInval, ypFirst);
    pwwd->ypLastInval = max(ypLast, pwwd->ypLastInval);
    }




/* T R A S H  A L L  W W S */
TrashAllWws()
{ /* trash them all */
    int     ww;

#ifdef CASHMERE
    for (ww = 0; ww < wwMac; ++ww)
        TrashWw(ww);
#else
    TrashWw( wwDocument );
#endif
    vfli.doc = docNil;  /* Mark vfli invalid */
}


/* T U R N  O F F  S E L */
TurnOffSel()
{ /* Remove sel highlighting from screen */
/* HideSel has no effect */
    if (!vfSelHidden)
        {
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfSelHidden = true;
        }
}

#ifdef  JAPAN

/* We handle IME convert window. */

//int FontHeight = 0; 01/19/93
// 03/29/93 int ImePosSize = 0; //01/19/93
int ImePosSize = 256; //03/29/93 #5484
BOOL    bGetFocus = FALSE;
// Handle to the IME communication block - 061491 Yukini
HANDLE  hImeMem = NULL;

// to prevent unwanted caret traveling - 061591 Yukini
BOOL    bForceBlock = FALSE;
// To avoid ilreagal setting for IME rectangle
static  BOOL bResetIMERect=FALSE;
static  BOOL bDefaultBlock = FALSE; //IME3.1J t-hiroyn

/*
 * ForceImeBlock controls IME input display to the screen.
 * When Write program is writing string to the screen, the caret
 * doesn't move with string. After completing text display,
 * then caret is moved to appropriate position. During this
 * period, if user type something by using IME, char is displayed on the
 * screen. This makes mixing ugly result. This routine will
 * prevent this. Yukini
 */
void ForceImeBlock( hWnd, bFlag )
HWND hWnd;
BOOL bFlag;
{
    WORD x, y;
    LPIMESTRUCT lpmem;

    if (bForceBlock = bFlag) {
        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            /* Move bounding rectangle to out of the world */
            lpmem->fnc = IME_MOVECONVERTWINDOW;
            x = GetSystemMetrics(SM_CXSCREEN);
            y = GetSystemMetrics(SM_CYSCREEN);
            lpmem->wParam = MCW_SCREEN | MCW_RECT;
#if 1 //01/19/93
            lpmem->lParam1 = (DWORD)MAKELONG(x+x/2,y+y/2);
            lpmem->lParam2 = (DWORD)MAKELONG(x+x/2,y+y/2);
            lpmem->lParam3 = (DWORD)MAKELONG(x*2,y*2);
#else
            lpmem->lParam1 = (DWORD)MAKELONG(x+1,y+1);
            lpmem->lParam2 = (DWORD)MAKELONG(x+1,y+1);
            lpmem->lParam3 = (DWORD)MAKELONG(x*2,y*2);
#endif
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
            bResetIMERect = FALSE;
        }
    }
}

void DefaultImeBlock(hWnd)
HWND hWnd;
{
    LPIMESTRUCT lpmem;

    if (bDefaultBlock == FALSE) {
        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            /* Move bounding rectangle to default */
            lpmem->fnc = IME_MOVECONVERTWINDOW;
            lpmem->wParam = MCW_DEFAULT;
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
            bResetIMERect = FALSE;
        }
    }
}

/* use these veriables to optimize IME call. This will prevent task switching
 * overhead. - Yukini
 */
static RECT rcOldRect = {-1, -1, -1, -1};
static DWORD dwCurpos = -1;
static WORD      wModeMCW = MCW_DEFAULT;

void    SetIMEConvertWindow(hWnd,x,y,bFlag)
HWND    hWnd;
int     x,y;
BOOL    bFlag;
{
    LPIMESTRUCT lpmem;
    //Yukini:HANDLE hIMEBlock;
    DWORD dwXY = MAKELONG(x,y);
    BOOL  bRetSendIme;
    RECT rcRect;
    extern BOOL bImeCnvOpen;    // Yutakan:08/06/91

    /* Do nothing if in text drawing to the screen */
    if (bForceBlock)
        return;

    /* we allocate the Ime communication area. freeing of this
     * area will be done by wrap up routine MmwDestroy() of Quit.C.
     * This will improve the performance than previous code. - Yukini
     */
    if (hImeMem == NULL) {
        if ((hImeMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE|GMEM_LOWER,
                (DWORD)sizeof(IMESTRUCT))) == NULL)
            return; // something wrong
    }
//Yukini:   /* Get comunication area with IME */
//Yukini:   hIMEBlock=GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
//Yukini:           (DWORD)sizeof(IMESTRUCT));
//Yukini:   if(!hIMEBlock)  return;

    if(!bGetFocus)
        bFlag = FALSE;

    GetWindowRect(hWnd,&rcRect);

// [yutakan:08/06/91]   IF out of Window Rect, force MCW_DEFAULT.
//  if(rcRect.top > y || rcRect.bottom < y) bFlag = TRUE;
//
    if (bFlag) {

/*   Add ResetIMERect check . If we've not done MOVECONVERTWINDOW after
**  ForceIMEblock(), don't pass by SendIMEMessage to avoid ilreagal setting
**  for bounding rectangle. [Yutakan.]
*/
        // bResetIMERect FALSE when just after ForceImeBlock()
        if ( bResetIMERect == TRUE
            && dwCurpos == dwXY && EqualRect(&rcRect, &rcOldRect)){
            //OutputDebugString("Write:optimized\r\n");
            return;
        }
    } else
        dwCurpos = -1;  // invalidate cache

//Yukini:   lpmem       = (LPIMESTRUCT)GlobalLock(hIMEBlock);
//Yukini:   lpmem->fnc  = IME_MOVECONVERTWINDOW;
//Yukini:   lpmem->wParam   = bFlag?MCW_WINDOW:MCW_DEFAULT;
//Yukini:   lpmem->lParam1  = (DWORD)MAKELONG(x,y);
//Yukini:   GlobalUnlock(hIMEBlock);
//Yukini:   SendIMEMessage(hWnd,MAKELONG(hIMEBlock,NULL));
//Yukini:   GlobalFree(hIMEBlock);

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    if(vfImeHidden) {
        DWORD dwXY1, dwXY2, dwXY3;
        int     x1,x2,x3,y1,y2,y3;
        RECT hiRect;

        //12/28/92
        if(whileUndetermine == TRUE) // we are managing IR_UNDETERMINE
            return;

        CopyRect(&hiRect, &rcRect);

        if(x < 0) x = 0;

        x1 = x + hiRect.left;
        y1 = (vypCursLine - vdypCursLine) + hiRect.top;

        if(y1 < 0) y1 = 0;

        x2 = hiRect.left;

        if(HiddenTextTop == 0)
            y2 = y1;
        else
            y2 = hiRect.top + HiddenTextTop;

        x3 = hiRect.right;
        if(vdypCursLine <= 0)
            y3 = y1 + (19+1);
        else {
            if(HiddenTextBottom == 0)
                y3 = y1 + (vdypCursLine+1);
            else
                y3 = hiRect.top + HiddenTextBottom + 1;

            if(y3 < (y1 + (vdypCursLine+1)))
                y3 = y1 + (vdypCursLine+1);
        }

        if(y2 > y1)
            y2 = y1;

        if(x3 <= x1 || y3 <= y1)
            goto dontHidden;
        if(x3 <= x2 || y3 <= y2)
            goto dontHidden;

        dwXY1 = MAKELONG(x1, y1);
        dwXY2 = MAKELONG(x2, y2);
        dwXY3 = MAKELONG(x3, y3);

        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            lpmem->fnc = IME_MOVECONVERTWINDOW;
            lpmem->wParam = MCW_HIDDEN;
            dwCurpos = dwXY;
            CopyRect(&rcOldRect, &rcRect);
            lpmem->lParam1 = dwXY1;
            lpmem->lParam2 = dwXY2;
            lpmem->lParam3 = dwXY3;
            GlobalUnlock(hImeMem);
            bResetIMERect = TRUE;
            if(MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL))) {
                vfImeHidden = 1; //Hidden OK
                return;
            } else {
                vfImeHidden = 0; //Hidden ERR we set MCW_WINDOW
            }
        }
    }

dontHidden:
    if(selUncpLim > selUncpFirst) {
        return;
    }
#endif

    if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
        lpmem->fnc = IME_MOVECONVERTWINDOW;
        if ((lpmem->wParam = bFlag ? MCW_WINDOW : MCW_DEFAULT) == MCW_WINDOW) {
            /* update previous state */
            dwCurpos = dwXY;
            CopyRect(&rcOldRect, &rcRect);
            lpmem->lParam1 = dwXY;
                        wModeMCW = MCW_WINDOW;  //01/25/93
        } else {
                        wModeMCW = MCW_DEFAULT; //01/25/93
                }
        GlobalUnlock(hImeMem);
        if(FALSE == MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL)))
                        wModeMCW = MCW_DEFAULT; //01/25/93

        bResetIMERect = TRUE;   // yutakan:08/06/91
    }
}

HANDLE hImeSetFont = NULL;
BOOL	bImeFontEx = FALSE; //T-HIROYN 02/25/93
SetImeFont(HWND hWnd)
{
    LPIMESTRUCT lpmem;
    HANDLE      hImeLogfont;
    LOGFONT     lf;
    LPLOGFONT   lpLogfont;
    HANDLE      hfont;

    void IMEManage(BOOL);

    //Get IME use LOGFONT
    if (FALSE == GetLogfontImeFont((LPLOGFONT)(&lf)))
        return;

    if(TRUE == bImeFontEx) {
        if ((hImeLogfont = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
                     (DWORD)sizeof(LOGFONT))) == NULL)
            return; // something wrong

        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            lpmem->fnc = IME_SETCONVERSIONFONTEX;
            lpmem->lParam1 = 0L;
            if (lpLogfont = (LPLOGFONT)GlobalLock(hImeLogfont)) {
                bltbx((LPLOGFONT)(&lf), lpLogfont, sizeof(LOGFONT));
                lpmem->lParam1 = MAKELONG(hImeLogfont,NULL);
                GlobalUnlock(hImeLogfont);
            }
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
        }

        GlobalFree(hImeLogfont);

    } else {

        hfont = CreateFontIndirect(&lf);
        if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
            lpmem->fnc = IME_SETCONVERSIONFONT;
            lpmem->wParam = hfont;
            GlobalUnlock(hImeMem);
            MySendIMEMessageEx(hWnd,MAKELONG(hImeMem,NULL));
        }

        // prev font deleate;
        if(hImeSetFont != NULL) {
            HDC hdc;
            HANDLE oldhfont;

            hdc = GetDC(NULL);
            oldhfont = SelectObject(hdc,hImeSetFont);
            SelectObject(hdc,oldhfont);
            DeleteObject(hImeSetFont);
            ReleaseDC(NULL, hdc);
        }
        hImeSetFont = hfont;
    }

    //display:
    bResetIMERect = FALSE;
    IMEManage( FALSE );
}

int GetLogfontImeFont(lplf)
LPLOGFONT lplf;
{
        extern struct FCE *vpfceScreen;
    extern struct CHP vchpSel;
    struct CHP chp;

    blt(&vchpSel, &chp, cwCHP);  /* CHP for use in comparisons */

    //change CHARSET to KANJI_CHARSET
    {
                int ftc;
        if( ftcNil != (ftc = GetKanjiFtc(&chp))) {
                ApplyCLooks(&chp, sprmCFtc, ftc);
        }
    }

        LoadFont(docCur, &chp, mdFontJam);
    bltbcx(lplf, 0, sizeof(LOGFONT));
        GetObject(vpfceScreen->hfont, sizeof(LOGFONT), lplf);

        //Ime SETCONVERSIONWINDOW set point (vypCursLine - ImePosSize)
        ImePosSize = vfmiScreen.dypBaseline + vfli.dypBase;

        if(chp.hpsPos != 0 ) {
                if (chp.hpsPos < hpsNegMin)
                        ImePosSize += ypSubSuper;
                else
                        ImePosSize -= ypSubSuper;
        }
    return TRUE;
}

void
IMEManage( bFlag )
BOOL bFlag; /* Flag to indicate real default or virtual default in case
           of requesting IME convert line to be default. Real default
           (value TRUE) is selected when I am loosing the focus. In
           this case, IME convert line will be default. Virtual
           default (value FALSE) is selected when I lost a caret
           position. In this case, IME convert line will be out of
           the screen. You can type characters, but not displayed
           to the screen correctly. Yukini
        */
{
int x,y;
BOOL    bCE = ConvertEnable;

/*IME3.1J
        if(!FontHeight)
        {
        TEXTMETRIC  tm;
            GetTextMetrics(wwdCurrentDoc.hDC,&tm);
            FontHeight = tm.tmHeight;
        }
*/
        x = vxpCursLine;
//        y = vypCursLine-(vdypCursLine+FontHeight)/2; IME3.1J
//        y = vypCursLine - FontHeight;

        if(ImePosSize > vdypCursLine)
            y = vypCursLine - vdypCursLine;
        else
            y = vypCursLine - ImePosSize;

        if (x < 0 || y < 0)
            bCE = FALSE;    /* Sometime caret position will be
                       less than zero. Do no set IME
                       window in this case. Yukini */

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
        if (bCE == FALSE && bFlag == FALSE && bForceBlock == FALSE
            && 0 == vfImeHidden) {
#else
        if (bCE == FALSE && bFlag == FALSE && bForceBlock == FALSE) {
#endif
            // get out of the world, babe.
//IME3.1J
            if( vypCursLine > 0 && ImePosSize > vypCursLine ) {
                DefaultImeBlock( wwdCurrentDoc.wwptr);  //t-hiroyn
                bDefaultBlock = TRUE; //IME3.1J
            } else {
                ForceImeBlock( wwdCurrentDoc.wwptr, TRUE );
                bForceBlock = FALSE;
                bDefaultBlock = FALSE; //IME3.1J
            }
// yutakan:08/16/91         dwCurpos = 1;  // invalidate optimize cache
            dwCurpos = -1;
        } else {
            SetIMEConvertWindow(wwdCurrentDoc.wwptr, x, y, bCE);
            bDefaultBlock = FALSE; //IME3.1J
        }
}
#endif  // JAPAN

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J call by MENU selecting.
ChangeImeConversionMode()
{
    extern BOOL bImeCnvOpen;

    vfImeHidden = (vfImeHidden ? 0 : 1);

// 12/28/92   if(vfImeHidden)
//        bImeCnvOpen = TRUE;

    bResetIMERect = FALSE;
    IMEManage( FALSE );
}
#endif

/* D R A W  I N S E R T  L I N E */
DrawInsertLine()
{
#if defined(JAPAN) & defined(DBCS_IME)
    extern BOOL bImeCnvOpen;
#if defined(IME_HIDDEN)
    extern BOOL ImeClearInsert;
#endif
#endif

        /* Draw (in Xor mode) a vertical bar at screen position v*CursLine */
        /* Toggles both the display and the vfInsertOn flag */
        /* Adjustments in cursor draw must be reflected in DisplayFli, above */

            /* Last-minute correction for a bug: assure that the insert line
               does not extend above ypMin */
        if (!vfInsertOn && vdypCursLine > vypCursLine - wwdCurrentDoc.ypMin)
            vdypCursLine = vypCursLine - wwdCurrentDoc.ypMin;

            /* Tell GDI to invert the caret line */

//#3221 01/25/93
#if defined(JAPAN) & defined(DBCS_IME)
#if defined(IME_HIDDEN)
        if(ImeClearInsert || (bImeCnvOpen && wModeMCW == MCW_WINDOW) ) {
#else
        if(bImeCnvOpen && wModeMCW == MCW_WINDOW) {
#endif
            if(vfInsertOn) {
                PatBlt( wwdCurrentDoc.hDC, vxpCursLine,
                 vypCursLine - vdypCursLine, 2, vdypCursLine , DSTINVERT );
                vfInsertOn = 1 - vfInsertOn;
            }
        } else {
            PatBlt( wwdCurrentDoc.hDC, vxpCursLine,
                 vypCursLine - vdypCursLine, 2, vdypCursLine , DSTINVERT );
            vfInsertOn = 1 - vfInsertOn;
        }
#else
        PatBlt( wwdCurrentDoc.hDC, vxpCursLine, vypCursLine - vdypCursLine,
                      2, vdypCursLine , DSTINVERT );
        vfInsertOn = 1 - vfInsertOn;
#endif

/*T-HIROYN sync 3.0 disp.c */
#ifdef  JAPAN   /* KenjiK '90-10-30 */
    if(bClearCall)
    {
        if((vxpCursLine>=0) && (vxpCursLine<=wwdCurrentDoc.xpMac)
        && (vypCursLine>=0) && (vypCursLine<=wwdCurrentDoc.ypMac))
            ConvertEnable = TRUE;

    }
    IMEManage( FALSE );
#endif
}




/* C L E A R  I N S E R T  L I N E */
ClearInsertLine()
{
#if defined(JAPAN) & defined(DBCS_IME)
/* So we do some IME manage when clearning the line */

    if((vxpCursLine<0) || (vxpCursLine>=wwdCurrentDoc.xpMac)
    || (vypCursLine<0) || (vypCursLine>=wwdCurrentDoc.ypMac)) {
        ConvertEnable = FALSE;
        //OutputDebugString("ClearInsertLine\r\n");
    }

    bClearCall = FALSE;

    if ( vfInsertOn)    DrawInsertLine();
    else            IMEManage( FALSE );

    bClearCall = TRUE;

#else
 if ( vfInsertOn) DrawInsertLine();
#endif
}



#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
UndetermineTextOut(HDC hDC, int xp, int yp, PCH ptr, int cch, LPSTR Attrib)
{
    int Length;
    long rgbBack;
    long rgbText;
    int  bkMode;
    PCH ptr1 = ptr;
    TEXTMETRIC tm;

    GetTextMetrics(hDC, &tm);

    bkMode = SetBkMode(hDC, OPAQUE);

    rgbBack = GetBkColor(hDC);
    rgbText = GetTextColor(hDC);
    while( cch ) {
        switch((*Attrib) & 0x03)
        {
            case 1:
                SetBkColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMESPOT]));
                SetTextColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMESPOTTEXT]));
// 12/28/92
                if(HiddenTextTop == 0)
                    HiddenTextTop = yp;

                if(HiddenTextTop > yp)
                    HiddenTextTop = yp;

                if(HiddenTextBottom == 0)
                    HiddenTextBottom = yp + tm.tmHeight;

                if(HiddenTextBottom > (yp + tm.tmHeight))
                    HiddenTextBottom = yp + tm.tmHeight;
                break;
            case 0:
                SetBkColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEINPUT]));
                SetTextColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEINPUTTEXT]));
                break;

            case 2:
            default:
                SetBkColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEOTHER]));
                SetTextColor(hDC,
                    GetNearestColor(hDC, rgbIMEHidden[IMEOTHERTEXT]));
                break;
        }
        Length = ( (IsDBCSLeadByte((BYTE)(*ptr1)) ) ? 2 : 1 );
        TextOut(hDC, xp, yp, ptr1, Length);
        xp += LOWORD(GetTextExtent(hDC, ptr1, Length));
        xp-=tm.tmOverhang;
        ptr1+=Length;
        Attrib+=Length;
        AttribPos+=Length;
        cch-=Length;
    }
    SetBkColor(hDC,rgbBack);
    SetTextColor(hDC,rgbText);
    SetBkMode(hDC, bkMode);
}
UndetermineString(HDC hDC, int xp, int yp, PCH ptr, int cch, typeCP cpFirst,
                  typeCP cpEnd)
{
    int Length;
    int len = cch;
    PCH ptr1;
    TEXTMETRIC tm;

    GetTextMetrics(hDC, &tm);
    ptr1 = ptr;

    if((cpEnd <= selUncpFirst) || (cpFirst >= selUncpLim))
        TextOut(hDC, xp, yp, ptr1, len);
    else {
        Attrib = GlobalLock(hImeUnAttrib);

        if(cpFirst < selUncpFirst) {
            Length = selUncpFirst - cpFirst;
            TextOut(hDC, xp, yp, ptr1, Length);
            xp+=LOWORD(GetTextExtent(hDC, ptr1, Length));
            xp-=tm.tmOverhang;
            len-=Length;
            ptr1+=Length;
        }
        if(selUncpLim <= cpEnd) {
            if(cpFirst > selUncpFirst) {
                Length = (int)(selUncpLim - cpFirst);
                Attrib += (cpFirst-selUncpFirst);
            }
            else {
                Length = (int)(selUncpLim - selUncpFirst);
            }
            UndetermineTextOut(hDC, xp, yp, ptr1, Length, Attrib);

            AttribPos = 0;
            xp+=LOWORD(GetTextExtent(hDC, ptr1, Length));
            xp-=tm.tmOverhang;
            ptr1+=Length;
            len-=Length;

            if ( Length = (int)(cpEnd - selUncpLim) ) {
                 TextOut(hDC, xp, yp, ptr1, Length);
            }
        }
        else if(Attrib) {
            if(cpFirst > selUncpFirst) {
                Attrib += (cpFirst-selUncpFirst);
            }
            UndetermineTextOut(hDC, xp, yp, ptr1,len, Attrib);
        }
        GlobalUnlock(hImeUnAttrib);
        Attrib = NULL;
   }
}

DoHiddenRectSend()
{
    bResetIMERect = FALSE;
    IMEManage( FALSE );
}

GetImeHiddenTextColors()
{
    COLORREF NEAR PASCAL GetIMEColor(WORD);
    int i;

    for (i = 0; i < IMEDEFCOLORS; i++)
      rgbIMEHidden[i] = GetIMEColor(i);
}

/*
    GetIMEColor -

    Retrieve IME color scheme from [colors] in win.ini
*/
#define MAX_SCHEMESIZE 190

COLORREF NEAR PASCAL GetIMEColor(WORD wIndex)
{

static char  *pszWinStrings[IMEDEFCOLORS] = {
                         "IMESpot",
                         "IMESpotText",
                         "IMEInput",
                         "IMEInputText",
                         "IMEOther",
                         "IMEOtherText"};

  BYTE szTemp[MAX_SCHEMESIZE];
  LPBYTE szLP;
  COLORREF colRGB;
  int i, v;

  if (wIndex >= IMEDEFCOLORS)
      return RGB(0,0,0);

  GetProfileString("colors",
                   pszWinStrings[wIndex],
                   "",
                   szTemp,
                   MAX_SCHEMESIZE);

  if (!lstrlen(szTemp)) {
      switch(wIndex) {
          case IMESPOT:
              return GetSysColor(COLOR_HIGHLIGHTTEXT);
          case IMESPOTTEXT:
              return GetSysColor(COLOR_HIGHLIGHT);
          case IMEINPUT:
              return GetSysColor(COLOR_WINDOW);
          case IMEINPUTTEXT:
              return GetSysColor(COLOR_HIGHLIGHT);
          case IMEOTHER:
              return GetSysColor(COLOR_WINDOW);
          case IMEOTHERTEXT:
              return GetSysColor(COLOR_HIGHLIGHT);
      }
  }

  colRGB = RGB(0,0,0);
  szLP = szTemp;
  for (i = 0; i < 3; i++) {
      v = 0;
      while(*szLP < '0' || *szLP > '9') szLP++;
      while(*szLP >= '0' && *szLP <= '9') v = v * 10 + (*szLP++ - '0');
      switch(i) {
        case 0:
            colRGB |= RGB(v,0,0);
            break;
        case 1:
            colRGB |= RGB(0,v,0);
            break;
        case 2:
            colRGB |= RGB(0,0,v);
            break;
      }
  }
  return colRGB;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\d_form1.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*--- Module not really used, just the idea behind FORMAT.ASM ---*/


#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOCLIPBOARD
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#include <windows.h>
/* #include "wwsmall.h" */

#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "ch.h"
#include "docdefs.h"
#include "ffdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "dispdefs.h"
#include "scrndefs.h"
#include "macro.h"
#include "debug.h"
#include "fontdefs.h"
#include "str.h"
#include "wwdefs.h"
#ifdef DBCS
#include "dbcs.h"
/* We move several hard code Kanji code table from this source file
   to kanji.h as external variables. Define CODE_TABLE will define
   those variables */
#define CODE_TABLE

#include "kanji.h"
#endif

#if defined(TAIWAN) || defined(PRC)
int WINAPI GetFontAssocStatus(HDC);
#endif

#ifdef DFLI
#define Dfli(x) x  /* Enable debug-format-line info */
#else
#define Dfli(x)
#endif

#ifdef CASHMERE
#define                 cchSmcapMax     16
#endif /* CASHMERE */

static int              ichpFormat;

#ifdef CASHMERE
static CHAR             mptlcch[] = " .-_";
#endif /* CASHMERE */

#if defined(JAPAN) || defined(KOREA)                  //  added  22 Jun. 1992  by Hiraisi
int iWidenChar;     /* counter for widened characters except (KANJI) space */
                    /*   Ex.) DBCS, Japanese KANA */
int iNonWideSpaces;

#elif defined(TAIWAN) || defined(PRC)//  Daniel/MSTC, 1993/02/25, for jcBoth
int iWidenChar;     /* counter for widened characters except (KANJI) space */
                    /*   Ex.) DBCS, Japanese KANA */
int iNonWideSpaces;
extern int vfWordWrap;
#define FKana(_ch)      FALSE
#endif

/* T-HIROYN sync format.asm */
/*extern int              docHelp;*/
extern struct FLI       vfli;
extern struct CHP       (**vhgchpFormat)[];
extern int              ichpMacFormat;
extern struct CHP       vchpAbs;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct CHP       vchpNormal;
extern struct DOD       (**hpdocdod)[];
extern typeCP           vcpLimSectCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern typeCP           vcpFetch;
extern int              vichFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern int              vcchFetch;
extern int              vftc;
extern int              ypSubSuper;
extern int              ypSubSuperPr;
extern HDC              vhMDC;
extern HDC              vhDCPrinter;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern int              dypMax;
extern struct FMI       vfmiScreen, vfmiPrint;
extern int              vfOutOfMemory;
extern CHAR             vchDecimal;  /* "decimal point" character */
extern int              vzaTabDflt;  /* width of default tab */
#if defined(JAPAN) || defined(KOREA)
extern int              vfWordWrap; /*t-Yoshio WordWrap flag*/
#endif

#ifdef CASHMERE
extern int              vfVisiMode;
#endif /* CASHMERE */


/* F O R M A T  L I N E */
FormatLine(doc, cp, ichCp, cpMac, flm)
int doc;
typeCP cp;
int ichCp;
typeCP cpMac;
int flm;
    {
    /* Fills up vfli with a line of text */

    int near Justify(struct IFI *, unsigned, int);
    int near FGrowFormatHeap(void);
    int near FFirstIch(int);

#ifdef DBCS
    BOOL near FAdmitCh1(CHAR);
    BOOL near FAdmitCh2(CHAR, CHAR);
    BOOL near FOptAdmitCh1(CHAR);
    BOOL near FOptAdmitCh2(CHAR, CHAR);
    int DBCSDxpFromCh(int,int,int);
#endif

    struct IFI ifi;
    struct TBD *ptbd;
    struct CHP chpLocal;
    int xpTab;

#ifdef CASHMERE
    int dypBefore;
#endif /* CASHMERE */

    int dypAscent;
    int dypDescent;
    int dypAscentMac;
    int dypDescentMac;
    unsigned xaLeft;
    unsigned xaRight;
    struct PAP *ppap;
    struct SEP *psep;
    int fFlmPrinting = flm & flmPrinting;
    int dxaFormat;
    int dyaFormat;
    int dxpFormat;
    int dypFormat;
    int ypSubSuperFormat;
    int fTruncated = false;     /* if the run was truncated */
    int ichpNRH;

#ifdef DBCS
    int dichSpaceAdjust;
    int             dypLeading;
    int             dypIntLeading;
    int             dypPAscent;         /* Pure Ascent */
    int             dypLeadingMac;
    int             dypIntLeadingMac;
    int             dypPAscentMac;
    BOOL            fKanjiBreakOppr = false;
    BOOL            fKanjiPrevious = false;
    /* true iff we already have a hanging character on the line. */
    BOOL            fKanjiHanging = false;
    /* true iff the first and second bytes of a kanji character
       were in two different runs. */
    BOOL            fOddBoundary = false;
    typeCP          cpFetchSave;
    typeCP          cpSeqFetch;
    int             ichFetchSave;
    int             cchUsedSave;

    extern int      utCur;
    extern int      dxaAdjustPer5Ch;
    extern unsigned cxaCh;
#endif /* ifdef DBCS */


#ifdef CASHMERE
    struct FNTB **hfntb;
    int fVisiMode;
#endif /* CASHMERE */

    /* Check for fli current */
    if (vfli.doc == doc && vfli.cpMin == cp && vfli.ichCpMin == ichCp &&
      vfli.flm == flm)
        {
        /* Just did this one */
        return;
        }

#ifdef JAPAN   // added by Hiraisi
//   When printing, WRITE doesn't redraw the screen.
{
    extern BOOL fPrinting;
    if( fPrinting && !fFlmPrinting )
        return;
}
#endif

    Scribble(5, 'F');
    bltc(&vfli, 0, cwFLIBase);
    /* This means:
        vfli.fSplat = false;
        vfli.dcpDepend = 0;
        vfli.ichCpMac = 0;
        vfli.dypLine = 0;
        vfli.dypAfter = 0;
        vfli.dypFont = 0;
        vfli.dypBase = 0;
    */

    /* vfSplatNext = FALSE; No longer used. */

    /* Rest of format loads up cache with current data */
    vfli.doc = doc;
    vfli.cpMin = cp;
    vfli.ichCpMin = ichCp;
    vfli.flm = flm;

    if (cp > cpMac)
        {
        /* Space after the endmark.  Reset the cache because the footnotes come
        at the same cp in the footnote window */
        vfli.doc = docNil;
        vfli.cpMac = cp;
        vfli.rgdxp[0] = 0;

        /* Line after end mark is taller than screen */

#ifdef CASHMERE
        vfli.dypBase = vfli.dypFont = vfli.dypAfter = ((vfli.dypLine = dypMax)
          >> 1);
#else /* not CASHMERE */
        vfli.dypBase = vfli.dypFont = ((vfli.dypLine = dypMax) >> 1);
#endif /* not CASHMERE */

        Scribble(5, ' ');
        return;
        }

    /* Initialize run tables */
    ichpFormat = 0;

    /* Cache section and paragraph properties */

#ifdef CASHMERE
    hfntb = (**hpdocdod)[doc].hfntb;
    if (hfntb == 0 || cp < (**hfntb).rgfnd[0].cpFtn)
        {
        /* Normal text */
        CacheSect(doc, cp);
        }
    else
        {
        /* Footnote section properties come from the section of the footnote
        reference. */
        CacheSect(doc, CpRefFromFtn(doc, cp));
        }
#else /* not CASHMERE */
    CacheSect(doc, cp);
#endif /* not CASHMERE */

    psep = &vsepAbs;

    CachePara(doc, cp);
    ppap = &vpapAbs;

    /* Now we have:
        ppap    paragraph properties
        psep    division properties
    */

    if (ppap->fGraphics)
        {
        /* Format a picture paragraph in a special way (see picture.c) */
        FormatGraphics(doc, cp, ichCp, cpMac, flm);
        Scribble(5, ' ');
        return;
        }

    /* Assure we have a good memory DC for font stuff */
    ValidateMemoryDC();
    if (vhMDC == NULL || vhDCPrinter == NULL)
        {
        Scribble(5, ' ');
        return;
        }

#ifdef CASHMERE
    /* When printing, don't show visible characters */
    fVisiMode = vfVisiMode && !fFlmPrinting;
#endif /* CASHMERE */

    bltc(&ifi, 0, cwIFI);
    /* This means:
        ifi.ich = 0;
        ifi.ichPrev = 0;
        ifi.ichFetch = 0;
        ifi.cchSpace = 0;
        ifi.ichLeft = 0;
    */

    ifi.jc = jcTabLeft;
    ifi.fPrevSpace = true;

    /* Set up some variables that have different value depending on whether we
    are printing or not. */
    if (fFlmPrinting)
        {
        dxaFormat = dxaPrPage;
        dyaFormat = dyaPrPage;
        dxpFormat = dxpPrPage;
        dypFormat = dypPrPage;
        ypSubSuperFormat = ypSubSuperPr;
        }
    else
        {
        dxaFormat = dyaFormat = czaInch;
        dxpFormat = dxpLogInch;
        dypFormat = dypLogInch;
        ypSubSuperFormat = ypSubSuper;
        }

    /* Calculate line height and width measures.  Compute
        xaLeft          left indent 0 means at left margin
        xaRight         width of column measured from left margin (not from left
                        indent).
    */
    xaLeft = ppap->dxaLeft;

    /* If this is the first line of a paragraph, adjust xaLeft for the first
    line indent.  (Also, set dypBefore, since its handy.) */
    if (cp == vcpFirstParaCache)
        {
        xaLeft += ppap->dxaLeft1;

#ifdef CASHMERE
        dypBefore = MultDiv(ppap->dyaBefore, dypLogInch, czaInch);
#endif /* CASHMERE */

        }

#ifdef CASHMERE
    else
        {
        dypBefore = 0;
        }
#endif /* CASHMERE */

    /* Now, set xaRight (width measured in twips). */

#ifdef CASHMERE
    xaRight = (ppap->rhc ? vsepPage.xaMac - vsepPage.dxaGutter :
      psep->dxaText) - ppap->dxaRight;
#else /* not CASHMERE */
    xaRight = psep->dxaText - ppap->dxaRight;
#endif /* not CASHMERE */


    /* Do necessary checks on xaLeft and xaRight */
    if (xaRight > xaRightMax)
        {
        xaRight = xaRightMax;
        }
    if (xaLeft > xaRightMax)
        {
        xaLeft = xaRightMax;
        }
    if (xaLeft < 0)
        {
        xaLeft = 0;
        }
    if (xaRight < xaLeft)
        {
        xaRight = xaLeft + 1;
        }

    vfli.xpLeft = ifi.xp = ifi.xpLeft = MultDiv(xaLeft, dxpFormat, dxaFormat);
    vfli.xpMarg = ifi.xpRight = MultDiv(xaRight, dxpFormat, dxaFormat);
    ifi.xpPr = MultDiv(xaLeft, dxpPrPage, dxaPrPage);
    ifi.xpPrRight = MultDiv(xaRight, dxpPrPage, dxaPrPage);

#ifndef JAPAN       // added by Hiraisi (BUG#3542)
#ifdef  DBCS                /* was in JAPAN */
/* at least one kanji is displayed */
/* DxpFromCh() --> DBCSDxpFromCh()   03 Oct 1991 YutakaN */
    {
       int dxpPr;
    if ( ifi.xpPrRight - ifi.xpPr < (dxpPr = DBCSDxpFromCh(bKanjiSpace1,bKanjiSpace2, TRUE) ) )
    {
    ifi.xpPrRight = ifi.xpPr + dxpPr + 1;
    }
    }
#endif
#endif

    /* Get a pointer to the tab-stop table. */
    ptbd = ppap->rgtbd;

    /* Turn off justification. */
    SetTextJustification(fFlmPrinting ? vhDCPrinter : vhMDC, 0, 0);

    /* Initialize the line height information. */
    dypAscentMac = dypDescentMac = 0;

/*T-HIROYN add from 3.0*/
#if defined(JAPAN) || defined(KOREA)
    dypLeadingMac = dypIntLeadingMac = dypPAscentMac = 0;
#endif /* JAPAN */

    /* To tell if there were any tabs */
    ifi.ichLeft = -1;

#if defined(JAPAN) || defined(KOREA)                  //  added  22 Jun. 1992  by Hiraisi
    iWidenChar=0;
#elif defined(TAIWAN) || defined(PRC) // Daniel/MSTC, 1993/02/25, for jcBoth
    iWidenChar=0;
#endif

    /* Get the first run, and away we go... */
    FetchCp(doc, cp, ichCp, fcmBoth + fcmParseCaps);
    goto FirstCps;

    for ( ; ; )
        {
        int iichNew;
        int xpPrev;
        int dxp;
        int dxpPr;

        /* The number of characters to process (usually vcchFetch) */
        int cch;

        /* The number of characters in current run already used */
        int cchUsed;

        /* A pointer to the current list of characters (usually vpchFetch) */
        CHAR *pch;

#ifdef CASHMERE
        CHAR rgchSmcap[cchSmcapMax];
#endif /* CASHMERE */

        if (ifi.ichFetch == cch)
            {
            /* End of a run */
            int dich;
            BOOL fSizeChanged;

            if (ifi.ich >= ichMaxLine )
            /* End of run because of line length limit has been reached. */
                {
                goto DoBreak;
                }

            if (fTruncated)
                {
                cchUsed += cch;
                pch = vpchFetch + cchUsed;
                cch = vcchFetch - cchUsed;
                fTruncated = false;
                goto OldRun;    /* use the rest of the old run  */
                }

NullRun:
#ifdef DBCS
            if (!fOddBoundary)
                {
                /* The last fetch did not mess up a sequential access. */
                FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
                }
            else
                {
                /* Previous fetch was an odd one.  Set it up again. */
                FetchCp(doc, cpSeqFetch, 0, fcmBoth + fcmParseCaps);
                }
            fOddBoundary = false;
#else
            FetchCp(docNil, cpNil, 0, fcmBoth + fcmParseCaps);
#endif

FirstCps:

            cchUsed = 0;

            /* Continue fetching runs until a run is found with a nonzero
            length. */
            if ((cch = vcchFetch) == 0)
                {
                goto NullRun;
                }

            pch = vpchFetch;
            if (vcpFetch >= cpMac || (!fFlmPrinting && *pch == chSect))
                {
#ifdef SYSENDMARK
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = ftcSystem;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#else
#ifdef REVIEW
                /* The following comment is absolutely misleading!  Ftc==0
                   doesn't give you a system font.  It gives you the first
                   entry in the font table. */
#endif /* REVIEW */
                /* Force end mark and section mark to be in standard system
                font. */
                blt(&vchpNormal, &vchpAbs, cwCHP);
                vchpAbs.ftc = 0;
                vchpAbs.ftcXtra = 0;
                vchpAbs.hps = hpsDefault;
#endif /* if-else-def KANJI */
                }

#ifdef CASHMERE
            /* Adjust the size of the font for "small capitals". */
            if (vchpAbs.csm == csmSmallCaps)
                {
                vchpAbs.hps = HpsAlter(vchpAbs.hps, -1);
                }
#endif /* CASHMERE */

            /* Now we have:
                ichpFormat     index into gchp table
                vcpFetch        first cp of current run
                vfli.cpMin      first cp of line
                ifi.ich         ???
            */

           /* since LoadFont could change vchpAbs, and we don't want
              that to happen, we copy vchpAbs into vchpLocal and use
              vchpLocal in place of vchpAbs hereafter. Note that vchpAbs
              is intentionally used above for handling the endmark. */

                blt(&vchpAbs, &chpLocal, cwCHP);


            if (fFlmPrinting)
                {
                LoadFont(doc, &chpLocal, mdFontPrint);
                dypAscent = vfmiPrint.dypAscent + vfmiPrint.dypLeading;
                dypDescent = vfmiPrint.dypDescent;
#ifdef DBCS            /* was in JAPAN */
                dypPAscent = vfmiPrint.dypAscent;
                dypLeading = vfmiPrint.dypLeading;
                dypIntLeading = vfmiPrint.dypIntLeading;
#endif
                }
            else
                {
                LoadFont(doc, &chpLocal, mdFontJam);
                dypAscent = vfmiScreen.dypAscent + vfmiScreen.dypLeading;
                dypDescent = vfmiScreen.dypDescent;
#ifdef DBCS            /* was in JAPAN */
                dypPAscent = vfmiScreen.dypAscent;
                dypLeading = vfmiScreen.dypLeading;
                dypIntLeading = vfmiScreen.dypIntLeading;
#endif
                }
#ifdef ENABLE   /* BRYANL 8/27/87: New philosophy for handling
                   font selection failures is: font selection
                   ALWAYS succeeds. This prevents FormatLine
                   returns that do not advance. */
            /* Bail out if there is a memory failure. */
            if (vfOutOfMemory)
                {
                goto DoBreak;
                }
#endif  /* ENABLE */

            /* Floating line size algorithm */
            if (chpLocal.hpsPos != 0)
                {
                /* Modify font for subscript/superscript */
                if (chpLocal.hpsPos < hpsNegMin)
                    {
                    dypAscent += ypSubSuperFormat;
#ifdef DBCS            /* was in JAPAN */
                    dypPAscent += ypSubSuperFormat;
#endif
                    }
                else
                    {
                    dypDescent += ypSubSuperFormat;
                    }
                }

            /* Update the maximum ascent and descent of the line. */
            fSizeChanged = FALSE;
            if (dypDescentMac < dypDescent)
                {
                dypDescentMac = dypDescent;
                fSizeChanged = TRUE;
                }
            if (dypAscentMac < dypAscent)
                {
                dypAscentMac = dypAscent;
                fSizeChanged = TRUE;
                }

#ifdef DBCS                /* was in JAPAN */
            if (dypPAscentMac < dypPAscent)
                {
                dypPAscentMac = dypPAscent;
                fSizeChanged = TRUE;
                }
            if (dypIntLeadingMac < dypIntLeading)
                {
                dypIntLeadingMac = dypIntLeading;
                fSizeChanged = TRUE;
                }
            if (dypLeadingMac < dypLeading)
                {
                dypLeadingMac = dypLeading;
                fSizeChanged = TRUE;
                }
#endif

            if (fSizeChanged)
                {

#ifdef AUTO_SPACING
                /* This is the original Mac Word code that assumed line spacing
                of 0 in a PAP meant auto line spacing.  PC Word defaults to 1
                line invalidating this assumption. */
                if (ppap->dyaLine == 0)
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = dypDescentMac + dypAscentMac + dypBefore;
#else /* not CASHMERE */
                    ifi.dypLineSize = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    }
                else
                    {

#ifdef CASHMERE
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                    ifi.dypLineSize = imax(MultDiv(ppap->dyaLine, dypFormat,
                      dyaFormat), 1);
#endif /* not CASHMERE */

                    }
#else /* not AUTO_SPACING */
                /* This code forces auto line spacing except in the case where
                the user specifies a line spacing greater than the auto line
                spacing. */
                    {
#ifdef DBCS                /* was in JAPAN */
#if defined(TAIWAN) || defined(PRC)
            register int dypAuto = dypDescentMac + dypAscentMac;
            if (ppap->dyaLine > czaLine)
            {
            register int dypUser = imax(MultDiv(ppap->dyaLine,
              dypFormat, dyaFormat), 1);

            ifi.dypLineSize = max(dypAuto, dypUser);
            }
            else
            {
            ifi.dypLineSize = dypAuto;
            }
#else   /* TAIWAN */
                    register int dypAuto = dypDescentMac + dypAscentMac;
                             int cHalfLine;
                             int dypSingle = dypPAscentMac + dypDescentMac;

                    cHalfLine = (ppap->dyaLine + (czaLine / 4)) / (czaLine / 2);
                    ifi.dypLineSize = (cHalfLine == 3) ? (dypSingle*3)/2  :
                                           ((cHalfLine <= 2) ?
                                                dypSingle :
                                                (dypSingle * 2));
#endif      /* TAIWAN */
#else // DBCS
#ifdef CASHMERE
                    register int dypAuto = dypDescentMac + dypAscentMac +
                      dypBefore;
#else /* not CASHMERE */
                    register int dypAuto = dypDescentMac + dypAscentMac;
#endif /* not CASHMERE */

                    if (ppap->dyaLine > czaLine)
                        {
#ifdef CASHMERE
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat) + dypBefore, dypBefore + 1);
#else /* not CASHMERE */
                        register int dypUser = imax(MultDiv(ppap->dyaLine,
                          dypFormat, dyaFormat), 1);
#endif /* not CASHMERE */

                        ifi.dypLineSize = max(dypAuto, dypUser);
                        }
                    else
                        {
                        ifi.dypLineSize = dypAuto;
                        }
#endif      /* DBCS */
                    }
#endif /* not AUTO_SPACING */

                }

OldRun:
            /* Calculate length of the run but no greater than 256 */
            iichNew = (int)(vcpFetch - vfli.cpMin);
            if (iichNew >= ichMaxLine)
                {
                iichNew = ichMaxLine - 1;
                }
            dich = iichNew - ifi.ich;

            /* Ensure that all tab and non-required hyphen characters start at
            beginning of run */
            if (ichpFormat <= 0  || dich > 0 || CchDiffer(&chpLocal,
              &(**vhgchpFormat)[ichpFormat - 1], cchCHPUsed) != 0 || *pch ==
              chTab || *pch == chNRHFile)
                {
#ifdef DFLI
                if (*pch == chNRHFile)
                    CommSz("CHNRHFILE at beginning of run");
#endif
                if (ichpFormat != ichpMacFormat || FGrowFormatHeap())
                    {
                    register struct CHP *pchp = &(**vhgchpFormat)[ichpFormat -
                      1];

                    if (ichpFormat > 0)
                        {
                        pchp->cchRun = ifi.ich - ifi.ichPrev;
                        pchp->ichRun = ifi.ichPrev;
                        }
                    blt(&chpLocal, ++pchp, cwCHP);

#ifdef ENABLE   /* font codes */
                    pchp->ftc = vftc;
                    pchp->ftcXtra = (vftc & 0x01c0) >> 6;
                    pchp->hps = vhps;
#endif /* ENABLE */

                    pchp->cchRun = ichMaxLine;
                    if (dich <= 0)
                        {
                        pchp->ichRun = ifi.ich;
                        }
                    else
                        {
                        /* Q&D insert */
                        bltc(&vfli.rgdxp[ifi.ich], 0, dich);
                        bltbc(&vfli.rgch[ifi.ich], 0, dich);
                        pchp->ichRun = ifi.ich = iichNew;
                        }
                    ifi.ichPrev = ifi.ich;
                    ichpFormat++;
                    }
                }

            if (vcpFetch >= cpMac)
                {
                /* End of doc reached */
                if (!ifi.fPrevSpace || vcpFetch == cp)
                    {
                    vfli.ichReal = ifi.ich;
                    vfli.xpReal = ifi.xpReal = ifi.xp;
                    }
/* T-HIROYN sync fromat.asm */
/*              if (!fFlmPrinting && (doc != docHelp))*/
                if (!fFlmPrinting)
                    {
/*
 * Write 3.1j endmark is 1-bytecharcter
 *                       t-Yoshio May 26,92
 */
#if defined(JAPAN) || defined(KOREA)
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chEMark,
                      false));
#else
#ifdef  DBCS                    /* was in JAPAN */
        /* We use Double byte character to chEMark in Japan */
                    if (ifi.ich + cchKanji > ichMaxLine) {
                        /* vfli.rgch has no room for the two-byte
                           end mark.  Too bad do the break and
                           wait for the next time around. */
                        goto DoBreak;
                        }
                    vfli.rgch[ifi.ich] = chMark1;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chMark1,
                      false));
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.rgdxp[ifi.ich++] = 0;

#if !defined(TAIWAN) && !defined(PRC)
            ifi.dypLineSize += 2;
#endif

#else    /* DBCS */
                    vfli.rgch[ifi.ich] = chEMark;
                    vfli.xpReal += (vfli.rgdxp[ifi.ich++] = DxpFromCh(chEMark,
                      false));
#endif
#endif /*JAPAN*/
                    }
                vfli.dypLine = ifi.dypLineSize;
                vfli.dypBase = dypDescentMac;
                vfli.dypFont = dypAscentMac + dypDescentMac;
                vfli.ichMac = vfli.ichReal = ifi.ich;
                vfli.cpMac = cpMac + 1;
                goto JustEol;   /* dcpDepend == 0 */
                }

            /* Here we have ifi.ich, cch */
            if (ifi.ich + cch > ichMaxLine)
            /* If this run would put the line over 255, truncate it and set a
            flag. */
                  {
                  cch = ichMaxLine - ifi.ich;
                  fTruncated = true;
                  }

            ifi.ichFetch = 0;

#ifdef CASHMERE
            if (chpLocal.csm != csmNormal)
                {
                int ich;
                CHAR *pchT = &rgchSmcap[0];

                /* We can handle only a run of cchSmcapMax small capital
                characters.  If the run is larger then truncate. */
                if (cch > cchSmcapMax)
                    {
                    cch = cchSmcapMax;
                    fTruncated = true;
                    }

                /* Raise the case of the characters. */
                for (ich = 0 ; ich < cch ; ich++)
                    {
                    *pchT++ = ChUpper(*pch++);
                    }
                pch = &rgchSmcap[0];
                }
#endif /* CASHMERE */

            /* Do "special" characters here */
            if (chpLocal.fSpecial)
                {
                if (!FFormatSpecials(&ifi, flm, vsepAbs.nfcPgn))
                    {
                    if (ifi.chBreak == 0 )   /* No breaks in this line */
                        {
                        goto Unbroken;
                        }
                    else
                        {
                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
                        goto JustBreak;
                        }
                    }
                }

            continue;
            }

        /* End of new run treatment.  We are back in the "for every character"
        section. */
            {
            register int ch = pch[ifi.ichFetch++];

NormChar:
#ifdef  DBCS
            /* Unless it is a kanji space, we only need to adjust
               by 1 byte. */
            dichSpaceAdjust = 1;
#endif
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            if (ch == chSpace && vfWordWrap)
#else
            if (ch == chSpace)
#endif

                {
                /* Speed kludge for spaces */
                ifi.xp += (vfli.rgdxp[ifi.ich] = dxp =
                    fFlmPrinting ? vfmiPrint.dxpSpace : vfmiScreen.dxpSpace);
                ifi.xpPr += (dxpPr = vfmiPrint.dxpSpace);
                vfli.rgch[ifi.ich++] = chSpace;
#ifdef DFLI
                {
                char rgch[100];

                wsprintf(rgch,"  chSpace     , xp==%d/%d, xpPr==%d/%d",
                    ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                CommSz(rgch);
                }
#endif
                goto BreakOppr;
                }

#ifndef TEMP_KOREA
            /* If the printer width is not in the printer width table, then get
            it. */
            if (ch < chFmiMin || ch >= chFmiMax || (dxpPr =
              vfmiPrint.mpchdxp[ch]) == dxpNil)
                {
#ifdef  DBCS
                /*  Don't pass to DxpFromCh() DBCS LeadByte except for '8140H'.
                ** Because the function can make elleagal ShiftJIS and pass it
                ** to GetTextExtent(). GetTextExtent might return SBC space
                ** when the code is undefined. this will cause win-hang-up at
                ** formatting line.       yutakan
                */
#if defined(TAIWAN) || defined(PRC)  //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
                dxpPr=DBCSDxpFromCh(ch, ( ((cp + ifi.ich) < cpMac) ?
                                pch[ifi.ichFetch] : 0 ), TRUE);
#else
                dxpPr=DBCSDxpFromCh(ch,pch[ifi.ichFetch],TRUE);
#endif  //TAIWAN
#else
                dxpPr = DxpFromCh(ch, TRUE);
#endif
                }

            if (fFlmPrinting)
                {
                /* If we are printing, then there is no need to bother with the
                screen width. */
                dxp = dxpPr;
                }
            else if (ch < chFmiMin || ch >= chFmiMax ||
                (dxp = vfmiScreen.mpchdxp[ch]) == dxpNil)
#ifdef DBCS
#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
            dxp = DBCSDxpFromCh(ch, ( ((cp + ifi.ich) < cpMac) ?
                                pch[ifi.ichFetch] : 0 ), FALSE);
#else
// yutakan:
            dxp = DBCSDxpFromCh(ch,pch[ifi.ichFetch],FALSE);
#endif  //TAIWAN
#else
                    dxp = DxpFromCh(ch, FALSE);
#endif      /* ifdef DBCS */

#endif      /* ifndef KOREA */
#ifdef DBCS             /* was in JAPAN */

//solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
//#ifdef  TAIWAN
//            if (IsDBCSLeadByte(ch) && !pch[ifi.ichFetch]) {
//                ifi.xp += (vfli.rgdxp[ifi.ich] = (dxp/2));
//                ifi.xpPr += (dxpPr/2);
//                vfli.rgch[ifi.ich++] = ch;
//                vfli.rgch[ifi.ich] = NULL;
//                goto OnlyDBCSPaste;
//            }
//#endif

/*T-HIROYN add from 3.0*/
            ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
            ifi.xpPr += dxpPr;
            vfli.rgch[ifi.ich++] = ch;
#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
            // BUG 5477: Echen: add NON FA font, LeadByte + 2nd byte checking
            if (((cp + ifi.ich) < cpMac) && IsDBCSLeadByte(ch) &&
                GetFontAssocStatus(vhMDC)) {
#else
            if (IsDBCSLeadByte(ch)) {
#endif  //TAIWAN
                CHAR ch2;

                if (ifi.ich + 1 >= ichMaxLine) {
                    /* It's full.  Do the break without this kanji character. */
#ifndef TEMP_KOREA
                    ifi.ich--;
#endif
                    ifi.ichFetch--; /* We don't want to skip the first byte. */
#ifndef TEMP_KOREA
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
#endif
lblFull2:   /* new label of line full case ( for kanji and kana ) */

                    goto DoBreak;
                    }

                /* Now all is well.  Get the second byte of the kanji
                   character of interest from the current run. */
                /* Get the second byte of the kanji character from
                   the current run.  If we run of the current run,
                   use FetchRgch() to staple us over. */
#ifdef  TEMP_KOREA       /* for variable width, 90.12.26 by sangl */
                vfli.rgch[ifi.ich++] = ch;
#endif
                if (ifi.ichFetch == cch)
                    {
                    if (fTruncated)
                        {
                        cchUsed += cch;
                        pch = vpchFetch + cchUsed;
                        cch = vcchFetch - cchUsed;
                        fTruncated = false;
                        ch2 = vfli.rgch[ifi.ich] = pch[ifi.ichFetch++];
                        }
                    else {
                        int     cchFetch;

                        /* Save parameters needed for the re-fetch. */
                        cpFetchSave = vcpFetch;
                        ichFetchSave = vichFetch;
                        cchUsedSave = cchUsed;
                        cpSeqFetch = vcpFetch + cch + 1;

                        FetchRgch(&cchFetch, &ch2, docNil, cpNil,
                                  vcpFetch + cch + 1, 1);
                        fOddBoundary = true;
                        Assert(cchFetch != 0); /* Better fetched something for us. */

#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
                        if ( !cchFetch )  goto SingleDBCS;
#endif  //TAIWAN

                        /* Now, let's settle related parameters. */
                        pch = &ch2;
                        cch = cchFetch;
                        ifi.ichFetch = 1; /* == cch */
                        cchUsed = 0;

                        vfli.rgch[ifi.ich] = ch2;

#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
                //adjust DBCS char width by the new fetched 2nd byte
                        {
                          int       dxpPr2, dxp2;

                          dxpPr2 = DBCSDxpFromCh(ch, ch2, TRUE);
                          if (fFlmPrinting)   dxp2 = dxpPr2;
                          else                dxp2 = DBCSDxpFromCh(ch, ch2, FALSE);
                          vfli.rgdxp[ifi.ich - 1] += (dxp2 - dxp);
                          ifi.xp += (dxp2 - dxp);
                          ifi.xpPr += (dxpPr2 - dxpPr);
                        }
#endif  //TAIWAN

                        }
                    }
                else
                    {
                    ch2 = vfli.rgch[ifi.ich] = pch[ifi.ichFetch++];
                    }
#ifdef  TEMP_KOREA       /* For variable width, 90.12.26 by sangl */
                { unsigned int wd;
                  wd = (ch<<8) + ch2;
                  dxpPr = DxpFromCh(wd, TRUE);
                  if (fFlmPrinting)    /* if we are printing, then there is */
                                       /* no need to bother with the screen width */
                        dxp = dxpPr;
                  else
                        dxp = DxpFromCh(wd, FALSE);
                  ifi.xp += (vfli.rgdxp[ifi.ich-1] = dxp);
                  ifi.xpPr += dxpPr;
                  vfli.rgdxp[ifi.ich++] = 0;
                }
#else
                vfli.rgdxp[ifi.ich++] = 0;   /* The second byte has 0 width. */
#endif  /* KOREA */
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if (FKanjiSpace(ch, ch2) && vfWordWrap)
#else
                if (FKanjiSpace(ch, ch2))
#endif
                    {
                    fKanjiPrevious = true;
                    fKanjiBreakOppr = false; /* Treat it like a regular space. */
                    dichSpaceAdjust = cchKanji;

                    goto BreakOppr;
                    }
                if (ifi.xpPr > ifi.xpPrRight )  {
                    fKanjiBreakOppr = false; /* Reset the flag */
                    if (FAdmitCh2(ch, ch2) ||
                        (fKanjiPrevious && FOptAdmitCh2(ch, ch2))) {
                        /* We do a line break including this odd character. */
                        /* Make sure non-printables won't start a new line. */
                        /* If we already have a hanging character on the    */
                        /* line, we don't want to treat this character as   */
                        /* a hanging one.                                   */
                        if (!fKanjiHanging )
                            {
                            fKanjiHanging = TRUE;
                            ch = chHyphen;
                            goto BreakOppr;
                            }
                        }

#ifndef JAPAN       // added by Hiraisi (BUG#3542)
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                    if(vfWordWrap)
#endif
                        ifi.ich--;
#endif
                    /* If this run was the result of an odd boundary run,
                       re-fetch. */
                    if (fOddBoundary && ifi.ichFetch == 1 )
                        {
                        FetchCp(doc, cpFetchSave, ichFetchSave,
                                fcmBoth + fcmParseCaps);
                        /* This fetch is guaranteed to result to non-null run. */
                        fOddBoundary = false;
                        pch = vpchFetch;
                        ifi.ichFetch = cch = vcchFetch;
#ifdef JAPAN        // added by Hiraisi (BUG#3542)
                        ifi.ichFetch++;
#endif
                        cchUsed = cchUsedSave;
                        }
#ifndef JAPAN       // added by Hiraisi (BUG#3542)
                    else
                        {
#if defined(JAPAN) || defined(KOREA)  /*t-Yoshio*/

                        if(vfWordWrap)
#endif
                            ifi.ichFetch--;

                        }
#endif
                    /* ifi.xp and ifi.xpPr hasn't changed yet. */
            goto lblFull2;
#ifdef  TEMP_KOREA   /* 90.12.26 : For variable width, 90.12.26 by sangl */
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
#endif  /* KOREA */
                    }

#if defined(JAPAN) || defined(KOREA)                  //  added  26 Jun. 1992  by Hiraisi
                iWidenChar++;
#elif defined(TAIWAN) || defined(PRC)//Daniel/MSTC, 1993/02/25 , for jcBoth
                iWidenChar++;
#endif

                /* Record the line break opportunity while processing
                   it as a regular character at the same time. */
                fKanjiBreakOppr = true;
                fKanjiPrevious  = true;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if(!vfWordWrap)
                    goto DefaultCh;

#endif
                goto BreakOppr;
                }
            else {
#if defined(JAPAN) || defined(KOREA)  /*t-Yoshio add WordWrap flag*/
                if (FKana(ch) && vfWordWrap) {
                    /* If it is a 1-byte kana letter, we want to treat it
                       in the same way as a kanji letter. */
                    if (ifi.xpPr > ifi.xpPrRight) {
                        fKanjiBreakOppr = false; /* Reset the flag */
                        if (FAdmitCh1(ch)) {
                            /* Make sure non-printables won't start a new line. */
                            /* If we already have a hanging character on the    */
                            /* line, we don't want to treat this character as   */
                            /* a hanging one.                                   */
                            if (!fKanjiHanging) {
                                fKanjiHanging = TRUE;
                                ch = chHyphen;
                                goto BreakOppr;
                                }
                            }
                        goto lblFull2;
                        }

#if defined(JAPAN) || defined(KOREA)                  //  added  22 Jun. 1992  by Hiraisi

                    iWidenChar++;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25 , for jcBoth
                    iWidenChar++;
#endif

                    fKanjiPrevious  = true;
                    fKanjiBreakOppr = true;
                    /* Go through the break opprotunity processing, then the
                       default character processing. */
                    goto BreakOppr;
                    }
        else {
#endif     /* JAPAN */
#ifdef  TEMP_KOREA       /* For variable width by sangl 90.12.26 */
                    if (ch < chFmiMin || ch >= chFmiMax || (dxpPr =
                        vfmiPrint.mpchdxp[ch]) == dxpNil)
                          {
                          dxpPr = DxpFromCh(ch, TRUE);
                          }
                    if (fFlmPrinting)
                        {
                        /* If we are printing, then there is no need to bother
                           with the screen width */
                        dxp = dxpPr;
                        }
                    else if (ch < chFmiMin || ch >= chFmiMax ||
                                (dxp = vfmiScreen.mpchdxp[ch]) == dxpNil)
                                dxp = dxpFromCh(ch, FALSE);

                    ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
                    ifi.xpPr += dxpPr;
                    vfli.rgch[ifi.ich++] = ch;
#endif  /* KOREA */

#if defined(TAIWAN) || defined(PRC)  //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
SingleDBCS:
#endif  //TAIWAN

                    if (fKanjiPrevious && FOptAdmitCh1(ch)) {
                        fKanjiPrevious = false;
                        if (ifi.xpPr > ifi.xpPrRight) {
                            fKanjiBreakOppr = false;
                            /* If we already have a hanging character past the
                               margin, we don't want to treat this as a
                               hanging character. */
                            if (!fKanjiHanging) {
                                fKanjiHanging = true;
                                ch = chHyphen;
                                goto BreakOppr;
                                }
                            }
                        else {
                            /* We can treat this character as though a Kanji
                               punctuation, as far as line breaking is
                               is concerned. */
                            fKanjiBreakOppr = true;
                            goto BreakOppr;
                            }
                        }
                    else {
                        /* Just go on with a regular English formatting. */
                        fKanjiBreakOppr = false;
                        fKanjiPrevious = false;
                        }
                    }
#if defined(JAPAN) || defined(KOREA)
        }
#endif

#else   /* DBCS */
            ifi.xp += (vfli.rgdxp[ifi.ich] = dxp);
            ifi.xpPr += dxpPr;
            vfli.rgch[ifi.ich++] = ch;
#endif

#if defined (TAIWAN)
OnlyDBCSPaste:
#endif
             /* special case "normal characters" above hyphen */
            if (ch > chHyphen)
                goto DefaultCh;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            /*Non Word wrap Not Hyphen break*/
            if(!vfWordWrap) {
                if (ch == chHyphen)
                    goto DefaultCh;
            }
#endif
            switch (ch)
                {

#ifdef CRLF
                case chReturn:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;
                    continue;
#endif /* CRLF */

                case chNRHFile:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    ichpNRH = ichpFormat - 1;
#ifdef DFLI
                    {
                    char rgch[100];

                    wsprintf(rgch,"  OptHyph: width==%d, xpPr==%d/%d\n\r",
                        DxpFromCh(chHyphen,true), ifi.xpPr,ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif
                    if (ifi.xpPr + DxpFromCh(chHyphen, true) > ifi.xpPrRight)
                        {
                        /* Won't fit, force a break */
                        goto DoBreak;
                        }

#ifdef CASHMERE
                    else if (fVisiMode)
                        {
                        /* Treat just like a normal hyphen */
                        ch = chHyphen;
                        goto NormChar;
                        }
#endif /* CASHMERE */

                    xpPrev = ifi.xp;
                    vfli.rgch[ifi.ich] = chTab;
                    goto Tab0;

                case chSect:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    vfli.dypFont = vfli.dypLine = (dypAscentMac + (vfli.dypBase
                      = dypDescentMac));
                    vfli.cpMac = vcpFetch + ifi.ichFetch;
                    if (FFirstIch(ifi.ich))
                        {
                        /* Beginning of line; return a splat */
                        vfli.fSplat = true;

                        if (!fFlmPrinting)
                            {

#ifdef CASHMERE
                            int chT = vfli.cpMac == vcpLimSectCache ?
                              chSectSplat : chSplat;
#else /* not CASHMERE */
                            int chT = chSplat;
#endif /* not CASHMERE */

                            int dxpCh = DxpFromCh(chT, false);

                            /* Set the width of the splat to be about 8.5" */
                            int cch = min((dxpLogInch * 17 / 2) / dxpCh,
                              ichMaxLine - 32);

                            bltbc(&vfli.rgch[ifi.ich], chT, cch);
                            bltc(&vfli.rgdxp[ifi.ich], dxpCh, cch);
                            vfli.ichMac = cch + ifi.ich;
                            vfli.xpReal = LOWORD(GetTextExtent(vhMDC,
                              (LPSTR)vfli.rgch, cch));
                            vfli.xpLeft = 0;
                            }
                        else
                            {
                            vfli.ichMac = 0;
                            }
                        goto EndFormat;
                        }

                    /* The section character is in the middle of a line, the
                    line will terminate in front of the character. */
                    /* vfSplatNext = TRUE; No longer used*/
                    vfli.cpMac += cchUsed - 1;
                    vfli.dcpDepend = 1;
                    if (!ifi.fPrevSpace)
                        {
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    goto JustBreak;

                case chTab:
                    /* Undo damage */
                    ifi.ich--;
                    ifi.xp -= dxp;
                    ifi.xpPr -= dxpPr;

                    if (ifi.xpPr < ifi.xpPrRight)
                        {
                        register struct CHP *pchp;
                        unsigned xaPr;
                        unsigned xaTab;

                        if (!ifi.fPrevSpace)
                            {
                            /* Remember number of spaces to left and number of
                            real chars in line for justification */
                            ifi.cBreak = ifi.cchSpace;
                            vfli.ichReal = ifi.ich;
                            ifi.xpReal =  ifi.xp;
                            }

                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        xpPrev = ifi.xp;

                        /* Now get info about this tab */
                        xaPr = MultDiv(ifi.xpPr, dxaPrPage, dxpPrPage);
                        while ((xaTab = ptbd->dxa) != 0)
                            {
#ifdef DBCS             /* was in JAPAN */
                            if (xaTab >= xaRight)
#else
                            if (xaTab > xaRight)
#endif
                                {
                                /* Don't let tabs extend past right margin. */
#ifdef DBCS             /* was in JAPAN */
                break; // Stop to examin next tab-stop
#else
                                xaTab = xaRight;
#endif
                                }

                            if (xaTab >= xaPr)
                                {
                                /* Use tab stop information */

#ifdef CASHMERE
                                ifi.tlc = ptbd->tlc;
#endif /* CASHMERE */

                                ifi.jc = jcTabMin + (ptbd++)->jc;

#ifdef ENABLE /* we do the mapping in HgtbdCreate */
                                if (ifi.jc != jcTabDecimal)
                                    {
                                    ifi.jc = jcTabLeft;
                                    }
#endif
                                goto TabFound;
                                }
                            ptbd++;
                            }

                        /* Out of set tabs; go to next nth column */
                        xaTab = (xaPr / (vzaTabDflt) + 1) * (vzaTabDflt);

#ifdef CASHMERE
                        ifi.tlc = tlcWhite;
#endif /* CASHMERE */

                        ifi.jc = jcTabLeft;

TabFound:
                        xpTab = imax(MultDiv(xaTab, dxpFormat, dxaFormat),
                          ifi.xp);

                        /* Do left-justified tabs immediately */
                        if (ifi.jc == jcTabLeft)
                            {
                            ifi.xp = xpTab;
                            ifi.xpPr = MultDiv(xaTab, dxpPrPage, dxaPrPage);
                            }
                        ifi.xpLeft = ifi.xp;
                        ifi.ichLeft = ifi.ich;
                        ifi.cchSpace = 0;
                        ifi.chBreak = 0;
#if defined(JAPAN) || defined(KOREA)                  //  added  02 Jul. 1992  by Hiraisi
                        iWidenChar=0;
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25, for jcBoth
                        iWidenChar=0;
#endif

Tab0:
                        ifi.fPrevSpace = false;
                        vfli.ichMac = ifi.ich;
                        vfli.xpReal = ifi.xp;
                        vfli.dypLine = ifi.dypLineSize;
                        vfli.dypBase = dypDescentMac;
                        vfli.dypFont = dypAscentMac + dypDescentMac;

                        if (ifi.ichFetch != 1 && (ichpFormat != ichpMacFormat
                          || FGrowFormatHeap()))
                            {
                            /* Probably in real trouble if FGrowFormatHeap fails
                            at this point */
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            if (ichpFormat > 0)
                                {
                                /* Finish off previous run */
                                pchp->ichRun = ifi.ichPrev;
                                pchp->cchRun = ifi.ich - ifi.ichPrev;
                                }

                            blt(&chpLocal, ++pchp, cwCHP);
                            ichpFormat++;
                            }
                        else
                            {
                            pchp = &(**vhgchpFormat)[ichpFormat - 1];
                            }
                        pchp->ichRun = ifi.ich;
                        pchp->cchRun = ichMaxLine;

#ifdef CASHMERE
                        pchp->chLeader = mptlcch[ifi.tlc];
#endif /* CASHMERE */

                        vfli.rgdxp[ifi.ichPrev = ifi.ich++] = ifi.xp - xpPrev;

                        if (ch != chTab)
                            {
                            /* This character is a non-required hyphen. */
                            Dfli(CommSz("ch is really OptHyph "));
                            goto BreakOppr;
                            }

                        continue;
                        }

                    else
                        {
                        ch = chNBSFile;
                        goto NormChar;
                        }

                case chHyphen:
                    if (ifi.xpPr > ifi.xpPrRight)
                        {
                        goto DoBreak;
                        }

BreakOppr:
                Dfli(CommSz(" BKOPPR\n\r"));
                /*    this case never used in switch - always goto here */
                /* case chSpace:  */
                    if (ifi.ich >= ichMaxLine)
                        {
                        Dfli(CommSzNum("  Unbroken, ich>ichMaxLine\n\r"));
                        goto Unbroken;
                        }

                case chEol:
                case chNewLine:
                    ifi.chBreak = ch;
                    vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch;
                    vfli.xpReal = ifi.xp;
                    vfli.ichMac = ifi.ich;
                    vfli.dypLine = ifi.dypLineSize;
                    vfli.dypFont = dypAscentMac + (vfli.dypBase =
                      dypDescentMac);
                    Dfli(CommSzNumNum("    vfli.xpReal, ichMac ",vfli.xpReal,vfli.ichMac));

#ifdef  DBCS                /* was in JAPAN */
                    /* We recorded the kanji break opportunity, go default
                       character processing. */
                    if (fKanjiBreakOppr)
                        {
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        goto DefaultCh;
                        }
#endif
                    if (ch == chHyphen || ch == chNRHFile)
                        {
                        Dfli(CommSz("    chHyph/OptHyph catch \n\r"));
                        ifi.cBreak = ifi.cchSpace;
                        vfli.ichReal = ifi.ich;
                        vfli.xpReal = ifi.xpReal = ifi.xp;
                        }
                    else
                        {
                        if (!ifi.fPrevSpace)
                            {
                            Dfli(CommSz("!fPrevSpace \n\r"));
                            ifi.cBreak = ifi.cchSpace;
#ifdef DBCS         /* was in JAPAN */
                            vfli.ichReal = ifi.ich - dichSpaceAdjust;
                            dichSpaceAdjust = 1;
#else
                            vfli.ichReal = ifi.ich - 1;
#endif
                            ifi.xpReal = (vfli.xpReal = ifi.xp) - dxp;
                            }
                        if (ch == chEol || ch == chNewLine)
                            {

#ifdef CASHMERE
                            if (hfntb != 0 && vfli.cpMac ==
                              (**hfntb).rgfnd[0].cpFtn)
                                {
                                /* End of footnote */
                                if (!fFlmPrinting)
                                    {
                                    vfli.rgch[ifi.ich - 1] = chEMark;
                                    vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                      DxpFromCh(chEMark, false)) - dxp;
                                    vfli.ichReal++;     /* show this guy */
                                    }
                                }
                            else
#endif /* CASHMERE */
                                {

#ifdef CASHMERE
                                int chT = fVisiMode ? ChVisible(ch) : chSpace;
#else /* not CASHMERE */
                                int chT = chSpace;
#endif /* not CASHMERE */

                                int dxpNew = DxpFromCh(chT, fFlmPrinting);

                                vfli.rgch[ifi.ich - 1] = chT;
                                vfli.rgdxp[ifi.ich - 1] = dxpNew;

                                vfli.xpReal += (vfli.rgdxp[ifi.ich - 1] =
                                    dxpNew) - dxp;


                                if (!ifi.fPrevSpace)
                                    {
                                    vfli.xpReal += dxpNew - dxp;
#ifdef CASHMERE
                                    vfli.ichReal =
                                         fVisiMode ? ifi.ich : ifi.ich - 1;
#else /* not CASHMERE */
                                    vfli.ichReal = ifi.ich - 1;
#endif /* not CASHMERE */
                                    }
                                }


                            if (ch == chEol)
                                {
JustEol:
                                if (fFlmPrinting)
                                    {
                                    vfli.ichMac = vfli.ichReal;
                                    }
                                if (ifi.jc != jcTabLeft)
                                    {
                                    /* Handle last tab's text */
                                    Justify(&ifi, xpTab, flm);
                                    }
                                else if ((ifi.jc = ppap->jc) != jcBoth &&
                                  ifi.jc != jcLeft)
                                    {
                                    /* Do line justification */
                                    Justify(&ifi, ifi.xpRight, flm);
                                    }
                                vfli.xpRight = ifi.xpRight;
                                goto EndFormat;
                                }
                            else
                                {
                                /* Handle a line break */
                                goto JustBreak;
                                }
                            }
                        ++ifi.cchSpace;
                        ifi.fPrevSpace = true;
                        }
                    break;

DefaultCh:

                default:

#ifdef DFLI
                    {
                    char rgch[100];
                    wsprintf(rgch,"  DefaultCh: %c, xp==%d/%d, xpPr==%d/%d\n\r",
                        ch, ifi.xp, ifi.xpRight, ifi.xpPr, ifi.xpPrRight);
                    CommSz(rgch);
                    }
#endif /* ifdef DFLI */
#ifdef DBCS         /* was in JAPAN */
                    /* Reset the flag for the next character. */
                    fKanjiBreakOppr = false;
#endif

                    if (ifi.xpPr > ifi.xpPrRight)
DoBreak:
                        {
                        Dfli(CommSz("    BREAK!\n\r"));
                        if (ifi.chBreak == 0)
Unbroken:
                            {
                            /* Admit first character to the line, even if margin
                            is crossed.  First character at ifi.ich - 1 may be
                            preceded by 0 width characters. */
#ifdef DBCS
                            if (IsDBCSLeadByte(ch))
                                {
                                if (FFirstIch(ifi.ich-2) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-2;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 2;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
#ifdef KKBUGFIX /*t-Yoshio*/
                                vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
#else
                                vfli.xpReal = ifi.xpReal = ifi.xp - (dxp * 2);
#endif
                                }
                            else
                                {
                                if (FFirstIch(ifi.ich-1) && ifi.ich<ichMaxLine)
                                    goto PChar;
                                vfli.cpMac = vcpFetch+cchUsed+ifi.ichFetch-1;
                                vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                                vfli.dypLine = ifi.dypLineSize;
                                vfli.dypFont = dypAscentMac + (vfli.dypBase =
                                  dypDescentMac);
                                vfli.dcpDepend = 1;
                                vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
                                }
#else
                            if (FFirstIch(ifi.ich - 1) && ifi.ich < ichMaxLine)
                                {
                                goto PChar;
                                }
                            vfli.cpMac = vcpFetch + cchUsed + ifi.ichFetch - 1;
                            vfli.ichReal = vfli.ichMac = ifi.ich - 1;
                            vfli.dypLine = ifi.dypLineSize;
                            vfli.dypFont = dypAscentMac + (vfli.dypBase =
                              dypDescentMac);
                            vfli.dcpDepend = 1;
                            vfli.xpReal = ifi.xpReal = ifi.xp - dxp;
#endif
                            goto DoJustify;
                            }

                        vfli.dcpDepend = vcpFetch + ifi.ichFetch - vfli.cpMac;
JustBreak:
                        if (ifi.chBreak == chNRHFile)
                            {
                            /* Append a non-required hyphen to the end of the
                            line. (Replace zero length tab previously
                            inserted)  */

                            Dfli(CommSz("    Breaking line at OptHyphen\n\r"));
                            ifi.xpReal += (vfli.rgdxp[vfli.ichReal - 1] =
                              DxpFromCh(chHyphen, fFlmPrinting));
                            vfli.xpRight = vfli.xpReal = ifi.xpReal;
                            vfli.rgch[vfli.ichReal - 1] = chHyphen;
                            vfli.ichMac = vfli.ichReal;
                            if (ichpNRH < ichpFormat - 1)
                                {
                                register struct CHP *pchp =
                                  &(**vhgchpFormat)[ichpNRH];

                                pchp->cchRun++;
                                if (pchp->ichRun >= vfli.ichMac)
                                    {
                                    pchp->ichRun = vfli.ichMac - 1;
                                    }
                                }
                            }

                        if (fFlmPrinting)
                            {
                            vfli.ichMac = vfli.ichReal;
                            }
                        if (ifi.jc != jcTabLeft)
                            {
                            Justify(&ifi, xpTab, flm);
                            }
                        else
                            {
DoJustify:
                            if ((ifi.jc = ppap->jc) != jcLeft)
                                {
                                Dfli(CommSzNum("    DoJustify: xpRight ",ifi.xpRight));
                                Justify(&ifi, ifi.xpRight, flm);
                                }
                            }
                        vfli.xpRight = ifi.xpRight;
EndFormat:
                        vfli.ichLastTab = ifi.ichLeft;

#ifdef CASHMERE
                        if (vfli.cpMac == vcpLimParaCache)
                            {
                            vfli.dypAfter = vpapAbs.dyaAfter / DyaPerPixFormat;
                            vfli.dypLine += vfli.dypAfter;
                            vfli.dypBase += vfli.dypAfter;
                            }
#endif /* CASHMERE */

                        Scribble(5, ' ');
                        return;
                        }
                    else
                        {
PChar:
                        /* A printing character */
                        ifi.fPrevSpace = false;
                        }
                    break;

                }       /* Switch */
#ifdef DBCS             /* was in KKBUGFIX */
//
// [yutakan:04/02/91]
//
                if(vfOutOfMemory == TRUE)
                    return;
#endif
            }
        }       /* for ( ; ; ) */

    Scribble(5, ' ');
    }


/* J U S T I F Y */
near Justify(pifi, xpTab, flm)
struct IFI *pifi;
unsigned xpTab;
int flm;
    {
    int dxp;
    int ichT;
    int xpLeft;

//  justified paragraph is restored in Windows 3.1J          by Hiraisi
//#ifdef JAPAN
//    /* In the Kanji Write, there is no justified paragraph. */
//    if (pifi->jc == jcBoth)
//        {
//        /* Assert(FALSE); */
//        pifi->jc = jcLeft;
//      dxp = 0;                /* by yutakan / 08/03/91 */
//        }
//#endif /* ifdef JAPAN */


    xpLeft = pifi->xpLeft;
    switch (pifi->jc)
        {
        CHAR *pch;
        unsigned *pdxp;

#ifdef CASHMERE
        case jcTabLeft:
        case jcLeft:
            return;

        case jcTabRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcTabCenter:
            dxp = (xpTab - xpLeft) - ((pifi->xpReal - xpLeft + 1) >> 1);
            break;
#endif /* CASHMERE */

        case jcTabDecimal:
            dxp = xpTab - xpLeft;
            for (ichT = pifi->ichLeft + 1; ichT < vfli.ichReal &&
              vfli.rgch[ichT] != vchDecimal; ichT++)
                {
                dxp -= vfli.rgdxp[ichT];
                }
            break;

        case jcCenter:
            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                return;
                }
            dxp = dxp >> 1;
            break;

        case jcRight:
            dxp = xpTab - pifi->xpReal;
            break;

        case jcBoth:
//#if !defined(JAPAN)                  //  added  22 Jun. 1992  by Hiraisi
#if !defined(JAPAN) && !defined(TAIWAN) && !defined(PRC) // Daniel/MSTC, 1993/02/25, for jcBoth

            if (pifi->cBreak == 0)
                {
                /* Ragged edge forced */
                return;
                }

#endif

            if ((dxp = xpTab - pifi->xpReal) <= 0)
                {
                /* There is nothing to do. */
                return;
                }

//#if !defined(JAPAN)                  //  added  22 Jun. 1992  by Hiraisi
#if !defined(JAPAN) && !defined(TAIWAN) && !defined(PRC)//Daniel/MSTC, 1992,02,25, for jcBoth
            pifi->xp += dxp;
            vfli.xpReal += dxp;
            vfli.dxpExtra = dxp / pifi->cBreak;
#endif

            /* Rounding becomes a non-existant issue due to brilliant
            re-thinking.
                "What a piece of work is man
                How noble in reason
                In form and movement,
                how abject and admirable..."

                        Bill "Shake" Spear [describing Sand Word] */
                {
#ifdef JAPAN                   //  added  22 Jun. 1992  by Hiraisi
          /*
           *  In Japan, we examine the buffer from the beginning of the line.
           *  We find some NULLs in the buffer when a char is deleted,
           * but we can ignore all of them.
          */
                register CHAR *pch;
                register int *pdxp;
                CHAR *endPt;
                int dxpT = dxp;
                int cxpQuotient;
                int cNonWideSpaces;
                int ichLeft;

                if( pifi->ichLeft >= 0 )     /* including some tabs in line */
                    ichLeft = pifi->ichLeft;
                else
                    ichLeft = 0;
                pch = &vfli.rgch[ichLeft];
                pdxp = &vfli.rgdxp[ichLeft];
                endPt = &vfli.rgch[vfli.ichReal];

                if( vfWordWrap ){       /* Word Wrap ON */
                /*
                 *  We examine whether there is no break between a non-Japanese
                 * char and a following Japanese char. The reason is that we
                 * need to widen the non-Japanese char (except tab and space)
                 * if we can find no break there.
                */
                    for( ; pch<endPt ; ){
                        if( IsDBCSLeadByte( *pch ) ){
                            pch+=2;
                        }
                        else{
                            if( *pch != chSpace && *pch != chTab &&
                                !FKana( *pch ) && *pch != NULL ){
                                CHAR *ptr;

                                for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
                                if( IsDBCSLeadByte(*ptr) ){
                                    iWidenChar++;
                                    pch+=2;
                                }
                                else{
                                    if( FKana(*ptr) ){
                                        iWidenChar++;
                                        pch++;
                                    }
                                }
                            }
                            pch++;
                        }
                    }
                    /*
                     *  We decrease iWidenChar if last char of the current line
                     * is Japanese, because it needs not to be widened.
                    */
                    if( *(endPt-1) == NULL ){
                        for( endPt-- ; *endPt==NULL ; endPt-- );
                        endPt++;
                    }
                    if( IsDBCSLeadByte(*(endPt-2)) ){
                        iWidenChar--;
                    }
                    else{
                        if( FKana(*(endPt-1)) )
                            iWidenChar--;
                    }
                    iWidenChar += pifi->cBreak;
                }
                else{                   /* Word Wrap OFF */
                    /*  We widen all chars except last char in the line.  */
                    int iDBCS, ichReal;
                    for( iDBCS=0, ichReal=vfli.ichReal ; pch<endPt ; pch++ ){
                        if( IsDBCSLeadByte( *pch ) ){
                            pch++;
                            iDBCS++;
                        }
                        else{
                            if( *pch == NULL )
                                ichReal--;
                        }
                    }
                    iWidenChar = ichReal - ichLeft - iDBCS - 1;
                }
                if( iWidenChar == 0 )
                    return;

                pifi->xp += dxp;
                vfli.xpReal += dxp;
                vfli.dxpExtra = dxp / iWidenChar;
                cNonWideSpaces = iWidenChar - (dxp % iWidenChar);
                cxpQuotient = vfli.dxpExtra;
                iNonWideSpaces = cNonWideSpaces;

                vfli.ichFirstWide = 0;
                vfli.fAdjSpace = fTrue;

                pch = &vfli.rgch[ichLeft];    /* Reset pch */
                for( ; ; ){
                   if( IsDBCSLeadByte(*pch) ){
                      if( vfli.ichFirstWide == 0 ){
                         int *pdxpT = pdxp;
                         vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                      }
                      *pdxp += cxpQuotient;
                      if( --iWidenChar == 0 )
                         return;
                      if( --cNonWideSpaces == 0 )
                         cxpQuotient++;
                      pch++;
                      pdxp++;
                   }
                   else{
                      if( vfWordWrap ){           /* Word Wrap ON */
                         if( *pch == chSpace || FKana(*pch) ){
                            if( vfli.ichFirstWide == 0 ){
                               int *pdxpT = pdxp;
                               vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            }
                            *pdxp += cxpQuotient;
                            if( --iWidenChar == 0 )
                               return;
                            if( --cNonWideSpaces == 0 )
                                cxpQuotient++;
                         }
                         else{
                            if( *pch != chTab && *pch != NULL ){
                               CHAR *ptr;

                               /*
                                *  We examine whether the following char of
                                * non-Japanese char is Japanese.
                               */
                               for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
                               if( IsDBCSLeadByte(*ptr) || FKana(*ptr) ){
                                  if( vfli.ichFirstWide == 0 ){
                                     int *pdxpT = pdxp;
                                     vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                  }
                                  *pdxp += cxpQuotient;
                                  if( --iWidenChar == 0 )
                                     return;
                                  if( --cNonWideSpaces == 0 )
                                      cxpQuotient++;
                               }
                            }
                         }
                      }
                      else{                       /* Word Wrap OFF */
                         if( *pch != NULL ){
                            if( vfli.ichFirstWide == 0 ){
                               int *pdxpT = pdxp;
                               vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            }
                            *pdxp += cxpQuotient;
                            if( --iWidenChar == 0 )
                               return;
                            if( --cNonWideSpaces == 0 )
                               cxpQuotient++;
                         }
                      }
                   }
                   pch++;
                   pdxp++;
                }

#elif defined(TAIWAN) || defined(PRC)//Daniel/MSTC, 1992/02/25, for jcBoth
          /*
           *  In Japan, we examine the buffer from the beginning of the line.
           *  We find some NULLs in the buffer when a char is deleted,
           * but we can ignore all of them.
          */
      register CHAR *pch;
      register int *pdxp;
      CHAR *endPt;
      int dxpT = dxp;
      int cxpQuotient;
      int cNonWideSpaces;
      int ichLeft;

      if( pifi->ichLeft >= 0 )     /* including some tabs in line */
          ichLeft = pifi->ichLeft;
      else ichLeft = 0;

      pch = &vfli.rgch[ichLeft];
      pdxp = &vfli.rgdxp[ichLeft];
      endPt = &vfli.rgch[vfli.ichReal];

//      if( vfWordWrap ){       /* Word Wrap ON */
      /*
       *  We examine whether there is no break between a non-Japanese
       * char and a following Japanese char. The reason is that we
       * need to widen the non-Japanese char (except tab and space)
       * if we can find no break there.
      */
    for( ; pch<endPt ; )
                {
      if( IsDBCSLeadByte( *pch ) )  pch+=2;
      else
                        {
         if( *pch != chSpace && *pch != chTab && !FKana( *pch ) && *pch != NULL )
                                { CHAR *ptr;
            for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
            if( IsDBCSLeadByte(*ptr) )
                                        {
                                        iWidenChar++;
               pch+=2;
               }
                 else
                                        {
               if( FKana(*ptr) )
                                                {
                  iWidenChar++;
                  pch++;
                  }
               }
            }
            pch++;
         }
      }// for
      /*
       *  We decrease iWidenChar if last char of the current line
       * is Japanese, because it needs not to be widened.
       */
    if( *(endPt-1) == NULL )
                {
      for( endPt-- ; *endPt==NULL ; endPt-- );
      endPt++;
      }
    if( IsDBCSLeadByte(*(endPt-2)) ) iWidenChar--;
    else
                {
      if( FKana(*(endPt-1)) ) iWidenChar--;
      }
    iWidenChar += pifi->cBreak;
//      } // vfWordWrap

    if( iWidenChar == 0 )
                 return;

      pifi->xp += dxp;
      vfli.xpReal += dxp;
      vfli.dxpExtra = dxp / iWidenChar;
      cNonWideSpaces = iWidenChar - (dxp % iWidenChar);
      cxpQuotient = vfli.dxpExtra;
      iNonWideSpaces = cNonWideSpaces;

      vfli.ichFirstWide = 0;
      vfli.fAdjSpace = fTrue;

      pch = &vfli.rgch[ichLeft];    /* Reset pch */
      for( ; ; )
                        {
         if( IsDBCSLeadByte(*pch) )
                                {
            if( vfli.ichFirstWide == 0 )
                                        {
               int *pdxpT = pdxp;
               vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                }
            *pdxp += cxpQuotient;
            if( --iWidenChar == 0 )  return;
            if( --cNonWideSpaces == 0 ) cxpQuotient++;
            pch++;
            pdxp++;
                }
         else
                                {
           // if( vfWordWrap )
                                 if( 1 )
                                        {           /* Word Wrap ON */
               if( *pch == chSpace || FKana(*pch) )
                                                {
                  if( vfli.ichFirstWide == 0 )
                                                        {
                     int *pdxpT = pdxp;
                     vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                        }
                  *pdxp += cxpQuotient;
                  if( --iWidenChar == 0 ) return;
                  if( --cNonWideSpaces == 0 ) cxpQuotient++;
                }
               else
                                                {
                  if( *pch != chTab && *pch != NULL )
                                                        {
                     CHAR *ptr;

                     /*
                      *  We examine whether the following char of
                      * non-Japanese char is Japanese.
                     */
                     for( ptr = pch+1 ; *ptr == NULL ; ptr++ );
                     if( IsDBCSLeadByte(*ptr) || FKana(*ptr) )
                                                                {
                        if( vfli.ichFirstWide == 0 )
                                                                        {
                           int *pdxpT = pdxp;
                           vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                }
                        *pdxp += cxpQuotient;
                        if( --iWidenChar == 0 ) return;
                        if( --cNonWideSpaces == 0 ) cxpQuotient++;
                        }
                        }
                } //else : ==chSpace || FKana()
                    } //Word Wrap On
                 }
         pch++;
         pdxp++;
              }//for
#else     // not JAPAN
                register CHAR *pch = &vfli.rgch[vfli.ichReal];
                register int *pdxp = &vfli.rgdxp[vfli.ichReal];
                int dxpT = dxp;
                int cBreak = pifi->cBreak;
                int cxpQuotient = (dxpT / cBreak) + 1;
                int cWideSpaces = dxpT % cBreak;

                vfli.fAdjSpace = fTrue;

                for ( ; ; )
                    {
                    /* Widen blanks */
                    --pch;
                    --pdxp;
#if defined(KOREA)
                    if ((*pch == chSpace) || FKanjiSpace(*pch, *(pch-1)))
                        {
                        if (FKanjiSpace(*pch, *(pch-1)))
                            --pch;
#else
                    if (*pch == chSpace)
                        {
#endif
                        if (cWideSpaces-- == 0)
                            {
                            int *pdxpT = pdxp + 1;

                            while (*pdxpT == 0)
                                {
                                pdxpT++;
                                }
                            vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                            cxpQuotient--;
                            }
                        *pdxp += cxpQuotient;
                        if ((dxpT -= cxpQuotient) <= 0)
                            {
                            if (pifi->cBreak > 1)
                                {
                                int *pdxpT = pdxp + 1;

                                while (*pdxpT == 0)
                                    {
                                    pdxpT++;
                                    }
                                vfli.ichFirstWide = pdxpT - vfli.rgdxp;
                                }
                            return;
                            }
                        pifi->cBreak--;
                        }
                    }
#endif    // JAPAN
                }
        }       /* Switch */

    if (dxp <= 0)
        {
        /* Nothing to do */
        return;
        }

    pifi->xp += dxp;

    if (flm & flmPrinting)
        {
        pifi->xpPr += dxp;
        }
    else
        {
        /* This statememt might introduce rounding errors in pifi->xpPr, but
        with luck, they will be small. */
        pifi->xpPr += MultDiv(MultDiv(dxp, czaInch, dxpLogInch), dxpPrPage,
          dxaPrPage);
        }

    if (pifi->ichLeft < 0)
        {
        /* Normal justification */
        vfli.xpLeft += dxp;
        }
    else
        {
        /* Tab justification */
        vfli.rgdxp[pifi->ichLeft] += dxp;
        }
    vfli.xpReal += dxp;
    }


/* F  G R O W  F O R M A T  H E A P */
int near FGrowFormatHeap()
    {
    /* Grow vhgchpFormat by 20% */
    int cchpIncr = ichpMacFormat / 5 + 1;

#ifdef WINHEAP
    if (!LocalReAlloc((HANDLE)vhgchpFormat, (ichpMacFormat + cchpIncr) * cchCHP,
      NONZEROLHND))
#else /* not WINHEAP */
    if (!FChngSizeH(vhgchpFormat, (ichpMacFormat + cchpIncr) * cwCHP, false))
#endif /* not WINHEAP */

        {
        /* Sorry, charlie */
        return false;
        }
    ichpMacFormat += cchpIncr;
    return true;
    }


/* #define DBEMG */
/* D X P  F R O M  C H */
#ifdef DBCS
/* DxpFromCh() assumes that ch passed is the first byte of a DBCS character
   if it is a part of such character. */
#endif
int DxpFromCh(ch, fPrinter)
int ch;
int fPrinter;
    {
    int               *pdxp; // changed to int (7.23.91) v-dougk
    int               dxpDummy; // changed to int (7.23.91) v-dougk

    extern int        dxpLogCh;
    extern struct FCE *vpfceScreen;

    /* If the width is not in the width table, then get it. */
    if (ch < chFmiMin)
        {
        switch (ch)
            {
        case chTab:
        case chEol:
        case chReturn:
        case chSect:
        case chNewLine:
        case chNRHFile:
            /* the width for these characters aren't really important */
        pdxp = (CHAR *)(fPrinter ? &vfmiPrint.dxpSpace : &vfmiScreen.dxpSpace);
            break;
        default:
            pdxp = &dxpDummy;
            *pdxp = dxpNil;
            break;
            }
        }
    else if (ch >= chFmiMax)
        {
        /* outside the range we hold in our table - kludge it */
        pdxp = &dxpDummy;
        *pdxp = dxpNil;
        }
    else
        {
        /* inside our table */
        pdxp = (fPrinter ? vfmiPrint.mpchdxp : vfmiScreen.mpchdxp) + ch;
        }

#ifdef DBCS
#ifdef KOREA
    if (*pdxp == dxpNil && IsDBCSLeadByte(HIBYTE(ch)) )
#else
    if (*pdxp == dxpNil && IsDBCSLeadByte(ch) )
#endif
        {
        int dxp;
#else
    if (*pdxp == dxpNil)
        {
        int dxp;
#endif

#ifdef DBCS
        struct FMI *pfmi;
#if 0 /*T-HIROYN*/
        int        rgchT[cchDBCS]; // changed to int (7.23.91) v-dougk
#endif
        CHAR       rgchT[cchDBCS]; // changed to int (7.23.91) v-dougk
        int        dxpT;
        int        dxpDBCS;

        pfmi = fPrinter ? (&vfmiPrint) : (&vfmiScreen);
        Assert(pfmi->bDummy == dxpNil);
        if (pfmi->dxpDBCS == dxpNil)
            {
#ifdef  KOREA   /* 90.12.26  For variable width by sangl */
            rgchT[0] = HIBYTE(ch);
            rgchT[1] = LOBYTE(ch);
#else
            /* Get the width from GDI. */
            rgchT[0] = rgchT[1] = ch;
#endif
            dxpDBCS = (fPrinter ?
                            LOWORD(GetTextExtent(vhDCPrinter,
                                                 (LPSTR) rgchT, cchDBCS)) :
                            LOWORD(GetTextExtent(vhMDC,
                                                 (LPSTR) rgchT, cchDBCS)));
#ifndef  TEMP_KOREA   /* For variable width by sangl 90.12.26 */
            /* Store in fmi, if it fits. */
            if (0 <= dxpDBCS && dxpDBCS < dxpNil)
#if defined(JAPAN) || defined(KOREA) || defined(TAIWAN) || defined(PRC)    //Win3.1 BYTE-->WORD
                pfmi->dxpDBCS = (WORD) dxpDBCS;
#else
                pfmi->dxpDBCS = (BYTE) dxpDBCS;
#endif
#endif
            return (dxpDBCS - pfmi->dxpOverhang);
            }
        else
            return (pfmi->dxpDBCS - pfmi->dxpOverhang);
        }
#if defined(KOREA)
    else if (*pdxp == dxpNil)  {
#else
    else {
#endif
        int dxp;
#endif /* DBCS */
        /* get width from GDI */
        dxp = fPrinter ? LOWORD(GetTextExtent(vhDCPrinter, (LPSTR)&ch, 1)) -
          vfmiPrint.dxpOverhang : LOWORD(GetTextExtent(vhMDC, (LPSTR)&ch, 1)) -
          vfmiScreen.dxpOverhang;
#ifdef DBEMG
            CommSzNum("Get this.... ", dxp);
#endif
        //(7.24.91) v-dougk if (dxp >= 0 && dxp < dxpNil)
            {
            /* only store dxp's that fit in a byte */
            *pdxp = dxp;
            }

#ifdef DBEMG
        {
        char szT[10];
        CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
        if (ch == 0x0D) {
            szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
            }
        else if (ch == 0x0A) {
            szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
            }
        else if (32 <= ch && ch <= 126) {
            szT[0] = ch; szT[1] ='\0';
            }
        else if (FKanji1(ch)) {
            szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
            szT[4] = 'I'; szT[5] = '\0';
            }
        else {
            szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
            }
        CommSzSz("Character: ", szT);
        CommSzNum("Dxp:      ", (int) dxp);
        CommSzNum("OverHang: ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
        }
#endif
        return(dxp);
        }

#ifdef DBEMG
    {
    char szT[10];
    CommSzSz("fPrinter:  ", (fPrinter ? "Printer" : "Screen"));
    if (ch == 0x0D) {
        szT[0] = 'C'; szT[1] = 'R'; szT[2] = '\0';
        }
    else if (ch == 0x0A) {
        szT[0] = 'L'; szT[1] = 'F'; szT[2] = '\0';
        }
    else if (32 <= ch && ch <= 126) {
        szT[0] = ch; szT[1] ='\0';
        }
    else if (FKanji1(ch)) {
        szT[0] = 'K'; szT[1] = 'A'; szT[2] = 'N'; szT[3] = 'J';
        szT[4] = 'I'; szT[5] = '\0';
        }
    else {
        szT[0] = szT[1] = szT[2] = '-'; szT[3] = '\0';
        }
    CommSzSz("Character: ", szT);
    CommSzNum("Dxp:       ", (int) *pdxp);
    CommSzNum("OverHang:  ", (int) (fPrinter ? vfmiPrint.dxpOverhang : vfmiScreen.dxpOverhang));
    }
#endif
    return(*pdxp);
    }

#ifdef DBCS
//
//   DxpFromCh for DBCS
//                                           yutakan, 03 Oct 1991

int DBCSDxpFromCh(ch, ch2, fPrinter)
int ch;
int ch2;
int fPrinter;
{
   /* T-HIROYN sync us 3.1*/
    int               *pdxp; // changed to int (7.23.91) v-dougk
    int               dxpDummy; // changed to int (7.23.91) v-dougk

    extern int        dxpLogCh;
    extern struct FCE *vpfceScreen;
    /* If the width is not in the width table, then get it. */
    if (ch < chFmiMin)
        {
        switch (ch)
            {
        case chTab:
        case chEol:
        case chReturn:
        case chSect:
        case chNewLine:
        case chNRHFile:
            /* the width for these characters aren't really important */
        pdxp = (CHAR *)(fPrinter ? &vfmiPrint.dxpSpace : &vfmiScreen.dxpSpace);
            break;
        default:
            pdxp = &dxpDummy;
            *pdxp = dxpNil;
            break;
            }
        }
    else if (ch >= chFmiMax)
        {
        /* outside the range we hold in our table - kludge it */
        pdxp = &dxpDummy;
        *pdxp = dxpNil;
        }
    else
        {
        /* inside our table */
        pdxp = (fPrinter ? vfmiPrint.mpchdxp : vfmiScreen.mpchdxp) + ch;
        }


    if (*pdxp == dxpNil )
       {
       int dxp;

#if defined(TAIWAN) || defined(PRC) //solve BkSp single byte (>0x80) infinite loop problem, MSTC - pisuih, 2/25/93
       // BUG 5477: Echen: add NON FA font, LeadByte + 2nd byte checking
       if( ch2 != 0 && IsDBCSLeadByte(ch) && GetFontAssocStatus(vhMDC))
#else
       if( IsDBCSLeadByte(ch) )
#endif  //TAIWAN
           {

           struct FMI *pfmi;
#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //for Bug# 3362, MSTC - pisuih, 2/10/93
           CHAR       rgchT[cchDBCS << 1];
           int        dxpOverhang;
#else
           CHAR       rgchT[cchDBCS];
#endif //TAIWAN
           int        dxpT;
           int        dxpDBCS;

           pfmi = fPrinter ? (&vfmiPrint) : (&vfmiScreen);
           Assert(pfmi->bDummy == dxpNil);

#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //fix Italic position error while SBCS's overhang != DBCS's overhang
                //for Bug# 3362, MSTC - pisuih, 3/4/93

           //fix Go To page too slow, pisuih, 3/4/93
           if ( (!pfmi->dxpDBCS) || (pfmi->dxpDBCS == dxpNil) )
           {
               rgchT[0] = rgchT[2] = ch;
               rgchT[1] = rgchT[3] = ch2;
               dxpDBCS = LOWORD(GetTextExtent( (fPrinter ? vhDCPrinter : vhMDC),
                                                     (LPSTR) rgchT, cchDBCS ));
               dxpOverhang = (dxpDBCS << 1) - LOWORD( GetTextExtent(
                  (fPrinter ? vhDCPrinter : vhMDC), (LPSTR) rgchT, cchDBCS << 1 ));

               //for compatible with SBCS's overhang
               dxpDBCS += (pfmi->dxpOverhang - dxpOverhang);

               /* Store in fmi, if it fits. */
               if (0 <= dxpDBCS && dxpDBCS < dxpNil)
                       pfmi->dxpDBCS = (WORD) dxpDBCS;

               return (dxpDBCS - pfmi->dxpOverhang);
           }
           else
               return (pfmi->dxpDBCS - pfmi->dxpOverhang);
#else
           if(pfmi->dxpDBCS == dxpNil)
               {
               /* Get the width from GDI. */
           rgchT[0] = ch;
           rgchT[1] = ch2;
               dxpDBCS = (fPrinter ?
                            LOWORD(GetTextExtent(vhDCPrinter,
                                                 (LPSTR) rgchT, cchDBCS)) :
                            LOWORD(GetTextExtent(vhMDC,
                                                 (LPSTR) rgchT, cchDBCS)));
               /* Store in fmi, if it fits. */
               if (0 <= dxpDBCS && dxpDBCS < dxpNil)
#if defined(JAPAN) || defined(KOREA)    //Win3.1 BYTE-->WORD
                   pfmi->dxpDBCS = (WORD) dxpDBCS;
#else
                   pfmi->dxpDBCS = (BYTE) dxpDBCS;
#endif
               return (dxpDBCS - pfmi->dxpOverhang);
               }
           else
               return (pfmi->dxpDBCS - pfmi->dxpOverhang);
#endif //TAIWAN
           }
       else
           {
           /* get width from GDI */
           dxp = fPrinter ? LOWORD(GetTextExtent(vhDCPrinter, (LPSTR)&ch, 1)) -
          vfmiPrint.dxpOverhang : LOWORD(GetTextExtent(vhMDC, (LPSTR)&ch, 1)) -
          vfmiScreen.dxpOverhang;
           }
   /*T-HIROYN sync us 3.1*/
        //(7.24.91) v-dougk if (dxp >= 0 && dxp < dxpNil)
           {
           /* only store dxp's that fit in a byte */
           *pdxp = dxp;
           }

       return(dxp);
       }


   return(*pdxp);
   }

#endif


/* F  F I R S T  I C H */
int near FFirstIch(ich)
int ich;
    {
    /* Returns true iff ich is 0 or preceded only by 0 width characters */
    register int ichT;
    register int *pdxp = &vfli.rgdxp[0];

    for (ichT = 0; ichT < ich; ichT++)
        {
        if (*pdxp++)
            {
            return false;
            }
        }
    return true;
    }


ValidateMemoryDC()
    {
    /* Attempt to assure that vhMDC and vhDCPrinter are valid.  If we have not
    already run out of memory, then vhDCPrinter is guaranteed, but vhMDC may
    fail due to out of memory -- it is the callers responsibility to check for
    vhMDC == NULL. */

    extern int vfOutOfMemory;
    extern HDC vhMDC;
    extern BOOL vfMonochrome;
    extern long rgbText;
    extern struct WWD *pwwdCur;

    /* If we are out of memory, then we shouldn't try to gobble it up by getting
    DC's. */
    if (!vfOutOfMemory)
        {
        if (vhMDC == NULL)
            {
            /* Create a memory DC compatible with the screen if necessary. */
            vhMDC = CreateCompatibleDC(pwwdCur->hDC);

            /* Callers are responsible for checking for vhMDC == NULL case */
            if (vhMDC != NULL)
                {
                /* Put the memory DC in transparent mode. */
                SetBkMode(vhMDC, TRANSPARENT);

                /* If the display is a monochrome device, then set the text
                color for the memory DC.  Monochrome bitmaps will not be
                converted to the foreground and background colors in this case,
                we must do the conversion. */
                if (vfMonochrome = (GetDeviceCaps(pwwdCur->hDC, NUMCOLORS) ==
                  2))
                    {
                    SetTextColor(vhMDC, rgbText);
                    }
                }
            }

        /* If the printer DC is NULL then we need to reestablish it. */
        if (vhDCPrinter == NULL)
            {
            GetPrinterDC(FALSE);
            /* GetPrinterDC has already called SetMapperFlags() on vhDCPrinter. */
            }
        }
    }

#ifdef DBCS
/* The following two functions are used to determine if a given kanji
   (two byte) character (or 1 byte kana letters) should be admitted
   to the current line without causing the line break though it is
   passed the right margin.

   The table below shows which letters are admitted as a hanging character
   on a line.  The table below should be updated in sync with the code
   itself.

   Kanji (2-byte) characters

            letter           first byte  second byte       half width
        hiragana small a        82          9F
                       i        82          A1
                       u        82          A3
                       e        82          A5
                       o        82          A7
                       tsu      82          C1
                       ya       82          E1
                       yu       82          E3
                       yo       82          E5
        katakana small a        83          40              85 A5
                       i        83          42              85 A6
                       u        83          44              85 A7
                       e        83          46              85 A8
                       o        83          48              85 A9
                       tsu      83          62              85 AD
                       ya       83          83              85 AA
                       yu       83          85              85 AB
                       yo       83          87              85 AC
                       wa       83          8E
                       ka       83          95
                       ke       83          96
                    blank       81          40
        horizontal bar (long)   81          5B              85 AE
                       (med)    81          5C
                       (short)  81          5D
        touten
          (Japanese comma)      81          41              85 A2
        kuten
          (Japanese period)     81          42              85 9F
        handakuten              81          4B              85 DD
        dakuten                 81          4A              85 DC
        kagikakko
          (closing Japanese parenthesis)
                                81          76              85 A1
        " (2-byte)              81          68              85 41
        ' (2-byte)              81          66              85 46
        } (2-byte)              81          70              85 9D
        ] (2-byte)              81          6E              85 7C
        ) (2-byte)              81          6A              85 48
        . (at the center)       81          45              85 A3
        ...                     81          63
        ..                      81          64
        closing angle bracket   81          72
        closing double angled bracket
                                81          74
        closing double kagikakko
                                81          78
        closing inversed )      81          7A
        closing half angled bracket
                                81          6C
        thinner '               81          8C
        thinner "               81          8D

   1-byte kana characters

            letter             byte
        katakana small a        A7
                       i        A8
                       u        A9
                       e        AA
                       o        AB
                     tsu        AF
                      ya        AC
                      yu        AD
                      yo        AE
        touten
          (Japanese comma)      A4
        kuten
          (Japanese period)     A1
        handakuten              DF
        dakuten                 DE
        kagikakko
          (closing Japanese parenthesis)
                                A3
        . (at the center)       A5

   The following 1 or 2 byte characters are treated as a hanging character
   if the previous character is a 2-byte kanji character.

                      letter    byte
                        "        22
                        '        27
                        }        7D
                        ]        5D
                        )        29
                        .        2E
                        ,        2C
                        ;        3B
                        :        3A
                        ?        3F
                        !        21

                                byte 1      byte 2
                        .        81          44
                        ,        81          43
                        ;        81          47
                        :        81          46
                        ?        81          48
                        !        81          49


                        .        85          4D
                        ,        85          4B
                        ;        85          4A
                        :        85          49
                        ?        85          5E
                        !        85          40

*/

BOOL near FSearchChRgch(ch, rgch, ichLim)
    CHAR    ch;
    CHAR    *rgch;
    int     ichLim;
{
    int   ichMin;
    BOOL  fFound;

    fFound  = FALSE;
    ichMin  = 0;

    while (!fFound && ichMin <= ichLim) {
        int     ichMid;
        CHAR    chMid;

        /* Save on the dereferencing. */
        chMid = rgch[ichMid = (ichMin + ichLim) >> 1];
        if (ch == chMid) {
            fFound = TRUE;
            }
        else if (ch < chMid) {
            ichLim = ichMid - 1;
            }
        else {
            ichMin = ichMid + 1;
            }
        }
    return (fFound);
}

/* FAdmitCh1() returns true if and only if the given ch is a one-byte
   kana code for those letters that can appear beyond the right margin. */

BOOL near FAdmitCh1(ch)
    CHAR    ch;
{
#ifdef JAPAN
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
    return (
        (ch == 0xA1) ||
        ((0xA3 <= ch) && (ch <= 0xA5)) ||
        ((0xA7 <= ch) && (ch <= 0xAF)) ||
        ((0xDE <= ch) && (ch <= 0xDF))
        );
#else
    return(FALSE);
#endif
}

/* FOptAdmitCh1() returns true if and only if the given ch is a
   one-byte character that can be admitted to the end of a line
   beyond the right margin, if it appears after a kanji character. */

BOOL near FOptAdmitCh1(ch)
    CHAR    ch;
{
    static CHAR rgchOptAdmit1[]
                    = {0x21, 0x22, 0x27, 0x29, 0x2C, 0x2E, 0x3A, 0x3B,
                       0x3F, 0x5D, 0x7D};
#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    return (FSearchChRgch(ch, rgchOptAdmit1,
                          (sizeof(rgchOptAdmit1) / sizeof(CHAR)) - 1));
}

/* FAdmitCh2() returns true if and only if the given (ch1, ch2) combination
   represents a kanji (2-byte) letter that can appear beyond the right
   margin. */

BOOL near FAdmitCh2(ch1, ch2)
    CHAR    ch1, ch2;
{
    int   dch=0;

#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    while((dch < MPDCHRGCHIDX_MAC) && (ch1 != mpdchrgchIdx[dch]))
    dch++;
    if (dch < MPDCHRGCHIDX_MAC) {
        return (FSearchChRgch(ch2, mpdchrgch[dch], mpdchichMax[dch] - 1));
        }
    else {
        return (FALSE);
        }
}

/* FOptAdmitCh2() returns true if and only if the given (ch1, ch2) is a
   two-byte character combination that can be admitted to the end of a line
   beyond the right margin, provided it appears after a kanji character. */

BOOL near FOptAdmitCh2(ch1, ch2)
    CHAR    ch1, ch2;
{
    int i=0;
#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    while ((i < OPTADMIT2IDX_MAC) && (ch1 != OptAdmit2Idx[i]))
    i++;
    if (i < OPTADMIT2IDX_MAC){
    return (FSearchChRgch(ch2, mpdchrgchOptAdmit2[i], OptAdmit2ichMax[i]));
        }
    else {
        return (FALSE);
        }
}


/* FOptAdmitCh() returns TRUE if and only if the given (ch1, ch2) can
   be a hanging letter at the end of a line.  Otherwise, FALSE.  If ch1
   is equal to '\0', ch2 is treated as a 1-byte character code. */

BOOL FOptAdmitCh(ch1, ch2)
    CHAR ch1, ch2;
{
#if defined(JAPAN) || defined(KOREA)
    if(!vfWordWrap) /*WordWrap off t-Yoshio*/
        return FALSE;
#endif
    if (ch1 == '\0') {
        return ((ch2 == chSpace) || FAdmitCh1(ch2) || FOptAdmitCh1(ch2));
        }
    else {
        return (FKanjiSpace(ch1, ch2) || FAdmitCh2(ch1, ch2) ||
                FOptAdmitCh2(ch1, ch2));
        }
}
#endif /* ifdef DBCS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\d_selec2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Select2.c -- Less-frequently-used selection routines */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "toolbox.h"
#include "docdefs.h"
#include "editdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "fmtdefs.h"
#include "propdefs.h"

#ifdef	DBCS
#include "kanji.h"
#endif

extern int		vfSeeSel;
extern typeCP		vcpFirstParaCache;
extern typeCP		vcpLimParaCache;
extern typeCP		vcpFetch;
extern CHAR		*vpchFetch;
extern int		vccpFetch;
extern typeCP		cpMinCur;
extern typeCP		cpMacCur;
extern struct SEL	selCur;
extern int		docCur;
extern struct FLI	vfli;
extern struct WWD	rgwwd[];
extern int		vfSelHidden;
extern int		wwCur;
extern struct CHP	vchpFetch;
extern struct PAP	vpapAbs;
extern struct WWD	*pwwdCur;
extern int		vfInsEnd;
extern typeCP		CpBeginLine();
extern int		vfPictSel;
extern int		vfSizeMode;
extern struct CHP	vchpNormal;
extern int		vfInsertOn;
extern struct CHP	vchpSel;	/* Holds the props when the selection
						is an insert point */
extern int vfMakeInsEnd;
extern typeCP vcpSelect;
extern int vfSelAtPara;
/* true iff the last selection was made by an Up/Down cursor key */
extern int vfLastCursor;


#ifndef DBCS	/* US version */
/* C P	L I M  S T Y  S P E C I A L */
typeCP CpLimStySpecial(cp, sty)
typeCP cp;
int sty;
{    /* Return the first cp which is not part of the same sty unit */
	int wb, ch, ich;
	struct EDL *pedl;

	/* Other cases covered in CpLimSty, our only caller */

	Assert( cp < cpMacCur );
	Assert( cp >= cpMinCur );
	Assert( sty == styWord || sty == stySent );

/* Special kludge for picture paragraphs */
	CachePara(docCur, cp);
	if (vpapAbs.fGraphics)
		return vcpLimParaCache;

	FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);

	Assert(vccpFetch != 0);

	/* Must be word or sentence */
	wb = WbFromCh(ch = vpchFetch[ich = 0]);
#ifdef CRLF
	if (ch == chReturn)
		return vcpFetch + 2;
#endif
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab)
		/* EOL is its own unit */
		return vcpFetch + 1;

	if (wb == wbWhite && sty == stySent)
		{ /* Might be between sentences; go back to text */
		FetchCp(docCur, CpFirstSty(cp, styWord), 0, fcmChars + fcmNoExpand);
		wb = WbFromCh(ch = vpchFetch[ich = 0]);
		}

	for (;;)
		{
		if (++ich >= vccpFetch)
			{ /* Get next line and set up */
			FetchCp(docNil, cpNil, 0, fcmChars);
			if (vcpFetch == cpMacCur)
				return cpMacCur; /* End of doc */
			ich = 0;
			}
		if (sty == stySent)
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				sty = styWord;
				wb = wbPunct;
				}
		switch (ch = vpchFetch[ich])
			{
		case chTab:
		case chEol:
		case chSect:
		case chNewLine:
#ifdef CRLF
		case chReturn:
#endif
			goto BreakFor;
			}
		if (sty == styWord)
			{ /* Word ends after white space or on text/punct break */
			int wbT = WbFromCh(ch);
			if (wb != wbT && (wb = wbT) != wbWhite)
				break;
			}
		}
	BreakFor:
	return vcpFetch + ich;
}



/* C P	F I R S T  S T Y  S P E C I A L */
typeCP CpFirstStySpecial(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
	typeCP cpBegin;
	int wb, ch, dcpChunk;
	typeCP cpSent;
	CHAR rgch[dcpAvgSent];
	int ich;
	typeCP cpT;

	/* Other cases were covered by CpFirstSty, our only caller */

	Assert( cp > cpMinCur );
	Assert( sty == stySent || sty == styWord );

	if (cp >= cpMacCur)
	    cpT = cp = cpMacCur;
	else
	    cpT = cp++;

	CachePara(docCur, cpT );
	if ((vcpFirstParaCache == cpT) || vpapAbs.fGraphics)
	    return vcpFirstParaCache;

	dcpChunk = (sty == styWord) ? dcpAvgWord : dcpAvgSent;
	cpBegin = (cp > dcpChunk) ? cp - dcpChunk : cp0;

	FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
	wb = WbFromCh(ch = rgch[--ich]);

#ifdef CRLF
	if(cpBegin + ich == 0)
	    return cp0;

	if (ch == chEol && rgch[ich-1] == chReturn) /* EOL is its own unit */
	    return cpBegin + ich - 1;
	if (ch == chEol || ch == chReturn || ch == chSect || ch == chNewLine || ch == chTab)
	    return cpBegin + ich;
#else /* not CRLF */
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab) /* EOL is its own unit */
	    return cpBegin + ich;
#endif /* CRLF */

	if (wb == wbText)
		cpSent = cpBegin + ich;
	else
		cpSent = cpNil;

	for (;;)
		{
		if (ich == 0)
			{
			if (cpBegin == cpMinCur)
				return cpMinCur; /* beginning of doc */
			cpBegin = (cpBegin > dcpChunk) ? cpBegin - dcpChunk : cp0;
			FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
			}
		ch = rgch[--ich];
		CachePara( docCur, cpBegin + ich ); /* Needed for pictures */
		if (ch == chEol || ch == chSect || ch == chNewLine ||
				   ch == chTab || vpapAbs.fGraphics )
			break; /* EOL Always ends a unit */
		if (sty == styWord)
			{
			if (wb != wbWhite)
				{
				if (WbFromCh(ch) != wb)
					break;
				}
			else
				wb = WbFromCh(ch);
			}
		else
			{ /* Test for sentence. */
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				if (cpSent != cpNil)
					return cpSent;
				}
			switch (WbFromCh(ch))
				{
			case wbText:
				cpSent = cpBegin + ich;
				wb = wbText;
				break;
			case wbPunct:
				switch (wb)
					{
				case wbWhite:
					wb = wbPunct;
					break;
				case wbText:
					cpSent = cpBegin + ich;
					}
				break;
			case wbWhite:
				if (wb == wbPunct)
					cpSent = cpBegin + ich + 1;
				wb = wbWhite;
				break;
				}
			}
		}
	return cpBegin + ich + 1;
}

#else		/* DBCS version */

typeCP CpLimStySpecial(cp, sty)
    typeCP	cp;
    int 	sty;
{
    CHAR	rgch[cchKanji];
    int 	ch, ch2;
    int 	ich, wb;
    typeCP	cpLim, cpT;

    /* Other cases covered in CpLimSty, our only caller */
    Assert(cp < cpMacCur);
    Assert(cp >= cpMinCur);
    Assert(sty == styWord || sty == stySent);

    /* Picture paragraph? */
    CachePara(docCur, cp);
    if (vpapAbs.fGraphics) {
	return vcpLimParaCache;
	}

    cpLim = vcpLimParaCache;
    if (vcpLimParaCache > cpMacCur) {
	/* No EOL at end of doc */
	cpLim = cpMacCur;
	}

    FetchRgch(&ich, rgch, docCur, cp,
	      ((cpT = cp + cchKanji) < cpLim) ? cpT : cpLim, cchKanji);
    ch = rgch[0];
#ifdef CRLF
    if (ch == chReturn) {
	return (cp + 2);
	}
#endif /* CRLF */
    if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab) {
	/* EOL is its own unit. */
	return (cp + 1);
	}
#ifdef	KOREA
	wb=WbFromCh(ch);
#else

    if (FKanji1(ch)) {
	wb = WbFromKanjiChCh(ch, (int) rgch[1]);
	if (sty == styWord && wb == wbKanjiText) {
	    return (CpLimSty(cp, styChar));
	    }
	else {
	    if (wb == wbKanjiText) {
		wb = wbKanjiTextFirst;
		}
	    }
	}
    else {
	if (sty == styWord && FKanaText(ch)) {
	    return (CpLimSty(cp, styChar));
	    }
	wb = WbFromCh(ch);
	}
#endif

    for (; cp < cpLim;) {
	int	    wbT;

	if (sty == stySent) {
	    if (FKanji1(ch)) {
		CHAR ch2;

		ch2 = rgch[1];
		if (FKanjiKuten(ch, ch2)  ||
		    FKanjiQMark(ch, ch2)  ||
		    FKanjiBang(ch, ch2)   ||
		    FKanjiPeriod(ch, ch2)) {
			sty = styWord;
			wb = wbPunct;
			goto lblNextFetch;
		    }
		}
	    else {
		switch (ch) {
#ifndef  KOREA
		    case bKanjiKuten:
#endif
		    case chDot:
		    case chBang:
		    case chQMark:
			sty = styWord;
			wb = wbPunct;
			goto lblNextFetch;
		    }
		}
	    }

	switch (ch) {
	    case chTab:
	    case chEol:
	    case chSect:
	    case chNewLine:
#ifdef CRLF
	    case chReturn:
#endif /* CRLF */
		return cp;
	    }

	if (sty == styWord) {
#ifdef	KOREA
	    wbT = WbFromCh(ch);
#else
	    if (FKanji1(ch)) {
		wbT = WbFromKanjiChCh(ch, (int) rgch[1]);
		}
	    else {
		wbT = WbFromCh(ch);
		}
#endif

	    if (wb != wbT && (wb = wbT) != wbWhite) {
		return (cp);
		}
	    }

lblNextFetch:
	cp = CpLimSty(cp, styChar);
	if (cp < cpLim) {
	    /* Save some time and an untimely demise.... */
	    FetchRgch(&ich, rgch, docCur, cp,
		      ((cpT = cp + cchKanji) < cpLim) ? cpT : cpLim, cchKanji);
	    ch = rgch[0];
	    }
	}
    return (cpLim);
}

typeCP CpFirstStySpecial(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
    typeCP	cpT, cpLim, cpFirstPara,
		cpFirstLastSent; /* cpFirst of the last possible sentence boundary */
    CHAR	rgch[cchKanji];
    int 	ch;
    int 	wb;
    int 	ich;

    /* Other cases were covered by CpFirstSty, our only caller */

    Assert( cp > cpMinCur );
    Assert(CpFirstSty(cp, styChar) == cp); /* cp is on a char boundary */
    Assert( sty == stySent || sty == styWord );

    cpT = cp;
    if (cp >= cpMacCur) {
	cpT = cp = cpMacCur;
	}

    CachePara(docCur, cpT );
    cpFirstPara = vcpFirstParaCache;
    if ((vcpFirstParaCache == cpT) || vpapAbs.fGraphics) {
	return vcpFirstParaCache;
	}


#ifdef CRLF
    /* CR-LF is assumed. */
    Assert(TRUE);
#else
    Assert(FALSE);
#endif /* CRLF */
    FetchRgch(&ich, rgch, docCur, cp,
	      ((cpT = cp + cchKanji) < cpMacCur) ? cpT : cpMacCur, cchKanji);
    ch = rgch[0];
    if (ich == cchKanji && ch == chReturn && rgch[1] == chEol) {
	/* EOL is its own unit */
	return cp;
	}
    if (ch == chEol	|| ch == chReturn || ch == chSect ||
	ch == chNewLine || ch == chTab) {
	    return cp;
	    }

    cpFirstLastSent = cpNil;

#ifdef	KOREA
    wb = WbFromCh(ch);
#else
    if (FKanji1(ch)) {
	wb = WbFromKanjiChCh(ch, (int) rgch[1]);
	if (sty == styWord && wb == wbKanjiText) {
	    return (CpFirstSty(cp, styChar));
	    }
	else {
	    if (wb == wbKanjiText) {
		wb = wbKanjiTextFirst;
		}
	    }
	}
    else {
	if (sty == styWord && FKanaText(ch)) {
	    return (CpFirstSty(cp, styChar));
	    }
	wb = WbFromCh(ch);
	}
#endif

    for (; cpFirstPara < cp; ) {
	typeCP	cpTemp;
	int	wbT;

	cpTemp = CpFirstSty(cp - 1, styChar);
	FetchRgch(&ich, rgch, docCur, cpTemp,
		  ((cpT = cpTemp + cchKanji) < cpMacCur) ? cpT : cpMacCur, cchKanji);
	ch = rgch[0];
#ifdef	KOREA
	wbT = WbFromCh(ch);
#else
	if (FKanji1(ch)) {
	    wbT = WbFromKanjiChCh(ch, (int) rgch[1]);
	    }
	else {
	    wbT = WbFromCh(ch);
	    }
#endif
	if (wb == wbWhite) {
#ifdef	KOREA
	    wb=wbT;
#else
	    wb = (wbT == wbKanjiText) ? wbKanjiTextFirst : wbT;
#endif
	    }
	else if (wb != wbT) {
	    if (sty == styWord) {
		return (cp);
		}
	    else /* sty == stySent */ {
		 /* wb	!= wbWhite */
		 /* wb	!= wbT	   */
		if (wbT == wbWhite || wbT == wbPunct) {
		    cpFirstLastSent = cp;
		    wb = wbWhite;
		    }
		}
	    }

	if (sty == stySent) { /* for the sentence */
	    if (FKanji1(ch)) {
		int	ch2;
		ch2 = rgch[1];
		if (FKanjiKuten(ch, ch2) ||
		    FKanjiQMark(ch, ch2) ||
		    FKanjiBang(ch, ch2)  ||
		    FKanjiPeriod(ch, ch2)) {
			if (cpFirstLastSent != cpNil) {
			    return (cpFirstLastSent);
			    }
			else {
			    cpFirstLastSent = cp;
			    }
			}
		}
	    else {
		switch(ch) {
#ifndef KOREA
		    case bKanjiKuten:
#endif
		    case chDot:
		    case chBang:
		    case chQMark:
			if (cpFirstLastSent != cpNil) {
			    return (cpFirstLastSent);
			    }
			else {
			    cpFirstLastSent = cp;
			    }
		    }
		}

	    }

	cp = cpTemp;
	}
    return (cpFirstPara);
}
#endif		/* DBCS */

/* W B	F R O M  C H */
int WbFromCh(ch)
int ch;
{ /* Return word-breakness of ch */

#if defined(DBCS) & !defined(KOREA)    /* was in JAPAN; KenjiK '90-10-29 */
	/* Brought from WIN2 source. */
	if (FKanaPunct(ch)) {
	    return wbPunct;
	    }
	else if (FKanaText(ch)) {
	    return wbKanjiText;
	    }
#endif

	switch (ch)
		{
	case chSpace:
	case chEol:
#ifdef CRLF
	case chReturn:
#endif
	case chSect:
	case chTab:
	case chNewLine:
	case chNBSFile:
		return wbWhite;
	case chNRHFile:
		return wbText;
	default: /* we are using the ANSI char set that windows used */
#ifdef	KOREA
		return ((isalpha(ch) || isdigit(ch) || ((ch>0x81)&&(ch<0xfe)))? wbText : wbPunct);
#else
		return ((isalpha(ch) || isdigit(ch))? wbText : wbPunct);
#endif
		}
}

#ifdef	DBCS	/* was in JAPAN; KenjiK '90-10-29 */
	/* Brought from WIN2 source. */
int WbFromKanjiChCh(ch1, ch2)
    int ch1, ch2;
{
    if (ch1 == chReturn && ch2 == chEol) {
	return wbWhite;
	}
    else if (FKanjiSpace(ch1, ch2)) {
	return wbWhite;
	}
    else

#ifdef	JAPAN
	 {
	switch (ch1) {
	    case 0x81:
		if (0x57 <= ch2 && ch2 <= 0x59) {
		    return wbKanjiText;
		    }
		else {
		    return wbPunct;
		    }
	    case 0x85:
		if ((0x40 <= ch2 && ch2 <= 0x4E) ||
		    (0x59 <= ch2 && ch2 <= 0x5F) ||
		    (0x7A <= ch2 && ch2 <= 0x7E) ||
		    (0x9B <= ch2 && ch2 <= 0xA3) ||
		    (0xDC <= ch2 && ch2 <= 0xDD)) {
			return wbPunct;
			}
		else {
		    return wbKanjiText;
		    }
	    case 0x86:
		return wbPunct;
	    case 0x87:
		return ((ch2 >= 0x90) ? wbPunct : wbKanjiText);
	    default:
		return wbKanjiText;
	    }
	}
#endif
#ifdef	KOREA
	{
        switch (ch1) {
	    case 0xa2:
		if (0xde <= ch2 && ch2 <= 0xe5) {
		    return wbText; // wbKanjiText; MSCH bklee 01/26/95
		    }
		else {
		    return wbPunct;
		    }
	    case 0xa3:
		if ((0xa1 <= ch2 && ch2 <= 0xaf) ||
		    (0xba <= ch2 && ch2 <= 0xc0) ||
		    (0xdb <= ch2 && ch2 <= 0xe0) ||
		    (0xfb <= ch2 && ch2 <= 0xfe)) {
			return wbPunct;
			}
		else {
		    return wbText; //wbKanjiText;  MSCH bklee 01/26/95
		    }
	    default:
		return wbText; //wbKanjiText; MSCH bklee 01/26/95
	    }
	}
#endif

#ifdef PRC   // brucere 11/16/95
	{
      switch (ch1) {
      case 0xA1:
         return wbPunct;

      case 0xA3:
         if ((0xA1 <= ch2 && ch2 <= 0xAF) ||
             (0xBA <= ch2 && ch2 <= 0xC0) || 
             (0xDB <= ch2 && ch2 <= 0xE0) ||
             (0xFB <= ch2 && ch2 <= 0xFE)) 
            return wbPunct;
         else 
            return wbKanjiText;

      case 0xA4:
         if (ch2 == 0x92)
            return wbPunct;
         else 
            return wbKanjiText;

      default:
   		return wbKanjiText;
      }
	}
#elif	TAIWAN
	{
	switch (ch1) {
	    case 0xA1:
		if (0x41 <= ch2 && ch2 <= 0xAC) 
		    return wbPunct;
		else 
		    return wbKanjiText;

	    default:
		return wbKanjiText;
	    }
	}
#endif

}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\edit.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* edit.c -- MW editing routines */

#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
//#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "debug.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "editdefs.h"
#include "str.h"
#include "prmdefs.h"
#include "printdef.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

/* E X T E R N A L S */
extern int vfOutOfMemory;
extern struct DOD       (**hpdocdod)[];
extern typeCP           vcpFirstSectCache;
extern struct UAB       vuab;
extern typeCP           cpMinCur;
extern typeCP           cpMacCur;
extern struct SEL       selCur;
extern int              docCur;
extern struct WWD       rgwwd[];
extern int              wwMac;
extern int              wwCur;
extern typeCP           vcpLimSectCache;
/*extern int idstrUndoBase;*/
extern int              docScrap;
extern int              docUndo;
extern int              vfSeeSel;
extern struct PAP       vpapAbs;
extern int              vfPictSel;
extern int              ferror;

/* the following used to be defined here */
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
/* this is a global parameter to AdjustCp; if false, no invalidation will
take place */
extern BOOL             vfInvalid;

#ifdef ENABLE
extern struct SEL       selRulerSprm;
#endif

extern int              docRulerSprm;
extern struct EDL       *vpedlAdjustCp;

struct PCD *PpcdOpen();




/* R E P L A C E */
Replace(doc, cp, dcp, fn, fc, dfc)
int doc, fn;
typeCP cp, dcp;
typeFC fc, dfc;
{ /* Replace cp through (cp+dcp-1) in doc by fc through (fc+dfc-1) in fn */

        if (ferror) return;
#ifdef ENABLE
        if (docRulerSprm != docNil) ClearRulerSprm();
#endif
        /* if (fn == fnNil) we are infact deleting text by replacing text
           with nil.  Thus, the memory space check is unnecessary.*/
#ifdef BOGUS    /* No longer have cwHeapFree available */
        if ((fn != fnNil) && (cwHeapFree < 3 * cpcdMaxIncr * cwPCD))
                {
#ifdef DEBUG
                ErrorWithMsg(IDPMTNoMemory, " edit#1");
#else
                Error(IDPMTNoMemory);
#endif
                return;
                }
#else
        if (vfOutOfMemory)
            {
            ferror = 1;
            return;
            }
#endif

        if (dcp != cp0)
                {
                AdjParas(doc, cp, doc, cp, dcp, fTrue); /* Check for del EOL */
                DelFtns(doc, cp, cp + dcp);     /* Delete any footnotes */
                }

        Repl1(doc, cp, dcp, fn, fc, dfc);
        if (ferror)
            return;
        AdjustCp(doc, cp, dcp, dfc);

        /* Special kludge for graphics paragraphs */
        if (dfc != dcp)
                CheckGraphic(doc, cp + dfc);

}




/* C H E C K  G R A P H I C */
CheckGraphic(doc, cp)
int doc; typeCP cp;
{
#if defined(OLE)
extern  BOOL             bNoEol;
#endif

#ifdef CASHMERE /* No docBuffer in MEMO */
extern int docBuffer; /* Don't need extra paragraph mark in txb document */
        if (cp == ((**hpdocdod)[doc]).cpMac || doc == docBuffer)
                return;
#else
        if (cp == ((**hpdocdod)[doc]).cpMac)
            return;
        CachePara(doc, cp);
        /* !!! this has a bug.  There are cases when you don't want to insert
           EOL.  Ex1:  place cursor in front of bitmap and press
           backspace.  Ex2:  OleSaveObjectToDoc deletes an object and
           insert new one (Eol gets inserted too). (4.10.91) v-dougk
        */
        if (vpapAbs.fGraphics && vcpFirstParaCache != cp)
#if defined(OLE)
            if (!bNoEol)
#endif
                InsertEolInsert(doc, cp);
#endif
}




int IpcdSplit(hpctb, cp)
struct PCTB **hpctb;
typeCP cp;
{ /* Ensure cp is the beginning of a piece.  Return index of that piece.
     return ipcdNil on error (extern int ferror will be set in that case) */
register struct PCD *ppcd = &(**hpctb).rgpcd[IpcdFromCp(*hpctb, cp)];
typeCP dcp = cp - ppcd->cpMin;

if (dcp != cp0)
        {
        ppcd = PpcdOpen(hpctb, ppcd + 1, 1);      /* Insert a new piece */
        if (ppcd == NULL)
            return ipcdNil;
        ppcd->cpMin = cp;
        ppcd->fn = (ppcd - 1)->fn;
        ppcd->fc = (ppcd - 1)->fc + dcp;
        ppcd->prm = (ppcd - 1)->prm;
        ppcd->fNoParaLast = (ppcd - 1)->fNoParaLast;
        }
/* NOTE CASTS: For piece tables with rgpcd > 32Kbytes */
/* return ppcd - (*hpctb)->rgpcd; */

return ((unsigned)ppcd - (unsigned)((*hpctb)->rgpcd)) / sizeof (struct PCD);
}




/* P P C D  O P E N */
struct PCD *PpcdOpen(hpctb, ppcd, cpcd)
struct PCTB **hpctb;
struct PCD *ppcd;
int cpcd;
{ /* Insert or delete cpcd pieces */
register struct PCTB *ppctb = *hpctb;

/* NOTE CASTS: For piece tables with rgpcd > 32Kbytes */
/* int ipcd = ppcd - ppctb->rgpcd; */
int ipcd = ((unsigned)ppcd - (unsigned)(ppctb->rgpcd)) / sizeof (struct PCD);
int ipcdMac, ipcdMax;

ipcdMac = ppctb->ipcdMac + cpcd;
ipcdMax = ppctb->ipcdMax;

if (cpcd > 0)
        { /* Inserting pieces; check for pctb too small */
        if (ipcdMac > ipcdMax)
                { /* Enlarge piece table */
                int cpcdIncr = umin(cpcdMaxIncr, ipcdMac / cpcdChunk);

                if (!FChngSizeH((int **) hpctb, (int) (cwPCTBInit + cwPCD *
                    ((ipcdMax = ipcdMac + cpcdIncr) - cpcdInit)), false))
                    {
#ifdef DEBUG
                    ErrorWithMsg(IDPMTNoMemory, " edit#3");
#else
                    Error(IDPMTNoMemory);
#endif
                    return (struct PCD *)NULL;
                    }

                /* Successfully expanded piece table */

                ppctb = *hpctb;
                ppcd = &ppctb->rgpcd [ipcd];
                ppctb->ipcdMax = ipcdMax;
                }
        ppctb->ipcdMac = ipcdMac;
        blt(ppcd, ppcd + cpcd, cwPCD * (ipcdMac - (ipcd + cpcd)));
        }
else if (cpcd < 0)
        { /* Deleting pieces; check for pctb obscenely large */
        ppctb->ipcdMac = ipcdMac;
        blt(ppcd - cpcd, ppcd, cwPCD * (ipcdMac - ipcd));
        if (ipcdMax > cpcdInit && ipcdMac * 2 < ipcdMax)
                { /* Shrink piece table */
#ifdef DEBUG
                int f =
#endif
                FChngSizeH((int **) hpctb, (int) (cwPCTBInit + cwPCD *
                    ((ppctb->ipcdMax = umax(cpcdInit,
                      ipcdMac + ipcdMac / cpcdChunk)) - cpcdInit)), true);

                Assert( f );

                return &(**hpctb).rgpcd[ipcd];
                }
        }
return ppcd;
}




/* R E P L 1 */
/* core of replace except for checking and Adjust */
Repl1(doc, cp, dcp, fn, fc, dfc)
int doc, fn;
typeCP cp, dcp;
typeFC fc, dfc;
{ /* Replace pieces with an optional new piece */
        struct PCTB **hpctb;
        int ipcdFirst;
        int cpcd;
        typeCP dcpAdj = dfc - dcp;
        register struct PCD *ppcd;
        struct PCD *ppcdMac;
        struct PCTB *ppctb;
        struct PCD *ppcdPrev;
        struct PCD *ppcdLim=NULL;

        hpctb = (**hpdocdod)[doc].hpctb;
        ipcdFirst = IpcdSplit(hpctb, cp);

        if (dcp == cp0)
            cpcd = 0;
        else
            cpcd = IpcdSplit( hpctb, cp + dcp ) - ipcdFirst;

        if (ferror)
            return;

        ppctb = *hpctb;
        ppcdPrev = &ppctb->rgpcd[ipcdFirst - 1];

        if ( dfc == fc0 ||
             (ipcdFirst > 0 && ppcdPrev->fn == fn && bPRMNIL(ppcdPrev->prm) &&
                     ppcdPrev->fc + (cp - ppcdPrev->cpMin) == fc) ||
             ((ppcdLim=ppcdPrev + (cpcd + 1))->fn == fn &&
                      bPRMNIL(ppcdLim->prm) && (ppcdLim->fc == fc + dfc)))
            {   /* Cases: (1) No insertion,
                          (2) Insertion is appended to previous piece
                          (3) Insertion is prepended to this piece */

            ppcd = PpcdOpen( hpctb, ppcdPrev + 1, -cpcd );
            if (ppcd == NULL)
                return;

            if (dfc != fc0)
                {   /* Cases 2 & 3 */
                if (ppcdLim != NULL)
                        /* Case 3 */
                    (ppcd++)->fc = fc;

                    /* If extending, say we might have inserted EOL */
                (ppcd - 1)->fNoParaLast = false;
                }
            }
        else
            { /* Insertion */
            ppcd = PpcdOpen( hpctb, ppcdPrev + 1, 1 - cpcd );
            if (ppcd == NULL)
                return;
            ppcd->cpMin = cp;
            ppcd->fn = fn;
            ppcd->fc = fc;
            SETPRMNIL(ppcd->prm);
            ppcd->fNoParaLast = false;       /* Don't know yet */
            ++ppcd;
            }
        ppcdMac = &(*hpctb)->rgpcd[(*hpctb)->ipcdMac];
        if (dcpAdj !=0)
            while (ppcd < ppcdMac)
                (ppcd++)->cpMin += dcpAdj;
}




/* A D J U S T  C P */
/* note global parameter vfInvalid */
/* sets global vpedlAdjustCp to pedl of line containing cpFirst, if any */
AdjustCp(doc, cpFirst, dcpDel, dcpIns)
int doc;
typeCP cpFirst, dcpDel, dcpIns;
{
        /* Adjust all cp references in doc to conform to the deletion of
           dcpDel chars and the insertion of dcpIns chars at cpFirst.
           Mark display lines (dl's) dirty for all lines in all windows
           displaying doc that are affected by the insertion & deletion
        */
extern int vdocBitmapCache;
extern typeCP vcpBitmapCache;
int ww;
typeCP cpLim = cpFirst + dcpDel;
typeCP dcpAdj = dcpIns - dcpDel;
#ifdef DEBUG
Scribble(2,'A');
#endif

{   /* Range in which pdod belongs in a register */
register struct DOD *pdod = &(**hpdocdod)[doc];

#ifdef STYLES
/* If inserting or deleting in style sheet, invalidates rest of doc */
if (pdod->dty == dtySsht && dcpAdj != cp0)
        cpLim = pdod->cpMac;
#endif
pdod->cpMac += dcpAdj;
/* Change for sand to support separate footnote windows: Make sure that edit
                was within the current cpMacCur */
/* note <= (CS) */
if (doc == docCur && cpFirst <= cpMacCur)
        cpMacCur += dcpAdj;

#ifdef STYLES
if (dcpAdj != cp0 && pdod->dty != dtySsht)
#else
if (dcpAdj != cp0)
#endif
        {
#ifdef FOOTNOTES
        if (pdod->hfntb != 0)
                { /* Adjust footnotes */
                struct FNTB *pfntb = *pdod->hfntb;
                int cfnd = pfntb->cfnd;
                struct FND *pfnd = &pfntb->rgfnd[cfnd];
                AdjRg(pfnd, cchFND, bcpRefFND, cfnd, cpFirst, dcpAdj);
                AdjRg(pfnd, cchFND, bcpFtnFND, cfnd, cpFirst + 1, dcpAdj);
                }
#endif
#ifdef CASHMERE
        if (pdod->hsetb != 0)
                { /* Adjust sections */
                struct SETB *psetb = *pdod->hsetb;
                int csed = psetb->csed;
                AdjRg(&psetb->rgsed[csed], cchSED, bcpSED, csed, cpFirst + 1,
                    dcpAdj);
                }
#endif
        if (pdod->dty == dtyNormal && pdod->hpgtb != 0)
                { /* Adjust page table */
                struct PGTB *ppgtb = *pdod->hpgtb;
                int cpgd = ppgtb->cpgd;
                AdjRg(&ppgtb->rgpgd[cpgd], cchPGD, bcpPGD, cpgd, cpFirst + 1,
                    dcpAdj);
                }
        }

#ifdef ENABLE
/* invalidate selection which contains the sprm Ruler1. When AdjustCp is
called in behalf of DragTabs, this invalidation will be undone by the caller
*/
if (doc == docRulerSprm && cpFirst >= selRulerSprm.cpFirst)
        docRulerSprm = docNil;
#endif
}       /* End of pdod belongs in a register */

/* Adjust or invalidate bitmap cache as appropriate */

if (doc == vdocBitmapCache)
    {
    if (vcpBitmapCache >= cpFirst)
        {
        if (vcpBitmapCache < cpFirst + dcpDel)
            FreeBitmapCache();
        else
            vcpBitmapCache += dcpAdj;
        }
    }

for (ww = 0; ww < wwMac; ww++)
        {
        register struct WWD *pwwd;
        if ((pwwd = &rgwwd[ww])->doc == doc)
                { /* This window may be affected */
                int dlFirst = 0;
                int dlLim = pwwd->dlMac;
                struct EDL *pedlFirst;
                struct EDL *pedlLast;
                register struct EDL *pedl;
                typeCP cpFirstWw = pwwd->cpFirst;
                struct SEL *psel = (ww == wwCur) ? &selCur : &pwwd->sel;

                if (pwwd->cpMac >= cpLim)
                        {
                        pwwd->cpMac += dcpAdj;
                        if (pwwd->cpMin > cpLim || pwwd->cpMac < pwwd->cpMin)
                                {
                                pwwd->cpMin += dcpAdj;
                                if (ww == wwCur)
                                        cpMinCur = pwwd->cpMin;
                                }
                        }

#ifndef BOGUSCS
                if (dcpAdj != cp0 && psel->cpLim >= cpFirst)
#else
                if (dcpAdj != cp0 && psel->cpLim > cpFirst)
#endif
                        { /* Adjust selection */
                        if (psel->cpFirst >= cpLim)
                                { /* Whole sel is after edit */
                                psel->cpFirst += dcpAdj;
                                psel->cpLim += dcpAdj;
                                }
                        else
                                { /* Part of sel is in edit */
                                typeCP cpLimNew = (dcpIns == 0) ?
                                    CpFirstSty( cpFirst, styChar ) :
                                    cpFirst + dcpIns;
#ifdef BOGUSCS
                                if (ww == wwCur)
                                        TurnOffSel();
#endif
                                psel->cpFirst = cpFirst;
                                psel->cpLim = cpLimNew;
                                }
                        }

                pedlFirst = &(**(pwwd->hdndl))[0];
                pedl = pedlLast = &pedlFirst[ dlLim - 1];

                while (pedl >= pedlFirst && (pedl->cpMin > cpLim
                        /* || (dcpAdj < 0 && pedl->cpMin == cpLim) */))
                        { /* Adjust dl's after edit */
                        pedl->cpMin += dcpAdj;
                        pedl--;
                        }

                /* Invalidate dl's containing edit */
                while (pedl >= pedlFirst && (pedl->cpMin + pedl->dcpMac > cpFirst ||
                        (pedl->cpMin + pedl->dcpMac == cpFirst && pedl->fIchCpIncr)))
                        {
                        if (vfInvalid)
                                pedl->fValid = false;
                        if (ww == wwCur) vpedlAdjustCp = pedl;
                        pedl--;
                        }

                if (pedl == pedlLast)
                        continue;       /* Entire edit below ww */

                if (vfInvalid)
                        pwwd->fDirty = fTrue; /* Say ww needs updating */

                if (pedl < pedlFirst)
                        { /* Check for possible cpFirstWw change */
                        if (cpFirstWw > cpLim) /* Edit above ww */
                                pwwd->cpFirst = cpFirstWw + dcpAdj;
                        else if (cpFirstWw + pwwd->dcpDepend > cpFirst)
                                /* Edit includes hot spot at top of ww */
                                {
                                if (cpFirst + dcpIns < cpFirstWw)
                                        {
                                        pwwd->cpFirst = cpFirst;
                                        pwwd->ichCpFirst = 0;
                                        }
                                }
                        else /* Edit doesn't affect cpFirstWw */
                                continue;

                        pwwd->fCpBad = true; /* Say cpFirst inaccurate */
                        DirtyCache(cpFirst); /* Say cache inaccurate */
                        }
                else do
                        { /* Invalidate previous line if necessary */
                        if (pedl->cpMin + pedl->dcpMac + pedl->dcpDepend > cpFirst)
                                {
                                pedl->fValid = fFalse;
                                pwwd->fDirty = fTrue;
                                }
                        else
                                break;
                        } while (pedl-- > pedlFirst);
                }
        }   /* end for */

#if defined(OLE)
    ObjAdjustCps(doc,cpLim,dcpAdj);
#endif

    InvalidateCaches(doc);
    Scribble(2,' ');
}




ReplaceCps(docDest, cpDel, dcpDel, docSrc, cpIns, dcpIns)
int docDest, docSrc;
typeCP cpDel, dcpDel, cpIns, dcpIns;
{ /* General replace routine */
/* Replace dcpDel cp's starting at cpDel in docDest with
        dcpIns cp's starting at cpIns in docSrc. */
register struct PCTB **hpctbDest;
struct PCTB **hpctbSrc;
int ipcdFirst, ipcdLim, ipcdInsFirst, ipcdInsLast;
register struct PCD *ppcdDest;
struct PCD *ppcdIns, *ppcdMac;
typeCP dcpFile, dcpAdj;
int cpcd;

if (ferror) return;
#ifdef ENABLE
if (docRulerSprm != docNil) ClearRulerSprm();
#endif

if (dcpIns == cp0)  /* This is just too easy . . . */
        {
        Replace(docDest, cpDel, dcpDel, fnNil, fc0, fc0);
        return;
        }

#ifdef DEBUG
Assert(docDest != docSrc);
#endif /* DEBUG */

/* Keep the heap handles, because IpcdSplit & PpcdOpen move heap */
hpctbDest = (**hpdocdod)[docDest].hpctb;
hpctbSrc = (**hpdocdod)[docSrc].hpctb;

/* Get the first and last pieces for insertion */
ipcdInsFirst = IpcdFromCp(*hpctbSrc, cpIns);
ipcdInsLast = IpcdFromCp(*hpctbSrc, cpIns + dcpIns - 1);

#ifdef BOGUS        /* No longer have cwHeapFree */
if (cwHeapFree < (ipcdInsLast - ipcdInsFirst + cpcdMaxIncr + 1) * cwPCD + 10)
        {
#ifdef DEBUG
                ErrorWithMsg(IDPMTNoMemory, " edit#2");
#else
                Error(IDPMTNoMemory);
#endif
        return;
        }
#else
if (vfOutOfMemory)
    {
    ferror = TRUE;
    return;
    }
#endif

if (docDest == docCur)
        HideSel();      /* Take down sel before we mess with cp's */

if (dcpDel != cp0)
        { /* Check for deleting EOL */
        AdjParas(docDest, cpDel, docDest, cpDel, dcpDel, fTrue);
        DelFtns(docDest, cpDel, cpDel + dcpDel);  /* Remove footnotes */
        }

if (dcpIns != cp0)
        AdjParas(docDest, cpDel, docSrc, cpIns, dcpIns, fFalse);

/* Get the limiting pieces for deletion (indices because hp moves ) */
ipcdFirst = IpcdSplit(hpctbDest, cpDel);
ipcdLim = (dcpDel == cp0) ? ipcdFirst : IpcdSplit(hpctbDest, cpDel + dcpDel);
if (ferror)
    return;

/* Adjust pctb size; get pointer to the first new piece, ppcdDest, and to the
        first piece we are inserting.  No more heap movement! */
ppcdDest = PpcdOpen(hpctbDest, &(**hpctbDest).rgpcd[ipcdFirst],
    ipcdFirst - ipcdLim + ipcdInsLast - ipcdInsFirst + 1);
ppcdIns = &(**hpctbSrc).rgpcd[ipcdInsFirst];

if (ferror)
        /* Ran out of memory expanding piece table */
    return;

/* Fill first new piece */
blt(ppcdIns, ppcdDest, cwPCD);
ppcdDest->cpMin = cpDel;
ppcdDest->fc += (cpIns - ppcdIns->cpMin);

dcpFile = cpDel - cpIns;
dcpAdj = dcpIns - dcpDel;

/* Fill in rest of inserted pieces */
if ((cpcd = ipcdInsLast - ipcdInsFirst) != 0)
        {
        blt((ppcdIns + 1), (ppcdDest + 1), cwPCD * cpcd);
        while (cpcd--)
                (++ppcdDest)->cpMin += dcpFile;
        }

/* Adjust rest of pieces in destination doc */
ppcdMac = &(**hpctbDest).rgpcd[(**hpctbDest).ipcdMac];
while (++ppcdDest < ppcdMac)
        ppcdDest->cpMin += dcpAdj;
#ifdef DEBUG
/* ShowDocPcd("From ReplaceCps: ", docDest); */
#endif

/* And inform anyone else who cares */
AdjustCp(docDest, cpDel, dcpDel, dcpIns);
/* Copy any footnotes along with their reference marks */

#ifdef FOOTNOTES
{
/* If there are any footnotes call AddFtns */
struct FNTB **hfntbSrc;
if ((hfntbSrc = HfntbGet(docSrc)) != 0)
        AddFtns(docDest, cpDel, docSrc, cpIns, cpIns + dcpIns, hfntbSrc);
}
#endif  /* FOOTNOTES */

#ifdef CASHMERE
{
/* If there are any sections call AddSects */
struct SETB **hsetbSrc;
if ((hsetbSrc = HsetbGet(docSrc)) != 0)
        AddSects(docDest, cpDel, docSrc, cpIns, cpIns + dcpIns, hsetbSrc);
}
#endif

/* Special kludge for graphics paragraphs */
if (dcpIns != dcpDel)
        CheckGraphic(docDest, cpDel + dcpIns);

if (dcpIns != cp0)
        {
        /* may have to merge in font tables */
        MergeFfntb(docSrc, docDest, cpDel, cpDel + dcpIns);
        }

#ifdef DEBUG
/* ShowDocPcd("From ReplaceCps End: ", docDest); */
#endif
}




/* A D J  P A R A S */
AdjParas(docDest, cpDest, docSrc, cpFirstSrc, dcpLimSrc, fDel)
int docDest, docSrc, fDel;
typeCP cpDest, cpFirstSrc, dcpLimSrc;
{   /* Mark display lines showing the section/paragraph containing cpDest
       in docDest as invalid if the range cpFirstSrc through cpLimSrc-1
       in docSrc contains end-of-section/end-of-paragraph marks */


        typeCP cpFirstPara, cpFirstSect;
        typeCP cpLimSrc = cpFirstSrc + dcpLimSrc;

#ifdef CASHMERE     /* In WRITE, the document is one big section */
        CacheSect(docSrc, cpFirstSrc);
        if (cpLimSrc >= vcpLimSectCache)
                { /* Sel includes sect mark */
                typeCP dcp;
                CacheSect(docDest, cpDest);
                dcp = cpDest - vcpFirstSectCache;
                AdjustCp(docDest, vcpFirstSectCache, dcp, dcp);
                }
#endif

        CachePara(docSrc, cpFirstSrc);
        if (cpLimSrc >= vcpLimParaCache)
                { /* Diddling with a para return */
                typeCP dcp, cpLim;
                typeCP cpMacT = (**hpdocdod)[docDest].cpMac;
                typeCP cpFirst;

                if ((cpDest == cpMacT) && (cpMacT != cp0))
                        {
                        CachePara(docDest, cpDest-1);
                        cpLim = cpMacT + 1;
                        }
                else
                        {
                        CachePara(docDest, cpLim = cpDest);
                        }
                cpFirst = vcpFirstParaCache;
/* invalidate at least from cpFirst to cpLim */

/* cpFirst is start of disturbed para in destination doc */
/* next few lines check for effect of the edit on the semi-paragraph after
the last paragraph mark in the document.
Note: cpLimSrc is redefined as the point of insertion if !fDel.
If fDel, Src and Dest documents are the same.
*/
                if (!fDel)
                        cpLimSrc = cpFirstSrc;
                if (cpLimSrc <= cpMacT)
                        {
/* if a paragraph exists at the end of the disturbance, is it the last
semi-paragraph? */
                        CachePara(docDest, cpLimSrc);
                        if (vcpLimParaCache > cpMacT)
/* yes, extend invalidation over the semi-para */
                                cpLim = cpMacT + 1;
                        }
                else
                        cpLim = cpMacT + 1;
                dcp = cpLim - cpFirst;
                AdjustCp(docDest, cpFirst, dcp, dcp);
                }
}






int IcpSearch(cp, rgfoo, cchFoo, bcp, ifooLim)
typeCP cp;
CHAR rgfoo[];
unsigned cchFoo;
unsigned bcp;
unsigned ifooLim;
{ /* Binary search a table for cp; return index of 1st >= cp */
unsigned ifooMin = 0;

while (ifooMin + 1 < ifooLim)
        {
        int ifooGuess = (ifooMin + ifooLim - 1) >> 1;
        typeCP cpGuess;
        if ((cpGuess = *(typeCP *) &rgfoo[cchFoo * ifooGuess + bcp]) < cp)
                ifooMin = ifooGuess + 1;
        else if (cpGuess > cp)
                ifooLim = ifooGuess + 1;
        else
                return ifooGuess;
        }
return ifooMin;
} /* end of  I c p S e a r c h  */





DelFtns(doc, cpFirst, cpLim)
typeCP cpFirst, cpLim;
int doc;
{ /* Delete all footnote text corresponding to refs in [cpFirst:cpLim) */
/* Also delete SED's for section marks. */
struct FNTB **hfntb;

struct SETB **hsetb;

struct PGTB **hpgtb;

struct DOD *pdod;

#ifdef FOOTNOTES
if ((hfntb = HfntbGet(doc)) != 0)
        RemoveDelFtnText(doc, cpFirst, cpLim, hfntb);
#endif  /* FOOTNOTES */

#ifdef CASHMERE
if ((hsetb = HsetbGet(doc)) != 0)
        RemoveDelSeds(doc, cpFirst, cpLim, hsetb);
#endif

pdod = &(**hpdocdod)[doc];
if (pdod->dty == dtyNormal && (hpgtb = pdod->hpgtb) != 0)
        RemoveDelPgd(doc, cpFirst, cpLim, hpgtb);

}



AdjRg(pfoo, cchFoo, bcp, ccp, cp, dcpAdj)
register CHAR *pfoo;
int cchFoo, bcp, ccp;
typeCP cp, dcpAdj;
{ /* Adjust cp's in an array */
pfoo += bcp;
while (ccp-- && *(typeCP *)((pfoo -= cchFoo)) >= cp)
        *(typeCP *)(pfoo) += dcpAdj;
}




DeleteSel()
{ /* Delete a selection */
typeCP cpFirst;
typeCP cpLim;
typeCP dcp;

cpFirst = selCur.cpFirst;
cpLim = selCur.cpLim;

NoUndo();   /* We don't want any combining of adjacents for this operation */
SetUndo(uacDelNS, docCur, cpFirst, dcp = cpLim - cpFirst,
    docNil, cpNil, cp0, 0);
Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
vfSeeSel = true;
vfPictSel = false;
return ferror;
}




FWriteOk( fwc )
int fwc;
{   /* Test whether the edit operation specified by fwc is acceptable.
       Assume the operation is to be performed on selCur in docCur.
       Return TRUE if the operation is acceptable; FALSE otherwise */
extern int vfOutOfMemory;

return !vfOutOfMemory;
}




/* S E T  U N D O */
SetUndo(uac, doc, cp, dcp, doc2, cp2, dcp2, itxb)
int uac, doc, doc2;
typeCP cp, dcp, cp2, dcp2;
short itxb;
{/* Set up the UNDO structure, vuab, in response to an editing operation */
        struct DOD *pdod, *pdodUndo;

       /* Group delete operations together with adjacent deletes or replaces */
       /* WRITE needs the replace case since AlphaMode is treated as a big */
       /* replace operation */

        if (uac == uacDelNS && doc == vuab.doc)
            {
            if ((vuab.uac == uacDelNS) || (vuab.uac == uacReplNS))
                {
                typeCP cpUndoAdd;

                if (cp == vuab.cp)
                    {
                    cpUndoAdd = CpMacText( docUndo  );
                    goto UndoAdd;
                    }
                else if (cp + dcp == vuab.cp)
                    {
                    cpUndoAdd = cp0;
UndoAdd:            ReplaceCps( docUndo, cpUndoAdd, cp0, doc, cp, dcp );
                    if (vuab.uac == uacDelNS)
                        vuab.dcp += dcp;
                    else
                        vuab.dcp2 += dcp;
                    goto SURet;
                    }
                else if (vuab.uac == uacReplNS && cp == vuab.cp + vuab.dcp)
                    {   /* Special case for combining insertions --
                           do not start a new undo operation if a null
                           deletion is done at the end of an existing replace */
                    if (dcp == cp0)
                        return;
                    }
                }
            }

        /* Group insertions together with adjacent ins's and replaces */

        if (uac == uacInsert && doc == vuab.doc)
                {/* check for adjacent inserts */
                /* Because we can be popped out of Alpha Mode so easily
                   in WRITE, we try to be smarter about combining adjacent
                   insert operations */
                if (vuab.uac == uacInsert || vuab.uac == uacReplNS)
                    {
                    if (cp == vuab.cp + vuab.dcp)
                        {
                        vuab.dcp += dcp;
                        goto SURet;
                        }
                    }
                else if (cp == vuab.cp)
                        switch(vuab.uac)
                                {
                        default:
                                break;
                        case uacDelNS:
                                vuab.dcp2 = vuab.dcp;
                                vuab.uac = uacReplNS;
                                goto repl;
                        case uacDelBuf:
                                vuab.uac = uacReplBuf;
                                goto repl;
                        case uacDelScrap:
                                vuab.uac = uacReplScrap;
            repl:
                                vuab.dcp = dcp;
                                SetUndoMenuStr(IDSTRUndoEdit);
                                goto SURet;
                                }
                }

#ifndef CASHMERE
        /* The use of vuab.itxb is a kludge to determine if the undo block is
        for a ruler change or an undone ruler change. */
        if (uac == uacRulerChange && vuab.uac == uacRulerChange && doc ==
          vuab.doc && cp == vuab.cp && vuab.itxb == 0)
                {
                /* The undo action block for the ruler change is already set. */
                vuab.dcp = CpMax(dcp, vuab.dcp);
                goto SURet;
                }
#endif /* not CASHMERE */

        vuab.doc = doc;
        vuab.cp = cp;
        vuab.dcp = dcp;
        vuab.doc2 = doc2;
        vuab.cp2 = cp2;
        vuab.dcp2 = dcp2;
        vuab.itxb = itxb;
        /*idstrUndoBase = IDSTRUndoBase;*/
        switch (vuab.uac = uac)
                { /* Save deleted text if necessary */
        default:
                SetUndoMenuStr(IDSTRUndoEdit);
                break;
        case uacDelScrap:
        case uacReplScrap:
                /* Two-level edit; save scrap */
                {
                extern int vfOwnClipboard;

                if ( vfOwnClipboard )
                    {
                    ClobberDoc( docUndo, docScrap, cp0,
                                CpMacText( docScrap ) );
                    }
                else
                    ClobberDoc(docUndo, docNil, cp0, cp0);

                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(uac == uacDelScrap ? IDSTRUndoCut :*/
/*                                                  IDSTRUndoPaste);*/
                break;
                }
        case uacDelNS:
                /* One-level edit; save deleted text */
                ClobberDoc(docUndo, doc, cp, dcp);
                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(IDSTRUndoCut);*/
                break;
        case uacReplNS:
                /* One-level edit; save deleted text */
                ClobberDoc(docUndo, doc, cp, dcp2);
                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(IDSTRUndoPaste);*/
                break;
        case uacPictSel:
                ClobberDoc(docUndo, doc, cp, dcp);
                SetUndoMenuStr(IDSTRUndoEdit);
/*              SetUndoMenuStr(IDSTRUndoPict);*/
                break;
        case uacChLook:
        case uacChLookSect:
                SetUndoMenuStr(IDSTRUndoLook);
                break;

#ifndef CASHMERE
        case uacFormatTabs:
                ClobberDoc(docUndo, doc, cp, dcp);
                SetUndoMenuStr(IDSTRUndoBase);
                break;
        case uacRepaginate:
        case uacFormatSection:
                ClobberDoc(docUndo, doc, cp, dcp);
                if ((**hpdocdod)[doc].hpgtb)
                    { /* copy page table over if there is one */
                    int cw = cwPgtbBase + (**(**hpdocdod)[doc].hpgtb).cpgdMax * cwPGD;
                    CopyHeapTableHandle(hpdocdod,
                        (sizeof(struct DOD) * doc) + BStructMember(DOD, hpgtb),
                        (sizeof(struct DOD) * docUndo) + BStructMember(DOD, hpgtb),
                        cw);
                    }
                SetUndoMenuStr(IDSTRUndoBase);
                break;
        case uacRulerChange:
                ClobberDoc(docUndo, doc, cp, dcp2);
                SetUndoMenuStr(IDSTRUndoLook);
/*              SetUndoMenuStr(IDSTRUndoRuler);*/
                break;
#endif /* not CASHMERE */

#ifdef UPDATE_UNDO
#if defined(OLE)
        case uacObjUpdate:
            ClobberDoc(docUndo, docNil, cp0, cp0);
            SetUndoMenuStr(IDSTRObjUndo);
        break;
#endif
#endif
                }

        if (doc != docNil)
                {
                pdod = &(**hpdocdod)[doc];
                pdodUndo = &(**hpdocdod)[docUndo];
                pdodUndo->fDirty = pdod->fDirty;
                pdodUndo->fFormatted = pdod->fFormatted;
                if (uac != uacReplScrap)
                /* If SetUndo is called with uacReplScrap, = COPY SCRAP */
                        pdod->fDirty = true;
                }
#ifdef BOGUSCS
        if (uac == uacMove)
                CheckMove();
#endif
SURet:
        if (ferror) NoUndo();

        return;
}




/* C L O B B E R  D O C */
ClobberDoc(docDest, docSrc, cp, dcp)
int docDest, docSrc;
typeCP cp, dcp;
{ /* Replace contents of docDest with docSrc[cp:dcp] */

extern int docScrap;
extern int vfOwnClipboard;
struct FFNTB **hffntb;
struct SEP **hsep;
struct TBD (**hgtbd)[];

register int bdodDest=sizeof(struct DOD)*docDest;
register int bdodSrc=sizeof(struct DOD)*docSrc;

#define dodDest (*((struct DOD *)(((CHAR *)(*hpdocdod))+bdodDest)))
#define dodSrc  (*((struct DOD *)(((CHAR *)(*hpdocdod))+bdodSrc)))

        /* clear out dest doc's font table - it will get a copy of source's */
        hffntb = HffntbGet(docDest);
        dodDest.hffntb = 0;

        /* this does nothing if hffntb is NULL (5.15.91) v-dougk */
        FreeFfntb(hffntb);

        SmashDocFce(docDest);   /* font cache entries can't refer to it by doc
                                   any more */

        /* this does nothing (code stubbed out) (5.15.91) v-dougk */
        ZeroFtns(docDest); /* So ReplaceCps doesn't worry about them */

        ReplaceCps(docDest, cp0, dodDest.cpMac, docSrc, cp, dcp);

        /* Copy section properties and tab table, both of which are
           document properties in MEMO */
        CopyHeapTableHandle( hpdocdod,
                             ((docSrc == docNil) ? -1 :
                                 bdodSrc + BStructMember( DOD, hsep )),
                             bdodDest + BStructMember( DOD, hsep ),
                             cwSEP );
        CopyHeapTableHandle( hpdocdod,
                             ((docSrc == docNil) ? -1 :
                                 bdodSrc + BStructMember( DOD, hgtbd )),
                             bdodDest + BStructMember( DOD, hgtbd ),
                             cwTBD * itbdMax );
}




CopyHeapTableHandle( hBase, bhSrc, bhDest, cwHandle )
CHAR **hBase;
register int bhSrc;
register int bhDest;
int cwHandle;
{       /* Copy cwHandle words of contents from a handle located at
           offset (in bytes) bhSrc from the beginning of heap object
           hBase to a handle located at bhDest from the same base. If the
           destination handle is non-NULL, free it first.
           If bhSrc is negative, free the destination, but do not copy */

int **hT;

#define hSrc    (*((int ***) ((*hBase)+bhSrc)))
#define hDest   (*((int ***) ((*hBase)+bhDest)))

if (hDest != NULL)
    {
    FreeH( hDest );
    hDest = NULL;
    }

if ( (bhSrc >= 0) && (hSrc != NULL) &&
                     !FNoHeap( hT = (int **)HAllocate( cwHandle )))
     {
     blt( *hSrc, *hT, cwHandle );
     hDest = hT;
     }

#undef hSrc
#undef hDest
}



ZeroFtns(doc)
{ /* Remove all footnote & section references from doc */
struct FNTB **hfntb;
struct SETB **hsetb;

#ifdef FOOTNOTES
        if ((hfntb = HfntbGet(doc)) != 0)
                {
                FreeH(hfntb);
                (**hpdocdod)[doc].hfntb = 0;
                }
#endif  /* FOOTNOTES */
#ifdef CASHMERE
        if ((hsetb = HsetbGet(doc)) != 0)
                {
                FreeH(hsetb);
                (**hpdocdod)[doc].hsetb = 0;
                }
#endif
}



fnClearEdit(int nInsertingOver)

{   /* CLEAR command entry point: Delete the current selection */

/** 
    NOTE: as of this comment, this is used:
    1)  when typing over a selection (AlphaMode() in insert.c)
    2)  when Pasting over a selection (fnPasteEdit in clipboard.c)
    3)  when pressing the delete key
    4)  for InsertObject (obj3.c)
    5)  for DragDrop (obj3.c)
    6)  Clear header/footer (running.c)

    A similar sequence occurs when cutting to the clipboard
    (fnCutEdit in clipbord.c).

    Also see copying to clipboard (fnCopyEdit in clipbord.c).

    (8.29.91) v-dougk
**/

    if (!FWriteOk( fwcDelete ))
        return TRUE;

    if (selCur.cpFirst < selCur.cpLim)
    {
#if defined(OLE)

        /* this'll prevent us from deleting open embeds */
        if (!ObjDeletionOK(nInsertingOver))
            return TRUE;

         /* close open links */
        ObjEnumInRange(docCur,selCur.cpFirst,selCur.cpLim,ObjCloseObjectInDoc);
#endif

        return DeleteSel();
    }
    return FALSE;
}



MergeFfntb(docSrc, docDest, cpMin, cpLim)
/* determines if the two docs font tables differ to the extent that we need
   to apply a mapping sprm to the specified cp's */

int docSrc, docDest;
typeCP cpMin, cpLim;
{
struct FFNTB **hffntb;
int cftcDiffer, ftc, iffn;
struct FFN *pffn;
CHAR rgbSprm[2 + 256];
CHAR rgbFfn[ibFfnMax];

hffntb = HffntbGet(docSrc);
if (hffntb != 0)
        {
        cftcDiffer = 0;
        for (iffn = 0; iffn < (*hffntb)->iffnMac; iffn++)
                {
                pffn = *(*hffntb)->mpftchffn[iffn];
                bltbyte(pffn, rgbFfn, CbFromPffn(pffn));
                ftc = FtcChkDocFfn(docDest, rgbFfn);
                if (ftc != iffn)
                        cftcDiffer++;
                rgbSprm[2+iffn] = ftc;
                if (ftc == ftcNil)
                        /* we're stuck! */
                        return;
                }

        if (cftcDiffer == 0)
                /* new font table is a superset, & all the old font table's
                   ftc's matched exactly - no need to do anything */
                return;

        rgbSprm[0] = sprmCMapFtc;
        rgbSprm[1] = (*hffntb)->iffnMac;

        /* here goes - apply the mapping */
        AddSprmCps(rgbSprm, docDest, cpMin, cpLim);
        }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\editpgtb.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NOHDC
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "str.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "debug.h"

extern struct FCB       (**hpfnfcb)[];
int                     **HAllocate();




RemoveDelPgd(doc, cpFirst, cpLim, hpgtb)
int doc;
typeCP cpFirst, cpLim;
struct PGTB **hpgtb;
{
struct PGTB *ppgtb;
struct PGD *ppgd, *ppgdT;
int ipgd, cpgd, cpgdDel;

        {
        ppgtb = *hpgtb;
        ppgd = &ppgtb->rgpgd[0];
        ppgd += (ipgd =
            IcpSearch(cpFirst + 1, ppgd, cwPGD * sizeof(int),
                         bcpPGD, cpgd = ppgtb->cpgd));

        if (ppgd->cpMin > cpFirst) /* Ensure not past last page */
                { /* Find all page breaks in deleted area. */
                for (ppgdT = ppgd, cpgdDel = 0;
                    ipgd + cpgdDel < cpgd && ppgdT->cpMin <= cpLim;
                      ppgdT++, cpgdDel++)
                        continue;

                if (cpgdDel != 0)
                        { /* Close up pgtb. */
                        blt(ppgdT, ppgd, cwPGD * ((cpgd -= cpgdDel) - ipgd));
                        (*hpgtb)->cpgd = cpgd;
                        }
                }
        }
} /* end of  R e m o v e D e l P g d  */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\editsect.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM

#include <windows.h>

/*#include "toolbox.h"*/
#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "str.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "debug.h"

extern int              docMode;
extern struct FCB       (**hpfnfcb)[];

int                     **HAllocate();



#ifdef CASHMERE     /* Only if we support multiple sections */
AddSects(docDest, cpDest, docSrc, cpFirst, cpLim, hsetbSrc)
int docDest, docSrc;
typeCP cpDest, cpFirst, cpLim;
struct SETB **hsetbSrc;
{ /* Add SED's to correspond with inserted section marks */
/* Called after inserting docSrc[cpFirst:cpLim) into docDest@cpDest */
struct SETB *psetbSrc, **hsetbDest, *psetbDest;
struct SED *psedSrc, *psedDest;
int csedDest, isedSrc, csedIns, isedDest;


psedSrc = &(psetbSrc = *hsetbSrc)->rgsed[0];
psedSrc += (isedSrc = IcpSearch(cpFirst + 1, psedSrc,
    cchSED, bcpSED, psetbSrc->csed));

/* Find all section marks in inserted area. */
for (csedIns = 0; psedSrc->cp <= cpLim; psedSrc++, csedIns++)
        ;

if (csedIns != 0)
        { /* Insert sed's. */
        /* Ensure destination setb large enough */
        /* HEAP MOVEMENT */
        if (FNoHeap(hsetbDest = HsetbEnsure(docDest, csedIns)))
                return;
        psedDest = &(psetbDest = *hsetbDest)->rgsed[0];

        /* Find ised to insert new sed's */
        psedDest += (isedDest = IcpSearch(cpDest + 1, psedDest,
              cchSED, bcpSED, csedDest = psetbDest->csed));

        /* Insert new sed's */
        psedSrc = &(psetbSrc = *hsetbSrc)->rgsed[isedSrc];
        psetbDest->csed += csedIns;     /* Update sed count */
        blt(psedDest, psedDest + csedIns,
            cwSED * (csedDest - isedDest)); /* Open up setb */
        blt(psedSrc, psedDest, cwSED * csedIns);
        while (csedIns--)
                (psedDest++)->cp = cpDest + (psedSrc++)->cp - cpFirst;
        }
} /* end of  A d d S e c t s  */
#endif  /* CASHMERE */



#ifdef CASHMERE     /* Only if we support separate sections */
RemoveDelSeds(doc, cpFirst, cpLim, hsetb)
int doc;
typeCP cpFirst, cpLim;
struct SETB **hsetb;
{
struct SETB *psetb;
struct SED *psed, *psedT;
int ised, csed, csedDel;

        {
        psetb = *hsetb;
        psed = &psetb->rgsed[0];
        psed += (ised =
            IcpSearch(cpFirst + 1, psed, cchSED, bcpSED, csed = psetb->csed));

        /* Find all section marks in deleted area. */
        for (psedT = psed, csedDel = 0; psedT->cp <= cpLim; psedT++, csedDel++)
                ;

        Assert(ised + csedDel < csed);

        if (csedDel != 0)
                { /* Close up setb. */
                blt(psedT, psed, cwSED * ((csed -= csedDel) - ised));
                (*hsetb)->csed = csed;
                docMode = docNil;
                }
        }
} /* end of  R e m o v e D e l S e d s  */
#endif      /* CASHMERE */



#ifdef CASHMERE     /* This loads a complete section table */
struct SETB **HsetbCreate(fn)
int fn;
{ /* Create a section table from a formatted file */

struct SETB *psetbFile;
typePN pn;
int cchT;
int csed, ised;
struct SETB **hsetb;
int *pwSetb;
int cw;
struct SED *psed;

Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);

if ((pn = (**hpfnfcb)[fn].pnSetb) == (**hpfnfcb)[fn].pnBftb)
        return (struct SETB **) 0;
psetbFile = (struct SETB *) PchGetPn(fn, pn, &cchT, false);
if ((csed = psetbFile->csed) == 0)
        return (struct SETB **)0;

hsetb = (struct SETB **) HAllocate(cw = cwSETBBase + csed * cwSED);
if (FNoHeap(hsetb))
        return (struct SETB **)hOverflow;
pwSetb = (int *) *hsetb;

blt(psetbFile, pwSetb, min(cwSector, cw));

while ((cw -= cwSector) > 0)
        { /* Copy the sed's to heap */
        blt(PchGetPn(fn, ++pn, &cchT, false), pwSetb += cwSector,
            min(cwSector, cw));
        }

for (ised = 0, psed = &(**hsetb).rgsed[0]; ised < csed; ised++, psed++)
        psed->fn = fn;

(**hsetb).csedMax = csed;
return hsetb;
} /* end of  H s e t b C r e a t e  */
#endif  /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\editftn.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

/*#include "toolbox.h"*/
#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "str.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "debug.h"

extern struct DOD (**hpdocdod)[];
extern struct FCB       (**hpfnfcb)[];
extern int      wwMac;
extern struct WWD rgwwd[];
extern struct WWD *pwwdCur;
extern int **HAllocate();
extern int docCur;
extern typeCP cpMacCur;
extern struct SEL selCur;
extern int ferror;





#ifdef FOOTNOTES
AddFtns(docDest, cpDest, docSrc, cpFirst, cpLim, hfntbSrc)
int docDest, docSrc;
typeCP cpDest, cpFirst, cpLim;
struct FNTB **hfntbSrc;
{ /* Add footnote text to coppespond with inserted references */
/* Called after inserting docSrc[cpFirst:cpLim) into docDest@cpDest */
struct FNTB *pfntbSrc, **hfntbDest, *pfntbDest;
struct FND *pfndSrc, *pfndDest;
int cfndDest, ifndSrc, cfndIns, ifndDest;
typeCP cpFtnSrc, dcpFtn, cpFtnDest;
typeCP dcp;

if ((pfndSrc = &(pfntbSrc = *hfntbSrc)->rgfnd[0])->cpFtn <= cpFirst)
        return; /* No footnotes or source text is inside ftns */

pfndSrc += (ifndSrc = IcpSearch(cpFirst, pfndSrc,
    cchFND, bcpRefFND, pfntbSrc->cfnd));
cpFtnSrc = pfndSrc->cpFtn;

/* Find all references in inserted area. */
for (cfndIns = 0; pfndSrc->cpRef < cpLim; pfndSrc++, cfndIns++)
        ;

if (cfndIns != 0)
        { /* Insert footnote text and fnd's. */
        dcpFtn = pfndSrc->cpFtn - cpFtnSrc; /* Length of ftn texts */

        /* Ensure destination fntb large enough */
        /* HEAP MOVEMENT */
        if (FNoHeap(hfntbDest = HfntbEnsure(docDest, cfndIns)))
                return;
        if ((pfndDest = &(pfntbDest = *hfntbDest)->rgfnd[0])->cpFtn <= cpDest)
                { /* Inserting refs inside footnotes? No way! */
                Error(IDPMTFtnLoad);
                return;
                }

        /* Find ifnd to insert new fnd's */
        ifndDest = IcpSearch(cpDest, pfndDest,
              cchFND, bcpRefFND, cfndDest = pfntbDest->cfnd);

        /* Insert new footnote text */
        /* HEAP MOVEMENT */
        ReplaceCps(docDest, cpFtnDest = (pfndDest + ifndDest)->cpFtn, cp0,
            docSrc, cpFtnSrc, dcpFtn);
        if (ferror)
            return;

        /* Insert new fnd's */
        pfndSrc = &(pfntbSrc = *hfntbSrc)->rgfnd[ifndSrc];
        pfndDest = &(pfntbDest = *hfntbDest)->rgfnd[ifndDest];
        pfntbDest->cfnd += cfndIns;     /* Update fnd count */
        pfndDest->cpFtn += dcpFtn; /* AdjustCp considers the insertion to be
                                        part of this footnote; correct it. */
        blt(pfndDest, pfndDest + cfndIns,
            cwFND * (cfndDest - ifndDest)); /* Open up fntb */
        while (cfndIns--)
                { /* Copy fnd's */
                pfndDest->cpRef = cpDest + pfndSrc->cpRef - cpFirst;
                (pfndDest++)->cpFtn =
                    cpFtnDest + (pfndSrc++)->cpFtn - cpFtnSrc;
                }
        /* Invalidate dl's of later ftn refs */
        dcp = (**hfntbDest).rgfnd[0].cpFtn - ccpEol - cpDest;
        AdjustCp(docDest, cpDest, dcp, dcp);
        RecalcWwCps();
        }
}
#endif  /* FOOTNOTES */




#ifdef FOOTNOTES
/* R E M O V E  D E L  F T N  T E X T */
RemoveDelFtnText(doc, cpFirst, cpLim, hfntb)
int doc;
typeCP cpFirst,cpLim;
struct FNTB **hfntb;
/* Remove the text of footnotes that are contained in the selection that is
    delimited by cpFirst and CpLim  */
{
        struct FNTB *pfntb;
        struct FND *pfnd, *pfndT;
        int cfnd, ifnd, cfndDel;

        if  ((pfnd = &(pfntb = *hfntb)->rgfnd[0])->cpFtn > cpFirst)
                {
                pfnd += (ifnd =
                     IcpSearch(cpFirst, pfnd, cchFND, bcpRefFND, cfnd = pfntb->cfnd));

                /* Find all references in deleted area. */
                for (pfndT = pfnd, cfndDel = 0; pfndT->cpRef < cpLim; pfndT++, cfndDel++)
                        ;

#ifdef DEBUG
                Assert(ifnd + cfndDel < cfnd);
#endif

                if (cfndDel != 0)
                        { /* Delete footnote text and close up fntb. */
                        typeCP cpDel = pfnd->cpFtn;
                        blt(pfndT, pfnd, cwFND * ((cfnd -= cfndDel) - ifnd));
                        (*hfntb)->cfnd = cfnd;
                        /* HEAP MOVEMENT */
                        Replace(doc, cpDel, pfnd->cpFtn - cpDel, fnNil, fc0, fc0);
                        if (cfnd == 1)
                                {

                                Replace(doc,  (**hpdocdod)[doc].cpMac - ccpEol,
                                    (typeCP) ccpEol, fnNil, fc0, fc0);
                                FreeH((**hpdocdod)[doc].hfntb);
                                (**hpdocdod)[doc].hfntb = 0;
/* fix selCur twisted by AdjustCp. Another AdjustCp still pending. */
                                if (doc == docCur && !pwwdCur->fFtn)
                                        {
                                        selCur.cpFirst = selCur.cpLim = cpLim;
                                        cpMacCur = (**hpdocdod)[doc].cpMac;
                                        }
                                }
                        else
                                { /* Invalidate dl's of later ftn refs */
                                typeCP dcp = (**hfntb).rgfnd[0].cpFtn -
                                    ccpEol - cpLim;
                                AdjustCp(doc, cpLim, dcp, dcp);
                                }
                        }
                }
}
#endif  /* FOOTNOTES */



#ifdef FOOTNOTES
struct FNTB **HfntbCreate(fn)
int fn;
{ /* Create a footnote table from a formatted file */
struct FNTB *pfntbFile;
typePN pn;
int cchT;

int cfnd;
struct FNTB **hfntb;
int *pwFntb;
int cw;

#ifdef DEBUG
Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);
#endif
if ((pn = (**hpfnfcb)[fn].pnFntb) == (**hpfnfcb)[fn].pnSep)
        return 0;
pfntbFile = (struct FNTB *) PchGetPn(fn, pn, &cchT, false);
if ((cfnd = pfntbFile->cfnd) == 0)
        return (struct FNTB **)0;

hfntb = (struct FNTB **) HAllocate(cw = cwFNTBBase + cfnd * cwFND);
if (FNoHeap(hfntb))
        return (struct FNTB **)hOverflow;

pwFntb = (int *) *hfntb;

blt(pfntbFile, pwFntb, min(cwSector, cw));

while ((cw -= cwSector) > 0)
        { /* Copy the fnd's to heap */
        blt(PchGetPn(fn, ++pn, &cchT, false), pwFntb += cwSector,
            min(cwSector, cw));
        }

(*hfntb)->cfndMax = cfnd;
return hfntb;
}
#endif  /* FOOTNOTES */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\editdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define ipcdNil         -1  /* Error return from IpcdSplit */

#define cpcdChunk       5
#define cpcdInit        5
#define cpcdMaxIncr     10

#define dcpAvgWord      10
#define dcpAvgSent      100

#include "prmdefs.h"

struct PCD
        {
        typeCP          cpMin;
        unsigned        fNoParaLast     : 1;
        unsigned        fn              : 15;
        typeFC          fc;
        struct PRM      prm;
        };

#define cwPCD   (sizeof (struct PCD) / sizeof (int))
#define cbPCD   (sizeof (struct PCD))
#define bcpPCD  0

struct PCTB
        {
        unsigned        ipcdMax;
        unsigned        ipcdMac;
        struct PCD      rgpcd[cpcdInit];
        };

#define cwPCTBInit     (sizeof (struct PCTB) / sizeof (int))
#define cbPCTBInit     (sizeof (struct PCTB))

struct UAB
        { /* UNDO Action Block */
        int             uac;    /* UNDO Action Code (see cmddefs.h) */
        int             doc;
        typeCP          cp;
        typeCP          dcp;
        int             doc2;
        typeCP          cp2;
        typeCP          dcp2;
        short         itxb;
        };


struct PCD *PpcdFromCp();

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\ffdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

struct IFI
	{
	int             xp;
	int             xpLeft;
	int             xpRight;
	int             xpReal;
	int		xpPr;
	int		xpPrRight;
	int             ich;
	int             ichLeft;
	int             ichPrev;
	int             ichFetch;
	int             dypLineSize;
	int             cchSpace;
	int             cBreak;
	int             chBreak;
	int             jc;

#ifdef CASHMERE
	int             tlc;
#endif /* CASHMERE */

	int             fPrevSpace;
	};

#define cwIFI   (sizeof (struct IFI) / sizeof (int))

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\file.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* file.c -- WRITE file interface functions */
/* It is important that the external interface to this module be entirely
   at the level of "fn's", not "osfn's" and/or "rfn's".  An intermodule call
   may cause our files to be closed, and this is the only module internally
   capable of compensating for this */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSMETRICS
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOGDI
#define NOHDC
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMSG
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "docdefs.h"
#include "filedefs.h"
#define NOSTRUNDO
#include "str.h"
#include "debug.h"


extern int						vfDiskFull;
extern int						vfSysFull;
extern int						vfnWriting;
extern CHAR						(*rgbp)[cbSector];
extern typeTS					tsMruRfn;
extern struct BPS				*mpibpbps;
extern int						ibpMax;
extern struct FCB				(**hpfnfcb)[];
extern typeTS					tsMruBps;
extern struct ERFN				dnrfn[rfnMax];
extern int						iibpHashMax;
extern CHAR						*rgibpHash;
extern int						rfnMac;
extern int						ferror;
extern CHAR						szWriteDocPrompt[];
extern CHAR						szScratchFilePrompt[];
extern CHAR						szSaveFilePrompt[];


#ifdef CKSM
#ifdef DEBUG
extern unsigned					(**hpibpcksm) [];
extern int						ibpCksmMax;
#endif
#endif


#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax


#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#define ErrorWithMsg( idpmt, szModule )			Error( idpmt )
#define DiskErrorWithMsg( idpmt, szModule )		DiskError( idpmt )
#endif


#define osfnNil (-1)

STATIC int near  RfnGrab( void );
STATIC int near  FpeSeekFnPn( int, typePN );
STATIC typeOSFN near  OsfnEnsureValid( int );
STATIC typeOSFN near  OsfnReopenFn( int );
STATIC CHAR *(near SzPromptFromFn( int ));

/* The following debug flags are used to initiate, during debug, specific
   low-level disk errors */

#ifdef DEBUG
int vfFakeReadErr = 0;
int vfFakeWriteErr = 0;
int vfFakeOpenErr = 0;
#endif


#ifdef CKSM
#ifdef DEBUG
unsigned CksmFromIbp( ibp )
int ibp;
{
 int cb = mpibpbps [ibp].cch;
 unsigned cksm = 0;
 CHAR *pb;

 Assert( ibp >= 0 && ibp < ibpCksmMax );
 Assert( mpibpbps [ibp].fn != fnNil );
 Assert( !mpibpbps [ibp].fDirty );

 pb = rgbp [ibp];
 while (cb-- > 0)
	cksm += *(pb++);

 return cksm;
}
#endif
#endif



typeFC FcMacFromUnformattedFn( fn )
int fn;
{	/* Obtain fcMac for passed unformatted fn by seeking to the file's end.
       If it fails, return -1
       If it succeeds, return the fcMac */
 typeFC fcMac;
 typeOSFN osfn;

 Assert( (fn != fnNil) && (!(**hpfnfcb) [fn].fFormatted) );

 if ((osfn = OsfnEnsureValid( fn )) == osfnNil)
	return (typeFC) -1;
 else
	{
	if ( FIsErrDwSeek( fcMac=DwSeekDw( osfn, 0L, SF_END )))
		{
		if (fcMac == fpeBadHndError)
			{	/* Windows closed the file for us */
			if ( ((osfn = OsfnReopenFn( fn )) != osfnNil) &&
                 !FIsErrDwSeek( fcMac = DwSeekDw( osfn, 0L, SF_END )) )
					/* Successfully re-opened file */
				return fcMac;
			}
		if (FIsCaughtDwSeekErr( fcMac ))
				/* Suppress reporting of error -- Windows did it */
			ferror = TRUE;
		DiskErrorWithMsg(IDPMTSDE, " FcMacFromUnformattedFn");
		return (typeFC) -1;
		}
	}

return fcMac;
}




IbpLru(ibpStarting)
int ibpStarting;
/*
		Description:	Find least recently used BPS (Buffer page) starting
						at slot ibpStarting.
		Returns:		Number of the least recently used buffer slot.
*/
{
		int ibp, ibpLru = 0;
		typeTS ts, tsLru;
		struct BPS *pbps = &mpibpbps[ibpStarting];

		tsLru = -1;		/* Since time stamps are unsigned ints, -1 */
						/* is largest time stamp. */
		for(ibp = ibpStarting; ibp < ibpMax; ibp++, pbps++)
				{
				ts = pbps->ts - (tsMruBps + 1);
				/* The time stamp can conceivably wrap around and thus a */
				/* simple < or > comparison between time stamps cannot be */
				/* used to determine which is more or less recently used. */
				/* The above statement normalizes time stamps so that the */
				/* most recently used is FFFF and the others fall between */
				/* 0 and FFFE.	This method makes the assumption that */
				/* time stamps older than 2^16 clicks of the time stamp */
				/* counter have long since disappeared.  Otherwise, such */
				/* ancients would appear to be what they are not. */
				if (ts <= tsLru) {tsLru = ts; ibpLru = ibp;}
				}
		return(ibpLru);
}




int IbpMakeValid(fn, pn)
int fn;
typePN pn;
{ /*
		Description:	Get page pn of file fn into memory.
						Assume not already in memory.
		Returns:		Bp index (buffer slot #) where the page resides
						in memory.
  */
#define cbpClump		4

#define cpnAlign		4
#define ALIGN

int ibpT, cbpRead;
int ibp, iibpHash, ibpPrev;
typePN pnT;
register struct BPS *pbps;
int ibpNew;
int cch;
int fFileFlushed;
#ifdef ALIGN
int dibpAlign;
#endif

#ifdef DEBUG
 int cbpReadT;
 CheckIbp();
#endif /* DEBUG */
 Assert(fn != fnNil);

/* page is not currently in memory */

/* We will try to read in cbpClump Buffer Pages beginning with the
   least recently used */

 /* Pick best starting slot for read based on a least-recently-used scheme */

 if (vfnWriting != fnNil)
		/* Currently saving file, favor adjacent slots for fn being written  */
	ibpNew = IbpWriting( fn );
 else
		/* If reading from the scratch file, do not use the first
           cpbMustKeep slots. This is necessary to prevent a disk full
           condition from being catastrophic. */
	ibpNew = IbpLru( (fn == fnScratch) ? cbpMustKeep : 0 );


 /* Empty the slots by flushing out ALL buffers holding pieces of their fn's */
 /* Compute cbpRead */
 pbps = &mpibpbps[ ibpNew ];
 for ( cbpRead = 0;  cbpRead < min( cbpClump, ibpMax - ibpNew );
                                                       cbpRead++, pbps++ )
	{
#ifdef CKSM
#ifdef DEBUG
	int ibpT = pbps - mpibpbps;

	if (!pbps->fDirty && pbps->fn != fnNil)
		Assert( (**hpibpcksm) [ibpT] == CksmFromIbp( ibpT ) );
#endif
#endif
	if (pbps->fDirty && pbps->fn != fnNil)
		if (!FFlushFn( pbps->fn ))
			break;
	}

 /* If a flush failed, cbpRead was reduced. If it was reduced to 0, this
	is serious. If the file was not fnScratch, we can consider it flushed
	even though the flush failed, because upper-level procedures will detect
	the error and cancel the operation. If it was fnScratch, we must obtain
	a new slot for the page we are trying to read */
 if (cbpRead == 0)
	{
	if (pbps->fn == fnScratch)
		ibpNew = IbpFindSlot( fn );
	cbpRead++;
	}
 else
	{	/* Restrict cbpRead according to the following:
				(1) If we are reading in the text area, we don't want to
					free pages for stuff past the end of the text area
					that we know CchPageIn won't give us
				(2) If we are reading in the properties area, we only want to
					read one page, because FetchCp depends on us not trashing
					the MRU page */
	struct FCB *pfcb = &(**hpfnfcb)[fn];

	if (pfcb->fFormatted && fn != fnScratch && pn >= pfcb->pnChar)
		cbpRead = 1;
	else
		{
		typePN cbpValid = (pfcb->fcMac - (pn * cfcPage)) / cfcPage;

		cbpRead = min( cbpRead, max( 1, cbpValid ) );
		}
	}

#ifdef ALIGN
     /* Align the read request on an even sector boundary, for speed */
 dibpAlign = (pn % cpnAlign);
 if (cbpRead > dibpAlign)
		/* We are reading enough pages to cover the desired one */
	pn -= dibpAlign;
 else
	dibpAlign = 0;
#endif

	/* Remove flushed slots from their hash chains */
 for ( pbps = &mpibpbps[ ibpT = ibpNew + cbpRead - 1 ];
       ibpT >= ibpNew;
       ibpT--, pbps-- )
	if (pbps->fn != fnNil)
		FreeBufferPage( pbps->fn, pbps->pn );

	/* Free slots holding any existing copies of pages to be read */
#ifdef	DBCS				/* was in KKBUGFIX */
/*	In #else code ,If pn= 8000H(= -32768), pnT can not be littler than pn */
 for ( pnT = pn + cbpRead; pnT > pn; pnT-- )		// Assume cbpRead > 0
	FreeBufferPage( fn, pnT-1 );
#else
 for ( pnT = pn + cbpRead - 1; (int)pnT >= (int)pn; pnT-- )
	FreeBufferPage( fn, pnT );
#endif


	/* Read contents of file page(s) into buffer slot(s) */
 cch = CchPageIn( fn, pn, rgbp[ibpNew], cbpRead );

#ifdef DEBUG
 cbpReadT = cbpRead;
#endif

	/* Fill in bps records for as many bytes as were read, but always
       at least one record (to support PnAlloc). If we reached the end of the
       file, the unfilled bps slots are left free */
 pbps = &mpibpbps[ ibpT = ibpNew ];
 do
	{
	pbps->fn = fn;
	pbps->pn = pn;
	pbps->ts = ++tsMruBps; /* mark page as MRUsed */
	pbps->fDirty = false;
	pbps->cch = min( cch, cbSector );
	pbps->ibpHashNext = ibpNil;

	cch = max( cch - cbSector, 0 );

	/* put in new hash table entry for fn,pn */
	iibpHash = IibpHash(fn, pn);
	ibp = rgibpHash[iibpHash];
	ibpPrev = ibpNil;
	while (ibp != ibpNil)
		{
		ibpPrev = ibp;
		ibp = mpibpbps[ibp].ibpHashNext;
		}
	if (ibpPrev == ibpNil)
		rgibpHash[iibpHash] = ibpT;
	else
		mpibpbps[ibpPrev].ibpHashNext = ibpT;

	pn++;  ibpT++;	pbps++;

	}	while ( (--cbpRead > 0) && (cch > 0) );

#ifdef CKSM
#ifdef DEBUG
	/* Compute checksums for newly read pages */

 {
 int ibp;

 for ( ibp = ibpNew; ibp < ibpNew + cbpReadT; ibp++ )
	if (mpibpbps [ibp].fn != fnNil && !mpibpbps [ibp].fDirty)
		(**hpibpcksm) [ibp] = CksmFromIbp( ibp );
 }
	CheckIbp();
#endif /* DEBUG */
#endif

#ifdef ALIGN
	return (ibpNew + dibpAlign);
#else
	return (ibpNew);
#endif
} /* end of I b p M a k e V a l i d  */




FreeBufferPage( fn, pn )
int fn;
int pn;
{		/* Free buffer page holding page pn of file fn if there is one */
		/* Flushes fn if page is dirty */
 int iibp = IibpHash( fn, pn );
 int ibp = rgibpHash[ iibp ];
 int ibpPrev = ibpNil;

 Assert( fn != fnNil );
 while (ibp != ibpNil)
	{
	struct BPS *pbps=&mpibpbps[ ibp ];

	if ( (pbps->fn == fn) && (pbps->pn == pn ) )
		{	/* Found it. Remove this page from the chain & mark it free */

		if (pbps->fDirty)
			FFlushFn( fn );
#ifdef CKSM
#ifdef DEBUG
		else	/* Page has not been trashed while in memory */
			{
			Assert( (**hpibpcksm) [ibp] == CksmFromIbp( ibp ) );
			}
#endif
#endif

		if (ibpPrev == ibpNil)
				/* First entry in hash chain */
			rgibpHash [ iibp ] = pbps->ibpHashNext;
		else
			mpibpbps[ ibpPrev ].ibpHashNext = pbps->ibpHashNext;

		pbps->fn = fnNil;
		pbps->fDirty = FALSE;
			/* Mark the page not recently used */
		pbps->ts = tsMruBps - (ibpMax * 4);
			/* Mark pages that are on even clump boundaries a bit less recently
               used so they are favored in new allocations */
		if (ibp % cbpClump == 0)
			--(pbps->ts);
		pbps->ibpHashNext = ibpNil;
		}
	ibpPrev = ibp;
	ibp = pbps->ibpHashNext;
	}
#ifdef DEBUG
	CheckIbp();
#endif
}




int CchPageIn(fn, pn, rgbBuf, cpnRead)
int fn;
typePN pn;
CHAR rgbBuf[];
int cpnRead;
{ /*
		Description:	Read a cpnRead pages of file fn from disk into rgbBuf.
						Have already determined that page is not resident
						in the buffer.
		Returns:		Number of valid chars read (zero or positive #).
 */
		struct FCB *pfcb = &(**hpfnfcb)[fn];
		typeFC fcMac = pfcb->fcMac;
		typeFC fcPage = pn * cfcPage;
		int dfc;
		int fCharFormatInfo;			/* if reading Format info part of */
										/* file then = TRUE, text part of */
										/* file then = FALSE; */

			/* No reads > 32767 bytes, so dfc can be int */
		Assert( cpnRead <= 32767 / cbSector );

			/* Don't try to read beyond pnMac */
		if (cpnRead > pfcb->pnMac - pn)
			cpnRead = pfcb->pnMac - pn;

		dfc = cpnRead * (int)cfcPage;

		if (pn >= pfcb->pnMac)	/* are we trying to read beyond eof? */
				{
				return 0;		/* Nothing to read */
				}
		else if (pfcb->fFormatted && fn != fnScratch
                 && fn != vfnWriting	/* Since pnChar is zero in this case */
                 && pn >= pfcb->pnChar)
				{ /* reading character format info portion of file */
				fCharFormatInfo = TRUE;
				}
		else /* reading text portion of file */
				{ /* get dfc (cch) from fcMac */
				typeFC dfcT = fcMac - fcPage;

				fCharFormatInfo = FALSE;
				if (dfcT < dfc)
					dfc = (int) dfcT;
				else if (dfc <= fc0)	/* Nothing to read, so let's avoid disk access. */
						{
						return 0;
						}
				}

		return CchReadAtPage( fn, pn, rgbBuf, (int)dfc, fCharFormatInfo );
}




CchReadAtPage( fn, pn, rgb, dfc, fSeriousErr )
int fn;
typePN pn;
CHAR rgb[];
int dfc;
int fSeriousErr;
{ /*
		Description:	Read dfc bytes of file fn starting at page pn
						into rgb
		Returns:		Number of valid chars read (zero or positive #)
		Errors:			Returns # of chars read; ferror & vfDiskFull are
						set (in DiskError) if an error occurs.
		Notes:			Caller is responsible for assuring that the page
						range read is reasonable wrt the fn
  */

 typeOSFN osfn;
 int fpeSeek;
 int fpeRead;
 int fCaught;		/* Whether error was reported by DOS */

#ifdef DEBUG

 if (vfFakeReadErr)
	{
	dfc = 0;
	goto ReportErr;
	}
#endif

 if (!FIsErrFpe( fpeSeek = FpeSeekFnPn( fn, pn )))
	{
	osfn = OsfnEnsureValid( fn );

#ifdef DEBUG
#ifdef DFILE
	CommSzSz( "Read from file: ", &(**(**hpfnfcb)[fn].hszFile)[0] );
#endif
#endif

	if ((fpeRead = CchReadDoshnd( osfn, (CHAR FAR *)rgb, dfc )) == dfc)
		{	/* Read succeeded */
		return dfc;
		}
	else
		{
			/* Should be guaranteed that file was not closed because of seek */
		Assert( fpeRead != fpeBadHndError );

		fCaught = FIsCaughtFpe( fpeRead );
		}
	}
 else
	fCaught = FIsCaughtFpe( fpeSeek );

	/* unable to set position or read */
 if ((fn == fnScratch) || (fSeriousErr))
	{    /* unrecoverable error: either can't read from scratch */
         /* file or unable to read format info (FIB or format pages) part of */
         /* of some file. */
	dfc = 0;
	goto ReportErr;
	}
 else                    /* serious disk error on file (recoverable).*/
	{
	int cchRead = (FIsErrFpe(fpeSeek) || FIsErrFpe(fpeRead)) ? 0 : fpeRead;
	CHAR *pch = &rgb[cchRead];
	int cch = dfc - cchRead;

	/* If the positioning failed or the read failed
       for a reason other than disk full, completely
       fill the buffer with 'X's.  Otherwise, just
       fill the disputed portion (diff between #char
       requested and #char read) with 'X's */

	while (cch-- > 0)
		*pch++ = 'X';

ReportErr:
	if (fCaught)
			/* Suppress reporting of the error -- Windows reported it */
		ferror = TRUE;

	if	(pn != 0)
			/* Report error if not reading FIB */
		DiskErrorWithMsg(IDPMTSDE, " CchReadAtPage");

	return (int)dfc;
	/* recovery is accomplished: 1) Upper level procedures do not
       see any change in the world, 2) the worst thing that
       happens is that the user sees some 'X's on the screen. */
	}
}




AlignFn(fn, cch, fEven)
int fn, cch;
{ /* Make sure we have cch contiguous chars in fn */
/* if fEven, make sure fcMac is even */
		struct FCB *pfcb = &(**hpfnfcb)[fn];
		typeFC fcMac = pfcb->fcMac;
		typePN pn;
		typeFC fcFirstPage;

		pn = fcMac / cfcPage;
		fcFirstPage = (pn + 1) * cfcPage;

		Assert(cch <= cfcPage);

		if (fEven && (fcMac & 1) != 0)
				++cch;

		if (fcFirstPage - fcMac < cch)
				{
				struct BPS *pbps = &mpibpbps[IbpEnsureValid(fn, pn++)];
				pbps->cch = cfcPage;
				pbps->fDirty = true;
				fcMac = pfcb->fcMac = fcFirstPage;
				}

		if (fEven && (fcMac & 1) != 0)
				{
				struct BPS *pbps = &mpibpbps[IbpEnsureValid(fn, pn)];
				pbps->cch++;
				pbps->fDirty = true;
				pfcb->fcMac++;
				}
} /* end of  A l i g n F n	*/




/***	OsfnEnsureValid - ensure that file fn is open
 *
 *
 */

STATIC typeOSFN near OsfnEnsureValid(fn)
int fn;
{ /*
		Description:	Ensure that file fn is open (really)
		Returns:		operating system file number (osfnNil if error)
 */
		struct FCB *pfcb = &(**hpfnfcb)[fn];
		int rfn = pfcb->rfn;

		if (rfn == rfnNil)
			{ /* file doesn't have a rfn - ie. it is not opened */
#ifdef DEBUG
#ifdef DFILE
			CommSzSz( pfcb->fOpened ? "Re-opening file " :
                                      "Opening file", **pfcb->hszFile );
#endif
			if (vfFakeOpenErr || !FAccessFn( fn, dtyNormal ))
#else
			if (!FAccessFn( fn, dtyNormal ))
#endif
				{  /* unrecoverable error - unable to open file */
				DiskErrorWithMsg(IDPMTSDE, " OsfnEnsureValid");
				return osfnNil;
				}
			rfn = pfcb->rfn;
			Assert( (rfn >= 0) && (rfn < rfnMac) );
			}
		return dnrfn[rfn].osfn;
}
/* end of  O s F n E n s u r e V a l i d  */




STATIC int near FpeSeekFnPn( fn, pn )
int fn;
typePN	pn;
{	/* Seek to page pn of file fn
       return err code on failure, fpeNoErr on success
       Leaves file open (if no error occurs)
       Recovers from the case in which windows closed the file for us
     */
 typeOSFN osfn;
 long dwSeekReq;
 long dwSeekAct;

#ifdef DEBUG
#ifdef DFILE
 CommSzSz( "Seeking within file ", **(**hpfnfcb)[fn].hszFile );
#endif
#endif

 //osfn = OsfnEnsureValid( fn );
 if ((osfn = OsfnEnsureValid( fn )) == osfnNil)
	return fpeNoAccError;
 dwSeekReq = (long) pn * (long) cbSector;
 dwSeekAct = DwSeekDw( osfn, dwSeekReq, SF_BEGINNING);

 if ( ((int) dwSeekAct) == fpeBadHndError )
	{	/* Windows closed the file for us -- must reopen it */
	if ((osfn = OsfnReopenFn( fn )) == osfnNil)
		return fpeNoAccError;
	else
		dwSeekAct = DwSeekDw( osfn, dwSeekReq, SF_BEGINNING );
	}

 return (dwSeekAct >= 0) ? fpeNoErr : (int) dwSeekAct;
}




int FFlushFn(fn)
int fn;
{ /*
		Description:	Write all dirty pages of fn to disk.
						Sets vfSysFull = TRUE if disk full error occurred
						while flushing fnScratch.  Otherwise, a disk full
						error causes vfDiskFull = TRUE.
						Serious disk errors cause vfDiskError = TRUE
						Only the pages which actually made it to disk are
						marked as non-dirty.
		Returns:		TRUE if successful, FALSE if Disk full error
						while writing pages to disk.  Any other error
						is unrecoverable, ie. go back to main loop.
						To avoid extraneous error messages, the following
						two entry conditions cause FFlush to immediately
						return FALSE:
                         - If vfSysFull = TRUE and fn = fnScratch
                         - If vfDiskFull = TRUE and fn = vfnWriting
 */
int ibp;
typeOSFN osfn;
int fpe;
int cchWritten;
int cchAskWrite;
struct BPS *pbps;

Assert( fn != fnNil );

if ((vfSysFull) && (fn == fnScratch)) return (FALSE);
if ((vfDiskFull) && (fn == vfnWriting)) return (FALSE);

for (ibp = 0, pbps = mpibpbps; ibp < ibpMax; )
	{
	if (pbps->fn == fn && pbps->fDirty)
		{
		typePN pn = pbps->pn;
		int cbp = 0;
		CHAR *pch = (CHAR *)rgbp[ibp];
		struct BPS *pbpsStart = &mpibpbps[ibp];


		/* Coalesce all consecutive pages for a single write */
		do
			{
			/* taken out 11/7/84 - can't mark scratch file
               page as non dirty if chance that it will never
               get written out (write fails - disk full)
               pbps->fDirty = false;  mark page as clean */
			++ibp, ++cbp, ++pbps;
			}  while (ibp < ibpMax && pbps->fn == fn && pbps->pn == pn + cbp);

		/* Now do the write, checking for out of disk space */
		Scribble(3, 'W');

		cchAskWrite = (int)cbSector * (cbp - 1) + (pbps - 1)->cch;
		cchWritten = cchDiskHardError;	/* assure hard error if seek fails */

#ifdef DEBUG
		if (vfFakeWriteErr)
			goto SeriousError;
		else
#endif
		if ( FIsErrFpe( FpeSeekFnPn( fn, pn )) ||
             ((osfn = OsfnEnsureValid( fn )) == osfnNil) ||
#ifdef DEBUG
#ifdef DFILE
             (CommSzSz( "Writing to file: ", &(**(**hpfnfcb)[fn].hszFile)[0] ),
#endif
#endif
             (( cchWritten = CchWriteDoshnd( osfn, (CHAR FAR *)pch,
                                             cchAskWrite )) != cchAskWrite))
#ifdef DEBUG
#ifdef DFILE
                                                                             )
#endif
#endif
			{
				/* Should be guaranteed that windows did not close the file
                   since we have not called intermodule since the seek */
			Assert( cchWritten != fpeBadHndError );

			/* Seek or Write error */
			if ( !FIsErrCchDisk(cchWritten) )
				{    /* serious but recoverable disk error */
                     /* Ran out of disk space; write failed */
				if (fn == fnScratch)
					vfSysFull = fTrue;
				vfDiskFull = fTrue;
				DiskErrorWithMsg(IDPMTDFULL, " FFlushFn");
				return(FALSE);
				}
			else	/* cause of error is not disk full */
				{  /* unrecov. disk error */
#ifdef DEBUG
SeriousError:
#endif
				DiskErrorWithMsg(IDPMTSDE2, " FFlushFn");
				return FALSE;
				}
			}
		Diag(CommSzNumNum("      cchWritten, cchAskWrite ",cchWritten,cchAskWrite));

			/* ---- write was successful ---- */
			Scribble(3, ' ');
			while (cbp-- > 0)
				{    /* mark pages actually copied to disk as non dirty */
				(pbpsStart++)->fDirty = false;
#ifdef CKSM
#ifdef DEBUG
				{
				int ibpT = pbpsStart - 1  - mpibpbps;
					/* Recompute checksums for pages which are now clean */
				(**hpibpcksm) [ibpT] = CksmFromIbp( ibpT );
				}
#endif
#endif
				}
			}
		else
			{
			++ibp;
			++pbps;
			}
	}
return (TRUE);
}


#ifdef DEBUG
CheckIbp()
	{
	/* Walk through the rgibpHash and the mpibpbps structure to make sure all of
	the links are right. */

	/* 10/11/85 - Added extra Assert ( FALSE ) so we get the messages instead
                  of a freeze-up on systems not connected to a COM port.
                  Ignoring the assertion will produce the RIP with the ibp info */
	extern int fIbpCheck;
	int rgfibp[255];
	int ibp;
	int ibpHash;
	int iibp;
	static BOOL bAsserted=FALSE;

	if (fIbpCheck && !bAsserted)
		{
		if (!(ibpMax < 256))
		{
			Assert(0);
			bAsserted=TRUE;
			return;
		}

		bltc(rgfibp, false, ibpMax);

		/* Are there any circular links in mpibpbps? */
		for (iibp = 0; iibp < iibpHashMax; iibp++)
			{
			if ((ibpHash = rgibpHash[iibp]) != ibpNil)
				{
				if (!(ibpHash < ibpMax))
				{
					Assert(0);
					bAsserted=TRUE;
					return;
				}
				if (rgfibp[ibpHash])
					{
					/* Each entry in rgibpHash should point to an unique chain.
					*/
					Assert(0);
					bAsserted=TRUE;
#if DUGSTUB
					FatalExit(0x100 | ibp);
#endif
					return;
					}
				else
					{
					rgfibp[ibpHash] = true;
					while ((ibpHash = mpibpbps[ibpHash].ibpHashNext) != ibpNil)
						{
						if (!(ibpHash < ibpMax))
						{
							Assert(0);
							bAsserted=TRUE;
							return;
						}
						if (rgfibp[ibpHash])
							{
							/* The chain should be non-circular and unique. */
							Assert( FALSE );
							bAsserted=TRUE;
#if DUGSTUB
							FatalExit(0x200 | ibpHash);
#endif
							return;
							}
						rgfibp[ibpHash] = true;
						}
					}
				}
			}

		/* All chains not pointed to by rgibpHash should be nil. */
		for (ibp = 0; ibp < ibpMax; ibp++)
			{
			if (!rgfibp[ibp])
				{
				if (mpibpbps[ibp].fn != fnNil)
					{
					Assert( FALSE );
					bAsserted=TRUE;
#if DUGSTUB
					FatalExit(0x400 | mpibpbps[ibp].fn);
#endif
					return;
					}
				if (mpibpbps[ibp].ibpHashNext != ibpNil)
					{
					Assert( FALSE );
					bAsserted=TRUE;
#if DUGSTUB
					FatalExit(0x300 | ibp);
#endif
					return;
					}
				}
			}
		}
	}
#endif /* DEBUG */


/* Formerly fileOC.c -- file open and close routines */


/***		SetRfnMac - set usable # of rfn slots
 *
 *	ENTRY: crfn - desired # of rfn slots
 *	EXIT:  (global) rfnMac - set to crfn, if possible
 *
 *	The ability to adjust the usable # of rfn slots is a new addition in
 *	Windows Word.  The two things that it accomplishes are:
 *
 *			(1) Gives the ability for Word to scale back its need for
 *				DOS file handles if not enough are available
 *			(2) Permits Word to attempt to grab more file handles than usual
 *				when this would help performance (in particular, during
 *				Transfer Save, when the original, scratch, and write files
 *				are most commonly open)
 *
 */

SetRfnMac( crfn )
int crfn;
{
 int rfn;

 Assert( (crfn > 0) && (crfn <= rfnMax) );
 Assert( (sizeof (struct ERFN) & 1) == 0);	/* ERFN must be even for blt */

 if (crfn > rfnMac)
	{	/* Add rfn slots */

	for ( rfn = rfnMac; rfn < crfn; rfn++ )
		dnrfn [rfn].fn = fnNil;		/* These will get used next (see RfnGrab)*/
	rfnMac = crfn;
	}

 else	/* Lose Rfn slots (keep the most recently used one(s)) */
	while ( rfnMac > crfn )
		{
		int rfnLru=RfnGrab();
		int fn;

		if ( (rfnLru != --rfnMac) && ((fn = dnrfn [rfnMac].fn) != fnNil) )
			{
			extern int fnMac;

			Assert( fn >= 0 && fn < fnMac );
			(**hpfnfcb) [fn].rfn = rfnLru;
			blt( &dnrfn [rfnMac], &dnrfn [rfnLru],
                                     sizeof(struct ERFN)/sizeof(int) );
			}
		}
}





/*========================================================*/
STATIC int near RfnGrab()
{ /*
		Description:	Allocate the least recently used rfn (real file #)
						slot for a new file.
		Returns:		rfn slot number. */

 int rfn = 0, rfnLru = 0;
 typeTS ts, tsLru;
 struct ERFN *perfn = &dnrfn[rfn];

 /* Time stamp algorithm akin to method used with Bps. */
 /* See IbpLru in file.c for comments. */

 tsLru = -1;     /* max unsigned number */
 for ( rfn = 0; rfn < rfnMac ; rfn++, perfn++ )
	{
	ts = perfn->ts - (tsMruRfn + 1);
	if (perfn->fn == fnNil)
		ts = ts - rfnMac;

		/* cluge: If slot is unused, give it a lower ts. */
		/* This ensures that an occupied slot can never be */
		/* swapped out if a empty one exists. */
	if (ts <= tsLru)
		{
		tsLru = ts;
		rfnLru = rfn;
		}
	}

 if (dnrfn [rfnLru].fn != fnNil)
	CloseRfn( rfnLru );
 return rfnLru;
}




CloseFn( fn )
int fn;
{	/* Close file fn if it is currently open */
 int rfn;

 if (fn == fnNil)
	return;

 if (((rfn = (**hpfnfcb)[fn].rfn) != rfnNil) && (rfn != rfnFree))
	CloseRfn( rfn );
}




OpenEveryHardFn()
{	/* For each fn representing a file on nonremoveable media,
       try to open it.	It is not guaranteed that any or all such files
       will be open on return from this routine -- we are merely attempting
       to assert our ownership of these files on a network by keeping them open */

 extern int fnMac;
 int fn;
 struct FCB *pfcb;

#ifdef DFILE
extern int docCur;
CommSzNum("OpenEveryHardFn: docCur ", docCur);
#endif

 for ( fn = 0, pfcb = &(**hpfnfcb) [0] ; fn < fnMac; fn++, pfcb++ )
	{
/* Bryanl 3/26/87: only call FAccessFn if rfn == rfnNil, to prevent
   multiple opens of the same file, which fail if the sharer is loaded */
#ifdef DFILE
	{
	char rgch[100];
	if (pfcb->rfn == rfnNil && ((POFSTRUCT)(pfcb->rgbOpenFileBuf))->fFixedDisk)
		{
		wsprintf(rgch,"					fn %d, hszFile %s \n\r",fn,(LPSTR)(**pfcb->hszFile));
		CommSz(rgch);
		wsprintf(rgch,"                        OFSTR   %s \n\r", (LPSTR)(((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName));
		CommSz(rgch);
		}
	else
		{
		wsprintf(rgch,"					fn %d, not accessing, sz %s\n\r", fn, (LPSTR) (LPSTR)(**pfcb->hszFile));
		CommSz(rgch);
		wsprintf(rgch,"                        OFSTR   %s \n\r", (LPSTR)(((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName));
		CommSz(rgch);
		}
	}
#endif
	if (pfcb->rfn == rfnNil && ((POFSTRUCT)(pfcb->rgbOpenFileBuf))->fFixedDisk)
		{	/* fn refers to a file on nonremoveable media */
		FAccessFn( fn, dtyNormal );
		}
	}
}




STATIC typeOSFN near OsfnReopenFn( fn )
int fn;
{	/* Reopen file fn after it was automatically closed by Windows due
       to disk swap. State is: fn has an rfn but rfn's osfn has been
       made a "bad handle" */

 struct FCB *pfcb = &(**hpfnfcb) [fn];
 int rfn = pfcb->rfn;
 typeOSFN osfn;
 WORD wOpen;

 Assert( fn != fnNil );
 Assert( rfn != rfnNil );
 Assert( pfcb->fOpened);

	/* Only files on floppies are automatically closed */
 Assert( ! ((POFSTRUCT)(pfcb->rgbOpenFileBuf))->fFixedDisk );

#ifdef DEBUG
#ifdef DFILE
 CommSzSz( "Opening after WINDOWS close: ", **pfcb->hszFile );
#endif
#endif

 wOpen = OF_REOPEN | OF_PROMPT | OF_CANCEL | OF_SHARE_DENY_WRITE |
              ((pfcb->mdFile == mdBinary) ? OF_READWRITE : OF_READ );

 SetErrorMode(1);
 osfn = OpenFile( (LPSTR) SzPromptFromFn( fn ),
                  (LPOFSTRUCT) pfcb->rgbOpenFileBuf, wOpen );
 SetErrorMode(0);

 if (osfn == -1)
	return osfnNil;
 else
	{
	dnrfn[ rfn ].osfn = osfn;
	}
 return osfn;
}




FAccessFn( fn, dty)
int fn;
int  dty;
{ /*	Description:	Access file which is not currently opened.
						Open file and make an appropriate entry in the
						rfn table.	Put the rfn into (**hpfnfcb)[fn].rfn.
		Returns:		TRUE on success, FALSE on failure
  */
extern int vwDosVersion;
extern HANDLE hParentWw;
extern HWND vhWndMsgBoxParent;

int rfn;
register struct FCB *pfcb = &(**hpfnfcb)[fn];
typeOSFN osfn;
int wOpen;

#ifdef DEBUG
int junk;

 Assert(FValidFile(**pfcb->hszFile, CchSz(**pfcb->hszFile)-1, &junk));

#ifdef DFILE
 {
 char rgch[100];

 CommSzSz("FAccessFn: ", pfcb->fOpened ? SzPromptFromFn( fn ) : &(**pfcb->hszFile)[0]);
 wsprintf(rgch, "  * OFSTR before %s \n\r", (LPSTR)(((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName));
 CommSz(rgch);
 }
#endif
#endif /*DEBUG*/

 if ((**pfcb->hszFile)[0] == 0)  /* if file name field is blank, */
	return FALSE;			/* unable to open file */

 wOpen = /*OF_PROMPT + OF_CANCEL + (6.21.91) v-dougk bug #6910 */
						(((pfcb->mdFile == mdBinary) ? 
							OF_READWRITE : OF_READ) | 
								OF_SHARE_DENY_WRITE);
 if (pfcb->fOpened)
	wOpen += OF_REOPEN;
 else if (pfcb->fSearchPath)
	wOpen += OF_VERIFY;

 if ((vwDosVersion & 0x7F) >= 2)
	{
	WORD da;

	if ((vwDosVersion & 0x7F) >= 3)
			/* Above DOS 3, set attributes to deny access if the sharer is in */
		wOpen += bSHARE_DENYRDWR;

	if ( ( (pfcb->mdFile == mdBinary) && (!pfcb->fOpened)) &&
         ((da = DaGetFileModeSz( &(**pfcb->hszFile) [0] )) != DA_NIL) &&
         (da & DA_READONLY) )
		{	/* This is here because the Novell net does not allow us to test
               for read-only files by opening in read/write mode -- it lets
               us open them anyway! */
		goto TryReadOnly;
		}
	}

 for ( ;; )
	{
			/* OpenFile's first parm is a filename when opening for the
               first time, a prompt on successive occasions (OF_REOPEN) */

	SetErrorMode(1);
	osfn = OpenFile( pfcb->fOpened ?
                           (LPSTR) SzPromptFromFn( fn ) :
                           (LPSTR) &(**pfcb->hszFile)[0],
                     (LPOFSTRUCT) &pfcb->rgbOpenFileBuf[0],
                     wOpen );
	SetErrorMode(0);

	if (osfn != -1)		/* Note != -1: osfn is unsigned */
		{    /* Opened file OK */
#ifdef DFILE		
		{
		char rgch[100];
		wsprintf(rgch, "  * OFSTR now  %s \n\r", (LPSTR)(((POFSTRUCT)(**hpfnfcb) [fn].rgbOpenFileBuf)->szPathName));
		CommSz(rgch);
		}
#endif

		if (!pfcb->fOpened)
			{	/* First time through: OpenFile may have given us a
                   different name for the file */

			CHAR szT [cchMaxFile];
			CHAR (**hsz) [];

#if WINVER >= 0x300            
			/* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                                      *RETURNS*  an ANSI sz ..pault */
#endif

			if (FNormSzFile( szT, ((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName,
                             dty ) &&
                       WCompSz( szT, &(**pfcb->hszFile) [0] ) != 0 &&
                       FnFromSz( szT ) == fnNil &&
                       !FNoHeap( hsz = HszCreate( szT )))
				{
					/* Yes, indeed, the name OpenFile gave us was different.
                       Put the normalized version into the fcb entry */

				FreeH( (**hpfnfcb) [fn].hszFile );	/* HEAP MOVEMENT */
				(**hpfnfcb) [fn].hszFile = hsz;
				}
			}
		break;	/* We succeeded; break out of the loop */
		}
	else
		{	/* Open failed -- try read-only; don't prompt this time */
		if ( (pfcb->mdFile == mdBinary) && (!pfcb->fOpened) )
			{	/* Failed as read/write; try read-only */

			/* Check for sharing violation */

			if (((vwDosVersion & 0x7F) >= 3) &&
				(((POFSTRUCT) pfcb->rgbOpenFileBuf)->nErrCode == nErrNoAcc))
				{
				if ( DosxError() == dosxSharing )
                  {
                  extern int vfInitializing;
                  int fT = vfInitializing;

                  vfInitializing = FALSE;	/* Report this err, even during inz */
				{
					char szMsg[cchMaxSz];
					MergeStrings (IDPMTCantShare, **pfcb->hszFile, szMsg);
					IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw, szMsg, MB_OK|MB_ICONEXCLAMATION);
				}
                  vfInitializing = fT;
                  return FALSE;
                  }
				}

TryReadOnly:
			pfcb->mdFile = mdBinRO;
			wOpen = OF_READ;
			if (pfcb->fOpened)
				wOpen += OF_REOPEN;
#ifdef ENABLE
			else if (pfcb->fSearchPath)
               wOpen += OF_VERIFY;
#endif
			}
		else
			{
				if ((**hpfnfcb)[fn].fDisableRead)
				/* already reported */
				{
					ferror = TRUE;
					return FALSE;
				}
				else
				{	/* Could not find file in place specified */
				char szMsg[cchMaxSz];
				extern int ferror;
				extern int vfInitializing;
				int fT = vfInitializing;
				BOOL bRetry=TRUE;
				extern struct DOD      (**hpdocdod)[];
				extern int         docCur;

				/* get user to put file back */
				MergeStrings (IDPMTFileNotFound, **pfcb->hszFile, szMsg);

				vfInitializing = FALSE;   /* Report this err, even during inz */

				/* 
					This is frippin insidious.	MessageBox yields and allows us to get
					into here again before it has even been issued!
				*/

				(**hpdocdod)[docCur].fDisplayable = FALSE; // block redraws

				/* if we're being called from a message box, then use it
                   as the parent window, otherwise use main write window */
				if (IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw, 
                              szMsg, MB_OKCANCEL | MB_ICONEXCLAMATION | MB_APPLMODAL)
                      == IDCANCEL)
				{
					vfInitializing = fT;
					(**hpfnfcb)[fn].fDisableRead = TRUE;
					ferror = TRUE; /* need to flag */
					bRetry = FALSE;
				}

				(**hpdocdod)[docCur].fDisplayable = TRUE; // unblock redraws

				vfInitializing = fT;

				if (!bRetry)
					return FALSE;
				}
			}
		}
	}

 pfcb->fOpened = TRUE;

 rfn = RfnGrab();
 {
 struct ERFN *perfn = &dnrfn [rfn];

 perfn->osfn = osfn;
 perfn->fn   =	fn;
 perfn->ts   = ++tsMruRfn;     /* mark Rfn as MRused */
 }
 (**hpfnfcb) [fn].rfn = rfn;
 (**hpfnfcb) [fn].fDisableRead = FALSE;
 return TRUE;
}



FCreateFile( szFile, fn )	/* returns szFile in ANSI ..pault */
CHAR *szFile;
int fn;
{		/*	Create a new, unique file.
			Return the name in szFile.
			Returns TRUE on success, FALSE on failure.
			Leaves the filename in (**hpfnfcb)[fn].hszFile (if successful),
			the rfn in (**hpfnfcb)[fn].rfn.
			If szFile begins "X:...", creates the file on the specified drive;
			otherwise, creates the file on a drive of Windows' choice */

	extern CHAR szExtDoc[];
	CHAR (**hsz)[];
	CHAR szFileT [cchMaxFile];

	if (!GetTempFileName(szFile[0] | ((szFile[1] == ':') ? TF_FORCEDRIVE : 0),
                         (LPSTR)(szExtDoc+1), 0, (LPSTR)szFileT) )
		{    /* can't create file */
		DiskErrorWithMsg( IDPMTSDE, " RfnCreate" );

		/* recovery is accomplished: only FnCreateSz calls FCreateFile.
           FnCreateSz returns nil if FCreateFile returns FALSE.  All of
               FnCreateSz's callers check for nil */
		return FALSE;

		}

	/* Succeeded in creating file */

	FNormSzFile( szFile, szFileT, dtyNormal );

	if ( FNoHeap( hsz = HszCreate( (PCH)szFile )))
		return FALSE;

	(**hpfnfcb) [fn].hszFile = hsz;

	if ( !FAccessFn( fn, dtyNormal ) )
		return FALSE;

	return TRUE;
} /* end of  F C r e a t e F i l e	*/



FEnsureOnLineFn( fn )
int fn;
{		/* Ensure that file fn is on line (i.e. on a disk that is accessible).
           Return TRUE if we were able to guarantee this, FALSE if not */
 int rfn;

 Assert( fn != fnNil );

 if ( ((POFSTRUCT)(**hpfnfcb) [fn].rgbOpenFileBuf)->fFixedDisk )
		/* If it's on nonremovable media, we know it's on line */
	return TRUE;

 /* If it's open, must close and re-open, cause windows might have closed it */
 if ((rfn = (**hpfnfcb) [fn].rfn) != rfnNil)
	CloseRfn( rfn );

 return FAccessFn( fn, dtyNormal );
}




typePN PnAlloc(fn)
int fn;
{ /* Allocate the next page of file fn */
		typePN pn;
		struct BPS *pbps;
		struct FCB *pfcb = &(**hpfnfcb)[fn];

		AlignFn(fn, (int)cfcPage, false);
		pn = pfcb->fcMac / cfcPage;
		pbps = &mpibpbps[IbpEnsureValid(fn, pn)];
		pbps->cch = cfcPage;
		pbps->fDirty = true;
		pfcb->fcMac += cfcPage;
		pfcb->pnMac = pn + 1;
		return pn;
}




STATIC CHAR  *(near SzPromptFromFn( fn ))
int fn;
{
 extern int vfnSaving;
 CHAR *pch;

 Assert( fn != fnNil );

 if (fn == vfnSaving)
	pch = szSaveFilePrompt;
 else if (fn == fnScratch)
	pch = szScratchFilePrompt;
 else
	pch = szWriteDocPrompt;

 return pch;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\filedefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#include "machdefs.h"

#define cfcPage         ((typeFC)cbSector)
#define ibpNil          255
#define lruMax          ((unsigned) 65535)
#define fnMax           5
#define fnInsert        (fnNil - 1)
#define fnScratch       0
#define osfnNil         (-1)
#define rfnNil          rfnMax /* Stored in 7 bits */
#define rfnFree         (rfnMax + 1)
#define wMW             ('M' + ('W' << 8))
#define wSY             ('S' + ('Y' << 8))
#define wHP             ('H' + ('P' << 8))
#define cwSector        (cbSector / sizeof (int))
#define cbpMustKeep     6       /* assume no bp will be dislodged for this
                                   many calls to IbpEnsureValid */
#define cbOpenFileBuf   128

#ifdef SAND
#define wMagic          0177062
#define wMagicOld       0137061
#else /* not SAND */
#define wMagic          0137061
#endif /* not SAND */

#define wMagicTool      ((0253 << 8) + 0)

#define fcMax           ((typeFC) 2147483647)

#define fpeNoSuch       (-5)
#define fpeDiskFull     (-7)

struct BPS
        {
        typePN     pn;
        int        fn;
        typeTS     ts;          /* time stamp - used in LRU algorithm */
        unsigned   fDirty : 1;
        unsigned   cch : 15;
        CHAR       ibpHashNext; /* link for external chained hashing
                                                        collision resolution */
        };


struct FCB
        {
        typeFC    fcMac;          /* includes FIB, but not FKP's */
        unsigned char fFormatted : 1;
        unsigned char fDelete : 1;
        unsigned char fReferenced : 1;
        unsigned char dty : 4;
        unsigned char fOpened: 1;   /* Whether file has been opened before */
        unsigned char rfn : 7;
        unsigned char fSearchPath: 1; /* Search path when first opened */
        int       mdExt;
        int       mdFile;
        typePN    pnChar;
        typePN    pnPara;
        typePN    pnFntb;
        typePN    pnSep;
        typePN    pnSetb;
        typePN    pnBftb;
        typePN    pnFfntb;      /* font family name table offset */
        typePN    pnMac;  /* # of pages actually in existence */
        typeFC    (**hgfcChp)[];
        typeFC    (**hgfcPap)[];
        CHAR      (**hszFile)[];
        CHAR      (**hszSsht)[];
        CHAR      rgbOpenFileBuf[ cbOpenFileBuf ]; /* OpenFile's work space */

#ifdef SAND
        int       version;      /* version byte */
        int       vref;         /* volume reference number */
#endif /* SAND */

        unsigned int fDisableRead: 1; /* disable reading of file */
        };

#define cbFCB   (sizeof (struct FCB))
#define cwFCB   (sizeof (struct FCB) / sizeof (int))

struct ERFN
        { /* Real file (opened in os) */
        int     osfn;
        int     fn;
        typeTS  ts;     /* time stamp - used in LRU algorithm */
        };


#define cchToolHeader   14

struct FIB
        {
        int             wIdent; /* Word-specific magic number */
        int             dty;
        int             wTool;
        int             cReceipts; /* Number of external receipts allowed */
        int             cbReceipt; /* Length of each receipt */
        int             bReceipts; /* One word offset from beginning of file
                                        to beginning of receipts */
        int             isgMac;    /* Number of code segments included */
        /* End of Multi-Tool standard header */
        typeFC          fcMac;
        typePN          pnPara;
        typePN          pnFntb;
        typePN          pnSep;
        typePN          pnSetb;
        typePN          pnBftb; /* Also pnPgtb */
        typePN          pnFfntb;        /* font family name table */
        CHAR            szSsht[66]; /* Style sheet name */
        typePN          pnMac;
        CHAR            rgbJunk[cbSector - (cchToolHeader + sizeof (typeFC)
                             + 7 * sizeof (typePN) + 66)];
        };

#define cchFIB  (sizeof (struct FIB))

#define CONVFROMWORD (TRUE + 2)  /* used by FWriteFn to convert Word file
                                  characters to Write ANSI set */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fetch.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fetch.c -- MW routines for obtaining attributes associated with cp's */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NOATOM
#define NOMETAFILE
#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOPEN
#define NOBITMAP
#define NOCOLOR
#define NODRAWTEXT
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOMB
#define NOMSG
#define NOOPENFILE
#define NORESOURCE
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "editdefs.h"
#include "propdefs.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "filedefs.h"
/*
#include "code.h"
*/
#include "ch.h"
#include "fkpdefs.h"
#include "prmdefs.h"
/*
#include "stcdefs.h"
*/

static SetChp(struct CHP *pchp, int *pcfcChp, int fn, typeFC fc, struct PRM prm);

extern typeCP          vcpFetch;
extern int             vichFetch;
extern int             vdocFetch;
extern int             vccpFetch;
extern int             vcchFetch;
extern CHAR            *vpchFetch;
extern struct CHP      vchpFetch;
extern CHAR            (**hgchExpand)[];
extern int             vdocExpFetch;
extern struct CHP      vchpAbs;


extern int vfDiskError;
#ifdef CASHMERE
extern int docBuffer;
#endif
extern struct PAP       vpapAbs;
extern struct CHP vchpNormal;
extern struct DOD (**hpdocdod)[];
extern CHAR     rgchInsert[];
extern int      ichInsert;
extern struct CHP vchpInsert;
extern typeCP   vcpFirstParaCache;
extern typeCP   vcpLimParaCache;
extern struct PAP       vpapCache;
extern struct FCB    (**hpfnfcb)[];
extern struct FKPD   vfkpdCharIns;
extern typeFC        fcMacChpIns;

typePN PnFkpFromFcScr();
CHAR *PchFromFc();

#ifdef BOGUS
#ifdef DEBUG
typeCP   cpExpFetch;
CHAR     *pchExpFetch;
int      cchExpFetch;
int      ccpExpFetch;
#endif /* DEBUG */
#endif


FetchCp(doc, cp, ich, fcm)
int doc, ich, fcm;
typeCP cp;
{       /*
        Inputs:
                doc
                Starting cp
                ich within cp (for cp's which can cross line boundaries)
                fcm tells whether to get chars, props, or both
        Outputs:
                (in vcpFetch) starting cp
                (in vichFetch) starting ich within expanded cp
                (in vdocFetch) doc
                (in vccpFetch) number of cp's fetched (0 if expanded cp)
                (in vcchFetch) number of ch's fetched
                (in vpchFetch) characters fetched
                (in vchpFetch) char prop of fetched chars
        */
struct PCD *ppcd;

static int fn;
static typeFC fc;
static struct PRM prm;
static typeCP ccpChp, ccpPcd, ccpFile;
static int ipcd;
static typeCP   cpExpFetch;
static CHAR     *pchExpFetch;
static int      cchExpFetch;
static int      ccpExpFetch;



if (doc == docNil)
        { /* Sequential call to FetchCp */
        /* If last piece was Q&D insert, skip remainder of piece */
        if (fn == fnInsert && (fc + vccpFetch) >= ichInsert)
                vccpFetch = ccpPcd; /* Use whole piece */
        vcpFetch += vccpFetch;  /* Go to where we left off */
        if (vccpFetch == 0)
                vichFetch += vcchFetch;
        else
                vichFetch = 0;
        fc += vccpFetch;
        }
else
        { /* Random-access call */
        vcpFetch = cp;
        vichFetch = ich;
        vdocFetch = doc;
        ccpChp = ccpPcd = ccpFile = 0;
        }

if (vcpFetch >= (**hpdocdod)[vdocFetch].cpMac)
        { /* Use std looks for end mark */
        vccpFetch = 0;

        /* vcchFetch == 0 should not be used for endmark indications because of
        empty QD runs. */
        vcchFetch = 1;

        if (fcm & fcmProps)
                {
                blt(&vchpNormal, &vchpFetch, cwCHP);
                blt(&vchpNormal, &vchpAbs, cwCHP);
                }
        return;
        }

#ifdef STYLES
if ((fcm & (fcmChars + fcmNoExpand)) == fcmChars &&
    (**hpdocdod)[vdocFetch].dty == dtySsht)
        { /* Style sheet; expand encoded text */
        if (fcm & fcmProps)
                {
                blt(&vchpNormal, &vchpFetch, cwCHP);
                blt(&vchpNormal, &vchpAbs, cwCHP);
                }
        if (vdocExpFetch == vdocFetch && vcpFetch == cpExpFetch + ccpExpFetch)
                { /* Give back the last EOL in the expansion */
                vccpFetch = vcchFetch = 1;
                vpchFetch = &(**hgchExpand)[cchExpFetch];
                return;
                }
        else if (vdocExpFetch != vdocFetch || cpExpFetch != vcpFetch)
                { /* New expansion */
                int ich = vichFetch;

                vdocExpFetch = vdocFetch;
                cpExpFetch = vcpFetch;
                pchExpFetch = PchExpStyle(&cchExpFetch, &ccpExpFetch, vdocFetch,
                    vcpFetch);  /* Uses FetchCp, so better save v's */
                vcpFetch = cpExpFetch;  /* Got changed by PchExpStyle */
                vichFetch = ich;        /* Ditto */
                if (fcm & fcmProps)     /* Ditto */
                        {
                        blt(&vchpNormal, &vchpFetch, cwCHP);
                        blt(&vchpNormal, &vchpAbs, cwCHP);
                        }
                }
        if (vichFetch >= cchExpFetch)
                { /* End of expansion; skip cp's */
                vccpFetch = ccpExpFetch;
                vcchFetch = 0;
                ccpPcd = ccpFile = ccpChp = 0;
                }
        else
                {
                vccpFetch = 0;
                vcchFetch = cchExpFetch - vichFetch;
                }
        vpchFetch = pchExpFetch + vichFetch;
        return;
        }
#endif /* STYLES */


if (ccpPcd > vccpFetch)
        ccpPcd -= vccpFetch;
else
        {
        struct PCTB *ppctb = *(**hpdocdod)[vdocFetch].hpctb;

        if (doc == docNil)
                ++ipcd; /* Save some work on sequential call */
        else
                { /* Search for piece and remember index for next time */
                ipcd = IpcdFromCp(ppctb, vcpFetch);
                }

        ppcd = &ppctb->rgpcd[ipcd];
        ccpPcd = (ppcd + 1)->cpMin - vcpFetch;
        ccpChp = ccpFile = 0;   /* Invalidate everything; new piece */
        fc = ppcd->fc + vcpFetch - ppcd->cpMin;
        if ((fn = ppcd->fn) == fnInsert)
                { /* Special quick and dirty insert mode */
                vpchFetch = rgchInsert + fc;
                ccpChp = ccpFile = vccpFetch = max(0, ichInsert - (int) fc);
                if (fcm & fcmProps)
                        {
                        ccpChp = vccpFetch;
                        blt(&vchpInsert, &vchpFetch, cwCHP);
#ifdef STYLES
                        blt(PpropXlate(vdocFetch, &vchpFetch, &vpapAbs), &vchpAbs,
                            cwCHP);
#else
                        blt(&vchpFetch, &vchpAbs, cwCHP);
#endif
                        goto ParseCaps;
                        }
                return;
                }
        prm = ppcd->prm;
        }

/* No monkeying with files after this statement, or we may page out */
if (fcm & fcmChars)
        {
#ifdef ENABLE   /* In WRITE, we cannot assume that vpchFetch will remain
                   valid, because we do our reading in multi-page chunks;
                   also, rgbp can move */

        if (ccpFile > vccpFetch)
                {
                ccpFile -= vccpFetch;
                vpchFetch += vccpFetch;
                }
        else
#endif
                {
                int ccpT;
                vpchFetch = PchFromFc(fn, fc, &ccpT); /* Read in buffer */
                ccpFile = ccpT;
                }
        }

if (fcm & fcmProps)
        { /* There must be enough page buffers so that this will not
                page out vpchFetch! */
        if (ccpChp > vccpFetch)
                ccpChp -= vccpFetch;
        else
                { /* CachePara must have been called prior to FetchCp */
                int ccpT;
                SetChp(&vchpFetch, &ccpT, fn, fc, prm);
                ccpChp = ccpT;
#ifdef CASHMERE /* no docBuffer in WRITE */
                if(vdocFetch != docBuffer)
#endif
#ifdef STYLES
                    blt(PpropXlate(vdocFetch, &vchpFetch, &vpapAbs), &vchpAbs,
                        cwCHP);
#else
                    blt(&vchpFetch, &vchpAbs, cwCHP);
#endif
                }
        }

/* Set vccpFetch to minimum of various restraining ccp's */
vccpFetch = (ccpPcd >= 32767) ? 32767 : ccpPcd;
if ((fcm & fcmChars) && ccpFile < vccpFetch) vccpFetch = ccpFile;
if ((fcm & fcmProps) && ccpChp < vccpFetch) vccpFetch = ccpChp;

ParseCaps:

#ifdef CASHMERE
if ((fcm & fcmParseCaps) != 0)
    {
    CHAR *pch;
    int cch;

        /* Brodie says this will not work for style sheet */
    if (vchpFetch.csm == csmSmallCaps)
        { /* Parse small caps into runs */
        pch = &vpchFetch[0];
        cch = vccpFetch - 1;
        /* This either */
        blt(&vchpFetch, &vchpAbs, cwCHP); /* because vchpAbs could be modified */
        if (islower(*pch++))
                {
                while ((islower(*pch) || *pch == chSpace)
                    && cch-- != 0)
                        pch++;
#ifndef SAND
                vchpAbs.hps =
                    max(1, (vchpAbs.hps * 4  + 2) / 5);
#endif
                }
        else
                {
                while (!islower(*pch) && cch-- != 0)
                        pch++;
                vchpAbs.csm = csmNormal;
                }
        vccpFetch = min((int)ccpChp, pch - vpchFetch);
        }
    }
#endif /* CASHMERE */

vcchFetch = vccpFetch;
} /* end of  F e t c h C p  */


FetchRgch(pcch, pch, doc, cp, cpMac, cchMax)
int *pcch, doc, cchMax;
CHAR *pch;
typeCP cp, cpMac;
{
int cch = 0;

FetchCp(doc, cp, 0, fcmChars + fcmNoExpand);

while (cch < cchMax && vcpFetch < cpMac)
        {
#ifdef INEFFICIENT
        int ccp = (int) CpMin((typeCP) min(cchMax - cch, vccpFetch),
            cpMac - vcpFetch);
#endif
        int ccp = cchMax - cch;
        if (ccp > vccpFetch)
                ccp = vccpFetch;
        if (ccp > cpMac - vcpFetch)
                ccp = cpMac - vcpFetch;

        bltbyte(vpchFetch, pch, ccp);
        pch += ccp;
        cch += ccp;

        if (ccp < vccpFetch)
                break; /* Save some work */
        FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand);
        }
*pcch = cch;
} /* end of  F e t c h R g c h  */


int IpcdFromCp(ppctb, cp)
struct PCTB *ppctb;
typeCP cp;
{ /* Binary search piece table for cp; return index */
int ipcdLim = ppctb->ipcdMac;
int ipcdMin = 0;
struct PCD *rgpcd = ppctb->rgpcd;

while (ipcdMin + 1 < ipcdLim)
        {
        int ipcdGuess = (ipcdMin + ipcdLim) >> 1;
        typeCP cpGuess;
        if ((cpGuess = rgpcd[ipcdGuess].cpMin) <= cp)
                {
                ipcdMin = ipcdGuess;
                if (cp == cpGuess)
                        break;     /* Hit it on the nose! */
                }
        else
                ipcdLim = ipcdGuess;
        }
return ipcdMin;
} /* end of  I p c d F r o m C p  */


static SetChp(struct CHP *pchp, int *pcfcChp, int fn, typeFC fc, struct PRM prm)
{ /* Fill pchp with char props; return length of run in *pcfcChp */
struct FKP *pfkp;
struct FCHP *pfchp;
typeFC cfcChp;
struct FCB *pfcb;

pfcb = &(**hpfnfcb)[fn];
cfcChp = pfcb->fcMac - fc;
FreezeHp();

if (fn == fnScratch && fc >= fcMacChpIns)
        {
        blt(&vchpInsert, pchp, cwCHP);
        }
else
        {
        if (pfcb->fFormatted)
                { /* Copy necessary amt of formatting info over std CHP */
                typeFC fcMac;
                int cchT;
                int bfchp;

                blt(&vchpNormal, pchp, cwCHP);
                pfkp = (struct FKP *) PchGetPn(fn, fn == fnScratch ?
                    PnFkpFromFcScr(&vfkpdCharIns, fc) :
                      pfcb->pnChar + IFromFc(**pfcb->hgfcChp, fc),
                       &cchT, false);
                if (vfDiskError)
                        /* Serious disk error -- use default props */
                    goto DefaultCHP;

                {   /* In-line, fast substitute for BFromFc */
                register struct RUN *prun = (struct RUN *) pfkp->rgb;

                while (prun->fcLim <= fc)
                    prun++;

                fcMac = prun->fcLim;
                bfchp = prun->b;
                }

                if (bfchp != bNil)
                        {
                        pfchp = (struct FCHP *) &pfkp->rgb[bfchp];
                        bltbyte(pfchp->rgchChp, pchp, pfchp->cch);
                        }
                cfcChp = fcMac - fc;
                }
        else
                {
DefaultCHP:
                blt(&vchpNormal, pchp, cwCHP);
                /* in case default size is different "normal" (which is
                   used for encoding our bin files */
                pchp->hps = hpsDefault;
                }
        }

if (!bPRMNIL(prm))
        DoPrm(pchp, (struct PAP *) 0, prm);
if (cfcChp > 32767)
        *pcfcChp = 32767;
else
        *pcfcChp = cfcChp;
MeltHp();
} /* end of  S e t C h p  */


typePN PnFkpFromFcScr(pfkpd, fc)
struct FKPD *pfkpd;
typeFC fc;
{ /* Return page number in scratch file with props for char at fc. */
struct BTE *pbte = **pfkpd->hgbte;
int ibte = pfkpd->ibteMac;

/* A short table, linear search? */
while (ibte--)
        if (pbte->fcLim > fc)
                return pbte->pn;
        else
                pbte++;

return pfkpd->pn;       /* On current page. */
} /* end of  P n F k p F r o m F c S c r  */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fkpdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fkpdefs.h -- mw formatted disk page definitions */
/* #include filedefs.h, propdefs.h first */


#define ifcMacInit      10

#define cbFkp           (cbSector - sizeof (typeFC) - 1)

#define cchMaxGrpfsprm  cbSector
#define cchMaxFsprm     2

struct FKP
	{ /* Formatted disK Page */
	typeFC  fcFirst;        /* First fc which has formatting info here */
	CHAR    rgb[cbFkp];
	CHAR    crun;
	};


struct RUN
	{ /* Char or para run descriptor */
	typeFC  fcLim;  /* last fc of run */
	int     b; /* Byte offset from page start; if -1, standard props */
	};

#define cchRUN  (sizeof (struct RUN))
#define bfcRUN  0

struct FCHP
	{ /* File CHaracter Properties */
	CHAR    cch;    /* Number of bytes stored in chp (rest are vchpStd) */
			/* Must not be 0. */
	CHAR    rgchChp[sizeof (struct CHP)];
	};


struct FPAP
	{ /* File ParagrAph Properties */
	CHAR    cch;    /* Number of bytes stored in pap (rest are vpapStd) */
			/* Must not be 0. */
	CHAR    rgchPap[sizeof (struct PAP)];
	};



struct FPRM
	{ /* File PropeRty Modifiers (stored in scratch file) */
	CHAR    cch;
	CHAR    grpfsprm[cchMaxGrpfsprm + cchMaxFsprm]; /* + for overflow */
	};


struct FKPD
	{ /* FKP Descriptor (used for maintaining insert properties) */
	int     brun;   /* offset to next run to add */
	int     bchFprop;       /* offset to byte after last unused byte */
	typePN  pn;     /* pn of working FKP in scratch file */
	struct BTE (**hgbte)[]; /* pointer to bin table */
	int     ibteMac;        /* Number of bin table entries */
	};


struct BTE
	{ /* Bin Table Entry */
	typeFC          fcLim;
	typePN          pn;
	};
#define cwBTE (sizeof(struct BTE)/sizeof(int))

struct FND
	{ /* Footnote descriptor */
	typeCP          cpRef;          /* Or fcRef (cp of ftn reference) */
	typeCP          cpFtn;          /* Or fc... (first cp of text) */
	};

#define cchFND  (sizeof (struct FND))
#define cwFND   (cchFND / sizeof (int))
#define bcpRefFND       0
#define bcpFtnFND       (sizeof (typeCP))
#define cwFNTBBase      2
#define ifndMaxFile     ((cbSector - cwFNTBBase * sizeof (int)) / cchFND)

struct FNTB
	{ /* Footnote table */
	int             cfnd;   /* Number of entries (sorted ascending) */
	int             cfndMax; /* Heap space allocated */
	struct FND      rgfnd[ifndMaxFile]; /* Size varies */
	};



struct FNTB **HfntbEnsure(), **HfntbGet();

#define HsetbGet(doc) ((**hpdocdod)[doc].hsetb)

struct SED
	{ /* Section descriptor */
	typeCP          cp;
	int             fn;
	typeFC          fc;
	};

#define cchSED  (sizeof (struct SED))
#define cwSED   (cchSED / sizeof (int))
#define bcpSED          0
#define cwSETBBase      2
#define isedMaxFile     ((cbSector - cwSETBBase * sizeof (int)) / cchSED)


struct SETB
	{ /* Section table */
	int             csed;
	int             csedMax;
	struct SED      rgsed[isedMaxFile]; /* Size varies */
	};


struct SETB **HsetbCreate(), **HsetbEnsure();

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fmtdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define ichMaxLine	255
#define cpMaxTl 	(ichMaxLine + cchInsBlock)
#define ichpMacInitFormat 10	 /* Initial mac of char runs in a line */
#define dypBaselineMin	 2

#define wbWhite 	0	/* Word break types */
#define wbText		1
#define wbPunct 	2
#define wbAny		3	/* used when searching with wildcards */

#ifdef	DBCS		    /* was in JAPAN, changed it to DBCS */
	/* brought from WIN2. */
#define wbKanjiText	 4
#define wbKanjiTextFirst 5
#endif	/* DBCS */

#define dxpTab		40

/* Formatted line structure.
   Reorganized KJS, CS Sept 3
   Shuffled for word alignment bz, 6/11/85 */

/* booleans in bytes to simplify machine code */
struct FLI
	{
	typeCP		cpMin;
	int		ichCpMin;
	typeCP		cpMac;
	int		ichCpMac;
	int		ichMac;
	int		dcpDepend;
	unsigned	fSplat : 8;
/* First character in region where spaces have additional pixel */
	unsigned	ichFirstWide : 8;
/* ichMac, with trailing blanks excluded */
	int		ichReal;
	int		doc;

	int		xpLeft;
	int		xpRight;
/* xpRight, with trailing blanks excluded */
	int		xpReal;
/* the right margin where insert will have to break the line */
	int		xpMarg;

	unsigned	fGraphics : 8;
	unsigned	fAdjSpace : 8;	/* Whether you adjust the spaces */

	unsigned	dxpExtra;
/* the interesting positions in order from top to bottom are:
	top:		      yp+dypLine
	top of ascenders:     yp+dypAfter+dypFont
	base line:	      yp+dypBase
	bottom of descenders: yp+dypAfter
	bottom of line:       yp
distances between the points can be determined by algebraic subtraction.
e.g. space before = yp+dypLine - (yp+dypAfter+dypFont)
*/
	int		dypLine;
	int		dypAfter;
	int		dypFont;
	int		dypBase;
	int		fSplatNext; /* Splat on following line? */

	int		ichLastTab;
	int		flm;
	int		rgdxp[ichMaxLine];      /* NOTE this differs from fce.rgdxp==CHAR! */
	CHAR		rgch[ichMaxLine];
	};



#define cwFLI	(sizeof(struct FLI) / sizeof(int))
#define cwFLIBase (cwFLI - ichMaxLine - (ichMaxLine / sizeof (int)))


#define flmPrinting	1
#define flmCharMode	2
#define flmNoMSJ	4
#define flmSandMode	8

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fontdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fontdefs.h -- MW definitions for fonts */

#ifdef PRDFILES
struct PRDD
        { /* printer description file descriptor */
        int     cfcdMac,        /* count of fonts defined for this printer */
                cxInch,         /* pixels per inch, horizontal */
                dyaMin,         /*    "       "      "      "     y   "    */
                pid,            /* printer identification number */
                pe,             /* print element */
                fNoMSJ,         /* microspace justification flag */
                fSpecial,       /* special flags */
                pn,             /* serial interface word */
                bfcdBase,       /* byte address of start of FCDs */
                cttBase,        /* byte address of start of CTT  */
                bpcdBase,       /* byte address of start of PCDs */
                bpcsBase,       /* byte address of start of PCSs */
                bprdMax;        /* end of PRD file */

        CHAR    (**hrgbprdf)[]; /* block that contains the FCDs and WTs */
        int     (**hmpiftcfcd)[]; /* double entry table: consists of 2 word
                                   entries, 1st is the font code of this font,
                                   2nd is heap offset to FCD for this font.
                                   There are exactly cfcdMac sets of these */
        CHAR    (**hrgbctt)[];  /* character translation table */
        CHAR    (**hprcc)[];    /* printer control sequences */
/*      CHAR    szFile[cchMaxFile]; /* file name for printer desc. file */
        };

#define cchPRDDFile     26
#define cwPRDD  (sizeof (struct PRDD) / sizeof(int))

/* prd file byte offsets */
#define bPrdData1 (typeFC)64
#define bPrdData2 (typeFC)128

#define cpsMax          10
#define dxaDefault ((unsigned) 144)

#ifdef SAND
#define wpcPica         0       /* Daisy wheel pitch codes */
#define wpcElite        1
#define wpcMicron       2
#define wpcProportional 3

#define wpPica          10      /* Pitches */
#define wpElite         12
#define wpMicron        15
#define wpProportional  10      /* Bogus */

#define psPica          12      /* point Sizes */
#define psElite         10
#define psMicron        8
#define psProportional  12      /* Bogus */

#define convWpPs        120     /* conversion between wheel pitch and
                                   Point Size */

/* IMPORTANT-- the following font codes (20, 21, 22, 23) random numbers
   we will have to be assigned permanent font codes by Apple */

#define ftcPrintFONT    20
#define ftcPrintFWID    21
#define ftcPrintPSFONT  22
#define ftcPrintPSFWID  23
#endif /* SAND */

struct FAD
        {               /* Font Address Descriptor              */
        unsigned wtp;   /* multi purpose word                   */
        };

struct PCSD1
        { /* printer control sequence descriptor */
        int     bprcc;  /* byte offset of start of control sequence */
        CHAR    bMod;   /* modification byte */
        CHAR    cch;    /* length of control sequence */
        };

#define cwPCSD1  (sizeof(struct PCSD1) / sizeof(int))

struct PSD
        {               /* Printer Size Descriptor              */
        int     hps;    /* size available in half points        */
        struct FAD      fad,
                        fadI,
                        fadB,
                        fadIB;
        struct PCSD1    pcsdBegin,
                        pcsdEnd;
        };

struct FCD
        {               /* Font Code Description                */
        int     ctp;    /* character translation table pointer (a la wtp) */
        int     cpsd;   /* count of sizes available             */
        struct PSD      rgpsd[cpsMax];  /* psds for each size available */
        CHAR            rgchFntName[32];/* font name (null terminated)  */
        };

#define pnfSerial       0100000
#define pnfETX          040000
#define pnfXON          020000

#define MSJ_fNone       1
#define MSJ_fChars      2
#define MSJ_fPSCorrect  4

#define SPC_fNoBSCtt    1

#ifdef GENERIC_MSDOS
#ifdef HP150
#define cPortMac        3
#define cchPort         4
#else /* not HP150 */
#define cPortMac        2
#define cchPort         4
#endif /* not HP150 */
#else /* not GENERIC_MSDOS */
#define cPortMac        5
#define cchPort         5
#endif /* GENERIC_MSDOS */

#define fntMax 6

struct PCSD
        { /* printer control sequence descriptor */
        int     bprcc;  /* byte offset of start of control sequence */
        CHAR    bMod;   /* modification byte */
        CHAR    cch;    /* length of control sequence */
        CHAR    bMagic; /* magic number */
        CHAR    bMax;   /* max value of parameter */
        };
#endif /* PRDFILES */

#define hpsMin 8
#define hpsMax 256
#define cchFontSize 4
#define iszSizeMax 32
#define iffnEnumMax 64
#define psFontMin 4
#define psFontMax 127

/* macros used to get/put pitch and font family info in windows data structs */
#define bitPitch        0x01
#define grpbitFamily    0xf0

typedef CHAR FFID;      /* font family ID */

#define iftcRoman       0
#define iftcModern      1
#define iftcScript      2
#define iftcDecorative  3
#define iftcSwiss       4

#ifdef SYSENDMARK
#define ftcSystem 0x3E
#define bitFtcChp 0x3E
#endif /* KANJI */
#define ftcNil    255
#define cchFfnMin 1
#define chGhost '\003'

#define iffnProfMax 5   /* # of fonts described in win.ini list */

#define LocalFaceSize 32
#ifndef LF_FACESIZE
/* this is gross, but so's our compiler! */
#define LF_FACESIZE LocalFaceSize
#endif

#ifdef NEWFONTENUM
#define ibFfnMax (LF_FACESIZE + sizeof(FFID) + sizeof(BYTE) + 1 /* to make it a max */)
#else
#define ibFfnMax (LF_FACESIZE + sizeof(FFID) + 1)
#endif
#define CbFfn(cch) (sizeof(struct FFN) - cchFfnMin + (cch))

/* Added 5/5/89: insure we only touch memory to which we're entitled ..pault */
#define CbFromPffn(pffn)    (sizeof(FFID)+sizeof(BYTE)+CchSz((pffn)->szFfn))

/* NOTE: If this structure is changed, CbFromPffn() above must be updated! */
typedef struct FFN      /* Font Family Name */
        {
#ifdef NEWFONTENUM
        BYTE chs;       /* The charset associated with this facename
                           (ANSI, OEM, Symbol, etc).  We've kludged the
                           way that FFN's are written out in documents
                           so see HffntbForNewDoc() ..pault */
#endif
        FFID ffid;
        /* really a variable length string */
        CHAR szFfn[cchFfnMin];
        };

/* 255 ffn's lets us map ftc's in a single byte, with one nil value */
#define iffnMax 255
#define cffnMin 1
typedef struct FFNTB    /* font table */
        {
        unsigned int iffnMac: 15;
        unsigned int fFontMenuValid: 1; /* Used for names on CHAR dropdown */
        struct FFN **mpftchffn[cffnMin];
        };

struct FFNTB **HffntbCreateForFn();
struct FFNTB **HffntbNewDoc();
struct FFNTB **HffntbAlloc();
struct FFN *PffnDefault();
#define HffntbGet(doc) ((**hpdocdod)[(doc)].hffntb)

/* following structures support font information caching */

#define fcidNil 0xffffffffL

typedef union FCID /* font cache identifier */
        {
        long lFcid;
        struct
                {
                unsigned ftc : 8;
                unsigned hps : 8;
                unsigned doc : 4;
                unsigned wFcid : 12;
                } strFcid;
        };

/* bits set in wFcid */
#define grpbitPsWidthFcid       0x007f
#define bitFixedPitchFcid       0x0080
#define bitUlineFcid            0x0100
#define bitBoldFcid             0x0200
#define bitItalicFcid           0x0400
#define bitPrintFcid            0x0800

#define psWidthMax              127

typedef struct FMI      /* font metric information */
        {
        int *mpchdxp;          /* pointer to width table */
                                /* NOTE - we actually point chDxpMin entries
                                          before the start of the table, so
                                          that the valid range begins at the
                                          start of the actual table */
        int dxpSpace;           /* width of a space */
        int dxpOverhang;        /* overhang for italic/bold chars */
        int dypAscent;          /* ascent */
        int dypDescent;         /* descent */
        int dypBaseline;        /* difference from top of cell to baseline */
        int dypLeading;         /* accent space plus recommended leading */
#ifdef DBCS
        int dypIntLeading;      /* internal leading */
#if defined(JAPAN) || defined(KOREA) || defined(TAIWAN) || defined(PRC)
        WORD dxpDBCS;           /* Win3.1 T-HIROYN change BYTE--> WORD*/
#else
        BYTE dxpDBCS;           /* width of a DBCS character. */
                                /* WARNING - This assumes a kanji character
                                             is fixed pitch. */
        BYTE bDummy;            /* To guarantee that this addition
                                   increases the amount by 1 word. */
#endif /* JAPAN */
#endif /* DBCS */
        };

#define chFmiMin 0x20
#ifdef WIN30
   /* Why are we not asking for widths of all characters?  We should. */
#ifdef  KOREA
#define chFmiMax 0x80
#elif defined(TAIWAN)
#define chFmiMax 0x80
#elif defined(PRC)
#define chFmiMax 0x80
#else
#define chFmiMax 0x100
#endif

#else
#define chFmiMax 0x80
#endif

#define dxpNil 0xFFFF

typedef struct FCE      /* font cache entry */
        {
        struct FCE *pfceNext;   /* next entry in lru list */
        struct FCE *pfcePrev;   /* prev entry in lru list */
        union FCID fcidRequest; /* request this entry satisfied */
        union FCID fcidActual;  /* what this entry really contains */
        struct FFN **hffn;      /* font family name */
        struct FMI fmi;         /* helpful metric information for this entry */
        HFONT hfont;            /* windows' font object */
        int rgdxp[chFmiMax - chFmiMin]; /* width table proper */
        };

#define ifceMax 16
struct FCE *PfceLruGet();
struct FCE *PfceFcidScan();

/* values to be passed to LoadFont() directing it's actions */
#define mdFontScreen 0          /* sets font for random screen chars */
#define mdFontChk 1             /* sets font as constrained by printer avail */
#define mdFontJam 2             /* like mdFontChk, but jams props into chp */
#define mdFontPrint 3           /* like mdFontScreen, but for the printer */

#ifdef SAND
typedef struct  {       /* structure of a Macintosh font. See Font Manager */
        int     frFontType;     /* fr was prepended to each element to     */
        int     frFirstChar;    /* prevent "name collision" with the       */
        int     frLastChar;     /* elements of FONTINFO                    */
        int     frWidMax;
        int     frKernMax;
        int     frNDescent;
        int     frFRectMax;
        int     frChHeight;
        int     frOwTLoc;
        int     frAscent;
        int     frDescent;
        int     frLeading;
        int     frRowWords;
        } FONTREC;

#define woFrOwTLoc 8 /* The word offset of the owTLoc from the beginning */
#define wdthTabFrOwTLoc 4       /* The frOwTLoc for a width table       */

typedef struct {
        int     family;
        int     size;
        int     face;
        int     needBits;
        int     device;
        POINT   numer;
        POINT   denom;
        } FMINPUT;

typedef struct {
        int     errNum;
        HANDLE  fontHandle;
        CHAR    bold;
        CHAR    italic;
        CHAR    ulOffset;
        CHAR    ulShadow;
        CHAR    ulThick;
        CHAR    shadow;
        CHAR    extra;
        CHAR    ascent;
        CHAR    descent;
        CHAR    widMax;
        CHAR    leading;
        CHAR    unused;
        POINT   numer;
        POINT   denom;
        } FMOUTPUT;

#define qFMOUTPUT ((FMOUTPUT far *) 0x998)
#endif /* SAND */

#define enumFaceNames 0
#define enumFindAspectRatio 1
#define enumSizeList 2
#define enumCheckFont 3
#define enumQuickFaces 4

#ifdef JAPAN
#define enumFaceNameJapan 128   // T-HIROYN Win3.1 use FontFaceEnum JAPAN only
#endif

#ifdef NEWFONTENUM
#define psApprovedMax 48  /* don't know why we don't go up to 64 here; spose
                             that's for "the big boy word processors" ..pault */
#endif

/* Used in DOPRM.C and FONTENUM.C */
#define csizeApprovedMax 13
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fileutil.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fileutil.c -- WRITE file-related utilities */
#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "str.h"
#include "machdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "debug.h"
#include "editdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"



/***        FNormSzFile - Normalize MSDOS filename
 *
 *  Converts a MSDOS filename into an unambiguous representation
 *
 *  ENTRY:  szFile - a filename; drive, path, and extension
 *           are optional
 *      dty - the type of the document file (used to determine
 *            extensions)
 *  EXIT:   szNormal - A normalized filename
 *  RETURNS: FALSE - Errors found in filename     (szNormal left undefined)
 *       TRUE  - No errors found in filename  ( but there may be some
 *                          that we didn't find )
 *
 *  The form of the filename on entry is:
 *
 *  { <drive-letter>: }{ <amb-path> }<filename>{.<extension>}
 *
 *  The form of the normalized filename is:
 *
 *  <drive-letter>:<unamb-path><filename>.<extension>
 *
 *  Where all alphabetics in the normalized name are in upper case
 *  and <unamb-path> contains no "." or ".." uses nor any forward
 *  slashes.
 *
 *  All attributes required in the normalized filename and not
 *  provided in the szFile are taken from the defaults:
 *      drive - current (DOS)
 *      path - current (DOS)
 *      extension - derived from the passed dty
 *
 *  It is permissible to call this routine with szFile containing a path
 *  name instead of a filename.  The resulting szNormal will be backslash
 *  terminated if szFile was, not if szFile was not.
 *  "" is converted into the current path
 *
 *  WARNING:  The paths "." and ".." will produce errors
 *        (but ".\" and "..\" are OK)
 *
 ******
 *NOTE*   szFile is expected in OEM; szNormal is returned as ANSI!
 ******
 *
 */

FNormSzFile( szNormal, szFile, dty )
CHAR *szNormal;
CHAR *szFile;
int  dty;
{
/* Treat separators like terminators */

#define FIsTermCh( ch )     ((ch) == '\0' || (ch) == ',' || (ch == ' ') || \
                 (ch) == '+' || (ch) == '\011')
extern CHAR *mpdtyszExt [];

 CHAR szPath [cchMaxFile];
 CHAR szFileT[cchMaxFile];

 int  cchPath;
 CHAR *pchFileEye=&szFileT[0];      /* We read szFile with the Eye */
 CHAR *pchNormPen;          /* and write szNormal with the Pen */
 CHAR *pchNormPath;
 CHAR *pchPath;

/* Assert( CchSz( szFile ) <= cchMaxFile );*/
 if (CchSz(szFile) > cchMaxFile)
     return(FALSE);

#if WINVER >= 0x300
 /* Convert input filename, which is passed in OEM,
    to ANSI so entire return pathname will be ANSI */
 OemToAnsi((LPSTR) szFile, (LPSTR) szFileT);
#endif

#ifdef DBCS
    /* Get current (DOS) path: "X:\...\...\" */
 if( IsDBCSLeadByte(*szFileT) )
     cchPath = CchCurSzPath(szPath, 0 );
 else
     cchPath = CchCurSzPath(szPath, szFileT [1]==':' ?
                     (pchFileEye+=2,(ChUpper(szFileT [0])-('A'-1))):0 );
 if( cchPath < 3 )
#else
    /* Get current (DOS) path: "X:\...\...\" */
 if ((cchPath = CchCurSzPath(&szPath [0], szFileT [1]==':' ?
                     (pchFileEye+=2,(ChUpper(szFileT [0])-('A'-1))):0 )) < 3)
#endif
    {   /* Hardcore error -- could not get path */
    extern int ferror;

    if (FpeFromCchDisk(cchPath) == fpeNoDriveError)
    Error( IDPMTNoPath );

    ferror = TRUE;  /* Windows already reported this one */
    return FALSE;
    }

#ifdef DBCS //T-HIROYN 1992.07.14
/* CchCurSzPath() [doslib.asm] don't support DBCS code */
    {
        char *pchDb;
        char *pch;
        pchDb = szPath;
        do {
            pch = pchDb;
            pchDb = AnsiNext(pchDb);
        } while(*pchDb);
        if(*pch != '\\') {
            *pchDb++ = '\\';
            *pchDb = 0x00;
            cchPath++;
        }
    }
#endif

#if WINVER >= 0x300
 {
 CHAR szT[cchMaxFile];

 /* CchCurSzPath returns OEM; we should only be dealing
    with ANSI filenames at this level! ..pault 1/11/90 */

 bltsz(szPath, szT);
 OemToAnsi((LPSTR) szT, (LPSTR) szPath);
 }
#endif

    /* Write Drive Letter and colon */
 CopyChUpper( &szPath [0], &szNormal [0], 2 );

 pchNormPen = pchNormPath = &szNormal [2];
 pchPath = &szPath [2];
 cchPath -= 2;

 /* Now we have pchNormPen, pchPath, pchFileEye pointing at their path names */

    /* Write path name */
 if ( (*pchFileEye == '\\') || (*pchFileEye =='/') )
    {   /* "\....." -- basis is root */
    *pchFileEye++;
    *(pchNormPen++) = '\\';
    }
 else
    {   /* ".\" OR "..\" OR <text> -- basis is current path */
    CopyChUpper( pchPath, pchNormPen, cchPath );
    pchNormPen += cchPath - 1;
    }

  for ( ;; )
    {       /* Loop until we have built the whole szNormal */
    register CHAR ch=*(pchFileEye++);
    register int  cch;

    Assert( *(pchNormPen - 1) == '\\' );
    Assert( (pchNormPen > pchNormPath) &&
                  (pchNormPen <= &szNormal [cchMaxFile]));

    if ( FIsTermCh( ch ) )
        /* We get here if there is no filename portion  */
        /* This means we have produced a path name */
    {
    *pchNormPen = '\0';
    break;
    }

    if ( ch == '.' )
    if ( ((ch = *(pchFileEye++)) == '\\') || (ch == '/') )
        /* .\ and ./ do nothing */
        continue;
    else if ( ch == '.' )
        if ( ((ch = *(pchFileEye++)) == '\\') || (ch == '/') )
        {   /* ..\ and ../ back up by one directory */
        for ( pchNormPen-- ; *(pchNormPen-1) != '\\' ; pchNormPen-- )
            if ( pchNormPen <= pchNormPath )
                /* Can't back up, already at root */
            return FALSE;
        continue;
        }
        else
            /* ERROR: .. not followed by slash */
        return FALSE;
    else
        /* Legal file and path names do not begin with periods */
        return FALSE;

    /* Filename or Path -- copy ONE directory or file name */

    for ( cch = 1; !FIsTermCh(ch) && ( ch != '\\') && ( ch != '/' ) ; cch++ )
#ifdef  DBCS
    {
    if(IsDBCSLeadByte(ch))
    {
        pchFileEye++;
        cch++;
    }
    ch = *(pchFileEye++);
    }
#else
    ch = *(pchFileEye++);
#endif

    /* Check if filename too long or if full pathname will be too long ..pt */
    if ( cch > cchMaxLeaf || cch+cchPath >= cchMaxFile)
        /* Directory or file name too long */
    return FALSE;

    CopyChUpper( pchFileEye - cch, pchNormPen, cch );
    pchNormPen += cch;
    if ( ch == '/' )
    *(pchNormPen-1) = '\\';
    else if ( FIsTermCh( ch ) )
    {    /* Filename looks good, add extension & exit */
    *(pchNormPen-1) = '\0';

    /* kludge alert: if dtyNormNoExt then don't add extension unless 
        there's one already there to be overwritten. (6.21.91) v-dougk */
    if ((dty != dtyNormNoExt) ||
         index(szNormal,'.'))
            AppendSzExt( &szNormal [0],
                mpdtyszExt [ (dty == dtyNormNoExt) ? dtyNormal : dty ],
                FALSE );
    break;
    }
    }   /* Endfor (loop to build szNormal) */

 /* If there is anything but whitespace after the filename, then it is illegal */

 pchFileEye--;  /* Point at the terminator */
 Assert( FIsTermCh( *pchFileEye ));

 for ( ;; )
    {
#ifdef DBCS
    CHAR ch = *(pchFileEye=AnsiNext(pchFileEye));
#else
    CHAR ch = *(pchFileEye++);
#endif

    if (ch == '\0')
    break;
    else if ((ch != ' ') && (ch != '\011'))
        /* Non-whitespace after filename; return failure */
    return FALSE;
    }

 Assert( CchSz(szNormal) <= cchMaxFile );
 return TRUE;
}



/* Parses the cch chars stored in rgch.  Returns true if string is a valid
filename.  If the string is not a valid name, pichError is updated to have
ich of first illegal Char in the name. */
/* NOTE: this routine is tuned for ASCII on MS-DOS */

BOOL
FValidFile(rgch, ichMax, pichError)     /* filename presumed to be ANSI */
register char rgch[];
int ichMax;
int *pichError;
    {
    int ich;
    register int ichStart;
    CHAR ch;
    int cchBase;
    int ichDot = iNil;

    for (ichStart = 0; ichStart < ichMax;)
    {
    /* Does the file name begin with ".\" or "..\"? */
    if (rgch[ichStart] == '.' &&
      (rgch[ichStart + 1] == '\\' || rgch[ichStart + 1] == '/'))
        {
        ichStart += 2;
        }
    else if (rgch[ichStart] == '.' && rgch[ichStart + 1] == '.' &&
      (rgch[ichStart + 2] == '\\' || rgch[ichStart + 2] == '/'))
        {
        ichStart += 3;
        }
    else
        {
        break;
        }
    }

    cchBase = ichStart;

    if (ichStart >= ichMax)
        {
        ich = ichStart;
        goto badchar;
        }

    /* Are all characters legal? */
    for(ich = ichStart; ich < ichMax; ich++)
    {
    ch = rgch[ich];
    /* range check */

#ifndef DBCS
    if ((unsigned char)ch >= 0x80)
        /* To allow international filenames, pass everything above 128 */
        continue;
    if (ch < '!' || ch > '~')
        goto badchar;
#endif
    switch(ch)
        {
        default:
#ifdef  DBCS
        goto CheckDBCS;
#else
        continue;
#endif
        case '.':
        if (ichDot != iNil || ich == cchBase)
            /* More than  one dot in the name */
            /* Or null filename */
            goto badchar;
        ichDot = ich;
#ifdef DBCS
        goto CheckDBCS;
#else
        continue;
#endif
        case ':':
        if ( ich != 1 || !(isalpha(rgch[0])))
            goto badchar;
        /* fall through */
        case '\\':
        case '/':
        /* note end of the drive or path */
        if (ich + 1 == ichMax)
            goto badchar;
        cchBase = ich+1;
        ichDot = iNil;
#ifdef DBCS
        goto CheckDBCS;
#else
        continue;
#endif
        case '"':
#ifdef WRONG
        /* This IS a legal filename char! ..pault 10/26/89 */
        case '#':
#endif
        case '*':
        case '+':
        case ',':
        case ';':
        case '<':
        case '=':
        case '>':
        case '?':
        case '[':
        case ']':
        case '|':
        goto badchar;
        }
#ifdef DBCS
CheckDBCS:
    if(IsDBCSLeadByte(ch))  ich++;
#endif  /* DBCS */
    }

    /* Are there no more than eight chars before the '.'? */
    if(((ichDot == -1) ? ichMax : ichDot) - cchBase > 8)
        {
        ich = 8+cchBase;
        goto badchar;
        }
    /* If there is no '.' we are fine */
    if(ichDot == iNil)
        return true;
    /* Are there no more than three chars after the '.'? */
    if(ichMax - ichDot - 1 > 3)
        {
        ich = ichDot + 3 + 1;
        goto badchar;
        }
    return true;

badchar:
    *pichError += ich;
    return false;
    }







#ifdef DBCS
CopyChUpper( szSource, szDest, cch )
register CHAR *szSource;
register CHAR *szDest;
int cch;
{
 while(cch){
    if( IsDBCSLeadByte( *szSource ) ){
        *szDest++ = *szSource++;
        *szDest++ = *szSource++;
        cch--;
    } else
        *szDest++ = ChUpper( *szSource++ );
    cch--;
 }
}
#else
CopyChUpper( szSource, szDest, cch )
CHAR *szSource;
CHAR *szDest;
register int cch;
{
 register CHAR ch;

 while (cch--)
    {
    ch = *(szSource++);
    *(szDest++) = ChUpper( ch );
    }
}
#endif


/***        AppendSzExt - append extension to filename
 *
 *  Append extension (assumed to contain the ".") to passed filename.
 *  Assumes call allocated enough string space for the append
 *  if fOverride is TRUE, overrides any existing extension
 *  if fOverride is FALSE, appends extension only if szFile has
 *      no current extension
 */

AppendSzExt( szFile, szExt, fOverride )
CHAR *szFile;
CHAR *szExt;
int fOverride;
{
#define cchMaxExt   3
 CHAR *pch=NULL;
 int cch;
 register int cchT;
 register int chT;

 /* pch <-- pointer to the '.' for szFile's extension (if any) */
 cch = cchT = CchSz( szFile ) - 1;
 while (--cchT > cch - (cchMaxExt + 2))
    if ((chT=szFile[ cchT ]) == '.')
    {
    pch = &szFile[ cchT ];
    break;
    }
    else if ((chT == '\\') || (chT == '/'))
        /* Catches the weird case: szFile == "C:\X.Y\J" */
    break;

 if (pch == NULL)
    /* No explicit extension: APPEND */
    CchCopySz( szExt, szFile + CchSz( szFile ) - 1 );

 else if ( fOverride )
    /* Override explicit extension */
    CchCopySz( szExt, pch );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fileres.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* fileres.c -- functions from file.c that are usually resident */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOSYSCOMMANDS
#define NOATOM
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMETAFILE
#define NOMSG
#define NOHDC
#define NOGDI
#define NOMB
#define NOFONT
#define NOPEN
#define NOBRUSH
#define NOWNDCLASS
#define NOSOUND
#define NOCOMM
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#define NOUAC
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "str.h"
#include "debug.h"


extern int                      vfDiskFull;
extern int                      vfSysFull;
extern int                      vfnWriting;
extern CHAR                     (*rgbp)[cbSector];
extern typeTS                   tsMruRfn;
extern struct BPS               *mpibpbps;
extern int                      ibpMax;
extern struct FCB               (**hpfnfcb)[];
extern typeTS                   tsMruBps;
extern struct ERFN              dnrfn[rfnMax];
extern int                      iibpHashMax;
extern CHAR                     *rgibpHash;
extern int                      rfnMac;
extern int                      ferror;
extern CHAR                     szWriteDocPrompt[];
extern CHAR                     szScratchFilePrompt[];
extern CHAR                     szSaveFilePrompt[];


#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax


#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#define ErrorWithMsg( idpmt, szModule )         Error( idpmt )
#define DiskErrorWithMsg( idpmt, szModule )     DiskError( idpmt )
#endif

#define osfnNil (-1)


CHAR *PchFromFc(fn, fc, pcch)
int fn;
typeFC fc;
int *pcch;
{ /*
        Description:    Reads from a file, starting at virtual character
                        position fc.  Reads until end of buffer page.
        Returns:        Pointer to char buffer starting at fc.
                        The number of characters read is returned in *pcch.
  */
int dfc;
CHAR *pch;
typePN pn;
int ibp;
struct BPS *pbps;

        dfc = (int) (fc % cfcPage);
        pn = (typePN) (fc / cfcPage);

        ibp = IbpEnsureValid(fn, pn);
        pbps = &mpibpbps[ibp];
        *pcch = pbps->cch - dfc;
        return &rgbp[ibp][dfc];
}
/* end of  P c h F r o m F c  */




/***        PchGetPn - Assure file page loaded, return pointer
 *
 */

CHAR *PchGetPn(fn, pn, pcch, fWrite)
int fn;
typePN pn;
int *pcch;
BOOL fWrite; // missing before?? (2.11.91) D. Kent
{ /*
        Description:    Get char pointer to page buffer, option to mark
                        page as dirty.
        Returns:        Pointer to buffer.
                        cch in *pcch
  */

        int ibp = IbpEnsureValid(fn, pn);
        struct BPS *pbps = &mpibpbps[ibp];

        *pcch = pbps->cch;
        pbps->fDirty |= fWrite;
        return rgbp[ibp];
} /* end of  P c h G e t P n  */




int IbpEnsureValid(fn, pn)
int fn;
typePN pn;
{ /*
        Description:    Get page pn of file fn into memory.
                        If already in memory, return.
        Returns:        Bp index (buffer slot #) where the page resides
                        in memory.
  */

int ibp;
register struct BPS *pbps;

#ifdef DEBUG
 CheckIbp();
#endif /* DEBUG */

/* Is the page currently in memory? */
 ibp = rgibpHash[IibpHash(fn,pn)];
 /* ibp is the first in a linked list of possible matches */
 /* resident in memory */

 Scribble(3,'V');

 while (ibp != ibpNil)    /* while not end of linked list */
    {                   /* check if any buffers in memory match */
    pbps = &mpibpbps[ibp];
    if (pbps->fn == fn && pbps->pn == pn)
        { /* Found it */
        pbps->ts = ++tsMruBps;      /* mark page as MRUsed */
        Scribble(3,' ');
        return ibp;
        }
    ibp = pbps->ibpHashNext;
    }

/* page is not currently in memory */

 return IbpMakeValid( fn, pn );
} /* end of I b p E n s u r e V a l i d  */




CloseEveryRfn( fHardToo )
{   /* Close all files we have open. Close only files on removable media
       if fHardToo is FALSE; ALL files if fHardToo is TRUE */
int rfn;

for (rfn = 0; rfn < rfnMac; rfn++)
    {
    int fn = dnrfn [rfn].fn;

    if (fn != fnNil)
        if ( fHardToo ||
             !((POFSTRUCT)((**hpfnfcb)[fn].rgbOpenFileBuf))->fFixedDisk )
            {
            CloseRfn( rfn );
            }
    }
}



typeFC FcWScratch(pch, cch)
CHAR *pch;
int cch;
{ /*
        Description:    Write chars at end of scratch file.
        Returns:        first fc written.
 */
        typeFC fc = (**hpfnfcb)[fnScratch].fcMac;
#if 0
        extern BOOL  bNo64KLimit;

        if ((!bNo64KLimit) && (((long) fc) + ((long) cch) > 65536L))  /* scratch file to big */
        {
        DiskErrorWithMsg(IDPMTSFER, " FcWScratch"); /* session too long */

        vfSysFull = fTrue;
                /* recovery is accomplished: all that happens is that a few
                   characters do not get written to the scratch file - the
                   user loses only a little bit of his work. */
        }
        else
#endif
                WriteRgch(fnScratch, pch, cch);
        return fc;
}




WriteRgch(fn, pch, cch)
int fn;
CHAR *pch;
int cch;
{ /*
        Description:    Writes char string pch, length cch, to end of
                        file fn.
        Returns:        nothing
 */
 extern vfDiskError;
 struct FCB *pfcb = &(**hpfnfcb)[fn];
 typePN pn = (typePN) (pfcb->fcMac / cfcPage);
#ifdef WIN30
 /* Error checking was horrendous in these early days, right?
    Ha.  It still is.  In any case, don't know WHAT we can do
    if the page number has gotten too large, so just fake a 
    disk error so that IbpEnsureValid() doesn't go off into 
    never-never land!  This catch effectively limits us to 
    4M files ..pault 11/1/89 */

 if (pn > pgnMax)
#ifdef DEBUG
    DiskErrorWithMsg(IDPMTSDE2, "writergch");
#else    
    DiskError(IDPMTSDE2);
#endif
 else
#endif

        while (cch > 0)
                { /* One page at a time */
                int ibp = IbpEnsureValid(fn, pn++);
                struct BPS *pbps = &mpibpbps[ibp];
                int cchBp = pbps->cch;
                int cchBlt = min((int)cfcPage - cchBp, cch);

                Assert( vfDiskError ||
                        cchBp == pfcb->fcMac - (pn - 1) * cfcPage);

                bltbyte(pch, &rgbp[ibp][cchBp], cchBlt);
                pbps->cch += cchBlt;
                pbps->fDirty = true;
                pfcb->fcMac += cchBlt;
                pfcb->pnMac = pn;
                pch += cchBlt;
                cch -= cchBlt;
                }
} /* end of  W r i t e R g c h  */




CloseRfn( rfn )
int rfn;
{/*
        Description:    Close a file and delete its Rfn entry
        Returns:        nothing
 */
        struct ERFN *perfn = &dnrfn[rfn];
        int fn = perfn->fn;

        Assert (rfn >= 0 &&
                rfn < rfnMac &&
                perfn->osfn != osfnNil &&
                fn != fnNil);

#ifdef DEBUG
#ifdef DFILE
        CommSzSz( "Closing file: ", &(**(**hpfnfcb)[fn].hszFile)[0] );
#endif
#endif
        /* Close may fail if windows already closed the file for us,
           but that's OK */
        FCloseDoshnd( perfn->osfn );

        {   /* Just like the statement below, but 28 bytes less
               under CMERGE V13 */
        REG1    struct FCB *pfcb = &(**hpfnfcb) [fn];
        pfcb->rfn = rfnNil;
        }
        /* (**hpfnfcb)[fn].rfn = rfnNil; */


        perfn->fn = fnNil;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fontenum.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Fonts.c -- WRITE font routines */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dlgdefs.h"
#include "propdefs.h"
#include "fontdefs.h"
#include "prmdefs.h"
#include "str.h"
#include "docdefs.h"

#ifdef DBCS
#include "kanji.h"
#endif

#ifdef JAPAN
CHAR    szDefFFN0[10];
CHAR    szDefFFN1[10];
#endif

extern struct DOD     (**hpdocdod)[];
extern HANDLE         hMmwModInstance;
extern HANDLE         hParentWw;
extern int            vfSeeSel;
extern int            docCur;
extern HWND           vhWndMsgBoxParent;
extern int            vfCursorVisible;
extern HCURSOR        vhcArrow;


int iszSizeEnum;
int iszSizeEnumMac;
int iszSizeEnumMax;
extern CHAR szSystem[];

#ifdef DBCS_VERT
extern CHAR szAtSystem[]; // Use for '@' fontface checking.
#endif

int iffnEnum;
int vfFontEnumFail;
struct FFNTB **hffntbEnum = NULL;

#ifdef NEWFONTENUM
/* Changed because it is INCORRECT to filter out all non-ANSI
   character sets.  Also we've removed this aspect-ratio checking 
   stuff ..pault */

#define FCheckFont(lptm) (1)
#else
BOOL FCheckFont(lptm)
LPTEXTMETRIC lptm;
    {
    /* This routine returns TRUE iff the character set for this font is the
    ANSI set and either this is a vector font or the aspect ratio is correct. */

    extern int aspectXFont;
    extern int aspectYFont;

    return (
#ifdef  DBCS
      lptm->tmCharSet == NATIVE_CHARSET
#else
      lptm->tmCharSet == ANSI_CHARSET
#endif
      && ((lptm->tmPitchAndFamily & 0x6) == 0x2
      || (lptm->tmDigitizedAspectX == aspectXFont
      && lptm->tmDigitizedAspectY == aspectYFont)));
    }
#endif /* else-def-NEWFONTENUM */



/* FontFaceEnum used to be called for a number of reasons so it used
   rg[] to pass in parameters to get it to do different things including
   aspect-ratio filtering.  I've simplified this a great deal so Write
   will allow more things (this can be good or bad) ..pault */

BOOL far PASCAL FontFaceEnum(lplf, lptm, fty, lParam)
LPLOGFONT lplf;
LPTEXTMETRIC lptm;
int fty;            /* font type, passed through from the EnumFonts call: */
                    /*         fty & RASTER_FONTTYPE == fRasterFont       */
                    /*         fty & DEVICE_FONTTYPE == fDeviceFont       */
long lParam;
    {
    /* Callback routine to record all of the appropriate face names for the
       current printer.  "appropriate" is based on the params as follows:

           * rgw[0]=0 normal mode,
                   =enumQuickFaces indicates "streamlined mode"
                    (i.e. ignore all the following params in this case), and
                   =
           * rgw[1]=RASTER_FONTTYPE if only raster fonts are to be enumerated,
           *       =DEVICE_FONTTYPE if only device fonts are to be enumerated,
           *       =TRUETYPE_FONTTYPE if only TRUE_TYPE fonts are to be enumerated,
           * rgw[2]=desired font family code (e.g. we start out
                    only wanting swiss, and later expand that)
           * rgw[3] indicates whether or not we must match rgw[2]
           * rgw[4]=max number of fonts we have room for

    ..pault 10/12/89*/

    int *rgw = (int *)LOWORD(lParam);

    /* Stop enumerating if we have enough fonts */

    if ((*hffntbEnum)->iffnMac >= rgw[4])
        /* we have all we need */
        return(FALSE);
#ifdef DENUMF
    {
    char rgch[100];
    wsprintf(rgch,"FFEn: %s, devicebit %d rasterbit %d ",lplf->lfFaceName,
                fty&DEVICE_FONTTYPE, fty&RASTER_FONTTYPE);
    CommSz(rgch);
    }
#endif

#ifdef JAPAN //T-HIROYN Win3.1
    if (rgw[0] == enumQuickFaces)
        goto addenumj;
    if (rgw[0] == enumFaceNameJapan)
        {
        if (lplf->lfCharSet == NATIVE_CHARSET)
            {
            if (rgw[1] == 0 && (fty & DEVICE_FONTTYPE) &&
             !(CchDiffer(lplf->lfFaceName,szDefFFN0,lstrlen(szDefFFN0))))
                goto addenumj;
// 12/15/92
#if 1
            if (rgw[1] == 3 && (fty & TRUETYPE_FONTTYPE) &&
             (lplf->lfPitchAndFamily & 0xf0) == FF_ROMAN )
                goto addenumj;

            if (rgw[1] == 4 && (fty & TRUETYPE_FONTTYPE))
                goto addenumj;
#endif
            if (rgw[1] == 1 &&
             !(CchDiffer(lplf->lfFaceName,szDefFFN1,lstrlen(szDefFFN1))))
                goto addenumj;
            if (rgw[1] == 2 &&
             (lplf->lfPitchAndFamily & 0xf0) == FF_ROMAN &&
             (lplf->lfPitchAndFamily & 0x0f) == FIXED_PITCH)
                goto addenumj;
        /* Is this the right type of font? */
            }
        goto retenumj;
        }
    if (rgw[0] == enumFaceNames && (fty & rgw[1]))
        {
        if( (rgw[3] == 0) ||
            ( (lptm->tmPitchAndFamily&grpbitFamily) == rgw[2] ) )
            goto addenumj;
        }
    goto retenumj;

addenumj:
        {
#else
    if ((rgw[0] == enumQuickFaces) ||
        /* Is this the right type of font? */
        ((fty & rgw[1]) &&
            /* Does this font belong to the correct family?  Well
               when rgw[3] says: NEEDN'T MATCH then of course it does, and
               when rgw[3] says: MATCH then we check to see! */
            ((rgw[3] == 0)||((lptm->tmPitchAndFamily&grpbitFamily) == rgw[2]))))        {

#endif //JAPAN

        CHAR rgb[ibFfnMax];
        struct FFN *pffn = (struct FFN *)rgb;

        bltbx(lplf->lfFaceName, (LPSTR)pffn->szFfn,
              umin(LF_FACESIZE, IchIndexLp((LPCH)lplf->lfFaceName, '\0')+1));
        pffn->chs = lplf->lfCharSet;    /* save this setting */

        /* We're interested in this one */
        if (FCheckFont(lptm) && (*hffntbEnum)->iffnMac < iffnEnumMax)
            {
            pffn->ffid = lplf->lfPitchAndFamily & grpbitFamily;
#ifdef DENUMF
            CommSz("(adding)");
#endif

            if (!FAddEnumFont(pffn))
                {
                /* Couldn't add it to the table. */
                vfFontEnumFail = TRUE;
                return(FALSE);
                }
            }
        }
#ifdef DENUMF
        CommSz("\n\r");
#endif

#ifdef JAPAN //T-HIROYN Win3.1
retenumj:
#endif

    return(TRUE);
    }

FInitFontEnum(doc, cffnInteresting, fOrder)
/* sets up for a font enumeration, where caller cares about
   'cffnInteresting' fonts, and special stuff is done iff 'fOrder'
   (to help us pick good default font(s) on startup */

int doc, cffnInteresting, fOrder;
    {
    extern HDC vhDCPrinter;
#ifdef INEFFLOCKDOWN
    extern FARPROC lpFontFaceEnum;
#else
    FARPROC lpFontFaceEnum = NULL;
#endif

    int iffn, iffnMac;
    struct FFNTB **hffntb;
    struct FFN *pffn, **hffn;
    struct FFN ffn;
    CHAR rgb[ibFfnMax];
    int rgw[5];

    vfFontEnumFail = FALSE;

    if (hffntbEnum != NULL)
        {
        return(FALSE);
        }

    if (FNoHeap(hffntbEnum = HffntbAlloc()))
        {
        hffntbEnum = NULL;
        return(FALSE);
        }

    /* First we list all the fonts used in the current doc's ffntb */

#ifdef DENUMF
    CommSzNumNum("FINITFONTENUM: cffnInteresting,fOrder ",cffnInteresting,fOrder);
#endif

#ifdef JAPAN    //T-HIROYN  Win3.1J
//Clear defalut KanjiFtc <-- use menu.c GetKanjiFtc();
{
    extern  int KanjiFtc;
    KanjiFtc = ftcNil;
}
#endif

    if (doc != docNil)
        {
        hffntb = HffntbGet(doc);
        iffnMac = imin((*hffntb)->iffnMac, iffnEnumMax);
        pffn = (struct FFN *)rgb;
        for (iffn = 0; iffn < iffnMac; iffn++)
            {
            hffn = (*hffntb)->mpftchffn[iffn];
            bltbyte((*hffn), pffn, CbFromPffn(*hffn));
            if (!FAddEnumFont(pffn))
                goto InitFailure;
            }
        if ((*hffntbEnum)->iffnMac >= cffnInteresting)
            {
            goto HaveCffnInteresting;
            }
        }

#if 0
    /* Include the fonts from WIN.INI in the enumeration */
    if (!FAddProfileFonts())
        {
        goto InitFailure;
        }
#endif

    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;

    if (vhDCPrinter == NULL)
        {
        GetPrinterDC(FALSE);
        Assert(vhDCPrinter);
        }

#ifndef INEFFLOCKDOWN
    if (!(lpFontFaceEnum = MakeProcInstance(FontFaceEnum, hMmwModInstance)))
        {
        WinFailure();
        goto InitFailure;
        }
#endif

    /* See what the system knows about!
       If order ISN'T significant, we'll examine all fonts at once. */

    if (!fOrder)
        {
#ifdef DENUMF
        CommSz("FINITFONTENUM: EnumFonts(all) \n\r");
#endif
        rgw[0] = enumQuickFaces;  // means igonre the rest
#if 0
        rgw[1] = RASTER_FONTTYPE; // ignored, why set?
        rgw[2] = FF_SWISS;        // ignored, why set?
        rgw[3] = TRUE;            // ignored, why set?
        rgw[4] = cffnInteresting; // ignored, why set?
#endif
        EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
        if (vfFontEnumFail)
            goto InitFailure;
        else
            goto HaveCffnInteresting;   /* got what we needed */
        }

#ifdef JAPAN //T-HIROYN Win3.1
    /* japanens write try in steps first
        #1 KANJI_CHARSET device_fonttype mincho
//12/15/92
	add KANJI_CHARSET TRUETYPE FF_ROMAN
	add KANJI_CHARSET TRUETYPE
        #2 KANJI_CHARSET hyoujyun mincho
        #3 KANJI_CHARSET all font FF_ROMAN FIXED_PITCH
    */

    rgw[0] = enumFaceNameJapan;   /* #define in FONTDEFS.H */
    rgw[1] = 0;
    rgw[2] = rgw[3] = 0;   /* dummy */
    rgw[4] = 32767;

    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

// 12/15/92
#if 1
    rgw[1] = 3;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */
    rgw[1] = 4;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */
#endif

    rgw[1] = 1;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

    rgw[1] = 2;
    EnumFonts(vhDCPrinter,0L,lpFontFaceEnum,(LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#endif  /* JAPAN */

    /* Ahh... but since we now know order IS significant, i.e. we are
       trying  to pick good default fonts for startup, we'll try in steps:

          #1--any good TrueType fonts in the Swiss font family?
          #2--any good TrueType fonts in the non-Swiss?
          #3--any good device-based fonts in the Swiss font family?
          #4-- "   "        "         "      non-Swiss?
          #5--any  non device-based fonts in the Swiss font family?
          #6-- "   "        "         "      non-Swiss? */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss truetype) \n\r");
#endif
    rgw[0] = enumFaceNames;
    rgw[1] = TRUETYPE_FONTTYPE;
    rgw[2] = FF_SWISS;
    rgw[3] = TRUE;  /* match swiss! */
    rgw[4] = 32767;

    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(nonSwiss truetype) \n\r");
#endif
    rgw[3] = FALSE;  /* need not match swiss! */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss device) \n\r");
#endif
    rgw[1] = DEVICE_FONTTYPE;
    rgw[3] = TRUE;  /* match swiss! */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(nonSwiss device) \n\r");
#endif
    rgw[3] = FALSE; /* need not match swiss */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss nondevice) \n\r");
#endif
    rgw[1] = RASTER_FONTTYPE;
    rgw[3] = TRUE;  /* match swiss! */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;
    if ((*hffntbEnum)->iffnMac >= cffnInteresting)
        goto HaveCffnInteresting;   /* got what we needed */

#ifdef DENUMF
    CommSz("FINITFONTENUM: EnumFonts(Swiss nondevice) \n\r");
#endif
    rgw[3] = FALSE; /* need not match swiss */
    EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
    if (vfFontEnumFail)
        goto InitFailure;

HaveCffnInteresting:
    iffnEnum = 0;
#ifndef INEFFLOCKDOWN
    if (lpFontFaceEnum)
        FreeProcInstance(lpFontFaceEnum);
#endif

#ifdef JAPAN //T-HIROYN Win3.1
    if(docNil == doc && fOrder)
        SaveKanjiFfn();
#endif

    return(TRUE);

InitFailure:
    FreeFfntb(hffntbEnum);
    hffntbEnum = NULL;
#ifndef INEFFLOCKDOWN
    if (lpFontFaceEnum)
        FreeProcInstance(lpFontFaceEnum);
#endif
    return(FALSE);
    }

void ResetFontTables(void)
{
    /*
        Free the pfce's.  LoadFont will reallocate them with new information
        obtained below.
     */

    FreeFonts(TRUE,TRUE);

    /*  This is a clumsy method that takes advantage of side effect of
        resetting the data stored in the font tables */
    FInitFontEnum(docNil, 32767, FALSE);

#ifdef JAPAN    //T-HIROYN 92.08.18 Win3.1
//Printer Change ?
//Sync FontFaceName and CharSet
{
    int iffn, iffnMac;
    int Eiffn, EiffnMac;
    struct FFNTB **hffntb;
    struct FFN ***mpftchffn;
    struct FFN ***Empftchffn;
    char    msg[30];

    hffntb = HffntbGet(docCur);
    if (hffntb != 0) {
        mpftchffn = (*hffntb)->mpftchffn;
        iffnMac = (*hffntb)->iffnMac;

        Empftchffn = (*hffntbEnum)->mpftchffn;
        EiffnMac = (*hffntbEnum)->iffnMac;

        for (iffn = 0; iffn < iffnMac; iffn++) {
            for (Eiffn = 0; Eiffn < EiffnMac; Eiffn++) {
                if (WCompSz((*mpftchffn[iffn])->szFfn,
                            (*Empftchffn[Eiffn])->szFfn) == 0)
                {
                    (*mpftchffn[iffn])->chs = (*Empftchffn[Eiffn])->chs;
                    break;
                }
            }
        }
    }
}
#endif

    EndFontEnum();
}

CHAR * (NEAR PchSkipSpacesPch( CHAR * ));

int WFromSzNumber( ppch )
CHAR **ppch;
{   /* Given an ASCII string containing a (base 10) number, return the number
       represented.  Ignores leading and trailing spaces.
       Does not accept negative numbers. */
    /* 10/12/89 ..pault
        Now increments the pointer to just past last digit converted */

 unsigned w = 0;
 CHAR ch;

 *ppch = PchSkipSpacesPch( *ppch );
 while ( ((ch = (*(*ppch)++)) >= '0') && (ch <= '9') )
    {
    w = (w * 10) + (ch - '0');
    }

 (*ppch)--; /* bumped one too far */
 return w;
}


CHAR * (NEAR PchSkipSpacesPch( pch ))
CHAR *pch;
{   /* Return a pointer to the first character in the string
       at pch that is either null or non-whitespace */

 for ( ;; ) {
#ifdef DBCS
        /* DB Char space must be checked */
    if (FKanjiSpace(*pch, *(pch + 1))) {
        pch += cchKanji;
        continue;
    }
#endif  /* DBCS */
        switch (*pch) {
            default:
                return pch;
            case ' ':
            case 0x09:
                pch++;
                break;
            }
    }
}


BOOL FEnumFont(pffn)
/* returns the next font entry through pffn.  Returns FALSE if no more */

struct FFN *pffn;
    {
    int cb;
    struct FFN **hffn;

    if (iffnEnum >= (*hffntbEnum)->iffnMac)
        {
        return(FALSE);
        }

    hffn = (*hffntbEnum)->mpftchffn[iffnEnum];
#ifdef DEBUG
    cb = CchSz( (*hffn)->szFfn );
    Assert( cb <= LF_FACESIZE );
    cb = CbFfn( cb );
#else
    cb = CbFfn(CchSz((*hffn)->szFfn));
#endif
    bltbyte(*hffn, pffn, cb);
    iffnEnum++;
    return(TRUE);
    }


EndFontEnum()
/* cleans up after a font enumeration */
    {
    FreeFfntb(hffntbEnum);
    hffntbEnum = NULL;
    }


FAddEnumFont(pffn)
/* code factoring for adding described font to enumeration table - filters
   out "ghost fonts" and system font */

struct FFN *pffn;
    {
#ifdef JAPAN
// It is required to do vertical writing with system font in JAPAN.
    if ( pffn->szFfn[0] == chGhost)
#else
    if (WCompSz(pffn->szFfn, szSystem) == 0 || pffn->szFfn[0] == chGhost)
#endif
        return(TRUE);
    return(FEnsurePffn(hffntbEnum, pffn));
    }

#ifdef JAPAN    //T-HIROYN 92.08.18 Win3.1
BYTE scrFontChs;
//I want to get true Charset
BOOL far PASCAL _export NFontFaceEnum(lplf, lptm, fty, lParam)
LPLOGFONT lplf;
LPTEXTMETRIC lptm;
int fty;
long lParam;
{
        if (LOWORD(lParam) == 0)
        {
            scrFontChs = lplf->lfCharSet;
            return(FALSE);
        }
        return(TRUE);
}
#endif

#ifdef NEWFONTENUM
/* This stuff added for Win3 because we have to be able to determine
   with which character set a font in a particular document is associated,
   since our file format does not store it.  Naturally, WinWord added that
   to their file format!  ..pault */

/* Look through the list of fonts sitting out there [i.e. FInitFontEnum
   must have been called, and it is from HffntbForFn()] and make our best
   guess as to what CharSet it's  supposed to have, since we don't store
   these in the doc font table! */

int ChsInferred( pffn )
struct FFN *pffn;
    {
    struct FFN *pffnCheck;
    char *sz = pffn->szFfn;
#ifdef  DBCS
    int chs = NATIVE_CHARSET;
#else
    int chs = 0;
#endif
    int i, iMac = (*hffntbEnum)->iffnMac;

    for (i = 0; i < iMac; i++)
        {
        pffnCheck = *(struct FFN **) ((*hffntbEnum)->mpftchffn[i]);
        if (WCompSz(pffnCheck->szFfn, sz) == 0)
            {
#ifdef DIAG
            if (pffnCheck->ffid != pffn->ffid)
                {
                CommSzSz("ChsInferred: matched fontname ",sz);
                CommSzNumNum("   but enum->ffid / doc->ffid", pffnCheck->ffid,pffn->ffid);
                }
#endif
            Assert(pffnCheck->ffid == pffn->ffid);
            chs = pffnCheck->chs;
            break;
            }
        }

#ifdef JAPAN    //T-HIROYN 92.08.18 Win3.1
//I want to get true Charset
{
    extern HDC vhMDC;   /* memory DC compatible with the screen */
    FARPROC NlpFontFaceEnum;

    if(i == iMac) {
        if(vhMDC != NULL) {
           if (NlpFontFaceEnum =
                MakeProcInstance(NFontFaceEnum, hMmwModInstance))
           {
                scrFontChs = chs;
                EnumFonts(vhMDC,(LPSTR)sz,NlpFontFaceEnum,(LPSTR) NULL);
                FreeProcInstance(NlpFontFaceEnum);
                if(chs != scrFontChs)
                    chs = scrFontChs;
           }
        }
    }
}
#endif

    return(chs);
    }
#endif /* NEWFONTENUM */

#ifdef JAPAN //T-HIROYN Win3.1
CHAR saveKanjiDefFfn[ibFfnMax];

SaveKanjiFfn()
{
    int i, iMac = (*hffntbEnum)->iffnMac;

    struct FFN *pffn = (struct FFN *)saveKanjiDefFfn;
    struct FFN *hffn;

    for (i = 0; i < iMac; i++)
    {
        hffn = *(struct FFN **) ((*hffntbEnum)->mpftchffn[i]);
        if (NATIVE_CHARSET  == hffn->chs)
        {
            lstrcpy(pffn->szFfn, hffn->szFfn);
            pffn->ffid = hffn->ffid;
            pffn->chs  = hffn->chs;
            break;
        }
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\fontdlg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Fontdlg.c -- WRITE font dialog routines */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"

#ifndef JAPAN //T-HIROYN Win3.1
#define NOUAC
#endif

#include "cmddefs.h"
#include "dlgdefs.h"
#include "propdefs.h"
#include "fontdefs.h"
#include "prmdefs.h"
#include "str.h"
#include "docdefs.h"
#include <commdlg.h>

#ifdef JAPAN //T-HIROYN Win3.1 and added  02 Jun. 1992  by Hiraisi
#include <dlgs.h>
#include <ctype.h>
#include "kanji.h"
BOOL FAR PASCAL _export DeleteFacename( HWND , UINT , WPARAM , LPARAM );
static BOOL NEAR PASCAL KanjiCheckAddSprm(HWND, int, int);
extern int ferror;	//01/21/93
#elif defined(KOREA)  // jinwoo : 10/14/92  : remove @Facename
#include <dlgs.h>
BOOL FAR PASCAL _export DeleteFacename( HWND , UINT , WPARAM , LPARAM );
#endif

extern HDC              vhDCPrinter;
extern struct DOD     (**hpdocdod)[];
extern HANDLE         hMmwModInstance;
extern HANDLE         hParentWw;
extern int            vfSeeSel;
extern int            docCur;
extern HWND           vhWndMsgBoxParent;
extern int            vfCursorVisible;
extern HCURSOR        vhcArrow;

extern int iszSizeEnum;
extern int iszSizeEnumMac;
extern int iszSizeEnumMax;
extern int iffnEnum;
extern int vfFontEnumFail;
extern struct FFNTB **hffntbEnum;


BOOL NEAR FValidateEnumFfid(struct FFN *);

int FAR PASCAL NewFont(HWND hwnd)
{
    TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP */
    int ftc;
    int fSetUndo;
    CHAR rgb[2];
    CHOOSEFONT cf;
    LOGFONT lf;
    HDC hdc;

#if defined(JAPAN) || defined(KOREA) // added  02 Jun. 1992  by Hiraisi : jinwoo 11/10/92
    FARPROC lpfnDeleteFacename;
    int Result;
#endif

    if (!vhDCPrinter)
            return FALSE;

    GetRgtsvChpSel(rgtsv);

    bltbc(&lf, 0, sizeof(LOGFONT));
    bltbc(&cf, 0, sizeof(CHOOSEFONT));

    cf.lStructSize    = sizeof(cf);
    cf.hwndOwner      = hwnd;
    cf.lpLogFont      = &lf;
    cf.hDC        = vhDCPrinter;
    cf.nSizeMin   = 4;
    cf.nSizeMax   = 127;
#ifdef JAPAN	//#3902 T-HIROYN
    cf.Flags      = CF_PRINTERFONTS | CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;
#elif defined(KOREA)                                 // MSCH bklee 01/26/95
    cf.Flags      = CF_NOSIMULATIONS| CF_PRINTERFONTS /*| CF_ANSIONLY*/ | CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;
#else
    cf.Flags      = CF_NOSIMULATIONS| CF_PRINTERFONTS | CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;
#endif

#if defined(JAPAN) || defined(KOREA)   // added  02 Jun. 1992  by Hiraisi : jinwoo 11/10/92
    cf.Flags |= CF_ENABLEHOOK;
    lpfnDeleteFacename = MakeProcInstance( DeleteFacename, hMmwModInstance );
    cf.lpfnHook = (FARPROC)lpfnDeleteFacename;
#endif

    // check for multiple sizes selected
    if (rgtsv[itsvSize].fGray) {
        cf.Flags |= CF_NOSIZESEL;
    } else {
        hdc = GetDC(NULL);
        lf.lfHeight = -MulDiv(rgtsv[itsvSize].wTsv / 2, GetDeviceCaps(hdc, LOGPIXELSY), 72);
        ReleaseDC(NULL, hdc);
    }

    // check for multiple faces selected
    if (rgtsv[itsvFfn].fGray) {
        cf.Flags |= CF_NOFACESEL;
        lf.lfFaceName[0] = 0;
    } else {
        struct FFN **hffn;
        /* then, font name */

        /* note that the value stored in rgtsv[itsvFfn].wTsv
            is the font name handle, rather than the ftc */

        hffn = (struct FFN **)rgtsv[itsvFfn].wTsv;
        lstrcpy(lf.lfFaceName, (*hffn)->szFfn);
    }

    // check for multiple styles selected
        if (rgtsv[itsvBold].fGray || rgtsv[itsvItalic].fGray) {
        cf.Flags |= CF_NOSTYLESEL;
    } else {
            lf.lfWeight = rgtsv[itsvBold].wTsv ? FW_BOLD : FW_NORMAL;
        lf.lfItalic = rgtsv[itsvItalic].wTsv;
    }

#if defined(JAPAN) || defined(KOREA)   // added  02 Jun. 1992  by Hiraisi : jinwoo 11/10/92
    Result = ChooseFont(&cf);
    FreeProcInstance( lpfnDeleteFacename );
    if (!Result)
        return FALSE;
#else
    if (!ChooseFont(&cf))
        return FALSE;
#endif    // JAPAN

    fSetUndo = TRUE;

    if (!(cf.Flags & CF_NOFACESEL))
        {
            CHAR rgbFfn[ibFfnMax];
        struct FFN *pffn = (struct FFN *)rgbFfn;

        lstrcpy(pffn->szFfn, lf.lfFaceName);
            pffn->ffid = lf.lfPitchAndFamily & grpbitFamily;
            pffn->chs  = lf.lfCharSet;

        FValidateEnumFfid(pffn);

            ftc = FtcChkDocFfn(docCur, pffn);

            if (ftc != ftcNil) {
#ifdef JAPAN //T-HIROYN Win3.1
                if ( pffn->chs == NATIVE_CHARSET ||
                    FALSE == KanjiCheckAddSprm(hwnd, ftc, fSetUndo) ) {
                    rgb[0] = sprmCFtc;
                rgb[1] = ftc;
            AddOneSprm(rgb, fSetUndo);
                }
                fSetUndo = FALSE;
				if(ferror)		//01/21/93
					return TRUE;
#else
        rgb[0] = sprmCFtc;
        rgb[1] = ftc;
        AddOneSprm(rgb, fSetUndo);
#ifdef KKBUGFIX
// when font name was changed we can't undo
                fSetUndo = FALSE;
#endif
#endif
            }
    }

    if (!(cf.Flags & CF_NOSIZESEL)) {
            /* we got a value */
            rgb[0] = sprmCHps;
            rgb[1] = cf.iPointSize / 10 * 2; /* KLUDGE alert */
            AddOneSprm(rgb, fSetUndo);
            fSetUndo = FALSE;
    }

    if (!(cf.Flags & CF_NOSTYLESEL)) {
#ifdef KKBUGFIX //T-HIROYN Win3.1
// when font name was changed we can't undo
        ApplyCLooksUndo(sprmCBold, lf.lfWeight > FW_NORMAL, fSetUndo);
            fSetUndo = FALSE;
        ApplyCLooksUndo(sprmCItalic, lf.lfItalic ? 1 : 0, fSetUndo);
#else
        ApplyCLooks(0, sprmCBold, lf.lfWeight > FW_NORMAL);
        ApplyCLooks(0, sprmCItalic, lf.lfItalic ? 1 : 0);
#endif
        }

        return TRUE;
}

BOOL NEAR FValidateEnumFfid(pffn)
/* if the described ffn is in the enumeration table, then make sure we have
   a good family number for it */

struct FFN *pffn;
    {
    int ftc;
    struct FFN *pffnAlready;

    ftc = FtcScanFfn(hffntbEnum, pffn);
    if (ftc != ftcNil)
        {
        pffnAlready = *((*hffntbEnum)->mpftchffn[ftc]);
#ifdef JAPAN
        // Few fonts would be enumnrated with FF_DONTCARE in JAPAN
        // we won't check ffid here.
#else
        if (pffnAlready->ffid != FF_DONTCARE)
#endif
            {
            pffn->ffid = pffnAlready->ffid;
#ifdef NEWFONTENUM
            pffn->chs = pffnAlready->chs;
#endif
            return(TRUE);
            }
        }
    return(FALSE);
    }

#ifdef JAPAN //T-HIROYN Win3.1
/*