lPlatformVersion5;
GLOBAL DWORD GlobalPlatformMillennium = FALSE;
GLOBAL DWORD GlobalPlatformWhistler = FALSE;
GLOBAL DWORD GlobalDllState = INTERNET_STATE_ONLINE | INTERNET_STATE_IDLE;
GLOBAL BOOL GlobalDataInitialized = FALSE;
GLOBAL BOOL  GlobalTruncateFileName = FALSE;

//
// WinInet DLL version information (mainly for diagnostics)
//

#if INET_DEBUG

GLOBAL DWORD InternetMajorVersion = 1;
GLOBAL DWORD InternetMinorVersion = 0;

#endif // INET_DEBUG

#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

GLOBAL DWORD InternetBuildNumber = VER_PRODUCTBUILD;

//
// transport-based time-outs, etc.
//

//GLOBAL DWORD GlobalConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
#ifndef unix
GLOBAL DWORD GlobalConnectTimeout = 5 * 60 * 1000;
#else
GLOBAL DWORD GlobalConnectTimeout = 1 * 60 * 1000;
#endif /* unix */
GLOBAL DWORD GlobalConnectRetries = DEFAULT_CONNECT_RETRIES;
GLOBAL DWORD GlobalSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL DWORD GlobalReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL DWORD GlobalDataSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL DWORD GlobalDataReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL DWORD GlobalFromCacheTimeout = (DWORD)-1;
GLOBAL DWORD GlobalFtpAcceptTimeout = DEFAULT_FTP_ACCEPT_TIMEOUT;
GLOBAL DWORD GlobalTransportPacketLength = DEFAULT_TRANSPORT_PACKET_LENGTH;
GLOBAL DWORD GlobalKeepAliveSocketTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;
GLOBAL DWORD GlobalSocketSendBufferLength = DEFAULT_SOCKET_SEND_BUFFER_LENGTH;
GLOBAL DWORD GlobalSocketReceiveBufferLength = DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH;
GLOBAL DWORD GlobalMaxHttpRedirects = DEFAULT_MAX_HTTP_REDIRECTS;
GLOBAL DWORD GlobalMaxConnectionsPerServer = DEFAULT_MAX_CONNECTIONS_PER_SERVER;
GLOBAL DWORD GlobalMaxConnectionsPer1_0Server = DEFAULT_MAX_CONS_PER_1_0_SERVER;
GLOBAL DWORD GlobalConnectionInactiveTimeout = DEFAULT_CONNECTION_INACTIVE_TIMEOUT;
GLOBAL DWORD GlobalServerInfoTimeout = DEFAULT_SERVER_INFO_TIMEOUT;
GLOBAL const DWORD GlobalMaxSizeStatusLineResultText = 1024;
GLOBAL BOOL  GlobalHaveInternetOpened = FALSE;
GLOBAL BOOL  GlobalBypassEditedEntry = FALSE;

GLOBAL DWORD GlobalCacheMode = 0;

//GLOBAL DWORD GlobalServerInfoAllocCount = 0;
//GLOBAL DWORD GlobalServerInfoDeAllocCount = 0;

//
// async worker thread variables
//

//GLOBAL DWORD GlobalMinimumWorkerThreads = DEFAULT_MINIMUM_THREADS;
//GLOBAL DWORD GlobalMaximumWorkerThreads = DEFAULT_MAXIMUM_THREADS;
//GLOBAL DWORD GlobalInitialWorkerThreads = DEFAULT_INITIAL_THREADS;
//GLOBAL DWORD GlobalWorkerThreadIdleTimeout = DEFAULT_THREAD_IDLE_TIMEOUT;
//GLOBAL DWORD GlobalWorkQueueLimit = DEFAULT_WORK_QUEUE_LIMIT;
GLOBAL DWORD GlobalWorkerThreadTimeout = DEFAULT_WORKER_THREAD_TIMEOUT;

GLOBAL BOOL g_bHibernating = FALSE;
GLOBAL BOOL g_bDisableHibernation = FALSE;
//
// switches
//

GLOBAL BOOL InDllCleanup = FALSE;
GLOBAL BOOL GlobalPleaseQuitWhatYouAreDoing = FALSE;
GLOBAL BOOL GlobalDynaUnload = FALSE;
GLOBAL BOOL GlobalDisableKeepAlive = FALSE;
GLOBAL BOOL GlobalDisablePassport = FALSE;
GLOBAL BOOL GlobalEnableHttp1_1 = FALSE;
GLOBAL BOOL GlobalEnableProxyHttp1_1 = FALSE;
GLOBAL BOOL GlobalDisableReadRange = FALSE;
GLOBAL BOOL GlobalEnableGopher = FALSE;

//GLOBAL BOOL GlobalAutoProxyInDeInit = FALSE;
GLOBAL BOOL GlobalIsProcessExplorer = FALSE;
#ifndef UNIX
GLOBAL BOOL GlobalEnableFortezza = TRUE;
#else /* for UNIX */
GLOBAL BOOL GlobalEnableFortezza = FALSE;
#endif /* UNIX */

#if defined(SITARA)

GLOBAL BOOL GlobalEnableSitara = FALSE;
GLOBAL BOOL GlobalHasSitaraModemConn = FALSE;

#endif // SITARA

GLOBAL BOOL GlobalEnableUtf8Encoding = FALSE;
GLOBAL BOOL GlobalEnableRevocation = FALSE;

// SSL Switches  (petesk 7/24/97)
GLOBAL DWORD GlobalSecureProtocols  = DEFAULT_SECURE_PROTOCOLS;

GLOBAL DWORD GlobalSslStateCount = 0;

//
// AutoDetect Proxy Globals
//

GLOBAL LONG GlobalInternetOpenHandleCount = -1;
GLOBAL DWORD GlobalProxyVersionCount = 0;
GLOBAL BOOL GlobalAutoProxyNeedsInit = FALSE;
GLOBAL BOOL GlobalAutoProxyInInit = FALSE;
GLOBAL BOOL GlobalAutoProxyCacheEnable = TRUE;
GLOBAL BOOL GlobalDisplayScriptDownloadFailureUI = FALSE;

GLOBAL BOOL GlobalSendUTF8ServerToProxy = TRUE;
GLOBAL BOOL GlobalMBCSAPIforCrack = TRUE;
GLOBAL BOOL GlobalUseUTF8ServerForNameRes = FALSE;

//
//  Workaround for Novell's Client32
//

GLOBAL BOOL fDontUseDNSLoadBalancing = FALSE;

//
// Workaround for slow RAS enumeration
//
GLOBAL BOOL GlobalDisableNT4RasCheck = FALSE;
GLOBAL BOOL GlobalUseLanSettings = FALSE;

GLOBAL BOOL GlobalSendExtraCRLF = TRUE;

//Ftp time checking
GLOBAL BOOL  GlobalBypassFtpTimeCheck = FALSE;

//
// lists
//

GLOBAL SERIALIZED_LIST GlobalObjectList = {0};
GLOBAL SERIALIZED_LIST GlobalServerInfoList = {0};

//
// cache timeouts
//

GLOBAL LONGLONG dwdwHttpDefaultExpiryDelta = 12 * 60 * 60 * (LONGLONG)10000000;  // 12 hours in 100ns units
GLOBAL LONGLONG dwdwFtpDefaultExpiryDelta = 24 * 60 * 60 * (LONGLONG)10000000;  // 24 hours in 100ns units
GLOBAL LONGLONG dwdwGopherDefaultExpiryDelta = 24 * 60 * 60 * (LONGLONG)10000000;  // 24 hours in 100ns units
GLOBAL LONGLONG dwdwSessionStartTime;
GLOBAL LONGLONG dwdwSessionStartTimeDefaultDelta = 0;

GLOBAL DWORD GlobalUrlCacheSyncMode = WININET_SYNC_MODE_DEFAULT;
GLOBAL DWORD GlobalDiskUsageLowerBound = (4*1024*1024);
GLOBAL DWORD GlobalScavengeFileLifeTime = (10*60);

GLOBAL LPSTR vszMimeExclusionList=NULL, vszHeaderExclusionList=NULL;

GLOBAL LPSTR *lpvrgszMimeExclusionTable=NULL, *lpvrgszHeaderExclusionTable=NULL;

GLOBAL DWORD *lpvrgdwMimeExclusionTableOfSizes=NULL;

GLOBAL DWORD vdwMimeExclusionTableCount=0, vdwHeaderExclusionTableCount=0;

//
// SSL globals, for UI.  We need to know
//  whether its ok for us to pop up UI.
//
//

GLOBAL BOOL GlobalWarnOnPost = FALSE;
GLOBAL BOOL GlobalWarnAlways = FALSE;
GLOBAL BOOL GlobalWarnOnZoneCrossing = TRUE;
GLOBAL BOOL GlobalWarnOnBadCertSending = FALSE;
GLOBAL BOOL GlobalWarnOnBadCertRecving = TRUE;
GLOBAL BOOL GlobalDisableSslCaching = FALSE;
GLOBAL BOOL GlobalWarnOnPostRedirect = TRUE;
GLOBAL BOOL GlobalAlwaysDrainOnRedirect = FALSE;
GLOBAL BOOL GlobalBypassSSLNoCacheCheck = FALSE;
GLOBAL BOOL GlobalWarnOnHTTPSToHTTPRedirect = TRUE;


GLOBAL SECURITY_CACHE_LIST GlobalCertCache;

GLOBAL DWORD GlobalSettingsVersion=0; // crossprocess settings versionstamp
GLOBAL BOOL GlobalSettingsLoaded = FALSE;

GLOBAL const char vszSyncMode[] = "SyncMode5";

GLOBAL const char vszDisableSslCaching[] = "DisableCachingOfSSLPages";
GLOBAL BOOL GlobalDisableNTLMPreAuth = FALSE;

GLOBAL char vszCurrentUser[MAX_PATH];
GLOBAL DWORD vdwCurrentUserLen = 0;

//
// critical sections
//

GLOBAL CRITICAL_SECTION AutoProxyDllCritSec = {0};
GLOBAL CRITICAL_SECTION LockRequestFileCritSec = {0};
GLOBAL CRITICAL_SECTION ZoneMgrCritSec = {0};
GLOBAL CRITICAL_SECTION MlangCritSec  = {0};


// cookies info

GLOBAL BOOL vfPerUserCookies = TRUE;
const char  vszAnyUserName[]="anyuser";
const char  vszPerUserCookies[] = "PerUserCookies";
const char  vszInvalidFilenameChars[] = "<>\\\"/:|?*";

GLOBAL BOOL GlobalLeashLegacyCookies = TRUE;
const char vszLeashLegacyCookies[] = REGSTR_LEASH_LEGACY_COOKIES;

// Hard-coded user agent string
// Update for each different version of IE 
#if defined(UNIX)
const char gszDefaultUserAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; X11)";
#elif defined(_WIN64)
const char gszDefaultUserAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; Win64)";
#else
const char gszDefaultUserAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; Win32)";
#endif




// Mlang related data and functions.
PRIVATE HINSTANCE hInstMlang;
PRIVATE PFNINETMULTIBYTETOUNICODE pfnInetMultiByteToUnicode;
PRIVATE BOOL bFailedMlangLoad;  // So we don't try repeatedly if we fail once.
BOOL LoadMlang( );
BOOL UnloadMlang( );
#define MLANGDLLNAME    "mlang.dll"


// shfolder.dll hmod handle
HMODULE g_HMODSHFolder = NULL;
// Shell32.dll hmod handle
HMODULE g_HMODShell32 = NULL;

GLOBAL CUserName GlobalUserName;

//
// novell client32 (hack) "support"
//

GLOBAL BOOL GlobalRunningNovellClient32 = FALSE;
GLOBAL BOOL GlobalNonBlockingClient32 = FALSE;

//
// private data
//

HANDLE g_hAutodialMutex = NULL;

//
// proxy info
//

GLOBAL PROXY_INFO_GLOBAL GlobalProxyInfo;

//
// DLL version info
//

GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WININET_MAJOR_VERSION,
    WININET_MINOR_VERSION
};

//
// HTTP version info - default 1.0
//

GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 0};


GLOBAL BOOL fCdromDialogActive = FALSE;
GLOBAL DWORD g_dwCredPersistAvail = CRED_PERSIST_UNKNOWN;

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

GLOBAL char gszAt[]   = "@";
GLOBAL char gszBang[] = "!";
GLOBAL char gszCRLF[] = "\r\n";


extern GLOBAL SERIALIZED_LIST BlockedRequestQueue;


// Identity-related globals
GLOBAL DWORD GlobalIdentity = 0;
GLOBAL GUID  GlobalIdentityGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
GLOBAL BOOL GlobalSuppressCookiesPolicy = FALSE;
#ifdef WININET6
GLOBAL HKEY GlobalCacheHKey = HKEY_CURRENT_USER;
#endif

GLOBAL PTSTR GlobalSpecialDomains = NULL;
GLOBAL PTSTR *GlobalSDOffsets = NULL;

// auth globals

DWORD GlobalEnableNegotiate = FALSE;


// Nt service loading wininet. This triggers special semantics for webdav redir to avoid deadlocks
// due to crossprocessmutexes being taken (ConnectionMutex is a good example of that)
// (Shishir Pardikar)

GLOBAL BOOL GlobalIsProcessNtService = FALSE;

// Global Cred hack for Mars V2

PWC * g_pwcUserAndPassword;


// Begin (a-thkesa)
// The following global added to read expire time value from registry:Default is 30 Min
// See Windows Bug:557284/WinSE:23879 
// Declared in proxysup.hxx
GLOBAL DWORD GlobalBadProxyExpiresTime = 30*60; // this will be multiplied 
// End(a-thkesa)  


BOOL       g_fHasCredsTimestamp;
SYSTEMTIME g_TimeCredsEntered;

void SetUserOrPass (LPSTR lpszIn, BOOL fUser)
{
    if (NULL == g_pwcUserAndPassword)
    {
        g_pwcUserAndPassword = PWC_Create(NULL, 0, NULL, NULL, NULL);
    }

    if (g_pwcUserAndPassword)
    {
        AuthLock();

        if (fUser)
        {
            g_pwcUserAndPassword->SetUser(lpszIn);
        }
        else
        {
            g_pwcUserAndPassword->SetPass(lpszIn);
        }

        AuthUnlock();
    }
}

void TimeStampCreds(void) 
{
    ::GetSystemTime(&g_TimeCredsEntered); // time-stamp the creds
    g_fHasCredsTimestamp = TRUE;
}

PSYSTEMTIME GetCredTimeStamp (void) 
{
    if (g_fHasCredsTimestamp)
    {
        return &g_TimeCredsEntered;
    } 
    else 
    {
        return NULL;
    }
}

BOOL GetUserAndPass (LPSTR *pszUser, LPSTR *pszPass)
{
    if (g_pwcUserAndPassword)
    {
        if (g_pwcUserAndPassword->lpszUser && g_pwcUserAndPassword->lpszPass)
        {
            *pszUser = g_pwcUserAndPassword->GetUser();
            *pszPass = g_pwcUserAndPassword->GetPass();
            return TRUE;
        }
    }

    *pszUser = *pszPass = NULL;
    return FALSE;
}

//
// functions
//


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllInitialize(
    VOID
    )

/*++

Routine Description:

    The set of initializations - critical sections, etc. - that must be done at
    DLL_PROCESS_ATTACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllInitialize",
                 NULL
                 ));

    CLEAR_DEBUG_CRIT(szDebugBlankBuffer);

    GetCurrentGmtTime((LPFILETIME)&dwdwSessionStartTime);

    InitializeCriticalSection(&AutoProxyDllCritSec);
    InitializeCriticalSection(&LockRequestFileCritSec);
    InitializeCriticalSection(&ZoneMgrCritSec);
    InitializeCriticalSection(&MlangCritSec);


    InitializeSerializedList(&GlobalObjectList);
    InitializeSerializedList(&GlobalServerInfoList);
    InitializeSerializedList(&BlockedRequestQueue);

    AuthOpen();

    IwinsockInitialize();
    SecurityInitialize();
    FtpInitialize();
    GopherInitialize();

    //
    // initialize cache critical sections etc.
    //

    DLLUrlCacheEntry(DLL_PROCESS_ATTACH);

    EnsureInternetSettingsKeyCached();

    DEBUG_LEAVE(0);
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes the initializations of GlobalDllInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllTerminate",
                 NULL
                 ));

    //
    // only perform resource clean-up if this DLL is being unloaded due to a
    // FreeLibrary() call. Otherwise, we take the lazy way out and let the
    // system clean up after us
    //

    if (GlobalDynaUnload) {
        TerminateAsyncSupport();
        GopherTerminate();
        FtpTerminate();
        IwinsockTerminate();
        HandleTerminate();
    }

    CHECK_SOCKETS();

    AuthClose();

    TerminateSerializedList(&BlockedRequestQueue);
    TerminateSerializedList(&GlobalServerInfoList);

    //
    //BUGBUG: we can't Terminate the list here because
    //        of a race condition from IE3
    //        (someone still holds the handle)
    //        but we don't want to leak the CritSec
    //        TerminateSerlizedList == DeleteCritSec + some Asserts
    //
    //TerminateSerializedList(&GlobalObjectList);
    DeleteCriticalSection(&(GlobalObjectList.Lock));


    DeleteCriticalSection(&MlangCritSec);
    DeleteCriticalSection(&ZoneMgrCritSec);
    DeleteCriticalSection(&LockRequestFileCritSec);
    DeleteCriticalSection(&AutoProxyDllCritSec);

    DLLUrlCacheEntry(DLL_PROCESS_DETACH);

    SecurityTerminate();

    if (g_HMODSHFolder)
    {
        FreeLibrary(g_HMODSHFolder);
        g_HMODSHFolder = NULL;
    }
    if (g_HMODShell32)
    {
        FreeLibrary(g_HMODShell32);
        g_HMODShell32 = NULL;
    }
    
    CloseInternetSettingsKey();

    DEBUG_LEAVE(0);
}


DWORD
GlobalDataInitialize(
    VOID
    )

/*++

Routine Description:

    Loads any global data items from the registry

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "GlobalDataInitialize",
                 NULL
                 ));

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    static DWORD error = ERROR_SUCCESS;
    
    //
    // only one thread initializes
    //

    if (InterlockedExchange((LPLONG)&Initializing, TRUE)) {
        while (!Initialized) {
            SleepEx(0, TRUE);
        }
        goto done;
    }

    //
    // we ignore any failure return codes from reading the registry. All the
    // global variables are initialized to default values
    //

    //
    // UseSchannelDirectly - TRUE if we are to bypass SSPI "Secur32/Security"
    //      and directly call into SCHANNEL.  This should give us a perf
    //      improvement since we don't have to load an extra DLL.
    //

    g_fHasCredsTimestamp = FALSE;

//
// BUGBUG - all these need to be per-process. They are intended for IE
//
    memset(&GlobalIdentityGuid, 0, sizeof(GlobalIdentityGuid));

    InternetReadRegistryDword("FromCacheTimeout",
                              (LPDWORD)&GlobalFromCacheTimeout
                              );

    //InternetReadRegistryDword("UseSchannelDirectly",
    //                          (LPDWORD)&GlobalUseSchannelDirectly
    //                          );

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("SecureProtocols",
                              (LPDWORD)&GlobalSecureProtocols
                              );

    // also in ChangeGlobalSettings()
    if (!GlobalPlatformWhistler)
    {
        // Fortezza support has been removed from XP
        InternetReadRegistryDword("Fortezza",
                                  (LPDWORD)&GlobalEnableFortezza
                                  );
    }
    else
    {
        GlobalEnableFortezza = FALSE;
    }

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("CertificateRevocation",
                              (LPDWORD)&GlobalEnableRevocation
                              );

    InternetReadRegistryDword("DisableKeepAlive",
                              (LPDWORD)&GlobalDisableKeepAlive
                              );

    InternetReadRegistryDword("DisablePassport",
                          (LPDWORD)&GlobalDisablePassport
                          );

    InternetReadRegistryDword("CacheMode", (LPDWORD) &GlobalCacheMode);

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("EnableHttp1_1",
                              (LPDWORD)&GlobalEnableHttp1_1
                              );

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("ProxyHttp1.1",
                              (LPDWORD)&GlobalEnableProxyHttp1_1
                              );

    DWORD dwEnableNegotiate = -1;
    InternetReadRegistryDword("EnableNegotiate",
                      (LPDWORD)&dwEnableNegotiate
                      );
    if (dwEnableNegotiate != -1)
    {
        // the value is present in the registy, so we honor it.
        GlobalEnableNegotiate = dwEnableNegotiate;
    }
    else
    {
        if (GlobalPlatformWhistler && !IsInGUIModeSetup())
        {
            // the value is abscent in Whistler, we'll need to turn set the value to 1
            InternetWriteRegistryDword("EnableNegotiate", 1);
            GlobalEnableNegotiate = TRUE;
        }
    }


    GetUrlCacheHeaderData(CACHE_HEADER_DATA_DOWNLOAD_PARTIAL, &GlobalSslStateCount);


    DWORD dwType, dwSize;

    dwSize = sizeof(DWORD);

    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "EnableAutoProxyResultCache", &dwType, &GlobalAutoProxyCacheEnable, &dwSize);

    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "DisplayScriptDownloadFailureUI", &dwType, &GlobalDisplayScriptDownloadFailureUI, &dwSize);

    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "MBCSServername", &dwType, &GlobalSendUTF8ServerToProxy, &dwSize);
    
    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "MBCSAPIforCrack", &dwType, &GlobalMBCSAPIforCrack, &dwSize);

    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "UTF8ServerNameRes", &dwType, &GlobalUseUTF8ServerForNameRes, &dwSize);

    //Read DisableWorkerThreadHibernation from HKLM first and allow HKCU override.
    InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                 "DisableWorkerThreadHibernation",
                                 (LPDWORD)&g_bDisableHibernation
                                 );
    InternetReadRegistryDword("DisableWorkerThreadHibernation",
                              (LPDWORD)&g_bDisableHibernation
                              );
                              
    GlobalUseUTF8ServerForNameRes = GlobalUseUTF8ServerForNameRes 
                            && GlobalSendUTF8ServerToProxy;
                              
    InternetReadRegistryDword("DisableReadRange",
                              (LPDWORD)&GlobalDisableReadRange
                              );

    InternetReadRegistryDword("SocketSendBufferLength",
                              &GlobalSocketSendBufferLength
                              );

    InternetReadRegistryDword("SocketReceiveBufferLength",
                              &GlobalSocketReceiveBufferLength
                              );

    InternetReadRegistryDword("KeepAliveTimeout",
                              &GlobalKeepAliveSocketTimeout
                              );

    InternetReadRegistryDword("MaxHttpRedirects",
                              &GlobalMaxHttpRedirects
                              );

    InternetReadRegistryDword("MaxConnectionsPerServer",
                              &GlobalMaxConnectionsPerServer
                              );

    InternetReadRegistryDword("MaxConnectionsPer1_0Server",
                              &GlobalMaxConnectionsPer1_0Server
                              );

    InternetReadRegistryDword("ServerInfoTimeout",
                              &GlobalServerInfoTimeout
                              );

    InternetReadRegistryDword("ReceiveTimeOut",
                              (LPDWORD)&GlobalReceiveTimeout
                              );

    InternetReadRegistryDword("DisableNTLMPreAuth",
                              (LPDWORD)&GlobalDisableNTLMPreAuth
                              );

    InternetReadRegistryDword("ScavengeCacheLowerBound",
                              (LPDWORD)&GlobalDiskUsageLowerBound
                              );

    InternetCacheReadRegistryDword("ScavengeCacheFileLifeTime",
                              (LPDWORD)&GlobalScavengeFileLifeTime
                              );

    DWORD dwDefTime;

    if (InternetReadRegistryDword("HttpDefaultExpiryTimeSecs", &dwDefTime) ==
            ERROR_SUCCESS) {
        dwdwHttpDefaultExpiryDelta = dwDefTime * (LONGLONG)10000000;
    }

    if (InternetReadRegistryDword("FtpDefaultExpiryTimeSecs", &dwDefTime) ==
            ERROR_SUCCESS) {
        dwdwFtpDefaultExpiryDelta = dwDefTime * (LONGLONG)10000000;
    }

    if (InternetReadRegistryDword("GopherDefaultExpiryTimeSecs", &dwDefTime) ==
            ERROR_SUCCESS) {
        dwdwGopherDefaultExpiryDelta = dwDefTime * (LONGLONG)10000000;
    }

    InternetReadRegistryDword(vszDisableSslCaching, (LPDWORD)&GlobalDisableSslCaching);

    InternetReadRegistryDword(vszPerUserCookies, (LPDWORD)&vfPerUserCookies);

    InternetReadRegistryDword(vszLeashLegacyCookies, (LPDWORD)&GlobalLeashLegacyCookies);

    InternetReadRegistryDword("DisableNT4RasCheck", (LPDWORD)&GlobalDisableNT4RasCheck);
    InternetReadRegistryDword("DialupUseLanSettings", (LPDWORD)&GlobalUseLanSettings);

    InternetReadRegistryDword("SendExtraCRLF", (LPDWORD)&GlobalSendExtraCRLF);
    InternetReadRegistryDword("BypassFtpTimeCheck", (LPDWORD)&GlobalBypassFtpTimeCheck);

    InternetReadRegistryDword("EnableGopher", (LPDWORD)&GlobalEnableGopher);

    dwSize = sizeof(DWORD);
    SHRegGetUSValue( INTERNET_SETTINGS_KEY, "BypassSSLNoCacheCheck", &dwType, 
                    (LPVOID)&GlobalBypassSSLNoCacheCheck, &dwSize, FALSE, NULL, 0 );


    //
    //  fix for Novell's Client32 - zekel 23-jul-96
    //  first check HKLM then HKCU, HKCU takes precdence
    //

    InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                 "DontUseDNSLoadBalancing",
                                 (LPDWORD)&fDontUseDNSLoadBalancing
                                 );
    InternetReadRegistryDword("DontUseDNSLoadBalancing",
                              (LPDWORD) &fDontUseDNSLoadBalancing
                              );

    InternetReadRegistryDword("NonBlockingClient32",
                              (LPDWORD)&GlobalNonBlockingClient32
                              );

    //
    // Get the list of MIME types for which caching needs to be disabled
    //

    CreateMimeExclusionTableForCache();

    //
    // Get the list of headers that should be excluded from the cache
    //

    CreateHeaderExclusionTableForCache();


    DEBUG_PRINT(HTTP,
                INFO,
                ("Current wininet user is %s length %d\n",
                vszCurrentUser,
                vdwCurrentUserLen
                ));


    //
    // initialize databases
    //

    InitializeResolverCache();
    GlobalDataReadWarningUIFlags();

    PerformStartupProcessing();

    //
    // create the global keep-alive, cert-cache and proxy lists
    //

    GlobalCertCache.Initialize();
    GlobalProxyInfo.InitializeProxySettings();
    

    //LoadServerInfoDatabase();


    //
    // initialize offline mode from registry
    //

    RefreshOfflineFromRegistry();

    //
    // read the global (cache) settings version to avoid an unnecessary reload
    // N.B. we rely on the side effect of calling urlcache InitGlobals
    //
    InternetSettingsChanged();

    char buf[MAX_PATH + 1];

    if (GetModuleFileName(NULL, buf, sizeof(buf))) {
        LPSTR p = strrchr(buf, DIR_SEPARATOR_CHAR);
        p = p ? ++p : buf;

        DEBUG_PRINT(INET, INFO, ("process is %q\n", p));

        if (lstrcmpi(p, "EXPLORER.EXE") && lstrcmpi(p, "IEXPLORE.EXE")) {

            //
            // yet another app-hack: AOL's current browser can't understand
            // HTTP 1.1. When they do, they have to call InternetSetOption()
            // with INTERNET_OPTION_HTTP_VERSION
            //

            if (!lstrcmpi(p, "WAOL.EXE")) {
                GlobalEnableHttp1_1 = FALSE;
            }


            if (!lstrcmpi(p, "SVCHOST.EXE")     ||
                !lstrcmpi(p, "SERVICES.EXE")) {
                GlobalIsProcessNtService = TRUE;
            }
            
            //
            // non-IE app must supply this through option
            //

            GlobalFromCacheTimeout = (DWORD)-1;
        } else {
            GlobalIsProcessExplorer = TRUE;
        }
    } else {

        DEBUG_PRINT(INET,
                    INFO,
                    ("GetModuleFileName() returns %d\n",
                    GetLastError()
                    ));

    }

    

    //
    // initialize the autodial code
    //

    // NB!!! this has been moved AFTER the above app hack because it uses the GlobalIsProcessNtService
    // variable to decide whether to create a perprocess connection mutex or cross-process
    // (Shishir Pardikar)

    InitAutodialModule(FALSE);




#if defined(SITARA)

    //
    // check if Sitara is loaded (IE5B1). Existence of key means Sitara
    // installed
    //

    HKEY key;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\InternetExpressLane",
                     0,
                     KEY_QUERY_VALUE,
                     &key) == ERROR_SUCCESS) {
        REGCLOSEKEY(key);
        OpenIeMainKey();
        GlobalEnableSitara = CheckABS();
    }

#endif // SITARA

    DWORD urlEncoding;

    urlEncoding = 0;
    InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                 "UrlEncoding",
                                 &urlEncoding
                                 );
    if (urlEncoding == 0) {
        GlobalEnableUtf8Encoding = TRUE;
    }

    // File name truncate ?
    DWORD dwTruncateFileName;

    dwTruncateFileName = 0;
    InternetReadRegistryDword("TruncateFileName", &dwTruncateFileName);

    if (dwTruncateFileName != 0) 
        GlobalTruncateFileName = TRUE;

    //
    // perform module/package-specific initialization
    //

    error = HandleInitialize();
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // initalize the cookie system
    //

    if (!OpenTheCookieJar()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // initialize the background task manager
    //
    if( !LoadBackgroundTaskMgr() ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        //goto quit;
    }


	// Begin (a-thkesa) 
	// Read GlobalBadProxyExpiresTime value from the registry.
	  InternetReadRegistryDword("BadProxyExpiresTime", (LPDWORD)&GlobalBadProxyExpiresTime);
	// End (a-thkesa)


quit:

    //
    // finally, if EnableHttp1_1 was set to non-zero in the registry, enable
    // HTTP 1.1
    //

    if (GlobalEnableHttp1_1) {
        HttpVersionInfo.dwMajorVersion = 1;
        HttpVersionInfo.dwMinorVersion = 1;
    }

    if (error == ERROR_SUCCESS) {
        GlobalDataInitialized = TRUE;
    }

    //
    // irrespective of success or failure, we have attempted global data
    // initialization. If we failed then we assume its something fundamental
    // and fatal: we don't try again
    //

    Initialized = TRUE;

done:

    DEBUG_LEAVE(error);

    return error;
}


VOID
GlobalDataReadWarningUIFlags(
    VOID
    )

/*++

Routine Description:

    Reads Registry values into global data.
    Used to read read the registry on connects.

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataReadWarningUIFlags",
                 NULL
                 ));

#ifndef WININET6
    //
    // Load SSL Values from the Registry on whether to pop up UI on error.
    //

    InternetReadRegistryDword("WarnOnPost", (LPDWORD)&GlobalWarnOnPost);

    GlobalWarnAlways = FALSE;
    InternetReadRegistryDword("WarnAlwaysOnPost", (LPDWORD)&GlobalWarnAlways);

    //
    // If Global Warn On Post is set to "2" we reset the "WarnAlways" to TRUE,
    //  since this is the new way INETCPL reads/writes the registry.
    //

    if ( GlobalWarnOnPost == 2 )
    {
        GlobalWarnAlways = TRUE;
    }

    InternetReadRegistryDword("WarnOnZoneCrossing", (LPDWORD)&GlobalWarnOnZoneCrossing);

    InternetReadRegistryDword("WarnOnBadCertSending", (LPDWORD)&GlobalWarnOnBadCertSending);

    InternetReadRegistryDword("WarnOnBadCertRecving", (LPDWORD)&GlobalWarnOnBadCertRecving);

    InternetReadRegistryDword("WarnOnPostRedirect", (LPDWORD)&GlobalWarnOnPostRedirect);

    InternetReadRegistryDword("AlwaysDrainOnRedirect", (LPDWORD)&GlobalAlwaysDrainOnRedirect);
    
    InternetReadRegistryDword("WarnOnHTTPSToHTTPRedirect", (LPDWORD)&GlobalWarnOnHTTPSToHTTPRedirect);

#else
    //
    // Load SSL Values from the Registry on whether to pop up UI on error.
    //

    InternetIDEReadRegistryDword("WarnOnPost", (LPDWORD)&GlobalWarnOnPost);

    GlobalWarnAlways = FALSE;
    InternetIDEReadRegistryDword("WarnAlwaysOnPost", (LPDWORD)&GlobalWarnAlways);

    //
    // If Global Warn On Post is set to "2" we reset the "WarnAlways" to TRUE,
    //  since this is the new way INETCPL reads/writes the registry.
    //

    if ( GlobalWarnOnPost == 2 )
    {
        GlobalWarnAlways = TRUE;
    }

    InternetIDEReadRegistryDword("WarnOnZoneCrossing", (LPDWORD)&GlobalWarnOnZoneCrossing);

    InternetIDEReadRegistryDword("WarnOnBadCertSending", (LPDWORD)&GlobalWarnOnBadCertSending);



    InternetIDEReadRegistryDword("WarnOnBadCertRecving", (LPDWORD)&GlobalWarnOnBadCertRecving);

    InternetIDEReadRegistryDword("WarnOnPostRedirect", (LPDWORD)&GlobalWarnOnPostRedirect);

    InternetIDEReadRegistryDword("WarnOnHTTPSToHTTPRedirect", (LPDWORD)&GlobalWarnOnHTTPSToHTTPRedirect);
#endif


    DEBUG_LEAVE(0);
}


VOID
GlobalDataTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes work of GlobalDataInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataTerminate",
                 NULL
                 ));

    //
    // Release background task manager
    //
    UnloadBackgroundTaskMgr();

    PWC_Free(g_pwcUserAndPassword);

    AuthUnload();
    UrlZonesDetach();

    TerminateResolverCache();
    CloseTheCookieJar();

    if (GlobalSpecialDomains)
    {
        delete [] GlobalSpecialDomains;
        delete [] GlobalSDOffsets;
    }
    
    //
    // destroy lists created from registry
    //

    DestroyMimeExclusionTableForCache();
    DestroyHeaderExclusionTableForCache();

    //
    // terminate the global cert-cache and proxy lists
    //

    GlobalCertCache.Terminate();
    GlobalProxyInfo.TerminateProxySettings();


    //SaveServerInfoDatabase();
    PurgeServerInfoList(TRUE);

    //TerminateAsyncSupport();

    //
    // free up the handle to the startup mutex
    //
    if (g_hAutodialMutex) {
        CloseHandle(g_hAutodialMutex);
    }

#if defined(SITARA)

    CloseIeMainKey();

#endif // SITARA

    UnloadMlang();
    UnloadSecurity();

    GlobalDataInitialized = FALSE;

    DEBUG_LEAVE(0);
}


BOOL
IsHttp1_1(
    VOID
    )

/*++

Routine Description:

    Determine if we are using HTTP 1.1 or greater

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    return (HttpVersionInfo.dwMajorVersion > 1)
            ? TRUE
            : (((HttpVersionInfo.dwMajorVersion == 1)
                && (HttpVersionInfo.dwMajorVersion >= 1))
                ? TRUE
                : FALSE);
}


BOOL
IsOffline(
    VOID
    )

/*++

Routine Description:

    Returns whether we are in (global) offline mode or not. We are offline if
    we went offline because of network failure, or we were put into offline
    mode by the user

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - we are currently offline

        FALSE   - not offline

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Bool,
                 "IsOffline",
                 NULL
                 ));

    INET_ASSERT(((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_ONLINE)
                || ((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE));
    INET_ASSERT((GlobalDllState & INTERNET_STATE_OFFLINE_USER)
                ? ((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE)
                : TRUE);

    BOOL offline = (GlobalDllState & (INTERNET_STATE_OFFLINE | INTERNET_STATE_OFFLINE_USER))
                    ? TRUE
                    : FALSE;

    DEBUG_LEAVE(offline);

    return offline;
}


DWORD
SetOfflineUserState(
    IN DWORD dwState,
    IN BOOL bForce
    )

/*++

Routine Description:

    If we are in online state, puts Wininet into user-induced offline mode. Stop
    all outstanding requests, if required and set the global scope. If we are in
    offline mode, then change state to online

Arguments:

    dwState - INTERNET_STATE_ONLINE or INTERNET_STATE_OFFLINE

    bForce  - TRUE if we are to forcibly complete all outstanding requests
              (including synchronous requests)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "SetOfflineUserState",
                 "%s (%d), %B",
                 (dwState == INTERNET_STATE_ONLINE) ? "INTERNET_STATE_ONLINE"
                 : (dwState == INTERNET_STATE_OFFLINE) ? "INTERNET_STATE_OFFLINE"
                 : "???",
                 dwState,
                 bForce
                 ));

    INET_ASSERT((dwState == INTERNET_STATE_ONLINE)
                || (dwState == INTERNET_STATE_OFFLINE));
    INET_ASSERT(((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_ONLINE)
                || ((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE));

    DWORD error = ERROR_SUCCESS;

    if (dwState == INTERNET_STATE_OFFLINE) {
        GlobalDllState = (GlobalDllState & ~INTERNET_LINE_STATE_MASK)
                       | (INTERNET_STATE_OFFLINE | INTERNET_STATE_OFFLINE_USER);
        if (bForce) {
            //CancelActiveAsyncRequests(ERROR_INTERNET_OFFLINE);
            CancelActiveSyncRequests(ERROR_INTERNET_OFFLINE);
            GlobalProxyInfo.AbortAutoProxy();
        }
    } else {
        GlobalDllState = GlobalDllState
                       & ~(INTERNET_LINE_STATE_MASK | INTERNET_STATE_OFFLINE_USER)
                       | INTERNET_STATE_ONLINE;
    }

    DEBUG_PRINT(GLOBAL,
                INFO,
                ("GlobalDllState = %#x\n",
                GlobalDllState
                ));

    DEBUG_LEAVE(error);

    return error;
}


/*++

FetchLocalStrings:

    This routine fetches the strings necessary to display information in the
    language of the local user.

Arguments:

    None

Return Value:

    The address of a LOCAL_STRINGS structure containing the addresses of the
    localized strings to display.

Author:

    Doug Barlow (dbarlow) 4/25/1996

--*/
//
// WARNING!  The order of elements in the following array must match the
// order of elements in the LOCAL_STRINGS structure.
//

static const UINT
    uStringId[]
        = { IDS_LW95_ENTERAUTHINFO,
            IDS_SECERT_CERTINFO,
            IDS_SECERT_STRENGTH_HIGH,
            IDS_SECERT_STRENGTH_MEDIUM,
            IDS_SECERT_STRENGTH_LOW,
            IDS_CERT_SUBJECT,
            IDS_CERT_ISSUER,
            IDS_CERT_EFFECTIVE_DATE,
            IDS_CERT_EXPIRATION_DATE,
            IDS_CERT_PROTOCOL,
            IDS_CERT_USAGE,
            IDS_CERT_ENCRYPT_ALG,
            IDS_CERT_HASH_ALG,
            IDS_CERT_EXCH_ALG,
            IDS_CERT_COMMENT,
            IDS_COMMENT_EXPIRES,
            IDS_COMMENT_NOT_VALID,
            IDS_COMMENT_BAD_CN,
            IDS_COMMENT_BAD_CA,
            IDS_COMMENT_BAD_SIGNATURE,
            IDS_COMMENT_REVOKED,
            IDS_STRING_CIPHMSG,
            IDS_STRING_HASHMSG,
            IDS_STRING_EXCHMSG,
            IDS_CERT_FINGERPRINT,
            IDS_DOMAIN,
            IDS_REALM,
            IDS_SITE,
            IDS_FIREWALL
};

PLOCAL_STRINGS
FetchLocalStrings(
    void)
{

    static LOCAL_STRINGS
        lszStrings;
    static BOOL fInitialized = FALSE;

    INET_ASSERT(sizeof(uStringId) == offsetof(LOCAL_STRINGS, rgchBuffer));
    EnterCriticalSection(&GeneralInitCritSec);
    __try
    {
        if (!fInitialized)
        {
            LPWSTR szBufEntry;
            LPWSTR *pszName;
            DWORD dwOffset;
            DWORD index, len;


            //
            // It needs to be initialized.
            //

            pszName = (LPWSTR *)&lszStrings;
            dwOffset = 0;
            for (index = 0;
                 index < sizeof(uStringId) / sizeof(UINT);
                 index += 1)
            {
                szBufEntry = &lszStrings.rgchBuffer[dwOffset];
                len = LoadStringWrapW(
                            GlobalDllHandle,
                            uStringId[index],
                            szBufEntry,
                            LOCAL_STRINGS_MAX_BUFFER - dwOffset);
                INET_ASSERT(0 != len);  // Resource missing!
                dwOffset += len;
                lszStrings.rgchBuffer[dwOffset++] = 0;
                *pszName++ = szBufEntry;
            }

            INET_ASSERT(LOCAL_STRINGS_MAX_BUFFER > dwOffset);


            //
            // Make it available to this and future callers.
            //

            fInitialized = TRUE;
        }
    }
    __finally
    {
        LeaveCriticalSection(&GeneralInitCritSec);
    }
    ENDFINALLY
    return &lszStrings;
}

PLOCAL_STRINGSA
FetchLocalStringsA(
    void)
{
    static LOCAL_STRINGSA
        lszStrings;
    static BOOL fInitialized = FALSE;

    INET_ASSERT(sizeof(uStringId) == offsetof(LOCAL_STRINGSA, rgchBuffer));
    EnterCriticalSection(&GeneralInitCritSec);
    __try
    {
        if (!fInitialized)
        {
            LPSTR szBufEntry;
            LPSTR *pszName;
            DWORD dwOffset;
            DWORD index, len;


            //
            // It needs to be initialized.
            //

            pszName = (LPSTR *)&lszStrings;
            dwOffset = 0;
            for (index = 0;
                 index < sizeof(uStringId) / sizeof(UINT);
                 index += 1)
            {
                szBufEntry = &lszStrings.rgchBuffer[dwOffset];
                len = LoadStringA(
                            GlobalDllHandle,
                            uStringId[index],
                            szBufEntry,
                            LOCAL_STRINGS_MAX_BUFFER - dwOffset);
                INET_ASSERT(0 != len);  // Resource missing!
                dwOffset += len;
                lszStrings.rgchBuffer[dwOffset++] = 0;
                *pszName++ = szBufEntry;
            }

            INET_ASSERT(LOCAL_STRINGS_MAX_BUFFER > dwOffset);

            //
            // Make it available to this and future callers.
            //

            fInitialized = TRUE;
        }
    }
    __finally
    {
        LeaveCriticalSection(&GeneralInitCritSec);
    }
    ENDFINALLY
    return &lszStrings;
}

BOOL
GetWininetUserName(
    VOID
)
{
    BOOL fRet = FALSE;
    DWORD dwT;
    CHAR *ptr;

    // Note this critsect could be blocked for a while if RPC gets involved...
    EnterCriticalSection(&GeneralInitCritSec);

    if (vdwCurrentUserLen) {
        fRet = TRUE;
        goto Done;
    }

    dwT = sizeof(vszCurrentUser);

    if (vfPerUserCookies) {

        fRet = GetUserName(vszCurrentUser, &dwT);

        if (!fRet) {

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("GetUsername returns %d\n",
                        GetLastError()
                        ));
        }

    }

    if (fRet == FALSE){

        strcpy(vszCurrentUser, vszAnyUserName);

        fRet = TRUE;
    }

    // Downcase the username.
    ptr = vszCurrentUser;
    while (*ptr)
    {
        /* BUGBUG: This logic mangles the user name when 
                   there are multi-byte characters.
           Unfortunately fixing it would lose legacy cookies so the 
           fix had to be backed out.
           The correct code is commented out below. */

        *ptr = tolower(*ptr);
        ptr++;

        // if (!IsDBCSLeadByte(*ptr))
        //    *ptr = tolower(*ptr);
        // ptr = CharNextExA(CP_ACP, ptr, 0);
    }

    INET_ASSERT(fRet == TRUE);

    vdwCurrentUserLen = (DWORD) (ptr - vszCurrentUser);


Done:
    LeaveCriticalSection(&GeneralInitCritSec);
    return (fRet);
}


VOID
ChangeGlobalSettings(
    VOID
    )

/*++

Routine Description:

    Changes global settings

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "ChangeGlobalSettings",
                 NULL
                 ));

    InternetReadRegistryDword(vszSyncMode,
                              &GlobalUrlCacheSyncMode
                              );

    InternetReadRegistryDword(vszDisableSslCaching,
                              (LPDWORD)&GlobalDisableSslCaching
                              );

    InternetReadRegistryDword("EnableHttp1_1",
                              (LPDWORD)&GlobalEnableHttp1_1
                              );

    InternetReadRegistryDword("ProxyHttp1.1",
                              (LPDWORD)&GlobalEnableProxyHttp1_1
                              );

    InternetReadRegistryDword(vszPerUserCookies,
                              (LPDWORD)&vfPerUserCookies
                              );

    InternetReadRegistryDword(vszLeashLegacyCookies, (LPDWORD)&GlobalLeashLegacyCookies);

    if (!GlobalProxyInfo.IsModifiedInProcess())
    {
        FixProxySettingsForCurrentConnection(
            FALSE
            );
    }

    //
    // update security protocol changes.
    //

    InternetReadRegistryDword("SecureProtocols",
                          (LPDWORD)&GlobalSecureProtocols
                          );

    if (!GlobalPlatformWhistler)
    {
        // Fortezza support has been removed from XP
        InternetReadRegistryDword("Fortezza",
                                  (LPDWORD)&GlobalEnableFortezza
                                  );
    }
    else
    {
        GlobalEnableFortezza = FALSE;
    }

    InternetReadRegistryDword("CertificateRevocation",
                              (LPDWORD)&GlobalEnableRevocation
                              );

    //
    // Check autodial settings and hang up if autodial was turned off
    //

    // have autodial module reset itself
    ResetAutodialModule();

    RefreshOfflineFromRegistry();

    // force reload of cookie-settings from registry by flushing memory cache
    RefreshP3PSettings();

    DEBUG_LEAVE(0);
}


VOID
RefreshOfflineFromRegistry(
    VOID
    )

/*++

Routine Description:

    Reads offline setting in the registry and sets wininet's offline mode
    accordingly.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "RefreshOfflineFromRegistry",
                 NULL
                 ));

    DWORD dwTemp = 0;

    // note: this won't alter dwTemp if not found and so will default to
    // online
    InternetReadRegistryDword("GlobalUserOffline", &dwTemp);

    // convert to appropriate flags
    if(0 == dwTemp) {
        // online
        dwTemp = INTERNET_STATE_ONLINE;
    } else {
        // offline
        dwTemp = INTERNET_STATE_OFFLINE;
    }
    SetOfflineUserState(dwTemp, FALSE);

    DEBUG_LEAVE(0);
}


VOID
PerformStartupProcessing(
    VOID
    )

/*++

Routine Description:

    Performs actions exactly once on system startup.  Resets offline mode.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "PerformStartupProcessing",
                 NULL
                 ));

    INET_ASSERT(NULL == g_hAutodialMutex);

    g_hAutodialMutex = OpenMutex(SYNCHRONIZE, FALSE, WININET_STARTUP_MUTEX);
    if (g_hAutodialMutex == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        if (psa)
        {
            g_hAutodialMutex = CreateMutex(psa, FALSE, WININET_STARTUP_MUTEX);
        }
    }

    if(g_hAutodialMutex) {
        DWORD dwLastError = GetLastError();

        if(ERROR_SUCCESS == dwLastError) {
            // GetLastError returns ERROR_ALREADY_EXISTS if the mutex existed
            // before we created it.  If we don't get this error, we're the
            // first so proceed with out startup processing

            if(!GlobalPlatformVersion5)
            {
                // Reset global offline mode on non-Win2K platforms
                InternetWriteRegistryDword("GlobalUserOffline", 0);
            }
        }
    }

    DEBUG_LEAVE(0);
}

#if defined(SITARA)

PRIVATE HKEY IeMainKey = NULL;


PRIVATE
VOID
OpenIeMainKey(
    VOID
    )
{
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     "Software\\Microsoft\\Internet Explorer\\Main",
                     0,
                     KEY_QUERY_VALUE,
                     &IeMainKey
                     ) != ERROR_SUCCESS) {
        IeMainKey = NULL;
    }
}


PRIVATE
VOID
CloseIeMainKey(
    VOID
    )
{
    if (IeMainKey != NULL) {
        REGCLOSEKEY(IeMainKey);
        IeMainKey = NULL;
    }
}


DWORD
GetSitaraProtocol(
    VOID
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "GetSitaraProtocol",
                 NULL
                 ));

    DWORD dwProtocol = IPPROTO_TCP;
    DWORD dwEnabled = 0;

    if (ReadIeMainDwordValue("Use_Express_Lane", &dwEnabled) && (dwEnabled != 0)) {
        dwProtocol = 901;
    }

    DEBUG_LEAVE(dwProtocol);

    return dwProtocol;
}


PRIVATE
BOOL
CheckABS(
    VOID
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CheckABS",
                 NULL
                 ));

    BOOL on = 0;

    ReadIeMainDwordValue("ABS", (LPDWORD)&on);

    DEBUG_LEAVE(!on);

    return !on;
}


PRIVATE
BOOL
ReadIeMainDwordValue(
    IN LPSTR pszValueName,
    OUT LPDWORD pdwValue
    )
{
    if (IeMainKey != NULL) {

        DWORD value;
        DWORD valueType;
        DWORD valueLength = sizeof(value);
        DWORD err = RegQueryValueEx(IeMainKey,
                                    pszValueName,
                                    NULL,
                                    &valueType,
                                    (LPBYTE)&value,
                                    &valueLength
                                    );

        if ((err == ERROR_SUCCESS)
            && ((valueType == REG_DWORD) || (valueType == REG_BINARY))
            && (valueLength == sizeof(DWORD))) {
            *pdwValue = value;
            return TRUE;
        }
    }
    return FALSE;
}

#endif // SITARA


// Loads Mlang.dll and get the entry point we are interested in.

BOOL LoadMlang( )
{
    EnterCriticalSection(&MlangCritSec);

    if (hInstMlang == NULL && !bFailedMlangLoad)
    {
        INET_ASSERT(pfnInetMultiByteToUnicode == NULL);
        hInstMlang = LoadLibrary(MLANGDLLNAME);

        if (hInstMlang != NULL)
        {
            pfnInetMultiByteToUnicode = (PFNINETMULTIBYTETOUNICODE)GetProcAddress
                                            (hInstMlang,"ConvertINetMultiByteToUnicode");
            if (pfnInetMultiByteToUnicode == NULL)
            {
                INET_ASSERT(FALSE);
                FreeLibrary(hInstMlang);
                hInstMlang = NULL;
            }
        }
        else
        {
            INET_ASSERT(FALSE); // bad news if we can't load mlang.dll
        }

        if (pfnInetMultiByteToUnicode == NULL)
            bFailedMlangLoad = TRUE;
    }

    LeaveCriticalSection(&MlangCritSec);

    return (pfnInetMultiByteToUnicode != NULL);
}

BOOL UnloadMlang( )
{
    EnterCriticalSection(&MlangCritSec);

    if (hInstMlang)
        FreeLibrary(hInstMlang);

    hInstMlang = NULL;
    pfnInetMultiByteToUnicode = NULL;
    bFailedMlangLoad = FALSE;

    LeaveCriticalSection(&MlangCritSec);

    return TRUE;
}

PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( )
{
    // We are checking for pfnInetMultiByteToUnicode without getting a crit section.
    // This works only because UnloadMlang is called at the Dll unload time.

    if (pfnInetMultiByteToUnicode == NULL)
    {
        LoadMlang( );
    }

    return pfnInetMultiByteToUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\iedial.cxx ===
#include "wininetp.h"
#include "autodial.h"
#include "rashelp.h"

#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>

void PostString(HWND hDlg, LPWSTR pszString);
void GetDialErrorString(DWORD dwError, LPWSTR pszBuffer, DWORD dwLength);
void SetDialError(HWND hDlg, DWORD dwError);

UINT_PTR
SendDialmonMessage(
    UINT    uMessage,
    BOOL    fPost
    );

// function prototype in inetcpl to launch connections tab
typedef BOOL (WINAPI *LAUNCHCPL)(HWND);

//
// Globals
//
BOOL    g_fRegisterWndProc = FALSE;

#define REGSTR_DIAL_AUTOCONNECTW            L"AutoConnect"

typedef struct _tagRASCONNSTATEMAP {
    RASCONNSTATE    rascs;
    UINT            uResourceID;
} RASCONNSTATEMAP;

RASCONNSTATEMAP rgRasStates[] = {
    { RASCS_OpenPort,                 IDS_DIALING       },
    { RASCS_AllDevicesConnected,      IDS_CONNECTED     },
    { RASCS_Authenticate,             IDS_AUTHENTICATE  },
    { RASCS_Disconnected,             IDS_DISCONNECTED  },
    { (RASCONNSTATE)0, 0 }
};

PROPMAP g_PropertyMap[] = {
    {DIALPROP_USERNAME,         PropUserName       },
    {DIALPROP_PASSWORD,         PropPassword       },
    {DIALPROP_DOMAIN,           PropDomain         },
    {DIALPROP_SAVEPASSWORD,     PropSavePassword   },
    {DIALPROP_PHONENUMBER,      PropPhoneNumber    },
    {DIALPROP_REDIALCOUNT,      PropRedialCount    },
    {DIALPROP_REDIALINTERVAL,   PropRedialInterval },
    {DIALPROP_LASTERROR,        PropLastError      },
    {DIALPROP_RESOLVEDPHONE,    PropResolvedPhone  }
};
#define NUM_DIALPROPS (sizeof(g_PropertyMap) / sizeof(PROPMAP))

//////////////////////////////////////////////////////////////////////////////
//
// CDialEngine implementation
//
//////////////////////////////////////////////////////////////////////////////


CDialEngine::CDialEngine()
{
    m_cRef = 0;
    m_pdes = NULL;
    m_rcs = RASCS_Disconnected;
    m_fCurrentlyDialing = FALSE;
    memset(&m_rdp, 0, sizeof(m_rdp));
    memset(&m_rcred, 0, sizeof(m_rcred));
    m_fPassword = FALSE;
    m_fSavePassword = FALSE;
    m_dwError = 0;

    // must be initialized to zero -- RasDial will fail (!) if this is anything
    // other than 0 when passed in to receive conn handle!!
    m_hConn = NULL;

    m_rdp.dwSize = sizeof(m_rdp);

    EnsureRasLoaded();

    if(FALSE == g_fRegisterWndProc)
    {
        // register window class for dialing engine
        WNDCLASS wc;
        memset(&wc, 0, sizeof(wc));
        wc.lpfnWndProc = CDialEngine::EngineWndProc;
        wc.hInstance = GlobalDllHandle;
        wc.lpszClassName = "DialEngine";
        RegisterClass(&wc);

        g_fRegisterWndProc = TRUE;
    }
}

CDialEngine::~CDialEngine()
{
    SAFE_RELEASE(m_pdes);

    if(m_hwnd)
    {
        DestroyWindow(m_hwnd);
    }
}

//
// IUnknown members
//
STDMETHODIMP_(ULONG) CDialEngine::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDialEngine::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CDialEngine::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv = NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_IDialEngine == riid))
    {
        *ppv = (IDialEngine *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}


//
// IDialEngine members
//
STDMETHODIMP
CDialEngine::Initialize(
    LPCWSTR pwzConnectoid,
    IDialEventSink *pIDES
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::Initialize",
                 "%#x (%Q), %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 pIDES
                 ));

    // save off stuff
    m_pdes = pIDES;
    m_pdes->AddRef();
    StrCpyW(m_rdp.szEntryName, pwzConnectoid);
    m_rdp.dwSize = sizeof(m_rdp);

    // get stats from RAS
    RasEntryDialParamsHelp re;
    if(re.GetW(NULL, &m_rdp, &m_fPassword))
    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if(IsOS(OS_WHISTLERORGREATER))
    {
        // on whistler, use RasGetCredentials instead to preserve settings
        m_rcred.dwSize = sizeof(m_rcred);
        m_rcred.dwMask = RASCM_UserName | RASCM_Password;
        if(_RasGetCredentialsW(NULL, pwzConnectoid, &m_rcred))
        {
            DEBUG_LEAVE(E_INVALIDARG);
            return E_INVALIDARG;
        }
        DEBUG_PRINT(DIALUP, INFO, ("Name=<%ws>, PW=<%ws>, dwMask=%x\n", m_rcred.szUserName, m_rcred.szPassword, m_rcred.dwMask));

        m_fPassword = (m_rcred.dwMask & RASCM_Password) ? TRUE : FALSE;
    }

    // read redial properties
    GetRedialParameters((LPWSTR)pwzConnectoid, &m_dwTryTotal, &m_dwWaitTotal);
    m_dwTryCurrent = 0;
    m_dwWaitCurrent = 0;

    // register the ras message
    m_uRasMsg = RegisterWindowMessageA(RASDIALEVENT);
    if(0 == m_uRasMsg)
        m_uRasMsg = WM_RASDIALEVENT;

    // create the window to get ras callbacks.
    m_hwnd = CreateWindowA(
                "DialEngine",
                "DialEngine",
                WS_OVERLAPPED,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                GlobalDllHandle,
                NULL
                );

    if(NULL == m_hwnd)
    {
        DEBUG_LEAVE(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    // tell window our this pointer
    SendMessage(m_hwnd, WM_USER, 0, (LPARAM)this);

    // get current connected state from RAS
    UpdateRasState();

    DEBUG_LEAVE(S_OK);
    return S_OK;
}


STDMETHODIMP
CDialEngine::GetProperty(
    LPCWSTR pwzProperty,
    LPWSTR  pwzValue,
    DWORD   dwBufSize
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::GetProperty",
                 "%#x (%Q), %#x, %#x",
                 pwzProperty,
                 pwzProperty,
                 pwzValue,
                 dwBufSize
                 ));

    HRESULT hr = E_INVALIDARG;
    WCHAR * pwzSrc = NULL;
    RasEntryPropHelp *pre = new RasEntryPropHelp;

    switch(PropertyToOrdinal(pwzProperty))
    {
    case PropUserName:
        pwzSrc = m_rdp.szUserName;
        break;
    case PropPassword:
        if(m_fPassword)
        {
            pwzSrc = m_rdp.szPassword;
        }
        else
        {
            hr = S_FALSE;
        }
        break;
    case PropDomain:
        pwzSrc = m_rdp.szDomain;
        break;
    case PropSavePassword:
        if(m_fSavePassword)
        {
            pwzSrc = L"TRUE";
        }
        else
        {
            pwzSrc = L"FALSE";
        }
        break;
    case PropResolvedPhone:
        if(ResolvePhoneNumber(pwzValue, dwBufSize))
        {
            hr = S_OK;
            break;
        }

        //
        // failed to get nicely formatted phone number, fall through to basic one
        //

    case PropPhoneNumber:
        if (pre == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pre->GetW(m_rdp.szEntryName);
            pwzSrc = pre->GetPhoneNumberW();
        }
        break;
    case PropRedialCount:
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %d\n", m_dwTryTotal));
        wnsprintfW(pwzValue, dwBufSize, L"%d", m_dwTryTotal);
        hr = S_OK;
        break;
    case PropRedialInterval:
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %d\n", m_dwWaitTotal));
        wnsprintfW(pwzValue, dwBufSize, L"%d", m_dwWaitTotal);
        hr = S_OK;
        break;
    case PropLastError:
        GetDialErrorString(m_dwError, pwzValue, dwBufSize);
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %ws\n", pwzValue));
        hr = S_OK;
        break;
    }

    if(pwzSrc)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %ws\n", pwzSrc));
        StrCpyNW(pwzValue, pwzSrc, dwBufSize);
        hr = S_OK;
    }

    if (pre)
        delete pre;

    DEBUG_LEAVE(hr);
    return hr;
}


STDMETHODIMP
CDialEngine::SetProperty(
    LPCWSTR pwzProperty,
    LPCWSTR  pwzValue
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::SetProperty",
                 "%#x (%Q), %#x (%Q)",
                 pwzProperty,
                 pwzProperty,
                 pwzValue,
                 pwzValue
                 ));

    HRESULT hr = E_INVALIDARG;
    WCHAR * pwzDest = NULL;
    DWORD   dwMaxLength = 0;
    WCHAR   wcNull = 0;

    // treat NULL values as emtpy values
    if(NULL == pwzValue)
    {
        pwzValue = &wcNull;
    }

    switch(PropertyToOrdinal(pwzProperty))
    {
    case PropUserName:
        pwzDest = m_rdp.szUserName;
        dwMaxLength = UNLEN;
        if(IsOS(OS_WHISTLERORGREATER))
        {
            StrCpyNW(m_rcred.szUserName, pwzValue, dwMaxLength);
        }
        break;
    case PropPassword:
        pwzDest = m_rdp.szPassword;
        dwMaxLength = PWLEN;
        m_fPassword = TRUE;
        if(IsOS(OS_WHISTLERORGREATER))
        {
            StrCpyNW(m_rcred.szPassword, pwzValue, dwMaxLength);
        }
        break;
    case PropDomain:
        pwzDest = m_rdp.szDomain;
        dwMaxLength = DNLEN;
        break;
    case PropSavePassword:
        if(!StrCmpIW(pwzValue, L"TRUE"))
        {
            m_fSavePassword = TRUE;
        }
        else
        {
            m_fSavePassword = FALSE;
        }
        if(FALSE == m_fSavePassword)
        {
            m_fPassword = FALSE;
        }
        hr = S_OK;
        break;
    case PropPhoneNumber:
        pwzDest = m_rdp.szPhoneNumber;
        dwMaxLength = RAS_MaxPhoneNumber;
        break;
    case PropRedialCount:
        m_dwTryTotal = StrToIntW(pwzValue);
        if(0 == m_dwTryTotal)
        {
            m_dwTryTotal = DEFAULT_DIAL_ATTEMPTS;
        }
        hr = S_OK;
        break;
    case PropRedialInterval:
        m_dwWaitTotal = StrToIntW(pwzValue);
        if(0 == m_dwWaitTotal)
        {
            m_dwWaitTotal = DEFAULT_DIAL_INTERVAL;
        }
        hr = S_OK;
        break;
    default:
        hr = E_UNEXPECTED;
        break;
    }

    if(pwzDest)
    {
        StrCpyNW(pwzDest, pwzValue, dwMaxLength);
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}


STDMETHODIMP
CDialEngine::StartConnection()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::StartConnection",
                 NULL
                 ));

    m_dwTryCurrent++;
    m_pdes->OnEvent(DIALENG_RedialAttempt, m_dwTryCurrent);

    RasDialHelp RasDial(NULL, NULL, &m_rdp, 0xFFFFFFFF, m_hwnd, &m_hConn);

    if(0 != RasDial.GetError()) {

        // Clean up since RAS may return a connection anyway...
        CleanConnection();
        m_dwError = ERROR_NO_CONNECTION;
        EndOfOperation();

        DEBUG_PRINT(DIALUP, INFO, ("Bailing - RasDial error\n"));
        DEBUG_LEAVE(E_FAIL);
        return E_FAIL;
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP
CDialEngine::Dial()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::Dial",
                 NULL
                 ));

    HRESULT hr;

    if(m_fCurrentlyDialing)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Bailing - m_fCurentlyDialing\n"));
        DEBUG_LEAVE(S_FALSE);
        return S_FALSE;
    }

    // find out if our connection state has changed in the mean time
    UpdateRasState();

    // we have begun...
    m_fCurrentlyDialing = TRUE;

    if(m_rcs == RASCS_Connected)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Bailing - already connected\n"));
        m_dwError = ERROR_SUCCESS;
        EndOfOperation();

        DEBUG_LEAVE(S_FALSE);
        return S_FALSE;
    }

    m_dwError = 0;
    m_dwTryCurrent = 0;

    hr = StartConnection();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CDialEngine::CleanConnection()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::CleanConnection",
                 NULL
                 ));

    HRESULT hr = S_FALSE;

    // make sure we see if we've connected in the mean time
    UpdateRasState();

    DEBUG_PRINT(DIALUP, INFO, ("m_hConn=%x\n", m_hConn));

    // hang up connection if we got one
    if(m_hConn)
    {
        HRASCONN hConn = m_hConn;
        m_hConn = NULL;
        _RasHangUp(hConn);
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CDialEngine::HangUp()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::HangUp",
                 NULL
                 ));

    HRESULT hr;

    // hang up or abort any pending dials
    hr = CleanConnection();

    // make sure no pending timers
    if(m_uTimerId)
    {
        KillTimer(m_hwnd, m_uTimerId);
        m_uTimerId = 0;
    }

    // calling hangup causes ras events to end
    if(0 == m_dwError)
    {
        m_dwError = ERROR_USER_DISCONNECTION;
    }
    EndOfOperation();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CDialEngine::GetConnectedState(
    DWORD  *pdwState)
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::GetConnectedState",
                 NULL
                 ));

    *pdwState = MapRCS(m_rcs);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}


STDMETHODIMP
CDialEngine::GetConnectHandle(
    DWORD_PTR *pdwHandle
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::GetConnectHandle",
                 NULL
                 ));

    if(RASCS_Connected == m_rcs)
    {
        *pdwHandle = (DWORD_PTR)m_hConn;
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    else
    {
        *pdwHandle = 0;
        DEBUG_LEAVE(S_FALSE);
        return S_FALSE;
    }
}

//
// private members
//
LONG_PTR CALLBACK
CDialEngine::EngineWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::EngineWndProc",
                 "%#x, %#x, %#x, %#x",
                 hwnd,
                 uMsg,
                 wParam,
                 lParam
                 ));

    CDialEngine * peng = (CDialEngine *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if(uMsg == WM_USER)
    {
        peng = (CDialEngine *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (DWORD_PTR)peng);
    }
    else if(peng && uMsg == peng->m_uRasMsg)
    {
        peng->OnRasEvent((RASCONNSTATE)wParam, (DWORD)lParam);
    }
    else if(peng && uMsg == WM_TIMER)
    {
        peng->OnTimer();
    }

    DEBUG_LEAVE(0);
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID
CDialEngine::OnTimer()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::OnTimer",
                 NULL
                 ));

    if(0 == m_dwError)
    {
        m_dwWaitCurrent--;
        if(0 == m_dwWaitCurrent)
        {
            // kick off dial
            KillTimer(m_hwnd, m_uTimerId);
            m_uTimerId = 0;
            StartConnection();
        }
        else
        {
            // update sink
            // m_pdes->OnEvent(DIALENG_RedialWait, m_dwWaitCurrent);
        }
    }

    DEBUG_LEAVE(0);
}

VOID
CDialEngine::OnRasEvent(
    RASCONNSTATE rcs,
    DWORD dwError
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::OnRasEvent",
                 "%#x, %#x",
                 (DWORD)rcs,
                 dwError
                 ));

    // save rasconnstate
    m_rcs = rcs;

    // forward event to UI object
    m_pdes->OnEvent(MapRCS(rcs), dwError);

    // handle the dial state
    if(dwError != SUCCESS) {

        // win95 returns this error if authentication failed.
        if(ERROR_UNKNOWN == dwError)
            dwError = ERROR_AUTHENTICATION_FAILURE;

        // save error if we don't already have one
        if(0 == m_dwError && dwError)
        {
            m_dwError = dwError;
        }

        // clean up connection
        CleanConnection();

        switch(dwError) {
        case ERROR_AUTHENTICATION_FAILURE:
            memset(m_rdp.szPassword, 0, ARRAYSIZE(m_rdp.szPassword));
            EndOfOperation();
            break;
        case ERROR_USER_DISCONNECTION:
            // we hit cancel and called RasHangUp.  Nothing to do here -
            // cancel code has cleaned up as necessary.
            EndOfOperation();
            break;
        case ERROR_LINE_BUSY:
        case ERROR_NO_ANSWER:
        case ERROR_NO_CARRIER:
            if(m_dwTryCurrent < m_dwTryTotal)
            {
                m_dwError = 0;
                m_dwWaitCurrent = m_dwWaitTotal;
                m_uTimerId = SetTimer(m_hwnd, 1, 1000, NULL);
                m_pdes->OnEvent(DIALENG_RedialWait, m_dwWaitCurrent);
                break;
            }

            // fall through
        default:
            EndOfOperation();
        }
    } else {
        // we're getting status
        if(rcs == RASCS_Connected)
        {
            // we're done
            m_dwError = ERROR_SUCCESS;
            EndOfOperation();

            DEBUG_PRINT(DIALUP, INFO, ("Connected: m_fPassword=%B, m_fSavePassword=%B\n", m_fPassword, m_fSavePassword));
            if(IsOS(OS_WHISTLERORGREATER))
            {
                // delete/write/leave alone semantics
                //
                // m_fPassword     m_fSavePassword      result
                //      T               T               Write password
                //      F               F               Delete password
                //      T               F               Leave password alone
                //      F               T               Never happens

                if(!m_fPassword && !m_fSavePassword)
                {
                    // delete case, only want password mask
                    m_rcred.dwMask = 0;
                }

                if(m_fPassword == m_fSavePassword)
                {
                    // write or delete case

                    // always need password flag
                    m_rcred.dwMask |= RASCM_Password;

                    // write or delete, depend on m_fSavePassword
                    DEBUG_PRINT(DIALUP, INFO, ("Name=<%ws>, PW=<%ws>, dwMask=%x\n", m_rcred.szUserName, m_rcred.szPassword, m_rcred.dwMask));
                    _RasSetCredentialsW(NULL, m_rdp.szEntryName, &m_rcred, !m_fSavePassword);
                }
            }
            else
            {
                if(m_fPassword == m_fSavePassword)
                {
                    // save or delete password
                    RasEntryDialParamsHelp re;
                    re.SetW(NULL, &m_rdp, !m_fSavePassword);
                }
            }

            // inform dialmon that we've dialed
            SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);
        }
    }

    DEBUG_LEAVE(0);
}

DWORD
CDialEngine::MapRCS(RASCONNSTATE rcs)
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::MapRCS",
                 "%#x",
                 (DWORD)rcs
                 ));


    DEBUG_LEAVE((DWORD)rcs);
    return (DWORD)rcs;
}


DIALPROP
CDialEngine::PropertyToOrdinal(LPCWSTR pwzProperty)
{
    long i;

    for(i=0; i<NUM_DIALPROPS; i++)
    {
        if(!StrCmpIW(g_PropertyMap[i].pwzProperty, pwzProperty))
        {
            return g_PropertyMap[i].Prop;
        }
    }

    return PropInvalid;
}

VOID
CDialEngine::UpdateRasState()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::UpdateRasState",
                 NULL
                 ));

    DEBUG_PRINT(DIALUP, INFO, ("m_fCurrentlyDialing = %B\n", m_fCurrentlyDialing));

    //
    // only do this if not dialing.  If we are, OnRasEvent will update
    // state appropriately.
    //
    if(FALSE == m_fCurrentlyDialing)
    {
        RasEnumConnHelp re;

        re.Enum();

        DEBUG_PRINT(DIALUP, INFO, ("Checking for connections\n"));

        // set state to disconnected and try to find a connection
        m_rcs = RASCS_Disconnected;

        if(0 == re.GetError())
        {
            DWORD dwCount;

            for(dwCount = 0; dwCount < re.GetConnectionsCount(); dwCount++)
            {
                if(0 == StrCmpW(re.GetEntryW(dwCount), m_rdp.szEntryName))
                {
                    DEBUG_PRINT(DIALUP, INFO, ("Found connection\n"));
                    m_hConn = re.GetHandle(dwCount);
                    m_rcs = RASCS_Connected;
                }
            }
        }
    }

    DEBUG_LEAVE(0);
}

VOID
CDialEngine::EndOfOperation()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::EndOfOperation",
                 NULL
                 ));

    if(m_fCurrentlyDialing)
    {
        // called when a dialing operation is done
        m_fCurrentlyDialing = FALSE;
        m_dwTryCurrent = 0;

        // notify sink that no more events are forthcoming
        m_pdes->OnEvent(DIALENG_OperationComplete, m_dwError);
    }

    DEBUG_LEAVE(0);
}

VOID FAR CALLBACK TapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    DWORD_PTR   dwCallbackInstance,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    )
{
}

BOOL
CDialEngine::ResolvePhoneNumber(LPWSTR pwzBuffer, DWORD dwLen)
{
    char   *pszTemp = NULL;
    WCHAR   szCanonical[128];
    CHAR    szAnsiCanonical[128];
    CHAR   *pszResolved;
    long    lErr, i;
    BOOL    fResult = FALSE;
    RasEntryPropHelp *pre = new RasEntryPropHelp;

    if (pre == NULL)
    {
        goto Cleanup;
    }

    pszTemp = (char *) ALLOCATE_FIXED_MEMORY(4096);
    if (pszTemp == NULL)
    {
        goto Cleanup;
    }

    // look up RAS entry
    pre->GetW(m_rdp.szEntryName);
    if(pre->GetError())
    {
        goto Cleanup;
    }

    if(pre->GetOptions() & RASEO_UseCountryAndAreaCodes)
    {
        PWSTR       pszAreaCode = pre->GetAreaCodeW();
        HLINEAPP    hApp;
        DWORD       dwNumDevs;

        // make TAPI canonical phone number
        wnsprintfW(szCanonical, 128, L"+%d (%ws) %ws", pre->GetCountryCode(), pszAreaCode ? pszAreaCode : L"", pre->GetPhoneNumberW());

        // ask TAPI to translate it
        LPLINETRANSLATEOUTPUT lpOut = (LPLINETRANSLATEOUTPUT)pszTemp;
        lpOut->dwTotalSize = 4096;
        lErr = lineInitialize(&hApp, GlobalDllHandle, TapiCallback, "Wininet", &dwNumDevs);
        if(lErr)
        {
            goto Cleanup;
        }
        WideCharToMultiByte(CP_ACP, 0, szCanonical, -1, szAnsiCanonical, 128, NULL, NULL);
        lErr = lineTranslateAddress(hApp, 0, TAPI_CURRENT_VERSION, szAnsiCanonical, 0, 0, lpOut);
        if(lErr)
        {
            goto Cleanup;
        }   
        pszResolved = (CHAR *)((char *)lpOut + lpOut->dwDisplayableStringOffset);
        i = MultiByteToWideChar(CP_ACP, 0, pszResolved, -1, pwzBuffer, dwLen);
        if(0 == i)
        {
            pwzBuffer[dwLen] = 0; // truncated - null terminate
        }
    }
    else
    {
        // TAPI resolution not turned on, just return straight phone number
        StrCpyNW(pwzBuffer, pre->GetPhoneNumberW(), dwLen);
    }

    fResult = TRUE;

Cleanup:
    if (pre)
        delete pre;

    if (pszTemp)
        FREE_MEMORY(pszTemp);

    return fResult;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDialUI implementation
//
//////////////////////////////////////////////////////////////////////////////

CDialUI::CDialUI(HWND hwndParent)
{
    m_cRef = 0;
    m_pEng = NULL;
    m_pdb = NULL;
    m_State = UISTATE_Interactive;
    m_fOfflineSemantics = FALSE;
    m_fSavePassword = FALSE;
    m_fPasswordChanged = FALSE;
    m_fAutoConnect = FALSE;
    m_fCDH = FALSE;
    m_fDialedCDH = FALSE;
    memset(&m_cdh, 0, sizeof(m_cdh));

    if(hwndParent)
    {
        m_hwndParent = hwndParent;
    }
    else
    {
        m_hwndParent = GetDesktopWindow();
    }
}

CDialUI::~CDialUI()
{
    SAFE_RELEASE(m_pEng);
    SAFE_RELEASE(m_pdb);
}

//
// IUnknown members
//
STDMETHODIMP_(ULONG) CDialUI::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDialUI::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CDialUI::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_IDialEventSink == riid))
    {
        *ppv = (IDialEventSink *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}


//
// IDialUI members
//
DWORD
CDialUI::StartDial(
    IN DIALSTATE *pDial,
    IN DWORD dwFlags
    )
//
//
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialUI::StartDial",
                 "%#x, %#x",
                 pDial,
                 dwFlags
                 ));

    DWORD dwSize, dwTemp, dwType;
    WCHAR szKey[MAX_PATH];

    // save passed info
    m_dwFlags = dwFlags;
    m_pDial = pDial;
    m_pDial->dwResult = 0;

    // check for connect automatically
    dwSize = sizeof(DWORD);
    dwTemp = 0;
    GetConnKeyW(pDial->params.szEntryName, szKey, ARRAYSIZE(szKey));
    if(0 == (dwFlags & INTERNET_DIAL_FORCE_PROMPT) &&
            ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey,
            REGSTR_DIAL_AUTOCONNECTW, &dwType, &dwTemp, &dwSize) && dwTemp)
    {
        m_fAutoConnect = TRUE;
    }

    //
    // Get some UI going
    //
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    if(-1 == DialogBoxParamWrapW(GlobalDllHandle, MAKEINTRESOURCEW(IDD_CONNECT_TO),
        m_hwndParent, CDialUI::DialogProc, (LPARAM)this))
    {
        // couldn't create dialog for some reason - no mem?
        m_pDial->dwResult = ERROR_OUTOFMEMORY;
    }
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    // prop odds and ends back to data so caller is happy
    if(!m_fCDH)
    {
        m_pDial->dwFlags = 0;
        if(m_fAutoConnect)
        {
            m_pDial->dwFlags |= CI_AUTO_CONNECT;
        }

        if(m_pEng)
        {
            m_pEng->GetConnectHandle((DWORD_PTR *)&m_pDial->hConn);
        }
    }
    else
    {
        m_pDial->hConn = (HRASCONN)CDH_HCONN;
    }

    //
    // Clean up
    //
    SAFE_RELEASE(m_pEng);

    DEBUG_LEAVE(m_pDial->dwResult);
    return m_pDial->dwResult;
}


STDMETHODIMP
CDialUI::OnEvent(
    DWORD dwEvent,
    DWORD dwStatus
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialUI::OnEvent",
                 "%#x, %#x",
                 dwEvent,
                 dwStatus
                 ));

    WCHAR   pszText[128], pszTemplate[128];
    INT     idRes;

    // find string for this state (if any)
    for (int nIndex = 0; rgRasStates[nIndex].uResourceID != 0; nIndex++)
    {
        if ((RASCONNSTATE)dwEvent == rgRasStates[nIndex].rascs) {
            LoadStringWrapW(GlobalDllHandle, rgRasStates[nIndex].uResourceID,
                pszText, 128);
            PostString(m_hwnd, pszText);
        }
    }

    switch(dwEvent)
    {
        case DIALENG_RedialAttempt:
        case DIALENG_RedialWait:
            idRes = IDS_REDIAL_ATTEMPT;
            if(dwEvent == DIALENG_RedialWait)
            {
                idRes = IDS_REDIAL_WAIT;
            }
            LoadStringWrapW(GlobalDllHandle, idRes, pszTemplate, 128);
            wnsprintfW(pszText, ARRAYSIZE(pszText), pszTemplate, dwStatus);
            PostString(m_hwnd, pszText);
            break;
        case DIALENG_OperationComplete:
            m_pDial->dwResult = dwStatus;
            if(0 == dwStatus || m_State == UISTATE_Unattended)
            {
                EndDialog(m_hwnd, 0);
            }
            else
            {
                if(dwStatus)
                {
                    // get an error - display it
                    SetDialError(m_hwnd, dwStatus);
                }
                m_State = UISTATE_Interactive;
                FixUIComponents();
            }
            break;
    }

    DEBUG_LEAVE(0);
    return NOERROR;
}

VOID
CDialUI::FixUIComponents(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::FixUIComponents",
                 NULL
                 ));
    WCHAR   pszTemp[64];
    int     i;
    BOOL    fActive = TRUE, fCanSave, fCDHActive = TRUE;
    TCHAR   szUser[UNLEN+1];
    DWORD   dwLen = UNLEN;
    UINT uIDs[] =      {IDC_CONN_TXT, IDC_CONN_LIST, ID_CONNECT, IDC_SETTINGS};
    UINT uCDHIDs[] =   {IDC_NAME_TXT, IDC_USER_NAME, IDC_PASSWORD_TXT, IDC_PASSWORD};

#define NUM_IDS      (sizeof(uIDs) / sizeof(UINT))
#define NUM_CDH_IDS  (sizeof(uCDHIDs) / sizeof(UINT))

    //
    // fix cancel button
    //
    if(UISTATE_Dialing == m_State || UISTATE_Unattended == m_State || FALSE == m_fOfflineSemantics)
    {
        i = IDS_CANCEL;
    }
    else
    {
        i = IDS_WORK_OFFLINE;
    }
    LoadStringWrapW(GlobalDllHandle, i, pszTemp, MAX_PATH);
    SetWindowTextWrapW(GetDlgItem(m_hwnd, IDCANCEL), pszTemp);

    //
    // Fix focus
    //
    if(UISTATE_Dialing == m_State || UISTATE_Unattended == m_State)
    {
        SetFocus(GetDlgItem(m_hwnd, IDCANCEL));
        fActive = FALSE;
    }

    //
    // Grey out appropriate stuff
    //
    for(i=0; i<NUM_IDS; i++)
    {
        EnableWindow(GetDlgItem(m_hwnd, uIDs[i]), fActive);
    }

    for(i=0; i<NUM_CDH_IDS; i++)
    {
        EnableWindow(GetDlgItem(m_hwnd, uCDHIDs[i]), fActive && !m_fCDH);
    }

    //
    // fix password and auto check boxes
    //
    fCanSave = (0 != GetUserName(szUser, &dwLen));
    EnableWindow(GetDlgItem(m_hwnd, IDC_SAVE_PASSWORD), fActive && fCanSave);

    //
    // special case - Autoconnect is disabled if save password not checked
    // or password cannot be saved
    //
    EnableWindow(
        GetDlgItem(m_hwnd, IDC_AUTOCONNECT),
        fCanSave && fActive && IsDlgButtonChecked(m_hwnd, IDC_SAVE_PASSWORD));

    DEBUG_LEAVE(0);
}


//
// Other members
//
VOID
CDialUI::OnInitDialog(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnInitDialog",
                 NULL
                 ));

    TCHAR szUser[UNLEN+1];
    DWORD dwLen = UNLEN;
    BOOL fCanSave;

    // Fill in the connectoid list
    EnumerateConnectoids();

    // Get the engine for this connectoid and get relevant properties
    GetProps();

    // check flags for unattended, etc.
    if(GlobalIsProcessExplorer || (m_dwFlags & INTERNET_DIAL_SHOW_OFFLINE))
    {
        m_fOfflineSemantics = TRUE;
    }

    if(m_dwFlags & (INTERNET_DIAL_UNATTENDED|INTERNET_AUTODIAL_FORCE_UNATTENDED))
    {
        // want unattended dial.. do it if we can, else bail out
        m_State = UISTATE_Unattended;
        if(m_pEng)
        {
            m_pEng->Dial();
        }
        else
        {
            OnCancel();
        }
    }

    // make sure cancel button is correct
    FixUIComponents();

    // Handle autoconnect
    if(m_fAutoConnect)
    {
        CheckDlgButton(m_hwnd, IDC_AUTOCONNECT, BST_CHECKED);
        OnConnect();
    }

    DEBUG_LEAVE(0);
}

VOID
CDialUI::OnSelChange()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnSelChange",
                 NULL
                 ));
    int iSel;
    HWND hwndList = GetDlgItem(m_hwnd, IDC_CONN_LIST);

    // yank out new name
    iSel = ComboBox_GetCurSel(hwndList);
    if(CB_ERR == iSel)
        iSel = 0;

    SendMessageWrapW(hwndList, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)m_pDial->params.szEntryName);

    // Fill in props for new connection (will get new engine)
    GetProps();

    DEBUG_LEAVE(0);
}


VOID
CDialUI::OnConnect(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnConnect",
                 NULL
                 ));

    // If we have a CDH, call it
    if(m_fCDH)
    {
        if(!CallCDH(m_hwnd, m_pDial->params.szEntryName, &m_cdh, 0, &(m_pDial->dwResult)))
        {
            // custom dial handler failed to handle dial request, bail out
            m_pDial->dwResult = ERROR_USER_DISCONNECTION;
        }

        m_fDialedCDH = TRUE;
        EndDialog(m_hwnd, 0);
        DEBUG_LEAVE(0);
        return;
    }
    else
    {
        // If we don't have an engine, repop conn list (may have been deleted)
        // and bail out of dial operation
        if(!m_pEng)
        {
            EnumerateConnectoids();
            DEBUG_LEAVE(0);
            return;
        }

        // Save off properties
        SaveProps();
    }

    // TODO grey stuff
    m_State = UISTATE_Dialing;
    FixUIComponents();

    // Stick phone number in progress box
    WCHAR szString[256], szPhone[128];

    LoadStringWrapW(GlobalDllHandle, IDS_DIALING, szString, 128);
    if(SUCCEEDED(m_pEng->GetProperty(DIALPROP_RESOLVEDPHONE, szPhone, 128)))
    {
        StrNCatW(szString, szPhone, 128);
        PostString(m_hwnd, szString);
    }

    // Start the dialing operation
    m_pEng->Dial();

    DEBUG_LEAVE(0);
}


VOID
CDialUI::OnCancel(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnCancel",
                 NULL
                 ));

    switch(m_State)
    {
    case UISTATE_Interactive:
        //
        // exit the dialog box
        //
        m_pDial->dwResult = ERROR_USER_DISCONNECTION;
        EndDialog(m_hwnd, 0);
        break;
    case UISTATE_Unattended:
    case UISTATE_Dialing:
        //
        // cancel current dialing operation
        //
        if(m_pEng)
        {
            m_pEng->HangUp();
        }
        m_pDial->dwResult = ERROR_USER_DISCONNECTION;

        //
        // If we were previous "unattended" we aren't any more
        //
        CheckDlgButton(m_hwnd, IDC_AUTOCONNECT, BST_UNCHECKED);
        m_fAutoConnect = FALSE;

        //
        // fix grey stuff
        //
        FixUIComponents();
        break;
    }

    DEBUG_LEAVE(0);
}


INT_PTR CALLBACK
CDialUI::DialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CDialUI * pui = (CDialUI *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
        pui = (CDialUI *)lParam;
        pui->m_hwnd = hwndDlg;
        pui->OnInitDialog();
        return TRUE;

    case WM_COMMAND:
        // handle combo box messages
        if(HIWORD(wParam) == CBN_SELCHANGE) {
            pui->OnSelChange();
            break;
        }

        switch (LOWORD(wParam))
        {
        case ID_CONNECT:
            pui->OnConnect();
            break;
        case IDCANCEL:
            pui->OnCancel();
            break;
        case IDC_SETTINGS:
            {
            HMODULE hInetcpl = LoadLibrary("inetcpl.cpl");
            if(hInetcpl)
            {
                LAUNCHCPL cpl = (LAUNCHCPL)GetProcAddress(hInetcpl, "LaunchConnectionDialog");
                if(cpl)
                {
                    cpl(hwndDlg);

                    // refresh to new default if any
                    AUTODIAL config;
                    memset(&config, 0, sizeof(config));
                    IsAutodialEnabled(NULL, &config);

                    if(config.fEnabled)
                    {
                        if(config.fHasEntry)
                        {
                            StrCpyW(pui->m_pDial->params.szEntryName, config.pszEntryName);
                        }

                        // refresh settings
                        pui->EnumerateConnectoids();
                        pui->GetProps();
                    }
                    else
                    {
                        // nothing to dial... bail out right away.
                        pui->OnCancel();
                    }   
                }
                FreeLibrary(hInetcpl);
            }
            }
            break;
        case IDC_SAVE_PASSWORD:
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_AUTOCONNECT),
                IsDlgButtonChecked(hwndDlg, IDC_SAVE_PASSWORD));
            break;
        case IDC_PASSWORD:
            if(HIWORD(wParam) == EN_CHANGE)
            {
                pui->m_fPasswordChanged = TRUE;
            }
            break;
        }
        break;
    }
    return FALSE;
}

VOID
CDialUI::EnumerateConnectoids(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::EnumerateConnectoids",
                 NULL
                 ));

    HWND hwndCombo = GetDlgItem(m_hwnd, IDC_CONN_LIST);
    INET_ASSERT(hwndCombo);

    ComboBox_ResetContent(hwndCombo);
    EnsureRasLoaded();

    DWORD dwEntries, dwRet;
    RasEnumHelp RasEnum;
    dwRet = RasEnum.GetError();
    dwEntries = RasEnum.GetEntryCount();
    if(ERROR_SUCCESS == dwRet)
    {
        // insert connectoid names from buffer into combo box
        DWORD i;
        for(i=0; i<dwEntries; i++)
        {
            SendMessageWrapW(hwndCombo, CB_ADDSTRING, 0, (LPARAM)RasEnum.GetEntryW(i));
        }

        // try to find connectoid from pinfo
        int iSel = (int)SendMessageWrapW(hwndCombo, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)m_pDial->params.szEntryName);
        if(CB_ERR == iSel)
        {
            iSel = 0;
            SendMessageWrapW(hwndCombo, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)m_pDial->params.szEntryName);
        }
        ComboBox_SetCurSel(hwndCombo, iSel);
    }

    DEBUG_LEAVE(0);
}


VOID
CDialUI::GetProps(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::GetProps",
                 NULL
                 ));

    WCHAR wzBuffer[256];
    HRESULT hr;
    CDHINFO cdh;

    SAFE_RELEASE(m_pEng);

    //
    // Find out if new selection is a CDH
    //
    m_fCDH = IsCDH(m_pDial->params.szEntryName, &m_cdh);

    //
    // Query for properties for non-CDH connections
    //
    if(!m_fCDH && SUCCEEDED(InternetGetDialEngineW(m_pDial->params.szEntryName, (IDialEventSink *)this, &m_pEng)))
    {
        if(FAILED(m_pEng->GetProperty(DIALPROP_USERNAME, wzBuffer, 256)))
        {
            *wzBuffer = 0;
        }
        SetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_USER_NAME), wzBuffer);

        m_fSavePassword = FALSE;
        hr = m_pEng->GetProperty(DIALPROP_PASSWORD, wzBuffer, 256);
        if(S_OK == hr)
        {
            m_fSavePassword = TRUE;
        }
        else // S_FALSE - no saved password, or error
        {
            *wzBuffer = 0;
        }
        SetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_PASSWORD), wzBuffer);
        CheckDlgButton(m_hwnd, IDC_SAVE_PASSWORD, m_fSavePassword ? BST_CHECKED : BST_UNCHECKED);

        if(FAILED(m_pEng->GetProperty(DIALPROP_DOMAIN, wzBuffer, 256)))
        {
            *wzBuffer = 0;
        }
        SetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_DOMAIN), wzBuffer);
    }

    //
    // fix UI based on connectoid type
    //
    FixUIComponents();

    // reset password changed as setting it above will cause the window message
    m_fPasswordChanged = FALSE;

    DEBUG_LEAVE(0);
}


VOID
CDialUI::SaveProps(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::SaveProps",
                 NULL
                 ));

    WCHAR wzBuffer[256];

    GetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_USER_NAME), wzBuffer, 256);
    m_pEng->SetProperty(DIALPROP_USERNAME, wzBuffer);

    GetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_DOMAIN), wzBuffer, 256);
    m_pEng->SetProperty(DIALPROP_DOMAIN, wzBuffer);

    m_fSavePassword = FALSE;
    if(BST_CHECKED == IsDlgButtonChecked(m_hwnd, IDC_SAVE_PASSWORD))
        m_fSavePassword = TRUE;

    if(m_fPasswordChanged || FALSE == m_fSavePassword)
    {
        GetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_PASSWORD), wzBuffer, 256);
        m_pEng->SetProperty(DIALPROP_PASSWORD, wzBuffer);
        m_pEng->SetProperty(DIALPROP_SAVEPASSWORD, m_fSavePassword ? L"TRUE" : L"FALSE");
        m_fPasswordChanged = FALSE;
    }

    m_fAutoConnect = FALSE;
    if(BST_CHECKED == IsDlgButtonChecked(m_hwnd, IDC_AUTOCONNECT))
        m_fAutoConnect = TRUE;

    DEBUG_LEAVE(0);
}


//////////////////////////////////////////////////////////////////////////////
//
// Helper functions
//
//////////////////////////////////////////////////////////////////////////////

//
// Add a string to the details edit box
//
void PostString(HWND hDlg, LPWSTR pszString)
{
    HWND hwndEdit = GetDlgItem(hDlg, IDC_DETAILS_LIST);
    WCHAR szCR[] = L"\r\n";

    // move caret to end
    SendMessageWrapW(hwndEdit, EM_SETSEL, 0,  -1);
    SendMessageWrapW(hwndEdit, EM_SETSEL, -1, -1);

    // replace selection (nothing) with new string
    SendMessageWrapW(hwndEdit, EM_REPLACESEL, 0, (LPARAM)pszString);

    // move caret to end
    SendMessageWrapW(hwndEdit, EM_SETSEL, 0,  -1);
    SendMessageWrapW(hwndEdit, EM_SETSEL, -1, -1);

    // replace selection (nothing) with CR
    SendMessageWrapW(hwndEdit, EM_REPLACESEL, 0, (LPARAM)szCR);

    // scroll to end
    SendMessageWrapW(hwndEdit, EM_SCROLLCARET, 0, 0);
}


#define RAS_BOGUS_AUTHFAILCODE_1    84
#define RAS_BOGUS_AUTHFAILCODE_2    74389484

DWORD RasErrorToIDS(DWORD dwErr)
{
    if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
    {
        return IDS_PPPRANDOMFAILURE;
    }

    if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
    {
        return IDS_MEDIAINIERROR;
    }

    switch(dwErr)
    {
    default:
        return IDS_PPPRANDOMFAILURE;

    case ERROR_LINE_BUSY:
        return IDS_PHONEBUSY;

    case ERROR_NO_ANSWER:
        return IDS_NOANSWER;

    case ERROR_NO_DIALTONE:
        return IDS_NODIALTONE;

    case ERROR_HARDWARE_FAILURE:    // modem turned off
    case ERROR_PORT_ALREADY_OPEN:   // procomm/hypertrm/RAS has COM port
    case ERROR_PORT_OR_DEVICE:      // got this when hypertrm had the device open -- jmazner
        return IDS_NODEVICE;

    case ERROR_BUFFER_INVALID:              // bad/empty rasdilap struct
    case ERROR_BUFFER_TOO_SMALL:            // ditto?
    case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY: // if connectoid name in registry is wrong
    case ERROR_INTERACTIVE_MODE:
        return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:      // get this on actual CHAP reject
        return IDS_AUTHFAILURE;

    case ERROR_VOICE_ANSWER:
    case ERROR_NO_CARRIER:
    case ERROR_PPP_TIMEOUT:                 // get this on CHAP timeout
    case ERROR_REMOTE_DISCONNECTION:        // Ascend drops connection on auth-fail
    case ERROR_AUTH_INTERNAL:               // got this on random POP failure
    case ERROR_PROTOCOL_NOT_CONFIGURED:     // get this if LCP fails
    case ERROR_PPP_NO_PROTOCOLS_CONFIGURED: // get this if IPCP addr download gives garbage
        return IDS_PPPRANDOMFAILURE;
    }
    return 0;
}

void GetDialErrorString(DWORD dwError, LPWSTR pszBuffer, DWORD dwLength)
{
    DWORD dwRes;

    dwRes = RasErrorToIDS(dwError);

    if(dwRes) {

        // we have a resource - use it
        LoadStringWrapW(GlobalDllHandle, dwRes, pszBuffer, dwLength);

    } else {

        // couldn't get ras error, try system error
        if(0 == FormatMessageWrapW(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, pszBuffer, dwLength, NULL)) {

            // couldn't get system error, get system error E_FAIL == Unknown error
            FormatMessageWrapW(FORMAT_MESSAGE_FROM_SYSTEM, NULL, E_FAIL, 0, pszBuffer, dwLength, NULL);
        }
    }
}

void SetDialError(HWND hDlg, DWORD dwError)
{
    WCHAR szBuf[200];

    GetDialErrorString(dwError, szBuf, 200);
    PostString(hDlg, szBuf);
}

BOOL
FindDialProvider(
    IN  LPWSTR      pwzConnectoid,
    IN  LPWSTR      pwzProviderType,
    OUT CLSID *     pclsid
    )
//
// FindDialProvider - find an engine, UI, or branding provider for a
// specific connectoid
//
{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "FindDialProvider",
                 "%#x (%Q), %#x (%Q), %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 pwzProviderType,
                 pwzProviderType,
                 pclsid
                 ));

    WCHAR szKey[MAX_PATH];
    WCHAR szClsid[64];
    DWORD dwSize;

    // get the key for the connectoid
    GetConnKeyW(pwzConnectoid, szKey, ARRAYSIZE(szKey));

    // read the CLSID string
    dwSize = sizeof(szClsid);
    if(ERROR_SUCCESS != SHGetValueW(
            HKEY_CURRENT_USER,
            szKey,
            pwzProviderType,
            NULL,
            szClsid,
            &dwSize))
    {
        // no provider specified
        DEBUG_PRINT(DIALUP, INFO, ("No provider found.\n"));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    // covert string to clsid
    if(FAILED(CLSIDFromString(szClsid, pclsid)))
    {
        DEBUG_PRINT(DIALUP, INFO, ("Unable to convert clsid.\n"));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    DEBUG_LEAVE(TRUE);
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// Public APIs
//
//////////////////////////////////////////////////////////////////////////////


INTERNETAPI InternetGetDialEngineW(
    IN LPWSTR               pwzConnectoid,
    IN IDialEventSink *     pdes,
    OUT IDialEngine **      ppde
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Dword,
                 "InternetGetDialEngineW",
                 "%#x (%Q), %#x, %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 pdes,
                 ppde
                 ));

    HRESULT hr;
    CLSID   clsid;

    *ppde = NULL;

    //
    // find engine we're going to use
    //
    if(FindDialProvider(pwzConnectoid, L"DialEngine", &clsid))
    {
        // engine specified, try to create it
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                IID_IDialEngine, (void **)ppde);
    }

    if(NULL == *ppde)
    {
        // use default engine
        CDialEngine * pEngine = new CDialEngine();
        if(pEngine)
        {
            hr = pEngine->QueryInterface(IID_IDialEngine, (void **)ppde);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = (*ppde)->Initialize(pwzConnectoid, pdes);

        if(FAILED(hr))
        {
            (*ppde)->Release();
            *ppde = NULL;
        }
    }

    DEBUG_LEAVE_API(hr);
    return hr;
}

#if 0
//
// [darrenmi 4/14/00] cleaning up exports of incomplete feature
//

INTERNETAPI InternetGetDialBrandingW(
    IN LPWSTR               pwzConnectoid,
    OUT IDialBranding **    ppdb
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Dword,
                 "InternetGetDialBrandingW",
                 "%#x (%Q), %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 ppdb
                 ));

    HRESULT hr = S_FALSE;
    CLSID   clsid;

    *ppdb = NULL;

    //
    // find engine we're going to use
    //
    if(FindDialProvider(pwzConnectoid, L"DialBranding", &clsid))
    {
        // engine specified, try to create it
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                IID_IDialBranding, (void **)ppdb);
    }

    if(SUCCEEDED(hr))
    {
        hr = (*ppdb)->Initialize(pwzConnectoid);
        if(FAILED(hr))
        {
            (*ppdb)->Release();
            *ppdb = NULL;
        }
    }

    DEBUG_LEAVE_API(hr);
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\dllentry.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dllentry.cxx

Abstract:

    Entry point for WinInet Internet client DLL

    Contents:
        WinInetDllEntryPoint

Author:

    Richard L Firth (rfirth) 10-Nov-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    10-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <process.h>
#include <perfdiag.hxx>
#include <shlwapi.h>
#include <advpub.h>
#include "autodial.h"

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;


#define FLAGS_SZ "Flags"
#define FLAGS_DW PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI | PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED
#define IE_SECURITY_DIGEST_REG_KEY "Software\\Microsoft\\Internet Explorer\\Security\\Digest"


#if defined(__cplusplus)
extern "C" {
#endif

BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );


#if defined(__cplusplus)
}
#endif

//
// global data
//

GLOBAL CRITICAL_SECTION GeneralInitCritSec = {0};

//
// functions
//

void SetupDelayloadErrorHandler()
{
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(GetModuleHandleA("shlwapi.dll"), "DelayLoadFailureHook");
}



BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    if (Reason != DLL_PROCESS_ATTACH) {

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

    }

    DWORD error;

    //
    // perform global dll initialization, if any.
    //
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        GlobalDllHandle = DllHandle;
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        // Call SHFusionInitialize only on themed platforms:
        if (GlobalPlatformWhistler)
            SHFusionInitializeFromModule((HMODULE)DllHandle);

        SetupDelayloadErrorHandler();
        
        InitializeCriticalSection(&GeneralInitCritSec);

        INITIALIZE_DEBUG_REGKEY();
        INITIALIZE_DEBUG_MEMORY();
        INET_DEBUG_START();

        GlobalDllInitialize();
        if (!InternetCreateThreadInfo(TRUE)) {
            return FALSE;
        }

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

        DEBUG_LEAVE(TRUE);

        break;

    case DLL_PROCESS_DETACH:

        //
        // signal to all APIs (and any other function that might have an
        // interest) that the DLL is being shutdown
        //

        GlobalDynaUnload = (Reserved == NULL) ? TRUE : FALSE;
        InDllCleanup = TRUE;
        GlobalPleaseQuitWhatYouAreDoing = TRUE;

        DEBUG_PRINT(DLL,
                    INFO,
                    ("DLL Terminated\n"
                    ));

        DEBUG_LEAVE(TRUE);

        if (GlobalDynaUnload) {
            if (GlobalDataInitialized) {
                GlobalDataTerminate();
            }
            GlobalDllTerminate();
            ExitAutodialModule();
            InternetTerminateThreadInfo();
        }

        CloseInternetSettingsKey();

        PERF_DUMP();

        PERF_END();

        //TERMINATE_DEBUG_MEMORY(FALSE);
        TERMINATE_DEBUG_MEMORY(TRUE);
        INET_DEBUG_FINISH();
        TERMINATE_DEBUG_REGKEY();

        //InternetDestroyThreadInfo();

        GlobalUserName.~CUserName();
        DeleteCriticalSection(&GeneralInitCritSec);

        // Call SHFusionUninitialize only on themed platforms:
        if (GlobalPlatformWhistler)
            SHFusionUninitialize();
        
        break;

    case DLL_THREAD_DETACH:

        //
        // kill the INTERNET_THREAD_INFO
        //

        DEBUG_LEAVE(TRUE);

        InternetDestroyThreadInfo();
        break;

    case DLL_THREAD_ATTACH:

        //
        // we do nothing for thread attach - if we need an INTERNET_THREAD_INFO
        // then it gets created by the function which realises we need one
        //

        AllowCAP();

        DEBUG_LEAVE(TRUE);

        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(GlobalDllHandle, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

extern VOID MakeCacheLocationsConsistent();

STDAPI
DllInstall
(
    IN BOOL      bInstall,   // Install or Uninstall
    IN LPCWSTR    pwStr
)
{
    HRESULT hr = S_OK;

    if(bInstall && StrCmpIW( pwStr, L"HKCUHard") == 0)
    {
        AddHardeningPrivacyDefaults();
        return hr;
    }

    if(bInstall && StrCmpIW( pwStr, L"HKCUSoft") == 0)
    {
        RemoveHardeningPrivacyDefaults();
        return hr;
    }


// Add entries to selfreg.inx and include the code below to support self-registration.
#ifdef WININET_SELFREG

    BOOL bUseHKCU = FALSE;
    if (pwStr && (0 == StrCmpIW(pwStr, L"HKCU")))
    {
        bUseHKCU = TRUE;
    }

    if ( bInstall )
    {
        hr = CallRegInstall(bUseHKCU ? "Reg.HKCU" : "Reg.HKLM");
    }
    else
    {
        hr = CallRegInstall(bUseHKCU ? "Unreg.HKCU" : "UnReg.HKLM");
    }
#endif

    if( bInstall && (!pwStr || !*pwStr || (StrCmpIW( pwStr, L"HKLM") == 0)))
    {
        // Write out to HKLM\Software\Microsoft\Internet Explorer\Security\Digest
        HKEY hKey;
        DWORD dwError, dwRegDisp, dwFlags;
        dwFlags = FLAGS_DW;

        dwError =  REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
            IE_SECURITY_DIGEST_REG_KEY, 0, NULL,
                0, KEY_READ | KEY_WRITE, NULL, &hKey, &dwRegDisp);

        if (dwError == ERROR_SUCCESS)
        {
            dwError = RegSetValueEx(hKey, FLAGS_SZ, 0,
                REG_BINARY, (LPBYTE) &dwFlags, sizeof(DWORD));
            REGCLOSEKEY(hKey);
        }


        // also need to fix up the HKLM\SV\MS\IE\AdavancedOptions\Negotiate so that "Restore Defaults" will work
        // HKEY hKey;
        // DWORD dwError, dwRegDisp, dwFlags;
        
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        if (GlobalPlatformWhistler)
        {
            dwFlags = 0x00000001;

            dwError =  REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
                "SOFTWARE\\Microsoft\\Internet Explorer\\AdvancedOptions\\CRYPTO\\NEGOTIATE", 0, NULL,
                    0, KEY_WRITE, NULL, &hKey, &dwRegDisp);

            if (dwError == ERROR_SUCCESS)
            {
                dwError = RegSetValueEx(hKey, "DefaultValue", 0,
                    REG_DWORD, (LPBYTE) &dwFlags, sizeof(DWORD));
                REGCLOSEKEY(hKey);
            }
        }

#ifndef UNIX
        DWORD dwNSVersion;
        if( GetActiveNetscapeVersion( &dwNSVersion) == FALSE)
            dwNSVersion = 0;
        SetNetscapeImportVersion( dwNSVersion);
#endif // UNIX

        WritePrivateProfileString("compatibility", "NOTIFIER", "0x400000", "win.ini");
        WritePrivateProfileString(NULL, NULL, NULL, "win.ini");
    }
    else if(bInstall && StrCmpIW( pwStr, L"HKCU") == 0)
    {

        MakeCacheLocationsConsistent();

#ifndef UNIX
        TCHAR szNSFilename[MAX_PATH];
        DWORD cNSFilenameSize = MAX_PATH;
        DWORD dwNSVersion;

        if( GetNetscapeImportVersion( &dwNSVersion) == TRUE
            && dwNSVersion != 0
            && FindNetscapeCookieFile( dwNSVersion, szNSFilename, &cNSFilenameSize) == TRUE)
        {
            ImportCookieFile( szNSFilename );
        }
#endif // UNIX

        ie401::Import401History();

        ie401::Import401Content();
    }
    else if (!bInstall && (!pwStr || !*pwStr || (StrCmpIW(pwStr, L"HKLM") == 0)))
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE, IE_SECURITY_DIGEST_REG_KEY);
    }

    //
    // set up privacy defaults
    //
    if(bInstall && StrCmpIW( pwStr, L"HKCU") == 0 && !IsInGUIModeSetup())
    {
        CheckPrivacyDefaults();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\inetapiu.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.cxx

Abstract:

    Contains WinInet API utility & sub-API functions

    Contents:
        wInternetQueryDataAvailable

Author:

    Richard L Firth (rfirth) 16-Feb-1996

Environment:

    Win32 user-level

Revision History:

    16-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include "inetapiu.h"

DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

//
// functions
//


BOOL
wInternetQueryDataAvailable(
    IN LPVOID hFileMapped,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Part 2 of InternetQueryDataAvailabe. This function is called by the async
    worker thread in order to resume InternetQueryDataAvailable(), and by the
    app as the worker part of the API, post validation

    We can query available data for handle types that return data, either from
    a socket, or from a cache file:

        - HTTP request
        - FTP file
        - FTP find
        - FTP find HTML
        - gopher file
        - gopher find
        - gopher find HTML

Arguments:

    hFileMapped                 - the mapped HINTERNET

    lpdwNumberOfBytesAvailable  - where the number of bytes is returned

    dwFlags                     - flags controlling operation

    dwContext                   - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_INET,
                Bool,
                "wInternetQueryDataAvailable",
                "%#x, %#x, %#x, %#x",
                hFileMapped,
                lpdwNumberOfBytesAvailable,
                dwFlags,
                dwContext
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;

    INET_ASSERT(hFileMapped);

    //
    // as usual, grab the per-thread info block
    //

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this is the async worker thread then set the context, handle, and
    // last-error info in the per-thread data block before we go any further
    // (we already did this on the sync path)
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        _InternetSetContext(lpThreadInfo,
                            ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetContext()
                            );
        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle(),
                                 hFileMapped
                                 );
        _InternetClearLastError(lpThreadInfo);

        //
        // we should only be here in async mode if there was no data immediately
        // available
        //

        INET_ASSERT(!((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable());

    }

    //
    // get the local handle for FTP & gopher
    //

    HINTERNET hLocal;

    error = RGetLocalHandle(hFileMapped, &hLocal);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we copy the number of bytes available to a local variable first, and
    // only update the caller's variable if we succeed
    //

    DWORD bytesAvailable;

    //
    // get the current data available, based on the handle type
    //

    switch (handleType = ((HANDLE_OBJECT *)hFileMapped)->GetHandleType()) {
    case TypeHttpRequestHandle:
        error = ((HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped)
                    ->QueryDataAvailable(&bytesAvailable);
        break;

    case TypeFtpFileHandle:
    case TypeFtpFindHandle:
        error = wFtpQueryDataAvailable(hLocal, &bytesAvailable);
        break;

    case TypeGopherFileHandle:
    case TypeGopherFindHandle:
        error = wGopherQueryDataAvailable(hLocal, &bytesAvailable);
        break;

    case TypeFtpFindHandleHtml:
    case TypeGopherFindHandleHtml:
        error = QueryHtmlDataAvailable(hFileMapped, &bytesAvailable);
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                    IsCacheWriteInProgress()) {
            DWORD errorCache = error;

            if ((errorCache == ERROR_SUCCESS) && (bytesAvailable == 0)) {
                errorCache = ERROR_NO_MORE_FILES;
            }
            if (errorCache != ERROR_SUCCESS) {
                if (handleType == TypeFtpFindHandleHtml) {
                    InbLocalEndCacheWrite(  hFileMapped,
                                            "htm",
                                            (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
                else {
                    InbGopherLocalEndCacheWrite(  hFileMapped,
                                                "htm",
                                                (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
            }
        }
        break;

#ifdef EXTENDED_ERROR_HTML

    case TypeFtpFileHandleHtml:
        error = QueryHtmlDataAvailable(hFileMapped, &bytesAvailable);
        break;

#endif

    default:
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        break;
    }

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->SetAvailableDataLength(bytesAvailable);
        *lpdwNumberOfBytesAvailable = bytesAvailable;
        success = TRUE;

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    bytesAvailable
                    ));

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                        lpdwNumberOfBytesAvailable,
                        bytesAvailable
                        ));

    } else {
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    SetLastError(error);

    DEBUG_LEAVE(success);

    return success;
}


STDAPI_(BOOL) ForceNexusLookupExW(
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    PP_CONTEXT hPP = 0; 

    hPP = ::PP_InitContext(L"WinInet.Dll", NULL); 
    
    BOOL RetVal = ::PP_ForceNexusLookup (hPP, 
                                         fForce,
                                         pwszRegUrl, 
                                         pdwRegUrlLen, 
                                         pwszDARealm, 
                                         pdwDARealmLen );

    ::PP_FreeContext ( hPP );

    return RetVal;
    
}

STDAPI_(VOID) ForceNexusLookup(void)
{
    PP_CONTEXT hPP = 0; 

    hPP = ::PP_InitContext(L"WinInet.Dll", NULL); 
    
    ::PP_ForceNexusLookup (hPP,
                           FALSE, // don't force connection establishment if nexus not reachable
                           NULL, 
                           0, 
                           NULL, 
                           0 );

    ::PP_FreeContext ( hPP );
}


BOOL 
GetMD5Result(PSTR pszChallengeInfo, PSTR pszPassword, PBYTE pbHexHash);


///////////////
// This routine gets the default passport password and does an MD5 hash of it with
// the supplied ChallengeInfo and returns the result in hex string format.  
//
// pwszRealm = realm to get the password for.  If NULL, uses default.  Ignored if pwszTarget is not null.
//
// pwszTarget = target to get the password for.  If NULL, uses realm
//
// pbHexHash = output buffer to receive the MD5 result in hex string format, 
//             MUST BE AT LEAST MD5DIGESTLEN * 2 + 1 IN SIZE
//
// Returns TRUE if success, FALSE if failure.
//
// 

STDAPI_(BOOL) CreateMD5SSOHash ( 
	IN PWSTR    pszChallengeInfo,
	IN PWSTR    pwszRealm,
	IN PWSTR    pwszTarget,
	OUT PBYTE   pbHexHash
)
{
    PP_CONTEXT hPP = 0; 
	BOOL bRetVal = FALSE;

    hPP = ::PP_InitContext(L"WinInet.Dll", NULL); 

	if ( hPP )
	{
		WCHAR pszPassword[INTERNET_MAX_PASSWORD_LENGTH];

		// Check for cached creds in the session 
		if (::PP_GetCachedCredential ( hPP, pwszRealm, pwszTarget, NULL, pszPassword) )
		{
			DWORD dwChallengeInfoLen = wcslen(pszChallengeInfo) + 1;
			PSTR pszChallengeInfoA = (PSTR) LocalAlloc (LPTR, dwChallengeInfoLen );

			DWORD dwPasswordLen = wcslen(pszPassword) + 1;
			PSTR pszPasswordA = (PSTR) LocalAlloc (LPTR, dwPasswordLen );

			if ( pszChallengeInfoA != NULL && pszPasswordA != NULL )
			{
				// convert to asci
				::WideCharToMultiByte(CP_ACP, 0, pszChallengeInfo, -1, pszChallengeInfoA, dwChallengeInfoLen, NULL, NULL);
				::WideCharToMultiByte(CP_ACP, 0, pszPassword, -1, pszPasswordA, dwPasswordLen, NULL, NULL);

				bRetVal = GetMD5Result ( pszChallengeInfoA, pszPasswordA, pbHexHash );

				ZeroMemory ( pszPassword, INTERNET_MAX_PASSWORD_LENGTH * sizeof(WCHAR) );
				ZeroMemory ( pszPasswordA, dwPasswordLen );

			}
	
		    if ( pszChallengeInfoA )
				LocalFree ( pszChallengeInfoA );
			if ( pszPasswordA )
				LocalFree ( pszPasswordA );
		}

		::PP_FreeContext ( hPP );
	}

	return bRetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\inetapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapia.cxx

Abstract:

    Contains the ANSI and character-mode-independent Internet APIs

    Contents:
        InternetCrackUrlA
        InternetCreateUrlA
        InternetCanonicalizeUrlA
        InternetCombineUrlA
        InternetOpenA
        InternetCloseHandle
        _InternetCloseHandle
        _InternetCloseHandleNoContext
        InternetConnectA
        InternetOpenUrlA
        InternetReadFile
        ReadFile_End
        InternetReadFileExA
        InternetWriteFile
        InternetWriteFileExA
        InternetSetFilePointer
        InternetQueryDataAvailable
        InternetFindNextFileA
        InternetQueryOptionA
        InternetSetOptionA
        InternetSetOptionExA
        InternetGetLastResponseInfoA
        InternetSetStatusCallbackA
        //InternetCancelAsyncRequest
        (wInternetCloseConnectA)
        (GetEmailNameAndPassword)
        InternetAttemptConnect
        (CreateDeleteSocket)
        InternetLockRequestFile
        InternetUnlockRequestFile
        InternetCheckConnectionA

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana


--*/


#include <wininetp.h>
#include <perfdiag.hxx>
#include "inetapiu.h"

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

#include "autodial.h"

//
// public ..?
//

extern "C" {

INTERNETAPI_(BOOL) InternetGetCertByURLA(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    );

}


//
// private manifests
//

//
// private prototypes
//

PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    );

PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    );

PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    );

PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    );


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET lpConnectHandle,
    IN DWORD ServiceType
    );

PRIVATE
DWORD
GetEmailNameAndPassword(
    IN OUT LPSTR* lplpszUserName,
    IN OUT LPSTR* lplpszPassword,
    OUT LPSTR lpszEmailName,
    IN DWORD dwEmailNameLength
    );

PRIVATE
BOOL
InternetParseCommon(
    IN LPCTSTR lpszBaseUrl,
    IN LPCTSTR lpszRelativeUrl,
    OUT LPTSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );

//PRIVATE
//DWORD
//CreateDeleteSocket(
//    VOID
//    );

BOOL
GetWininetUserName(
    VOID
);



//
// functions
//


INTERNETAPI_(BOOL) InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCrackUrlA",
                     "%q, %#x, %#x, %#x",
                     lpszUrl,
                     dwUrlLength,
                     dwFlags,
                     lpUrlComponents
                     ));

    DWORD error;

    //
    // validate parameters
    //

    if (ARGUMENT_PRESENT(lpszUrl)) {
        if (dwUrlLength == 0) {
            error = ProbeString((LPSTR)lpszUrl, &dwUrlLength);
        } else {
            error = ProbeReadBuffer((LPVOID)lpszUrl, dwUrlLength);
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if ((lpUrlComponents == NULL)
    || (lpUrlComponents->dwStructSize != sizeof(*lpUrlComponents))) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ProbeWriteBuffer((LPVOID)lpUrlComponents,
                                 sizeof(*lpUrlComponents)
                                 );
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only allow two flags for this API
    //

    if (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }
    
    if (!GlobalDataInitialized) 
    {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) 
        {
            goto quit;
        }
    }

    //
    // get the individual components to return. If they reference a buffer then
    // check it for writeability
    //

    LPSTR lpUrl;
    LPSTR urlCopy;
    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT nPort;
    LPSTR userName;
    DWORD userNameLength;
    LPSTR password;
    DWORD passwordLength;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extraInfo;
    DWORD extraInfoLength;
    BOOL copyComponent;
    BOOL havePort;

    copyComponent = FALSE;

    schemeName = lpUrlComponents->lpszScheme;
    schemeNameLength = lpUrlComponents->dwSchemeLength;
    if ((schemeName != NULL) && (schemeNameLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)schemeName, schemeNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *schemeName = '\0';
        copyComponent = TRUE;
    }

    hostName = lpUrlComponents->lpszHostName;
    hostNameLength = lpUrlComponents->dwHostNameLength;
    if ((hostName != NULL) && (hostNameLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)hostName, hostNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *hostName = '\0';
        copyComponent = TRUE;
    }

    userName = lpUrlComponents->lpszUserName;
    userNameLength = lpUrlComponents->dwUserNameLength;
    if ((userName != NULL) && (userNameLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)userName, userNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *userName = '\0';
        copyComponent = TRUE;
    }

    password = lpUrlComponents->lpszPassword;
    passwordLength = lpUrlComponents->dwPasswordLength;
    if ((password != NULL) && (passwordLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)password, passwordLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *password = '\0';
        copyComponent = TRUE;
    }

    urlPath = lpUrlComponents->lpszUrlPath;
    urlPathLength = lpUrlComponents->dwUrlPathLength;
    if ((urlPath != NULL) && (urlPathLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)urlPath, urlPathLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *urlPath = '\0';
        copyComponent = TRUE;
    }

    extraInfo = lpUrlComponents->lpszExtraInfo;
    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
    if ((extraInfo != NULL) && (extraInfoLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)extraInfo, extraInfoLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *extraInfo = '\0';
        copyComponent = TRUE;
    }

    //
    // we can only escape or decode the URL if the caller has provided us with
    // buffers to write the escaped strings into
    //

    if (dwFlags & (ICU_ESCAPE | ICU_DECODE)) {
        if (!copyComponent) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        urlCopy = NewString((LPSTR)lpszUrl, dwUrlLength);
        if (urlCopy == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        lpUrl = urlCopy;
    } else {
        lpUrl = (LPSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     (dwFlags & ICU_ESCAPE) ? TRUE : FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     extraInfoLength ? &extraInfo : NULL,
                     extraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto crack_error;
    }

    BOOL copyFailure;

    copyFailure = FALSE;

    //
    // update the URL_COMPONENTS structure based on the results, and what was
    // asked for
    //

    if (lpUrlComponents->lpszScheme != NULL) {
        if (lpUrlComponents->dwSchemeLength > schemeNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszScheme,
                   (LPVOID)schemeName,
                   schemeNameLength
                   );
            lpUrlComponents->lpszScheme[schemeNameLength] = '\0';
            // Windows Bug 757146
            // No longer unescaping the scheme. It's just wrong to do so.
            // if (dwFlags & ICU_DECODE) {
            //    UrlUnescapeInPlace(lpUrlComponents->lpszScheme, 0);
            // }
        } else {
            ++schemeNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    } else if (lpUrlComponents->dwSchemeLength != 0) {
        lpUrlComponents->lpszScheme = schemeName;
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    }

    if (lpUrlComponents->lpszHostName != NULL) {
        if (lpUrlComponents->dwHostNameLength > hostNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszHostName,
                   (LPVOID)hostName,
                   hostNameLength
                   );
            lpUrlComponents->lpszHostName[hostNameLength] = '\0';
            // Windows Bug 757146
            // No longer unescaping the host name if ICU_DECODE set. 
            // It already has been unescaped once in CrackUrl above.
            // if (dwFlags & ICU_DECODE) {
            //     UrlUnescapeInPlace(lpUrlComponents->lpszHostName, 0);
            // }
        } else {
            ++hostNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwHostNameLength = hostNameLength;
    } else if (lpUrlComponents->dwHostNameLength != 0) {
        lpUrlComponents->lpszHostName = hostName;
        lpUrlComponents->dwHostNameLength = hostNameLength;
    }

    if (lpUrlComponents->lpszUserName != NULL) {
        if (lpUrlComponents->dwUserNameLength > userNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUserName,
                   (LPVOID)userName,
                   userNameLength
                   );
            lpUrlComponents->lpszUserName[userNameLength] = '\0';
            // Windows Bug 757146
            // No longer unescaping the user name if ICU_DECODE set. 
            // It already has been unescaped once in CrackUrl above.
            // if (dwFlags & ICU_DECODE) {
            //     UrlUnescapeInPlace(lpUrlComponents->lpszUserName, 0);
            // }
        } else {
            ++userNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwUserNameLength = userNameLength;
    } else if (lpUrlComponents->dwUserNameLength != 0) {
        lpUrlComponents->lpszUserName = userName;
        lpUrlComponents->dwUserNameLength = userNameLength;
    }

    if (lpUrlComponents->lpszPassword != NULL) {
        if (lpUrlComponents->dwPasswordLength > passwordLength) {
            memcpy((LPVOID)lpUrlComponents->lpszPassword,
                   (LPVOID)password,
                   passwordLength
                   );
            lpUrlComponents->lpszPassword[passwordLength] = '\0';
            // Windows Bug 757146
            // No longer unescaping the password if ICU_DECODE set. 
            // It already has been unescaped once in CrackUrl above.
            // if (dwFlags & ICU_DECODE) {
            //     UrlUnescapeInPlace(lpUrlComponents->lpszPassword, 0);
            // }
        } else {
            ++passwordLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwPasswordLength = passwordLength;
    } else if (lpUrlComponents->dwPasswordLength != 0) {
        lpUrlComponents->lpszPassword = password;
        lpUrlComponents->dwPasswordLength = passwordLength;
    }

    if (lpUrlComponents->lpszUrlPath != NULL) {
        if(schemeType == INTERNET_SCHEME_FILE)
        {
            //
            //  for file: urls we return the path component
            //  as a valid dos path.
            //

            copyFailure = FAILED(PathCreateFromUrl(lpUrl, lpUrlComponents->lpszUrlPath, &(lpUrlComponents->dwUrlPathLength), 0));
        }
        else if (lpUrlComponents->dwUrlPathLength > urlPathLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUrlPath,
                   (LPVOID)urlPath,
                   urlPathLength
                   );
            lpUrlComponents->lpszUrlPath[urlPathLength] = '\0';
            // Windows Bug 757146
            // Unescape the path if only ICU_DECODE is set.
            // ICU_ESCAPE causes the path to be unescaped in 
            // CrackUrl above.  
            if ((dwFlags & (ICU_DECODE | ICU_ESCAPE)) == ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUrlPath, 0);
            }
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        } else {
            ++urlPathLength;
            copyFailure = TRUE;
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        }
    } else if (lpUrlComponents->dwUrlPathLength != 0) {
        lpUrlComponents->lpszUrlPath = urlPath;
        lpUrlComponents->dwUrlPathLength = urlPathLength;
    }

    if (lpUrlComponents->lpszExtraInfo != NULL) {
        if (lpUrlComponents->dwExtraInfoLength > extraInfoLength) {
            memcpy((LPVOID)lpUrlComponents->lpszExtraInfo,
                   (LPVOID)extraInfo,
                   extraInfoLength
                   );
            lpUrlComponents->lpszExtraInfo[extraInfoLength] = '\0';
            // Windows Bug 757146
            // Unescape the extrainfo if only ICU_DECODE is set.
            // ICU_ESCAPE causes the extrainfo to be unescaped in 
            // CrackUrl above.  
            if ((dwFlags & (ICU_DECODE | ICU_ESCAPE)) == ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszExtraInfo, 0);
            }
        } else {
            ++extraInfoLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    } else if (lpUrlComponents->dwExtraInfoLength != 0) {
        lpUrlComponents->lpszExtraInfo = extraInfo;
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    }

    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //
    // N.B. Don't change error below here. If need be, move this test lower
    //

    if (copyFailure) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case INTERNET_SCHEME_FTP:
            nPort = INTERNET_DEFAULT_FTP_PORT;
            break;

        case INTERNET_SCHEME_GOPHER:
            nPort = INTERNET_DEFAULT_GOPHER_PORT;
            break;

        case INTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case INTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

crack_error:

    if (urlCopy != NULL) {
        DEL_STRING(urlCopy);
    }

quit:
    BOOL success = (error==ERROR_SUCCESS);

    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI_(BOOL) InternetCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl OPTIONAL,
    IN OUT LPDWORD lpdwUrlLength
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

    lpUrlComponents - pointer to URL_COMPONENTS structure containing pointers
                      and lengths of components of interest

    dwFlags         - flags controlling function:

                        ICU_ESCAPE  - the components contain characters that
                                      must be escaped in the output URL

    lpszUrl         - pointer to buffer where output URL will be written

    lpdwUrlLength   - IN: number of bytes in lpszUrl buffer
                      OUT: if success, number of characters in lpszUrl, else
                           number of bytes required for buffer

Return Value:

    BOOL
        Success - URL written to lpszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCreateUrlA",
                     "%#x, %#x, %#x, %#x",
                     lpUrlComponents,
                     dwFlags,
                     lpszUrl,
                     lpdwUrlLength
                     ));

#if INET_DEBUG

    LPSTR lpszUrlOriginal = lpszUrl;

#endif

    DWORD error = ERROR_SUCCESS;
    LPSTR encodedUserName = NULL;
    LPSTR encodedPassword = NULL;
    LPSTR encodedHostName = NULL;
    LPSTR encodedUrlPath = NULL;
    LPSTR encodedExtraInfo = NULL;

    //
    // validate parameters
    //

    if ((lpUrlComponents == NULL)
    || (lpUrlComponents->dwStructSize != sizeof(*lpUrlComponents))
    || (dwFlags & ~(ICU_ESCAPE | ICU_USERNAME | ICU_ESCAPE_AUTHORITY))
    || (lpdwUrlLength == NULL)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!ARGUMENT_PRESENT(lpszUrl)) {
        *lpdwUrlLength = 0;
    }

    //
    // allocate large buffers from heap
    //

    encodedHostName = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_HOST_NAME_LENGTH + 1);
    encodedUserName = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_USER_NAME_LENGTH + 1);
    encodedPassword = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_PASSWORD_LENGTH + 1);
    encodedUrlPath = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    encodedExtraInfo = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    if ((encodedHostName == NULL) || 
        (encodedUserName == NULL) || 
        (encodedPassword == NULL) ||
        (encodedUrlPath == NULL) || 
        (encodedExtraInfo == NULL)
        ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we get an exception, we return ERROR_INVALID_PARAMETER
    //

    __try {

        //
        // get the individual components to copy
        //

        LPSTR schemeName;
        DWORD schemeNameLength;
        DWORD schemeFlags;
        LPSTR hostName;
        DWORD hostNameLength;
        DWORD encodedHostNameLength;
        INTERNET_PORT nPort;
        DWORD portLength;
        LPSTR userName;
        DWORD userNameLength;
        DWORD encodedUserNameLength;
        LPSTR password;
        DWORD passwordLength;
        DWORD encodedPasswordLength;
        LPSTR urlPath;
        DWORD urlPathLength;
        DWORD extraLength;
        DWORD encodedUrlPathLength;
        LPSTR extraInfo;
        DWORD extraInfoLength;
        DWORD encodedExtraInfoLength;
        LPSTR schemeSep;
        DWORD schemeSepLength;
        INTERNET_SCHEME schemeType;
        INTERNET_PORT defaultPort;

        //
        // if the scheme name is absent then we use the default
        //

        schemeName = lpUrlComponents->lpszScheme;
        schemeType = lpUrlComponents->nScheme;

        if (schemeName == NULL) {
            if (schemeType == INTERNET_SCHEME_DEFAULT){
                schemeName = DEFAULT_URL_SCHEME_NAME;
                schemeNameLength = sizeof(DEFAULT_URL_SCHEME_NAME) - 1;
            }
            else {
                schemeName = MapUrlScheme(schemeType, &schemeNameLength);
            }
        } else {
            schemeNameLength = lpUrlComponents->dwSchemeLength;
            if (schemeNameLength == 0) {
                schemeNameLength = lstrlen(schemeName);
            }
        }

        //
        // determine the schemeFlags for possible use in encoding below
        //
        
        schemeFlags = 0;
        if (strnicmp(schemeName, "http", schemeNameLength) == 0) {
            schemeFlags = SCHEME_HTTP;
        } else if (strnicmp(schemeName, "ftp", schemeNameLength) == 0) {
            schemeFlags = SCHEME_FTP;
        } else if (strnicmp(schemeName, "gopher", schemeNameLength) == 0) {
            schemeFlags = SCHEME_GOPHER;
        }

        //
        // doesn't have to be a host name
        //

        hostName = lpUrlComponents->lpszHostName;
        portLength = 0;
        if (hostName != NULL) {
            hostNameLength = lpUrlComponents->dwHostNameLength;
            if (hostNameLength == 0) {
                hostNameLength = lstrlen(hostName);
            }
            // Windows Bugs 625684
            // encode hostname if ICU_ESCAPE_AUTHORITY is set
            if (dwFlags & ICU_ESCAPE_AUTHORITY) {
                encodedHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH + 1;
                error = EncodeAuthorityComponent(
                                      hostName,
                                      hostNameLength,
                                      encodedHostName,
                                      &encodedHostNameLength
                                      );
                if (error == ERROR_SUCCESS) {
                    hostName = encodedHostName;
                    hostNameLength = encodedHostNameLength;
                }
            }
        //
        // if the port is default then we don't add it to the URL, else we need to
        // copy it as a string
        //
        // there won't be a port unless there's host.

            schemeType = MapUrlSchemeName(schemeName, schemeNameLength ? schemeNameLength : -1);
            switch (schemeType) {
            case INTERNET_SCHEME_FTP:
                defaultPort = INTERNET_DEFAULT_FTP_PORT;
                break;

            case INTERNET_SCHEME_GOPHER:
                defaultPort = INTERNET_DEFAULT_GOPHER_PORT;
                break;

            case INTERNET_SCHEME_HTTP:
                defaultPort = INTERNET_DEFAULT_HTTP_PORT;
                break;

            case INTERNET_SCHEME_HTTPS:
                defaultPort = INTERNET_DEFAULT_HTTPS_PORT;
                break;

            default:
                defaultPort = INTERNET_INVALID_PORT_NUMBER;
                break;
            }

            if (lpUrlComponents->nPort != defaultPort) {

                INTERNET_PORT divisor;

                nPort = lpUrlComponents->nPort;
                if (nPort) {
                    divisor = 10000;
                    portLength = 6; // max is 5 characters, plus 1 for ':'
                    while ((nPort / divisor) == 0) {
                        --portLength;
                        divisor /= 10;
                    }
                } else {
                    portLength = 2;         // port is ":0"
                }
            }
        } else {
            hostNameLength = 0;
        }


        //
        // doesn't have to be a user name
        //

        if (error == ERROR_SUCCESS) {

            userName = lpUrlComponents->lpszUserName;
            if (userName != NULL) {
                userNameLength = lpUrlComponents->dwUserNameLength;
                if (userNameLength == 0) {
                    userNameLength = lstrlen(userName);
                }
                // Windows Bugs 625684
                // encode hostname if ICU_ESCAPE_AUTHORITY is set
                if (dwFlags & ICU_ESCAPE_AUTHORITY) {
                    encodedUserNameLength = INTERNET_MAX_USER_NAME_LENGTH + 1;
                    error = EncodeAuthorityComponent(
                                          userName,
                                          userNameLength,
                                          encodedUserName,
                                          &encodedUserNameLength
                                          );
                    if (error == ERROR_SUCCESS) {
                        userName = encodedUserName;
                        userNameLength = encodedUserNameLength;
                    }
                }
                
            } else {

                //
                // BUGBUG - if ICU_USERNAME then we get the value from the registry
                //

                userNameLength = 0;
            }
        }

        //
        // doesn't have to be a password
        //

        if (error == ERROR_SUCCESS) {
            password = lpUrlComponents->lpszPassword;
            if (password != NULL) {
                passwordLength = lpUrlComponents->dwPasswordLength;
                if (passwordLength == 0) {
                    passwordLength = lstrlen(password);
                }
                // Windows Bugs 625684
                // encode hostname if ICU_ESCAPE_AUTHORITY is set
                if (dwFlags & ICU_ESCAPE_AUTHORITY) {
                    encodedPasswordLength = INTERNET_MAX_PASSWORD_LENGTH + 1;
                    error = EncodeAuthorityComponent(
                                          password,
                                          passwordLength,
                                          encodedPassword,
                                          &encodedPasswordLength
                                          );
                    if (error == ERROR_SUCCESS) {
                        password = encodedPassword;
                        passwordLength = encodedPasswordLength;
                    }
                }
            } else {

                //
                // BUGBUG - if ICU_USERNAME then we get the value from the registry
                //

                passwordLength = 0;
            }
        }
        
        //
        // but if there's a password without a user name, then its an error
        //

        if (error == ERROR_SUCCESS) {
            
            if (password && !userName) {
                error = ERROR_INVALID_PARAMETER;
            } else {


                //
                // doesn't have to be an URL-path. Empty string is default
                //

                urlPath = lpUrlComponents->lpszUrlPath;
                if (urlPath != NULL) {
                    urlPathLength = lpUrlComponents->dwUrlPathLength;
                    if (urlPathLength == 0) {
                        urlPathLength = lstrlen(urlPath);
                    }
                    if ((*urlPath != '/') && (*urlPath != '\\')) {
                        extraLength = 1;
                    } else {
                        extraLength = 0;
                    }

                    //
                    // if requested, we will encode the URL-path
                    //

                    if (dwFlags & ICU_ESCAPE) {

                        //
                        // only encode the URL-path if it's a recognized scheme
                        //

                        if (schemeFlags != 0) {
                            encodedUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
                            error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                                                  schemeFlags,
                                                  urlPath,
                                                  urlPathLength,
                                                  encodedUrlPath,
                                                  &encodedUrlPathLength
                                                  );
                            if (error == ERROR_SUCCESS) {
                                urlPath = encodedUrlPath;
                                urlPathLength = encodedUrlPathLength;
                            }
                        }
                    }
                } else {
                    urlPathLength = 0;
                    extraLength = 0;
                }

                //
                // handle extra info if present
                //

                if (error == ERROR_SUCCESS) {
                    extraInfo = lpUrlComponents->lpszExtraInfo;
                    if (extraInfo != NULL) {
                        extraInfoLength = lpUrlComponents->dwExtraInfoLength;
                        if (extraInfoLength == 0) {
                            extraInfoLength = lstrlen(extraInfo);
                        }

                        //
                        // if requested, we will encode the extra info
                        //

                        if (dwFlags & ICU_ESCAPE) {

                            //
                            // only encode the extra info if it's a recognized scheme
                            //

                            if (schemeFlags != 0) {
                                encodedExtraInfoLength = INTERNET_MAX_URL_LENGTH + 1;
                                error = EncodeUrlPath(0,
                                                      schemeFlags,
                                                      extraInfo,
                                                      extraInfoLength,
                                                      encodedExtraInfo,
                                                      &encodedExtraInfoLength
                                                      );
                                if (error == ERROR_SUCCESS) {
                                    extraInfo = encodedExtraInfo;
                                    extraInfoLength = encodedExtraInfoLength;
                                }
                            }
                        }
                    } else {
                        extraInfoLength = 0;
                    }
                }

                DWORD requiredSize;

                if (error == ERROR_SUCCESS) {

                    //
                    // Determine if we have a protocol scheme that requires slashes
                    //

                    if (DoesSchemeRequireSlashes(schemeName, schemeNameLength, (hostName != NULL))
                    || ((schemeType == INTERNET_SCHEME_NEWS)
                    && urlPath
                    && (strchr(urlPath, '/') || strchr(urlPath, '\\')))) {
                        schemeSep = "://";
                        schemeSepLength = sizeof("://") - 1;
                    } else {
                        schemeSep = ":";
                        schemeSepLength = sizeof(":") - 1;
                    }

                    //
                    // ensure we have enough buffer space
                    //

                    requiredSize = schemeNameLength
                                 + schemeSepLength
                                 + hostNameLength
                                 + portLength
                                 + (userName ? userNameLength + 1 : 0) // +1 for '@'
                                 + (password ? passwordLength + 1 : 0) // +1 for ':'
                                 + urlPathLength
                                 + extraLength
                                 + extraInfoLength
                                 + 1                                // +1 for '\0'
                                 ;

                    //
                    // if there is enough buffer, copy the URL
                    //

                    if (*lpdwUrlLength >= requiredSize) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)schemeName, schemeNameLength);
                        lpszUrl += schemeNameLength;
                        memcpy((LPVOID)lpszUrl, (LPVOID)schemeSep, schemeSepLength);
                        lpszUrl += schemeSepLength;
                        if (userName) {
                            memcpy((LPVOID)lpszUrl, (LPVOID)userName, userNameLength);
                            lpszUrl += userNameLength;
                            if (password) {
                                *lpszUrl++ = ':';
                                memcpy((LPVOID)lpszUrl, (LPVOID)password, passwordLength);
                                lpszUrl += passwordLength;
                            }
                            *lpszUrl++ = '@';
                        }
                        if (hostName) {
                            memcpy((LPVOID)lpszUrl, (LPVOID)hostName, hostNameLength);
                            lpszUrl += hostNameLength;

                            // We won't attach a port unless there's a host to go with it.
                            if (portLength) {
                                lpszUrl += wsprintf(lpszUrl, ":%d", nPort & 0xffff);
                            }

                        }
                        if (urlPath) {

                            //
                            // Only do extraLength if we've actually copied something
                            // after the scheme.  Also, don't copy slash if it's
                            // mailto:
                            //

                            if (extraLength != 0 && (userName || hostName || portLength) &&
                                schemeType != INTERNET_SCHEME_MAILTO) {
                                *lpszUrl++ = '/';
                            } else if (extraLength != 0) {
                                --requiredSize;
                            }
                            memcpy((LPVOID)lpszUrl, (LPVOID)urlPath, urlPathLength);
                            lpszUrl += urlPathLength;
                        } else if (extraLength != 0) {
                            --requiredSize;
                        }
                        if (extraInfo) {
                            memcpy((LPVOID)lpszUrl, (LPVOID)extraInfo, extraInfoLength);
                            lpszUrl += extraInfoLength;
                        }

                        //
                        // terminate string
                        //

                        *lpszUrl = '\0';

                        //
                        // -1 for terminating '\0'
                        //

                        --requiredSize;
                    } else {

                        //
                        // not enough buffer space - just return the required buffer length
                        //

                        error = ERROR_INSUFFICIENT_BUFFER;
                    }
                }

                //
                // update returned parameters
                //

                *lpdwUrlLength = requiredSize;
            }
        }
        
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
quit:

    //
    // clear up the buffers we allocated
    //
    if (encodedUserName != NULL) {
        FREE_MEMORY(encodedUserName);
    }
    if (encodedPassword != NULL) {
        FREE_MEMORY(encodedPassword);
    }
    if (encodedHostName != NULL) {
        FREE_MEMORY(encodedHostName);
    }
    if (encodedUrlPath != NULL) {
        FREE_MEMORY(encodedUrlPath);
    }
    if (encodedExtraInfo != NULL) {
        FREE_MEMORY(encodedExtraInfo);
    }

    BOOL success = (error==ERROR_SUCCESS);

    if (success) {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("URL = %q\n",
                        lpszUrlOriginal
                        ));
    } else {

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}

//
//  ICUHrToWin32Error() is specifically for converting the return codes for
//  Url* APIs in shlwapi into win32 errors.
//  WARNING:  it should not be used for any other purpose.
//
DWORD
ICUHrToWin32Error(HRESULT hr)
{
    DWORD err = ERROR_INVALID_PARAMETER;
    switch(hr)
    {
    case E_OUTOFMEMORY:
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case E_POINTER:
        err = ERROR_INSUFFICIENT_BUFFER;
        break;

    case S_OK:
        err = ERROR_SUCCESS;
        break;

    default:
        break;
    }
    return err;
}



INTERNETAPI_(BOOL) InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszUrl             - pointer to URL to be canonicalize
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlA",
                     "%q, %#x, %#x [%d], %#x",
                     lpszUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet = TRUE;;

    INET_ASSERT(lpszUrl);
    INET_ASSERT(lpszBuffer);
    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszUrl || !lpszBuffer || !lpdwBufferLength || *lpdwBufferLength == 0 || IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeA(lpszUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}


INTERNETAPI_(BOOL) InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszBaseUrl         - pointer to base URL
    lpszRelativeUrl     - pointer to relative URL
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCombineUrlA",
                     "%q, %q, %#x, %#x [%d], %#x",
                     lpszBaseUrl,
                     lpszRelativeUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

    INET_ASSERT(lpszBaseUrl);
    INET_ASSERT(lpszRelativeUrl);
    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszBaseUrl || !lpszRelativeUrl || !lpdwBufferLength || (lpszBuffer && IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA(lpszBaseUrl, lpszRelativeUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    IF_DEBUG_CODE() {
        if (bRet) {
            DEBUG_PRINT_API(API,
                            INFO,
                            ("URL = %q\n",
                            lpszBuffer
                            ));
        }
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}



INTERNETAPI_(HINTERNET) InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Opens a root Internet handle from which all HINTERNET objects are derived

Arguments:

    lpszAgent       - name of the application making the request (arbitrary
                      identifying string). Used in "User-Agent" header when
                      communicating with HTTP servers, if the application does
                      not add a User-Agent header of its own

    dwAccessType    - type of access required. Can be

                        INTERNET_OPEN_TYPE_PRECONFIG
                            - Gets the configuration from the registry

                        INTERNET_OPEN_TYPE_DIRECT
                            - Requests are made directly to the nominated server

                        INTERNET_OPEN_TYPE_PROXY
                            - Requests are made via the nominated proxy

                        INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
                            - Like Pre-Config, but prevents JavaScript, INS
                                and other auto-proxy types from being used.

    lpszProxy       - if INTERNET_OPEN_TYPE_PROXY, a list of proxy servers to
                      use

    lpszProxyBypass - if INTERNET_OPEN_TYPE_PROXY, a list of servers which we
                      will communicate with directly

    dwFlags         - flags to control the operation of this API or potentially
                      all APIs called on the handle generated by this API.
                      Currently supported are:

                        INTERNET_FLAG_ASYNC
                            - if specified then all subsequent API calls made
                              against the handle returned from this API, or
                              handles descended from the handle returned by
                              this API, have the opportunity to complete
                              asynchronously, depending on other factors
                              relevant at the time the API is called

Return Value:

    HINTERNET
        Success - handle of Internet object

        Failure - NULL. For more information, call GetLastError()

--*/

{
    PERF_INIT();

    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenA",
                     "%q, %s (%d), %q, %q, %#x",
                     lpszAgent,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     lpszProxy,
                     lpszProxyBypass,
                     dwFlags
                     ));

    DWORD error;
    HINTERNET hInternet = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // we are doing GetUserName here instead of in DLL_PROCESS_ATTACH
    // As every caller of wininet has to do this first, we ensure
    // that the username is initialized when they get to actually doing
    // any real operation
    //

    GetWininetUserName();

    //
    // validate parameters
    //

    if (!
         (
              (dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
           || (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY)
           || (
                (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                &&
                    (
                       !ARGUMENT_PRESENT(lpszProxy)
                    || (*lpszProxy == '\0')

                    )
              )
           || (dwFlags & ~INTERNET_FLAGS_MASK)
         )
       )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    GlobalHaveInternetOpened = TRUE;

    //
    // Initalize an auto proxy dll if needed,
    //  as long as the caller is allowing us free rein to do this
    //  by calling us with INTERNET_OPEN_TYPE_PRECONFIG.
    //

    //if ( dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG )
    //{
    //    if ( ! InitalizeAutoConfigDllIfNeeded() )
    //  {
    //      error = GetLastError();
    //
    //      INET_ASSERT(error != ERROR_SUCCESS);
    //
    //      goto quit;
    //  }
    //
    //


    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = new INTERNET_HANDLE_OBJECT(lpszAgent,
                                            dwAccessType,
                                            (LPSTR)lpszProxy,
                                            (LPSTR)lpszProxyBypass,
                                            dwFlags
                                            );
    if (lpInternet == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    error = lpInternet->GetStatus();
    if (error == ERROR_SUCCESS) {
        hInternet = (HINTERNET)lpInternet;

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();

        //
        // start async support now if required. If we can't start it, we'll get
        // another chance the next time we create an async request
        //

        if (dwFlags & INTERNET_FLAG_ASYNC) {
            InitializeAsyncSupport();
        }
    } else {

        //
        // hack fix to stop InternetIndicateStatus (called from the handle
        // object destructor) blowing up if there is no handle object in the
        // thread info block. We can't call back anyway
        //

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        if (lpThreadInfo) {

            //
            // BUGBUG - incorrect handle value
            //

            _InternetSetObjectHandle(lpThreadInfo, lpInternet, lpInternet);
        }

        //
        // we failed during initialization. Kill the handle using Dereference()
        // (in order to stop the debug version complaining about the reference
        // count not being 0. Invalidate for same reason)
        //

        lpInternet->Invalidate();
        lpInternet->Dereference();

        INET_ASSERT(hInternet == NULL);

    }

quit:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE_API(hInternet);

    return hInternet;
}


INTERNETAPI_(BOOL) InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes any open internet handle object

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCloseHandle",
                     "%#x",
                     hInternet
                     ));

    PERF_ENTER(InternetCloseHandle);

    DWORD error;
    BOOL success = FALSE;
    HINTERNET hInternetMapped = NULL;
    static DWORD ticks = GetTickCountWrap();

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // map the handle. Don't invalidate it (_InternetCloseHandle() does this)
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped == NULL) {

            //
            // the handle never existed or has been completely destroyed
            //

            DEBUG_PRINT(API,
                        ERROR,
                        ("Handle %#x is invalid\n",
                        hInternet
                        ));

            //
            // catch invalid handles - may help caller
            //

            DEBUG_BREAK(INVALID_HANDLES);

        } else {

            //
            // this handle is already being closed (it's invalidated). We only
            // need one InternetCloseHandle() operation to invalidate the handle.
            // All other threads will simply dereference the handle, and
            // eventually it will be destroyed
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }
        goto quit;
    }

    //
    // the handle is not invalidated
    //

    HANDLE_OBJECT * pHandle;

    pHandle = (HANDLE_OBJECT *)hInternetMapped;

    if ( ! ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->IsAsyncHandle() )
    {
        if ((GetTickCountWrap() - ticks) >= 5000)
        {
            PurgeServerInfoList(FALSE);

            InterlockedExchange((LPLONG) &ticks, (LONG) GetTickCountWrap());
        }
    }

    DEBUG_PRINT(INET,
                INFO,
                ("handle %#x == %#x == %s\n",
                hInternet,
                hInternetMapped,
                InternetMapHandleType(pHandle->GetHandleType())
                ));

    //
    // if this is an http request handle, notify all filters.
    //

    if (pHandle->GetHandleType() == TypeHttpRequestHandle) {
        HttpFiltOnTransactionComplete (hInternet);
    }

    //
    // if this is a delete-parent-with-child subtree then find the root node
    //

    while (pHandle->GetDeleteWithChild()) {

        HINTERNET handleObject;

        handleObject = pHandle->GetParent();

        INET_ASSERT(handleObject != NULL);

        //
        // remove the delete-parent-with-child indication, or we'll get stuck
        // in a loop
        //

        pHandle->SetParent(handleObject, FALSE);

        //
        // if the parent handle is an EXISTING_CONNECT connect handle then we
        // just mark it unused & close the current handle
        //

        HINTERNET_HANDLE_TYPE handleType;

        handleType = ((HANDLE_OBJECT *)handleObject)->GetHandleType();
        if ((handleType == TypeFtpConnectHandle)
        || (handleType == TypeGopherConnectHandle)
        || (handleType == TypeHttpConnectHandle)) {

            INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

            pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)handleObject;

            //
            // SetUnused() will only operate on a connect handle object that
            // has been created with INTERNET_FLAG_EXISTING_CONNECT
            //

            if (pConnect->SetUnused()) {

                //
                // only handle type should be FTP connect handle for now
                //

                INET_ASSERT(handleType == TypeFtpConnectHandle);

                DEBUG_PRINT(INET,
                            INFO,
                            ("caching unused %s connect handle object %#x. RefCount = %d\n",
                            (handleType == TypeFtpConnectHandle)
                                ? "FTP"
                                : (handleType == TypeGopherConnectHandle)
                                    ? "Gopher"
                                    : "HTTP",
                            ((HANDLE_OBJECT *)handleObject)->GetPseudoHandle(),
                            ((HANDLE_OBJECT *)handleObject)->ReferenceCount()
                            ));
                break;
            }
        }
        pHandle = (HANDLE_OBJECT *)handleObject;
        hInternet = pHandle->GetPseudoHandle();
    }

    //
    // close all child handles first
    //

    while (pHandle->HaveChildren()) {

        //
        // we'll fall out at the first error we get. It *should* mean that this
        // handle (and its descendents) is already being closed
        //

        if (!InternetCloseHandle(pHandle->NextChild())) {
            break;
        }
    }

    //
    // clear the handle object last error variables
    //

    InternetClearLastError();


    //
    // remove the reference added by MapHandleToAddress(), or the handle won't
    // be destroyed by _InternetCloseHandle()
    //

    DereferenceObject((LPVOID)hInternetMapped);

    //
    // use _InternetCloseHandle() to do the work
    //

    success = _InternetCloseHandle(hInternet);

quit:

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(InternetCloseHandle);

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as InternetCloseHandle() except does not clear out the last error text.
    Mainly for FTP

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    BOOL success;
    HINTERNET hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        if (InDllCleanup) {
            error = ERROR_INTERNET_SHUTDOWN;
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // we need the parent handle - we will set this as the handle object being
    // processed by this thread. This is required for async worker threads (see
    // below)
    //

    HINTERNET hParent;
    HINTERNET hParentMapped;
    DWORD_PTR dwParentContext;

    hParentMapped = ((HANDLE_OBJECT *)hInternetMapped)->GetParent();
    if (hParentMapped != NULL) {
        hParent = ((HANDLE_OBJECT *)hParentMapped)->GetPseudoHandle();
        dwParentContext = ((HANDLE_OBJECT *)hParentMapped)->GetContext();
    }

    //
    // set the object handle and context in the per-thread data structure
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->GetContext()
                        );

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

    //
    // now set the object to be the parent. This is necessary for e.g.
    // FtpGetFile() and async requests (where the async worker thread will make
    // an extra callback to deliver the results of the async request)
    //

    if (hParentMapped != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hParent, hParentMapped);
        if (dwParentContext != 0) {
            _InternetSetContext(lpThreadInfo, dwParentContext);
        }
    }

    if (g_bHibernating)
    {
        InterruptSelect();
    }
    //
    // if the handle was still alive after dereferencing it then we will inform
    // the app that the close is pending
    //

quit:

    //
    // if the handle is still alive then we return success - it is invalidated
    // and will be deleted as soon as possible
    //

    if (error == ERROR_INTERNET_HANDLE_EXISTS) {
        error = ERROR_SUCCESS;
    }
    success = (error==ERROR_SUCCESS);
    if (!success) {
        SetLastError(error);
        DEBUG_ERROR(INET, error);
    }
    DEBUG_LEAVE(success);
    return success;
}


DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as _InternetCloseHandle() except does not change the per-thread info
    structure handle/context values

    BUGBUG - This should be handled via a parameter to _InternetCloseHandle(),
             but its close to shipping...

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandleNoContext",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    HINTERNET hInternetMapped = NULL;

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

quit:

    //
    // if the handle is still alive then we return success - it is invalidated
    // and will be deleted as soon as possible
    //

    if (error == ERROR_INTERNET_HANDLE_EXISTS) {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetGetCertByURLA(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
/*++

Routine Description:

    Does a high-level lookup against the Certificate Cache.
    Searches by URL (broken down into hostname) for the Certificate,
    and returns it in a formatted (&localized) string.

Arguments:

    lpszUrl         - pointer to URL to crack

    lpszCertText    - Output of formatted certifcate

    dwcbCertText    - Size of lpszCertText

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{

    BOOL fSuccess = FALSE;

/*    LPSTR lpszHostName;
    DWORD dwcbHostName;
    INTERNET_CERTIFICATE_INFO cInfo;
    CHAR chBackup;
    DWORD error = ERROR_SUCCESS;

    ZeroMemory(&cInfo, sizeof(INTERNET_CERTIFICATE_INFO));

    error = CrackUrl(lpszURL,
             lstrlen(lpszURL),
             FALSE,
             NULL,          //  Scheme Type
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             &lpszHostName, //  Host Name
             &dwcbHostName, //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra Info
             NULL,          //  Extra Info Length
             NULL
             );


    if ( error != ERROR_SUCCESS)
        goto quit;

    chBackup = lpszHostName[dwcbHostName];
    lpszHostName[dwcbHostName] = '\0';

    fSuccess = GlobalCertCache.GetCert(
                    lpszHostName,
                    &cInfo
                    );


    lpszHostName[dwcbHostName] = chBackup;

    if ( ! fSuccess )
    {
        error = ERROR_INTERNET_INVALID_OPERATION;
        goto quit;
    }

    LPSTR szResult;

    szResult = FormatCertInfo(&cInfo);

    if ( ! szResult )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    DWORD dwcbResult;

    dwcbResult = lstrlen(szResult);

    if ( dwcbCertText < (dwcbResult+1) )
    {
        error = ERROR_INSUFFICIENT_BUFFER;
        goto quit;
    }

    memcpy(
        lpszCertText,
        szResult,
        (dwcbResult + 1) * sizeof(TCHAR));


quit:

    if (NULL != szResult) {
        FREE_MEMORY(szResult);
    }
    if (NULL != cInfo.lpszSubjectInfo) {
        FREE_MEMORY(cInfo.lpszSubjectInfo);
    }
    if (NULL != cInfo.lpszIssuerInfo) {
        FREE_MEMORY(cInfo.lpszIssuerInfo);
    }
    if (NULL != cInfo.lpszSignatureAlgName) {
        FREE_MEMORY(cInfo.lpszSignatureAlgName);
    }
    if (NULL != cInfo.lpszEncryptionAlgName) {
        FREE_MEMORY(cInfo.lpszEncryptionAlgName);
    }
    if (NULL != cInfo.lpszProtocolName) {
        FREE_MEMORY(cInfo.lpszProtocolName);
    }

    fSuccess = TRUE;

    if ( error != ERROR_SUCCESS )
    {
        fSuccess = FALSE;
        SetLastError(error);
    }*/

    return fSuccess;

}


INTERNETAPI_(BOOL) InternetShowSecurityInfoByURLA(
    IN LPSTR     lpszURL,
    IN HWND      hwndRootWindow
    )
/*++

Routine Description:

    Does a high-level lookup against the Certificate Cache.
    Searches by URL (broken down into hostname) for the Certificate,
    and returns it in a formatted (&localized) string.

Arguments:

    lpszUrl         - pointer to URL to crack

    lpszCertText    - Output of formatted certifcate

    dwcbCertText    - Size of lpszCertText

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_INET,
                 Bool,
                 "InternetShowSecurityInfoA",
                 "%q %#x",
                 lpszURL,
                 hwndRootWindow
                 ));

    LPSTR lpszHostName;
    DWORD dwcbHostName;
    INTERNET_SECURITY_INFO cInfo;
    CHAR chBackup;
    DWORD dwFlags;
    DWORD error = ERROR_SUCCESS;
    WCHAR   szTitle[MAX_PATH];
    WCHAR   szMessage[MAX_PATH];
    INTERNET_SCHEME ustSchemeType;
    BOOL fResult = FALSE;

    if (!GlobalDataInitialized) {
        if (GlobalDataInitialize() != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }

    ZeroMemory(&cInfo, sizeof(INTERNET_SECURITY_INFO));

    error = CrackUrl(lpszURL,
             lstrlen(lpszURL),
             FALSE,
             &ustSchemeType,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             &lpszHostName, //  Host Name
             &dwcbHostName, //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra Info
             NULL,          //  Extra Info Length
             NULL
             );


    if ( error != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if ( ustSchemeType != INTERNET_SCHEME_HTTPS )
    {
        goto Cleanup;
    }

    if ( lpszHostName == NULL || dwcbHostName == 0 )
    {
        fResult = TRUE;
        goto done;
    }


    chBackup = lpszHostName[dwcbHostName];
    lpszHostName[dwcbHostName] = '\0';
    SECURITY_CACHE_LIST_ENTRY *pEntry;
    pEntry = GlobalCertCache.Find(lpszHostName);

    lpszHostName[dwcbHostName] = chBackup;

    if(pEntry)
    {
        pEntry->CopyOut(cInfo);
        pEntry->Release();
        ShowSecurityInfo(hwndRootWindow,
                         &cInfo);
        CertFreeCertificateContext(cInfo.pCertificate);
        fResult = TRUE;
        goto done;
    }

Cleanup:
    // No certificate info, display messagebox.
    LoadStringWrapW(
            GlobalDllHandle,
            IDS_NOCERT_TITLE,
            szTitle,
            sizeof(szTitle) / sizeof(szTitle[0]));

    LoadStringWrapW(
            GlobalDllHandle,
            IDS_NOCERT,
            szMessage,
            sizeof(szMessage) / sizeof(szMessage[0]));

     MessageBoxWrapW(hwndRootWindow,
         szMessage,
         szTitle,
         MB_ICONINFORMATION | MB_OK);

done:
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(HINTERNET) InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a connection with a server, logging-on the user in the process.

Arguments:

    hInternet       - Internet handle, returned by InternetOpen()

    lpszServerName  - name of server with which to connect

    nServerPort     - port at which server listens

    lpszUserName    - name of current user

    lpszPassword    - password of current user

    dwService       - service required. Controls type of handle generated.
                      May be one of:
                        - INTERNET_SERVICE_FTP
                        - INTERNET_SERVICE_GOPHER
                        - INTERNET_SERVICE_HTTP

    dwFlags         - protocol-specific flags. The following are defined:
                        - INTERNET_FLAG_PASSIVE (FTP)
                        - INTERNET_FLAG_KEEP_CONNECTION (HTTP)
                        - INTERNET_FLAG_SECURE (HTTP)

    dwContext       - application-supplied value used to identify this
                      request in callbacks

Return Value:

    HINTERNET
        Success - address of a new handle object

        Failure - NULL. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetConnectA",
                     "%#x, %q, %d, %q, %q, %s (%d), %#08x, %#x",
                     hInternet,
                     lpszServerName,
                     nServerPort,
                     lpszUserName,
                     lpszPassword,
                     InternetMapService(dwService),
                     dwService,
                     dwFlags,
                     dwContext
                     ));

    char emailName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    char proxyBuf[INTERNET_MAX_HOST_NAME_LENGTH + 1];

    HINTERNET connectHandle = NULL;
    HINTERNET hInternetMapped = NULL;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;

    BOOL fUseProxy = FALSE;

    LPSTR serverName = NULL;
    LPSTR userName = (LPSTR)lpszUserName;
    LPSTR password = (LPSTR)lpszPassword;
    LPSTR realServerName = (LPSTR)lpszServerName;
    LPSTR realUserName = (LPSTR)lpszUserName;

    BOOL existingConnection = FALSE;
    BOOL viaProxy = FALSE;

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect = NULL;
    //CServerInfo * lpServerInfo;

    BOOL bProtocolLevel = !(dwFlags & INTERNET_FLAG_OFFLINE);
    BOOL bIsWorker = FALSE;
    BOOL bNonNestedAsync = FALSE;
    BOOL isLocal;
    BOOL isAsync;
    BOOL bFTPSetPerUserItem = FALSE;

    DWORD error = ERROR_SUCCESS;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    bIsWorker = lpThreadInfo->IsAsyncWorkerThread;
    bNonNestedAsync = bIsWorker && (lpThreadInfo->NestedRequests == 1);

    //
    // handle any global proxy settings changes first
    //

    if (InternetSettingsChanged()) {
        ChangeGlobalSettings();
    }

    //
    // handle/refcount munging:
    //
    //  sync:
    //      map hInternet on input (+1 ref)
    //      generate connect handle (1 ref)
    //      if failure && !connect handle
    //          close connect handle (0 refs: delete)
    //      if success
    //          deref hInternet (-1 ref)
    //      else if going async
    //          ref connect handle (2 refs)
    //
    //  async:
    //      hInternet is mapped connect handle (2 refs)
    //      get real hInternet from connect handle parent (2 refs (e.g.))
    //      deref connect handle (1 ref)
    //      if failure
    //          close connect handle (0 refs: delete)
    //      deref open handle (-1 ref)
    //
    // N.B. the final deref of the *indicated* handle on async callback will
    // happen in the async code
    //

    if (bNonNestedAsync) {
        connectHandle = hInternet;
        hInternetMapped = ((HANDLE_OBJECT *)connectHandle)->GetParent();
        hInternet = ((HANDLE_OBJECT *)hInternetMapped)->GetPseudoHandle();
    } else {
        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
            goto quit;
        }

        //
        // set the info context and clear the last error info
        //

        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
        _InternetClearLastError(lpThreadInfo);
        _InternetSetContext(lpThreadInfo, dwContext);

        //
        // quit now if the handle object is invalidated
        //

        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // validate the handle & discover local/remote & sync/async
        //

        error = RIsHandleLocal(hInternetMapped,
                               &isLocal,
                               &isAsync,
                               TypeInternetHandle
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // we allow all valid flags to be passed in
        //

        if ((dwFlags & ~INTERNET_FLAGS_MASK)
            || (lpszServerName == NULL)
            || (*lpszServerName == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    INTERNET_SCHEME schemeType;

    switch (dwService) {
    case INTERNET_SERVICE_FTP:
        schemeType = INTERNET_SCHEME_FTP;
        break;

    case INTERNET_SERVICE_HTTP:
        schemeType = (dwFlags & INTERNET_FLAG_SECURE)
                        ? INTERNET_SCHEME_HTTPS
                        : INTERNET_SCHEME_HTTP;
        break;

    case INTERNET_SERVICE_GOPHER:   // disable gopher by default
        if (GlobalEnableGopher) {
            schemeType = INTERNET_SCHEME_GOPHER;
            break;
        }

    default:
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // validate arguments if we're not in the async thread context, in which
    // case we did this when the original request was made
    //

    if (bNonNestedAsync) {
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
        goto sync_path;
    }

    //
    // app thread or in async worker thread but being called from another
    // async API, such as InternetOpenUrl()
    //

    //
    // special case: if the server name is the NULL pointer or empty string, and
    // the port is 0 AND we have a proxy configured for this protocol then the
    // app is asking to connect directly to the proxy (the proxy server itself
    // had better be in the bypass list!)
    //
    // BUGBUG - not sure if this is really where we want to do this
    //

    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = (INTERNET_HANDLE_OBJECT * )hInternetMapped;

    //
    // if the port value is 0 convert it to the default port for the
    // protocol
    //

    if (nServerPort == INTERNET_INVALID_PORT_NUMBER) {
        switch (dwService) {
        case INTERNET_SERVICE_FTP:
            nServerPort = INTERNET_DEFAULT_FTP_PORT;
            break;

        case INTERNET_SERVICE_GOPHER:
            nServerPort = INTERNET_DEFAULT_GOPHER_PORT;
            break;

        case INTERNET_SERVICE_HTTP:
            if (dwFlags & INTERNET_FLAG_SECURE) {
                nServerPort = INTERNET_DEFAULT_HTTPS_PORT;
            } else {
                nServerPort = INTERNET_DEFAULT_HTTP_PORT;
            }
            break;
        }
    }

    //
    // if we have been given a net (i.e. IP) address, try to convert it to the
    // corresponding host name
    //

    //if (IsNetAddress((LPSTR)lpszServerName)) {
        //lpszServerName = (LPCSTR)MapNetAddressToName((LPSTR)lpszServerName);
        realServerName = (LPSTR)lpszServerName;
    //}

    //
    // we need to get the username and password for the current user before we
    // make the connection proper. The reason for this is that if we leave it
    // to the server, it will end up with a username of "SYSTEM" for all
    // anonymous FTP connects
    //

    if (dwService == INTERNET_SERVICE_FTP) {

        //
        // Make sure we have the correct Proxy-Network Settings, at this point.
        //

        InternetAutodialIfNotLocalHost(NULL, (LPSTR) lpszServerName);

        //
        // check the user name & password. If NULLs were supplied, use the values
        // from the registry
        //

        //
        // Do we need to set this item as per user? If a username was supplied (
        // either cracked from the URL or set on the handle, userName will be
        // non-null. Currently, this is the only criteria for when we set pu.
        //
        // Need to check this BEFORE calling GetEmailNameAndPassword which will
        // plugin "anonymous" if no username provided.
        //

        bFTPSetPerUserItem = userName ? TRUE : FALSE;
        DEBUG_PRINT(FTP,
                    INFO,
                    ("InternetConnectA:FTP: bFTPSetPerUserItem = %d\n",
                    bFTPSetPerUserItem
                    ));

        error = GetEmailNameAndPassword(&userName,
                                        &password,
                                        emailName,
                                        sizeof(emailName)
                                        );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this is the user name we will use for the object, i.e. either the
        // name supplied, or "anonymous" as mapped above
        //

        realUserName = userName;

        //
        // if this request is going via an FTP proxy, then convert the parameters
        // now. We convert the username to <username>@<servername>, the password
        // remains the same, and the server name & port become the proxy server
        // name and port
        //
        // N.B. We ONLY do this once on the initial (synchronous) path
        //

        AUTO_PROXY_ASYNC_MSG proxyInfoQuery(
            INTERNET_SCHEME_FTP,
            (LPSTR)lpszServerName,
            lstrlen((LPSTR)lpszServerName)
            );

        AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery;

        pProxyInfoQuery = &proxyInfoQuery;


        proxyInfoQuery.SetAvoidAsyncCall(TRUE);

        error = lpInternet->GetProxyInfo(
                    &pProxyInfoQuery
                    );

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }

        if ( proxyInfoQuery.IsUseProxy() )
        {
            if (proxyInfoQuery.GetProxyScheme() == INTERNET_SCHEME_FTP)
            {

                int ulen = lstrlen(userName);
                int slen = lstrlen(lpszServerName);

                INET_ASSERT((ulen + slen) < (sizeof(proxyBuf) - 1));

                if ((ulen + slen) < (sizeof(proxyBuf) - 1))
                {
                    memcpy(proxyBuf, userName, ulen);
                    proxyBuf[ulen++] = '@';
                    memcpy(&proxyBuf[ulen], lpszServerName, slen + 1);

                    //
                    // keep a pointer to the real user name for when we
                    // create the object
                    //

                    realUserName = userName;
                    userName = proxyBuf;

                    //
                    // create a copy of the proxy name. We have to do
                    // this in case the current proxy list is replaced
                    // while we are using this string
                    //

                    //
                    // N.B. we can't be here if we determined that the
                    // proxy server was the destination (i.e. we mapped2
                    // the empty server name above)
                    //

                    INET_ASSERT(serverName == NULL);

                    serverName = NewString((LPCSTR)proxyInfoQuery._lpszProxyHostName);

                    if ( serverName == NULL )
                    {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }

                    //
                    // keep a pointer to the real (origin) server name
                    // for when we create the object
                    //

                    realServerName = (LPSTR)lpszServerName;
                    lpszServerName = serverName;

                    //
                    // BUGBUG - what if proxyPort != nServerPort? Where
                    //          should the port go (user@server:port?)
                    //

                    nServerPort = proxyInfoQuery._nProxyHostPort;

                    //
                    // this request will go via proxy
                    //

                    viaProxy = TRUE;

                }
                else
                {

                    //
                    // blew internal limit
                    //

                    error = ERROR_INTERNET_INTERNAL_ERROR;
                    goto quit;
                }
            }
        }

    }
    else
    {
        if (userName != NULL) {
            if (IsBadStringPtr(userName, INTERNET_MAX_USER_NAME_LENGTH)) {
                error = ERROR_INVALID_PARAMETER;
                goto quit;
            } else if (*userName == '\0') {
                userName = NULL;
            }
        }
        if (password != NULL) {
            if (IsBadStringPtr(password, INTERNET_MAX_PASSWORD_LENGTH)) {
                error = ERROR_INVALID_PASSWORD;
                goto quit;
            } else if (*password == '\0') {
                password = NULL;
            }
        }
    }

    //
    // find the handle object if EXISTING_CONNECT AND we are creating protocol-
    // level connections, else create it
    //

    INET_ASSERT(connectHandle == NULL);
    INET_ASSERT(error == ERROR_SUCCESS);

    if ((dwFlags & INTERNET_FLAG_EXISTING_CONNECT) && bProtocolLevel) {
        connectHandle = FindExistingConnectObject(hInternet,
                                                  realServerName,
                                                  nServerPort,
                                                  realUserName,
                                                  password,
                                                  dwService,
                                                  dwFlags,
                                                  dwContext
                                                  );
    }
    if (connectHandle != NULL) {
        existingConnection = TRUE;
    } else {

        //
        // turn off INTERNET_FLAG_EXISTING_CONNECT if we are creating a cache
        // handle - we don't want the handle to hang around after we delete
        // the request handle (i.e. be set unused by InternetCloseHandle()).
        // N.B. We don't need this flag after this operation, so its safe to
        // remove it from dwFlags
        //

        if (!bProtocolLevel) {
            dwFlags &= ~INTERNET_FLAG_EXISTING_CONNECT;
        }
        error = RMakeInternetConnectObjectHandle(
                    hInternetMapped,
                    &connectHandle,
                    (CONNECT_CLOSE_HANDLE_FUNC)wInternetCloseConnectA,
                    realServerName, // origin server, not proxy
                    nServerPort,
                    realUserName,   // just user name, not user@server
                    password,
                    dwService,
                    dwFlags,
                    dwContext
                    );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // this new handle will be used in callbacks
    //

    _InternetSetObjectHandle(lpThreadInfo,
                             ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle(),
                             connectHandle
                             );

    //
    // based on whether we have been asked to perform async I/O AND we are not
    // in an async worker thread context AND the request is to connect with an
    // FTP service (currently only FTP because this request performs network
    // I/O - gopher and HTTP just allocate & fill in memory) AND there is a
    // valid context value, we will queue the async request, or execute the
    // request synchronously
    //

    //
    // BUGBUG - GetFlags()
    //

    if ((lpInternet->GetInternetOpenFlags() | dwFlags) & INTERNET_FLAG_OFFLINE) {
        error = ERROR_SUCCESS;
        goto quit;
    }

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    //lpServerInfo = pConnect->GetServerInfo();
    DEBUG_PRINT(FTP,
                INFO,
                ("bIsWorker = %d isAsync = %d dwContext %s INC dwService %s ISF bProtocolLevel = %d\n",
                bIsWorker,
                isAsync,
                (dwContext == INTERNET_NO_CALLBACK) ? "==":"!=",
                (dwService == INTERNET_SERVICE_FTP) ? "==":"!=",
                bProtocolLevel));

    if (!bIsWorker
        && isAsync
        && (dwContext != INTERNET_NO_CALLBACK)
        && ((dwService == INTERNET_SERVICE_FTP) ? bProtocolLevel : FALSE)) {

        // If we determined item should be set pu, do so now
        pConnect->SetPerUserItem(bFTPSetPerUserItem);
        DEBUG_PRINT(FTP,
                    INFO,
                    ("InternetConnectA:Async Path: SetPerUserItem to %\r\n\
                    <pConnect = 0x%x> <connectHandle = 0x%x>\r\n",
                    pConnect->IsPerUserItem(), pConnect, connectHandle));
        CFsm_FtpConnect * pFsm;

        pFsm = new CFsm_FtpConnect(lpszServerName,
                                   userName,
                                   password,
                                   nServerPort,
                                   dwService,
                                   dwFlags,
                                   dwContext
                                   );
        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            BOOL bDerefConnect = TRUE;

            error = pConnect->Reference();

            if (error == ERROR_ACCESS_DENIED)
            {
                bDerefConnect = FALSE;
            }
            else if (error == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if (error == ERROR_IO_PENDING) {
                    hInternetMapped = NULL;
                    bDerefConnect = FALSE;
                }
            }
            if (bDerefConnect) {
                pConnect->Dereference();
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

sync_path:

    if (bProtocolLevel && !existingConnection) {

        //
        // generate the protocol-level connect 'object' if required (for FTP).
        // This simply creates a memory object
        //

        HINTERNET protocolConnectHandle = NULL;

        INET_ASSERT(error == ERROR_SUCCESS);

        if (dwService == INTERNET_SERVICE_FTP) {
            error = wFtpConnect(lpszServerName,
                                nServerPort,
                                userName,
                                password,
                                dwService,
                                dwFlags,
                                &protocolConnectHandle
                                );
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }

        //
        // associate the protocol-level handle and INTERNET_CONNECT_HANDLE_OBJECT
        //

        pConnect->SetConnectHandle(protocolConnectHandle);

        // If we determined item should be set pu, do so now
        pConnect->SetPerUserItem(bFTPSetPerUserItem);
        DEBUG_PRINT(FTP,
                    INFO,
                    ("InternetConnectA:Sync Path:SetPerUserItem to %d\r\n\
                        <pConnect = 0x%x> <protocolConnectHandle = 0x%x> <connectHandle = 0x%x>\r\n",
                    pConnect->IsPerUserItem(), pConnect, protocolConnectHandle, connectHandle));


        // for all connect types, get the server info and resolve the server
        // name. If we can't resolve the name then we fail this request
        //

        //lpServerInfo = pConnect->GetServerInfo();
        //if ((lpServerInfo != NULL) && !lpServerInfo->IsNameResolved()) {
        //    error = pConnect->SetServerInfo(schemeType, FALSE, FALSE);
        //    if (error != ERROR_SUCCESS) {
        //        goto quit;
        //    }
        //}

        //
        // if we succeeded in creating the connect object and this is an FTP
        // request then we will now attempt to connect to the server proper.
        //
        // We don't need to do this for gopher and HTTP because (currently) they
        // don't make server connections until we perform some other action,
        // like find file, e.g.
        //

        if (dwService == INTERNET_SERVICE_FTP) {
            error = wFtpMakeConnection(protocolConnectHandle,
                                       userName,
                                       password
                                       );
        }
    }

quit:

    _InternetDecNestingCount(1);

    //
    // free the buffer we used to hold the proxy name if we had to map the
    // empty string to a proxy name
    //

    if (serverName != NULL) {
        DEL_STRING(serverName);
    }

done:

    if (error == ERROR_SUCCESS) {

        //
        // set the via proxy flag
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle)->SetViaProxy(viaProxy);

        //
        // success - return generated pseudo-handle
        //

        connectHandle = ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle();

        //
        // created a handle. If we are generating protocol-level connections
        // then flush the existing connection cache
        //

        if (bProtocolLevel) {
            FlushExistingConnectObjects(hInternet);
        }
    } else {
        if (bNonNestedAsync
            && (/*((HANDLE_OBJECT *)connectHandle)->Dereference()
                ||*/ ((HANDLE_OBJECT *)connectHandle)->IsInvalidated())) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (connectHandle != NULL)) {

            //
            // use _InternetCloseHandle() to close the handle: it doesn't clear
            // out the last error text, so that an app can find out what the
            // server sent us in the event of an FTP login failure
            //


            if (bNonNestedAsync) {

                //
                // this handle deref'd at async completion
                //

                hInternetMapped = NULL;
            }
            else
            {
                _InternetCloseHandle(((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle());
            }
        }
        connectHandle = NULL;
    }
    if (hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }
    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE_API(connectHandle);
    return connectHandle;
}



INTERNETAPI_(HINTERNET) InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens an URL. This consists of creating a handle to the type of item
    identified by the URL - directory or file

Arguments:

    hInternet       - root Internet handle

    lpszUrl         - pointer to the URL to use to open the item

    lpszHeaders     - headers to send to HTTP server. May be NULL

    dwHeadersLength - length of lpszHeaders. May be -1 if the app wants us to
                      perform the strlen()

    dwFlags         - open flags (cache/nocache, etc.)

    dwContext       - app-supplied context value for call-backs

Return Value:

    HINTERNET
        Success - open handle to item described by URL

        Failure - NULL. Use GetLastError() to get more information about why the
                  call failed. There may be error text returned from the server
                  (in the case of a gopher or FTP URL)

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenUrlA",
                     "%#x, %q, %.80q, %d, %#08x, %#x",
                     hInternet,
                     lpszUrl,
                     lpszHeaders,
                     dwHeadersLength,
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD error;
    DWORD nestingLevel = 0;
    HINTERNET hInternetMapped = NULL;
    HINTERNET hUrlMapped = NULL;
    HINTERNET hUrl = NULL;

    PROXY_STATE * pProxyState = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
        goto quit;
    }

    //
    // set the info context and clear the last error info
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    _InternetClearLastError(lpThreadInfo);
    _InternetSetContext(lpThreadInfo, dwContext);

    //
    // quit now if the handle object is invalidated
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle & discover async/sync & local/remote
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hInternetMapped,
                           &isLocal,
                           &isAsync,
                           TypeInternetHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters if we're not in the async worker thread context
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {

        //
        // ensure we have good values for the headers pointer and length
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        if (ARGUMENT_PRESENT(lpszHeaders) && (dwHeadersLength == -1)) {
            __try {
                dwHeadersLength = lstrlen(lpszHeaders);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                error = ERROR_INVALID_PARAMETER;
            }
            ENDEXCEPT
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        } else if (!ARGUMENT_PRESENT(lpszHeaders) || (dwHeadersLength == 0)) {
            lpszHeaders = NULL;
            dwHeadersLength = 0;
        }
        if (!ARGUMENT_PRESENT(lpszUrl)
        || (*lpszUrl == '\0')
//        || !IsValidUrl(lpszUrl)
        || (dwFlags & ~INTERNET_FLAGS_MASK)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // determine if this is a http request or FTP request - either http URL, or via http proxy.
    // or via another protocol.
    // For any Async request, we must go async in order to determine proxy information
    //

    bDeref = FALSE;
    hUrl = hInternet;

    if (isAsync
    && !lpThreadInfo->IsAsyncWorkerThread
    && (dwContext != INTERNET_NO_CALLBACK))
    {
        CFsm_ParseUrlForHttp *pFsm;

        pFsm = new CFsm_ParseUrlForHttp(&hUrl,
                                       (INTERNET_HANDLE_OBJECT *)hInternetMapped,
                                       lpszUrl,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwFlags,
                                       dwContext
                                       );

        if (pFsm != NULL) {
            // IE6 BUG #27905
            // check if ctor of CFsm_ParseUrlForHttp encountered an error
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                // first call will not be on this API's thread context
                pFsm->ClearOnApiCall();
                error = pFsm->QueueWorkItem();
            } else {
                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        bDeref = TRUE;
        CFsm_ParseUrlForHttp *pFsm;

        pFsm = new CFsm_ParseUrlForHttp(&hUrl,
                                       (INTERNET_HANDLE_OBJECT *)hInternetMapped,
                                       lpszUrl,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwFlags,
                                       dwContext
                                       );
        if (pFsm != NULL) {
            // IE6 BUG #27905
            // check if ctor of CFsm_ParseUrlForHttp encountered an error
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                error = DoFsm(pFsm);
            } else {
                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( error == ERROR_IO_PENDING )
    {
        bDeref = FALSE;
    }

quit:

    if (bDeref && hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }

    if ( lpThreadInfo != NULL ) {
        _InternetDecNestingCount(nestingLevel);
    }

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        hUrl = NULL;
    }

    DEBUG_LEAVE_API(hUrl);

    return hUrl;
}




INTERNETAPI_(BOOL) InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    This functions reads the next block of data from the file object. The
    following handle/data types are supported:

        TypeGopherFileHandle        - raw gopher file data
        TypeGopherFileHandleHtml    - HTML-encapsulated gopher file data
        TypeGopherFindHandleHtml    - HTML-encapsulated gopher directory data
        TypeFtpFileHandle           - raw FTP file data
        TypeFtpFileHandleHtml       - HTML-encapsulated FTP file data
        TypeFtpFindHandleHtml       - HTML-encapsulated FTP directory data

Arguments:

    hFile                   - handle returned from Open function

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - size of lpBuffer in BYTEs

    lpdwNumberOfBytesRead   - returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetReadFile",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    BOOL bEndRead = TRUE;
    HINTERNET_HANDLE_TYPE handleType = TypeWildHandle;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFileMapped, &context);

    if (!lpThreadInfo->IsAsyncWorkerThread) {

        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle and retrieve its type
    //

    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // we should not get an error - we already believe the handle object
        // is valid and of the type just retrieved!
        //

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // ensure correct handle type
    //

    if ((handleType != TypeHttpRequestHandle)
    && (handleType != TypeFtpFileHandle)
    && (handleType != TypeGopherFileHandle)
    && (handleType != TypeFtpFindHandleHtml)
    && (handleType != TypeGopherFindHandleHtml)
    && (handleType != TypeFtpFileHandleHtml)
    && (handleType != TypeGopherFileHandleHtml)
    && (handleType != TypeFileRequestHandle)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        goto quit;
    }

    //
    // validate parameters
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {
        error = ProbeAndSetDword(lpdwNumberOfBytesRead, 0);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        error = ProbeWriteBuffer(lpBuffer, dwNumberOfBytesToRead);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        *lpdwNumberOfBytesRead = 0;

        if (((handleType == TypeFtpFindHandleHtml) ||
            (handleType == TypeGopherFindHandleHtml)) &&
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                            IsCacheReadInProgress())
        {
            error = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                                        ReadCache((LPBYTE)lpBuffer,
                                        dwNumberOfBytesToRead,
                                        &bytesRead);
            success = (error == ERROR_SUCCESS);
            goto quit;
        }

        if (handleType == TypeHttpRequestHandle) {

            HTTP_REQUEST_HANDLE_OBJECT *lpRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hFileMapped;

            // See if request can be fulfilled from file system.
            if (lpRequest->AttemptReadFromFile
                (lpBuffer, dwNumberOfBytesToRead, &bytesRead)) {
                success = TRUE;
                goto quit;
            }

        } // end if (handleType == TypeHttpRequestHandle)

        else
        {
            //
            // trap a zero-length buffer before we go to the trouble of going async.
            // Maintain compatibility with base ReadFile(), although this is
            // POTENTIALLY A BUG. ReadFile() is *supposed* to return TRUE and number
            // of bytes read equal to zero to indicate end-of-file, but it will also
            // return TRUE and zero if a read of zero bytes is requested. According
            // to MarkL, that's the way it is. Good enough for me...
            //
            // For http, AttemptToReadFromFile traps zero-length reads

            if (dwNumberOfBytesToRead == 0) {

                //
                // *lpdwNumberOfBytesRead and error should have been correctly set
                // during parameter validation
                //

                INET_ASSERT(*lpdwNumberOfBytesRead == 0);
                INET_ASSERT(error == ERROR_SUCCESS);

                success = TRUE;
                goto quit;
            }
        } // end else (handleType != TypeHttpRequestHandle)

    } // end if (!lpThreadInfo->IsAsyncWorkerThread)

    //
    // the request will only be made asynchronously if more data is requested
    // than is immediately available AND we haven't reached end of file
    //

    DWORD available;

    available = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->AvailableDataLength();

    BOOL eof;

    eof = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsEndOfFile();

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (context != INTERNET_NO_CALLBACK)
    && (dwNumberOfBytesToRead > available)
    && !eof
    && (handleType != TypeHttpRequestHandle)
    && (handleType != TypeFileRequestHandle)) {

        // MakeAsyncRequest
        CFsm_InternetReadFile * pFsm;

        pFsm = new CFsm_InternetReadFile(hFile, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                bEndRead = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;

        //
        // we're going synchronous - set the error so we do the right thing when
        // we exit
        //

        error = ERROR_SUCCESS;
    } else if ((available >= dwNumberOfBytesToRead) || eof) {

        DEBUG_PRINT(API,
                    INFO,
                    ("immediate read: %d requested, %d available. EOF = %B\n",
                    dwNumberOfBytesToRead,
                    available,
                    eof
                    ));

    }

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // just call the underlying API: return whatever it returns, and let it
    // handle setting the last error
    //

    switch (handleType) {
    case TypeFtpFileHandle:
        success = FtpReadFile(hFileMapped,
                              lpBuffer,
                              dwNumberOfBytesToRead,
                              &bytesRead
                              );
        break;

    case TypeGopherFileHandle:
        success = GopherReadFile(hFileMapped,
                                 lpBuffer,
                                 dwNumberOfBytesToRead,
                                 &bytesRead
                                 );
        break;

    case TypeFtpFindHandleHtml:
    case TypeGopherFindHandleHtml:

        //
        // HTML handle types - convert underlying data to HTML document
        //

        success = ReadHtmlUrlData(hFileMapped,
                                  lpBuffer,
                                  dwNumberOfBytesToRead,
                                  &bytesRead
                                  );

        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->IsCacheWriteInProgress())
        {
            DWORD errorCache;

            if (success) {


                if (bytesRead) {

                    errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                                    WriteCache(
                                        (LPBYTE)lpBuffer,
                                        bytesRead
                                    );
                }
                else {
                    errorCache = ERROR_NO_MORE_FILES;
                }

            }
            else {
                errorCache = GetLastError();
            }

            // if the thing failed because the caller passed in
            // insufficient buffer for internetreadfile
            // then we should do nothing

            if ((errorCache != ERROR_SUCCESS)&&
                (errorCache != ERROR_INSUFFICIENT_BUFFER)) {
                if (handleType == TypeFtpFindHandleHtml) {

                    // we save extension in the index file
                    // this is used to differentiate between html directory
                    // entry from the non-html one for the same url

                    InbLocalEndCacheWrite(  hFileMapped,
                                            "htm",  // save extension in index file
                                            (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
                else {
                    InbGopherLocalEndCacheWrite(  hFileMapped,
                                                "htm",
                                                (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
            }
        }

        break;


    case TypeFtpFileHandleHtml:
    case TypeGopherFileHandleHtml:

        //
        // HTML handle types - convert underlying data to HTML document
        //

        success = ReadHtmlUrlData(hFileMapped,
                                  lpBuffer,
                                  dwNumberOfBytesToRead,
                                  &bytesRead
                                  );
        break;

    case TypeHttpRequestHandle:

        {
            //HTTP_REQUEST_HANDLE_OBJECT * lpRequest;
            //
            //lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
            //
            //error = lpRequest->QuickSyncRead(
            //                lpBuffer,
            //                dwNumberOfBytesToRead,
            //                lpdwNumberOfBytesRead,
            //                0
            //                );
            //
            //if ( error == ERROR_IO_PENDING )
            //{
                error = DoFsm(new CFsm_ReadFile(lpBuffer,
                                                dwNumberOfBytesToRead,
                                                lpdwNumberOfBytesRead
                                                ));
            //}

            success = (error == ERROR_SUCCESS) ? TRUE : FALSE;
            bEndRead = FALSE;
            break;
        }

    case TypeFileRequestHandle:

        success = ReadFile(
                    ((INTERNET_FILE_HANDLE_OBJECT *) hFileMapped)->GetFileHandle(),
                    lpBuffer,
                    dwNumberOfBytesToRead,
                    &bytesRead,
                    NULL // overlapped I/O
                    );

        if (!success)
        {
            error = GetLastError();
        }
        else
        {
            error = ERROR_SUCCESS;
        }

        break;

    case TypeFtpFindHandle:
    case TypeGopherFindHandle:

        //
        // you cannot receive RAW directory data using this API. You have
        // to call InternetFindNextFile()
        //

    default:

        //
        // the handle is a valid handle (or else RGetHandleType() would
        // have returned ERROR_INVALID_HANDLE), but this operation is
        // inconsistent with the handle type. Return a more prosaic error
        // code
        //

        error = ERROR_INTERNET_INVALID_OPERATION;
        break;
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

    if (bEndRead) {

        //
        // if handleType is not HttpRequest or File then we are making this
        // request in the context of an uninterruptable async worker thread.
        // HTTP and file requests use the normal mechanism. In the case of non-
        // HTTP and file requests, we need to treat the request as if it were
        // sync and deref the handle
        //

        ReadFile_End(!lpThreadInfo->IsAsyncWorkerThread
                     || !((handleType == TypeHttpRequestHandle)
                          || (handleType == TypeFileRequestHandle)),
                     success,
                     hFileMapped,
                     bytesRead,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     );
    }

    if (lpThreadInfo && !lpThreadInfo->IsAsyncWorkerThread) {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_READ_FILE,
                 bytesRead,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

done:

    //
    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    //

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    )

/*++

Routine Description:

    Common end-of-read processing:

        - update bytes read parameter
        - dump data if logging & API data requested
        - dereference handle if not async request

Arguments:

    bDeref                  - TRUE if handle should be dereferenced (should be
                              FALSE for async request)

    bSuccess                - TRUE if Read completed successfully

    hFileMapped             - mapped file handle

    dwBytesRead             - number of bytes read

    lpBuffer                - into this buffer

    dwNumberOfBytesToRead   - originally requested bytes to read

    lpdwNumberOfBytesRead   - where bytes read is stored

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                 None,
                 "ReadFile_End",
                 "%B, %B, %#x, %d, %#x, %d, %#x",
                 bDeref,
                 bSuccess,
                 hFileMapped,
                 dwBytesRead,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    if (bSuccess) {

        //
        // update the amount of immediate data available only if we succeeded
        //

        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->ReduceAvailableDataLength(dwBytesRead);

        if (lpdwNumberOfBytesRead != NULL) {
            *lpdwNumberOfBytesRead = dwBytesRead;

            DEBUG_PRINT(API,
                        INFO,
                        ("*lpdwNumberOfBytesRead = %d\n",
                        *lpdwNumberOfBytesRead
                        ));

            //
            // dump API data only if requested
            //

            IF_DEBUG_CONTROL(DUMP_API_DATA) {
                DEBUG_DUMP_API(API,
                               "Received data:\n",
                               lpBuffer,
                               *lpdwNumberOfBytesRead
                               );
            }
        }
        if (dwBytesRead < dwNumberOfBytesToRead) {

            DEBUG_PRINT(API,
                        INFO,
                        ("(!) bytes read (%d) < bytes requested (%d)\n",
                        dwBytesRead,
                        dwNumberOfBytesToRead
                        ));

        }
    }

    //
    // if async request, handle will be deref'd after REQUEST_COMPLETE callback
    // is delivered
    //

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    PERF_LOG(PE_CLIENT_REQUEST_END,
             AR_INTERNET_READ_FILE,
             dwBytesRead,
             0,
             (!bDeref && hFileMapped) ? ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle() : NULL
             );

    DEBUG_LEAVE(0);
}


DWORD
CFsm_ReadFile::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFile::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFile * stateMachine = (CFsm_ReadFile *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFile_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFile_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFile & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }
    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 fsm.m_dwBytesRead,
                 fsm.m_lpBuffer,
                 fsm.m_dwNumberOfBytesToRead,
                 fsm.m_lpdwNumberOfBytesRead
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetReadFileExA(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSA lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetReadFileExA",
                     "%#x, %#x [%#x, %d], %#x, %#x",
                     hFile,
                     lpBuffersOut,
                     (lpBuffersOut ? lpBuffersOut->lpvBuffer : NULL),
                     (lpBuffersOut ? lpBuffersOut->dwBufferLength : 0),
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    LPVOID lpBuffer = NULL;
    DWORD dwNumberOfBytesToRead;
    BOOL bEndRead = TRUE;
    BOOL success = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto done;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFileMapped, &context);

    if (!lpThreadInfo->IsAsyncWorkerThread) {

        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto done;
    }

    //
    // validate handle and retrieve its type
    //

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto done;
    }

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // we should not get an error - we already believe the handle object
        // is valid and of the type just retrieved!
        //

        INET_ASSERT(FALSE);

        goto done;
    }

    //
    // only accepting HTTP handles currently
    //

    if (handleType != TypeHttpRequestHandle) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        goto done;
    }

    HTTP_REQUEST_HANDLE_OBJECT * lpRequest;

    lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;

    //
    // validate params
    //

    if (lpBuffersOut->dwStructSize != sizeof(INTERNET_BUFFERS)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    lpBuffer = lpBuffersOut->lpvBuffer;
    dwNumberOfBytesToRead = lpBuffersOut->dwBufferLength;

    INET_ASSERT(dwNumberOfBytesToRead > 0);

    //
    // See if request can be fulfilled from file system.
    //

    if (lpRequest->AttemptReadFromFile(lpBuffer,
                                       dwNumberOfBytesToRead,
                                       &bytesRead)) {
        error = ERROR_SUCCESS;
        goto quit;
    }

    //
    // trap a zero-length buffer before we go to the trouble of going async.
    // Maintain compatibility with base ReadFile(), although this is
    // POTENTIALLY A BUG. ReadFile() is *supposed* to return TRUE and number
    // of bytes read equal to zero to indicate end-of-file, but it will also
    // return TRUE and zero if a read of zero bytes is requested. According
    // to MarkL, that's the way it is. Good enough for me...
    //
    // For http, AttemptToReadFromFile traps zero-length reads

    if (dwNumberOfBytesToRead == 0) {

        //
        // *lpdwNumberOfBytesRead and error should have been correctly set
        // during parameter validation
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        goto quit;
    }

    //error = lpRequest->QuickSyncRead(
    //                lpBuffer,
    //                dwNumberOfBytesToRead,
    //                &bytesRead,
    //                SF_NO_WAIT
    //                );
    //
    //if ( error == ERROR_IO_PENDING )
    //{
        error = DoFsm(new CFsm_ReadFileEx(lpBuffersOut,
                                          dwFlags,
                                          dwContext
                                          ));
    //}

    if (error == ERROR_SUCCESS) {
        bytesRead = lpBuffersOut->dwBufferLength;
    }
    bEndRead = FALSE;

quit:

    _InternetDecNestingCount(nestingLevel);;

    if (bEndRead) {
        ReadFile_End(TRUE,
                     (error == ERROR_SUCCESS),
                     hFileMapped,
                     bytesRead,
                     lpBuffersOut->lpvBuffer,
                     dwNumberOfBytesToRead,
                     &lpBuffersOut->dwBufferLength
                     );

    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


DWORD
CFsm_ReadFileEx::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFileEx::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFileEx * stateMachine = (CFsm_ReadFileEx *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFileEx_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFileEx_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFileEx & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        fsm.m_dwNumberOfBytesToRead = fsm.m_lpBuffersOut->dwBufferLength;
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffersOut->lpvBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             (fsm.m_dwFlags & IRF_NO_WAIT)
                               ? SF_NO_WAIT
                               : 0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }

    //
    // if we are asynchronously completing a no-wait read then we don't update
    // any app parameters - we simply return the indication that we completed.
    // The app will then make another no-wait read to get the data
    //

    BOOL bNoOutput;

    bNoOutput = ((fsm.m_dwFlags & IRF_NO_WAIT)
                && fsm.GetThreadInfo()->IsAsyncWorkerThread)
                    ? TRUE
                    : FALSE;

    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 bNoOutput ? 0    : fsm.m_dwBytesRead,
                 bNoOutput ? NULL : fsm.m_lpBuffersOut->lpvBuffer,
                 bNoOutput ? 0    : fsm.m_dwNumberOfBytesToRead,
                 bNoOutput ? NULL : &fsm.m_lpBuffersOut->dwBufferLength
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetWriteFile(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    This function write next block of data to the internet file. Currently it
    supports the following protocol data:

        FtpWriteFile
        HttpWriteFile
        FileWriteFile

Arguments:

    hFile                       - handle that was obtained by OpenFile Call

    lpBuffer                    - pointer to the data buffer

    dwNumberOfBytesToWrite      - number of bytes in the above buffer

    lpdwNumberOfBytesWritten    -  pointer to a DWORD where the number of bytes
                                   of data actually written is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetWriteFile",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToWrite,
                     lpdwNumberOfBytesWritten
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fNeedDeref = TRUE;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFileMapped, &context);
    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle and retrieve its type
    //

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // we should not get an error - we already believe the handle object
        // is valid and of the type just retrieved!
        //

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // validate parameters - write length cannot be 0
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {
        if (dwNumberOfBytesToWrite != 0) {
            error = ProbeReadBuffer((LPVOID)lpBuffer, dwNumberOfBytesToWrite);
            if (error == ERROR_SUCCESS) {
                error = ProbeAndSetDword(lpdwNumberOfBytesWritten, 0);
            }
        } else {
            error = ERROR_INVALID_PARAMETER;
        }
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }


    // # 62953
    // If the authentication state of the handle is Negotiate,
    // don't submit data to the server but return success.
    // ** Added test for NTLM or Negotiate - Adriaanc.
    if (handleType == TypeHttpRequestHandle)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest;
        pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hFileMapped;

        if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE
            && !((PLUG_CTX*) (pRequest->GetAuthCtx()))->_fNTLMProxyAuth
            && !(pRequest->GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_DPA))
        {
            *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
            error = ERROR_SUCCESS;
            success = TRUE;
            goto quit;
        }
    }
    //
    // we have to do some work. If the file object handle was created with
    // async I/O capability then we will queue an async request, otherwise
    // we will process the request synchronously
    //

    if (isAsync
    && !lpThreadInfo->IsAsyncWorkerThread
    && (handleType != TypeHttpRequestHandle)
    && (handleType != TypeFileRequestHandle)) {

        // MakeAsyncRequest
        CFsm_InternetWriteFile * pFsm;

        pFsm = new CFsm_InternetWriteFile(hFile, lpBuffer, dwNumberOfBytesToWrite, lpdwNumberOfBytesWritten);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fNeedDeref = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;

        //
        // we're going synchronous. Change error to ERROR_SUCCESS so that we do
        // the right thing at quit
        //

        error = ERROR_SUCCESS;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    switch (handleType) {
    case TypeFtpFileHandle:
        success = FtpWriteFile(hFileMapped,
                               (LPVOID)lpBuffer,
                               dwNumberOfBytesToWrite,
                               lpdwNumberOfBytesWritten
                               );
        break;

    case TypeHttpRequestHandle:
        error = HttpWriteData(hFileMapped,
                               (LPVOID)lpBuffer,
                               dwNumberOfBytesToWrite,
                               lpdwNumberOfBytesWritten,
                               0
                               );
        //
        // Don't Derefrence if we're going pending cause the FSM will do
        //  it for us.
        //

        if ( error == ERROR_IO_PENDING )
        {
            fNeedDeref = FALSE;
        }
        success = (error == ERROR_SUCCESS) ? TRUE : FALSE;
        //bEndRead = FALSE;
        break;

    case TypeFileRequestHandle:

        success = WriteFile(((INTERNET_FILE_HANDLE_OBJECT *) hFileMapped)->GetFileHandle(),
                               (LPVOID)lpBuffer,
                               dwNumberOfBytesToWrite,
                               lpdwNumberOfBytesWritten,
                               NULL // overlapped I/O
                               );

        if ( !success )
        {
            error = GetLastError();
        }
        else
        {
            error = ERROR_SUCCESS;
        }

        break;

    default:
        error = ERROR_INVALID_HANDLE;
        break;
    }

quit:

    if (hFileMapped != NULL && fNeedDeref) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) InternetWriteFileExA(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSA lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(DWORD) InternetSetFilePointer(
    IN HINTERNET hFile,
    IN LONG lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sets a file position for InternetReadFile.  It is a synchronous call,
    however subsequent calls to InternetReadFile may block or return
    pending if the data is not available from the cache and the server
    does not support random access.

Arguments:

    hFile
        A valid handle returned from a previous call to InternetOpenUrl
        or a handle returned from HttpOpenRequest for a GET or HEAD method
        and passed to HttpSendRequest.  The handle must have been created
        without INTERNET_FLAG_DONT_CACHE.

    lDistanceToMove

        Specifies the number of bytes to move the file pointer. A positive
        value moves the pointer forward in the file and a negative value
        moves it backward.

pReserved
        Reserved, pass NULL.

dwMoveMethod
        Specifies the starting point for the file pointer move. This
        parameter can be one of the following values:

        Value            Meaning
        FILE_BEGIN       The starting point is zero or the beginning of the file.
                         If FILE_BEGIN is specified, DistanceToMove is interpreted
                         as an unsigned location for the new file pointer.
        FILE_CURRENT     The current value of the file pointer is the starting point.
        FILE_END         The current end-of-file position is the starting point.
                         This method will fail if the content length is unknown.

Return Value:

    -1 on failure, else the current file position.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Int,
                     "InternetSetFilePointer",
                     "%#x, %#x, %#x, %#x %#x",
                     hFile,
                     lDistanceToMove,
                     pReserved,
                     dwMoveMethod,
                     dwContext
                     ));

    DWORD dwNewPosition = (DWORD) -1L;
    DWORD error;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    // Validate parameters...

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    HINTERNET_HANDLE_TYPE handleType;
    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    switch (handleType) {
        // case TypeFtpFileHandle:
        // case TypeGopherFileHandle:
        case TypeHttpRequestHandle:
            break;
        default:
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT *lpRequest;
    lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hFileMapped;
    dwNewPosition = lpRequest->SetStreamPointer (lDistanceToMove, dwMoveMethod);

quit:

    if (hFileMapped != NULL) {
        DereferenceObject((LPVOID)hFileMapped);
    }

done:

    DEBUG_LEAVE_API(dwNewPosition);

    return dwNewPosition;
}



INTERNETAPI_(BOOL) InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Determines the amount of data currently available to be read on the handle

Arguments:

    hFile                       - handle of internet object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

    dwFlags                     - flags controlling operation - FUTURE

    dwContext                   - used to differentiate multiple requests - FUTURE

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryDataAvailable",
                     "%#x, %#x, %#x, %#x",
                     hFile,
                     lpdwNumberOfBytesAvailable,
                     dwFlags,
                     dwContext
                     ));

    BOOL success;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        bDeref = FALSE;
        goto quit;
    }

    INET_ASSERT(hFile);

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    PERF_LOG(PE_CLIENT_REQUEST_START,
             AR_INTERNET_QUERY_DATA_AVAILABLE,
             lpThreadInfo->ThreadId,
             hFile
             );

    //
    // validate parameters
    //

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    INET_ASSERT(hFileMapped);

    //
    // set the context and handle values in the per-thread info block (this API
    // can't return extended error info, so we don't care about it)
    //

    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetContext()
                        );
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);

    //
    // if the handle is invalid, quit now
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate rest of parameters
    //

    error = ProbeAndSetDword(lpdwNumberOfBytesAvailable, 0);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // get the handle type
    //

    HINTERNET_HANDLE_TYPE handleType;

    handleType = ((HANDLE_OBJECT *)hFileMapped)->GetHandleType();

    //
    // find out if we're sync or async
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, TypeWildHandle);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    // WinSE 4998.  If there's no context on the handle, force the request to be synchronous.
    //
    if (isAsync && lpThreadInfo->Context == INTERNET_NO_CALLBACK)
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("Zero context: Call is Synchronous\n"
                    ));
        isAsync = FALSE;
    }

    //
    // since the async worker thread doesn't come back through this API, the
    // following test is sufficient. Note that we only go async if there is
    // no data currently available on the handle
    //

    BOOL dataAvailable;

    dataAvailable = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable();

    BOOL eof;

    eof = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsEndOfFile();

    if ((handleType != TypeHttpRequestHandle)
    && isAsync
    && !dataAvailable
    && !eof) {

        INET_ASSERT(hFileMapped);

        // MakeAsyncRequest
        CFsm_InternetQueryDataAvailable * pFsm;

        pFsm = new CFsm_InternetQueryDataAvailable(hFileMapped, lpdwNumberOfBytesAvailable, dwFlags, dwContext);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if (error == ERROR_IO_PENDING) {
                bDeref = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;

        //
        // we will continue along the synchronous path, in which case we
        // need to set error back to ERROR_SUCCESS so that our exit
        // processing (at quit) does the right thing
        //

        error = ERROR_SUCCESS;
    } else if (dataAvailable || eof) {

        DWORD available;

        available = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->AvailableDataLength();

        //
        // we have immediate data; if the handle type is FTP or gopher find and
        // the data is coming from cache, then we only want to indicate that a
        // single (fixed-length) find structure is available
        //

        switch (((HANDLE_OBJECT *)hFileMapped)->GetHandleType()) {
        case TypeFtpFindHandle:
            available = min(available, sizeof(WIN32_FIND_DATA));
            break;

        case TypeGopherFindHandle:
            available = min(available, sizeof(GOPHER_FIND_DATA));
            break;
        }

        DEBUG_PRINT(API,
                    INFO,
                    ("%d bytes are immediately available\n",
                    available
                    ));

        *lpdwNumberOfBytesAvailable = available;
        success = TRUE;
        goto finish;
    }

    INET_ASSERT(hFileMapped);

    //
    // sync path. wInternetQueryDataAvailable will set the last error code
    // if it fails
    //

    if (handleType == TypeHttpRequestHandle) {
        error = DoFsm(new CFsm_QueryAvailable(lpdwNumberOfBytesAvailable,
                                              dwFlags,
                                              dwContext
                                              ));
        if (error == ERROR_SUCCESS) {
            success = TRUE;
        } else {
            if (error == ERROR_IO_PENDING) {
                bDeref = FALSE;
            }
            goto quit;
        }
    } else {
        success = wInternetQueryDataAvailable(hFileMapped,
                                              lpdwNumberOfBytesAvailable,
                                              dwFlags,
                                              dwContext
                                              );
    }

finish:

    DEBUG_PRINT_API(API,
                    INFO,
                    ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                    lpdwNumberOfBytesAvailable,
                    *lpdwNumberOfBytesAvailable
                    ));

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (lpThreadInfo) {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_QUERY_DATA_AVAILABLE,
                 *lpdwNumberOfBytesAvailable,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    DEBUG_LEAVE_API(success);

    return success;

    //
    // we only come here if we are returning an error before calling
    // wInternetQueryDataAvailable
    //

    INET_ASSERT(error != ERROR_SUCCESS);

quit:

    DEBUG_ERROR(API, error);

    SetLastError(error);
    success = FALSE;

    goto finish;
}


DWORD
CFsm_QueryAvailable::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_QueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_QueryAvailable * stateMachine = (CFsm_QueryAvailable *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_QueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.GetMappedHandle();

    if (fsm.GetState() == FSM_STATE_INIT) {
        error = pRequest->QueryDataAvailable(fsm.m_lpdwNumberOfBytesAvailable);
    }
    if (error == ERROR_SUCCESS) {
        pRequest->SetAvailableDataLength(*fsm.m_lpdwNumberOfBytesAvailable);

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    *fsm.m_lpdwNumberOfBytesAvailable
                    ));

        fsm.SetApiData(*fsm.m_lpdwNumberOfBytesAvailable);
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpBuffer
    )

/*++

Routine Description:

    Returns the next directory entry in the listing identified by the handle

Arguments:

    hFind       - find handle, as returned by e.g. FtpFindFirstFile()

    lpBuffer    - pointer to buffer where next directory entry information will
                  be written. Contents of buffer may be different depending on
                  type of directory request, and protocol used (FTP/gopher/etc.)

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetFindNextFileA",
                     "%#x, %#x",
                     hFind,
                     lpBuffer
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fDeref = TRUE;
    HINTERNET hFindMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the per-thread info block on all paths
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFind, (LPVOID *)&hFindMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFindMapped == NULL)) {
        goto quit;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFindMapped, &context);
    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFind, hFindMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // retrieve handle type, and validate in the process
    //

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(hFindMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // get async/sync and local/remote
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFindMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // this should never happen - we just successfully called
        // RGetHandleType(), so RIsHandleLocal() should have worked too
        //

        DEBUG_PRINT(INET,
                    ERROR,
                    ("RIsHandleLocal() returns %d\n",
                    error
                    ));

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // make sure the handle type is valid for this request. We only support
    // FTP find handle and gopher find handle (both raw data)
    //

    if (!((handleType == TypeFtpFindHandle)
    || (handleType == TypeGopherFindHandle))) {
        error = ERROR_INTERNET_INVALID_OPERATION;
        goto quit;
    }

    //
    // if we're not in an async worker thread context then probe the buffer. If
    // we are in the async worker thread context, then we've already validated
    // the buffer. If is has since become invalid, then the app will fail
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {
        error = ProbeWriteBuffer(lpBuffer,
                                 (handleType == TypeFtpFindHandle)
                                    ? sizeof(WIN32_FIND_DATA)
                                    : sizeof(GOPHER_FIND_DATA)
                                 );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if this is an async request and we are not an async worker thread
        // then queue the request
        //

        if (isAsync) {

            // MakeAsyncRequest
            CFsm_InternetFindNextFile * pFsm;

            pFsm = new CFsm_InternetFindNextFile(hFind, lpBuffer);
            if (pFsm != NULL) {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;

            //
            // we will continue along the synchronous path, in which case we
            // need to set error back to ERROR_SUCCESS so that our exit
            // processing (at quit) does the right thing
            //

            error = ERROR_SUCCESS;
        }
    }

    //
    // dispatch to the underlying API. Return what the API returns, and let
    // the API SetLastError()
    //
    // N.B. We have already checked the handle type above, and we know at
    // this stage that we have a correct handle type
    //

    INET_ASSERT(error == ERROR_SUCCESS);

    switch (handleType) {
    case TypeFtpFindHandle:
        success = FtpFindNextFileA(hFindMapped,
                                   (LPWIN32_FIND_DATA)lpBuffer
                                   );
        break;

    case TypeGopherFindHandle:
        success = GopherFindNextA(hFindMapped,
                                  (LPGOPHER_FIND_DATA)lpBuffer
                                  );
        break;
    }

quit:

    if (hFindMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)hFindMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    //
    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    //

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE_API(success);
    return success;
}



INTERNETAPI_(BOOL) InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwErrorCategory,
    IN LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    This function returns the per-thread last internet error description text
    or server response.

    If this function is successful, *lpdwBufferLength contains the string length
    of lpszBuffer.

    If this function returns a failure indication, *lpdwBufferLength contains
    the number of BYTEs required to hold the response text

Arguments:

    lpdwErrorCategory   - pointer to DWORD location where the error catagory is
                          returned

    lpszBuffer          - pointer to buffer where the error text is returned

    lpdwBufferLength    - IN: length of lpszBuffer
                          OUT: number of characters in lpszBuffer if successful
                          else size of buffer required to hold response text

Return Value:

    BOOL
        Success - TRUE
                    lpszBuffer contains the error text. The caller must check
                    *lpdwBufferLength: if 0 then there was no text to return

        Failure - FALSE
                    Call GetLastError() for more information

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoA",
                     "%#x, %#x, %#x [%d]",
                     lpdwErrorCategory,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    BOOL success;
    DWORD textLength;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    //
    // validate parameters
    //

    if (IsBadWritePtr(lpdwErrorCategory, sizeof(*lpdwErrorCategory))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszBuffer)
        ? IsBadWritePtr(lpszBuffer, *lpdwBufferLength)
        : FALSE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the buffer pointer is NULL then its the same as a zero-length buffer
    //

    if (!ARGUMENT_PRESENT(lpszBuffer)) {
        *lpdwBufferLength = 0;
    } else if (*lpdwBufferLength != 0) {
        *lpszBuffer = '\0';
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(INET,
                    ERROR,
                    ("failed to get INTERNET_THREAD_INFO\n"
                    ));

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // there may not be any error text for this thread - either no server
    // error/response has been received, or the error text has been cleared by
    // an intervening API
    //

    if (lpThreadInfo->hErrorText != NULL) {

        //
        // copy as much as we can fit in the user supplied buffer
        //

        textLength = lpThreadInfo->ErrorTextLength;
        if (*lpdwBufferLength) {

            LPBYTE errorText;

            errorText = (LPBYTE)LOCK_MEMORY(lpThreadInfo->hErrorText);
            if (errorText != NULL) {
                textLength = min(textLength, *lpdwBufferLength) - 1;
                memcpy(lpszBuffer, errorText, textLength);

                //
                // the error text should always be zero terminated, so the
                // calling app can treat it as a string
                //

                lpszBuffer[textLength] = '\0';

                UNLOCK_MEMORY(lpThreadInfo->hErrorText);

                if (textLength == lpThreadInfo->ErrorTextLength - 1) {
                    error = ERROR_SUCCESS;
                } else {

                    //
                    // returned length is amount of buffer required
                    //

                    textLength = lpThreadInfo->ErrorTextLength;
                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            } else {

                DEBUG_PRINT(INET,
                            ERROR,
                            ("failed to lock hErrorText (%#x): %d\n",
                            lpThreadInfo->hErrorText,
                            GetLastError()
                            ));

                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        } else {

            //
            // user's buffer is not large enough to hold the info. We'll
            // let them know the required length
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        INET_ASSERT(lpThreadInfo->ErrorTextLength == 0);

        textLength = 0;
        error = ERROR_SUCCESS;
    }

    *lpdwErrorCategory = lpThreadInfo->ErrorNumber;
    *lpdwBufferLength = textLength;

    IF_DEBUG(ANY) {
        if ((error == ERROR_SUCCESS)
        || ((textLength != 0) && (lpszBuffer != NULL))) {

            DEBUG_DUMP_API(API,
                           "Last Response Info:\n",
                           lpszBuffer,
                           textLength
                           );

        }
    }

quit:
    success = (error == ERROR_SUCCESS);
    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackCore(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback,
    IN BOOL fType
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    INTERNET_STATUS_CALLBACK previousCallback = INTERNET_INVALID_STATUS_CALLBACK;
    HINTERNET hObjectMapped = NULL;

    if (!GlobalDataInitialized) {
        dwErr = GlobalDataInitialize();
        if (dwErr != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if ((lpfnInternetCallback != NULL) && IsBadCodePtr((FARPROC)lpfnInternetCallback))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (!hInternet)
    {
        dwErr = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        goto cleanup;
    }

    //
    // map the handle
    //

    dwErr = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwErr == ERROR_SUCCESS)
    {
        //
        // swap the new and previous handle object status callbacks, ONLY
        // if there are no pending requests on this handle
        //
        previousCallback = lpfnInternetCallback;
        dwErr = RExchangeStatusCallback(hObjectMapped, &previousCallback, fType);
    }

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(API, dwErr);
    }
    return previousCallback;
}


INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackA(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER_API((DBG_INET,
                 Pointer,
                 "InternetSetStatusCallbackA",
                 "%#x, %#x",
                 hInternet,
                 lpfnInternetCallback
                 ));

    INTERNET_STATUS_CALLBACK previousCallback = InternetSetStatusCallbackCore(
                                                    hInternet,
                                                    lpfnInternetCallback,
                                                    FALSE
                                                    );

    DEBUG_LEAVE_API(previousCallback);
    return previousCallback;
}


//
//INTERNETAPI_(BOOL) InternetCancelAsyncRequest(
//    IN DWORD dwAsyncId
//    )
//
///*++
//
//Routine Description:
//
//    Cancels an outstanding async request
//
//Arguments:
//
//    dwAsyncId   - identifier of the async I/O request
//
//Return Value:
//
//    BOOL
//        Success - TRUE
//                    Request was cancelled
//
//        Failure - FALSE
//                    Call GetLastError() for more information
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_INET,
//                 Bool,
//                 "InternetCancelAsyncRequest",
//                 "%d",
//                 dwAsyncId
//                 ));
//
//    DWORD error;
//    BOOL success;
//
//    error = CancelAsyncRequest(dwAsyncId);
//    if (error != ERROR_SUCCESS) {
//
//        DEBUG_ERROR(INET, error);
//
//        SetLastError(error);
//        success = FALSE;
//    } else {
//        success = TRUE;
//    }
//
//    DEBUG_LEAVE(success);
//
//    return success;
//}

//
// private functions
//


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET hConnect,
    IN DWORD dwService
    )

/*++

Routine Description:

    The obverse of InternetConnect(). Closes the handle created in
    InternetConnect()

Arguments:

    hConnect    - protocol handle created in InternetConnect()

    dwService   - service required. Controls type of handle generated.
                  May be one of:
                    - INTERNET_SERVICE_FTP
                    - INTERNET_SERVICE_GOPHER
                    - INTERNET_SERVICE_HTTP

Return Value:

    Success - ERROR_SUCCESS

    Failure - ERROR_INVALID_PARAMETER
                Incorrect dwService parameter (*never* expect this)

              Windows error
              Wininet error
              WSA error
                Error from protocol-specific disconnect function
--*/

{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "wInternetCloseConnectA",
                 "%#x, %d",
                 hConnect,
                 dwService
                 ));

    DWORD error;

    switch (dwService) {
    case INTERNET_SERVICE_FTP :
        error = wFtpDisconnect(hConnect, CF_EXPEDITED_CLOSE);
        break;

    case INTERNET_SERVICE_GOPHER :
        //error = wGopherDisconnect(hConnect);
        error = ERROR_SUCCESS;
        break;

    case INTERNET_SERVICE_HTTP:
        //error = wHttpConnectClose((LPHINTERNET)hConnect);
        error = ERROR_SUCCESS;
        break;

    default:
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
GetEmailNameAndPassword(
    IN OUT LPSTR* lplpszUserName,
    IN OUT LPSTR* lplpszPassword,
    OUT LPSTR EmailName,
    IN DWORD EmailNameLength
    )

/*++

Routine Description:

    Gets the login name and password for the FTP server (but can be used for any
    other protocol)

Arguments:

    lplpszUserName  - IN: pointer to pointer to user name
                      OUT: pointer to pointer to user name; may be modified

    lplpszPassword  - IN: pointer to pointer to password
                      OUT: pointer to pointer to password; may be modified

    EmailName       - pointer to buffer in which to store password if
                      "anonymous" returned for login name

    EmailNameLength - length of EmailName

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    LPSTR lpszUserName;
    LPSTR lpszPassword;

    lpszUserName = *lplpszUserName;
    lpszPassword = *lplpszPassword;

    //
    // validate username and password arguments. Valid combinations are:
    // (N.B. NULL means NULL pointer or NUL string)
    //
    //  lpszUsername    lpszPassword    Result
    //
    //      NULL            NULL        "anonymous", "emailname@domain"
    //      !NULL           NULL        lpszUserName, NULL
    //      NULL            !NULL       ERROR
    //      !NULL           !NULL       lpszUserName, lpszPassword
    //

    error = ERROR_SUCCESS;
    if (lpszUserName != NULL) {
        if (IsBadStringPtr(lpszUserName, INTERNET_MAX_USER_NAME_LENGTH)) {
            error = ERROR_INVALID_PARAMETER;
        } else if (*lpszUserName == '\0') {
            lpszUserName = NULL;
        }
    }
    if (error == ERROR_SUCCESS) {
        if (lpszPassword != NULL) {
            if (IsBadStringPtr(lpszPassword, INTERNET_MAX_PASSWORD_LENGTH)) {
                error = ERROR_INVALID_PASSWORD;
            } else if (*lpszPassword == '\0') {
                lpszPassword = NULL;
            }
        }
    }
    if (error == ERROR_SUCCESS) {
        if (lpszPassword == NULL) {
            if (lpszUserName == NULL) {

                DWORD length;

                //
                // both name and password are null pointers. We will convert to
                // "anonymous", "EmailName@DomainName"
                //

                //
                // because we don't require a client to be running TCP/IP, we
                // may be unable to get a domain name. Hence we now require the
                // EmailName entry in the registry to contain the entire
                // EmailName@DomainName string, including the '@'. If this is
                // not available, then we will just return an error
                //

                lpszUserName = "anonymous";
                length = EmailNameLength;
                error = GetMyEmailName(EmailName, &EmailNameLength);
                if (error == ERROR_SUCCESS) {
                    lpszPassword = EmailName;
                }
            } else {
                lpszPassword = "";
            }
        } else if (lpszUserName == NULL) {
            error = ERROR_INVALID_PARAMETER;
        }
    }

    *lplpszUserName = lpszUserName;
    *lplpszPassword = lpszPassword;

    return error;
}


INTERNETAPI_(DWORD) InternetAttemptConnect(
    IN DWORD dwReserved
    )

/*++

Routine Description:

    This routine attempts to make a loopback socket
    Clients call this to either invoke the dialdialog or to see whether
    they are connected to the net (??).

    4/29/97 (darrenmi) This function now calls InternetAutodial to see if a
    connection needs to be made.

    This function
Arguments:


    dwReserved  - ?

Return Value:

    DWORD

        Windows error code, or sockets error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "InternetAttemptConnect",
                     "%d",
                     dwReserved
                     ));

    DWORD error = ERROR_SUCCESS;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    if(!InternetAutodial(0, 0)) {
        error = ERROR_GEN_FAILURE;
    }

quit:
    DEBUG_LEAVE_API(error);
    return error;
}


INTERNETAPI_(BOOL) InternetLockRequestFile(
    IN HINTERNET hInternet,
    OUT HANDLE *lphLockReqHandle
    )

/*++

Routine Description:

    This routine allows the caller to place a lock on the file that he is
    using  by doing a CreateFile. This ensures that if this file is associated
    with this url, and another download on this url tries to commit another
    file, then this file won't vanish because the cache does a safe delete
    when updating or deleting the cache entry.
    The caller can then call the InternetUnlockRequestFile to give wininet
    the permission to delete this file if not committed to the cache.

Arguments:
    hInternet            request object which is doing the download
    lphLocReqHandle     place to return LockRequestHandle

Return Value:
    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetLockRequest",
                     "%#x, %#x",
                     hInternet,
                     lphLockReqHandle
                     ));

    DWORD error, dwSize, dwUrlLenPlus1, dwFileLenPlus1;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    LPLOCK_REQUEST_INFO lpLockReqInfo = NULL;
    LPSTR lpSource;
    BOOL locked = FALSE;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternet, FALSE);
    if (error == ERROR_SUCCESS) {
        hObjectMapped = hInternet;
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
        error = RGetHandleType(hInternet, &handleType);
    }
    if (error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    if ((handleType ==    TypeGenericHandle)||
        (handleType ==    TypeInternetHandle)||
        (handleType ==    TypeFtpConnectHandle)||
        (handleType ==    TypeGopherConnectHandle)||
        (handleType ==    TypeHttpConnectHandle) ||
        (handleType ==    TypeFileRequestHandle)) {

        error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    EnterCriticalSection(&LockRequestFileCritSec);
    locked = TRUE;

    //
    // If a lock handle was already created, simply increment the refcount.
    //

    if(lpLockReqInfo = (LPLOCK_REQUEST_INFO)(pConnect->GetLockRequestHandle())) {

        lpLockReqInfo->dwCount++;
        *lphLockReqHandle = (HANDLE)lpLockReqInfo;
        error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Record the URL and associated filename in the lock handle.
    //

    lpSource = pConnect->GetDataFileName();
    if (!lpSource) {
        error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    dwSize = sizeof(LOCK_REQUEST_INFO)
            +(dwUrlLenPlus1 = lstrlen(pConnect->GetCacheKey())+1)
            +(dwFileLenPlus1 = lstrlen(lpSource)+1)+3;  // atmost 3 bytes slop

    lpLockReqInfo = (LPLOCK_REQUEST_INFO)ALLOCATE_MEMORY(LPTR,  dwSize);
    if (!lpLockReqInfo) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    lpLockReqInfo->dwSignature = LOCK_REQUEST_SIGNATURE;
    lpLockReqInfo->dwSize = dwSize;
    lpLockReqInfo->fNoCacheLookup = FALSE;

    memcpy(lpLockReqInfo->rgBuff, pConnect->GetCacheKey(), dwUrlLenPlus1);
    lpLockReqInfo->UrlName = lpLockReqInfo->rgBuff;

    // align filename to DWORD
    lpLockReqInfo->FileName = &(lpLockReqInfo->rgBuff[((dwUrlLenPlus1+sizeof(DWORD)) & ~(3))]);
    memcpy(lpLockReqInfo->FileName, lpSource, dwFileLenPlus1);

    DEBUG_PRINT(INET,
                INFO,
                ("Url==%s, File== %s\n",
                lpLockReqInfo->UrlName,
                lpLockReqInfo->FileName
                ));

    //
    // Open the file so it will not be deleted upon cache entry delete/update.
    //

    lpLockReqInfo->hFile = CreateFile (
                                lpSource,
                                GENERIC_READ,
                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
    if (lpLockReqInfo->hFile == INVALID_HANDLE_VALUE) {
        error = GetLastError();
        goto Cleanup;
    }

    //
    // Set refcount to 2, one for connect handle and the other for lock handle.
    // Whichever one is closed last will perform cleanup.
    //

    lpLockReqInfo->dwCount = 2;
    *lphLockReqHandle = (HANDLE)lpLockReqInfo;
    pConnect->SetLockRequestHandle((HANDLE)lpLockReqInfo);

    // Check to see if this file corresponds to an installed cache
    // entry. If so, set fNoDelete so unlocking cannot delete the file.
    // Note - because installed cache entries are generally not downloaded
    // by wininet this is ok to do - it is only necessary to check if there
    // is a cache entry in the request object and if it is an installed type.
    if (handleType == TypeHttpRequestHandle)
    {
        LPCACHE_ENTRY_INFO pcei;
        pcei = ((HTTP_REQUEST_HANDLE_OBJECT*) pConnect)->GetCacheEntryInfo();
        if (pcei)
        {
            if (pcei->CacheEntryType & INSTALLED_CACHE_ENTRY)
                lpLockReqInfo->fNoDelete = TRUE;
        }
    }

    error = ERROR_SUCCESS;

Cleanup:
    BOOL fRet = (error==ERROR_SUCCESS);

    if (!fRet) {

        if (lpLockReqInfo) {
            FREE_MEMORY(lpLockReqInfo);
        }

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    else {
        DEBUG_PRINT(INET,
                    INFO,
                    ("Url==%s, File== %s RefCount=%d, Handle = %#x\n",
                    lpLockReqInfo->UrlName,
                    lpLockReqInfo->FileName,
                    lpLockReqInfo->dwCount,
                    *lphLockReqHandle
                    ));

    }

    if (locked) {
        LeaveCriticalSection(&LockRequestFileCritSec);
    }

    if (hObjectMapped) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) InternetUnlockRequestFile(
    IN HANDLE hLockHandle
    )

/*++

Routine Description:

    This routine allows the caller to unlock a request file that was locked
    using the InternetLockRequestFile routine. This allows the file
    to be deleted after the request object is long gone.

Arguments:

    hLockHandle     Lock Request Handle that was returned in InternetLockRequestFile

Return Value:

    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetUnlockRequest",
                     "%#x",
                     hLockHandle
                     ));

    DWORD error, dwUrlLen, dwFileNameLen;
    LPLOCK_REQUEST_INFO lpLockReqInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    EnterCriticalSection(&LockRequestFileCritSec);

    lpLockReqInfo = (LPLOCK_REQUEST_INFO)hLockHandle;

    __try {
        if (lpLockReqInfo->dwSignature == LOCK_REQUEST_SIGNATURE) {

            DEBUG_PRINT(INET,
                        INFO,
                        ("Url==%s, File== %s, refcount=%d\n",
                        lpLockReqInfo->UrlName,
                        lpLockReqInfo->FileName,
                        lpLockReqInfo->dwCount
                        ));

            if (--lpLockReqInfo->dwCount == 0) {

                if (!CloseHandle(lpLockReqInfo->hFile)) {

                    DEBUG_PRINT(INET,
                                ERROR,
                                ("Error=%d while Closing OpenHandle for file=%s for url=%s\n",
                                GetLastError(),
                                lpLockReqInfo->FileName,
                                lpLockReqInfo->UrlName
                                ));

                    }

                if (!lpLockReqInfo->fNoDelete) {

                    //
                    // Validate URL and filename.
                    //

                    dwUrlLen = lstrlen(lpLockReqInfo->UrlName);
                    dwFileNameLen =  lstrlen(lpLockReqInfo->FileName);

                    //
                    // Check if there is a cache entry for the URL.
                    //

                    DWORD dwSize;
                    LPINTERNET_CACHE_ENTRY_INFO pCEI;
                    char buf[sizeof(INTERNET_CACHE_ENTRY_INFO)+MAX_PATH+1];

                    pCEI = (LPINTERNET_CACHE_ENTRY_INFO)buf;
                    dwSize = sizeof(buf);

                    if (lpLockReqInfo->fNoCacheLookup) {

                        error = ERROR_FILE_NOT_FOUND;

                    } else {
                        // Grab info and
                        // Check if the filename actually matches.
                        error = GetUrlCacheEntryInfoEx(lpLockReqInfo->UrlName,
                                            pCEI,
                                            &dwSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY) ?
                                     (lstrcmpi(lpLockReqInfo->FileName, pCEI->lpszLocalFileName) ?
                                              ERROR_FILE_NOT_FOUND
                                            : ERROR_SUCCESS)
                                   : GetLastError();
                    } // end else if (!lpLockReqInfo->fNoCacheLookup)

                    if (error != ERROR_SUCCESS) {

                        //
                        // The file was not committed to cache, so attempt to delete it.
                        //

                        DEBUG_PRINT(INET, INFO,("deleting %q\n",lpLockReqInfo->FileName));

                        if (!DeleteFile(lpLockReqInfo->FileName)) {

                            DEBUG_PRINT(INET,
                                        ERROR,
                                        ("Error=%d while deleting file=%s for url=%s\n",
                                        GetLastError(),
                                        lpLockReqInfo->FileName,
                                        lpLockReqInfo->UrlName
                                        ));

                            if (lpLockReqInfo->fNoCacheLookup) {

                                switch (GetLastError()) {
                                    case ERROR_SHARING_VIOLATION:
                                    case ERROR_ACCESS_DENIED:
                                        UrlCacheAddLeakFile (lpLockReqInfo->FileName);
                                }
                            }

                        } // end if (!DeleteFile(...))
                    }
                } // end if (!lpLockReqInfo->fNoDelete)

                FREE_MEMORY(lpLockReqInfo);
                error = ERROR_SUCCESS;

            } else {

                DEBUG_PRINT(INET,
                            INFO,
                            ("Quitting after decrementing refcount, new refcount=%d\n",
                            lpLockReqInfo->dwCount
                            ));

                error = ERROR_SUCCESS;
            }
        } else {
            error = ERROR_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT

    LeaveCriticalSection(&LockRequestFileCritSec);

quit:
    BOOL fRet = (error==ERROR_SUCCESS);

    if  (fRet) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) InternetCheckConnectionA(
    IN LPCSTR lpszUrl,
    IN DWORD dwFlags,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    This routine tells the caller whether he can establish a connection to the
    network. If no URL is specified and dwFlags are set to NULL then wininet
        a) checks whether it has an outstanding socket connection and if so
            then the API returns TRUE.
        b) If there are no outstanding socket connections then a check
           is made in the wininet serverdatabase for servers which were
           connected to in the recent past. If one is found then the API returns TRUE.

        If neither a) or b) succeeds the API returns FALSE.

Arguments:

    lpszUrl     this parameter is an indication to the API to attempt
                a specific host. The use of this parameter is based on the
                flags set in the dwFlags parameter

    dwFlags     a bitwise OR of the following flags

                    INTERNET_FLAG_ICC_FORCE_CONNECTION - force a connection
                    A sockets connection is attempted in the following order
                    1) If lpszUrl is non-NULL then a host value is extracted
                       fromt it used that to ping the specific host
                    2) If the lpszUrl parameter is NULL then if there is an
                       entry in the wininet's internal server database for
                       the nearest server, it is used to do the pinging

                    If neither of these are available then ERROR_NOT_CONNECTED is
                    returned in GetLastError()

    dwReserved  reserved

Return Value:

    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCheckConnectionA",
                     "%s %x",
                     lpszUrl,
                     dwFlags
                     ));

    DWORD           dwError = ERROR_SUCCESS;
    LPSTR           lpszHostName;
    DWORD           dwHostNameLen;
    INTERNET_PORT   ServerPort = INTERNET_DEFAULT_HTTP_PORT;
    INTERNET_SCHEME ustScheme = INTERNET_SCHEME_HTTP;
    ICSocket *pSocket = NULL;
    char            buff[INTERNET_MAX_HOST_NAME_LENGTH+1];
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET   hInternet = NULL, hConnect = NULL, hConnectMapped = NULL;
    CServerInfo * lpServerInfo = NULL;

    if (!GlobalDataInitialized) {
        dwError = GlobalDataInitialize();
        if (dwError != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }

    // if the main sockets database thinks we are
    // unconditionally offline, then let us give that to the user
    //if(vSocketsDatabase.IsOffline())
    //{
    //
    //    dwError = ERROR_NOT_CONNECTED;
    //}
    //else
    {

        // We are not explicitly in offline mode

        lpServerInfo = FindNearestServer();

        if (dwFlags & FLAG_ICC_FORCE_CONNECTION) {

            buff[0] = 0;

            if (lpszUrl) {

                if (((dwError = CrackUrl(
                            (LPSTR)lpszUrl,            // url
                            lstrlen(lpszUrl),   // url length
                            FALSE,              // escape the URL ?
                            &ustScheme,         // scheme type
                            NULL,               // scheme name
                            NULL,               // scheme length
                            &lpszHostName,      // hostname pointer
                            &dwHostNameLen,     // hostname length
                            &ServerPort,        // port
                            NULL,               // UserName
                            NULL,               // UserName Length
                            NULL,               // Password
                            NULL,               // Password Length
                            NULL,               // Path
                            NULL,               // Path Length
                            NULL,               // Extra
                            NULL,               // Extra Length
                            NULL                // have port?
                            )) == ERROR_SUCCESS)&&
                                (dwHostNameLen<=INTERNET_MAX_HOST_NAME_LENGTH))
                {
                    memcpy(buff, lpszHostName, dwHostNameLen);
                    buff[dwHostNameLen] = 0;

                    // make sure we have a valid scheme
                    if(INTERNET_SCHEME_UNKNOWN == ustScheme)
                    {
                        ustScheme = INTERNET_SCHEME_HTTP;
                    }

                    // make sure we have a valid port
                    if(0 == ServerPort)
                    {
                        switch(ustScheme)
                        {
                        case INTERNET_SCHEME_FTP:
                            ServerPort = INTERNET_DEFAULT_FTP_PORT;
                            break;
                        case INTERNET_SCHEME_HTTPS:
                            ServerPort = INTERNET_DEFAULT_HTTPS_PORT;
                            break;
                        default:
                            ServerPort = INTERNET_DEFAULT_HTTP_PORT;
                            break;
                        }
                    }

                    // for our purposes, HTTPS == HTTP
                    if(INTERNET_SCHEME_HTTPS == ustScheme)
                    {
                        ustScheme = INTERNET_SCHEME_HTTP;
                    }

                    // we need the serverinfo struct for this server, not
                    // the nearest one that we already found
                    if(lpServerInfo)
                    {
                        lpServerInfo->Dereference();
                    }

                    lpServerInfo = FindServerInfo(buff);
                    if(!lpServerInfo)
                    {
                        // new CServerInfo has ref count 1 already
                        // we need to raise it so another thread won't go ahead and destroy this.
                        LockSerializedList(&GlobalServerInfoList);
                        lpServerInfo = new CServerInfo(buff, &dwError, INTERNET_SERVICE_HTTP, 0);
                        if(NULL == lpServerInfo)
                        {
                            dwError = ERROR_NOT_ENOUGH_MEMORY;
                            goto Cleanup;
                        }
                        else if (dwError != ERROR_SUCCESS)
                        {
                            delete lpServerInfo;
                            lpServerInfo = NULL;
                        }
                        else
                        {
                            lpServerInfo->Reference();
                        }
                        UnlockSerializedList(&GlobalServerInfoList);
                    }
                }
            }
            else {
                if (lpServerInfo) {

                    buff[sizeof(buff)-1] = 0;

                    strncpy(buff, lpServerInfo->GetHostName(), sizeof(buff)-1);
                }
                else
                {
                    // FORCE but no server to try - set error
                    dwError = ERROR_INTERNET_INVALID_OPERATION;
                    goto Cleanup;
                }
            }

            if (buff[0] && lpServerInfo) {

                // we have a host name, ping it.

                // This threadinfo/InternetOpen stuff is being done
                // because the ICSocket class is intertwined with
                // an internet handle, so we are just getting round that
                // difficulty. Ideally, ICSocket should have been a
                // standalone sockets class

                lpThreadInfo = InternetGetThreadInfo();

                if (lpThreadInfo == NULL) {

                    INET_ASSERT(FALSE);

                    dwError = ERROR_INTERNET_INTERNAL_ERROR;
                    goto Cleanup;
                }


                hInternet = InternetOpen("Internal",
                                            0,
                                            NULL,
                                            NULL,
                                            0
                                            );
                if (!hInternet) {
                    dwError = GetLastError();
                    goto Cleanup;
                }

                hConnect = InternetConnect(hInternet,
                                            buff,
                                            ServerPort,
                                            NULL,
                                            NULL,
                                            ustScheme,
                                            0,
                                            0);
                if (!hConnect) {
                    dwError = GetLastError();
                    goto Cleanup;
                }

                dwError = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);

                if (dwError != ERROR_SUCCESS) {
                    goto Cleanup;
                }

                _InternetSetObjectHandle(lpThreadInfo, hConnect, hConnectMapped);

                // Ping the server
                if (pSocket = new ICSocket()) {

                    pSocket->SetPort(ServerPort);

                    dwError = pSocket->SocketConnect(
                        GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                        GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                        0,
                        lpServerInfo
                        );

                    if (dwError == ERROR_SUCCESS) {
                        pSocket->Disconnect();
                    }
                }
                else {

                    dwError = ERROR_NOT_ENOUGH_MEMORY;

                }

            }

        }
        else{
            // caller doesn't ask us to force a connection
            // do the best we can and tell him

            dwError = (/*vSocketsDatabase.GetSocketCount() ||*/ lpServerInfo)?
                      ERROR_SUCCESS:
                      ERROR_NOT_CONNECTED;

        }

    }

Cleanup:

    if (lpServerInfo)
    {
        lpServerInfo->Dereference();
    }
    if (pSocket) {

        pSocket->Dereference();

    }
    if (hConnectMapped) {

        DereferenceObject((LPVOID)hConnectMapped);

    }
    if (hConnect) {

        InternetCloseHandle(hConnect);

    }
    if (hInternet) {

        InternetCloseHandle(hInternet);

    }

    BOOL fRet = (dwError==ERROR_SUCCESS);
    if (FALSE == fRet) {
        SetLastError(dwError);
        DEBUG_ERROR(API, dwError);
    }
    DEBUG_LEAVE_API(fRet);

    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\makefile.inc ===
!if "$(BUILD_PRODUCT)" == "IE"
MC_INC = -A
!endif

$(O)\inetmsg.rc $(O)\inetmsg.h $(O)\msg00001.bin : inetmsg.mc
    mc $(MC_INC) -v -d -r $(O) -h $(O) inetmsg.mc

$(SDK_INC_PATH)\inetmsg.h : $(O)\inetmsg.h
   $(PUBLISH_CMD) {$?=$@}

#wininet.sym: wininet.map
#    mapsym -o wininet.sym wininet.map

wininet.rc : $(O)\selfreg_wininet.inf
wininet.rc : ..\inetui\inetui.rc
wininet.rc : *.ico

$(O)\selfreg_wininet.inf : selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\inetapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapiw.cxx

Abstract:

    Contains the wide-character Internet APIs

    Contents:
        InternetCrackUrlW
        InternetCreateUrlW
        InternetCanonicalizeUrlW
        InternetCombineUrlW
        InternetOpenW
        InternetConnectW
        InternetOpenUrlW
        InternetReadFileExW
        InternetWriteFileExW
        InternetFindNextFileW
        InternetQueryOptionW
        InternetSetOptionW
        InternetGetLastResponseInfoW
        InternetSetStatusCallbackW

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

//  because wininet doesnt know about IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

extern BOOL TransformFtpFindDataToW(LPWIN32_FIND_DATAA pfdA, LPWIN32_FIND_DATAW pfdW);
extern BOOL TransformGopherFindDataToW(LPGOPHER_FIND_DATAA pgfdA, LPGOPHER_FIND_DATAW pgfdW);

// -- FixStrings ------

//  Used in InternetCrackUrlW only.
//  Either
//  (a) If we have an ansi string, AND a unicode buffer, convert from ansi to unicode
//  (b) If we have an ansi string, but NO unicode buffer, determine where the ansi string
//         occurs in the unicode URL, and point the component there.

VOID
FixStrings(    
    LPSTR& pszA, 
    DWORD cbA, 
    LPWSTR& pszW, 
    DWORD& ccW, 
    LPSTR pszUrlA, 
    LPCWSTR pszUrlW)
{
    if (!pszA)
        return;

    if (pszW) 
    {
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA+1, pszW, ccW) - 1; 
    } 
    else 
    { 
        pszW = (LPWSTR)(pszUrlW + MultiByteToWideChar(CP_ACP, 0, 
                pszUrlA, (int) (pszA-pszUrlA), NULL, 0)); 
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA, NULL, 0); 
    } 
}

//
// functions
//


INTERNETAPI_(BOOL) InternetCrackUrlW(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW pUCW
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    pszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if pszUrl is ASCIIZ string, else length of pszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCrackUrlW",
                     "%wq, %#x, %#x, %#x",
                     pszUrlW,
                     dwUrlLengthW,
                     dwFlags,
                     pUCW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    BOOL fContinue;
    DWORD c;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!(pszUrlW && pUCW))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    UCA.dwStructSize = sizeof(URL_COMPONENTSA); 
    ALLOC_MB(pszUrlW, dwUrlLengthW, mpUrlA);
    if (!mpUrlA.psStr) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI(pszUrlW, mpUrlA);

    for (c=0; c<=5; c++) {
        LPWSTR pszWorker;
        DWORD ccLen;
        MEMORYPACKET* pmpWorker;
        
        switch(c)
        {
        case 0:
            pszWorker = pUCW->lpszScheme;
            ccLen = pUCW->dwSchemeLength;
            pmpWorker = &mpScheme;
            break;

        case 1:
            pszWorker = pUCW->lpszHostName;
            ccLen = pUCW->dwHostNameLength;
            pmpWorker = &mpHostName;
            break;

        case 2:
            pszWorker = pUCW->lpszUserName;
            ccLen = pUCW->dwUserNameLength;
            pmpWorker = &mpUserName;
            break;

        case 3:
            pszWorker = pUCW->lpszPassword;
            ccLen = pUCW->dwPasswordLength;
            pmpWorker = &mpPassword;
            break;

        case 4:
            pszWorker = pUCW->lpszUrlPath;
            ccLen = pUCW->dwUrlPathLength;
            pmpWorker = &mpUrlPath;
            break;

        case 5:
            pszWorker = pUCW->lpszExtraInfo;
            ccLen = pUCW->dwExtraInfoLength;
            pmpWorker = &mpExtraInfo;
            break;
        }

        if (pszWorker) { 
            ALLOC_MB(pszWorker,ccLen,(*pmpWorker)); 
            if (!pmpWorker->psStr) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        } else { 
            pmpWorker->dwAlloc = ccLen; 
        }
    };

    REASSIGN_ALLOC(mpScheme,UCA.lpszScheme,UCA.dwSchemeLength);
    REASSIGN_ALLOC(mpHostName, UCA.lpszHostName,UCA.dwHostNameLength);
    REASSIGN_ALLOC(mpUserName, UCA.lpszUserName,UCA.dwUserNameLength);
    REASSIGN_ALLOC(mpPassword,UCA.lpszPassword,UCA.dwPasswordLength);
    REASSIGN_ALLOC(mpUrlPath,UCA.lpszUrlPath,UCA.dwUrlPathLength);
    REASSIGN_ALLOC(mpExtraInfo,UCA.lpszExtraInfo,UCA.dwExtraInfoLength);
                
    fResult = InternetCrackUrlA(mpUrlA.psStr, mpUrlA.dwSize, dwFlags, &UCA);
    if (fResult) {
        FixStrings(UCA.lpszScheme, UCA.dwSchemeLength, pUCW->lpszScheme, 
                    pUCW->dwSchemeLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszHostName, UCA.dwHostNameLength, pUCW->lpszHostName, 
                    pUCW->dwHostNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUserName, UCA.dwUserNameLength, pUCW->lpszUserName, 
                    pUCW->dwUserNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszPassword, UCA.dwPasswordLength, pUCW->lpszPassword, 
                    pUCW->dwPasswordLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUrlPath, UCA.dwUrlPathLength, pUCW->lpszUrlPath, 
                    pUCW->dwUrlPathLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszExtraInfo, UCA.dwExtraInfoLength, pUCW->lpszExtraInfo, 
                    pUCW->dwExtraInfoLength, mpUrlA.psStr, pszUrlW);
        pUCW->nScheme = UCA.nScheme;
        pUCW->nPort = UCA.nPort;
        pUCW->dwStructSize = sizeof(URL_COMPONENTSW);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetCreateUrlW(
    IN LPURL_COMPONENTSW pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

Return Value:

    BOOL
        Success - URL written to pszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCreateUrlW",
                     "%#x, %#x, %#x, %#x",
                     pUCW,
                     dwFlags,
                     pszUrlW,
                     pdwUrlLengthW
                     ));

    // INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pdwUrlLengthW 
        || (pUCW==NULL)
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW))
        || (pszUrlW && IsBadWritePtr(pszUrlW, *pdwUrlLengthW*sizeof(WCHAR))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW, *pdwUrlLengthW, mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    mpUrlA.dwSize = mpUrlA.dwAlloc;
    UCA.dwStructSize = sizeof(URL_COMPONENTSA);

    UCA.nScheme = pUCW->nScheme;
    UCA.nPort = pUCW->nPort;
    if (pUCW->lpszScheme)
    {
        ALLOC_MB(pUCW->lpszScheme, pUCW->dwSchemeLength, mpScheme);
        if (!mpScheme.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszScheme, mpScheme);
    }
    REASSIGN_SIZE(mpScheme, UCA.lpszScheme, UCA.dwSchemeLength);
    if (pUCW->lpszHostName)
    {
        ALLOC_MB(pUCW->lpszHostName, pUCW->dwHostNameLength, mpHostName);
        if (!mpHostName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszHostName, mpHostName);
    }
    REASSIGN_SIZE(mpHostName, UCA.lpszHostName, UCA.dwHostNameLength);
    if (pUCW->lpszUserName)
    {
        ALLOC_MB(pUCW->lpszUserName, pUCW->dwUserNameLength, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUserName, mpUserName);
    }
    REASSIGN_SIZE(mpUserName, UCA.lpszUserName, UCA.dwUserNameLength);
    if (pUCW->lpszPassword)
    {
        ALLOC_MB(pUCW->lpszPassword, pUCW->dwPasswordLength, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszPassword, mpPassword);
    }
    REASSIGN_SIZE(mpPassword, UCA.lpszPassword, UCA.dwPasswordLength);
    if (pUCW->lpszUrlPath)
    {
        ALLOC_MB(pUCW->lpszUrlPath, pUCW->dwUrlPathLength, mpUrlPath); 
        if (!mpUrlPath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUrlPath, mpUrlPath);
    }
    REASSIGN_SIZE(mpUrlPath, UCA.lpszUrlPath, UCA.dwUrlPathLength);
    if (pUCW->lpszExtraInfo)
    {
        ALLOC_MB(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength, mpExtraInfo);
        if (!mpExtraInfo.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszExtraInfo, mpExtraInfo);
    }
    REASSIGN_SIZE(mpExtraInfo, UCA.lpszExtraInfo, UCA.dwExtraInfoLength);
    fResult = InternetCreateUrlA(&UCA, dwFlags, mpUrlA.psStr, &mpUrlA.dwSize);
    if (fResult)
    {
        MAYBE_COPY_ANSI(mpUrlA, pszUrlW, *pdwUrlLengthW);
    }
    else
    {
        *pdwUrlLengthW = mpUrlA.dwSize*sizeof(WCHAR);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// implemented in inetapia.cxx
DWORD ICUHrToWin32Error(HRESULT);


INTERNETAPI_(BOOL) InternetCanonicalizeUrlW(
    IN LPCWSTR pszUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    pszUrl             - pointer to URL to be canonicalize

    pszBuffer          - pointer to buffer where new URL is written

    lpdwBufferLength    - size of buffer on entry, length of new URL on exit

    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlW",
                     "%wq, %#x, %#x [%d], %#x",
                     pszUrl,
                     pszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

//    We don't need no stinkin asserts
//    INET_ASSERT(pszUrl);
//    INET_ASSERT(pszBuffer);
//    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!pszUrl || !pszBuffer || !lpdwBufferLength 
        || IsBadWritePtr(lpdwBufferLength, sizeof(lpdwBufferLength))
        || *lpdwBufferLength == 0
        || IsBadWritePtr(pszBuffer, *lpdwBufferLength*sizeof(WCHAR))
        || IsBadStringPtrW(pszUrl, INTERNET_MAX_URL_LENGTH))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeW(pszUrl, pszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(INET, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    DEBUG_LEAVE_API(bRet);
    return bRet;
}


INTERNETAPI_(BOOL) InternetCombineUrlW(
    IN LPCWSTR pszBaseUrl,
    IN LPCWSTR pszRelativeUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    pszBaseUrl         - pointer to base URL

    pszRelativeUrl     - pointer to relative URL

    pszBuffer          - pointer to buffer where new URL is written

    lpdwBufferLength    - size of buffer on entry, length of new URL on exit

    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCombineUrlW",
                     "%wq, %wq, %#x, %#x [%d], %#x",
                     pszBaseUrl,
                     pszRelativeUrl,
                     pszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

//    We don't need no stinkin' asserts
//    INET_ASSERT(pszBaseUrl);
//    INET_ASSERT(pszRelativeUrl);
//    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!pszBaseUrl || !pszRelativeUrl || !lpdwBufferLength 
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (pszBuffer && IsBadWritePtr(pszBuffer, *lpdwBufferLength*sizeof(WCHAR)))
        || IsBadStringPtrW(pszBaseUrl, INTERNET_MAX_URL_LENGTH)
        || IsBadStringPtrW(pszRelativeUrl, INTERNET_MAX_URL_LENGTH))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineW(pszBaseUrl, pszRelativeUrl, pszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(INET, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    DEBUG_LEAVE_API(bRet);
    return bRet;
}


INTERNETAPI_(HINTERNET) InternetOpenW(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pszAgent       -

    dwAccessType    -

    pszProxy       -

    pszProxyBypass -

    dwFlags         -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenW",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpAgentA, mpProxyA, mpProxyBypassA;

    ALLOC_MB(pszAgentW,0,mpAgentA);
    if (!mpAgentA.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI(pszAgentW,mpAgentA);
    if (pszProxyW)
    {
        ALLOC_MB(pszProxyW,0,mpProxyA);
        if (!mpProxyA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszProxyW,mpProxyA);
    }
    if (pszProxyBypassW)
    {
        ALLOC_MB(pszProxyBypassW,0,mpProxyBypassA);
        if (!mpProxyBypassA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszProxyBypassW,mpProxyBypassA);
    }

    hInternet = InternetOpenA(mpAgentA.psStr, dwAccessType, mpProxyA.psStr, 
                                        mpProxyBypassA.psStr, dwFlags);

                                        
cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(HINTERNET) InternetConnectW(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR pszUserNameW,
    IN LPCWSTR pszPasswordW,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszServerName      -
    nServerPort         -
    pszUserName        -
    pszPassword        -
    dwService           -
    dwFlags             -
    dwContext           -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetConnectW",
                     "%#x, %wq, %d, %wq, %wq, %s (%d), %#08x, %#x",
                     hInternetSession,
                     pszServerNameW,
                     nServerPort,
                     pszUserNameW,
                     pszPasswordW,
                     InternetMapService(dwService),
                     dwService,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpServerNameA, mpUserNameA, mpPasswordA;
    HINTERNET hInternet = NULL;

    if (!pszServerNameW)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pszServerNameW, 0, mpServerNameA);
    if (!mpServerNameA.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pszServerNameW, mpServerNameA);
    if (pszUserNameW)
    {
        ALLOC_MB(pszUserNameW, 0, mpUserNameA);
        if (!mpUserNameA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszUserNameW, mpUserNameA);
    }
    if (pszPasswordW)
    {
        ALLOC_MB(pszPasswordW, 0, mpPasswordA);
        if (!mpPasswordA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszPasswordW, mpPasswordA);
    }
    hInternet = InternetConnectA(hInternetSession, mpServerNameA.psStr, nServerPort,
                                mpUserNameA.psStr, mpPasswordA.psStr, dwService, dwFlags, dwContext);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(HINTERNET) InternetOpenUrlW(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszUrlW,
    IN LPCWSTR pszHeadersW,
    IN DWORD dwHeadersLengthW,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszUrl             -
    pszHeaders         -
    dwHeadersLength     -
    dwFlags             -
    dwContext           -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenUrlW",
                     "%#x, %wq, %.80wq, %d, %#08x, %#x",
                     hInternetSession,
                     pszUrlW,
                     pszHeadersW,
                     dwHeadersLengthW,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpHeadersA, mpUrlA;
    HINTERNET hInternet = NULL;
    
    if (!pszUrlW || (*pszUrlW==L'\0'))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pszUrlW, 0, mpUrlA);
    if (!mpUrlA.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pszUrlW, mpUrlA);
    if (pszHeadersW)
    {
        ALLOC_MB(pszHeadersW, (dwHeadersLengthW==-1L? 0 : dwHeadersLengthW), mpHeadersA);
        if (!mpHeadersA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszHeadersW, mpHeadersA);
    }
    hInternet = InternetOpenUrlA(hInternetSession, mpUrlA.psStr, mpHeadersA.psStr, 
                                    mpHeadersA.dwSize, dwFlags, dwContext);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) InternetReadFileExW(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSW lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(BOOL) InternetWriteFileExW(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSW lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(BOOL) InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    )

/*++

Routine Description:

    This function retrieves the next block of data from the server.
    Currently it supports the following protocol data :

    FtpFindNextFile
    GopherFindNext

Arguments:

    hFind       - handle that was obtained by a FindFirst call

    lpvFindData - pointer to buffer where the next block of data is copied

Return Value:

    TRUE if the function successfully returns next block of data.
    FALSE otherwise. GetLastError() will return the error code.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetFindNextFileW",
                     "%#x, %#x",
                     hFind,
                     lpvFindData
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hFindMapped;
    HINTERNET_HANDLE_TYPE handleType;
    BOOL fResult = FALSE;
    
    dwErr = MapHandleToAddress(hFind, (LPVOID *)&hFindMapped, FALSE);
    if (dwErr!=ERROR_SUCCESS)
    {
        goto cleanup;
    }
    dwErr = RGetHandleType(hFindMapped, &handleType);
    DereferenceObject(hFindMapped);
    if (dwErr!=ERROR_SUCCESS)
    {
        goto cleanup;
    }
    if ((handleType != TypeFtpFindHandle) && (handleType != TypeGopherFindHandle))
    {
        dwErr = ERROR_INTERNET_INVALID_OPERATION;
        goto cleanup;
    }

    if (handleType == TypeFtpFindHandle)
    {
        WIN32_FIND_DATAA fdA;
        dwErr = ProbeWriteBuffer(lpvFindData, sizeof(WIN32_FIND_DATAW));
        if (dwErr!=ERROR_SUCCESS) 
        {
            goto cleanup;
        }
        if (InternetFindNextFileA(hFind,(LPVOID)&fdA))
            fResult = TransformFtpFindDataToW(&fdA,(LPWIN32_FIND_DATAW)lpvFindData);
    }
    else
    {
        GOPHER_FIND_DATAA gfdA;
        dwErr = ProbeWriteBuffer(lpvFindData, sizeof(GOPHER_FIND_DATAW));
        if (dwErr!=ERROR_SUCCESS) 
        {
            goto cleanup;
        }
        if (InternetFindNextFileA(hFind,(LPVOID)&gfdA))
            fResult = TransformGopherFindDataToW(&gfdA,(LPGOPHER_FIND_DATAW)lpvFindData);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwErrorCategory,
    IN LPWSTR pszBufferW,
    IN OUT LPDWORD lpdwBufferLengthW
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpdwErrorCategory   -
    pszBuffer          -
    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoW",
                     "%#x, %ws, %#x [%d]",
                     lpdwErrorCategory,
                     pszBufferW,
                     lpdwBufferLengthW,
                     lpdwBufferLengthW ? *lpdwBufferLengthW : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBufferA;

    if (pszBufferW)
    {
        ALLOC_MB(pszBufferW,*lpdwBufferLengthW,mpBufferA);
        if (!mpBufferA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
        
    mpBufferA.dwSize = mpBufferA.dwAlloc;
    fResult = InternetGetLastResponseInfoA(lpdwErrorCategory, mpBufferA.psStr,
                                            &mpBufferA.dwSize);
    if (fResult) {
        MAYBE_COPY_ANSI(mpBufferA, pszBufferW, *lpdwBufferLengthW);
    } else {
        *lpdwBufferLengthW = mpBufferA.dwSize*sizeof(WCHAR);
    }

cleanup:    
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetCheckConnectionW(
    IN      LPCWSTR   pszUrlW,
    IN      DWORD   dwFlags,
    IN      DWORD   dwReserved
)

/*++

Routine Description:

    This routine tells the caller whether he can establish a connection to the
    network.


Arguments:

    pszUrl     this parameter is an indication to the API to attempt
                a specific host. The use of this parameter is based on the
                flags set in the dwFlags parameter

    dwFlags     a bitwise OR of the following flags

                    INTERNET_FLAG_ICC_FORCE_CONNECTION - force a connection if
                    cannot find one already established

                    INTERNET_FLAG_ICC_CONNECT_SPECIFIC_HOST - try the connection
                    to the specific host. If this flag is not set then the
                    host name is used if a quicker method is not avilable.

    dwReserved  reserved

Return Value:

    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCheckConnectionW",
                     "%ws %x",
                     pszUrlW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlA;
    BOOL fResult = FALSE;
    
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW,0,mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszUrlW,mpUrlA);
    }
    fResult = InternetCheckConnectionA(mpUrlA.psStr, dwFlags, dwReserved);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackCore(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback,
    IN BOOL fType
    );

INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackW(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Pointer,
                 "InternetSetStatusCallbackW",
                 "%#x, %#x",
                 hInternet,
                 lpfnInternetCallback
                 ));

    INTERNET_STATUS_CALLBACK pfn = InternetSetStatusCallbackCore(hInternet,lpfnInternetCallback,TRUE);

    DEBUG_LEAVE(pfn);
    return pfn;
}

#ifdef IGCURLW
INTERNETAPI_(BOOL) InternetGetCertByURLW(
    IN LPWSTR     lpszURL,
    IN OUT LPWSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
    return InternetGetCertByURLA(lpszURL,lpszCertText,dwcbCertText);
}

#endif

INTERNETAPI_(BOOL) InternetShowSecurityInfoByURLW(
    IN LPWSTR    pszUrlW,
    IN HWND      hwndRootWindow
    )
/*++

Routine Description:

    Does a high-level lookup against the Certificate Cache.
    Searches by URL (broken down into hostname) for the Certificate,
    and returns it in a formatted (&localized) string.

Arguments:

    lpszUrl         - pointer to URL to crack

    lpszCertText    - Output of formatted certifcate

    dwcbCertText    - Size of lpszCertText

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_INET,
                 Bool,
                 "InternetShowSecurityInfoW",
                 "%wq, %#x",
                 pszUrlW,
                 hwndRootWindow
                 ));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlA;
    
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW,0,mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszUrlW,mpUrlA);
    }
    fResult = InternetShowSecurityInfoByURLA(mpUrlA.psStr, hwndRootWindow);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(BOOL) InternetAlgIdToStringW(
    IN ALG_ID       ai,
    IN LPWSTR       lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a algid to a user-displayable string.

Arguments:
    
    ai - Algorithm identifiers ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)
    
    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetAlgIdToStringW",
                     "%#x, %wq, %#x, %#x",
                     ai,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    if (dwReserved!=0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (lpstr)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwstrLength;
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));

        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (InternetAlgIdToStringA(ai, (LPSTR)mpBuffer.psStr, &mpBuffer.dwSize, dwReserved))
    {
        *lpdwstrLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                      NULL, 0);
        if (*lpdwstrLength*sizeof(WCHAR) <= mpBuffer.dwAlloc && lpstr)
        {
            MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                    lpstr, *lpdwstrLength);
            (*lpdwstrLength)--;
            fResult = TRUE;
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else 
    {
        dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            *lpdwstrLength = mpBuffer.dwSize * sizeof(WCHAR);
        }
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSecurityProtocolToStringW(
    IN DWORD        dwProtocol,
    IN LPWSTR       lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a security protocol to a user-displayable string.

Arguments:
    
    dwProtocol - Security protocol identifier ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)
    
    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSecurityProtocolToStringW",
                     "%d, %wq, %#x, %#x",
                     dwProtocol,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    if (dwReserved!=0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (lpstr)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwstrLength;
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (InternetSecurityProtocolToStringA(dwProtocol, (LPSTR)mpBuffer.psStr, &mpBuffer.dwSize, dwReserved))
    {
        *lpdwstrLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                      NULL, 0);
        if (*lpdwstrLength*sizeof(WCHAR) <= mpBuffer.dwAlloc && lpstr)
        {
            MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                    lpstr, *lpdwstrLength);
            (*lpdwstrLength)--;
            fResult = TRUE;
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else 
    {
        dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            *lpdwstrLength = mpBuffer.dwSize * sizeof(WCHAR);
        }
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\inetapiu.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.h

Abstract:

    Prototypes for inetapiu.cxx

Author:

    Richard L Firth (rfirth) 17-Feb-1996

Revision History:

    17-Feb-1996 rfirth
        Created

--*/

//
// prototypes
//

//BOOL
//wInternetQueryDataAvailable(
//    IN LPVOID hFileMapped,
//    OUT LPDWORD lpdwNumberOfBytesAvailable,
//    IN DWORD dwFlags,
//    IN DWORD_PTR dwContext
//    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\millenras.h ===
/* Copyright (c) 1999, Microsoft Corporation, all rights reserved
**
** autodial.h
** Autodial remote access external API
** Public header for external API clients
**
*/

#ifndef _MILLEN_AUTODIAL_H_
#define _MILLEN_AUTODIAL_H_

// First two match WinInet
#define RAS_INTERNET_AUTODIAL_FORCE_DIAL        0x00000001
#define RAS_INTERNET_AUTODIAL_UNATTENDED        0x00000002
// #define RAS_INTERNET_AUTODIAL_FAILIFSECURITYCHECK 0x0000004

#define RAS_INTERNET_AUTODIAL_NO_TRAY_ICON      0x00000010
#define RAS_INTERNET_AUTODIAL_NO_REDIAL         0x00000020
#define RAS_INTERNET_AUTODIAL_ALLOW_OFFLINE     0x00000040
#define RAS_INTERNET_AUTODIAL_RECONNECT         0x00000080 
#define RAS_INTERNET_AUTODIAL_RESERVED          0x80000000

#define RAS_INTERNET_AUTODIAL_FLAGS_MASK        RAS_INTERNET_AUTODIAL_UNATTENDED | \
                                                RAS_INTERNET_AUTODIAL_FORCE_DIAL | \
                                                RAS_INTERNET_AUTODIAL_NO_TRAY_ICON | \
                                                RAS_INTERNET_AUTODIAL_NO_REDIAL | \
                                                RAS_INTERNET_AUTODIAL_ALLOW_OFFLINE | \
                                                RAS_INTERNET_AUTODIAL_RECONNECT | \
                                                RAS_INTERNET_AUTODIAL_RESERVED

DWORD APIENTRY RasInternetDialA( HWND, LPSTR, DWORD, DWORD *, DWORD );

DWORD APIENTRY RasRegisterAutodialCallbackA( DWORD, DWORD, LPVOID, LPHANDLE, DWORD );

DWORD APIENTRY RasUnregisterAutodialCallbackA( HANDLE );

BOOL APIENTRY RasInternetAutodialA( DWORD, HWND );

BOOL APIENTRY RasInternetAutodialHangUpA( DWORD );

DWORD APIENTRY RasInternetHangUpA( DWORD, DWORD );


#define RAS_INTERNET_CONNECTION_MODEM           0x01
#define RAS_INTERNET_CONNECTION_LAN             0x02
#define RAS_INTERNET_CONNECTION_PROXY           0x04
#define RAS_INTERNET_CONNECTION_MODEM_BUSY      0x08  /* no longer used */
#define RAS_INTERNET_RAS_INSTALLED              0x10
#define RAS_INTERNET_CONNECTION_OFFLINE         0x20
#define RAS_INTERNET_CONNECTION_CONFIGURED      0x40

BOOL APIENTRY RasInternetGetConnectedStateExA(
    OUT LPDWORD lpdwFlags,
    OUT LPSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    );


// Taken from WinInet.h

// Custom dial handler prototype
typedef DWORD (FAR PASCAL * PFNCUSTOMDIALHANDLER) (HWND, LPCSTR, DWORD, LPDWORD);

// Flags for custom dial handler
#define INTERNET_CUSTOMDIAL_CONNECT         0
#define INTERNET_CUSTOMDIAL_UNATTENDED      1
#define INTERNET_CUSTOMDIAL_DISCONNECT      2
#define INTERNET_CUSTOMDIAL_SHOWOFFLINE     4

// Custom dial handler supported functionality flags
#define INTERNET_CUSTOMDIAL_SAFE_FOR_UNATTENDED 1
#define INTERNET_CUSTOMDIAL_WILL_SUPPLY_STATE   2
#define INTERNET_CUSTOMDIAL_CAN_HANGUP          4

// Settings for autodial
//
#define RAS_AUTODIAL_OPT_NONE           0x00000000  // No options
#define RAS_AUTODIAL_OPT_NEVER          0x00000001  // Never Autodial
#define RAS_AUTODIAL_OPT_ALWAYS         0x00000002  // Autodial regardless
#define RAS_AUTODIAL_OPT_DEMAND         0x00000004  // Autodial on demand
#define RAS_AUTODIAL_OPT_NOPROMPT       0x00000010  // Dial without prompting

DWORD      WINAPI RnaGetDefaultAutodialConnection(LPBYTE lpBuf, DWORD cb, LPDWORD lpdwOptions);
DWORD      WINAPI RnaSetDefaultAutodialConnection(LPSTR szEntry, DWORD dwOptions);

// Auto disconnect managment

typedef struct  tagAutoDisInfo {
    DWORD       dwSize;
    BOOL        fIdleDisPromptDisabled;
    BOOL        fDisconnectOnExit;
    DWORD       dwIdleTimeoutSec;  // Auto disconnect time, 0 = disabled
} AUTODISINFO, *PAUTODISINFO, FAR* LPAUTODISINFO;


DWORD NEAR PASCAL RnaGetAutoDisconnectInfoA (
    LPSTR   lpszPhonebook,      
    LPSTR        szEntry,       
    LPAUTODISINFO lpadi);
    
DWORD NEAR PASCAL RnaSetAutoDisconnectInfoA (
    LPSTR   lpszPhonebook,      
    LPSTR        szEntry,       
    LPAUTODISINFO lpadi);


#ifdef UNICODE
#define RasInternetDial                 RasInternetDialW
#define RasRegisterAutodialCallback     RasRegisterAutodialCallbackW
#define RasUnregisterAutodialCallback   RasUnregisterAutodialCallbackW
#define RasInternetAutodial             RasInternetAutodialW
#define RasInternetAutodialHangUp       RasInternetAutodialHangUpW
#define RasInternetHangUp               RasInternetUpW
#define RasInternetGetConnectedStateEx  RasInternetGetConnectedStateExW
#else
#define RasInternetDial                 RasInternetDialA
#define RasRegisterAutodialCallback     RasRegisterAutodialCallbackA
#define RasUnregisterAutodialCallback   RasUnregisterAutodialCallbackA
#define RasInternetAutodial             RasInternetAutodialA
#define RasInternetAutodialHangUp       RasInternetAutodialHangUpA
#define RasInternetHangUp               RasInternetHangUpA
#define RasInternetGetConnectedStateEx  RasInternetGetConnectedStateExA
#endif


#endif // _AUTODIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\parseurl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.cxx

Abstract:

    Contains functions to parse the basic URLs - FTP, Gopher, HTTP.

    An URL parser simply acts as a macro: it must break out the protocol-specific
    information from the URL and initiate opening the identified resource: all
    this can be accomplished by calling the relevant Internet protocol APIs.

    Code in this module is based on RFC1738

    Contents:
        IsValidUrl
        DoesSchemeRequireSlashes
        ParseUrl
        CrackUrl
        EncodeUrlPath
        (HexCharToNumber)
        (NumberToHexChar)
        DecodeUrl
        DecodeUrlInSitu
        DecodeUrlStringInSitu
        GetUrlAddressInfo
        GetUrlAddress
        MapUrlSchemeName
        MapUrlScheme
        MapUrlSchemeToName

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Apr-1995
        Created

--*/

#include <wininetp.h>
#include "autodial.h"

//
// private manifests
//

#define RESERVED    SAFE

//
// private macros
//

//#define HEX_CHAR_TO_NUMBER(ch) \
//    ((ch <= '9') \
//        ? (ch - '0') \
//        : ((ch >= 'a') \
//            ? ((ch - 'a') + 10) \
//            : ((ch - 'A') + 10)))

#define NUMBER_TO_HEX_CHAR(n) \
    (((n) <= 9) ? ((char)(n) + '0') : (((char)(n) - 10) + 'A'))

#define IS_UNSAFE_URL_CHARACTER(Char, Scheme) \
    (((UCHAR)(Char) <= 0x20) || ((UCHAR)(Char) >= 0x7f) \
    || (SafetyList[(Char) - 0x21] & (UNSAFE | Scheme)))

//
// private types
//

//
// private prototypes
//

PRIVATE
char
HexCharToNumber(
    IN char ch
    );

PRIVATE
char
NumberToHexChar(
    IN int Number
    );

PRIVATE
DWORD
ParseFileUrl(
    IN OUT LPHINTERNET lphInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );


//
// private data
//

//
// SafetyList - the list of characters above 0x20 and below 0x7f that are
// classified as safe, unsafe or scheme-specific. Safe characters do not need
// to be escaped for any URL scheme. Unsafe characters must be escaped for all
// URL schemes. Scheme-specific characters need only be escaped for the relevant
// scheme(s)
//

PRIVATE
const
UCHAR
SafetyList[] = {

    //
    // UNSAFE: 0x00..0x20
    //

    SAFE,                       // 0x21 (!)
    UNSAFE,                     // 0x22 (")
    UNSAFE,                     // 0x23 (#)
    SAFE,                       // 0x24 ($)
    UNSAFE,                     // 0x25 (%)
    RESERVED,                   // 0x26 (&)
    SAFE,                       // 0x27 (')
    SAFE,                       // 0x28 (()
    SAFE,                       // 0x29 ())
    SAFE,                       // 0x2A (*)
    SCHEME_GOPHER,              // 0x2B (+)
    SAFE,                       // 0x2C (,)
    SAFE,                       // 0x2D (-)
    SAFE,                       // 0x2E (.)
    RESERVED,                   // 0x2F (/)
    SAFE,                       // 0x30 (0)
    SAFE,                       // 0x31 (1)
    SAFE,                       // 0x32 (2)
    SAFE,                       // 0x33 (3)
    SAFE,                       // 0x34 (4)
    SAFE,                       // 0x35 (5)
    SAFE,                       // 0x36 (6)
    SAFE,                       // 0x37 (7)
    SAFE,                       // 0x38 (8)
    SAFE,                       // 0x39 (9)
    RESERVED,                   // 0x3A (:)
    RESERVED,                   // 0x3B (;)
    UNSAFE,                     // 0x3C (<)
    RESERVED,                   // 0x3D (=)
    UNSAFE,                     // 0x3E (>)
    RESERVED | SCHEME_GOPHER,   // 0x3F (?)
    RESERVED,                   // 0x40 (@)
    SAFE,                       // 0x41 (A)
    SAFE,                       // 0x42 (B)
    SAFE,                       // 0x43 (C)
    SAFE,                       // 0x44 (D)
    SAFE,                       // 0x45 (E)
    SAFE,                       // 0x46 (F)
    SAFE,                       // 0x47 (G)
    SAFE,                       // 0x48 (H)
    SAFE,                       // 0x49 (I)
    SAFE,                       // 0x4A (J)
    SAFE,                       // 0x4B (K)
    SAFE,                       // 0x4C (L)
    SAFE,                       // 0x4D (M)
    SAFE,                       // 0x4E (N)
    SAFE,                       // 0x4F (O)
    SAFE,                       // 0x50 (P)
    SAFE,                       // 0x51 (Q)
    SAFE,                       // 0x42 (R)
    SAFE,                       // 0x43 (S)
    SAFE,                       // 0x44 (T)
    SAFE,                       // 0x45 (U)
    SAFE,                       // 0x46 (V)
    SAFE,                       // 0x47 (W)
    SAFE,                       // 0x48 (X)
    SAFE,                       // 0x49 (Y)
    SAFE,                       // 0x5A (Z)
    UNSAFE,                     // 0x5B ([)
    UNSAFE,                     // 0x5C (\)
    UNSAFE,                     // 0x5D (])
    UNSAFE,                     // 0x5E (^)
    SAFE,                       // 0x5F (_)
    UNSAFE,                     // 0x60 (`)
    SAFE,                       // 0x61 (a)
    SAFE,                       // 0x62 (b)
    SAFE,                       // 0x63 (c)
    SAFE,                       // 0x64 (d)
    SAFE,                       // 0x65 (e)
    SAFE,                       // 0x66 (f)
    SAFE,                       // 0x67 (g)
    SAFE,                       // 0x68 (h)
    SAFE,                       // 0x69 (i)
    SAFE,                       // 0x6A (j)
    SAFE,                       // 0x6B (k)
    SAFE,                       // 0x6C (l)
    SAFE,                       // 0x6D (m)
    SAFE,                       // 0x6E (n)
    SAFE,                       // 0x6F (o)
    SAFE,                       // 0x70 (p)
    SAFE,                       // 0x71 (q)
    SAFE,                       // 0x72 (r)
    SAFE,                       // 0x73 (s)
    SAFE,                       // 0x74 (t)
    SAFE,                       // 0x75 (u)
    SAFE,                       // 0x76 (v)
    SAFE,                       // 0x77 (w)
    SAFE,                       // 0x78 (x)
    SAFE,                       // 0x79 (y)
    SAFE,                       // 0x7A (z)
    UNSAFE,                     // 0x7B ({)
    UNSAFE,                     // 0x7C (|)
    UNSAFE,                     // 0x7D (})
    UNSAFE                      // 0x7E (~)

    //
    // UNSAFE: 0x7F..0xFF
    //

};

//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD SchemeFlags;
    BOOL NeedSlashes;
    LPFN_URL_PARSER SchemeParser;
    DWORD OpenFlags;
} URL_SCHEME_INFO;


PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,           0,  INTERNET_SCHEME_DEFAULT,    0,              FALSE,  NULL,           0,
    "ftp",          3,  INTERNET_SCHEME_FTP,        SCHEME_FTP,     TRUE,   ParseFtpUrl,    0,
    "gopher",       6,  INTERNET_SCHEME_GOPHER,     SCHEME_GOPHER,  TRUE,   ParseGopherUrl, 0,
    "http",         4,  INTERNET_SCHEME_HTTP,       SCHEME_HTTP,    TRUE,   ParseHttpUrl,   0,
    "https",        5,  INTERNET_SCHEME_HTTPS,      SCHEME_HTTP,    TRUE,   ParseHttpUrl,   INTERNET_FLAG_SECURE,
    "file",         4,  INTERNET_SCHEME_FILE,       0,              TRUE,   ParseFileUrl,   0,
    "news",         4,  INTERNET_SCHEME_NEWS,       0,              FALSE,  NULL,           0,
    "mailto",       6,  INTERNET_SCHEME_MAILTO,     0,              FALSE,  NULL,           0,
    "socks",        5,  INTERNET_SCHEME_SOCKS,      0,              FALSE,  NULL,           0,
    "javascript",   10, INTERNET_SCHEME_JAVASCRIPT, 0,              FALSE,  NULL,           0,
    "vbscript",     8,  INTERNET_SCHEME_VBSCRIPT,   0,              FALSE,  NULL,           0,
    "res",          3,  INTERNET_SCHEME_RES,        0,              TRUE,   NULL,           0
};


// For handling escaping chars in authority component in URL

#define SHOULD_ESCAPE_AUTHORITY(Char) \
    (((UCHAR)(Char) <= 0x20) || ((UCHAR)(Char) >= 0x7f) \
    || (AuthorityEscapeList[(Char) - 0x21] == AEL_ESC))

#define AEL_OK  0 // char OK in authority component in URL
#define AEL_ESC 1 // char should be escaped in authority component in URL

// The list of characters to escape in the authority component 
// of a URI.  Essentially RFC2396 "userinfo" chars minus "authority
// reserved" chars.

PRIVATE
const
UCHAR
AuthorityEscapeList[] = {
    //
    // AEL_ESC: 0x00..0x20
    //
    AEL_OK,  // 0x21 (!) userinfo, unreserved, mark
    AEL_ESC, // 0x22 (") delims
    AEL_ESC, // 0x23 (#) delims
    AEL_OK,  // 0x24 ($) userinfo, reserved
    AEL_ESC, // 0x25 (%) delims
    AEL_OK,  // 0x26 (&) userinfo, reserved
    AEL_OK,  // 0x27 (') userinfo, unreserved, mark
    AEL_OK,  // 0x28 (() userinfo, unreserved, mark
    AEL_OK,  // 0x29 ()) userinfo, unreserved, mark
    AEL_OK,  // 0x2A (*) userinfo, unreserved, mark
    AEL_OK,  // 0x2B (+) userinfo, reserved
    AEL_OK,  // 0x2C (,) userinfo, reserved
    AEL_OK,  // 0x2D (-) userinfo, unreserved, mark
    AEL_OK,  // 0x2E (.) userinfo, unreserved, mark
    AEL_ESC, // 0x2F (/) reserved, authority reserved
    AEL_OK,  // 0x30 (0) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x31 (1) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x32 (2) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x33 (3) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x34 (4) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x35 (5) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x36 (6) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x37 (7) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x38 (8) userinfo, unreserved, alphanum, digit
    AEL_OK,  // 0x39 (9) userinfo, unreserved, alphanum, digit
    AEL_ESC, // 0x3A (:) userinfo, authority reserved
    AEL_OK,  // 0x3B (;) userinfo, reserved
    AEL_ESC, // 0x3C (<) delim
    AEL_OK,  // 0x3D (=) userinfo, reserved
    AEL_ESC, // 0x3E (>) delim
    AEL_ESC, // 0x3F (?) reserved, authority reserved
    AEL_ESC, // 0x40 (@) reserved, authority reserved
    AEL_OK,  // 0x41 (A) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x42 (B) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x43 (C) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x44 (D) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x45 (E) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x46 (F) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x47 (G) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x48 (H) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x49 (I) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x4A (J) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x4B (K) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x4C (L) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x4D (M) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x4E (N) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x4F (O) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x50 (P) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x51 (Q) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x42 (R) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x43 (S) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x44 (T) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x45 (U) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x46 (V) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x47 (W) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x48 (X) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x49 (Y) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_OK,  // 0x5A (Z) userinfo, unreserved, alphanum, alpha, upalpha
    AEL_ESC, // 0x5B ([) unwise
    AEL_ESC, // 0x5C (\) unwise
    AEL_ESC, // 0x5D (]) unwise
    AEL_ESC, // 0x5E (^) unwise
    AEL_OK,  // 0x5F (_) unreserved, mark 
    AEL_ESC, // 0x60 (`) unwise
    AEL_OK,  // 0x61 (a) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x62 (b) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x63 (c) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x64 (d) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x65 (e) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x66 (f) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x67 (g) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x68 (h) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x69 (i) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x6A (j) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x6B (k) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x6C (l) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x6D (m) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x6E (n) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x6F (o) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x70 (p) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x71 (q) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x72 (r) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x73 (s) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x74 (t) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x75 (u) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x76 (v) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x77 (w) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x78 (x) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x79 (y) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_OK,  // 0x7A (z) userinfo, unreserved, alphanum, alpha, lowalpha
    AEL_ESC, // 0x7B ({) unwise
    AEL_ESC, // 0x7C (|) unwise
    AEL_ESC, // 0x7D (}) unwise
    AEL_OK   // 0x7E (~) unreserved, mark
    //
    // AEL_ESC: 0x7F..0xFF
    //
};


#define NUMBER_OF_URL_SCHEMES   ARRAY_ELEMENTS(UrlSchemeList)

BOOL ScanSchemes(LPTSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (strnicmp(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

//
// functions
//


BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Determines whether an URL has a valid format

Arguments:

    lpszUrl - pointer to URL to check.

    Assumes:    1. lpszUrl is non-NULL, non-empty string

Return Value:

    BOOL

--*/

{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');

    while (*lpszUrl != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszUrl, SCHEME_ANY)) {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}

BOOL IsValidHostName(IN LPCSTR lpszUrl, IN DWORD dwLength)
{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');
    INET_ASSERT(dwLength != '\0');

    while (*lpszUrl != '\0' && dwLength--) 
    {
        if (((UCHAR)(*lpszUrl) < 0x20))
        {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}


BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    )

/*++

Routine Description:

    Determines whether a protocol scheme requires slashes

Arguments:

    lpszScheme      - pointer to protocol scheme in question
                      (does not include ':' or slashes, just scheme name)

    dwUrlLength     - if not 0, string length of lpszScheme

Return Value:

    BOOL

--*/

{
    DWORD i;

    //
    // if dwSchemeLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwSchemeLength == 0) {
        dwSchemeLength = strlen(lpszScheme);
    }

    if (ScanSchemes(lpszScheme, dwSchemeLength, &i))
    {
        return UrlSchemeList[i].NeedSlashes;
    }
    return bHasHostName;
}



PRIVATE
DWORD
ParseFileUrl(
    IN OUT LPHINTERNET lphInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    )

/*++

Routine Description:

    URL parser for generic File URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls Win32 File APIs to
    do the work

Arguments:

    lphInternet     - IN: pointer to InternetOpen handle
                      OUT: if successful handle of opened item, else undefined

    Url             - pointer to string containing FTP URL to open

    SchemeLength    - length of the URL scheme, exluding "://"

    Headers         - unused for FTP

    HeadersLength   - unused for FTP

    OpenFlags       - optional flags for opening a file (cache/no-cache, etc.)

    Context         - app-supplied context value for call-backs

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Dword,
                 "ParseFileUrl",
                 "%#x [%#x], %q, %d, %#x, %d, %#x, %#x",
                 lphInternet,
                 *lphInternet,
                 Url,
                 SchemeLength,
                 Headers,
                 HeadersLength,
                 OpenFlags,
                 Context
                 ));

    UNREFERENCED_PARAMETER(Headers);
    UNREFERENCED_PARAMETER(HeadersLength);


    DWORD urlLength;
    DWORD error = ERROR_SUCCESS;
    HINTERNET hInternetMapped = NULL;
    HANDLE hFileHandle;
    INTERNET_FILE_HANDLE_OBJECT *pFileHandleObj;

    //
    // parse "file://" component of the Url.
    //

    Url += SchemeLength + sizeof("://") - 1;

    //
    // BUGBUG - this function should receive the handle already mapped
    //

    error = MapHandleToAddress(*lphInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    INET_ASSERT(hInternetMapped != NULL);

    hFileHandle = CreateFile( Url,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL, // security attributes
                              OPEN_EXISTING,
                              FILE_FLAG_SEQUENTIAL_SCAN/*FILE_ATTRIBUTE_NORMAL*/,
                              NULL // handle to file attributes
                              );

    if ( hFileHandle == INVALID_HANDLE_VALUE)
    {
        error = GetLastError();
        goto quit;
    }

    pFileHandleObj = new INTERNET_FILE_HANDLE_OBJECT(
                                (INTERNET_HANDLE_OBJECT *)hInternetMapped,
                                Url,
                                hFileHandle,
                                OpenFlags,
                                Context
                                );

    if ( pFileHandleObj == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Link File Handle object to Internet Open handle.
    //

    RSetParentHandle(pFileHandleObj, hInternetMapped, FALSE);

    //
    // return the new file handle
    //

    *lphInternet = pFileHandleObj->GetPseudoHandle();

quit:

    if ( hInternetMapped != NULL )
    {
        DereferenceObject((LPVOID)hInternetMapped);
    }

    DEBUG_LEAVE(error);

    return error;
}

DWORD
CFsm_ParseUrlForHttp::ScanProxyUrl(
    IN CFsm_ParseUrlForHttp * Fsm
    )
/*++

Routine Description:

    Attempts to Determine what Protocol should be used for a given
      navigation on an URL, maps the scheme (FTP, HTTP, etc) to
      protocol parser

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/


{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "ScanProxyUrl",
                 "%#x",
                 Fsm
                 ));

    CFsm_ParseUrlForHttp & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    //
    // get parser based on the protocol name
    //

    for (fsm.m_dwSchemeLength = 0; fsm.m_lpcszUrl[fsm.m_dwSchemeLength] != ':'; ++fsm.m_dwSchemeLength) {
        if (fsm.m_lpcszUrl[fsm.m_dwSchemeLength] == '\0') {

            //
            // no ':' in URL
            //

            error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
            goto quit;
        }
    }

    DWORD i;

    if (ScanSchemes((LPSTR)fsm.m_lpcszUrl, fsm.m_dwSchemeLength, &i))
    {
        fsm.m_SchemeType = UrlSchemeList[i].SchemeType;
        fsm.m_dwFlags   |= UrlSchemeList[i].OpenFlags;
        fsm.m_pUrlParser = UrlSchemeList[i].SchemeParser;
    }

    //
    // we are only supporting Internet URL schemes, so the next token in the
    // URL should be "://"
    //

    if ((fsm.m_pUrlParser == NULL) ||
        (memcmp(&fsm.m_lpcszUrl[fsm.m_dwSchemeLength], "://", 3) != 0))
    {
        error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
        goto quit;
    }


    //
    // allocate a new URL that can be overwritten by the parsers (to avoid
    // having to allocate buffers/use stack buffers for the various sub-
    // strings contained within the URL)
    //

    fsm.m_lpszUrlCopy = NEW_STRING((LPSTR)fsm.m_lpcszUrl);
    if (fsm.m_lpszUrlCopy == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ParseUrlForHttp::BuildProxyMessage(
    IN CFsm_ParseUrlForHttp * Fsm
    )

/*++

Routine Description:

    Assembles the necessary parsed URL info that will be used
      for resolving and requesting proxy info

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DWORD error = ERROR_SUCCESS;

    CFsm_ParseUrlForHttp & fsm = *Fsm;

    LPSTR currentUrl;
    DWORD currentUrlLength;
    INTERNET_SCHEME currentScheme;
    LPSTR currentHostName;
    DWORD currentHostNameLength;
    INTERNET_PORT currentHostNamePort;

    //
    // Gather the URL off the handle
    //

    currentUrl = (LPSTR) fsm.m_lpcszUrl;
    currentUrlLength = lstrlen(currentUrl);

    //
    // crack the current URL
    //

    error = CrackUrl(currentUrl,
                     currentUrlLength,
                     FALSE, // don't escape URL-path
                     &currentScheme,
                     NULL,  // don't care about Scheme Name
                     NULL,
                     &currentHostName,
                     &currentHostNameLength,
                     &currentHostNamePort,
                     NULL,  // don't care about user name
                     NULL,
                     NULL,  // or password
                     NULL,
                     NULL,
                     NULL,
                     NULL,  // no extra
                     NULL,
                     NULL
                     );

    if ( error == ERROR_SUCCESS )
    {
        fsm.m_pProxyInfoQuery->SetProxyMsg(
            currentScheme,
            currentUrl,
            currentUrlLength,
            currentHostName,
            currentHostNameLength,
            currentHostNamePort
            );
    }

    return error;
}

DWORD
CFsm_ParseUrlForHttp::QueryProxySettings(
    IN CFsm_ParseUrlForHttp * Fsm,
    IN BOOL fCallback
    )
/*++

Routine Description:

    Calls internal proxy methods to determine what
     proxy (if any) a given request should use

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DWORD error = ERROR_SUCCESS;

    CFsm_ParseUrlForHttp & fsm = *Fsm;
    INTERNET_HANDLE_OBJECT * pMapped = (INTERNET_HANDLE_OBJECT *)fsm.m_hInternetMapped;

    if ( ! fCallback ) {
        fsm.m_pProxyInfoQuery->SetBlockUntilCompletetion(TRUE);
    }

    error = pMapped->GetProxyInfo(
                &fsm.m_pProxyInfoQuery
                );

    if ( error != ERROR_SUCCESS ) {
        goto quit;
    }

    if ( fsm.m_pProxyInfoQuery->IsUseProxy() &&
          (fsm.m_pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_HTTP ||
           fsm.m_pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_DEFAULT))
    {
        fsm.m_pUrlParser = ParseHttpUrl;
    }

quit:

    return error;
}


DWORD
CFsm_ParseUrlForHttp::CompleteParseUrl(
    IN CFsm_ParseUrlForHttp * Fsm,
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD error
    )

/*++

Routine Description:

    Handles the return code path after a protcol parser is
        called.  Needs to patch up ref counts and handle
        Html Handle types.

Arguments:

    Fsm - Containing the current request info
    lpThreadInfo - thread info
    error - Current error code in the parser

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    HINTERNET hUrlMapped = NULL;
    CFsm_ParseUrlForHttp & fsm = *Fsm;

    //
    // use our handle value in case the caller doesn't expect the input
    // handle to be modified
    //

    if (error == ERROR_SUCCESS) {

        //
        // map the new URL (Ftp,Gopher,etc) handle
        //

        error = MapHandleToAddress(fsm.m_hInternet, (LPVOID *)&hUrlMapped, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // we successfully created the handle object. If we are to return
        // HTML data (default) for this handle then we need to modify the
        // handle object to be the correct type
        //

        if ((fsm.m_pUrlParser != ParseHttpUrl) &&
           !(fsm.m_dwFlags & INTERNET_FLAG_RAW_DATA)) {

            DWORD handleError;

            //
            // RSetHtmlHandleType() does the right thing - it will set the
            // handle object to be HTML if the handle object is of a type
            // which can be set to HTML. Otherwise it will return an error
            //

            handleError = RSetHtmlHandleType(hUrlMapped);

            //
            // if ERROR_INTERNET_INVALID_OPERATION is returned then that is
            // OK, it just means the handle is not a type that we can convert
            // to HTML. Subsequent calls to InternetReadFile() will go the
            // normal route
            //

            if (handleError != ERROR_INTERNET_INVALID_OPERATION) {
                error = handleError;

                INET_ASSERT((error == ERROR_SUCCESS) || (error == ERROR_INVALID_HANDLE));

                //
                // if we successfully set the HTML handle type then we need
                // to associate the URL with the handle - we need the URL
                // when we create the HTML document in InternetReadFile().
                // RSetUrl() will create a copy of the URL and attach it to
                // the handle object
                //

                if (error == ERROR_SUCCESS) {
                    error = RSetUrl(hUrlMapped, (LPSTR)fsm.m_lpszUrlCopy);

                    INET_ASSERT(error == ERROR_SUCCESS);
                }
            }
        }

        //
        // BUGBUG - we may have some cleaning up to do if RSetHtmlHandleType()
        //          returns ERROR_INVALID_HANDLE (couldn't happen!) or if
        //          RSetUrl() fails (also couldn't happen!)
        //

    }

    //
    // Non-HTTP based parsers can sometimes polute the thread info
    //  structure with the wrong handle value (i.e. they may leave a Find handle,
    //   instead of the internet handle)
    //

    if (lpThreadInfo->IsAsyncWorkerThread)
    {
        _InternetSetObjectHandle(lpThreadInfo, fsm.m_hInternetCopy, fsm.m_hInternetMapped);
        _InternetSetContext(lpThreadInfo, fsm.m_dwContext);
    }

quit:

    if (hUrlMapped != NULL) {
        DereferenceObject((LPVOID)hUrlMapped);
    }

    return error;
}


#ifdef EXTENDED_ERROR_HTML
#error Not completed
DWORD
CFsm_ParseUrlForHttp::ExtendedErrorHtml(
    DWORD error
    )
{
    //
    // if we got extended error info AND we requested an FTP entity AND
    // we are not returning raw data then we will return the error info
    // as HTML. We need to generate a handle for this info
    //

    if ((error == ERROR_INTERNET_EXTENDED_ERROR)
    && !(OpenFlags & INTERNET_FLAG_RAW_DATA)
    && (protocolScheme == INTERNET_SCHEME_FTP)) {

        //
        // first we have to create a dummy connect handle object
        //

        HINTERNET hConnect = NULL;

        InternetSetObjectHandle(pMapped->GetPseudoHandle(), hMapped);
        InternetSetContext(INTERNET_NO_CALLBACK);
        error = RMakeInternetConnectObjectHandle(
            pMapped,
            &hConnect,
            NULL,                   // close function
            //hostName,               // server name
            NULL,
            0,                      // server port
            NULL,                   // user name
            NULL,                   // password
            INTERNET_SERVICE_FTP,
            0,                      // flags
            INTERNET_NO_CALLBACK    // context
            );
        if (error == ERROR_SUCCESS) {
            InternetSetObjectHandle(
                ((HANDLE_OBJECT *)hConnect)->GetPseudoHandle(),
                hConnect
                );
            InternetSetContext(Context);
            error = RMakeFtpErrorObjectHandle(hConnect, hInternet);
        }

        //
        // if we failed to generate the handle then just return the
        // original error & let the caller sort it out
        //

        if (error == ERROR_SUCCESS) {

            //
            // link child & parent so that InternetCloseHandle() on the
            // child (error) handle also derefs the parent (connect)
            // handle
            //

            RSetParentHandle(*hInternet, hConnect, TRUE);

            //
            // return the pseudo handle, not the object address
            //

            *hInternet = ((HANDLE_OBJECT *)(*hInternet))->GetPseudoHandle();
        } else {
            if (hConnect != NULL) {
                _InternetCloseHandleNoContext(
                    ((HANDLE_OBJECT *)hConnect)->GetPseudoHandle()
                    );
            }
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
    }
}
#endif // def EXTENDED_ERROR_HTML





DWORD
CFsm_ParseUrlForHttp::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ParseUrlForHttp::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ParseUrlForHttp * stateMachine = (CFsm_ParseUrlForHttp *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ParseUrlForHttp_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
ParseUrlForHttp_Fsm(
    IN CFsm_ParseUrlForHttp * Fsm
    )

/*++

Routine Description:

    The Root FSM that handles HTTP, FTP, and all other protcols
        for InternetOpenUrl

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "ParseUrlForHttp_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ParseUrlForHttp & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL fOnApiCall = fsm.IsOnApiCall(); // Is the API on the stack?

    AUTO_PROXY_ASYNC_MSG proxyInfoQuery;
    DWORD schemeLength;
    INTERNET_SCHEME protocolScheme;
    INTERNET_HANDLE_OBJECT * pMapped = (INTERNET_HANDLE_OBJECT *)fsm.m_hInternetMapped;

    fsm.ClearOnApiCall();

    if (fsm.IsInvalid()) {
        goto quit;
    }

    if (state != FSM_STATE_INIT)
    {
        state = fsm.GetFunctionState();
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    switch (state)
    {
        case FSM_STATE_INIT:
        case FSM_STATE_1:
            {
                fsm.SetFunctionState(FSM_STATE_1);

                error = fsm.ScanProxyUrl(Fsm);

                if ( error != ERROR_SUCCESS) {
                    goto quit;
                }

                fsm.m_pProxyInfoQuery = &proxyInfoQuery;

                error = fsm.BuildProxyMessage(Fsm);

                if ( error != ERROR_SUCCESS ) {
                    goto quit;
                }


                if (fsm.m_pUrlParser == ParseFileUrl)
                {
                    LPFN_URL_PARSER parser = fsm.m_pUrlParser;

                    //
                    // call the FILE Parser right away
                    //

                    error = parser(&fsm.m_hInternet,
                                   fsm.m_lpszUrlCopy,
                                   fsm.m_dwSchemeLength,
                                   (LPSTR)fsm.m_lpcszHeaders,
                                   fsm.m_dwHeadersLength,
                                   fsm.m_dwFlags,
                                   fsm.m_dwContext
                                   );
                    goto quit;
                }

                if(0 == (pMapped->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE))
                {
                    InternetAutodialIfNotLocalHost(fsm.m_lpszUrlCopy, NULL);
                }

                fsm.SetFunctionState(FSM_STATE_2);
                error = fsm.QueryProxySettings(Fsm, FALSE);
                if ( error != ERROR_SUCCESS ) {
                    goto quit;
                } else {
                    fsm.SetFunctionState(FSM_STATE_3);
                }

                // fall through...
            }

        case FSM_STATE_2:
            {
                if ( fsm.GetFunctionState() == FSM_STATE_2 ) {
                    fsm.SetFunctionState(FSM_STATE_3);
                    error = fsm.QueryProxySettings(Fsm, TRUE);
                    if ( error != ERROR_SUCCESS ) {
                        goto quit;
                    }
                }

                // fall through...
            }

        case FSM_STATE_3:
            {

                fsm.SetFunctionState(FSM_STATE_4);

                if ( fsm.m_pUrlParser == ParseHttpUrl)
                {
                    DWORD dwFlags = fsm.m_dwFlags;

                    //
                    // call the protocol-specific parser to open the entity identified
                    // by the URL
                    //

                    fsm.SetBlocking(FALSE);
                    _InternetIncNestingCount();

                    if  (dwFlags & INTERNET_FLAG_RESYNCHRONIZE
                        && (fsm.m_pProxyInfoQuery->GetUrlScheme() == INTERNET_SCHEME_FTP
                        ||  fsm.m_pProxyInfoQuery->GetUrlScheme() == INTERNET_SCHEME_GOPHER)) {

                        //
                        // For ftp and gopher via proxy, there is no if-modified-since,
                        // so we force a reload, otherwise proxy may serve stale data.
                        //

                        dwFlags |= INTERNET_FLAG_RELOAD;
                    }

                    //
                    // remove local proxy info, before going pending
                    //

                    if ( !fsm.m_pProxyInfoQuery->IsAlloced()) {
                        fsm.m_pProxyInfoQuery = NULL;
                    }

                    error = DoFsm(new CFsm_ParseHttpUrl(&fsm.m_hInternet,
                                                        fsm.m_lpszUrlCopy,
                                                        fsm.m_dwSchemeLength,
                                                        (LPSTR)fsm.m_lpcszHeaders,
                                                        fsm.m_dwHeadersLength,
                                                        dwFlags,
                                                        fsm.m_dwContext
                                                        ));
                    _InternetDecNestingCount(1);
                    if (error == ERROR_IO_PENDING) {
                        goto quit;
                    }
                }
                else if (fsm.m_pUrlParser != NULL)
                {
                    LPFN_URL_PARSER parser = fsm.m_pUrlParser;

                    fsm.SetBlocking(TRUE);
                    _InternetIncNestingCount();

                    //
                    // call the protocol-specific parser to open the entity identified
                    // by the URL
                    //

                    error = parser(&fsm.m_hInternet,
                                   fsm.m_lpszUrlCopy,
                                   fsm.m_dwSchemeLength,
                                   (LPSTR)fsm.m_lpcszHeaders,
                                   fsm.m_dwHeadersLength,
                                   fsm.m_dwFlags,
                                   fsm.m_dwContext
                                   );

#ifdef EXTENDED_ERROR_HTML
                    error = fsm.ExtendedErrorHtml(Fsm, error);
#endif
                    _InternetDecNestingCount(1);

                    //if ( error != ERROR_SUCCESS ) {
                    //    goto quit;
                    //}

                }
                else
                {
                    error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
                }
            }

        case FSM_STATE_4:
            {

                error = fsm.CompleteParseUrl(Fsm, lpThreadInfo, error);

                //
                // and free the copy of the URL
                //

                if ( fsm.m_lpszUrlCopy ) {
                    DEL_STRING(fsm.m_lpszUrlCopy);
                }

                //if (fsm.m_pProxyState) {
                //    if (pMapped->RedoSendRequest(&error, fsm.m_pProxyState)) {
                //        fsm.SetNextState(FSM_STATE_INIT);
                //        goto retry_with_different_proxy;
                //    }
                //    fsm.m_pProxyState = NULL;
                //}
            }

    } // end of switch(state)
quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        if ( fsm.m_pProxyInfoQuery &&
             fsm.m_pProxyInfoQuery->IsAlloced() )
        {
            delete fsm.m_pProxyInfoQuery;
            fsm.m_pProxyInfoQuery = NULL;
        }

        fsm.m_pProxyInfoQuery = NULL;  // just in case

        if (fsm.m_pProxyState) {
            delete fsm.m_pProxyState;
        }

        //
        // only deref hInternet if we are in sync mode, otherwise it is done in
        // async request completion
        //
        // BUGBUG - RLF 05/17/97
        //
        // Need to fix this - it is confusing and error-prone. Right fix is to
        // do like old async code does - additional ref when starting async
        // request && additional deref when completing async processing
        //

        if (!fOnApiCall &&
            (fsm.m_hInternetMapped != NULL))
        {
            fsm.m_hInternetMapped = NULL;
        }
        if (error == ERROR_SUCCESS) {
            if (fsm.GetThreadInfo()->IsAsyncWorkerThread) {

                //
                // async request - return handle in FSM - lphInternet points
                // into app thread's stack - original request completed with
                // pending so we can't return it there
                //

                fsm.SetApiResult(fsm.m_hInternet);
            } else {

                //
                // sync request - app thread's stack is still there so we are
                // safe to return the handle through the pointer
                //

                *fsm.m_lphInternet = fsm.m_hInternet;
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error;
    DWORD schemeLength;
    INTERNET_SCHEME schemeType;

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = strlen(lpszUrl);
    }

    //
    // get parser based on the protocol name
    //

    for (schemeLength = 0; lpszUrl[schemeLength] != ':'; ++schemeLength) {
        if ((dwUrlLength == 0) || (lpszUrl[schemeLength] == '\0')) {

            //
            // no ':' in URL? Bogus (dude)
            //

            error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
            goto quit;
        }
        --dwUrlLength;
    }

    DWORD i;
    int skip;
    BOOL isGeneric;
    BOOL needSlashes;
    BOOL haveSlashes;

    isGeneric = FALSE;
    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = INTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(lpszUrl, schemeLength, &i))
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength > 3) && (memcmp(&lpszUrl[schemeLength], "://", 3) == 0)) {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    if (schemeType == INTERNET_SCHEME_FILE)
        isGeneric = TRUE;

    if (schemeType == INTERNET_SCHEME_NEWS ||
        schemeType == INTERNET_SCHEME_UNKNOWN) {

        //
        //  urls can be hierarchical or opaque.  if the slashes
        //  exist, then we should assume hierarchical
        //  when we dont know the scheme or it is news:.
        //  otherwise it is opaque (isGeneric)
        //

        needSlashes = haveSlashes;
        isGeneric = !haveSlashes;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if ((!haveSlashes && !needSlashes) || (haveSlashes && needSlashes)) {
        if (ARGUMENT_PRESENT(lpSchemeType)) {
            *lpSchemeType = schemeType;
        }
        if (ARGUMENT_PRESENT(lpszSchemeName)) {
            *lpszSchemeName = lpszUrl;
            *lpdwSchemeNameLength = schemeLength;
        }
        lpszUrl += schemeLength + skip;
        dwUrlLength -= skip;

        if (INTERNET_SCHEME_RES == schemeType) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            PTSTR psz = lpszUrl;
            while (*lpszUrl && *lpszUrl!='/')
                lpszUrl++;

            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = psz;
                *lpdwHostNameLength = PtrDiff32(lpszUrl, psz);
                dwUrlLength -= *lpdwHostNameLength;
                error = DecodeUrlInSitu(*lpszHostName, lpdwHostNameLength);
           }
        } else if (isGeneric) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = NULL;
                *lpdwHostNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            error = ERROR_SUCCESS;
        } else {
            error = GetUrlAddress(&lpszUrl,
                                  &dwUrlLength,
                                  lpszUserName,
                                  lpdwUserNameLength,
                                  lpszPassword,
                                  lpdwPasswordLength,
                                  lpszHostName,
                                  lpdwHostNameLength,
                                  lpServerPort,
                                  pHavePort
                                  );
        }
        if (bEscape && (error == ERROR_SUCCESS)) {
            error = DecodeUrlInSitu(lpszUrl, &dwUrlLength);
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszExtraInfo)) {
            *lpdwExtraInfoLength = 0;
            for (i = 0; i < (int)dwUrlLength; i++) {
                if (lpszUrl[i] == '?' || lpszUrl[i] == '#') {
                    *lpszExtraInfo = &lpszUrl[i];
                    *lpdwExtraInfoLength = dwUrlLength - i;
                    dwUrlLength -= *lpdwExtraInfoLength;
                }
            }
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszUrlPath)) {
            *lpszUrlPath = lpszUrl;
            *lpdwUrlPathLength = dwUrlLength;
        }
    } else {
        error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

quit:

    return error;
}

DWORD
EncodeAuthorityComponent(
    IN LPSTR Component,
    IN DWORD ComponentLength,
    OUT LPSTR EncodedComponent,
    IN OUT LPDWORD EncodedComponentLength
    )
    /*++
    
    Routine Description:
    
        Encodes username, password, hostname components that are part
        of a URL authority component per RFC 2396.
    
    Arguments:
    
        Component               - pointer to the unescaped string
    
        ComponentLength         - length of unescaped string
    
        EncodedComponent        - pointer to buffer where encoded component
                                  will be written
    
        EncodedComponentLength  - IN: size of EncodedComponent buffer
                                  OUT: length of string written to 
                                  EncodedComponent buffer
    
    Return Value:
    
        DWORD
            Success - ERROR_SUCCESS
    
            Failure - ERROR_INSUFFICIENT_BUFFER
                        EncodedComponentLength not large enough to store 
                        encoded component
    --*/
{
    DWORD error = ERROR_SUCCESS;
    DWORD OutputSpaceRemaining = *EncodedComponentLength;
    DWORD OutputStringLength = 0;
    UCHAR ch;

    while (ComponentLength > 0) 
    {
        // get next char

        ch = (UCHAR)*Component++;
        --ComponentLength;

        // a null char will terminate

        if (ch == '\0')
        {
            break;
        }

        // check char

        if (SHOULD_ESCAPE_AUTHORITY(ch)) 
        {
            // character should be encoded - is there room?
            
            if (OutputSpaceRemaining < 3) 
            {
                error = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            // encode it
            
            *EncodedComponent++ = '%';
            *EncodedComponent++ = NUMBER_TO_HEX_CHAR((int)ch / 16);
            *EncodedComponent++ = NUMBER_TO_HEX_CHAR((int)ch % 16);
            OutputSpaceRemaining -= 3; 
            OutputStringLength += 3;
        } 
        else 
        {
            // no encoding needed - is there room for char?

            if (OutputSpaceRemaining < 1)
            {                
                // char won't fit.
            
                error = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            // output char as is
            
            *EncodedComponent++ = (signed char)ch;
            OutputSpaceRemaining--;
            OutputStringLength++;
        }

    }

    // output terminating null if no error and room for it

    if (error == ERROR_SUCCESS)
    {
        if (OutputSpaceRemaining > 0)
        {
            *EncodedComponent++ = '\0';
            OutputSpaceRemaining--;
            // don't count terminating null in string length
        }
        else
        {
            // no room for null is an error
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    // output encoded string length

    *EncodedComponentLength = OutputStringLength;
    return error;
    
}


DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR EncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    )

/*++

Routine Description:

    Encodes an URL-path. That is, escapes the string. Creates a new URL-path in
    which all the 'unsafe' and reserved characters for this scheme have been
    converted to escape sequences

Arguments:

    Flags                   - controlling expansion

    SchemeFlags             - which scheme we are encoding for -
                              SCHEME_HTTP, etc.

    UrlPath                 - pointer to the unescaped string

    UrlPathLength           - length of Url

    EncodedUrlPath          - pointer to buffer where encoded URL will be
                              written

    EncodedUrlPathLength    - IN: size of EncodedUrlPath
                              OUT: number of bytes written to EncodedUrlPath

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    UrlPathLength not large enough to store encoded URL path

--*/

{
    DWORD error;
    DWORD len;

    len = *EncodedUrlPathLength;
    while (len > 0) {

        UCHAR ch;

        ch = (UCHAR)*UrlPath++;
        if (ch == '\0') {

            //
            // end of input URL. Done
            //

            break;
        }

        //
        // check whether this character is safe. For now, we encode all unsafe
        // and scheme-specific characters the same way (i.e. irrespective of
        // scheme)
        //
        // We are allowing '/' to be copied unmodified
        //

        if (IS_UNSAFE_URL_CHARACTER(ch, SchemeFlags)
        && !((ch == '/') && (Flags & NO_ENCODE_PATH_SEP))) {
            if (len < 3) {

                //
                // set the length to zero so that we return
                // ERROR_INSUFFICIENT_BUFFER
                //

                len = 0;
                break;
            }
            *EncodedUrlPath++ = '%';
            //*EncodedUrlPath++ = NumberToHexChar((int)ch / 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch / 16);
            //*EncodedUrlPath++ = NumberToHexChar((int)ch % 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch % 16);
            len -= 2; // extra --len below
        } else {
            *EncodedUrlPath++ = (signed char)ch;
        }
        --len;
    }
    if (len >= 1) {
        *EncodedUrlPath = '\0';
        *EncodedUrlPathLength -= len;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    return error;
}


PRIVATE
char
HexCharToNumber(
    IN char ch
    )

/*++

Routine Description:

    Converts an ANSI character in the range '0'..'9' 'A'..'F' 'a'..'f' to its
    corresponding hexadecimal value (0..f)

Arguments:

    ch  - character to convert

Return Value:

    char
        hexadecimal value of ch, as an 8-bit (signed) character value

--*/

{
    return (ch <= '9') ? (ch - '0')
                       : ((ch >= 'a') ? ((ch - 'a') + 10) : ((ch - 'A') + 10));
}


PRIVATE
char
NumberToHexChar(
    IN int Number
    )

/*++

Routine Description:

    Converts a number in the range 0..15 to its ASCII character hex representation
    ('0'..'F')

Arguments:

    Number  - to convert

Return Value:

    char
        character in above range

--*/

{
    return (Number <= 9) ? (char)('0' + Number) : (char)('A' + (Number - 10));
}


DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {

        char ch;

        if (*Url == '%') {

            //
            // BUGBUG - would %00 ever appear in an URL?
            //

            ++Url;
            if (isxdigit(*Url)) {
                ch = HexCharToNumber(*Url++) << 4;
                if (isxdigit(*Url)) {
                    ch |= HexCharToNumber(*Url++);
                } else {
                    return ERROR_INTERNET_INVALID_URL;
                }
            } else {
                return ERROR_INTERNET_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}


DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD stringLength;

    stringLength = *BufferLength;
    if (memchr(BufferAddress, '%', stringLength)) {
        return DecodeUrl(BufferAddress,
                         stringLength,
                         BufferAddress,
                         BufferLength
                         );
    } else {

        //
        // no escape character in the string, just return success
        //

        return ERROR_SUCCESS;
    }
}


DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Performs DecodeUrlInSitu() on a string and zero terminates it

    Assumes: 1. Even if no decoding is performed, *BufferLength is large enough
                to fit an extra '\0' character

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string, excluding '\0'

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error;

    error = DecodeUrlInSitu(BufferAddress, BufferLength);
    if (error == ERROR_SUCCESS) {
        BufferAddress[*BufferLength] = '\0';
    }
    return error;
}


DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL

--*/

{
    LPSTR pString;
    LPSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString != '/') && (*pString != '\0') && (length != 0)) {
        if (*pString == '%') {

            //
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //

            *partEscape = TRUE;
        }
        if (*pString == ':') {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                return ERROR_INTERNET_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_INTERNET_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    LPSTR pAt;
    DWORD urlLength;
    LPSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    char portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPSTR pPortNumber;
    DWORD error;
    LPSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = strlen(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    if (GlobalMBCSAPIforCrack)
    {
        BOOL bFound = FALSE;
        for (pAt = pUrl; pAt < (pUrl+urlLength); pAt = CharNext(pAt))
        {
            if (*pAt == '/')
            {
                break;
            }
            else if (*pAt == '@')
            {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound)
            pAt = NULL;
    }
    else
    {
        for (DWORD i = 0; i < urlLength; ++i) {
            if (pUrl[i] == '/') {
                break;
            } else if (pUrl[i] == '@') {
                pAt = &pUrl[i];
                break;
            }
        }
    }

    if (pAt != NULL) {

        DWORD addressPartLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        INET_ASSERT(addressPartLength == 0);
        INET_ASSERT(pUrl == pAt);

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword)) {

            //
            // convert the password in situ
            //

            if (part2Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);
                INET_ASSERT(password != NULL);
                INET_ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {

        //
        // no '@' therefore no username or password
        //

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (ARGUMENT_PRESENT(lpszPassword)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_INTERNET_INVALID_URL;
//  }

    if (ARGUMENT_PRESENT(lpszHostName)) {

        INET_ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }

            if(!IsValidHostName(hostName, hostNameLength))
            {
                return ERROR_INTERNET_INVALID_URL;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (ARGUMENT_PRESENT(lpPort)) {
        if (portNumberLength != 0) {

            DWORD i;
            DWORD port;

            INET_ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!isdigit(*pPortNumber)) {
                    return ERROR_INTERNET_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - '0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535)
                {
                    return ERROR_INTERNET_INVALID_URL;
                }
            }
            *lpPort = (INTERNET_PORT)port;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName      - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1) {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    DWORD i;
    if (ScanSchemes(lpszSchemeName, dwSchemeNameLength, &i))
    {
        return UrlSchemeList[i].SchemeType;
    }
    return INTERNET_SCHEME_UNKNOWN;
}


LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme                  - enumerated scheme type to map

    lpdwSchemeNameLength    - pointer to returned length of scheme name

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        *lpdwSchemeNameLength = UrlSchemeList[Scheme].SchemeLength;
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}


LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme  - enumerated scheme type to map

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\strtodbl.c ===
#ifndef _CRTBLD
#define _CRTBLD
#endif

#include <windows.h>
#include <shlwapi.h>

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double __cdecl StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\proxreg.cxx ===
#include "wininetp.h"
#include "autodial.h"

const CHAR szRegPathConnections[] = REGSTR_PATH_INTERNET_SETTINGS "\\Connections";
static const CHAR szRegValProxyEnabled[] = REGSTR_VAL_PROXYENABLE;
static const CHAR szLegacyAutoConfigURL[] = "AutoConfigURL";

// when we haven't looked up dial-up override for autodetect
#define UNKNOWN_AUTODETECT      ((DWORD)(-1))

// Internet Settings reg value do determine dial-up override for autodetect
static const CHAR szDialupAutodetect[] = "DialupAutodetect";

// base hkey we use for settings.  May be per user or per machine.
CRefdKey* g_prkBase = NULL;

// type for RtlConvertSidToUnicodeString, exported from ntdll.dll
typedef NTSTATUS (* PCONVERTSID)(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

// some winsock stacks fault if we do a gethostbyname(NULL).  If we come
// accross one of these, don't do any more autodetecting.
BOOL g_fGetHostByNameNULLFails = FALSE;

//
// IsConnectionMatch - a worker function to simply some logic elsewhere,
//  it just handles Connection Name Matching.
//

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2)
{
    if ( lpszConnection1 == NULL && 
         lpszConnection2 == NULL) 
    {
        return TRUE;
    }

    if ( lpszConnection1 && lpszConnection2 &&
         stricmp(lpszConnection1, lpszConnection2) == 0 )
    {
        return TRUE;
    }

    return FALSE;
}

//
// Decide whether or not autodiscovery is turned based on IEAK setting.
// Only used when upgrading or creating settings for a new connectoid.
//
BOOL
EnableAutodiscoverForDialup(
    VOID
    )
{
    static DWORD dwDialUpAutodetect = UNKNOWN_AUTODETECT;

    if(UNKNOWN_AUTODETECT == dwDialUpAutodetect)
    {
        DWORD   dwType, dwSize = sizeof(DWORD);

        if(ERROR_SUCCESS !=
            SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
            szDialupAutodetect, &dwType, &dwDialUpAutodetect, &dwSize))
        {
            // not set
            dwDialUpAutodetect = 0;
        }
    }

    return (BOOL)dwDialUpAutodetect;
}

///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    Commit();

    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;
    }

    lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                regsam, NULL, &_hkey, &dwDisposition);
    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            // nothing there - make zero size buffer
            _dwBufferLimit = 0;
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::Encrpyt(
    )
{
    return 0;
}


DWORD
CRegBlob::Decrypt(
    )
{
    return 0;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = _dwBufferLimit + ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


///////////////////////////////////////////////////////////////////////////
//
// Helpers to read and write proxy settings
//
///////////////////////////////////////////////////////////////////////////

//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

#define MAX_SID_STRING 256


//
// Function Declarations
//

BOOL
InitClientUserString (
    LPWSTR pString
    )

/*++

Routine Description:

Arguments:

    pString - output string of current user

Return Value:

    TRUE = success,
    FALSE = fail

    Returns in pString a ansi string if the impersonated client's
    SID can be expanded successfully into  Unicode string. If the conversion
    was unsuccessful, returns FALSE.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "InitClientUserString",
                 "%#x",
                 pString
                 ));

    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    BOOL        Status;
    DWORD       dwLastError;
    UNICODE_STRING UnicodeString;
    HMODULE     hNtDll;
    PCONVERTSID pRtlConvertSid;

    /*
    if (GlobalIsProcessNtService)
    {
        char    szUserName[10];
        DWORD   cbUserNameSize = ARRAYSIZE(szUserName);
        GlobalUserName.Get(szUserName,&cbUserNameSize);
        if (0 == lstrcmpi(szUserName, "SYSTEM"))
        {
            DEBUG_PRINT(DIALUP, INFO, ("User Profile = %s(env = %d)\n",
                        szUserName, GlobalIsProcessNtService
                        ));
            
            wcscpy(pString, L".default");

            DEBUG_PRINT(DIALUP, INFO, ("User SID = %ws\n",
                        pString
                        ));

            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
    }
    */
    
    //
    // get RtlConvertSideToUnicodeString entry point in NTDLL
    //
    hNtDll = LoadLibrary("ntdll.dll");
    if(NULL == hNtDll)
    {
        return FALSE;
    }

    pRtlConvertSid = (PCONVERTSID)GetProcAddress(hNtDll, "RtlConvertSidToUnicodeString");
    if(NULL == pRtlConvertSid)
    {
        FreeLibrary(hNtDll);
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // We can use OpenThreadToken because this server thread
    // is impersonating a client
    //
    Status = OpenThreadToken(
                GetCurrentThread(),
                TOKEN_READ,
                TRUE,                // Open as self
                &TokenHandle
                );
    dwLastError = GetLastError();

    if( Status == FALSE )
    {
        DEBUG_PRINT(DIALUP, INFO, ("OpenThreadToken() failed: Error=%d\n",
                    dwLastError
                    ));

        Status = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_READ,
                    &TokenHandle
                    );
        dwLastError = GetLastError();

        if( Status == FALSE )
        {
            DEBUG_LEAVE(FALSE);
            return FALSE ;
        }
    }

    //
    // Notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure
    //
    Status = GetTokenInformation( TokenHandle,
                                  TokenUser,
                                  TokenInformation,
                                  sizeof( TokenInformation ),
                                  &ReturnLength
                                   );
    dwLastError = GetLastError();
    CloseHandle( TokenHandle );

    if ( Status == FALSE ) {
        DEBUG_PRINT(DIALUP, INFO, ("GetTokenInformation failed: Error=%d\n",
                    dwLastError
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // Convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.
    //

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_SID_STRING;
    UnicodeString.Buffer = pString;

    Status = (*pRtlConvertSid)(
                 &UnicodeString,
                 ((PTOKEN_USER)TokenInformation)->User.Sid,
                 FALSE );
    FreeLibrary(hNtDll);

    if( !NT_SUCCESS( Status )){
        DEBUG_PRINT(DIALUP, INFO, ("RtlConvertSidToUnicodeString failed: Error=%d\n",
                    Status
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    
    DEBUG_PRINT(DIALUP, INFO, ("User SID = %ws\n",
                pString
                ));

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    )

/*++

Routine Description:

Arguments:

Returns:

---*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "GetClientUserHandle",
                 "%#x",
                 samDesired
                 ));

    HKEY   hKeyClient;
    WCHAR  String[MAX_SID_STRING];
    LONG   ReturnValue;

    if (!InitClientUserString(String)) {
        DEBUG_LEAVE(0);
        return NULL ;
    }

    //
    // We now have the Unicode string representation of the
    // local client's Sid we'll use this string to open a handle
    // to the client's key in  the registry.

    ReturnValue = RegOpenKeyExW( HKEY_USERS,
                                 String,
                                 0,
                                 samDesired,
                                 &hKeyClient );

    //
    // If we couldn't get a handle to the local key
    // for some reason, return a NULL handle indicating
    // failure to obtain a handle to the key
    //

    if ( ReturnValue != ERROR_SUCCESS )
    {
        DEBUG_PRINT(DIALUP, INFO, ("RegOpenKeyW failed: Error=%d\n",
                    ReturnValue
                    ));

        DEBUG_ERROR(DIALUP, ReturnValue);
        SetLastError( ReturnValue );

        DEBUG_LEAVE(0);
        return NULL;
    }

    DEBUG_LEAVE(hKeyClient);
    return( hKeyClient );
}

CRefdKey*
FindBaseProxyKey(
    VOID
    )

/*
** Determine whether proxy settings live in HKLM or HKCU
**
** Returns HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE
**
** Checks \HKLM\SW\MS\Win\CV\Internet Settings\ProxySettingsPerUser.  If
** exists and is zero, use HKLM otherwise use HKCU.
*/

{
    // grab the cached value
    CRefdKey* prk = (CRefdKey*)InterlockedExchangePointer((void**)&g_prkBase, NULL);

    if (prk == NULL)
    {
        HKEY hkeyBase = NULL;
        BOOL bSetNewCachedValue = FALSE;
        DWORD  dwType, dwValue, dwSize = sizeof(DWORD);

        if(ERROR_SUCCESS ==
            SHGetValue(HKEY_LOCAL_MACHINE, INTERNET_POLICY_KEY,
            TEXT("ProxySettingsPerUser"), &dwType, &dwValue, &dwSize) &&
            0 == dwValue)
        {
            hkeyBase = HKEY_LOCAL_MACHINE;
            bSetNewCachedValue = TRUE;
        }
        else
        {
            //
            // Find an HKCU equivalent for this process
            //
            if(PLATFORM_TYPE_WIN95 == GlobalPlatformType ||
               NULL == (hkeyBase = GetClientUserHandle(KEY_QUERY_VALUE | KEY_SET_VALUE)))
            {
                BOOL fLocalSystem = FALSE;
                if (GlobalIsProcessNtService)
                {
                    char    szUserName[20];
                    DWORD   cbUserNameSize = ARRAYSIZE(szUserName);
                    GlobalUserName.Get(szUserName,&cbUserNameSize);
                    if (0 == lstrcmpi(szUserName, "SYSTEM") ||
                        0 == lstrcmpi(szUserName, "LOCAL SERVICE") || 
                        0 == lstrcmpi(szUserName, "NETWORK SERVICE"))
                    {
                        fLocalSystem = TRUE;
                    }
                }
                
                if (!fLocalSystem)
                {
                    hkeyBase = HKEY_CURRENT_USER;
                    bSetNewCachedValue = TRUE;
                }
            }
            else if (!GlobalIsProcessNtService)
            {
                // only cache the CRefdKey if we are not a service
                bSetNewCachedValue = TRUE;
            }
        }

        if (hkeyBase)
        {
            prk = new CRefdKey(hkeyBase);

            if (prk)
            {
                if (bSetNewCachedValue)
                {
                    // addref it again since we are going to try and stick it in the global
                    prk->AddRef();

                    if (InterlockedCompareExchangePointer((void **)&g_prkBase, prk, 0))
                    {
                        // someone beat us in the race to fill in g_prkBase, release ours since we
                        // failed to set it into g_prkBase
                        prk->Release();
                    }
                }
            }
            else
            {
                // we failed to create a CRefdKey, so close the hkeyBase if it is not a predefined handle
                if ((hkeyBase != HKEY_LOCAL_MACHINE) &&
                    (hkeyBase != HKEY_CURRENT_USER))
                {
                    RegCloseKey(hkeyBase);
                }
            }
        }
    }
    else
    {
        // addref the global and put it back
        prk->AddRef();
        CRefdKey* prkOld = (CRefdKey*)InterlockedExchangePointer((void**)&g_prkBase, prk);
        if (prkOld)
        {
            // someone also stuck a cached value in g_prkBase! Since we just put ours back
            // in the global cache, we need to release theirs.
            prkOld->Release();
        }
    }

    return prk;
}

BOOL
CloseBaseProxyKey(
    CRefdKey* prk
    )
{
    if (prk)
    {
        prk->Release();
        return TRUE;
    }

    return FALSE;
}

DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    DWORD   i;
    BOOL    fSave = FALSE, fLanConnection = FALSE;
    CRefdKey* prkBase = NULL;
    DWORD   dwStructVersion;

    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "ReadProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // take mutex
    WaitForSingleObject(g_hProxyRegMutex, INFINITE);

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        fLanConnection = TRUE;
        pszConnectionName = "DefaultConnectionSettings";
    }

    // figure out base key
    prkBase = FindBaseProxyKey();
    if (prkBase == NULL)
    {
        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(prkBase->GetKey(), szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&dwStructVersion, sizeof(DWORD)) ||
         (dwStructVersion < INTERNET_PROXY_INFO_EX_VERSION))
    {
        // blob didn't exist or in correct format - set default values

        // If not on a lan connection and we're set to inherit lan settings
        if(!fLanConnection && GlobalUseLanSettings)
        {
            // Ensure we're reading the LAN proxy information.
            pInfo->lpszConnectionName = NULL;

            // Get proxy settings into pInfo
            lRes = ReadProxySettings(pInfo);
            if(lRes)
            {
                error = lRes;
                goto quit;
            }

            // Restore connection name
            pInfo->lpszConnectionName = pszSavedConnectionName;
        }
        else
        {
#ifndef UNIX
            //
            // All lan connections and overridden dial-ups get autodetect
            //
            if(fLanConnection || EnableAutodiscoverForDialup())
            {
                pInfo->dwFlags |= PROXY_TYPE_AUTO_DETECT;
            }
#else
            ;
#endif /* UNIX */
        }
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
        r.ReadString(&pInfo->lpszAutoconfigUrl);
        r.ReadBytes(&pInfo->dwAutoDiscoveryFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszLastKnownGoodAutoConfigUrl);
        r.ReadBytes(&pInfo->ftLastKnownDetectTime, sizeof(FILETIME));

        // read interface ips
        r.ReadBytes(&pInfo->dwDetectedInterfaceIpCount, sizeof(DWORD));
        if(pInfo->dwDetectedInterfaceIpCount)
        {
            pInfo->pdwDetectedInterfaceIp = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD) * pInfo->dwDetectedInterfaceIpCount);
            if(pInfo->pdwDetectedInterfaceIp)
            {
                for(i=0; i<pInfo->dwDetectedInterfaceIpCount; i++)
                {
                    r.ReadBytes(&pInfo->pdwDetectedInterfaceIp[i], sizeof(DWORD));
                }
            }
        }

        r.ReadString(&pInfo->lpszAutoconfigSecondaryUrl);
        r.ReadBytes(&pInfo->dwAutoconfigReloadDelayMins, sizeof(DWORD));
    }

    // Netware hack.  Don't ever allow autodiscovery to be turned on if
    // we're running the netware client.  It faults and it isn't useful
    // anyway.
    //
    // Some other stacks may also fault.  If we find one, don't autodetect.
    if(GlobalRunningNovellClient32 || g_fGetHostByNameNULLFails)
    {
        pInfo->dwFlags &= ~PROXY_TYPE_AUTO_DETECT;

        // save this back so we don't ever try again
        fSave = TRUE;
    }

    DEBUG_PRINT(DIALUP, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s, acu=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>"),
                    (pInfo->lpszAutoconfigUrl ? pInfo->lpszAutoconfigUrl : "<none>")
                    ));

    if(fSave)
    {
        WriteProxySettings(pInfo, TRUE);
    }

quit:
    CloseBaseProxyKey(prkBase);
    // free mutex
    ReleaseMutex(g_hProxyRegMutex);
    DEBUG_LEAVE(error);
    return error;
}


DWORD
WriteProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo,
    BOOL fForceUpdate
    )

// serialize this.  Only write if dwCurrentSettingsVersion member has been
// incremented by exactly 1.

{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "WriteProxySettings",
                 "%#x, %B",
                 pInfo,
                 fForceUpdate                 
                 ));

    CRegBlob    r(TRUE);
    CRegBlob    CurrentVersion(FALSE);
    LPCSTR      pszConnectionName;
    long        lRes;
    DWORD       i;
    DWORD       dwCurrentVersion;
    DWORD       dwCurrentStructSize;
    DWORD       error = ERROR_SUCCESS;
    DWORD       dwStructVersion = INTERNET_PROXY_INFO_EX_VERSION;
    CRefdKey*   prkBase = NULL;

    //
    // verify pInfo
    //
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        r.Abandon();
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // take mutex
    WaitForSingleObject(g_hProxyRegMutex, INFINITE);

    //
    // figure out connection name  (NULL == 'network')
    //
    pszConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        pszConnectionName = "DefaultConnectionSettings";
    }

    //
    // For forced update changes, turn off this FLAG since,
    //  any major change in settings indicates a possible FIX
    //  for detection issues.
    //

    if ( fForceUpdate ) {
        pInfo->dwAutoDiscoveryFlags &= ~(AUTO_PROXY_FLAG_DETECTION_SUSPECT);
    }

    DEBUG_PRINT(DIALUP, INFO, ("conn=%s, vers=%u, flag=%X, a-flag=%X, prox=%s, by=%s, acu=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    pInfo->dwAutoDiscoveryFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>"),
                    (pInfo->lpszAutoconfigUrl ? pInfo->lpszAutoconfigUrl : "<none>")
                    ));

    // figure out base key
    prkBase = FindBaseProxyKey();

    if (prkBase == NULL)
    {
        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    //
    // Get current version and verify another write hasn't happened
    //
    // Second dword is version
    //
    lRes = CurrentVersion.Init(prkBase->GetKey(), szRegPathConnections, pszConnectionName);
    if(lRes || IsInGUIModeSetup())
    {
        r.Abandon();
        error = lRes;
        goto quit;
    }

    dwCurrentStructSize = sizeof(*pInfo);
    dwCurrentVersion    = 0;

    CurrentVersion.ReadBytes(&dwCurrentStructSize, sizeof(DWORD)); // struct size
    CurrentVersion.ReadBytes(&dwCurrentVersion, sizeof(DWORD)); // actual version

    if(dwCurrentVersion != pInfo->dwCurrentSettingsVersion)
    {
        // someone else has written since this read.  If we aren't in force
        // mode, bail out
        if((fForceUpdate == FALSE) &&
           (dwCurrentStructSize >= sizeof(*pInfo)))
        {
            r.Abandon();
            error = ERROR_INVALID_DATA;
            goto quit;
        }

        // update to most recent version
        pInfo->dwCurrentSettingsVersion = dwCurrentVersion;
    }

    //
    // increment version
    //
    pInfo->dwCurrentSettingsVersion++;

    //
    // init blob
    //
    lRes = r.Init(prkBase->GetKey(), szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        r.Abandon();
        error = lRes;
        goto quit;
    }

    //
    // write fields to blob
    //

    r.WriteBytes(&dwStructVersion, sizeof(DWORD)); // used for data format checking
    r.WriteBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
    r.WriteBytes(&pInfo->dwFlags, sizeof(DWORD));
    r.WriteString(pInfo->lpszProxy);
    r.WriteString(pInfo->lpszProxyBypass);
    r.WriteString(pInfo->lpszAutoconfigUrl);
    r.WriteBytes(&pInfo->dwAutoDiscoveryFlags, sizeof(DWORD));
    r.WriteString(pInfo->lpszLastKnownGoodAutoConfigUrl);
    r.WriteBytes(&pInfo->ftLastKnownDetectTime, sizeof(FILETIME));

    //
    // write interface ip list
    //
    r.WriteBytes(&pInfo->dwDetectedInterfaceIpCount, sizeof(DWORD));
    for(i=0; i<pInfo->dwDetectedInterfaceIpCount; i++)
    {
        r.WriteBytes(&pInfo->pdwDetectedInterfaceIp[i], sizeof(DWORD));
    }

    r.WriteString(pInfo->lpszAutoconfigSecondaryUrl);
    r.WriteBytes(&pInfo->dwAutoconfigReloadDelayMins, sizeof(DWORD));

quit:
    CloseBaseProxyKey(prkBase);
    // free mutex
    ReleaseMutex(g_hProxyRegMutex);

    DEBUG_LEAVE(error);

    return error;
}

void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    if(pInfo->lpszAutoconfigUrl)              GlobalFree((LPSTR) pInfo->lpszAutoconfigUrl);
    if(pInfo->lpszLastKnownGoodAutoConfigUrl) GlobalFree((LPSTR) pInfo->lpszLastKnownGoodAutoConfigUrl);
    if(pInfo->pdwDetectedInterfaceIp)         GlobalFree(pInfo->pdwDetectedInterfaceIp);
    memset(pInfo, 0, sizeof(INTERNET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}


DWORD
SetPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info, info_temp;
    DWORD   i, dwError = ERROR_SUCCESS;
    BOOL fCommit = FALSE;
    LPSTR   pszCopy, pszNew;
    BOOL    fFreeCopy = FALSE;

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);

    if ( hInternet == NULL )
    {
        //
        // If auto-proxy thread then try to get the settings
        //  from the auto-proxy thread
        //

        if ( ! fIsAutoProxyThread || 
             ! GlobalProxyInfo.GetAutoProxyThreadSettings(&info) ||
             ! IsConnectionMatch(info.lpszConnectionName, pList->pszConnection))
        {
            fFreeCopy = TRUE;            
            info.lpszConnectionName = pList->pszConnection;
            CheckForUpgrade();
            dwError = ReadProxySettings(&info);
            if (dwError != ERROR_SUCCESS)
            {
                return dwError;
            }
        }
    }

    // loop through option list and set members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pszNew = NULL;

        switch(pList->pOptions[i].dwOption)
        {        
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:        
            // make a copy of the string passed in for these guys
            pszCopy = pList->pOptions[i].Value.pszValue;
            if(pszCopy)
            {
                pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
                if(pszNew)
                {
                    lstrcpy(pszNew, pszCopy);
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    pList->dwOptionError = i;
                }
            }
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            info.dwFlags = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            info.dwAutoDiscoveryFlags = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
            info.dwAutoconfigReloadDelayMins = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            if(info.lpszProxy)
                GlobalFree((LPSTR)info.lpszProxy);
            info.lpszProxy = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            if(info.lpszProxyBypass)
                GlobalFree((LPSTR)info.lpszProxyBypass);
            info.lpszProxyBypass = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
            if(info.lpszAutoconfigUrl)
                GlobalFree((LPSTR)info.lpszAutoconfigUrl);
            info.lpszAutoconfigUrl = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            if(info.lpszAutoconfigSecondaryUrl)
                GlobalFree((LPSTR)info.lpszAutoconfigSecondaryUrl);
            info.lpszAutoconfigSecondaryUrl = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
            dwError = ERROR_INTERNET_OPTION_NOT_SETTABLE;
            pList->dwOptionError = i;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
            dwError = ERROR_INTERNET_OPTION_NOT_SETTABLE;
            pList->dwOptionError = i;
            break;
        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }
    }

    if(fCommit)
    {
        if ( hInternet == NULL ) 
        {

            memset(&info_temp, 0, sizeof(info_temp));
            info_temp.dwStructSize = sizeof(info_temp);

            if ( ! fIsAutoProxyThread ||
                 ! GlobalProxyInfo.GetAutoProxyThreadSettings(&info_temp) ||
                 ! IsConnectionMatch(info_temp.lpszConnectionName, pList->pszConnection) ||
                 ! GlobalProxyInfo.SetAutoProxyThreadSettings(&info))
                 
            { 
                WriteProxySettings(&info, TRUE);

                // update legacy settings with new values
                info.lpszConnectionName = LEGACY_SAVE_NAME;
                WriteLegacyProxyInfo(szRegPathInternetSettings, &info, TRUE);
                WriteProxySettings(&info, TRUE);
            }
        } 
        else 
        {
            GlobalProxyInfo.SetProxySettings(&info, TRUE);
        }
    }

    if ( fFreeCopy ) {
        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return dwError;
}



DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info;
    LPCSTR   pszCopy;
    LPSTR    pszNew;
    DWORD    i, dwError = ERROR_SUCCESS;
    BOOL     fFreeCopy = FALSE;

    pList->dwOptionError = 0;

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = pList->pszConnection;

    if ( hInternet == NULL ) 
    {
        if ( ! fIsAutoProxyThread ||                          
             ! GlobalProxyInfo.GetAutoProxyThreadSettings(&info) ||
             ! IsConnectionMatch(info.lpszConnectionName, pList->pszConnection)) 
        { 
            CheckForUpgrade();
            dwError = ReadProxySettings(&info);
            if (dwError != ERROR_SUCCESS)
            {
                return dwError;
            }
            fFreeCopy = TRUE;
        }
    }
    else 
    {
        GlobalProxyInfo.GetProxySettings(&info, FALSE);
    }

    // loop through option list and fill in members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pList->pOptions[i].Value.pszValue = NULL;
        pszCopy = NULL;

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            pList->pOptions[i].Value.dwValue = info.dwFlags;
            break;
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            pList->pOptions[i].Value.dwValue = info.dwAutoDiscoveryFlags;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
            pList->pOptions[i].Value.dwValue = info.dwAutoconfigReloadDelayMins;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            pszCopy = info.lpszProxy;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            pszCopy = info.lpszProxyBypass;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
            pszCopy = info.lpszAutoconfigUrl;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszCopy = info.lpszAutoconfigSecondaryUrl;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
            pszCopy = info.lpszLastKnownGoodAutoConfigUrl;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
            *(LONGLONG *) &(pList->pOptions[i].Value.ftValue) = *(LONGLONG *) &(info.ftLastKnownDetectTime);
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        // if this is a string value, make a copy of the string for the
        // caller
        if(pszCopy)
        {
            // make a copy of the string and stick it in the option
            pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
            if(pszNew)
            {
                lstrcpy(pszNew, pszCopy);
                pList->pOptions[i].Value.pszValue = pszNew;
            }
            else
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                pList->dwOptionError = i;
            }
        }

        if(dwError)
        {
            break;
        }
    }

    if (dwError)
    {
        // If an error has occurred, we should get rid of any strings that
        // we've allocated.
        for (i=0; i<pList->dwOptionError; i++)
        {
            switch(pList->pOptions[i].dwOption)
            {
            case INTERNET_PER_CONN_PROXY_SERVER:
            case INTERNET_PER_CONN_PROXY_BYPASS:
            case INTERNET_PER_CONN_AUTOCONFIG_URL:
            case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                if (pList->pOptions[i].Value.pszValue)
                {
                    GlobalFree(pList->pOptions[i].Value.pszValue);
                    pList->pOptions[i].Value.pszValue = NULL;
                }
                break;

            default:
                break;
            }
        }
    }

    if ( fFreeCopy ) {
        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return dwError;
}


BOOL
ReadLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy
    )

/*++

Routine Description:

    Reads legacy proxy information from a specified key.

Arguments:

    pszKey      - key from which to read proxy info
    pProxy      - pointer to PROXY structure to store info

Return Value:

    BOOL
        TRUE    - success
        FALSE   - failed

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "ReadLegacyProxyInfo",
                 "%#x (%q), %#x",
                 pszKey,
                 pszKey,
                 pProxy
                 ));

    BOOL    fSuccess = FALSE;
    HKEY    hKey;
    CRefdKey* prkBase;
    DWORD   dwSize, dwValue;

    pProxy->dwFlags = PROXY_TYPE_DIRECT;

    prkBase = FindBaseProxyKey();

    if(prkBase && 
       (ERROR_SUCCESS == REGOPENKEYEX(prkBase->GetKey(), pszKey, NULL,
                                KEY_READ, &hKey))) {
        // read enable
        dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS != RegQueryValueEx(hKey, szRegValProxyEnabled,
                    NULL, NULL, (LPBYTE)&dwValue, &dwSize)) {
            dwValue = 0;
        }
        if(dwValue)
        {
            pProxy->dwFlags |= PROXY_TYPE_PROXY;
        }

        // read server
        dwSize = INTERNET_MAX_URL_LENGTH;
        pProxy->lpszProxy = (LPSTR)GlobalAlloc(GMEM_FIXED, dwSize);
        if(pProxy->lpszProxy)
        {
            if(ERROR_SUCCESS != RegQueryValueEx(hKey, REGSTR_VAL_PROXYSERVER,
                NULL, NULL, (LPBYTE)pProxy->lpszProxy, &dwSize) ||
                (dwSize == 0) ||
                (*pProxy->lpszProxy == '\0'))
            {
                GlobalFree((LPVOID)pProxy->lpszProxy);
                pProxy->lpszProxy = NULL;
            }
        }

        // read override
        dwSize = INTERNET_MAX_URL_LENGTH;
        pProxy->lpszProxyBypass = (LPSTR)GlobalAlloc(GMEM_FIXED, dwSize);
        if(pProxy->lpszProxyBypass)
        {
            if(ERROR_SUCCESS != RegQueryValueEx(hKey, REGSTR_VAL_PROXYOVERRIDE,
                NULL, NULL, (LPBYTE)pProxy->lpszProxyBypass, &dwSize) ||
                (dwSize == 0) ||
                (*pProxy->lpszProxyBypass == '\0'))
            {
                GlobalFree((LPVOID)pProxy->lpszProxyBypass);
                pProxy->lpszProxyBypass = NULL;
            }
        }
        

        // read autoconfig URL
        dwSize = INTERNET_MAX_URL_LENGTH;
        pProxy->lpszAutoconfigUrl = (LPSTR)GlobalAlloc(GMEM_FIXED, dwSize);
        if(pProxy->lpszAutoconfigUrl)
        {
            if(ERROR_SUCCESS != RegQueryValueEx(hKey, szLegacyAutoConfigURL,
                NULL, NULL, (LPBYTE)pProxy->lpszAutoconfigUrl, &dwSize) ||
                (dwSize == 0) ||
                (*pProxy->lpszAutoconfigUrl == '\0'))
            {
                // clear out
                GlobalFree((LPVOID)pProxy->lpszAutoconfigUrl);
                pProxy->lpszAutoconfigUrl = NULL;
            }
            else
            {
                // turn on if there's an URL
                pProxy->dwFlags |= PROXY_TYPE_AUTO_PROXY_URL;
            }
        }

        REGCLOSEKEY(hKey);
        fSuccess = TRUE;
    }

    DEBUG_PRINT(DIALUP, INFO, ("flag=%x, prox=%s, by=%s, acu=%s\n", 
                    pProxy->dwFlags,
                    (pProxy->lpszProxy ? pProxy->lpszProxy : "<none>"),
                    (pProxy->lpszProxyBypass ? pProxy->lpszProxyBypass : "<none>"),
                    (pProxy->lpszAutoconfigUrl ? pProxy->lpszAutoconfigUrl : "<none>")
                    ));

    CloseBaseProxyKey(prkBase);

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}


BOOL
WriteLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy,
    IN BOOL    fOverwrite
    )

/*++

Routine Description:

    Writes legacy proxy info a specified key

Arguments:

    pszKey      - key to write proxy inf to
    pProxy      - pointer to PROXY structure containing info to write
    fOverwrite  - If TRUE, overwrite existing info. otherwise only create

Return Value:

    BOOL
        TRUE    - success
        FALSE   - failed

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "WriteLegacyProxyInfo",
                 "%#x (%q), %#x, %B",
                 pszKey,
                 pszKey,
                 pProxy,
                 fOverwrite
                 ));

    BOOL    fSuccess = FALSE;
    HKEY    hKey;
    CRefdKey* prkBase;
    DWORD   dwDisposition, dwValue;

    prkBase = FindBaseProxyKey();
    if (!prkBase)
    {
        goto quit;
    }

    if (IsInGUIModeSetup())
    {
        fSuccess = TRUE;  // don't return a failure, just skip
        goto quit;
    }

    DEBUG_PRINT(DIALUP, INFO, ("flag=%x, prox=%s, by=%s, acu=%s\n", 
                    pProxy->dwFlags,
                    (pProxy->lpszProxy ? pProxy->lpszProxy : "<none>"),
                    (pProxy->lpszProxyBypass ? pProxy->lpszProxyBypass : "<none>"),
                    (pProxy->lpszAutoconfigUrl ? pProxy->lpszAutoconfigUrl : "<none>")
                    ));

    if(ERROR_SUCCESS == REGCREATEKEYEX(prkBase->GetKey(), pszKey, 0, "", 0,
                KEY_WRITE, NULL, &hKey, &dwDisposition)) {

        fSuccess = TRUE;

        //
        // if we're not supposed to overwrite, check enable key.  If it
        // exists, bail
        //
        if(FALSE == fOverwrite) {
            DWORD dwEnable, dwSize = sizeof(DWORD);
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, szRegValProxyEnabled,
                    NULL, NULL, (LPBYTE)&dwEnable, &dwSize)) {
                REGCLOSEKEY(hKey);
                DEBUG_PRINT(DIALUP, INFO, ("Overwrite not set.\n"));
                goto quit;
            }
        }

        // write enable
        dwValue = 0;
        if(pProxy->dwFlags & PROXY_TYPE_PROXY)
            dwValue = 1;
        DEBUG_PRINT(DIALUP, INFO, ("Setting legacy enabled=%d\n", dwValue));
        if(ERROR_SUCCESS != RegSetValueEx(hKey, szRegValProxyEnabled, 0,
                    REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD)))
            fSuccess = FALSE;

        // write server
        if(pProxy->lpszProxy)
        {
            if(ERROR_SUCCESS != RegSetValueEx(hKey, REGSTR_VAL_PROXYSERVER, 0,
                    REG_SZ, (BYTE *)pProxy->lpszProxy,
                    lstrlen(pProxy->lpszProxy)))
                fSuccess = FALSE;
        }
        else
        {
            RegDeleteValue(hKey, REGSTR_VAL_PROXYSERVER);
            DEBUG_PRINT(DIALUP, INFO, ("Deleting legacy server\n"));
        }

        // write override
        if(pProxy->lpszProxyBypass)
        {
            if(ERROR_SUCCESS != RegSetValueEx(hKey, REGSTR_VAL_PROXYOVERRIDE, 0,
                    REG_SZ, (BYTE *)pProxy->lpszProxyBypass,
                    lstrlen(pProxy->lpszProxyBypass)))
                fSuccess = FALSE;
        }
        else
        {
            RegDeleteValue(hKey, REGSTR_VAL_PROXYOVERRIDE);
            DEBUG_PRINT(DIALUP, INFO, ("Deleting legacy override\n"));
        }

        // write autoconfig url
        if( (pProxy->dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
             pProxy->lpszAutoconfigUrl)
        {
            if(ERROR_SUCCESS != RegSetValueEx(hKey, szLegacyAutoConfigURL, 0,
                REG_SZ, (BYTE *)pProxy->lpszAutoconfigUrl,
                lstrlen(pProxy->lpszAutoconfigUrl)))
            {
                fSuccess = FALSE;
            }
        }
        else
        {
            RegDeleteValue(hKey, szLegacyAutoConfigURL);
            DEBUG_PRINT(DIALUP, INFO, ("Deleting legacy autoconfig url\n"));
        }

        REGCLOSEKEY(hKey);
    }

    //
    // duplicate proxy enable reg settings to HKEY_CURRENT_CONFIG so 
    // shell doesn't blow away the setting when it migrates.
    //
    dwValue = (pProxy->dwFlags & PROXY_TYPE_PROXY) ? 1 : 0;
    SHSetValue(HKEY_CURRENT_CONFIG, pszKey, szRegValProxyEnabled,
        REG_DWORD, &dwValue, sizeof(DWORD));

quit:
    CloseBaseProxyKey(prkBase);

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\options.cxx ===
/*++

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    options.cxx

Abstract:

    Contains the Internet*Option APIs

    Contents:
        InternetQueryOptionA
        InternetSetOptionA
        InternetSetOptionExA
        InternetQueryOptionW
        InternetSetOptionW
        InternetSetOptionExW
        (FValidCacheHandleType)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana

    07-Jul-1998 Forked by akabir

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "inetapiu.h"
#include "autodial.h"
#include "msident.h"
#include "secinit.h"


extern HANDLE g_hDialEvent;

//
// private macros
//

//
// IS_PER_THREAD_OPTION - options applicable to the thread (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

//#define IS_PER_THREAD_OPTION(option)                        \
//    (( ((option) == INTERNET_OPTION_SERVER_ERROR_CALLBACK)  \
//    || ((option) == INTERNET_OPTION_ASYNC_ID)               \
//    || ((option) == INTERNET_OPTION_EXTENDED_ERROR)         \
//    ) ? TRUE : FALSE)

#define IS_PER_THREAD_OPTION(option)                        \
    (( ((option) == INTERNET_OPTION_ASYNC_ID)               \
    || ((option) == INTERNET_OPTION_EXTENDED_ERROR)         \
    || ((option) == INTERNET_OPTION_PER_CONNECTION_OPTION)  \
    ) ? TRUE : FALSE)

//
// IS_PER_PROCESS_OPTION - options applicable to the process (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_PROCESS_OPTION(option)                       \
    (( ((option) == INTERNET_OPTION_GET_DEBUG_INFO)         \
    || ((option) == INTERNET_OPTION_SET_DEBUG_INFO)         \
    || ((option) == INTERNET_OPTION_GET_HANDLE_COUNT)       \
    || ((option) == INTERNET_OPTION_CONNECT_TIMEOUT)        \
    || ((option) == INTERNET_OPTION_CONNECT_RETRIES)        \
    || ((option) == INTERNET_OPTION_CONNECT_BACKOFF)        \
    || ((option) == INTERNET_OPTION_SEND_TIMEOUT)           \
    || ((option) == INTERNET_OPTION_RECEIVE_TIMEOUT)        \
    || ((option) == INTERNET_OPTION_DATA_SEND_TIMEOUT)      \
    || ((option) == INTERNET_OPTION_DATA_RECEIVE_TIMEOUT)   \
    || ((option) == INTERNET_OPTION_FROM_CACHE_TIMEOUT)     \
    || ((option) == INTERNET_OPTION_REFRESH)                \
    || ((option) == INTERNET_OPTION_PROXY)                  \
    || ((option) == INTERNET_OPTION_SETTINGS_CHANGED)       \
    || ((option) == INTERNET_OPTION_PROXY_SETTINGS_CHANGED) \
    || ((option) == INTERNET_OPTION_VERSION)                \
    || ((option) == INTERNET_OPTION_END_BROWSER_SESSION)    \
    || ((option) == INTERNET_OPTION_RESET_URLCACHE_SESSION) \
    || ((option) == INTERNET_OPTION_OFFLINE_TIMEOUT)        \
    || ((option) == INTERNET_OPTION_LINE_STATE)             \
    || ((option) == INTERNET_OPTION_IDLE_STATE)             \
    || ((option) == INTERNET_OPTION_OFFLINE_SEMANTICS)      \
    || ((option) == INTERNET_OPTION_HTTP_VERSION)           \
    || ((option) == INTERNET_OPTION_BYPASS_EDITED_ENTRY)    \
    || ((option) == INTERNET_OPTION_MAX_CONNS_PER_SERVER)   \
    || ((option) == INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER)    \
    || ((option) == INTERNET_OPTION_DIGEST_AUTH_UNLOAD)    \
    || ((option) == INTERNET_OPTION_IDENTITY)    \
    || ((option) == INTERNET_OPTION_REMOVE_IDENTITY)    \
    || ((option) == INTERNET_OPTION_ALTER_IDENTITY)    \
    || ((option) == INTERNET_OPTION_SUPPRESS_BEHAVIOR)    \
    || ((option) == INTERNET_OPTION_PER_CONNECTION_OPTION)  \
    || ((option) == INTERNET_OPTION_AUTODIAL_CONNECTION)  \
    || ((option) == INTERNET_OPTION_AUTODIAL_MODE)  \
    || ((option) == INTERNET_OPTION_USERNAME)  \
    || ((option) == INTERNET_OPTION_PASSWORD)  \
    || ((option) == INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS) \
    || ((option) == INTERNET_OPTION_ACTIVATE_WORKER_THREADS) \
    || ((option) == INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS) \
    ) ? TRUE : FALSE)

//
// IS_DEBUG_OPTION - the set of debug-specific options
//

#define IS_DEBUG_OPTION(option)                     \
    (( ((option) >= INTERNET_FIRST_DEBUG_OPTION)    \
    && ((option) <= INTERNET_LAST_DEBUG_OPTION)     \
    ) ? TRUE : FALSE)

//
// IS_VALID_OPTION - the set of known option values, for a HINTERNET, thread, or
// process. In the retail version, debug options are invalid
//

#if INET_DEBUG

#define IS_VALID_OPTION(option)             \
    (((((option) >= INTERNET_FIRST_OPTION)  \
    && ((option) <= INTERNET_LAST_OPTION_INTERNAL))  \
    || IS_DEBUG_OPTION(option)              \
    ) ? TRUE : FALSE)

#else

#define IS_VALID_OPTION(option)             \
    (((((option) >= INTERNET_FIRST_OPTION)  \
    && ((option) <= INTERNET_LAST_OPTION_INTERNAL))  \
    ) ? TRUE : FALSE)

#endif // INET_DEBUG

//
// IS_CONNECT_HANDLE_TYPE - TRUE if handle type contains INTERNET_CONNECT_HANDLE_OBJECT
//

#define IS_CONNECT_HANDLE_TYPE(handleType)          \
    ((handleType == TypeHttpRequestHandle)          \
     || (handleType == TypeHttpConnectHandle)       \
     || (handleType == TypeFtpConnectHandle)        \
     || (handleType == TypeFtpFileHandle)           \
     || (handleType == TypeFtpFindHandle)           \
     || (handleType == TypeFtpFileHandleHtml)       \
     || (handleType == TypeFtpFindHandleHtml)       \
     || (handleType == TypeGopherConnectHandle)     \
     || (handleType == TypeGopherFileHandle)        \
     || (handleType == TypeGopherFindHandle)        \
     || (handleType == TypeGopherFileHandleHtml)    \
     || (handleType == TypeGopherFindHandleHtml))

//
// private prototypes
//

PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    );

PRIVATE
VOID
InitIPCOList(LPINTERNET_PER_CONN_OPTION_LISTW plistW, LPINTERNET_PER_CONN_OPTION_LISTA plistA)
{
    plistA->dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
    plistA->dwOptionCount = plistW->dwOptionCount;
    if (plistW->pszConnection && *plistW->pszConnection)
    {
        SHUnicodeToAnsi(plistW->pszConnection, plistA->pszConnection, RAS_MaxEntryName + 1);
    }
    else
    {
        plistA->pszConnection = NULL;
    }
}

//
// functions
//


INTERNETAPI_(BOOL) InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns information about various handle-specific variables

Arguments:

    hInternet           - handle of object for which information will be
                          returned

    dwOption            - the handle-specific INTERNET_OPTION to query

    lpBuffer            - pointer to a buffer which will receive results

    lpdwBufferLength    - IN: number of bytes available in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_INTERNET_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INSUFFICIENT_BUFFER
                        lpBuffer is not large enough to hold the requested
                        information; *lpdwBufferLength contains the number of
                        bytes needed

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        The handle is the wrong type for the requested option

                    ERROR_INTERNET_INVALID_OPTION
                        The option is unrecognized

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryOptionA",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD error;
    BOOL success;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize = 0;
    LPVOID lpSource;
    DWORD dwValue;
    DWORD_PTR dwPtrValue;
    HANDLE hValue;
    HINTERNET hObjectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * lphRequest;
    BOOL isString = FALSE;
    BOOL freeString = FALSE;
    INTERNET_DIAGNOSTIC_SOCKET_INFO socketInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //
    // validate parameters
    //

    if (!ARGUMENT_PRESENT(lpdwBufferLength)) {
        error = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    //
    // validate the handle and get its type
    //

    HINTERNET hOriginal;

    hOriginal = hInternet;
    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternet, FALSE);
        if (error == ERROR_SUCCESS) {
            hObjectMapped = hInternet;
            lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_INTERNET_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    : ERROR_INTERNET_INVALID_OPTION
                    ;
    }

    //
    // if the option and handle combination is valid then query the option value
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    switch (dwOption) {
    case INTERNET_OPTION_CALLBACK:
        requiredSize = sizeof(INTERNET_STATUS_CALLBACK);
        if (hInternet != NULL) {
            error = RGetStatusCallback(hInternet,
                                       (LPINTERNET_STATUS_CALLBACK)&dwValue
                                       );
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INVALID_HANDLE;
        }
        break;

    case INTERNET_OPTION_CONNECT_TIMEOUT:
    case INTERNET_OPTION_CONNECT_RETRIES:
    case INTERNET_OPTION_CONNECT_BACKOFF:
    case INTERNET_OPTION_SEND_TIMEOUT:
    case INTERNET_OPTION_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        requiredSize = sizeof(DWORD);

        //
        // remember hInternet in the INTERNET_THREAD_INFO then call
        // GetTimeoutValue(). If hInternet refers to a valid Internet
        // object handle, then the relevant timeout value will be
        // returned from that, else we will return the global value
        // corresponding to the requested option
        //

        InternetSetObjectHandle(hOriginal, hInternet);
        dwValue = GetTimeoutValue(dwOption);
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_HANDLE_TYPE:
        requiredSize = sizeof(dwValue);
        switch (handleType) {
        case TypeInternetHandle:
            dwValue = INTERNET_HANDLE_TYPE_INTERNET;
            break;

        case TypeFtpConnectHandle:
            dwValue = INTERNET_HANDLE_TYPE_CONNECT_FTP;
            break;

        case TypeFtpFindHandle:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FIND;
            break;

        case TypeFtpFindHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FIND_HTML;
            break;

        case TypeFtpFileHandle:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FILE;
            break;

        case TypeFtpFileHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FILE_HTML;
            break;

        case TypeGopherConnectHandle:
            dwValue = INTERNET_HANDLE_TYPE_CONNECT_GOPHER;
            break;

        case TypeGopherFindHandle:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FIND;
            break;

        case TypeGopherFindHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML;
            break;

        case TypeGopherFileHandle:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FILE;
            break;

        case TypeGopherFileHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML;
            break;

        case TypeHttpConnectHandle:
            dwValue = INTERNET_HANDLE_TYPE_CONNECT_HTTP;
            break;

        case TypeHttpRequestHandle:
            dwValue = INTERNET_HANDLE_TYPE_HTTP_REQUEST;
            break;

        case TypeFileRequestHandle:
            dwValue = INTERNET_HANDLE_TYPE_FILE_REQUEST;
            break;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;
            break;
        }
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_CONTEXT_VALUE:
    case INTERNET_OPTION_CONTEXT_VALUE_OLD: // see InternetSetOption
        requiredSize = sizeof(DWORD_PTR);
        error = RGetContext(hInternet, &dwPtrValue);
        lpSource = (LPVOID)&dwPtrValue;
        break;

    //case INTERNET_OPTION_NAME_RES_THREAD:
    //    requiredSize = sizeof(BOOL);
    //    lpSource = (LPVOID)&MultiThreadedNameResolution;
    //    break;

    case INTERNET_OPTION_READ_BUFFER_SIZE:
    case INTERNET_OPTION_WRITE_BUFFER_SIZE:
        if (IS_CONNECT_HANDLE_TYPE(handleType)) {
            requiredSize = sizeof(DWORD);
            error = RGetBufferSize(hInternet, dwOption, &dwValue);
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    //case INTERNET_OPTION_GATEWAY_NAME:
    //    error = ERROR_CALL_NOT_IMPLEMENTED;
    //    break;

    case INTERNET_OPTION_ASYNC_ID:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_ASYNC_PRIORITY:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    //case INTERNET_OPTION_ASYNC_REQUEST_COUNT:
    //    requiredSize = sizeof(dwValue);
    //    error = RGetAsyncRequestCount(hInternet, &dwValue);
    //    lpSource = (LPVOID)&dwValue;
    //    break;

    case INTERNET_OPTION_PARENT_HANDLE:
        hInternet = ((HANDLE_OBJECT *)hInternet)->GetParent();
        if (hInternet != NULL) {
            hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        }
        requiredSize = sizeof(hInternet);
        lpSource = (LPVOID)&hInternet;
        break;

    case INTERNET_OPTION_KEEP_CONNECTION:
        if (handleType == TypeHttpConnectHandle) {
            requiredSize = sizeof(BOOL);

            //
            // we return TRUE or FALSE based on whether the connect
            // object believes the server supports Keep-Alive
            //

            //dwValue = RGetKeepAliveState(hInternet);
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_REQUEST_FLAGS:
        requiredSize = sizeof(dwValue);
        if (FValidCacheHandleType(handleType)) {
            dwValue = 0;
            if (lphRequest->IsFromCache()) {
                dwValue |= INTERNET_REQFLAG_FROM_CACHE;
                if (lphRequest->IsNetFailed()) {
                    dwValue |= INTERNET_REQFLAG_NET_TIMEOUT;
                }
            }
            if (lphRequest->IsViaProxy()) {
                dwValue |= INTERNET_REQFLAG_VIA_PROXY;
            }
            if (lphRequest->IsNoHeaders()) {
                dwValue |= INTERNET_REQFLAG_NO_HEADERS;
            }
            if (lphRequest->IsCacheWriteDisabled()) {
                dwValue |= INTERNET_REQFLAG_CACHE_WRITE_DISABLED;
            }
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_EXTENDED_ERROR:
        requiredSize = sizeof(lpThreadInfo->dwMappedErrorCode);
        lpSource = (LPVOID)&lpThreadInfo->dwMappedErrorCode;
        break;

    case INTERNET_OPTION_OFFLINE_MODE:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_CACHE_STREAM_HANDLE:
        requiredSize = sizeof(HANDLE);
        if (FValidCacheHandleType(handleType)) {
            error = lphRequest->GetCacheStream((LPBYTE)&hValue,
                                               sizeof(hValue)
                                               );
            lpSource = (LPVOID)&hValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    BOOL fUser, fProxy;

    case INTERNET_OPTION_USERNAME:
        fUser = IS_USER;
        fProxy = IS_SERVER;
        goto callGetUserOrPass;

    case INTERNET_OPTION_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_SERVER;
        goto callGetUserOrPass;

    case INTERNET_OPTION_PROXY_USERNAME:
        fUser = IS_USER;
        fProxy = IS_PROXY;
        goto callGetUserOrPass;

    case INTERNET_OPTION_PROXY_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_PROXY;
        goto callGetUserOrPass;

callGetUserOrPass:

        if (hInternet && (handleType != TypeInternetHandle)
            && (handleType != TypeFileRequestHandle)) {
            lpSource = lphRequest->GetUserOrPass(fUser, fProxy);
            isString = TRUE;
            freeString = (lpSource != NULL && fUser == IS_PASS); // password string must be freed
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;


    case INTERNET_OPTION_ASYNC:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_IDENTITY:
        lpSource = (LPVOID)&GlobalIdentityGuid;
        requiredSize = sizeof(GlobalIdentityGuid);
        break;
    
    case INTERNET_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            dwValue = lphHttpRqst->GetSecureFlags();

            DEBUG_PRINT(INET,
                        INFO,
                        ("SECURITY_FLAGS: %X\n",
                        dwValue
                        ));


            error = ERROR_SUCCESS;
        }

        break;


    case INTERNET_OPTION_DATAFILE_NAME:
        if ((handleType == TypeHttpRequestHandle)
        || (handleType == TypeFtpFindHandle)
        || (handleType == TypeFtpFindHandleHtml)
        || (handleType == TypeFtpFileHandle)
        || (handleType == TypeFtpFileHandleHtml)
        || (handleType == TypeGopherFindHandle)
        || (handleType == TypeGopherFindHandleHtml)
        || (handleType == TypeGopherFileHandle)
        || (handleType == TypeGopherFileHandleHtml)
        || (handleType == TypeFileRequestHandle )) {

            //
            // DATAFILE_NAME is slightly different from the other string
            // options: if the name is not present then we return an error
            // to the effect that we couldn't find it. The others just
            // return an empty string
            //

            if ( handleType != TypeFileRequestHandle ) {  
                lpSource = lphRequest->GetDataFileName();
            }
            else {
                lpSource = 
                   ((INTERNET_FILE_HANDLE_OBJECT *)lphRequest)->GetDataFileName();
            }

            if (lpSource != NULL) {
                isString = TRUE;

                INET_ASSERT(error == ERROR_SUCCESS);

            } else {
                error = ERROR_INTERNET_ITEM_NOT_FOUND;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_URL:

        //
        // return the URL associated with the request handle. This may be
        // different from the original URL due to redirections
        //

        if ((handleType == TypeHttpRequestHandle)
        || (handleType == TypeFtpFindHandle)
        || (handleType == TypeFtpFindHandleHtml)
        || (handleType == TypeFtpFileHandle)
        || (handleType == TypeFtpFileHandleHtml)
        || (handleType == TypeGopherFindHandle)
        || (handleType == TypeGopherFindHandleHtml)
        || (handleType == TypeGopherFileHandle)
        || (handleType == TypeGopherFileHandleHtml)) {

            //
            // only these handle types (retrieved object handles) can have
            // associated URLs
            //

            lpSource = lphRequest->GetURL();
            isString = TRUE;

            INET_ASSERT(error == ERROR_SUCCESS);

        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;
    case INTERNET_OPTION_SECURITY_CERTIFICATE:

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO siInfo;
            INTERNET_CERTIFICATE_INFO ciInfo;
            DWORD dwciInfoSize = sizeof(INTERNET_CERTIFICATE_INFO);

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&siInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&siInfo, &ciInfo, &dwciInfoSize);
                if(siInfo.pCertificate)
                {
                    CertFreeCertificateContext(siInfo.pCertificate);
                }

                if ( error == ERROR_SUCCESS )
                {
                    LPTSTR szResult = NULL;
                    DWORD cchNeedLen = 0;


                    szResult = FormatCertInfo(
                                &ciInfo
                                );

                    if (NULL == szResult)
                    {
                        error = ERROR_INTERNET_INVALID_OPERATION;
                        goto secOptEnd;
                    }

                    cchNeedLen = lstrlen(szResult) + 1;
                    if (*lpdwBufferLength < cchNeedLen)
                    {
                        error = ERROR_INSUFFICIENT_BUFFER;
                        goto secOptEnd;
                    }

                    if (ARGUMENT_PRESENT(lpBuffer))
                    {
                        memcpy(
                            lpBuffer,
                            szResult,
                            (cchNeedLen) * sizeof(TCHAR));
                        cchNeedLen--;
                    }

secOptEnd:
                    if (NULL != szResult) {
                        FREE_MEMORY(szResult);
                    }
                    if (NULL != ciInfo.lpszSubjectInfo) {
                        LocalFree(ciInfo.lpszSubjectInfo);
                    }
                    if (NULL != ciInfo.lpszIssuerInfo) {
                        LocalFree(ciInfo.lpszIssuerInfo);
                    }
                    if (NULL != ciInfo.lpszSignatureAlgName) {
                        LocalFree(ciInfo.lpszSignatureAlgName);
                    }
                    if (NULL != ciInfo.lpszEncryptionAlgName) {
                        LocalFree(ciInfo.lpszEncryptionAlgName);
                    }
                    if (NULL != ciInfo.lpszProtocolName) {
                        LocalFree(ciInfo.lpszProtocolName);
                    }

                    *lpdwBufferLength = cchNeedLen;
                    requiredSize = *lpdwBufferLength;
                }

                goto quit;
            }
            else
            {
                error = ERROR_INTERNET_INVALID_OPERATION;
            }
        }
        break;

    case INTERNET_OPTION_SECURITY_CONNECTION_INFO:
        //
        // Caller is expected to pass in an INTERNET_SECURITY_CONNECTION_INFO structure.

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_SECURITY_CONNECTION_INFO)) {
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            LPINTERNET_SECURITY_CONNECTION_INFO lpSecConnInfo;
            INTERNET_SECURITY_INFO ciInfo;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            lpSecConnInfo = (LPINTERNET_SECURITY_CONNECTION_INFO)lpBuffer;
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);

            if ((error = lphHttpRqst->GetSecurityInfo(&ciInfo)) == ERROR_SUCCESS) {
                // Set up that data members in the structure passed in.
                lpSecConnInfo->fSecure = TRUE;

                lpSecConnInfo->dwProtocol = ciInfo.dwProtocol;
                lpSecConnInfo->aiCipher = ciInfo.aiCipher;
                lpSecConnInfo->dwCipherStrength = ciInfo.dwCipherStrength;
                lpSecConnInfo->aiHash = ciInfo.aiHash;
                lpSecConnInfo->dwHashStrength = ciInfo.dwHashStrength;
                lpSecConnInfo->aiExch = ciInfo.aiExch;
                lpSecConnInfo->dwExchStrength = ciInfo.dwExchStrength;

                if (ciInfo.pCertificate)
                {
                    CertFreeCertificateContext(ciInfo.pCertificate);
                }

            } else if (error == ERROR_INTERNET_INTERNAL_ERROR)  {
                // This implies we are not secure.
                error = ERROR_SUCCESS;
                lpSecConnInfo->fSecure = FALSE;
            }

            lpSecConnInfo->dwSize = requiredSize;
            *lpdwBufferLength = requiredSize;
        }

        goto quit;


    case INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT:

        //
        // Allocates memory that caller is expected to free.
        //

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        } else {
            LPTSTR szResult = NULL;
            DWORD cchNeedLen = 0;
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&cInfo, (LPINTERNET_CERTIFICATE_INFO)lpBuffer, lpdwBufferLength);
                if(cInfo.pCertificate)
                {
                    CertFreeCertificateContext(cInfo.pCertificate);
                }
                goto quit;
            }
            else
            {
                error = ERROR_INTERNET_INVALID_OPERATION;
            }
        }
        break;

    case INTERNET_OPTION_SECURITY_KEY_BITNESS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO secInfo;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            if (ERROR_SUCCESS != lphHttpRqst->GetSecurityInfo(&secInfo)) {
                error = ERROR_INTERNET_INVALID_OPERATION;
            } else {
                dwValue = secInfo.dwCipherStrength;
                CertFreeCertificateContext(secInfo.pCertificate);

                INET_ASSERT (error == ERROR_SUCCESS);

                DEBUG_PRINT(INET,
                            INFO,
                            ("SECURITY_KEY_BITNESS: %X\n",
                            dwValue
                            ));

            }
        }

        break;


    case INTERNET_OPTION_PROXY:
        if (!ARGUMENT_PRESENT(hInternet)) {

            if (!GlobalProxyInfo.IsModifiedInProcess())
            {
                FixProxySettingsForCurrentConnection(
                    FALSE
                    );
            }

            error = GlobalProxyInfo.GetProxyStringInfo(lpBuffer, lpdwBufferLength);
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else if (handleType == TypeInternetHandle) {

            //
            // GetProxyInfo() will return the data, or calculate the buffer
            // length required
            //

            error = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetProxyStringInfo(
                lpBuffer,
                lpdwBufferLength
                );
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_VERSION:
        requiredSize = sizeof(InternetVersionInfo);
        lpSource = (LPVOID)&InternetVersionInfo;
        break;

    case INTERNET_OPTION_USER_AGENT:
        if (handleType == TypeInternetHandle) {
            lpSource = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetUserAgent();
            isString = TRUE;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_LINE_STATE:

        if(InternetSettingsChanged())
        {
            ChangeGlobalSettings();     // refreshes GlobalDllState
        }

        requiredSize = sizeof(DWORD);
        lpSource = (LPVOID)&dwValue;
        dwValue = GlobalDllState
                & (INTERNET_LINE_STATE_MASK | INTERNET_STATE_OFFLINE_USER);
        break;

    case INTERNET_OPTION_IDLE_STATE:
        requiredSize = sizeof(DWORD);
        lpSource = (LPVOID)&dwValue;
        dwValue = GlobalDllState & INTERNET_STATE_IDLE;
        break;

    case INTERNET_OPTION_OFFLINE_SEMANTICS:
        requiredSize = sizeof(DWORD);
        dwValue = FALSE;
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
        if (handleType == TypeHttpRequestHandle) {
                        lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
                        lpSource = lphRequest->GetSecondaryCacheKey();
                        isString = TRUE;
                } else {
                        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
                }
        break;

    case INTERNET_OPTION_CALLBACK_FILTER:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_CONNECT_TIME:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_SEND_THROUGHPUT:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_RECEIVE_THROUGHPUT:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(dwValue);
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetPriority();
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_HTTP_VERSION:
        requiredSize = sizeof(HttpVersionInfo);
        lpSource = (LPVOID)&HttpVersionInfo;
        break;

    case INTERNET_OPTION_NET_SPEED:
        break;

    case INTERNET_OPTION_BYPASS_EDITED_ENTRY:
        requiredSize = sizeof(BOOL);
        dwValue = GlobalBypassEditedEntry;
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO:

        //
        // internal option
        //

        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(socketInfo);
            lpSource = (LPVOID)&socketInfo;

            HTTP_REQUEST_HANDLE_OBJECT * pReq;

            pReq = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            socketInfo.Socket = pReq->GetSocket();
            socketInfo.SourcePort = pReq->GetSourcePort();
            socketInfo.DestPort = pReq->GetDestPort();
            socketInfo.Flags = (pReq->FromKeepAlivePool()
                                    ? IDSI_FLAG_KEEP_ALIVE : 0)
                                | (pReq->IsSecure()
                                    ? IDSI_FLAG_SECURE : 0)
                                | (pReq->IsRequestUsingProxy()
                                    ? IDSI_FLAG_PROXY : 0)
                                | (pReq->IsTunnel()
                                    ? IDSI_FLAG_TUNNEL : 0);
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_CACHE_TIMESTAMPS:
        if (handleType == TypeHttpRequestHandle) {
            if (*lpdwBufferLength == sizeof(INTERNET_CACHE_TIMESTAMPS)) {
                INTERNET_CACHE_TIMESTAMPS* ts =
                    (INTERNET_CACHE_TIMESTAMPS*)lpBuffer;
                BOOL bU1;
                BOOL bU2;
                BOOL bU3;
                FILETIME ftPostCheck;

                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    GetTimeStampsForCache(
                        &(ts->ftExpires),
                        &(ts->ftLastModified),
                        &ftPostCheck,
                        &bU1, &bU2, &bU3 );
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        goto quit;
        break;

    case INTERNET_OPTION_DISABLE_AUTODIAL:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_AUTODIAL_MODE:
        requiredSize = sizeof(DWORD);
        dwValue = GetAutodialMode();
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        error = GetAutodialConnection((LPSTR)lpBuffer, *lpdwBufferLength);
        isString = TRUE;
        lpSource = lpBuffer;
        requiredSize = *lpdwBufferLength;
        break;

    // IE5 #23845: Wininet: Various auth related feature requests for FP
    // This will return TRUE if post data will be sent on a request.
    case INTERNET_OPTION_DETECT_POST_SEND:
        if (handleType == TypeHttpRequestHandle)
        {
            requiredSize = sizeof(DWORD);
            lpSource = (LPVOID)&dwValue;
            HTTP_REQUEST_HANDLE_OBJECT *pRequest;
            pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;

            if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE
                && !((PLUG_CTX*)(pRequest->GetAuthCtx()))->_fNTLMProxyAuth
                && !(pRequest->GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_DPA))
            {
                dwValue = 0;
            }
            else
            {
                dwValue = 1;
            }
        }
        else
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_MAX_CONNS_PER_SERVER:
        if( !hInternet )  {
            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;
            dwValue = GlobalMaxConnectionsPerServer;
        }
        else
            error = ERROR_INTERNET_INVALID_OPERATION;

        break;

    case INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if( !hInternet ) {
            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;
            dwValue = GlobalMaxConnectionsPer1_0Server;
        }
        else
            error = ERROR_INTERNET_INVALID_OPERATION;

        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = QueryPerConnOptions(hInternet,
                                        lpThreadInfo->IsAutoProxyProxyThread,
                                        (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);

            requiredSize = *lpdwBufferLength;
            goto quit;
        }

    case INTERNET_OPTION_COOKIES_3RD_PARTY:
        if (handleType == TypeHttpRequestHandle)
        {
            requiredSize = sizeof(DWORD);
            lpSource = (LPVOID)&dwValue;
            dwValue = (DWORD) ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->Is3rdPartyCookies();
        }
        else
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

#if INET_DEBUG

    case INTERNET_OPTION_GET_DEBUG_INFO:
        error = InternetGetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     lpdwBufferLength
                                     );

        //
        // everything updated, so quit without going through common buffer
        // processing
        //

        goto quit;
        break;

    case INTERNET_OPTION_GET_HANDLE_COUNT:
        requiredSize = sizeof(DWORD);
        dwValue = InternetHandleCount();
        lpSource = (LPVOID)&dwValue;
        break;

#endif // INET_DEBUG

    default:
        requiredSize = 0;
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    //
    // if we have a buffer and enough space, then copy the data
    //

    if (error == ERROR_SUCCESS) {

        //
        // if we are returning a string, calculate the amount of space
        // required to hold it
        //

        if (isString) {
            if (lpSource != NULL) {
                requiredSize = lstrlen((LPCSTR)lpSource) + 1;
            } else {

                //
                // option string is NULL: return an empty string
                //

                lpSource = "";
                requiredSize = 1;
            }
        }

        INET_ASSERT(lpSource != NULL);

        if ((*lpdwBufferLength >= requiredSize)
        && ARGUMENT_PRESENT(lpBuffer)) {
            memcpy(lpBuffer, lpSource, requiredSize);
            if (isString) {

                //
                // string copied successfully. Returned length is string
                // length, not buffer length, i.e. drop 1 for '\0'
                //

                --requiredSize;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }

        // Scrub and free password string from GetUserOrPass().
        switch (dwOption)
        {
        case INTERNET_OPTION_PASSWORD:
        case INTERNET_OPTION_PROXY_PASSWORD:
            if (freeString)
            {
                INET_ASSERT(isString);
                SecureZeroMemory(lpSource, requiredSize);
                FREE_MEMORY(lpSource);
            }
            break;
        }
    }

quit:

    //
    // return the amount the app needs to supply, or the amount of data in the
    // buffer, depending on success/failure status
    //

    *lpdwBufferLength = requiredSize;

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error == ERROR_SUCCESS) {
        success = TRUE;

        IF_DEBUG(API) {

            if (isString) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("returning %q (%d chars)\n",
                                lpBuffer,
                                requiredSize
                                ));


            } else {

                DEBUG_DUMP_API(API,
                               "option data:\n",
                               lpBuffer,
                               requiredSize
                               );
            }
        }
    } else {

        DEBUG_ERROR(API, error);

        IF_DEBUG(API) {

            if (error == ERROR_INSUFFICIENT_BUFFER) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("*lpdwBufferLength (%#x)= %d\n",
                                lpdwBufferLength,
                                *lpdwBufferLength
                                ));

            }
        }

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) InternetQueryOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet           -

    dwOption            -

    lpBuffer            -

    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryOptionW",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBuffer;

    switch (dwOption)
    {
    case INTERNET_OPTION_USERNAME:
    case INTERNET_OPTION_PASSWORD:
    case INTERNET_OPTION_DATAFILE_NAME:
    case INTERNET_OPTION_URL:
    case INTERNET_OPTION_USER_AGENT:
    case INTERNET_OPTION_PROXY_USERNAME:
    case INTERNET_OPTION_PROXY_PASSWORD:
    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        if (lpBuffer)
        {
            mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
            mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
            if (!mpBuffer.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (LPVOID)mpBuffer.psStr,
                                  &mpBuffer.dwSize
                                 );
        if (fResult)
        {
            *lpdwBufferLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                        NULL, 0);
            if (*lpdwBufferLength*sizeof(WCHAR)<=mpBuffer.dwAlloc && lpBuffer)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, *lpdwBufferLength);
                (*lpdwBufferLength)--;
            }
            else
            {
                *lpdwBufferLength *= sizeof(WCHAR);
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);

            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;
                listA.pOptions[i].Value.pszValue = NULL;
                plistW->pOptions[i].Value.pszValue = NULL;
            }

            fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (PVOID)&listA,
                                  lpdwBufferLength);

            // Now, convert from ansi to unicode

            if (fResult)
            {
                for (DWORD i=0; i<listA.dwOptionCount; i++)
                {
                    switch (listA.pOptions[i].dwOption)
                    {
                    case INTERNET_PER_CONN_FLAGS:
                    case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                    case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                        plistW->pOptions[i].Value.dwValue = listA.pOptions[i].Value.dwValue;
                        break;

                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                        plistW->pOptions[i].Value.ftValue = listA.pOptions[i].Value.ftValue;
                        break;
                    
                    case INTERNET_PER_CONN_PROXY_SERVER:
                    case INTERNET_PER_CONN_PROXY_BYPASS:
                    case INTERNET_PER_CONN_AUTOCONFIG_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                        if (listA.pOptions[i].Value.pszValue && *listA.pOptions[i].Value.pszValue)
                        {
                            DWORD cc = MultiByteToWideChar(CP_ACP, 
                                                           0, 
                                                           listA.pOptions[i].Value.pszValue, 
                                                           -1,
                                                           NULL,
                                                           0);
                            plistW->pOptions[i].Value.pszValue = (PWSTR)GlobalAlloc(GPTR, cc*sizeof(WCHAR));
                            if (!plistW->pOptions[i].Value.pszValue)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                goto iopco_cleanup;
                            }
                            MultiByteToWideChar(CP_ACP, 
                                                0, 
                                                listA.pOptions[i].Value.pszValue, 
                                                -1,
                                                plistW->pOptions[i].Value.pszValue,
                                                cc);
                        }
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        dwErr = ERROR_INVALID_PARAMETER;
                        goto iopco_cleanup;
                        break;
                    }
                }
            }
            else
            {
                plistW->dwOptionError = listA.dwOptionError;
            }
            
        iopco_cleanup:
            // Free all the allocated buffers
            for (i=0; i<listA.dwOptionCount; i++)
            {
                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    // These should have been converted from ansi to unicode
                    // and can be freed now
                    if (listA.pOptions[i].Value.pszValue)
                    {
                        GlobalFree(listA.pOptions[i].Value.pszValue);
                    }
                    // No point in passing back buffers in the event of an error
                    // condition
                    if (dwErr && plistW->pOptions[i].Value.pszValue)
                    {
                        GlobalFree(plistW->pOptions[i].Value.pszValue);
                    }
                    break;

                default:
                    // No need to do anything
                    break;
                }
            }
        }
        break;

    default:
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  lpdwBufferLength
                                 );
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific INTERNET_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_INTERNET_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INTERNET_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_INTERNET_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INTERNET_BAD_OPTION_LENGTH
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionA",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD error;
    BOOL success = TRUE;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD requiredSize;
    HINTERNET hObjectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT *lphRequest;

    //
    // Auth code can query on connect handle by walking up from request handle,
    // unbeknownst to the client, who might try to set the option concurrently.
    // Ideally access would be serialized only for the four combinations of
    // {user,pass} and {server,proxy}, but unconditional keeps the code simple.
    //

    //AuthLock();

    //
    // validate parameters
    //

    if ((dwBufferLength == 0) || IsBadReadPtr(lpBuffer, dwBufferLength)) {


        switch (dwOption) {

            //
            // these options don't require a buffer - don't fail request because
            // no buffer supplied
            //

            case INTERNET_OPTION_SETTINGS_CHANGED:
            case INTERNET_OPTION_PROXY_SETTINGS_CHANGED:
            case INTERNET_OPTION_END_BROWSER_SESSION:
            case INTERNET_OPTION_RESET_URLCACHE_SESSION:
            case INTERNET_OPTION_REFRESH:
            case INTERNET_OPTION_DIGEST_AUTH_UNLOAD:
            case INTERNET_OPTION_IGNORE_OFFLINE:
            case INTERNET_OPTION_EXEMPT_CONNECTION_LIMIT:
            case INTERNET_OPTION_DISABLE_PASSPORT_AUTH:
            case INTERNET_OPTION_ENABLE_PASSPORT_AUTH:
            case INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS:
            case INTERNET_OPTION_ACTIVATE_WORKER_THREADS:
            case INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS:
                break;

            default:
                error = ERROR_INVALID_PARAMETER;
                goto quit;
        }
    }

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    //
    // validate the handle and get its type
    //

    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternet, FALSE);
        if (error == ERROR_SUCCESS) {
            hObjectMapped = hInternet;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        lpThreadInfo = InternetGetThreadInfo();
        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_INTERNET_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    : ERROR_INTERNET_INVALID_OPTION
                    ;
    }

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if the option and handle combination is valid then set the option value
    //

    switch (dwOption) {
    case INTERNET_OPTION_CALLBACK:
    case INTERNET_OPTION_HANDLE_TYPE:
    //case INTERNET_OPTION_GATEWAY_NAME:
    case INTERNET_OPTION_KEEP_CONNECTION:
    case INTERNET_OPTION_ASYNC_ID:
    case INTERNET_OPTION_ASYNC_REQUEST_COUNT:
    case INTERNET_OPTION_ASYNC_QUEUE_DEPTH:
    case INTERNET_OPTION_WORKER_THREAD_TIMEOUT:
    case INTERNET_OPTION_IDLE_STATE:
    case INTERNET_OPTION_CONNECT_TIME:
    case INTERNET_OPTION_SEND_THROUGHPUT:
    case INTERNET_OPTION_RECEIVE_THROUGHPUT:
    case INTERNET_OPTION_NET_SPEED:

        //
        // these options cannot be set by this function
        //

        error = ERROR_INTERNET_OPTION_NOT_SETTABLE;
        break;

    case INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS:

        if (!g_bDisableHibernation)
        {
            g_bHibernating = TRUE;
        }
        break;
        
    case INTERNET_OPTION_ACTIVATE_WORKER_THREADS:
    
        if (g_bHibernating)
        {
            InterruptSelect();
            GlobalProxyInfo.ActivateAutoproxyThread();
        }
        break;

    case INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS:

        if (g_bHibernating)
        {
            g_bHibernating = FALSE;
            InterruptSelect();
            GlobalProxyInfo.ActivateAutoproxyThread();
        }
        break;
        
    case INTERNET_OPTION_BYPASS_EDITED_ENTRY:
        requiredSize = sizeof(BOOL);
        if (dwBufferLength != requiredSize) {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            break;
        }
        // Only support global, not per handle yet
        if (hInternet != NULL) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            break;
        }

        // Made it this far, so buffer is right size and handle is NULL
        GlobalBypassEditedEntry = *(LPBOOL)lpBuffer;
        break;


    case INTERNET_OPTION_CONNECT_TIMEOUT:
    case INTERNET_OPTION_CONNECT_RETRIES:
    case INTERNET_OPTION_CONNECT_BACKOFF:
    case INTERNET_OPTION_SEND_TIMEOUT:
    case INTERNET_OPTION_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        requiredSize = sizeof(DWORD);
        if (dwBufferLength != requiredSize) {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            break;
        }

        //
        // if hInternet is NULL then the app is requesting that we set the
        // global timeout values, not handle-specific ones
        //

        if (hInternet == NULL) {
            switch (dwOption) {
            case INTERNET_OPTION_CONNECT_TIMEOUT:
                GlobalConnectTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_CONNECT_RETRIES:
                GlobalConnectRetries = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_SEND_TIMEOUT:
                GlobalSendTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_RECEIVE_TIMEOUT:
                GlobalReceiveTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_DATA_SEND_TIMEOUT:
                GlobalDataSendTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
                GlobalDataReceiveTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
                GlobalFromCacheTimeout = *(LPDWORD)lpBuffer;
                break;
            }
            break;
        }


        //
        // we have a non-NULL context handle: the app wants to set specific
        // protocol timeouts
        //

        switch (handleType) {
        case TypeInternetHandle:
        case TypeFtpConnectHandle:
        case TypeFtpFindHandle:
        case TypeFtpFindHandleHtml:
        case TypeFtpFileHandle:
        case TypeFtpFileHandleHtml:
        case TypeGopherConnectHandle:
        case TypeGopherFindHandle:
        case TypeGopherFindHandleHtml:
        case TypeGopherFileHandle:
        case TypeGopherFileHandleHtml:
        case TypeHttpConnectHandle:
        case TypeHttpRequestHandle:

            //
            // N.B. For some of these handle types, setting a timeout etc.
            // value will have absolutely no affect (we have already gotten
            // the information after connecting, sending etc.), but we'll
            // allow the app to go ahead anyway (its benign)
            //

            error = RSetTimeout(hInternet,
                                dwOption,
                                *(LPDWORD)lpBuffer
                                );
            break;

        default:

            //
            // any other handle type (?) cannot have timeouts set for it
            //

            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case INTERNET_OPTION_CONTEXT_VALUE:

        //
        // BUGBUG - can't change context if async operation is pending
        //

        if (dwBufferLength == sizeof(lpThreadInfo->Context)) {
            error = RSetContext(hInternet, *((DWORD*) lpBuffer));
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_NAME_RES_THREAD:
        //if (dwBufferLength == sizeof(MultiThreadedNameResolution)) {
        //    MultiThreadedNameResolution = (BOOL)(*(LPDWORD)lpBuffer != 0);
        //} else {
        //    error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        //}
        break;

    case INTERNET_OPTION_READ_BUFFER_SIZE:
    case INTERNET_OPTION_WRITE_BUFFER_SIZE:
        if (IS_CONNECT_HANDLE_TYPE(handleType)) {
            if (dwBufferLength == sizeof(DWORD)) {

                DWORD bufferSize;

                bufferSize = *(LPDWORD)lpBuffer;
                if (bufferSize > 0) {
                    error = RSetBufferSize(hInternet, dwOption, bufferSize);
                } else {

                    //
                    // the read/write buffer size cannot be set to 0
                    //

                    error = ERROR_INVALID_PARAMETER;
                }
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    BOOL fUser, fProxy;

    case INTERNET_OPTION_ASYNC_PRIORITY:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_AUTH_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetAuthFlag(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case INTERNET_OPTION_USERNAME:
        fUser = IS_USER;
        fProxy = IS_SERVER;
        goto callSetUserOrPass;


    case INTERNET_OPTION_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_SERVER;
        goto callSetUserOrPass;

    case INTERNET_OPTION_PROXY_USERNAME:
        fUser = IS_USER;
        fProxy = IS_PROXY;
        goto callSetUserOrPass;

    case INTERNET_OPTION_PROXY_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_PROXY;
        goto callSetUserOrPass;


callSetUserOrPass:

        if (hInternet == 0)
        {
            if (!fProxy)
            {
                AuthLock();
                SetUserOrPass ((LPSTR)lpBuffer, fUser);
                TimeStampCreds();
                AuthUnlock();
            }
            else
            {
                error = ERROR_INVALID_PARAMETER;
            }
            error = ERROR_SUCCESS;
        }
        else if (handleType != TypeInternetHandle) {
            AuthLock();
            lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
            lphRequest->SetUserOrPass ((LPSTR)lpBuffer, fUser, fProxy);
            lphRequest->TimeStampCreds();
            AuthUnlock();
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }

    break;

    case INTERNET_OPTION_DISABLE_PASSPORT_AUTH:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->DisableTweener();
            error = ERROR_SUCCESS;
        }
                    
        break;

    case INTERNET_OPTION_ENABLE_PASSPORT_AUTH:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->EnableTweener();
            error = ERROR_SUCCESS;
        }
                    
        break;
    
    case INTERNET_OPTION_EXEMPT_CONNECTION_LIMIT:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->ExemptConnLimit();
            error = ERROR_SUCCESS;
        }
                    
        break;

    case INTERNET_OPTION_CLIENT_CERT_CONTEXT:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(CERT_CONTEXT))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            CERT_CONTEXT_ARRAY* pArray = pRequest->GetCertContextArray();
            if (!pArray)
            {
                pArray = new CERT_CONTEXT_ARRAY;
                pRequest->SetCertContextArray(pArray);
            }

            if (!pArray)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
            {
                error = LoadSecurity();
                if (ERROR_SUCCESS == error)
                {
                    pArray->Reset();
                    pArray->AddCertContext((PCCERT_CONTEXT) lpBuffer);
                    pArray->SelectCertContext(0);
                    error = ERROR_SUCCESS;
                }
                else
                {
                    pRequest->SetCertContextArray(NULL);
                }
            }
        }
        break;
    
    case INTERNET_OPTION_SECURITY_SELECT_CLIENT_CERT:

    // This option sets an index into an internal wininet structure.
    // This is worthless to apps because there is no way to guarantee
    // they enum the cert store the same as wininet, especially if the
    // server returns a list of acceptable CA to filter by.  This has
    // been superseded by INTERNET_OPTION_CLIENT_CERT_CONTEXT above.

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            CERT_CONTEXT_ARRAY* pCertContextArray;
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            pCertContextArray =
                lphHttpRqst->GetCertContextArray();

            if ( ! pCertContextArray )
            {
                error = ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP;
            }
            else
            {

                if ( (*((LPINT)lpBuffer) < (INT) pCertContextArray->GetArraySize() )
                      || *((LPINT)lpBuffer) == -1 )
                {
                    pCertContextArray->SelectCertContext( *((LPDWORD)lpBuffer) );

                    error = ERROR_SUCCESS;
                }
                else
                {
                    error = ERROR_INVALID_PARAMETER;
                }
            }
        }
        break;

    case INTERNET_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecureFlags(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case INTERNET_OPTION_REFRESH:

        //
        // BUGBUG - can only accept global or InternetOpen() handles currently
        //

        if (!ARGUMENT_PRESENT(hInternet)) {
            if (!GlobalProxyInfo.IsModifiedInProcess()) {
                FixProxySettingsForCurrentConnection(TRUE);
                error = ERROR_SUCCESS;
            } else {
                INET_ASSERT(error == ERROR_SUCCESS);
            }
        } else if (handleType == TypeInternetHandle) {
            error = ((INTERNET_HANDLE_OBJECT *)hInternet)->Refresh(0);
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_PROXY:
        if ((handleType == TypeInternetHandle) || !ARGUMENT_PRESENT(hInternet)) {

            LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

            //
            // validate parameters
            //

            if (dwBufferLength != sizeof(*lpInfo)) {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            } else if (!((lpInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
                || (lpInfo->dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                || (lpInfo->dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG))
            || ((lpInfo->dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                && ((lpInfo->lpszProxy == NULL) || (*lpInfo->lpszProxy == '\0')))) {
                error = ERROR_INVALID_PARAMETER;
            } else {
                if (!ARGUMENT_PRESENT(hInternet)) {

                    INTERNET_PROXY_INFO_EX info;
                    memset(&info, 0, sizeof(info));
                    info.dwFlags = PROXY_TYPE_DIRECT;
                    

                    switch (lpInfo->dwAccessType) {
                        case INTERNET_OPEN_TYPE_PRECONFIG:
                            FixProxySettingsForCurrentConnection(TRUE);
                            error = ERROR_SUCCESS;
                            goto quit;
                        case INTERNET_OPEN_TYPE_DIRECT:
                            info.dwFlags |= PROXY_TYPE_DIRECT;
                            break;
                        case INTERNET_OPEN_TYPE_PROXY:     
                            info.dwFlags |= PROXY_TYPE_PROXY;
                            info.lpszProxy = lpInfo->lpszProxy;
                            info.lpszProxyBypass = lpInfo->lpszProxyBypass;
                            break;
                    }                    
                    GlobalProxyInfo.SetProxySettings(&info, TRUE ); 

                } else {
                    error = ((INTERNET_HANDLE_OBJECT *)hInternet)->SetProxyInfo(
                                lpInfo->dwAccessType,
                                lpInfo->lpszProxy,
                                lpInfo->lpszProxyBypass
                                );
                }
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_SETTINGS_CHANGED:
        {
            DWORD dwVer;

            IncrementCurrentSettingsVersion(&dwVer);
            // eat the update settings for this process,
            //  since calling ChangeGlobalSettings should suffice
            InternetSettingsChanged(); 
            ChangeGlobalSettings();
            PurgeKeepAlives(PKA_NOW);
        }

        break;

    case INTERNET_OPTION_PROXY_SETTINGS_CHANGED:
        {
            DWORD dwVer;

            IncrementCurrentSettingsVersion(&dwVer);
            // eat the update settings for this process,
            //  since calling ChangeGlobalSettings should suffice
            InternetSettingsChanged(); 
            ChangeGlobalSettings();
            // PurgeKeepAlives(PKA_NOW);
        }

        break;
    
    case INTERNET_OPTION_USER_AGENT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        } else {
            if (handleType == TypeInternetHandle) {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->SetUserAgent((LPSTR)lpBuffer);
            } else {
                error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            }
        }
        break;

    case INTERNET_OPTION_END_BROWSER_SESSION:

        //
        // Flush the in-memory password cache and drop any keep-alive
        // sockets which had authorization (IIS retains the credentials.
        //

        AuthFlush();
        PurgeKeepAlives (PKA_AUTH_FAILED);

        if(g_hDialEvent)
        {
            WaitForSingleObject(g_hDialEvent, INFINITE);
            CloseHandle(g_hDialEvent);
        }

        //
        // Empty the content cache if registry key is set.
        //

        UrlCacheFlush();

        //
        // Flush session cookies.
        //

        PurgeCookieJarOfStaleCookies();

        //
        // Purge Proxy Script Cache
        //

        UPDATE_GLOBAL_PROXY_VERSION();

        //
        // Flush all cached SSL Certificates.
        //

        //GlobalCertCache.ClearList();

        //
        // Need to close global keys
        // 
        ResetAutodialModule();
        CloseInternetSettingsKey();

        //
        // Make sure cert key is reset, too
        //
        CloseMyCertStore();

    // Look out: intentional fall through.

    case INTERNET_OPTION_RESET_URLCACHE_SESSION:

    // Look out: intentional fall through.

        //
        // Restart the session used for cache syncmode.
        //

        GetCurrentGmtTime ((LPFILETIME)&dwdwSessionStartTime);
        dwdwSessionStartTime -= dwdwSessionStartTimeDefaultDelta;
        
        error = ERROR_SUCCESS;
        break;

    case INTERNET_OPTION_DIGEST_AUTH_UNLOAD:
        if (DIGEST_CTX::g_pFuncTbl)
        {
            DIGEST_CTX::Logoff();
            DIGEST_CTX::g_pFuncTbl = NULL;
        }            
        break;

    case INTERNET_OPTION_LINE_STATE:
        if (dwBufferLength == sizeof(INTERNET_ONLINE_OFFLINE_INFO)) {

            LPINTERNET_ONLINE_OFFLINE_INFO lpInfo;
            DWORD state;

            lpInfo = (LPINTERNET_ONLINE_OFFLINE_INFO)lpBuffer;
            state = lpInfo->dwOfflineState;

            //
            // we allow app to pass in INTERNET_STATE_OFFLINE_USER and interpret
            // it as same as INTERNET_STATE_OFFLINE
            //

            if (state == INTERNET_STATE_OFFLINE_USER) {
                state = INTERNET_STATE_OFFLINE;
            }
            if (((state == INTERNET_STATE_ONLINE)
            || (state == INTERNET_STATE_OFFLINE))
            && ((lpInfo->dwFlags & ~ISO_FORCE_OFFLINE) == 0)) {
                error = SetOfflineUserState(state,
                                            (lpInfo->dwFlags & ISO_FORCE_OFFLINE)
                                                ? TRUE
                                                : FALSE
                                            );

                // update registry value
                InternetWriteRegistryDword("GlobalUserOffline",
                        ((state == INTERNET_STATE_ONLINE) ? 0 : 1));

                // notification
                DWORD dwOp = CACHE_NOTIFY_SET_OFFLINE;
                if( state == INTERNET_STATE_ONLINE )
                {
                    dwOp = CACHE_NOTIFY_SET_ONLINE;
                }

                UrlCacheSendNotification(dwOp);

                // invalidate global info so other instances pick it up
                DWORD dwVer;
                IncrementCurrentSettingsVersion(&dwVer);

            } else {
                error = ERROR_INVALID_PARAMETER;
            }
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_OFFLINE_SEMANTICS:
        break;

    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
                if( handleType == TypeHttpRequestHandle ) {
                        lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
                        if (!lphRequest->SetSecondaryCacheKey((LPSTR) lpBuffer)) {
                                error = ERROR_NOT_ENOUGH_MEMORY;
                        } else {
                                INET_ASSERT (error == ERROR_SUCCESS);
                        }
                } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }

        break;

    case INTERNET_OPTION_CALLBACK_FILTER:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(LONG)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetPriority(*(LPLONG)lpBuffer);
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_HTTP_VERSION:
        if (dwBufferLength == sizeof(HTTP_VERSION_INFO)) {
            HttpVersionInfo = *(LPHTTP_VERSION_INFO)lpBuffer;
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_ERROR_MASK:
        lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
        if (dwBufferLength == sizeof(DWORD)) {
            if ( *((LPDWORD) lpBuffer) & ~(INTERNET_ERROR_MASK_INSERT_CDROM |
                                           INTERNET_ERROR_MASK_COMBINED_SEC_CERT |
                                           INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY)) {

                error = ERROR_INVALID_PARAMETER;
            } else {
                lphRequest->SetErrorMask(*(LPDWORD) lpBuffer);
            }
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_CODEPAGE:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(DWORD)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetCodePage(*(LPDWORD)lpBuffer);
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY:
        if (!GlobalSendUTF8ServerToProxy)
        {
            error = ERROR_INTERNET_INVALID_OPTION;
        }
        else if (handleType != TypeHttpRequestHandle) 
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength != sizeof(DWORD))
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        else            
        {
            ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                SetSendUTF8ServerNameToProxy(*(LPDWORD)lpBuffer);
        }
        break;
        
    case INTERNET_OPTION_DISABLE_AUTODIAL:
        if (dwBufferLength == sizeof(DWORD)) {

            DWORD dwValue = *(LPDWORD)lpBuffer;

            SetAutodialEnable(dwValue == 0);
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_AUTODIAL_MODE:
        if(dwBufferLength == sizeof(DWORD))
        {
            SetAutodialMode(*(LPDWORD)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        if(dwBufferLength > 0)
        {
            SetAutodialConnection((LPSTR)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    // Override to disable NTLM preauth.
    case INTERNET_OPTION_DISABLE_NTLM_PREAUTH:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(DWORD)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetDisableNTLMPreauth(*(LPDWORD)lpBuffer);
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_MAX_CONNS_PER_SERVER:
        if (dwBufferLength == sizeof(DWORD)) {
            DWORD dwValue = *(LPDWORD)lpBuffer;

            if( !hInternet )
            {
                GlobalMaxConnectionsPerServer = dwValue;
                // begin a-thkesa: 
                // Using NULL should affect the whole process.
                // As per the bug, its not affecting the visited sites.
                // so browse through the server info and set the new limits to all server.
                // WindSE BUG: 243039 & Windows 612742
                CServerInfo * lpServerInfo;
                LockSerializedList(&GlobalServerInfoList);
                for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
                    lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
                    lpServerInfo = lpServerInfo->Next()) 
                {
                    lpServerInfo->SetNewLimit(dwValue); 
                }
                UnlockSerializedList(&GlobalServerInfoList);
                //end: a-thkesa.
            }
            else
                error = ERROR_INTERNET_INVALID_OPERATION;

        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;


        break;
    case INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (dwBufferLength == sizeof(DWORD)) {
            DWORD dwValue = *(LPDWORD)lpBuffer;

            if( !hInternet )
            {
                GlobalMaxConnectionsPer1_0Server = dwValue;
                // begin a-thkesa: 
                // Using NULL should affect the whole process.
                // As per the bug, its not affecting the visited sites.
                // so browse through the server info and set the new limits to all server.
                // WindSE BUG: 243039 & Windows 612742
                CServerInfo * lpServerInfo;
                LockSerializedList(&GlobalServerInfoList);
                for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
                    lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
                    lpServerInfo = lpServerInfo->Next()) 
                {
                    lpServerInfo->SetNewLimit(dwValue); 
                }
                UnlockSerializedList(&GlobalServerInfoList);
                //end: a-thkesa.
            }
            else
                error = ERROR_INTERNET_INVALID_OPERATION;

        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }

        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = SetPerConnOptions(hInternet, 
                lpThreadInfo? lpThreadInfo->IsAutoProxyProxyThread : FALSE,
                                      (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);
            break;
        }
     
    case INTERNET_OPTION_IGNORE_OFFLINE:
        if (handleType == TypeHttpRequestHandle) {
            ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->SetIgnoreOffline();
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_IDENTITY:
        if (dwBufferLength==sizeof(IUserIdentity2 *))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else if (dwBufferLength==sizeof(GUID))
        {
            error = SwitchIdentity((GUID*)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_REMOVE_IDENTITY:
        if (dwBufferLength==sizeof(GUID))
        {
            error = RemoveIdentity((GUID*)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;
        
    case INTERNET_OPTION_ALTER_IDENTITY:
        if (dwBufferLength==sizeof(DWORD))
        {
            error = AlterIdentity(*(LPDWORD)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_SUPPRESS_BEHAVIOR:
        if (dwBufferLength==sizeof(DWORD))
        {
            error = ERROR_SUCCESS;
            switch (*(LPDWORD)lpBuffer)
            {
            case INTERNET_SUPPRESS_RESET_ALL:
                GlobalSuppressCookiesPolicy = FALSE;
                break;
                
            case INTERNET_SUPPRESS_COOKIE_POLICY:
                GlobalSuppressCookiesPolicy = TRUE;
                break;
                
            case INTERNET_SUPPRESS_COOKIE_POLICY_RESET:
                GlobalSuppressCookiesPolicy = FALSE;
                break;

            default:
                error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_COOKIES_3RD_PARTY:
        if(handleType == TypeHttpRequestHandle)
        {
            if(sizeof(DWORD) == dwBufferLength)
            {
                BOOL f3rdParty = *(BOOL *)lpBuffer;

                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->Set3rdPartyCookies(f3rdParty);
            }
            else
            {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        }
        else
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_SOCKET_SEND_BUFFER_LENGTH:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSocketSendBufferLength(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;


#if INET_DEBUG
    case INTERNET_OPTION_SET_DEBUG_INFO:
        error = InternetSetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     dwBufferLength
                                     );
        break;

#endif // INET_DEBUG

    default:

        //
        // this option is not recognized
        //

        error = ERROR_INTERNET_INVALID_OPTION;
    }

quit:

    //AuthUnlock();

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionW",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    switch (dwOption)
    {
    case INTERNET_OPTION_USERNAME:
    case INTERNET_OPTION_PASSWORD:
    case INTERNET_OPTION_DATAFILE_NAME:
    case INTERNET_OPTION_URL:
    case INTERNET_OPTION_USER_AGENT:
    case INTERNET_OPTION_PROXY_USERNAME:
    case INTERNET_OPTION_PROXY_PASSWORD:
    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        ALLOC_MB((LPWSTR)lpBuffer, dwBufferLength, mpBuffer);
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI((LPWSTR)lpBuffer, mpBuffer);
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  mpBuffer.psStr,
                                  mpBuffer.dwSize
                                 );
        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);
            
            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;

                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                    listA.pOptions[i].Value.dwValue = plistW->pOptions[i].Value.dwValue;
                    break;

                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                    listA.pOptions[i].Value.ftValue = plistW->pOptions[i].Value.ftValue;
                    break;
                    
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    if (plistW->pOptions[i].Value.pszValue && *plistW->pOptions[i].Value.pszValue)
                    {
                        // ** WARNING ** NO UTF8 ENCODING HERE
                        DWORD cb = WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        0, 
                                        0,
                                        NULL,
                                        NULL);
                        listA.pOptions[i].Value.pszValue = (PSTR)_alloca(cb);
                        WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        listA.pOptions[i].Value.pszValue, 
                                        cb,
                                        NULL,
                                        NULL);
                    }
                    else
                    {
                        listA.pOptions[i].Value.pszValue = NULL; 
                    }
                    break;
                    
                default:
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                    break;
                }
            }
            fResult = InternetSetOptionA(hInternet,
                              dwOption,
                              (PVOID)&listA,
                              dwBufferLength);
            plistW->dwOptionError = listA.dwOptionError;
        }
        break;

    default:
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  dwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSetOptionExA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific INTERNET_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

    dwFlags             - flags controlling operation. Possible values are:

                            ISO_GLOBAL      - set this option globally. The
                                              shared Wininet data segment will
                                              be updated with this value

                            ISO_REGISTRY    - this value will be written to the
                                              registry for the corresponding
                                              entry

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_INTERNET_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INTERNET_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_INTERNET_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INTERNET_BAD_OPTION_LENGTH
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionExA",
                     "%#x, %s (%d), %#x [%#x], %d, %#x",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength,
                     dwFlags
                     ));

    BOOL success;

    //
    // validate parameters
    //

    //
    // currently, dwFlags MBZ
    //

    if (dwFlags == 0) {
        success = InternetSetOptionA(hInternet,
                                     dwOption,
                                     lpBuffer,
                                     dwBufferLength
                                     );
    } else {
        DEBUG_ERROR(INET, ERROR_INVALID_PARAMETER);
        SetLastError(ERROR_INVALID_PARAMETER);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI_(BOOL) InternetSetOptionExW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

    dwFlags         -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionExW",
                     "%#x, %s (%d), %#x [%#x], %d, %#x",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength,
                     dwFlags
                     ));

    BOOL fResult = FALSE;

    if (dwFlags)
    {
        DEBUG_ERROR(INET, ERROR_INVALID_PARAMETER);
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        fResult = InternetSetOptionW(hInternet,
                                     dwOption,
                                     lpBuffer,
                                     dwBufferLength
                                     );
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    )
{
    return ((hType != TypeInternetHandle)   &&
            (hType != TypeFtpConnectHandle) &&
            (hType != TypeGopherConnectHandle) &&
            (hType != TypeFileRequestHandle) &&
            (hType != TypeHttpConnectHandle));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\registry.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

    Contents:
        EnsureInternetSettingsKeyCached
        CloseInternetSettingsKey
        GetMyEmailName
        InternetGetComputerName
        InternetDeleteRegistryValue
        InternetReadRegistryDword
        InternetWriteRegistryDword
        InternetReadRegistryString
        InternetWriteRegistryString
        InternetReadRegistryBinary
        (InternetReadRegistryDwordKey)
        (InternetReadRegistryStringKey)
        (InternetReadRegistryBinaryKey)
        (InternetGetPrivateProfileString)
        (ReadRegistryOemString)
        (WriteRegistryDword)
        ReadRegistryDword
        GetFileExtensionFromMimeType
        CreateMimeExclusionTableForCache
        DestroyMimeExclusionTableForCache
        CreateHeaderExclusionTableForCache
        DestroyHeaderExclusionTableForCache
        (CreateTableFromRegistryList)
        (CreateStringArrayFromDelimitedList)

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Environment:

    Win32(s) user-level DLL

Revision History:

    20-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

char vszDelimiters[] = ";, ";

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );


PRIVATE
DWORD
CreateTableFromRegistryList(
    IN LPSTR   lpszParameter,       // wininet registry parameter
    OUT LPSTR   *lplpszList,        // Delimited List
    OUT LPSTR   **lplprgszTable,    // Pointer table pointing into the list
    OUT DWORD   **lplpdwTableSizes, // Pointer to table containing sizes of string elements
    OUT LPDWORD lpdwCount           // count of elements in the table
    );

PRIVATE
DWORD
CreateStringArrayFromDelimitedList(
    IN  LPSTR   lpszDelimitedList,
    IN  LPSTR   lpszDelimiters,
    IN  LPSTR   *lprgszStringArray,
    OUT LPDWORD lpdwCount
    );


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

//
// private data
//

PRIVATE CRefdKey* g_prkInternetSettings = NULL;


//
// functions
//

CRefdKey*
OpenInternetSettingsKey(
    VOID
    )
{
    CRefdKey* prk = NULL;
    HKEY hkInternetSettings = NULL;
    DWORD dwDisposition;

    REGCREATEKEYEX(HKEY_CURRENT_USER,
                   INTERNET_SETTINGS_KEY,
                   0,     // reserved
                   NULL,  // class
                   0,     // options
                   KEY_READ | KEY_WRITE,
                   NULL,  // security attributes
                   &hkInternetSettings,
                   &dwDisposition
                   );

    if (hkInternetSettings)
    {
        prk = new CRefdKey(hkInternetSettings);

        if (!prk)
        {
            // we failed to create a ref'd key, so close the key we opened
            REGCLOSEKEY(hkInternetSettings);
        }
    }

    return prk;
}


CRefdKey*
GetInternetSettingsKey(
    VOID
    )
{
    CRefdKey* prk;

    EnterCriticalSection(&GeneralInitCritSec);

    prk = g_prkInternetSettings;
    if (prk)
    {
        prk->AddRef();
    }
    else
    {
        prk = OpenInternetSettingsKey();
        if (prk)
        {
            // addref once more for sticking in in the global
            prk->AddRef();

            // cache this value in the global
            g_prkInternetSettings = prk;
        }
    }

    LeaveCriticalSection(&GeneralInitCritSec);

    return prk;
}


VOID
EnsureInternetSettingsKeyCached(
    VOID
    )

/*++

Routine Description:

    Ensures that the registry key for the Internet Settings branch is 
    cached and ready to be used

Arguments:

    None.

Return Value:

    None.

--*/

{
    CRefdKey* prk;

    DEBUG_ENTER((DBG_REGISTRY,
                 None,
                 "EnsureInternetSettingsKeyCached",
                 NULL
                 ));

    // just get the key and release it to ensure that it has been cached in g_prkInternetSettings
    prk = GetInternetSettingsKey();
    if (prk)
    {
        prk->Release();
    }
}



DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "CloseInternetSettingsKey",
                 NULL
                 ));

    CRefdKey* prk;

    EnterCriticalSection (&GeneralInitCritSec);

    prk = g_prkInternetSettings;
    if (prk)
    {
        g_prkInternetSettings = NULL;

        prk->Release();
    }

    LeaveCriticalSection (&GeneralInitCritSec);

    DEBUG_LEAVE(ERROR_SUCCESS);

    return ERROR_SUCCESS;
}


DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Retrieve the user's email name from the appropriate place in the registry

Arguments:

    EmailName   - place to store email name

    Length      - IN: length of EmailName
                  OUT: returned length of EmailName (in characters, minus
                       trailing NUL)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                  ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "GetMyEmailName",
                 "%#x, %#x [%d]",
                 EmailName,
                 Length,
                 *Length
                 ));

    DWORD error;

    //
    // for the EmailName, we first try HKEY_CURRENT_USER. If that fails then we
    // try the same branch of the HKEY_LOCAL_MACHINE tree. If that fails,
    // invent something
    //

    static HKEY KeysToTry[2] = {HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE};
    int i;

    //
    // in the event we cannot find EmailName in both HKEY_CURRENT_USER and
    // HKEY_LOCAL_MACHINE trees, then we return this default
    //

    static char DefaultEmailName[] = DEFAULT_EMAIL_NAME;

    for (i = 0; i < ARRAY_ELEMENTS(KeysToTry); ++i) {
        error = InternetReadRegistryStringKey(KeysToTry[i],
                                              "EmailName",
                                              EmailName,
                                              Length
                                              );
        if (error == ERROR_SUCCESS) {
            break;
        }
    }
    if (error != ERROR_SUCCESS) {
        if (IsPlatformWinNT()) {

            //
            // only NT supports GetUserName()
            //

            if (GetUserName(EmailName, Length)) {

                //
                // we return the length as if the result from strlen/wcslen
                //

                *Length -= sizeof(char);

                DEBUG_PRINT(REGISTRY,
                            INFO,
                            ("GetUserName() returns %q\n",
                            EmailName
                            ));

                error = ERROR_SUCCESS;
            } else {

                //
                // BUGBUG - what's the required length?
                //

                error = GetLastError();
            }
        } else {

            //
            // Win95 & Win32s: have to do something different
            //

        }

        //
        // if we still don't have an email name, we use an internal default
        //

        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("Cannot find EmailName: using default (%s)\n",
                        DefaultEmailName
                        ));

            if (*Length >= sizeof(DEFAULT_EMAIL_NAME)) {
                memcpy(EmailName, DefaultEmailName, sizeof(DEFAULT_EMAIL_NAME));

                //
                // success - returned length as if from strlen()
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME) - 1;
                error = ERROR_SUCCESS;
            } else {

                //
                // failure - returned length is the required buffer size
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME);
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetGetComputerName(
//    OUT LPSTR Buffer,
//    IN OUT LPDWORD Length
//    )
//
///*++
//
//Routine Description:
//
//    Platform-dependent function that returns this computer's name
//
//Arguments:
//
//    Buffer  - pointer to buffer where name is returned
//
//    Length  - IN: number of bytes in Buffer
//              OUT: number of characters in computer name, exluding terminating
//              NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - Win32 error
//
//--*/
//
//{
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//        error = InternetGetPrivateProfileString(SYSTEM_INI_FILE_NAME,
//                                                NETWORK_SECTION_NAME,
//                                                COMPUTER_NAME_VALUE,
//                                                Buffer,
//                                                Length
//                                                );
//    } else {
//        if (GetComputerName(Buffer, Length)) {
//            error = ERROR_SUCCESS;
//        } else {
//            error = GetLastError();
//        }
//    }
//    return error;
//}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_CURRENT_USER,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}

#ifdef WININET6

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity 
                ? WriteIDRegDword(ParameterName, ParameterValue)
                : InternetWriteRegistryDword(ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    If we're in an identity-mode, we'll read from the special location.
    Otherwise, read from the old location.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity
                ? ReadIDRegDword(ParameterName, ParameterValue)
                : InternetReadRegistryDwordKey(HKEY_CURRENT_USER, ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}
#endif


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    CRefdKey* prk = GetInternetSettingsKey();

    if (prk != NULL) {
        error = WriteRegistryDword(prk->GetKey(),
                                   ParameterName,
                                   ParameterValue
                                   );
        prk->Release();

    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetWriteRegistryString(
//    IN LPCSTR ParameterName,
//    IN LPSTR ParameterValue
//    )
//
///*++
//
//Routine Description:
//
//    Writes a string to the Internet Client registry key on NT/Win95, or writes
//    the corresponding value to SYSTEM.INI on Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to string to write
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetWriteRegistryString",
//                 "%.40q, %.80q",
//                 ParameterName,
//                 ParameterValue
//                 ));
//
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//
//        BOOL ok;
//
//        ok = WritePrivateProfileString(INTERNET_CLIENT_KEY,
//                                       ParameterName,
//                                       ParameterValue,
//                                       SYSTEM_INI_FILE_NAME
//                                       );
//        error = ok ? ERROR_SUCCESS : GetLastError();
//    } else {
//
//        //
//        // BUGBUG - currently, nothing needs to write to registry if NT or Win95
//        //
//
//        INET_ASSERT(FALSE);
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinary",
//                 "%q, %#x, %#x [%d]",
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//
//    error = InternetReadRegistryBinaryKey(HKEY_CURRENT_USER,
//                                          ParameterName,
//                                          ParameterValue,
//                                          ParameterLength
//                                          );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    CRefdKey* prk = GetInternetSettingsKey();
    BOOL bOpenedKey = FALSE;
    HKEY hkSettings = NULL;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &hkSettings
                             );
        if (error == ERROR_SUCCESS) {
            bOpenedKey = TRUE;
        }
    } else if (prk) {
        hkSettings = prk->GetKey();
    } else {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(hkSettings,
                                  ParameterName,
                                  ParameterValue
                                  );
    }
    
    if (bOpenedKey) {
        REGCLOSEKEY(hkSettings);
    }

    if (prk) {
        prk->Release();
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    CRefdKey* prk = GetInternetSettingsKey();
    BOOL bOpenedKey = FALSE;
    HKEY hkSettings = NULL;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &hkSettings
                             );
        if (error == ERROR_SUCCESS) {
            bOpenedKey = TRUE;
        }
    } else if (prk) {
        hkSettings = prk->GetKey();
    } else {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(hkSettings,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
    }
    
    if (bOpenedKey) {
        REGCLOSEKEY(hkSettings);
    }

    if (prk) {
        prk->Release();
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}

//
//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinaryKey",
//                 "%s (%x), %q, %#x, %#x [%d]",
//                 (ParameterKey == HKEY_LOCAL_MACHINE)
//                    ? "HKEY_LOCAL_MACHINE"
//                    : (ParameterKey == HKEY_CURRENT_USER)
//                        ? "HKEY_CURRENT_USER"
//                        : "???",
//                 ParameterKey,
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//    HKEY clientKey;
//
//    //
//    // open the registry key containing the Internet client values (this is
//    // in the same place on NT and Win95)
//    //
//
//    error = REGOPENKEYEX(ParameterKey,
//                         INTERNET_SETTINGS_KEY,
//                         0, // reserved
//                         KEY_QUERY_VALUE,
//                         &clientKey
//                         );
//
//    if (error == ERROR_SUCCESS) {
//
//        DWORD valueType;
//
//        error = RegQueryValueEx(clientKey,
//                                ParameterName,
//                                NULL,   // reserved
//                                &valueType,
//                                ParameterValue,
//                                ParameterLength
//                                );
//        REGCLOSEKEY(clientKey);
//    }
//
//    DEBUG_PRINT(REGISTRY,
//                INFO,
//                ("InternetReadRegistryBinaryKey(%q): length = %d\n",
//                ParameterName,
//                *ParameterLength
//                ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads an string out of an INI file. Mainly just for Win32s
//
//Arguments:
//
//    IniFileName     - name of INI file to read
//
//    SectionName     - name of section in INI file to read
//
//    ParameterName   - name of entry in section to read
//
//    ParameterValue  - returned string
//
//    ParameterLength - IN: Length of ParameterValue
//                      OUT: Number of characters in ParameterValue, excluding
//                           terminating NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                  ERROR_FILE_NOT_FOUND
//
//--*/
//
//{
//    DWORD error;
//    DWORD nChars;
//
//    nChars = GetPrivateProfileString(SectionName,
//                                     ParameterName,
//                                     "",                // lpszDefault
//                                     ParameterValue,
//                                     *ParameterLength,
//                                     IniFileName
//                                     );
//    if (nChars > 0) {
//        *ParameterLength = nChars;
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_PATH_NOT_FOUND;
//    }
//    return error;
//}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_INTERNET_BAD_REGISTRY_PARAMETER
                    Inconsistent registry contents

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    LPSTR str;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_INTERNET_BAD_REGISTRY_PARAMETER;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}


BOOL
GetFileExtensionFromMimeType(
    LPCSTR  lpszMimeType,
    DWORD   dwMimeLen,
    LPSTR   lpszFileExtension,
    LPDWORD lpdwExtLen
    )
{
    HKEY    hKey = NULL;
    LPSTR   lpszMimeKey = (LPSTR)_alloca(sizeof(MIME_TO_FILE_EXTENSION_KEY)+dwMimeLen);

    memcpy(lpszMimeKey, MIME_TO_FILE_EXTENSION_KEY,
            sizeof(MIME_TO_FILE_EXTENSION_KEY)-1);
    memcpy(lpszMimeKey + sizeof(MIME_TO_FILE_EXTENSION_KEY) - 1, lpszMimeType,
            dwMimeLen);
    lpszMimeKey[sizeof(MIME_TO_FILE_EXTENSION_KEY) + dwMimeLen - 1] = '\0';

    if (REGOPENKEYEX(HKEY_CLASSES_ROOT,
                               lpszMimeKey,
                               0,
                               KEY_QUERY_VALUE,
                               &hKey)==ERROR_SUCCESS)
    {
        DWORD dwType, dwError = RegQueryValueEx(hKey,
                                EXTENSION_VALUE,
                                NULL,
                                &dwType,
                                (LPBYTE)lpszFileExtension,
                                lpdwExtLen);
        REGCLOSEKEY(hKey);
        return (dwError==ERROR_SUCCESS);
    }
    return FALSE;
}



DWORD
CreateMimeExclusionTableForCache()
{
    INET_ASSERT(lpvrgszMimeExclusionTable == NULL);
    INET_ASSERT(vszMimeExclusionList == NULL);

    return (CreateTableFromRegistryList("MimeExclusionListForCache",
                                        &vszMimeExclusionList,
                                        &lpvrgszMimeExclusionTable,
                                        &lpvrgdwMimeExclusionTableOfSizes,
                                        &vdwMimeExclusionTableCount));
}

VOID
DestroyMimeExclusionTableForCache()
{
    if (lpvrgszMimeExclusionTable) {

        INET_ASSERT(vszMimeExclusionList != NULL);

        FREE_MEMORY(lpvrgszMimeExclusionTable);
        FREE_MEMORY(lpvrgdwMimeExclusionTableOfSizes);
        FREE_MEMORY(vszMimeExclusionList);

        lpvrgszMimeExclusionTable = NULL;
        vszMimeExclusionList = NULL;
        vdwMimeExclusionTableCount = 0;
    }
}


DWORD
CreateHeaderExclusionTableForCache()
{
    INET_ASSERT(lpvrgszHeaderExclusionTable == NULL);
    INET_ASSERT(vszHeaderExclusionList == NULL);

    return (CreateTableFromRegistryList("HeaderExclusionListForCache",
                                        &vszHeaderExclusionList,
                                        &lpvrgszHeaderExclusionTable,
                                        NULL,
                                        &vdwHeaderExclusionTableCount));

}

VOID
DestroyHeaderExclusionTableForCache()
{
    if (lpvrgszHeaderExclusionTable) {

        INET_ASSERT(vszHeaderExclusionList != NULL);

        FREE_MEMORY(lpvrgszHeaderExclusionTable);
        FREE_MEMORY(vszHeaderExclusionList);

        lpvrgszHeaderExclusionTable = NULL;
        vszHeaderExclusionList = NULL;
        vdwHeaderExclusionTableCount = 0;
    }
}


PRIVATE
DWORD
CreateTableFromRegistryList(
    IN LPSTR   lpszParameter,       // wininet registry parameter
    OUT LPSTR   *lplpszList,        // Delimited List
    OUT LPSTR   **lplprgszTable,    // Pointer table pointing into the list
    OUT DWORD   **lplpdwTableSizes, // Pointer to table containing sizes of string elements
    OUT LPDWORD lpdwCount           // count of elements in the table
    )

/*++

Routine Description:

    Creates argv array from registry string

Arguments:

    lpszParameter       - wininet registry parameter

    lplpszList          - delimited List

    lplprgszTable       - pointer table pointing into the list

    lplpdwTableSizes    - pointer to table containing sizes of string elements

    lpdwCount           - count of elements in the table

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  ERROR_INVALID_PARAMETER

--*/

{
    INET_ASSERT(lplpszList != NULL);
    INET_ASSERT(lplprgszTable != NULL);

    DWORD dwLen = 0;
    DWORD error;

    //
    // let us find out the length of this string
    //

    error = InternetReadRegistryString(lpszParameter, NULL, &dwLen);
    if ((error != ERROR_SUCCESS) && (error != ERROR_MORE_DATA)) {
        return error;
    }

    dwLen += 2; // for good measure
    if (!(*lplpszList = (LPSTR)ALLOCATE_MEMORY(LPTR, dwLen))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    error = InternetReadRegistryString(lpszParameter, *lplpszList, &dwLen);

    //
    // if it fails now, we need to bailout
    //

    if (error != ERROR_SUCCESS) {
        goto bailout;
    }

    //
    // now let us see how many elements are there in this list
    //

    error = CreateStringArrayFromDelimitedList(*lplpszList,
                                               vszDelimiters,
                                               NULL,
                                               lpdwCount
                                               );
    if (!*lpdwCount) {
        error = ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    //
    // let us allocate an array of pointers
    //

    if (!(*lplprgszTable = (LPSTR *)ALLOCATE_MEMORY(LPTR, *lpdwCount * sizeof(LPSTR)))) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto bailout;
    }

    error = CreateStringArrayFromDelimitedList(*lplpszList,
                                               vszDelimiters,
                                               *lplprgszTable,
                                               lpdwCount
                                               );

    INET_ASSERT(*lpdwCount);

    if ((lplpdwTableSizes == NULL) || (error != ERROR_SUCCESS)) {
        goto bailout;
    }

    *lplpdwTableSizes = (LPDWORD)ALLOCATE_MEMORY(LPTR, (sizeof(DWORD)*(*lpdwCount)));

    if (*lplpdwTableSizes == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto bailout;
    }

    DWORD i;

    for (i = 0; i < *lpdwCount; i++) {

        INET_ASSERT((*lplprgszTable)[i]);

        (*lplpdwTableSizes)[i] = lstrlen((*lplprgszTable)[i]);
    }

bailout:

    if (error != ERROR_SUCCESS) {
        if (*lplpszList) {
            FREE_MEMORY(*lplpszList);
            *lplpszList = NULL;
        }
        if (*lplprgszTable) {
            FREE_MEMORY(*lplprgszTable);
            *lplprgszTable = NULL;
        }
    }

    return error;
}


PRIVATE
DWORD
CreateStringArrayFromDelimitedList(
    IN  LPSTR   lpszDelimitedList,
    IN  LPSTR   lpszDelimiters,
    IN  LPSTR   *lprgszStringArray,
    OUT LPDWORD lpdwCount
    )
{

    LPSTR   lpStart, lpEnd, lpTmp;
    DWORD   dwError = ERROR_INVALID_PARAMETER;

    *lpdwCount = 0;

    lpStart = lpszDelimitedList;
    lpEnd = lpStart + strlen(lpszDelimitedList);    // points to null

    // strip out the trailing spaces
    for(;(lpStart<lpEnd);--lpEnd) {
        int c;
        c = (int)*(lpEnd-1);
        if (!isspace(c)) {
            *lpEnd = '\0';
            break;
        }
    }

    // bailout if this is an empty string
    if (lpStart == lpEnd) {
        goto done;
    }

    dwError = ERROR_SUCCESS;

    for (lpTmp = lpStart;(lpTmp && (lpEnd > lpStart)); lpStart = lpTmp+1) {
        int c;

        lpTmp = lpStart;

        c = (int)*lpStart;
        if (isspace(c)) {
             continue;
        }

        // when we come here there is a non space character
        INET_ASSERT(!isspace(*lpStart));

        lpTmp = strpbrk(lpStart, lpszDelimiters);

        if (lprgszStringArray) {

            if (lpTmp) {
                *lpTmp = 0; // create a string out of it
            }
            // plug the start pointer into the array
            lprgszStringArray[*lpdwCount] = lpStart;
        }

        ++*lpdwCount;

    }
done:
    return (dwError);
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

SERIALIZED_LIST DbgRegKeyList;

VOID DbgRegKey_Init(VOID) {
    InitializeSerializedList(&DbgRegKeyList);
}

VOID DbgRegKey_Terminate(VOID) {
    TerminateSerializedList(&DbgRegKeyList);
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {

    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
//dprintf("Wininet.DbgRegKey: adding %q\n", name);
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
}

void regkey_remove(HKEY hkey) {
    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {
            RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
//dprintf("Wininet.DbgRegKey: removing %q\n", p->name);
            FREE_MEMORY(p);
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);
}

char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;

    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {

            int len = lstrlen(p->name);
            int slen = lstrlen(subname);

            name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
            if (name) {
                memcpy(name, p->name, len);
                name[len] = '\\';
                memcpy(name + len + 1, subname, slen + 1);
            }
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);

    return name;
}

void regkey_freename(char * name) {
    if (name) {
        FREE_MEMORY(name);
    }
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\rashelp.cxx ===
/////////////////////////////////////////////////////////////////////////////
//
// RAS API wrappers for wide/ansi
//
// Works on all 9x and NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

#include "wininetp.h"
#include "rashelp.h"
#include "autodial.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
ENUM_TYPE GetOSVersion::_EnumType = ENUM_NONE;

GetOSVersion::GetOSVersion()
{
    if(_EnumType == ENUM_NONE)
    {
        if(0 == GlobalPlatformType)
            GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        // figure out which kind of enumeration we're doing - start with multibyte
        _EnumType = ENUM_MULTIBYTE;

        if(PLATFORM_TYPE_WINNT == GlobalPlatformType)
        {
            if(TRUE == GlobalPlatformVersion5)
                _EnumType = ENUM_WIN2K;
            else
                _EnumType = ENUM_UNICODE;
        }
    }
}

GetOSVersion::~GetOSVersion()
{
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        dwStructSize = sizeof(RASENTRYNAMEA);
        break;
    case ENUM_UNICODE:
        dwStructSize = sizeof(RASENTRYNAMEW);
        break;
    case ENUM_WIN2K:
        dwStructSize = sizeof(W2KRASENTRYNAMEW);
        break;
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
    if(_preList)
    {
        do
        {
            // set up list
            _preList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            if(ENUM_MULTIBYTE == _EnumType)
            {
                _dwLastError = _RasEnumEntriesA(
                                NULL,
                                NULL,
                                (LPRASENTRYNAMEA)_preList,
                                &dwBufSize,
                                &_dwEntries
                                );
            }
            else
            {
                _dwLastError = _RasEnumEntriesW(
                                NULL,
                                NULL,
                                (LPRASENTRYNAMEW)_preList,
                                &dwBufSize,
                                &_dwEntries
                                );
            }

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_preList);
                _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _preList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_preList && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_preList);
        _preList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_preList)
    {
        LocalFree(_preList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPWSTR
RasEnumHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_preList[dwConnectionNum].szEntryName)
        {
            MultiByteToWideChar(CP_ACP, 0, _preList[dwConnectionNum].szEntryName,
                -1, _szCurrentEntryW, RAS_MaxEntryName + 1);
            pwszName = _szCurrentEntryW;
        }
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_preList[dwConnectionNum].szEntryName)
            pszName = _preList[dwConnectionNum].szEntryName;
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    }

    return pszName;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEnumConnHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEnumConnHelp::RasEnumConnHelp()
{
    DWORD           dwBufSize;

    // init
    _dwConnections = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwStructSize = sizeof(RASCONNA);
        break;
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASCONNW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASCONNW);
        break;
    }

    // allocate space for MAX_CONNECTION entries
    dwBufSize = MAX_CONNECTION * _dwStructSize;
    _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
    if(_pRasCon == NULL)
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasEnumConnHelp::~RasEnumConnHelp()
{
    if(_pRasCon)
    {
        LocalFree(_pRasCon);
        _pRasCon = NULL;
    }
}

DWORD RasEnumConnHelp::Enum()
{
    DWORD           dwBufSize;

    _dwLastError = 0;

    if(_pRasCon)
    {
        dwBufSize = MAX_CONNECTION * _dwStructSize;
        do
        {
            // set up list
            _pRasCon[0].dwSize = _dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            switch(_EnumType)
            {
                case ENUM_MULTIBYTE:
                    _dwLastError = _RasEnumConnectionsA((LPRASCONNA)_pRasCon, &dwBufSize, &_dwConnections);
                    break;
                case ENUM_UNICODE:
                case ENUM_WIN2K:
                    _dwLastError = _RasEnumConnectionsW((LPRASCONNW)_pRasCon, &dwBufSize, &_dwConnections);
                    break;
            }

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_pRasCon);
                _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _pRasCon)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetConnectionsCount()
{
    return _dwConnections;
}

LPWSTR
RasEnumConnHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_pRasCon[dwConnectionNum].szEntryName)
        {
            MultiByteToWideChar(CP_ACP, 0, _pRasCon[dwConnectionNum].szEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1);
            pwszName = _szEntryNameW;
        }
        break;
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumConnHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_pRasCon[dwConnectionNum].szEntryName)
            pszName = _pRasCon[dwConnectionNum].szEntryName;
        break;
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW )_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    }

    return pszName;
}

LPWSTR
RasEnumConnHelp::GetLastEntryW(DWORD dwConnectionNum)
{
    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameW;
}

LPSTR
RasEnumConnHelp::GetLastEntryA(DWORD dwConnectionNum)
{
    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameA;
}

HRASCONN
RasEnumConnHelp::GetHandle(DWORD dwConnectionNum)
{
    HRASCONN hTemp;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        hTemp = _pRasCon[dwConnectionNum].hrasconn;
        break;
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    }

    return hTemp;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEntryPropHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEntryPropHelp::RasEntryPropHelp()
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwStructSize = sizeof(RASENTRYA);
        break;
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASENTRYW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASENTRYW);
        break;
    }

    _pRasEntry = (LPRASENTRYA)LocalAlloc(LPTR, _dwStructSize * 2);
    if(_pRasEntry)
    {
        _pRasEntry->dwSize = _dwStructSize;
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_pRasEntry && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
    return;
}

RasEntryPropHelp::~RasEntryPropHelp()
{
    if(_pRasEntry)
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
}

DWORD RasEntryPropHelp::GetError()
{
    return _dwLastError;
}

DWORD RasEntryPropHelp::GetA(LPSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwLastError = _RasGetEntryPropertiesA(NULL, lpszEntryName, (LPRASENTRYA)_pRasEntry, &dwSize, NULL, NULL);
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1 );
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1);
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

DWORD RasEntryPropHelp::GetW(LPWSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        WideCharToMultiByte(CP_ACP, 0, lpszEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
        _dwLastError = _RasGetEntryPropertiesA(NULL, _szEntryNameA, (LPRASENTRYA)_pRasEntry, &dwSize, NULL, NULL);
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

LPWSTR RasEntryPropHelp::GetDeviceTypeW(VOID)
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szDeviceType)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szDeviceType, -1, _szDeviceTypeW, RAS_MaxDeviceType  + 1);
                lpwstr = _szDeviceTypeW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetDeviceTypeA(VOID)
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szDeviceType)
                lpstr = _pRasEntry->szDeviceType;
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodiallDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialDll)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szAutodialDll, -1, _szAutodialDllW, MAX_PATH);
                lpwstr = _szAutodialDllW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodiallDllA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialDll)
                lpstr = _pRasEntry->szAutodialDll;
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodialFuncW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialFunc)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szAutodialFunc, -1, _szAutodialFuncW, RAS_MaxDeviceType  + 1);
                lpwstr = _szAutodialFuncW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodialFuncA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialFunc)
                lpstr = _pRasEntry->szAutodialFunc;
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetCustomDialDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:    // Not in Win9x
            break;
        case ENUM_UNICODE:      // Not is NT4
            break;
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry  ;
            if(*lpTemp->szCustomDialDll)
                lpwstr = lpTemp->szCustomDialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPWSTR RasEntryPropHelp::GetPhoneNumberW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szLocalPhoneNumber)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szLocalPhoneNumber, -1, _szPhoneNumberW, RAS_MaxPhoneNumber);
                lpwstr = _szPhoneNumberW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        }
    }

    return lpwstr;
}


DWORD RasEntryPropHelp::GetCountryCode()
{
    DWORD dwCode = 0;

    if(_pRasEntry)
    {
        // country code is at the same place for all versions of the struct,
        // so take the shortcut
        dwCode = _pRasEntry->dwCountryCode;
    }

    return dwCode;
}

DWORD RasEntryPropHelp::GetOptions()
{
    DWORD dwOptions = 0;

    if(_pRasEntry)
    {
        // dwfOptions is at the same place for all versions of the struct,
        // so take the shortcut
        dwOptions = _pRasEntry->dwfOptions;
    }

    return dwOptions;
}

LPWSTR RasEntryPropHelp::GetAreaCodeW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAreaCode)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szAreaCode, -1, _szAreaCodeW, RAS_MaxAreaCode);
                lpwstr = _szAreaCodeW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        }
    }

    return lpwstr;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasEntryDialParamsHelp::RasEntryDialParamsHelp()
{
    // init
    _dwLastError = 0;
    _pRasDialParamsA = NULL;

    if(_EnumType == ENUM_MULTIBYTE)
    {
        _pRasDialParamsA = (LPRASDIALPARAMSA)LocalAlloc(LPTR, sizeof(RASDIALPARAMSA));
        if(_pRasDialParamsA == NULL)
        {
            _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            _pRasDialParamsA->dwSize = sizeof(RASDIALPARAMSA);
        }
    }
    return;
}

RasEntryDialParamsHelp::~RasEntryDialParamsHelp()
{
    _dwLastError = 0;

    if(_pRasDialParamsA)
    {
        LocalFree(_pRasDialParamsA);
        _pRasDialParamsA= NULL;
    }
}

DWORD RasEntryDialParamsHelp::GetError()
{
    return _dwLastError;
}

DWORD RasEntryDialParamsHelp::SetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, BOOL fRemovePassword)
{
    _dwLastError = 1;

    if(lprasdialparams)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(_pRasDialParamsA)
            {
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szEntryName, -1, _pRasDialParamsA->szEntryName, RAS_MaxEntryName  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szPhoneNumber, -1, _pRasDialParamsA->szPhoneNumber, RAS_MaxPhoneNumber  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szCallbackNumber, -1, _pRasDialParamsA->szCallbackNumber, RAS_MaxCallbackNumber  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szUserName, -1, _pRasDialParamsA->szUserName, UNLEN  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szPassword, -1, _pRasDialParamsA->szPassword, PWLEN  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szDomain, -1, _pRasDialParamsA->szDomain, DNLEN  , NULL, NULL);
                _dwLastError = _RasSetEntryDialParamsA(NULL, _pRasDialParamsA, fRemovePassword);
            }
            break;
        case ENUM_UNICODE:
        case ENUM_WIN2K:
            _dwLastError = _RasSetEntryDialParamsW(NULL, lprasdialparams, fRemovePassword);
            break;
        }
    }

    return _dwLastError;
}

DWORD RasEntryDialParamsHelp::GetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, LPBOOL pfRemovePassword)
{
    _dwLastError = 1;

    if(lprasdialparams)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szEntryName, -1, _pRasDialParamsA->szEntryName, RAS_MaxEntryName, NULL, NULL);
            _dwLastError = _RasGetEntryDialParamsA(NULL, _pRasDialParamsA, pfRemovePassword);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szEntryName, -1, lprasdialparams->szEntryName, RAS_MaxEntryName);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szPhoneNumber, -1, lprasdialparams->szPhoneNumber, RAS_MaxPhoneNumber);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szCallbackNumber, -1, lprasdialparams->szCallbackNumber, RAS_MaxCallbackNumber);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szUserName, -1, lprasdialparams->szUserName, UNLEN);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szPassword, -1, lprasdialparams->szPassword, PWLEN);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szDomain, -1, lprasdialparams->szDomain, DNLEN);
            break;
        case ENUM_UNICODE:
        case ENUM_WIN2K:
            _dwLastError = _RasGetEntryDialParamsW(NULL, lprasdialparams, pfRemovePassword);
            break;
        }
    }

    return _dwLastError;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasGetConnectStatusHelp::RasGetConnectStatusHelp(HRASCONN hrasconn)
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwStructSize = sizeof(RASCONNSTATUSA);
        break;
    case ENUM_UNICODE:
    case ENUM_WIN2K:
        _dwStructSize = sizeof(RASCONNSTATUSW);
        break;
    }

    _pRasConnStatus = (LPRASCONNSTATUSA)LocalAlloc(LPTR, _dwStructSize);
    if(_pRasConnStatus)
    {
        _pRasConnStatus->dwSize = _dwStructSize;

        if(_EnumType == ENUM_MULTIBYTE)
        {
            _dwLastError = _RasGetConnectStatusA(hrasconn, (LPRASCONNSTATUSA)_pRasConnStatus);
        }
        else
        {
            _dwLastError = _RasGetConnectStatusW(hrasconn, (LPRASCONNSTATUSW)_pRasConnStatus);
        }

        if(_pRasConnStatus && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_pRasConnStatus);
            _pRasConnStatus = NULL;
        }
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasGetConnectStatusHelp::~RasGetConnectStatusHelp()
{
    _dwLastError = 0;
    if(_pRasConnStatus)
    {
        LocalFree(_pRasConnStatus);
        _pRasConnStatus = NULL;
    }
}

DWORD RasGetConnectStatusHelp::GetError()
{
    return _dwLastError;
}

RASCONNSTATE RasGetConnectStatusHelp::ConnState()
{
    RASCONNSTATE hConnState = (RASCONNSTATE)NULL;

    if(_pRasConnStatus)
    {
        if(_EnumType == ENUM_MULTIBYTE)
        {
            hConnState = _pRasConnStatus->rasconnstate;
        }
        else
        {
            LPRASCONNSTATUSW lpTemp = (LPRASCONNSTATUSW)_pRasConnStatus;
            hConnState = lpTemp->rasconnstate;
        }
    }

    return hConnState;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasDialHelp::RasDialHelp(LPRASDIALEXTENSIONS lpRDE, LPWSTR lpszPB, LPRASDIALPARAMSW lpRDPW,  DWORD dwType, LPVOID lpvNot, LPHRASCONN lphRasCon)
{
    // init
    _dwLastError = 1;
    _pRasDialParams = NULL;
    _lpszPhonebookA = NULL;

    if(lpRDPW)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            _pRasDialParams = (LPRASDIALPARAMSA)LocalAlloc(LPTR, sizeof(RASDIALPARAMSA));
            if(_pRasDialParams)
            {
                if(lpszPB)
                    _lpszPhonebookA = (LPSTR)LocalAlloc(LPTR, (lstrlenW(lpszPB)+1) * sizeof(CHAR));
                _pRasDialParams->dwSize = sizeof(RASDIALPARAMSA);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szEntryName, -1, _pRasDialParams->szEntryName, RAS_MaxEntryName, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szPhoneNumber, -1, _pRasDialParams->szPhoneNumber, RAS_MaxPhoneNumber, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szCallbackNumber, -1, _pRasDialParams->szCallbackNumber, RAS_MaxCallbackNumber, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szUserName, -1, _pRasDialParams->szUserName, UNLEN, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szPassword, -1, _pRasDialParams->szPassword, PWLEN, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szDomain, -1, _pRasDialParams->szDomain, DNLEN, NULL, NULL);
                _dwLastError = _RasDialA(lpRDE, _lpszPhonebookA, _pRasDialParams, dwType, lpvNot, lphRasCon);
            }
            else
            {
                _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
        case ENUM_WIN2K:
        case ENUM_UNICODE:
            _pRasDialParams = (LPRASDIALPARAMSA)LocalAlloc(LPTR, sizeof(NT4RASDIALPARAMSW));
            if(_pRasDialParams)
            {
                LPNT4RASDIALPARAMSW pRDPW = (LPNT4RASDIALPARAMSW)_pRasDialParams;
                pRDPW->dwSize = sizeof(NT4RASDIALPARAMSW);
                StrCpyNW(pRDPW->szEntryName, lpRDPW->szEntryName, RAS_MaxEntryName);
                StrCpyNW(pRDPW->szPhoneNumber, lpRDPW->szPhoneNumber, RAS_MaxPhoneNumber);
                StrCpyNW(pRDPW->szCallbackNumber, lpRDPW->szCallbackNumber, RAS_MaxCallbackNumber);
                StrCpyNW(pRDPW->szUserName, lpRDPW->szUserName, UNLEN);
                StrCpyNW(pRDPW->szPassword, lpRDPW->szPassword, PWLEN);
                StrCpyNW(pRDPW->szDomain, lpRDPW->szDomain, DNLEN);
                _dwLastError = _RasDialW(lpRDE, lpszPB, (LPRASDIALPARAMSW)pRDPW, dwType, lpvNot, lphRasCon);
            }
            else
            {
                _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
        }

        if(_pRasDialParams && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_pRasDialParams);
            _pRasDialParams = NULL;
        }
        if(_lpszPhonebookA && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_lpszPhonebookA);
            _lpszPhonebookA = NULL;
        }
    }
    return;
}

RasDialHelp::~RasDialHelp()
{
    _dwLastError = 0;
    if(_pRasDialParams)
    {
        LocalFree(_pRasDialParams);
        _pRasDialParams = NULL;
    }
    if(_lpszPhonebookA)
    {
        LocalFree(_lpszPhonebookA);
        _lpszPhonebookA = NULL;
    }
}

DWORD RasDialHelp::GetError()
{
    return _dwLastError;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\readhtml.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    readhtml.cxx

Abstract:

    Contains functions for returning files and directory listings (gopher and
    FTP) as HTML documents

    Contents:
        ReadHtmlUrlData
        QueryHtmlDataAvailable
        (MakeHtmlDirEntry)

Author:

    Richard L Firth (rfirth) 23-Jun-1995

Environment:

    Win32 user-mode

Revision History:

    23-Jun-1995 rfirth
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

//
// HTML encapsulation strings - we generate HTML documents using the following
// strings. Although we don't need carriage-return, line-feed at the end of each
// line, we add them anyway since it allows View Source and Save As commands in
// the viewer to create human-sensible documents
//

//
// HTML_DOCUMENT_HEADER - every HTML document should have a header. It must have
// a title. This string defines the header, title and start of the document body
//

#define HTML_DOCUMENT_HEADER        "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n" \
                                    "<HTML>\r\n" \
                                    "<HEAD>\r\n" \
                                    "<TITLE>%s</TITLE>\r\n" \
                                    "</HEAD>\r\n" \
                                    "<BODY>\r\n" \
                                    "<H2>%s</H2>\r\n"

#ifdef EXTENDED_ERROR_HTML

//
// HTML_ERROR_DOCUMENT_HEADER - error variant of standard document header
//

#define HTML_ERROR_DOCUMENT_HEADER  "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n" \
                                    "<HTML>\r\n" \
                                    "<HEAD>\r\n" \
                                    "<TITLE>%s</TITLE>\r\n" \
                                    "</HEAD>\r\n" \
                                    "<BODY>\r\n" \
                                    "<H2>%s</H2>\r\n" \
                                    "<HR>\r\n"

#endif

//
// HTML_DOCUMENT_PREFORMAT - directory entries are preformatted to stop the HTML
// viewer putting its own interpretation on the listing
//

#define HTML_DOCUMENT_PREFORMAT     "<PRE>\r\n"

//
// HTML_DOCUMENT_END_PREFORMAT - this is required after the last directory entry
// to allow the viewer to resume HTML formatting
//

#define HTML_DOCUMENT_END_PREFORMAT "</PRE>\r\n"

//
// HTML_HORIZONTAL_RULE - we separate each part of the document with a horizontal
// rule line
//

#define HTML_HORIZONTAL_RULE        "<HR>\r\n"

//
// HTML_FTP_WELCOME_START - for FTP directories, we display the FTP welcome
// message
//

#define HTML_FTP_WELCOME_START      HTML_HORIZONTAL_RULE \
                                    "<H4><PRE>\r\n"

//
// HTML_FTP_WELCOME_END - finish off at end of FTP welcome message
//

#define HTML_FTP_WELCOME_END        "</PRE></H4>\r\n"

//
// HTML_DOCUMENT_DIR_START - when creating a directory listing document, we
// follow the header with a Horizontal Rule (<HR>)
//

#define HTML_DOCUMENT_DIR_START     HTML_HORIZONTAL_RULE \
                                    HTML_DOCUMENT_PREFORMAT

//
// HTML_DOCUMENT_FTP_DIR_START - same as HTML_DOCUMENT_DIR_START, but used to
// add an additional "back up one level" if FTP and not the root
//

#define HTML_DOCUMENT_FTP_DIR_START HTML_HORIZONTAL_RULE \
                                    "%s" \
                                    HTML_DOCUMENT_PREFORMAT

//
// HTML_DOCUMENT_DIR_END - string that appears at the end of the preformatted
// directory list, but before the end of the document
//

#define HTML_DOCUMENT_DIR_END       HTML_DOCUMENT_END_PREFORMAT \
                                    HTML_HORIZONTAL_RULE

//
// HTML_ISINDEX - string that causes browser to display search form
//
#define HTML_ISINDEX                "<ISINDEX>"

//
// HTML_DOCUMENT_FOOTER - this goes at the end of every HTML document we create
//

#define HTML_DOCUMENT_FOOTER        "</BODY>\r\n" \
                                    "</HTML>\r\n"

//
// HTML_DOCUMENT_DIR_ENTRY - each directory entry is formatted using the
// following string. Directories are bold
//

#define HTML_DOCUMENT_DIR_ENTRY     "%s %s <A HREF=\"%s\"><B>%s</B></A>\r\n"

//
// HTML_DOCUMENT_FILE_ENTRY - same as HTML_DOCUMENT_DIR_ENTRY, except link is
// not bold
//

#define HTML_DOCUMENT_FILE_ENTRY    "%s %s <A HREF=\"%s\">%s</A>\r\n"

#define SCRATCH_PAD_SIZE            1024

#define FTP_WELCOME_INTRO           "230-"
#define FTP_WELCOME_INTRO_LENGTH    (sizeof(FTP_WELCOME_INTRO) - 1)

#define MAX_FMT_BUF 200 // size of buffer for loading title format string resource
char szDir[32];
char szSearch[32];

//
// private prototypes
//

PRIVATE
DWORD
MakeHtmlDirEntry(
    IN HINTERNET_HANDLE_TYPE HandleType,
    IN LPSTR PathPrefix,
    IN LPVOID DirBuffer,
    IN LPBYTE EntryBuffer,
    IN OUT LPDWORD BufferLength,
    OUT LPSTR* DirEntry
    );

//
// functions
//


BOOL
ReadHtmlUrlData(
    IN HINTERNET hInternet,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    )

/*++

Routine Description:

    Converts an FTP or gopher file or directory listing to a HTML document. This
    function is a wrapper for InternetReadFile() and InternetFindNext(), and so
    returns BOOL: the error code proper is set by the appropriate API

Arguments:

    hInternet           - handle of file or find object

    lpBuffer            - pointer to caller's buffer

    dwBufferLength      - size of lpBuffer on input

    lpdwBytesReturned   - pointer to returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_INET,
                Bool,
                "ReadHtmlUrlData",
                "%#x, %#x, %d, %#x",
                hInternet,
                lpBuffer,
                dwBufferLength,
                lpdwBytesReturned
                ));

    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;
    BOOL success;
    LPSTR url;
    DWORD charsCopied;
    LPBYTE buffer;
    BYTE dirBuffer[max(sizeof(WIN32_FIND_DATA), sizeof(GOPHER_FIND_DATA))];
    BOOL done;
    HTML_STATE htmlState;
    HTML_STATE previousHtmlState;
    BYTE scratchPad[SCRATCH_PAD_SIZE];
    BOOL dataCopied;
    LPSTR lastDirEntry;
    LPSTR urlCopy;

    //
    // initialize variables in case we quit early
    //

    htmlState = previousHtmlState = HTML_STATE_INVALID;
    urlCopy = NULL;

    //
    // retrieve some information from the file/find handle - the handle type,
    // URL string, current HTML document state and previous failed dir entry
    //

    error = RGetHandleType(hInternet, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    error = RGetUrl(hInternet, &url);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    error = RGetHtmlState(hInternet, &htmlState);
    previousHtmlState = htmlState;
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    error = RGetDirEntry(hInternet, &lastDirEntry);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // initialize variables for loop
    //

    *lpdwBytesReturned = dwBufferLength;
    charsCopied = 0;
    buffer = (LPBYTE)lpBuffer;
    done = FALSE;
    success = TRUE;
    dataCopied = FALSE;

    //
    // first, maybe we already have data available from a previous
    // QueryDataAvailable operation
    //

#ifdef EXTENDED_ERROR_HTML
    INET_ASSERT((handleType == TypeFtpFindHandleHtml)
                || (handleType == TypeFtpFileHandleHtml)
                || (handleType == TypeGopherFindHandleHtml));
#else
    INET_ASSERT((handleType == TypeFtpFindHandleHtml)
                || (handleType == TypeGopherFindHandleHtml));
#endif

    if (handleType == TypeFtpFindHandleHtml) {

        FTP_FIND_HANDLE_OBJECT * pObject = (FTP_FIND_HANDLE_OBJECT *)hInternet;

        if (pObject->HaveQueryData()) {
            dwBufferLength -= pObject->CopyQueriedData(lpBuffer, dwBufferLength);
            goto quit;
        }
    }
#ifdef EXTENDED_ERROR_HTML
    else if (handleType == TypeFtpFileHandleHtml) {

        FTP_ERROR_HANDLE_OBJECT * pObject = (FTP_ERROR_HANDLE_OBJECT *)hInternet;

        if (pObject->HaveQueryData()) {
            dwBufferLength -= pObject->CopyQueriedData(lpBuffer, dwBufferLength);
            goto quit;
        }
    }
#endif
    else
    {
        GOPHER_FIND_HANDLE_OBJECT * pObject = (GOPHER_FIND_HANDLE_OBJECT *)hInternet;

        if (pObject->HaveQueryData()) {
            dwBufferLength -= pObject->CopyQueriedData(lpBuffer, dwBufferLength);
            goto quit;
        }
    }

    //
    // loop round, writing as much data as we are able to the caller's buffer
    //

    do {
        switch (htmlState) {
        case HTML_STATE_START:

            //
            // if we are dealing with files then we go straight to copying the
            // file contents - we don't encapsulate files in HTML
            //

#ifdef EXTENDED_ERROR_HTML
            if (handleType == TypeFtpFileHandleHtml) {

                //
                // FTP file handle is used for FTP errors
                //

                charsCopied = (DWORD)wsprintf((LPSTR)scratchPad,
                                              HTML_ERROR_DOCUMENT_HEADER,
                                              "FTP Error",
                                              "FTP Error"
                                              );
                if (charsCopied > dwBufferLength) {

                    //
                    // caller's buffer not large enough to fit header - clean up
                    // and allow the caller to retry
                    //

                    success = FALSE;
                    error = ERROR_INSUFFICIENT_BUFFER;
                    done = TRUE;
                } else {

                    //
                    // copy the header to the caller's buffer
                    //

                    memcpy(buffer, scratchPad, charsCopied);
                    dataCopied = TRUE;
                }
                htmlState = HTML_STATE_ERROR_BODY;
            } else if (handleType == TypeGopherFileHandleHtml)
#else
            if ((handleType == TypeFtpFileHandleHtml)
            || (handleType == TypeGopherFileHandleHtml))
#endif
            {
                htmlState = HTML_STATE_BODY;
            }
            else
            {
                htmlState = (HTML_STATE)((int)htmlState + 1);
            }
            break;

        case HTML_STATE_HEADER: {

            //
            // crack the URL for the info we need (i) for the header (ii) for
            // FTP file paths
            //

            DWORD urlLength;
            LPSTR host;
            DWORD hostLength;
            char title[MAX_FMT_BUF + INTERNET_MAX_PATH_LENGTH + 1];
            char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

            //
            // first, make a copy of the URL, reserving 2 extra characters in
            // case this is an FTP request and we need to add a root directory
            // path
            //

            urlLength = strlen(url);
            urlCopy = NEW_MEMORY(urlLength + 2, char);
            if (urlCopy == NULL) {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            memcpy(urlCopy, url, urlLength + 1);

            //
            // get the start of the URL path and the host name. CrackUrl() will
            // destroy url but leave urlCopy intact
            //

            error = CrackUrl(urlCopy,
                             0,     // dwUrlLength
                             FALSE, // decode the url-path
                             NULL,  // we don't care about the scheme
                             NULL,  // or scheme name
                             NULL,
                             &host, // we want the host name (for title)
                             &hostLength,
                             NULL,  // or the port
                             NULL,  // or the user name
                             NULL,
                             NULL,  // or the password
                             NULL,
                             &url,  // we want the url-path
                             &urlLength,
                             NULL,
                             NULL,
                             NULL
                             );
            if (error != ERROR_SUCCESS) {

                //
                // handle still has previous URL pointer, but it will be deleted
                // when the handle is closed
                //

                goto quit;
            }

            //
            // ensure the host name is zero-terminated
            //

            hostLength = (DWORD)min(hostLength, sizeof(hostName) - 1);
            memcpy(hostName, host, hostLength);
            hostName[hostLength] = '\0';

            //
            // same for the URL-path
            //

            url[urlLength] = '\0';

            //
            // create the header/title
            //

            char szFmt[MAX_FMT_BUF];
            szFmt[0] = 0; // guard against LoadString failing (why would it?)

            if (handleType == TypeGopherFindHandleHtml) {

                GOPHER_FIND_HANDLE_OBJECT* pGopherFind =
                    (GOPHER_FIND_HANDLE_OBJECT *) hInternet;

                switch (pGopherFind->GetFixedType()) {

                    case GOPHER_TYPE_CSO:
                        LoadString (GlobalDllHandle, IDS_GOPHER_CSO,
                            szFmt, sizeof(szFmt));
                        wsprintf (title, szFmt, hostName);
                        break;

                    case GOPHER_TYPE_INDEX_SERVER:
                        LoadString (GlobalDllHandle, IDS_GOPHER_INDEX,
                            szFmt, sizeof(szFmt));
                        wsprintf (title, szFmt, hostName);
                        break;

                    default:
                        if ((*url == '\0') || (memcmp(url, "/", 2) == 0)) {
                            LoadString (GlobalDllHandle, IDS_GOPHER_ROOT,
                                szFmt, sizeof(szFmt));
                            wsprintf(title, szFmt, hostName);
                        } else {
                            LoadString (GlobalDllHandle, IDS_GOPHER_DIR,
                                szFmt, sizeof(szFmt));
                            wsprintf(title, szFmt, hostName);
                        }
                }

            } else if (handleType == TypeFtpFindHandleHtml) {
                if ((*url == '\0') || (memcmp(url, "/", 2) == 0)) {
                    LoadString (GlobalDllHandle, IDS_FTP_ROOT,
                        szFmt, sizeof(szFmt));
                    wsprintf(title, szFmt, hostName);
                } else {
                    LoadString (GlobalDllHandle, IDS_FTP_DIR,
                        szFmt, sizeof(szFmt));
                    wsprintf(title, szFmt, url, hostName);
                }
            } else {
                title[0] = '\0';
            }
            charsCopied = (DWORD)wsprintf((LPSTR)scratchPad,
                                          HTML_DOCUMENT_HEADER,
                                          title,
                                          title
                                          );
            if (charsCopied > dwBufferLength) {

                //
                // caller's buffer not large enough to fit header - clean up
                // and allow the caller to retry
                //

                success = FALSE;
                error = ERROR_INSUFFICIENT_BUFFER;
                done = TRUE;
            } else {

                //
                // copy the header to the caller's buffer
                //

                memcpy(buffer, scratchPad, charsCopied);
                dataCopied = TRUE;

                //
                // if the URL contains a NULL path then point it at the FTP
                // root. Likewise, end any and all directory paths with '/'
                //

                if (handleType == TypeFtpFindHandleHtml) {
                    if (urlLength == 0) {
                        *url = '/';
                        ++urlLength;
                    } else if ((url[urlLength - 1] != '/')
                    && (url[urlLength - 1] != '\\')) {
                        url[urlLength++] = '/';
                    }
                    url[urlLength] = '\0';
                } else {
                    url = NULL;
                }

                //
                // free the URL in the handle object if gopher, else (FTP) set
                // it to be the path part of the URL. The previous string will
                // be deleted, and a new one allocated
                //

                RSetUrl(hInternet, url);

                //
                // we can now start on the dir header
                //

                htmlState = (HTML_STATE)((int)htmlState + 1);
            }
            break;
        }

        case HTML_STATE_WELCOME: {

            LPSTR lastInfo;
            DWORD lastInfoLength;
            INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
            BOOL freeLastResponseInfo;

            if (  handleType == TypeGopherFindHandleHtml
               && ((GOPHER_FIND_HANDLE_OBJECT *) hInternet)->GetFixedType()) {

                //
                // BUGBUG - wimp out on CSO searches for now.
                //

                if (((GOPHER_FIND_HANDLE_OBJECT *) hInternet)->GetFixedType()
                         == GOPHER_TYPE_CSO) {
                    success = TRUE;
                    dataCopied = FALSE;
                    htmlState = HTML_STATE_FOOTER;
                    break;
                }


                charsCopied = sizeof(HTML_ISINDEX);
                if (dwBufferLength < charsCopied) {

                    success = FALSE;

                } else {

                    memcpy (buffer, HTML_ISINDEX, charsCopied);
                    dataCopied = TRUE;
                    success = TRUE;
                    htmlState = HTML_STATE_FOOTER;
                }
                break;
            }

            pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)
                            ((HANDLE_OBJECT *)hInternet)->GetParent();
            lastInfo = pConnect->GetLastResponseInfo(&lastInfoLength);

            //
            // if not an FTP find operation then we don't check for any welcome
            // message, or other text from the server. Just go to the next state
            //

            if ((handleType == TypeFtpFindHandleHtml) && (lastInfo != NULL)) {

                //
                // find the welcome message. This starts with "230-" and can
                // continue over multiple lines, each of which may start with
                // "230-", or each may start with a line beginning only with a
                // space
                //

                LPSTR p = strstr(lastInfo, FTP_WELCOME_INTRO);

                if (p != NULL) {

                    //
                    // first, copy the separator
                    //

                    LPBYTE pBuffer = buffer;
                    DWORD bufferLeft = dwBufferLength;

                    if (bufferLeft >= (sizeof(HTML_FTP_WELCOME_START) - 1)) {
                        memcpy(pBuffer,
                               HTML_FTP_WELCOME_START,
                               sizeof(HTML_FTP_WELCOME_START) - 1
                               );
                        pBuffer += sizeof(HTML_FTP_WELCOME_START) - 1;
                        bufferLeft -= sizeof(HTML_FTP_WELCOME_START) - 1;
                        charsCopied = sizeof(HTML_FTP_WELCOME_START) - 1;
                    } else {

                        //
                        // caller's buffer not large enough to fit header -
                        // clean up and allow the caller to retry
                        //

                        success = FALSE;
                        error = ERROR_INSUFFICIENT_BUFFER;
                        done = TRUE;
                        freeLastResponseInfo = FALSE;
                        goto quit_welcome;
                    }

                    //
                    // then copy each welcome message line, dropping the "230-"
                    // from each
                    //

                    do {
                        if (!strncmp(p, FTP_WELCOME_INTRO, FTP_WELCOME_INTRO_LENGTH)) {
                            p += FTP_WELCOME_INTRO_LENGTH;
                        } else if (*p != ' ') {

                            //
                            // line doesn't start with "230-" or a space. We're
                            // done
                            //

                            break;
                        }

                        LPSTR lastChar;
                        DWORD len;

                        lastChar = strchr(p, '\n');
                        if (lastChar != NULL) {
                            len = (DWORD)(lastChar - p) + 1;
                        } else {
                            len = strlen(p);
                        }

                        if (bufferLeft >= len) {
                            memcpy(pBuffer, p, len);
                            pBuffer += len;
                            p += len;
                            bufferLeft -= len;
                            charsCopied += len;

                            //
                            // find start of next line, or end of buffer, in
                            // case there are multiple line terminators
                            //

                            while ((*p == '\r') || (*p == '\n')) {
                                ++p;
                            }
                        } else {

                            //
                            // caller's buffer not large enough to fit header -
                            // clean up and allow the caller to retry
                            //

                            success = FALSE;
                            error = ERROR_INSUFFICIENT_BUFFER;
                            done = TRUE;
                            freeLastResponseInfo = FALSE;
                            break;
                        }
                    } while (TRUE);

                    //
                    // finish off
                    //

                    if (bufferLeft >= (sizeof(HTML_FTP_WELCOME_END) - 1)) {
                        memcpy(pBuffer,
                               HTML_FTP_WELCOME_END,
                               sizeof(HTML_FTP_WELCOME_END) - 1
                               );
                        pBuffer += sizeof(HTML_FTP_WELCOME_END) - 1;
                        bufferLeft -= sizeof(HTML_FTP_WELCOME_END) - 1;
                        charsCopied += sizeof(HTML_FTP_WELCOME_END) - 1;

                        //
                        // successfully completed welcome message part
                        //

                        dataCopied = TRUE;
                        freeLastResponseInfo = TRUE;
                        htmlState = (HTML_STATE)((int)htmlState + 1);
                    } else {

                        //
                        // caller's buffer not large enough to fit header -
                        // clean up and allow the caller to retry
                        //

                        success = FALSE;
                        error = ERROR_INSUFFICIENT_BUFFER;
                        done = TRUE;
                        freeLastResponseInfo = FALSE;
                    }
                } else {

                    //
                    // last response info, but no welcome text. Continue
                    //

                    htmlState = (HTML_STATE)((int)htmlState + 1);
                    freeLastResponseInfo = TRUE;
                    charsCopied = 0;
                }
            } else {

                //
                // no info from server. Continue
                //

                htmlState = (HTML_STATE)((int)htmlState + 1);
                freeLastResponseInfo = FALSE;
                charsCopied = 0;
            }

quit_welcome:

            if (freeLastResponseInfo) {
                pConnect->FreeLastResponseInfo();
            }
            break;
        }

        case HTML_STATE_DIR_HEADER:

            //
            // copy the directory listing introduction. N.B. this is mainly here
            // from the time when we had directory listings AND files being HTML
            // encapsulated. This is no longer true, so I could change things
            // somewhat
            //

            //
            // if FTP directory AND not root directory, display link to higher
            // level
            //

            DWORD cbTotal;
            char szUp[64];
            LPSTR lpszHtml;

            szUp[0] = 0;

            if (handleType == TypeFtpFindHandleHtml) {
                lpszHtml = HTML_DOCUMENT_FTP_DIR_START;
                cbTotal = sizeof(HTML_DOCUMENT_FTP_DIR_START);
                if ((*url != '\0') && (memcmp(url, "/", 2) != 0)) {
                    cbTotal += LoadString(GlobalDllHandle,
                                          IDS_FTP_UPLEVEL,
                                          szUp,
                                          sizeof(szUp)
                                          );
                }
            } else {
                lpszHtml = HTML_DOCUMENT_DIR_START;
                cbTotal = sizeof(HTML_DOCUMENT_DIR_START);
            }
            if (dwBufferLength >= cbTotal) {
                charsCopied = wsprintf((char *)buffer, lpszHtml, szUp);
                dataCopied = TRUE;
                htmlState = (HTML_STATE)((int)htmlState + 1);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
                success = FALSE;
            }
            break;

        case HTML_STATE_BODY:

            //
            // if we already have a formatted dir entry from last time (it
            // wouldn't fit in the buffer), then copy it now
            //

            if (lastDirEntry != NULL) {
                charsCopied = strlen(lastDirEntry);
                if (dwBufferLength >= charsCopied) {
                    memcpy(buffer, lastDirEntry, charsCopied);

                    //
                    // we no longer require the string
                    //

                    RSetDirEntry(hInternet, NULL);
                    lastDirEntry = NULL;
                    success = TRUE;
                } else {

                    //
                    // still not enough room
                    //

                    error = ERROR_INSUFFICIENT_BUFFER;
                    success = FALSE;
                    done = TRUE;
                }

                //
                // in both cases fall out of the switch()
                //

                break;
            }

            //
            // read the next part of the HTML document
            //

            switch (handleType) {
            case TypeFtpFindHandleHtml:
                success = FtpFindNextFileA(hInternet,
                                           (LPWIN32_FIND_DATA)dirBuffer
                                           );
                goto create_dir_entry;

            case TypeGopherFindHandleHtml:

                //
                // Check if we simply can return fixed text for a search
                //

                success = GopherFindNextA(hInternet,
                                          (LPGOPHER_FIND_DATA)dirBuffer
                                          );

                //
                // directory listing - get the next directory entry, convert
                // to HTML and write to the caller's buffer. If there's not
                // enough space, return an error
                //

create_dir_entry:

                if (success) {
                    charsCopied = dwBufferLength;
                    error = MakeHtmlDirEntry(handleType,
                                             url,
                                             dirBuffer,
                                             buffer,
                                             &charsCopied,
                                             &lastDirEntry
                                             );
                    if (error != ERROR_SUCCESS) {

                        //
                        // if MakeHtmlDirEntry() created a copy of the directory
                        // entry then store it in the handle object for next
                        // time
                        //

                        if (lastDirEntry != NULL) {
                            RSetDirEntry(hInternet, lastDirEntry);

                            //
                            // no longer need our copy of the string -
                            // RSetLastDirEntry() also makes a copy and adds it
                            // to the handle object
                            //

                            DEL_STRING(lastDirEntry);
                        }

                        //
                        // probably out of buffer space - we're done
                        //

                        success = FALSE;
                        done = TRUE;
                    } else {
                        dataCopied = TRUE;
                    }
                } else if (GetLastError() == ERROR_NO_MORE_FILES) {

                    //
                    // change the error to success - ReadFile() doesn't return
                    // ERROR_NO_MORE_FILES
                    //

                    SetLastError(ERROR_SUCCESS);

                    //
                    // reached the end of the directory listing - time to
                    // add the footer
                    //

                    charsCopied = 0;
                    success = TRUE;
                    htmlState = (HTML_STATE)((int)htmlState + 1);
                }
                break;

            case TypeFtpFileHandleHtml:
            case TypeGopherFileHandleHtml:

                //
                // BUGBUG - this path never taken because we do not encapsulate
                //          files?
                //

                //
                // file data - just read the next chunk
                //

                success = InternetReadFile(hInternet,
                                           (LPVOID)buffer,
                                           dwBufferLength,
                                           &charsCopied
                                           );
                if (success) {
                    if (charsCopied == 0) {

                        //
                        // read all of file - we're done (no HTML to add for
                        // files)
                        //

                        htmlState = HTML_STATE_END;
                    } else {
                        buffer += charsCopied;
                        dwBufferLength -= charsCopied;
                        dataCopied = TRUE;
                    }
                }
                break;
            }
            break;

        case HTML_STATE_DIR_FOOTER:
            if (dwBufferLength >= sizeof(HTML_DOCUMENT_DIR_END) - 1) {
                memcpy(buffer,
                       HTML_DOCUMENT_DIR_END,
                       sizeof(HTML_DOCUMENT_DIR_END) - 1
                       );
                charsCopied = sizeof(HTML_DOCUMENT_DIR_END) - 1;
                dataCopied = TRUE;
                htmlState = (HTML_STATE)((int)htmlState + 1);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
                success = FALSE;
            }
            break;

        case HTML_STATE_FOOTER:

            //
            // copy the HTML document footer - don't copy the end-of-string
            // character ('\0')
            //

            if (dwBufferLength >= sizeof(HTML_DOCUMENT_FOOTER) - 1) {
                memcpy(buffer,
                       HTML_DOCUMENT_FOOTER,
                       sizeof(HTML_DOCUMENT_FOOTER) - 1
                       );
                charsCopied = sizeof(HTML_DOCUMENT_FOOTER) - 1;

                //
                // the document is done
                //

                htmlState = (HTML_STATE)((int)htmlState + 1);
                dataCopied = TRUE;
                done = TRUE;
            } else if (charsCopied==0) {
                error = ERROR_INSUFFICIENT_BUFFER;
                success = FALSE;
            } else {
                // We're out of buffer space. but we've got everything else
                // so we'll just leave
                done = TRUE;
            }
            break;

        case HTML_STATE_END:
            done = TRUE;
            break;

#ifdef EXTENDED_ERROR_HTML
        case HTML_STATE_ERROR_BODY:
            htmlState = HTML_STATE_FOOTER;
            break;
#endif

        default:

            INET_ASSERT(FALSE);

            break;
        }

        if (success) {

            //
            // update the buffer pointer and remaining length by the number of
            // bytes read this time round the loop
            //

            buffer += charsCopied;
            dwBufferLength -= charsCopied;
        }
    } while ((dwBufferLength != 0) && success && !done);

    //
    // if we succeeded, update the amount of data returned, else set the last
    // error, which may be different from the last error set by the underlying
    // API (if any were called)
    //

quit:

    //
    // remember the current state
    //

    if (htmlState != previousHtmlState) {
        RSetHtmlState(hInternet, htmlState);
    }

    //
    // if we quit because we ran out of buffer then only return an error if we
    // didn't copy *any* data
    //

    if ((error == ERROR_INSUFFICIENT_BUFFER) && dataCopied) {
        error = ERROR_SUCCESS;
        success = TRUE;
    }

    //
    // if we succeeded then return the amount of data read, else reset the last
    // error
    //

    if (error == ERROR_SUCCESS) {
        *lpdwBytesReturned -= dwBufferLength;
    } else {
        *lpdwBytesReturned = 0;
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    //
    // clean up
    //

    if (urlCopy != NULL) {
        DEL(urlCopy);
    }

    //
    // return API-level success or failure indication
    //

    DEBUG_LEAVE(success);

    return success;
}


DWORD
QueryHtmlDataAvailable(
    IN HINTERNET hInternet,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    This function is called when the app is querying available data for a cooked
    (HTML) find handle. Because we have to cook the data before we can determine
    how much there is, we need to allocate a buffer and cook the data there

Arguments:

    hInternet                   - MAPPED address of handle object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    Can only handle TypeFtpFindHandleHtml and
                    TypeGopherFindHandleHtml

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating HTML buffer

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "QueryHtmlDataAvailable",
                "%#x, %#x",
                hInternet,
                lpdwNumberOfBytesAvailable
                ));

    DWORD error;

    switch (((HANDLE_OBJECT *)hInternet)->GetHandleType()) {
    case TypeFtpFindHandleHtml:
        error = ((FTP_FIND_HANDLE_OBJECT *)hInternet)->
                    QueryHtmlDataAvailable(lpdwNumberOfBytesAvailable);
        break;

#ifdef EXTENDED_ERROR_HTML
    case TypeFtpFileHandleHtml:
        error = ((FTP_ERROR_HANDLE_OBJECT *)hInternet)->
                    QueryHtmlDataAvailable(lpdwNumberOfBytesAvailable);
        break;
#endif

    case TypeGopherFindHandleHtml:
        error = ((GOPHER_FIND_HANDLE_OBJECT *)hInternet)->
                    QueryHtmlDataAvailable(lpdwNumberOfBytesAvailable);
        break;

    default:
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private functions
//


PRIVATE
DWORD
MakeHtmlDirEntry(
    IN HINTERNET_HANDLE_TYPE HandleType,
    IN LPSTR PathPrefix,
    IN LPVOID DirBuffer,
    IN LPBYTE EntryBuffer,
    IN OUT LPDWORD BufferLength,
    OUT LPSTR* DirEntry
    )

/*++

Routine Description:

    Creates a single-line directory entry for a HTML document. The line is
    formatted thus (e.g.):

    "   12,345,678 Fri Jun 23 95  4:43pm pagefile.sys                   "
    "    Directory Fri Jun 23 95 10:00am foobar.directory               "
    "                                    unknown.filesize               "

Arguments:

    HandleType      - type of the handle - gopher or FTP (find + HTML)

    PathPrefix      - string used to build (FTP) absolute paths

    DirBuffer       - pointer to buffer containing GOPHER_FIND_DATA or
                      WIN32_FIND_DATA

    EntryBuffer     - pointer to buffer where HTML dir entry will be written

    BufferLength    - IN: number of bytes available in EntryBuffer
                      OUT: number of bytes written to EntryBuffer

    DirEntry        - if we couldn't copy the directory entry to the HTML buffer
                      then we return a pointer to a copy of the formatted
                      directory entry. The caller should remember this and use
                      it the next time the function is called, before getting
                      the next dir entry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    EntryBuffer is not large enough to hold this entry

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "MakeHtmlDirEntry",
                "%s (%d), %q, %#x, %#x, %#x [%d], %#x",
                InternetMapHandleType(HandleType),
                HandleType,
                PathPrefix,
                DirBuffer,
                EntryBuffer,
                BufferLength,
                *BufferLength,
                DirEntry
                ));

    BOOL isDir;
    BOOL isSearch;
    LPSTR entryName;
    DWORD entrySize;
    FILETIME entryTime;
    SYSTEMTIME systemTime;
    char timeBuf[80];
    char sizeBuf[15];   // 4,294,967,295
    char entryBuf[sizeof(HTML_DOCUMENT_DIR_ENTRY) + INTERNET_MAX_PATH_LENGTH];
    char urlBuf[INTERNET_MAX_URL_LENGTH];
    LPSTR url;
    LPSTR pSizeDir;
    DWORD nPrinted;
    DWORD error;
    BOOL haveTimeAndSize;
    DWORD urlLength;

    //
    // ensure we are dealing with the correct handle type
    //

    INET_ASSERT((HandleType == TypeFtpFindHandleHtml)
                || (HandleType == TypeGopherFindHandleHtml));

    //
    // get the common information we will use to create a directory entry line
    //

    if (HandleType == TypeFtpFindHandleHtml) {
        isDir = ((LPWIN32_FIND_DATA)DirBuffer)->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        isSearch = FALSE;
        entryName = ((LPWIN32_FIND_DATA)DirBuffer)->cFileName;
        entryTime = ((LPWIN32_FIND_DATA)DirBuffer)->ftLastWriteTime;
        entrySize = ((LPWIN32_FIND_DATA)DirBuffer)->nFileSizeLow;
        haveTimeAndSize = TRUE;

        DWORD slen = strlen(PathPrefix);
        DWORD len = (DWORD)min(slen, sizeof(urlBuf) - 1);

        memcpy(urlBuf, PathPrefix, len);
        slen = strlen(entryName);
        slen = (DWORD)min(slen, (sizeof(urlBuf) - 1) - len);
        memcpy(&urlBuf[len], entryName, slen);
        len += slen;
        if (isDir && (len < sizeof(urlBuf) - 1)) {
            urlBuf[len] = '/';
            ++len;
        }
        urlBuf[len] = '\0';
        url = urlBuf;
    } else {
        isDir = IS_GOPHER_DIRECTORY(((LPGOPHER_FIND_DATA)DirBuffer)->GopherType);
        isSearch = IS_GOPHER_INDEX_SERVER(((LPGOPHER_FIND_DATA)DirBuffer)->GopherType);
        entryName = ((LPGOPHER_FIND_DATA)DirBuffer)->DisplayString;
        GopherLocatorToUrl(((LPGOPHER_FIND_DATA)DirBuffer)->Locator,
                           urlBuf,
                           sizeof(urlBuf),
                           &urlLength
                           );
        url = urlBuf;
        if (IS_GOPHER_PLUS(((LPGOPHER_FIND_DATA)DirBuffer)->GopherType)) {
            haveTimeAndSize = TRUE;
            entryTime = ((LPGOPHER_FIND_DATA)DirBuffer)->LastModificationTime;
            entrySize = ((LPGOPHER_FIND_DATA)DirBuffer)->SizeLow;
        } else {
            haveTimeAndSize = FALSE;
            entryTime.dwLowDateTime = 0;
            entryTime.dwHighDateTime = 0;
            entrySize = 0;
        }
    }

    //
    // if we have a non-zero entry time AND we can convert it to a system time
    // then create an internationalized time string
    //

    if ((entryTime.dwLowDateTime != 0)
    && (entryTime.dwHighDateTime != 0)
    && FileTimeToSystemTime(&entryTime, &systemTime)) {

        int n;

        //
        // BUGBUG - if either of these fail for any reason, we should fill the
        //          string with the requisite-t-t-t-t-t number of spaces
        //

        n = GetDateFormat(0,    // lcid
                          0,    // dwFlags
                          &systemTime,
                          "MM/dd/yyyy ",
                          timeBuf,
                          sizeof(timeBuf)
                          );
        if (n > 0) {

            //
            // number of characters written to string becomes index in string
            // at which to write time string
            //

            --n;
        }
        GetTimeFormat(0,    // lcid
                      TIME_NOSECONDS,
                      &systemTime,
                      "hh:mmtt",
                      &timeBuf[n],
                      sizeof(timeBuf) - n
                      );

        //
        // convert any non-ANSI characters to the OEM charset
        //

        CharToOem(timeBuf, timeBuf);
    } else {
        memcpy(timeBuf, "                ", 17);
    }

    //
    // convert the entry size to a human-readable form
    //

    if (isDir) {

        //
        // directories show up as DOS-style <DIR> entries, except we use the
        // full "Directory" text
        //

        //
        // BUGBUG - needs to be in a resource. Also, if we are adding images
        //          <IMG> then we don't need to specify dir - it will be obvious
        //          from the display (but what about text-only? what about
        //          viewers that don't care to/can't load the image?)
        //

        if (!szDir[0]) {
            LoadString(GlobalDllHandle, IDS_TAG_DIRECTORY, szDir, sizeof(szDir));
        }
        pSizeDir = szDir;
    } else if (isSearch) {

        //
        // if this is a gopher item and it is an index server (7) then indicate
        // the fact using this string
        //

        if (!szSearch[0]) {
            LoadString(GlobalDllHandle, IDS_TAG_SEARCH, szSearch, sizeof(szSearch));
        }
        pSizeDir = szSearch;
    } else if (haveTimeAndSize) {
        pSizeDir = NiceNum(sizeBuf, entrySize, 14);
    } else {
        pSizeDir = "              ";
    }

    //
    // now create the HTML directory entry
    //

    //
    // BUGBUG - at this point we need to call the MIME function to retrieve the
    //          URL for the image file that goes with this file type
    //

    nPrinted = wsprintf(entryBuf,
                        isDir
                            ? HTML_DOCUMENT_DIR_ENTRY
                            : HTML_DOCUMENT_FILE_ENTRY,
                        timeBuf,
                        pSizeDir,
                        url,
                        entryName
                        );
    if (nPrinted <= *BufferLength) {
        memcpy(EntryBuffer, entryBuf, nPrinted);
        *BufferLength = nPrinted;
        error = ERROR_SUCCESS;
    } else {

        //
        // there is not enough space in the buffer to store this formatted
        // directory entry. So since we've gone to the trouble of creating
        // the string, we make a copy of it and return it to the caller. If
        // NEW_STRING fails, then we will lose this directory entry, but it's
        // not really a problem. (The alternative would be to return e.g.
        // ERROR_NOT_ENOUGH_MEMORY and probably fail the entire request)
        //

        DEBUG_PRINT(INET,
                    WARNING,
                    ("failed to copy %q\n",
                    entryBuf
                    ));

        *DirEntry = NEW_STRING(entryBuf);

        if (*DirEntry == NULL) {

            DEBUG_PRINT(INET,
                        WARNING,
                        ("failed to make copy of %q!\n",
                        entryBuf
                        ));

        }
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\thrdinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.cxx

Abstract:

    Functions to manipulate an INTERNET_THREAD_INFO

    Contents:
        InternetCreateThreadInfo
        InternetDestroyThreadInfo
        InternetTerminateThreadInfo
        InternetGetThreadInfo
        InternetSetThreadInfo
        InternetIndicateStatusAddress
        InternetIndicateStatusString
        InternetIndicateStatusNewHandle
        InternetIndicateStatus
        InternetSetLastError
        _InternetSetLastError
        InternetLockErrorText
        InternetUnlockErrorText
        InternetSetContext
        InternetSetObjectHandle
        InternetGetObjectHandle
        InternetFreeThreadInfo

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win32 user-level DLL

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// manifests
//

#define BAD_TLS_INDEX   0xffffffff  // according to online win32 SDK documentation
#ifdef SPX_SUPPORT
#define GENERIC_SPX_NAME   "SPX Server"
#endif //SPX_SUPPORT
//
// macros
//

#ifdef ENABLE_DEBUG

#define InitializeInternetThreadInfo(lpThreadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->Signature = INTERNET_THREAD_INFO_SIGNATURE; \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#else

#define InitializeInternetThreadInfo(threadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#endif // ENABLE_DEBUG

//
// private data
//

PRIVATE DWORD InternetTlsIndex = BAD_TLS_INDEX;
PRIVATE SERIALIZED_LIST ThreadInfoList;



INTERNETAPI_(BOOL) ResumeSuspendedDownload(
    IN HINTERNET hRequest,
    IN DWORD dwResultCode
    )
/*++

Routine Description:

    Attempts to restart a stalled FSM that is blocked on UI interaction,

Arguments:

    hRequest - handle to open HTTP request

    dwResultCode  - the result of InternetErrorDlg, passed back into Wininet via this API

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                  ERROR_IO_PENDING

        Failure - 

--*/

{
    HINTERNET hRequestMapped = NULL;
    BOOL fResumed = FALSE;
    DWORD error;

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Call internal to do the work
    //

    error = ResumeAfterUserInput(
        hRequestMapped,
        dwResultCode,
        &fResumed
        );

    if ( error != ERROR_SUCCESS) 
    {
        goto quit;
    }

    if ( error == ERROR_SUCCESS )
    {
        error = ERROR_IO_PENDING; // remap to pending
    }


    //
    // If we failed to resume, the handle must have been canceled
    //

    if (!fResumed)
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

quit:

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    SetLastError(error);

    return (error == ERROR_SUCCESS) ? TRUE : FALSE;
}


//
// functions
//


DWORD 
ResumeAfterUserInput(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwResultCode,
    OUT LPBOOL   pfItemResumed
    )
/*++

Routine Description:

    
     Internal version of Resume API that 
       unblocks an FSM after the UI has been shown, user prompted, and the FSM should now continue.

Arguments:

    hRequestMapped - 
    dwResultCode -
    pfItemResumed - 

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/
{
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    INTERNET_HANDLE_OBJECT * pInternet;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "ResumeAfterUserInput",
                "%x, %u, %x",
                hRequestMapped,
                dwResultCode,
                pfItemResumed
                ));

    *pfItemResumed = FALSE;

    //
    // Now round up the objects that are involved 
    //

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    //
    // Lock us while we attempt to unblock the FSM
    //
        
    pInternet->LockPopupInfo();      

    //
    // Can only resume if we're blocked on both request and internet handles
    // 

    if ( pInternet->IsBlockedOnUserInput() && 
         pRequest->IsBlockedOnUserInput() ) 
    {
        DWORD dwCntUnBlocked;

        INET_ASSERT(pInternet->GetBlockId() == pRequest->GetBlockId());

        dwCntUnBlocked = UnblockWorkItems(
                            pInternet->GetBlockedUiCount(),
                            pRequest->GetBlockId(), // blocked on FSM
                            ERROR_SUCCESS,
                            TP_NO_PRIORITY_CHANGE
                            );

        if ( dwCntUnBlocked > 0 )
        {
            *pfItemResumed = TRUE;
            pInternet->SetBlockedResultCode(dwResultCode);
        }

    }

    INET_ASSERT( ! (pRequest->IsBlockedOnUserInput() && !pInternet->IsBlockedOnUserInput()) );

//quit: -- not used

    pInternet->UnlockPopupInfo();

    DEBUG_LEAVE(error);

    return error;
}




DWORD
ChangeUIBlockingState(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwError,
    OUT LPDWORD  lpdwActionTaken,
    OUT LPDWORD  lpdwResultCode,
    IN OUT LPVOID * lplpResultData
    )

/*++

Routine Description:

    Attempts to determine the best way of putting up UI for a given error.  This allows 
        us to back out of the Asyncronous FSM thread while popping up UI.

    How it works: 
        We attempt to prevent more than one dialog per InternetOpen handle

Arguments:

  hRequestHandle - mapped handle to open request

    dwError - error code to pass back to client and ultimately to InternetErrorDlg to generate UI

    lpdwActionTaken - returns one of several values, used to tell caller what UI action has been taken
                        UI_ACTION_CODE_NONE_TAKEN                   0
                        UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE  1
                        UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT       2
                        UI_ACTION_CODE_USER_ACTION_COMPLETED        3

    lpdwResultCode  - returns the result of InternetErrorDlg, passed through ResumeSuspendedDownload

    lplpResultData  - a void pointer allocated and owned by callee until after a thread has been resumed
                        used to pass extra data through client to InternetErrorDlg

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                  ERROR_IO_PENDING

        Failure - 

--*/

{
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "ChangeUIBlockingState",
                "%x, %u, %x, %x [%x]",
                hRequestMapped,
                dwError,
                lpdwActionTaken,
                lpdwResultCode,
                lplpResultData,
                (lplpResultData ? *lplpResultData : NULL )
                ));


    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;
    DWORD_PTR dwBlockId;
    BOOL fLocked = FALSE;
    BOOL fDoAsyncCallback = FALSE; // TRUE if we need to callback to the app
    LPVOID lpResultData = NULL;
   

    *lpdwActionTaken = UI_ACTION_CODE_NONE_TAKEN;

    if ( lplpResultData ) {
        lpResultData = *lplpResultData; // save off
    }

    //
    // Gather various sundry elements, objects, thread info, etc,
    //  validate, and if proper continue with the process
    //

    if (lpThreadInfo != NULL) {

        if ( lpThreadInfo->Fsm == NULL )
        {
            goto quit;
        }

        if ( ! lpThreadInfo->IsAsyncWorkerThread )
        {
            goto quit;
        }

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        if ( hRequestMapped == NULL )
        {
            hRequestMapped = lpThreadInfo->Fsm->GetMappedHandle();
        }

        INET_ASSERT(hRequestMapped == lpThreadInfo->Fsm->GetMappedHandle());

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = _InternetGetContext(lpThreadInfo);
        if (context == INTERNET_NO_CALLBACK) {
            context = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetContext();
        }

        INTERNET_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        //
        // No callback, no FSM means no special UI callback can be done.
        //

        if ((appCallback == NULL) || (context == INTERNET_NO_CALLBACK)) 
        {
            //
            // For the sync return error
            //

            error = dwError;
            goto quit;
        }

    }
    else
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    //
    // Make sure our handle isn't invalidated before proceeding
    //
    if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated())
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // Now get the objects that are involved 
    //

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    INTERNET_HANDLE_OBJECT * pInternet;

    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);
    
    pInternet->LockPopupInfo();      
    fLocked = TRUE;

    //
    // We check whether we're blocked on the HTTP handle and the 
    //  Internet handle.   Basically we have a little matrix here
    //  based on which one is blocked (or if neither is blocked)
    //
    //  So: 
    //      InternetHandle(blocked)/RequestHandle(not-blocked) -
    //          indicates we are not the request blocking the UI,
    //          we will need to block the FSM until the other dialog
    //          has completed
    //
    //      InternetHandle(blocked)/RequestHandle(blocked) - 
    //          indicates that we have blocked and have now been 
    //          woken up, we need return the result of the UI
    //          to the caller.
    //
    //      InternetHandle(not-blocked)/RequestHandle(blocked) - 
    //          ASSERT, we shouldn't have this happen
    //
    //      InternetHandle(not-blocked)/RequestHandle(not-blocked) - 
    //          We've just entered with no-blocking handles,
    //          so we block both and wait till UI has completed
    //

    if (!pInternet->IsBlockedOnUserInput())
    {
        //
        // Indicate to the caller via callback
        //   that we need to generate UI, then block
        //

        DEBUG_PRINT(THRDINFO,
                    INFO,
                    ("Blocking on UI, notifing client via callback\n"
                    ));

        fDoAsyncCallback = TRUE;

        INET_ASSERT(!pRequest->IsBlockedOnUserInput());

        dwBlockId = (DWORD_PTR) lpThreadInfo->Fsm;
        pInternet->BlockOnUserInput(dwError, dwBlockId, lpResultData); // IncrementBlockedUiCount() is implied here.
        pRequest->BlockOnUserInput(dwBlockId);
        *lpdwActionTaken = UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT;
    }
    else if (pRequest->IsBlockedOnUserInput() )
    {

        DEBUG_PRINT(THRDINFO,
                    INFO,
                    ("UnBlocking on UI, returning UI result\n"
                    ));

        INET_ASSERT(pInternet->IsBlockedOnUserInput());

        //
        // Retrieve the result of the UI and return
        //   to caller.
        //

        // save off block id in case need it later
        DWORD_PTR dwSavedBlockedId = pRequest->GetBlockId();
        
        INET_ASSERT(pInternet->GetBlockId() == pRequest->GetBlockId());

        pInternet->UnBlockOnUserInput(lpdwResultCode, &lpResultData);
        pRequest->UnBlockOnUserInput();

        if ( lplpResultData ) {
            *lplpResultData = lpResultData;
        }

        *lpdwActionTaken = UI_ACTION_CODE_USER_ACTION_COMPLETED;

        //
        // If others are still blocked, then wake them up too
        //

        if (pInternet->IsBlockedOnUserInput())
        {
            DWORD dwCntUnBlocked;

            dwCntUnBlocked = UnblockWorkItems(
                                pInternet->GetBlockedUiCount(),
                                dwSavedBlockedId,
                                ERROR_SUCCESS,
                                TP_NO_PRIORITY_CHANGE
                                );

            DEBUG_PRINT(THRDINFO,
                        INFO,
                        ("Unblocked %u work items, expected %u\n",
                        dwCntUnBlocked,
                        pInternet->GetBlockedUiCount()
                        ));

            pInternet->ClearBlockedUiCount();
        }

        goto quit;
    }
    else
    {
        DEBUG_PRINT(THRDINFO,
                    INFO,
                    ("Blocking on another FSM (that is busy doing UI) until their completeion\n"
                    ));

        INET_ASSERT(pInternet->IsBlockedOnUserInput());
        INET_ASSERT(!pRequest->IsBlockedOnUserInput());

        //
        // not blocked on the request handle
        // but blocked on internet handle, so we need
        //  to wait until this internet handle is ours
        //   so we do nothing
        //

        pInternet->IncrementBlockedUiCount();

        dwBlockId = pInternet->GetBlockId();        
        *lpdwActionTaken = UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE;
    }

    //
    // Now do the actual blocking of the FSM here.
    //

    lpThreadInfo->Fsm->SetState(FSM_STATE_CONTINUE);
    lpThreadInfo->Fsm->SetNextState(FSM_STATE_CONTINUE);

    error = BlockWorkItem(
        lpThreadInfo->Fsm,
        dwBlockId,               // block the FSM on FSM that created this
        INFINITE                 // we block foreever
        );

    if ( error == ERROR_SUCCESS )
    { 
        error = ERROR_IO_PENDING;
        //goto quit;
    }

quit:

    if (fLocked)
    {
        INET_ASSERT(hRequestMapped);

        pInternet->UnlockPopupInfo();
    }

    if (fDoAsyncCallback)
    {
        INTERNET_ASYNC_RESULT asyncResult;

        //
        // Pass the result Data pointer back to the caller,
        //  this is needed to pass extra info to InternetErrorDlg,
        //  once this pointer is passed, the caller must not free,
        //  until his/her FSM is restarted.
        //

        INET_ASSERT(*lpdwActionTaken == UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT);

        asyncResult.dwResult = (DWORD_PTR)lpResultData;
        asyncResult.dwError  = dwError;

        SetLastError(dwError);

        error = InternetIndicateStatus(
                    INTERNET_STATUS_USER_INPUT_REQUIRED,
                    (LPVOID)&asyncResult,
                    sizeof(asyncResult)
                    );

        if ( error == ERROR_SUCCESS || error == ERROR_INTERNET_OPERATION_CANCELLED )
        {
            error = ERROR_IO_PENDING;
        }
        else
        {
            INET_ASSERT(FALSE);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    )

/*++

Routine Description:

    Creates, initializes an INTERNET_THREAD_INFO. Optionally (allocates and)
    sets this thread's Internet TLS

    Assumes: 1. The first time this function is called is in the context of the
                process attach library call, so we allocate the TLS index once

Arguments:

    SetTls  - TRUE if we are to set the INTERNET_THREAD_INFO TLS for this thread

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to allocated INTERNET_THREAD_INFO structure which has
                  been set as this threads value in its InternetTlsIndex slot

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL ok = FALSE;

    if (InDllCleanup) {
        goto quit;
    }
    if (InternetTlsIndex == BAD_TLS_INDEX) {

        //
        // first time through, initialize serialized list
        //

        InitializeSerializedList(&ThreadInfoList);

        //
        // we assume that if we are allocating the TLS index, then this is the
        // one and only thread in this process that can call into this DLL
        // right now - i.e. this thread is loading the DLL
        //

        InternetTlsIndex = TlsAlloc();
    }
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = NEW(INTERNET_THREAD_INFO);
        if (lpThreadInfo != NULL) {
            InitializeInternetThreadInfo(lpThreadInfo);
            if (SetTls) {
                ok = TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo);
                if (!ok) {

                    DEBUG_PUT(("InternetCreateThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                             InternetTlsIndex,
                             lpThreadInfo,
                             GetLastError()
                             ));

                    DEBUG_BREAK(THRDINFO);

                }
            } else {
                ok = TRUE;
            }
        } else {

            DEBUG_PUT(("InternetCreateThreadInfo(): NEW(INTERNET_THREAD_INFO) returned NULL\n"));

            DEBUG_BREAK(THRDINFO);

        }
    } else {

        DEBUG_PUT(("InternetCreateThreadInfo(): TlsAlloc() returns %#x, error %d\n",
                 BAD_TLS_INDEX,
                 GetLastError()
                 ));

        DEBUG_BREAK(THRDINFO);
    }
    if (ok) {
        InsertAtHeadOfSerializedList(&ThreadInfoList, &lpThreadInfo->List);
    } else {
        if (lpThreadInfo != NULL) {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;
        }
        if (InternetTlsIndex != BAD_TLS_INDEX) {
            TlsFree(InternetTlsIndex);
            InternetTlsIndex = BAD_TLS_INDEX;
        }
    }

quit:

    return lpThreadInfo;
}


VOID
InternetDestroyThreadInfo(
    VOID
    )

/*++

Routine Description:

    Cleans up the INTERNET_THREAD_INFO - deletes any memory it owns and deletes
    it

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    IF_DEBUG(NOTHING) {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: Deleting INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }

    //
    // don't call InternetGetThreadInfo() - we don't need to create the
    // INTERNET_THREAD_INFO if it doesn't exist in this case
    //

    lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    if (lpThreadInfo != NULL) {

#if INET_DEBUG

        //
        // there shouldn't be anything in the debug record stack. On Win95, we
        // ignore this check if this is the async scheduler (nee worker) thread
        // AND there are entries in the debug record stack. The async thread
        // gets killed off before it has chance to DEBUG_LEAVE, then comes here,
        // causing this assert to be over-active
        //

        if (IsPlatformWin95() && lpThreadInfo->IsAsyncWorkerThread) {
            if (lpThreadInfo->CallDepth != 0) {

                DEBUG_PUT(("InternetDestroyThreadInfo(): "
                            "Thread %#x: "
                            "%d records in debug stack\n",
                            lpThreadInfo->CallDepth
                            ));
            }
        } else {

            INET_ASSERT(lpThreadInfo->Stack == NULL);

        }

#endif // INET_DEBUG

        InternetFreeThreadInfo(lpThreadInfo);

        INET_ASSERT(InternetTlsIndex != BAD_TLS_INDEX);

        TlsSetValue(InternetTlsIndex, NULL);
    } else {

        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: no INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));

    }
}


VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Removes the INTERNET_THREAD_INFO from the list and frees all allocated
    blocks

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO to remove and free

Return Value:

    None.

--*/

{
    RemoveFromSerializedList(&ThreadInfoList, &lpThreadInfo->List);

    if (lpThreadInfo->hErrorText != NULL) {
        FREE_MEMORY(lpThreadInfo->hErrorText);
    }

    //if (lpThreadInfo->lpResolverInfo != NULL) {
    //    if (lpThreadInfo->lpResolverInfo->DnrSocketHandle != NULL) {
    //        lpThreadInfo->lpResolverInfo->DnrSocketHandle->Dereference();
    //    }
    //    DEL(lpThreadInfo->lpResolverInfo);
    //}

    DEL(lpThreadInfo);
}


VOID
InternetTerminateThreadInfo(
    VOID
    )

/*++

Routine Description:

    Destroy all INTERNET_THREAD_INFO structures and terminate the serialized
    list. This funciton called at process detach time.

    At DLL_PROCESS_DETACH time, there may be other threads in the process for
    which we created an INTERNET_THREAD_INFO that aren't going to get the chance
    to delete the structure, so we do it here.

    Code in this module assumes that it is impossible for a new thread to enter
    this DLL while we are terminating in DLL_PROCESS_DETACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // get rid of this thread's info structure. No more debug output after this!
    //

    InternetDestroyThreadInfo();

    //
    // get rid of the thread info structures left by other threads
    //

    LockSerializedList(&ThreadInfoList);

    LPINTERNET_THREAD_INFO lpThreadInfo;

    while (lpThreadInfo = (LPINTERNET_THREAD_INFO)SlDequeueHead(&ThreadInfoList)) {

        //
        // already dequeued, no need to call InternetFreeThreadInfo()
        //

        FREE_MEMORY(lpThreadInfo);
    }

    UnlockSerializedList(&ThreadInfoList);

    //
    // no more need for list
    //

    TerminateSerializedList(&ThreadInfoList);

    //
    // or TLS index
    //

    TlsFree(InternetTlsIndex);
    InternetTlsIndex = BAD_TLS_INDEX;
}


LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    )

/*++

Routine Description:

    Gets the pointer to the INTERNET_THREAD_INFO for this thread and checks
    that it still looks good.

    If this thread does not have an INTERNET_THREAD_INFO then we create one,
    presuming that this is a new thread

Arguments:

    None.

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to INTERNET_THREAD_INFO block

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD lastError;

    //
    // this is pretty bad - TlsGetValue() can destroy the per-thread last error
    // variable if it returns NULL (to indicate that NULL was actually set, and
    // that NULL does not indicate an error). So we have to read it before it is
    // potentially destroyed, and reset it before we quit.
    //
    // We do this here because typically, other functions will be completely
    // unsuspecting of this behaviour, and it is better to fix it once here,
    // than in several dozen other places, even though it is slightly
    // inefficient
    //

    lastError = GetLastError();
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    }

    //
    // we may be in the process of creating the INTERNET_THREAD_INFO, in
    // which case its okay for this to be NULL. According to online SDK
    // documentation, a threads TLS value will be initialized to NULL
    //

    if (lpThreadInfo == NULL) {

        //
        // we presume this is a new thread. Create an INTERNET_THREAD_INFO
        //

        IF_DEBUG(NOTHING) {
            DEBUG_PUT(("InternetGetThreadInfo(): Thread %#x: Creating INTERNET_THREAD_INFO\n",
                      GetCurrentThreadId()
                      ));
        }

        lpThreadInfo = InternetCreateThreadInfo(TRUE);
    }
    if (lpThreadInfo != NULL) {

        INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE);
        INET_ASSERT(lpThreadInfo->ThreadId == GetCurrentThreadId());

    } else {

        DEBUG_PUT(("InternetGetThreadInfo(): Failed to get/create INTERNET_THREAD_INFO\n"));

    }

    //
    // as above - reset the last error variable in case TlsGetValue() trashed it
    //

    SetLastError(lastError);

    //
    // actual success/failure indicated by non-NULL/NULL pointer resp.
    //

    return lpThreadInfo;
}


VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Sets lpThreadInfo as the current thread's INTERNET_THREAD_INFO. Used within
    fibers

Arguments:

    lpThreadInfo    - new INTERNET_THREAD_INFO to set

Return Value:

    None.

--*/

{
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        if (!TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo)) {

            DEBUG_PUT(("InternetSetThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                     InternetTlsIndex,
                     lpThreadInfo,
                     GetLastError()
                     ));

            INET_ASSERT(FALSE);

        }
    } else {

        DEBUG_PUT(("InternetSetThreadInfo(): InternetTlsIndex = %d\n",
                 InternetTlsIndex
                 ));

        INET_ASSERT(FALSE);
    }
}


DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a network address that we
    need to convert to a string

Arguments:

    dwInternetStatus    - INTERNET_STATUS_ value

    lpSockAddr          - pointer to full socket address

    dwSockAddrLength    - length of lpSockAddr in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    LPSTR lpAddress;

    INET_ASSERT(lpSockAddr != NULL);

    switch (lpSockAddr->sa_family) {
    case AF_INET:
        lpAddress = _I_inet_ntoa(
                        ((struct sockaddr_in*)lpSockAddr)->sin_addr
                        );
        break;

    case AF_IPX:

        //
        // BUGBUG - this should be a call to WSAAddressToString, but that's not implemented yet
        //
#ifdef SPX_SUPPORT
        lpAddress = GENERIC_SPX_NAME;
#else
        lpAddress = NULL;
#endif //SPX_SUPPORT
        break;

    default:
        lpAddress = NULL;
        break;
    }
    return InternetIndicateStatusString(dwInternetStatus, lpAddress);
}


DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo OPTIONAL
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a string

Arguments:

    dwInternetStatus    - INTERNET_STATUS_ value

    lpszStatusInfo      - string status data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusString",
                "%d, %q",
                dwInternetStatus,
                lpszStatusInfo
                ));

    DWORD length;

    if (ARGUMENT_PRESENT(lpszStatusInfo)) {
        length = strlen(lpszStatusInfo) + 1;
    } else {
        length = 0;
    }

    DWORD error;

    error = InternetIndicateStatus(dwInternetStatus, lpszStatusInfo, length);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    )

/*++

Routine Description:

    Indicates to the app a new handle

Arguments:

    hInternetMapped - mapped address of new handle being indicated

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the either the new object handle or the
                    parent object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusNewHandle",
                "%#x",
                hInternetMapped
                ));

    HANDLE_OBJECT * hObject = (HANDLE_OBJECT *)hInternetMapped;

    //
    // reference the new request handle, in case the app closes it in the
    // callback. The new handle now has a reference count of 2
    //

    hObject->Reference();

    //INET_ASSERT(hObject->ReferenceCount() == 3);

    //
    // we indicate the pseudo handle to the app
    //

    HINTERNET hInternet = hObject->GetPseudoHandle();

    DWORD error = InternetIndicateStatus(INTERNET_STATUS_HANDLE_CREATED,
                                         (LPVOID)&hInternet,
                                         sizeof(hInternet)
                                         );

    //
    // dereference the new request handle. If this returns TRUE then the new
    // handle has been deleted (the app called InternetCloseHandle() against
    // it which dereferenced it to 1, and now we've dereferenced it to zero)
    //

    if (hObject->Dereference()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (error == ERROR_INTERNET_OPERATION_CANCELLED) {

        //
        // the parent handle was deleted. Kill off the new handle too
        //

        BOOL ok;

        ok = hObject->Dereference();

        INET_ASSERT(ok);

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatus(
    IN DWORD dwStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwLength
    )

/*++

Routine Description:

    If the app has registered a callback function for the object that this
    thread is operating on, call it with the arguments supplied

Arguments:

    dwStatus    - INTERNET_STATUS_ value

    lpBuffer    - pointer to variable data buffer

    dwLength    - length of *lpBuffer in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatus",
                "%s, %#x, %d",
                InternetMapStatus(dwStatus),
                lpBuffer,
                dwLength
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;

    //
    // the app can affect callback operation by specifying a zero context value
    // meaning no callbacks will be generated for this API
    //

    if (lpThreadInfo != NULL) {

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = _InternetGetContext(lpThreadInfo);
        if (context == INTERNET_NO_CALLBACK) {
            context = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetContext();
        }

        INTERNET_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        IF_DEBUG(THRDINFO) {

            if (dwStatus == INTERNET_STATUS_REQUEST_COMPLETE) {

                DEBUG_PRINT(THRDINFO,
                            INFO,
                            ("REQUEST_COMPLETE: dwResult = %#x, dwError = %d [%s]\n",
                            ((LPINTERNET_ASYNC_RESULT)lpBuffer)->dwResult,
                            ((LPINTERNET_ASYNC_RESULT)lpBuffer)->dwError,
                            InternetMapError(((LPINTERNET_ASYNC_RESULT)lpBuffer)->dwError)
                            ));

            }
        }

        if ((appCallback != NULL) && (context != INTERNET_NO_CALLBACK)) {

            LPVOID pInfo;
            DWORD infoLength;
            BOOL isAsyncWorkerThread;
            BYTE buffer[256];

            //
            // we make a copy of the info to remove the app's opportunity to
            // change it. E.g. if we were about to resolve host name "foo" and
            // passed the pointer to our buffer containing "foo", the app could
            // change the name to "bar", changing the intended server
            //

            if (lpBuffer != NULL) {
                if (dwLength <= sizeof(buffer)) {
                    pInfo = buffer;
                } else {
                    pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(dwLength);
                }

                if (pInfo != NULL) {
                    memcpy(pInfo, lpBuffer, dwLength);
                    infoLength = dwLength;
                } else {
                    infoLength = 0;

                    DEBUG_PRINT(THRDINFO,
                                ERROR,
                                ("Failed to allocate %d bytes for info\n",
                                dwLength
                                ));

                }
            } else {
                pInfo = NULL;
                infoLength = 0;
            }

            //
            // we're about to call into the app. We may be in the context of an
            // async worker thread, and if the callback submits an async request
            // then we'll execute it synchronously. To avoid this, we will reset
            // the async worker thread indicator in the INTERNET_THREAD_INFO and
            // restore it when the app returns control to us. This way, if the
            // app makes an API request during the callback, on a handle that
            // has async I/O semantics, then we will simply queue it, and not
            // try to execute it synchronously
            //

            isAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
            lpThreadInfo->IsAsyncWorkerThread = FALSE;

            BOOL bInCallback = lpThreadInfo->InCallback;

            lpThreadInfo->InCallback = TRUE;

            INET_ASSERT(!IsBadCodePtr((FARPROC)appCallback));

            DEBUG_ENTER((DBG_THRDINFO,
                         None,
                         "(*callback)",
                         "%#x, %#x, %s (%d), %#x [%#x], %d",
                         lpThreadInfo->hObject,
                         context,
                         InternetMapStatus(dwStatus),
                         dwStatus,
                         pInfo,
                         ((dwStatus == INTERNET_STATUS_HANDLE_CREATED)
                         || (dwStatus == INTERNET_STATUS_HANDLE_CLOSING))
                            ? (DWORD_PTR)*(LPHINTERNET)pInfo
                            : (((dwStatus == INTERNET_STATUS_REQUEST_SENT)
                            || (dwStatus == INTERNET_STATUS_RESPONSE_RECEIVED)
                            || (dwStatus == INTERNET_STATUS_INTERMEDIATE_RESPONSE)
                            || (dwStatus == INTERNET_STATUS_STATE_CHANGE))
                                ? *(LPDWORD)pInfo
                                : 0),
                         infoLength
                         ));

            PERF_LOG(PE_APP_CALLBACK_START,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            HINTERNET hObject = lpThreadInfo->hObject;
            LPVOID hObjectMapped = lpThreadInfo->hObjectMapped;

            appCallback(lpThreadInfo->hObject,
                        context,
                        dwStatus,
                        pInfo,
                        infoLength
                        );

            lpThreadInfo->hObject = hObject;
            lpThreadInfo->hObjectMapped = hObjectMapped;

            PERF_LOG(PE_APP_CALLBACK_END,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_LEAVE(0);

            lpThreadInfo->InCallback = bInCallback;
            lpThreadInfo->IsAsyncWorkerThread = isAsyncWorkerThread;

            //
            // free the buffer
            //

            if (pInfo != NULL) {
                if (dwLength > sizeof(buffer))
                    FREE_FIXED_MEMORY(pInfo);
            }

            //
            // if the object is now invalid then the app closed the handle in
            // the callback, and the entire operation is cancelled
            //

            if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated()) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }
        } else {

            DEBUG_PRINT(THRDINFO,
                        ERROR,
                        ("%#x: callback = %#x, context = %#x\n",
                        lpThreadInfo->hObject,
                        appCallback,
                        context
                        ));

            //
            // if we're completing a request then we shouldn't be here - it
            // means we lost the context or callback address somewhere along the
            // way
            //

            INET_ASSERT(dwStatus != INTERNET_STATUS_REQUEST_COMPLETE);

#ifdef DEBUG
            if ( dwStatus == INTERNET_STATUS_REQUEST_COMPLETE)
            {
                INET_ASSERT(appCallback != NULL);
                INET_ASSERT(context != INTERNET_NO_CALLBACK);
                INET_ASSERT(_InternetGetContext(lpThreadInfo) != INTERNET_NO_CALLBACK);
            }
#endif


        }
    } else {

        //
        // this is catastrophic if the indication was async request completion
        //

        DEBUG_PUT(("InternetIndicateStatus(): no INTERNET_THREAD_INFO?\n"));

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Copies the error text to the per-thread error buffer (moveable memory)

Arguments:

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetSetLastError",
                "%d, %.80q, %d, %#x",
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        error = _InternetSetLastError(lpThreadInfo,
                                      ErrorNumber,
                                      ErrorText,
                                      ErrorTextLength,
                                      Flags
                                      );
    } else {

        DEBUG_PUT(("InternetSetLastError(): no INTERNET_THREAD_INFO\n"));

        error = ERROR_INTERNET_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Sets or resets the last error text in an INTERNET_THREAD_INFO block

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "_InternetSetLastError",
                "%#x, %d, %.80q, %d, %#x",
                lpThreadInfo,
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD currentLength;
    DWORD newTextLength;
    DWORD error;

    newTextLength = ErrorTextLength;

    //
    // if we are appending text, then account for the '\0' currently at the end
    // of the buffer (if it exists)
    //

    if (Flags & SLE_APPEND) {
        currentLength = lpThreadInfo->ErrorTextLength;
        if (currentLength != 0) {
            --currentLength;
        }
        newTextLength += currentLength;
    }

    if (Flags & SLE_ZERO_TERMINATE) {
        ++newTextLength;
    }

    //
    // expect success (and why not?)
    //

    error = ERROR_SUCCESS;

    //
    // allocate, grow or shrink the buffer to fit. The buffer is moveable. If
    // the buffer is being shrunk to zero size then NULL will be returned as
    // the buffer handle from ResizeBuffer()
    //

    lpThreadInfo->hErrorText = ResizeBuffer(lpThreadInfo->hErrorText,
                                            newTextLength,
                                            FALSE
                                            );
    if (lpThreadInfo->hErrorText != NULL) {

        LPSTR lpErrorText;

        lpErrorText = (LPSTR)LOCK_MEMORY(lpThreadInfo->hErrorText);

        INET_ASSERT(lpErrorText != NULL);

        if (lpErrorText != NULL) {
            if (Flags & SLE_APPEND) {
                lpErrorText += currentLength;
            }
            memcpy(lpErrorText, ErrorText, ErrorTextLength);
            if (Flags & SLE_ZERO_TERMINATE) {
                lpErrorText[ErrorTextLength++] = '\0';
            }

            //
            // the text should always be zero-terminated. We expect this in
            // InternetGetLastResponseInfo()
            //

            INET_ASSERT(lpErrorText[ErrorTextLength - 1] == '\0');

            UNLOCK_MEMORY(lpThreadInfo->hErrorText);

        } else {

            //
            // real error occurred - failed to lock memory?
            //

            error = GetLastError();
        }
    } else {

        INET_ASSERT(newTextLength == 0);

        newTextLength = 0;
    }

    //
    // set the error code and text length
    //

    lpThreadInfo->ErrorTextLength = newTextLength;
    lpThreadInfo->ErrorNumber = ErrorNumber;

    DEBUG_LEAVE(error);

    return error;
}


LPSTR
InternetLockErrorText(
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the locked per-thread error text buffer

Arguments:

    None.

Return Value:

    LPSTR
        Success - pointer to locked buffer

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {

        HLOCAL lpErrorText;

        lpErrorText = lpThreadInfo->hErrorText;
        if (lpErrorText != (HLOCAL)NULL) {
            return (LPSTR)LOCK_MEMORY(lpErrorText);
        }
    }
    return NULL;
}

//
//VOID
//InternetUnlockErrorText(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Unlocks the per-thread error text buffer locked by InternetLockErrorText()
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    LPINTERNET_THREAD_INFO lpThreadInfo;
//
//    lpThreadInfo = InternetGetThreadInfo();
//
//    //
//    // assume that if we locked the error text, there must be an
//    // INTERNET_THREAD_INFO when we come to unlock it
//    //
//
//    INET_ASSERT(lpThreadInfo != NULL);
//
//    if (lpThreadInfo != NULL) {
//
//        HLOCAL hErrorText;
//
//        hErrorText = lpThreadInfo->hErrorText;
//
//        //
//        // similarly, there must be a handle to the error text buffer
//        //
//
//        INET_ASSERT(hErrorText != NULL);
//
//        if (hErrorText != (HLOCAL)NULL) {
//            UNLOCK_MEMORY(hErrorText);
//        }
//    }
//}


VOID
InternetSetContext(
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sets the context value in the INTERNET_THREAD_INFO for status callbacks

Arguments:

    dwContext   - context value to remember

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetContext(lpThreadInfo, dwContext);
    }
}


VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    )

/*++

Routine Description:

    Sets the hObject field in the INTERNET_THREAD_INFO structure so we can get
    at the handle contents, even when we're in a function that does not take
    the hInternet as a parameter

Arguments:

    hInternet       - handle of object we may need info from

    hInternetMapped - mapped handle of object we may need info from

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }
}


HINTERNET
InternetGetObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObject value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}


HINTERNET
InternetGetMappedObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObjectMapped value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObjectMapped;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\strtokex.c ===
/***
*strtokex.c - tokenize a string with given delimiters
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines strtok() - breaks string into series of token
*       via repeated calls.
*
*******************************************************************************/
#if defined(unix)
#define __cdecl
#endif
#include <string.h>
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char * __cdecl StrTokEx (char ** pstring, const char * control)
{
        /*unsigned*/ char *str;
        const /*unsigned*/ char *ctrl = control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = *pstring;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) )
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = str;

        /* Determine if a token has been found. */
        if ( tokenstr == str )
            return NULL;
        else
            return tokenstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\unixwrap.cxx ===
/*
 * unixwrap.cxx
 *
 * Purpose:
 *          Implementation of Functions, to overcome following problems
 *          On Unix:
 *
 *          1. Unix map files do not support statments such as
 *              InternetTimeFromSystemTimeA
 *              InternetTimeFromSystemTimeW
 *              InternetTimeFromSystemTime=InternetTimeFromSystemTimeA
 *          2. Delay loading of functions.
 *
 * Functions:
 *          InternetTimeFromSystemTime
 *          InternetTimeToSystemTime
 *          InternetSetStatusCallback
 *          InternetConfirmZoneCrossing
 *          UnlockUrlCacheEntryFile
 *          DeleteUrlCacheEntry
 *          SetUrlCacheEntryGroup
 *          InternetShowSecurityInfoByURL
 *          InternetDial
 *          InternetSetDialState
 *          InternetGoOnline
 *          InternetGetConnectedStateEx
 *          InternetGetCertByURL
 *
 * ----- CRYPT32 Wrappers -------------------
 *          CryptDecodeObject
 *          CertFindRDNAttr
 *          CertFreeCertificateContext
 *          CryptGetProvParam
 *          CertCreateCertificateContext
 *          CertSetCertificateContextProperty
 *          CertGetCertificateContextProperty
 *          CertNameToStrA
 *          CryptSetProvParam
 *          CertRDNValueToStrA
 *          CryptReleaseContext
 *          CertDuplicateCertificateContext
 *          CertCloseStore
 *          CertControlStore
 *          CertOpenSystemStoreA
 *          CryptAcquireContextA
 *          CertFindCertificateInStore
 */ 

#include <wininetp.h>

/*****************************************************************************/
/*================= Begin of the delay loading definitions ==================*/
/*****************************************************************************/

/*
 * Delay loading mechanism.  This allows you to write code as if you are
 * calling implicitly linked APIs, and yet have these APIs really be
 * explicitly linked.  You can reduce the initial number of DLLs that 
 * are loaded (load on demand) using this technique.
 *
 * Use the following macros to indicate which APIs/DLLs are delay-linked
 * and -loaded.
 *
 *      DELAY_LOAD
 *      DELAY_LOAD_HRESULT
 *      DELAY_LOAD_SAFEARRAY
 *      DELAY_LOAD_UINT
 *      DELAY_LOAD_INT
 *      DELAY_LOAD_VOID
 *
 */

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_hmod = LoadLibraryA(#_dll "." #_ext)))

void _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    /*
     * If it's already loaded, return.
     */
    if (*ppfn) {
        return;
    }

    if (*phmod == NULL)
    {
       *phmod = LoadLibraryA(pszDLL);
       if (*phmod == NULL)
       {
          return;
       }
    }

    *ppfn = GetProcAddress(*phmod, pszProc);
}

/*
 * NOTE: this takes two parameters that are the function name.
 * the First (_fn) is the name that the function will be called in 
 * this DLL and the other (_fni) is the name of the function we 
 * will GetProcAddress. This helps get around functions that
 * are defined in the header files with _declspec...
 * 
 *  HMODULE _hmod - where we cache the HMODULE (aka HINSTANCE)
 *           _dll - Basename of the target DLL, not quoted
 *           _ext - Extension of the target DLL, not quoted (usually DLL)
 *           _ret - Data type of return value
 *        _fnpriv - Local name for the function
 *            _fn - Exported name for the function
 *          _args - Argument list in the form (TYPE1 arg1, TYPE2 arg2, ...)
 *         _nargs - Argument list in the form (arg1, arg2, ...)
 *           _err - Return value if we can't call the actual function
 */
#define DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hmod, #_dll "." #_ext, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_NAME_ERR(_hmod, _dll,       _ret, _fnpriv, _fn, _args, _nargs, _err) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll,  DLL, _ret, _fnpriv, _fn, _args, _nargs, _err)

#define DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn,      _args, _nargs, _err) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hmod, _dll, _ret, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn, _args, _nargs, 0)

#define DELAY_LOAD_HRESULT(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)

#define DELAY_LOAD_SAFEARRAY(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)

#define DELAY_LOAD_UINT(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, UINT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_INT(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_BOOL(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, BOOL, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_BOOLEAN(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, BOOLEAN, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_DWORD(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_WNET(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, WN_NOT_SUPPORTED)

/*
 * the NAME variants allow the local function to be called something different from the imported
 * function to avoid dll linkage problems.
 */
#define DELAY_LOAD_NAME(_hmod, _dll, _ret, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_HRESULT(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, HRESULT, _fn, _fni, _args, _nargs, E_FAIL)

#define DELAY_LOAD_NAME_SAFEARRAY(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, SAFEARRAY *, _fn, _fni, _args, _nargs, NULL)

#define DELAY_LOAD_NAME_UINT(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, UINT, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_BOOL(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, BOOL, _fn, _fni, _args, _nargs, FALSE)

#define DELAY_LOAD_NAME_DWORD(_hmod, _dll, _fn, _fni, _args, _nargs) \
        DELAY_LOAD_NAME_ERR(_hmod, _dll, DWORD, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fni, _args, _nargs)                             \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (__stdcall *_pfn##_fni) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hmod, _dll, DLL, TEXT(#_fni)))                                       \
    {                                                                                   \
        AssertMsg(BOOLFROMPTR(_hmod), TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fni == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fni) = GetProcAddress(_hmod, #_fni);                         \
        AssertMsg(BOOLFROMPTR(_pfn##_fni), TEXT("GetProcAddress failed on ") ## TEXT(#_fni));    \
        if (_pfn##_fni == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fni _nargs;                                                                   \
}

#define DELAY_LOAD_VOID(_hmod, _dll, _fn, _args, _nargs) \
        DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fn, _args, _nargs)

#define DELAY_LOAD_EXT(_hmod, _dll, _ext, _ret, _fn, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fn, _fn, _args, _nargs, 0)

/*****************************************************************************/
/*================= End   of the delay loading definitions ==================*/
/*****************************************************************************/

/*************************************/
/*=== Begin: Wrappers for CRYPT32 ===*/
/*************************************/

HINSTANCE g_hinstCRYPT32 = NULL;

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE* pbEncoded, DWORD cbEncoded, DWORD dwFlags, void* pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo ))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName), (pszObjId, pName))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext), (pCertContext))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptGetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags), (hProv, dwParam, pbData, pdwDataLen, dwFlags))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCCERT_CONTEXT, CertCreateCertificateContext,
    (DWORD dwCertEncodingType, const BYTE* pbCertEncoded, DWORD cbCertEncoded),
    (dwCertEncodingType, pbCertEncoded, cbCertEncoded))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void* pvData), (pCertContext, dwPropId, dwFlags, pvData))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void* pvData, DWORD* pcbData),
    (pCertContext, dwPropId, pvData, pcbData))

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertNameToStrW,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertNameToStrA,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz))
#endif /* UNICODE */

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptSetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE* pbData, DWORD dwFlags),
    (hProv, dwParam, pbData, dwFlags))

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertRDNValueToStrW,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz))
#endif /* UNICODE */

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags), (hProv, dwFlags))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext), (pCertContext))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags), (hCertStore, dwFlags))

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CertControlStore,
    (HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, void const* pvCtrlPara),
    (hCertStore, dwFlags, dwCtrlType, pvCtrlPara))

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, HCERTSTORE, CertOpenSystemStoreW,
    (HCRYPTPROV hProv, LPCWSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, HCERTSTORE, CertOpenSystemStoreA,
    (HCRYPTPROV hProv, LPCSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol))
#endif /* UNICODE */

#ifdef UNICODE
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptAcquireContextW,
    (HCRYPTPROV* phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags))
#else
DELAY_LOAD(g_hinstCRYPT32, CRYPT32, BOOL, CryptAcquireContextA,
    (HCRYPTPROV* phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags))
#endif /* UNICODE */

DELAY_LOAD(g_hinstCRYPT32, CRYPT32, PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void* pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext))

/*************************************/
/*=== End:   Wrappers for CRYPT32 ===*/
/*************************************/

/* In wininet.def, we don't support statements like
 * InternetTimeFromSystemTime=InternetTimeFromSystemTimeA
 * So, on Unix, we create a wrapper for InternetTimeFromSystemTime which will
 * call the corresponding ANSI function.
 *
 * The following are all such wrappers ----
 */

extern "C" {

#ifdef InternetTimeFromSystemTime
#undef InternetTimeFromSystemTime
#endif

INTERNETAPI_(BOOL) InternetTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    ) {
    return InternetTimeFromSystemTimeA(pst, dwRFC, lpszTime, cbTime);
}

#ifdef InternetTimeToSystemTime
#undef InternetTimeToSystemTime
#endif

INTERNETAPI_(BOOL) InternetTimeToSystemTime(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved )
{
    return InternetTimeToSystemTimeA(lpcszTimeString, lpSysTime, dwReserved);
}

#ifdef InternetSetStatusCallback
#undef InternetSetStatusCallback
#endif

INTERNETAPI_(BOOL) InternetSetStatusCallback(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )
{
    return InternetSetStatusCallbackA(hInternet, lpfnInternetCallback);
}

#ifdef InternetConfirmZoneCrossing
#undef InternetConfirmZoneCrossing
#endif

INTERNETAPI_(BOOL) InternetConfirmZoneCrossing(
    IN HWND hWnd,
    IN LPSTR szUrlPrev,
    IN LPSTR szUrlNew,
    BOOL bPost
    )
{
    return InternetConfirmZoneCrossingA(hWnd, szUrlPrev, szUrlNew, bPost);
}

#ifdef UnlockUrlCacheEntryFile
#undef UnlockUrlCacheEntryFile
#endif

URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFile(
    LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
{
    return UnlockUrlCacheEntryFileA(lpszUrlName,dwReserved);
}

#ifdef DeleteUrlCacheEntry
#undef DeleteUrlCacheEntry
#endif

URLCACHEAPI_(BOOL) DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    )
{
    return DeleteUrlCacheEntryA(lpszUrlName);
}

#ifdef SetUrlCacheEntryGroup
#undef SetUrlCacheEntryGroup
#endif

BOOLAPI SetUrlCacheEntryGroup(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    return SetUrlCacheEntryGroupA(lpszUrlName, dwFlags, GroupId, pbGroupAttributes,
                                  cbGroupAttributes, lpReserved);
}

#ifdef InternetShowSecurityInfoByURL
#undef InternetShowSecurityInfoByURL
#endif

INTERNETAPI_(BOOL) InternetShowSecurityInfoByURL(
    IN LPSTR     lpszURL,
    IN HWND      hwndRootWindow
    )
{
    return InternetShowSecurityInfoByURLA(lpszURL, hwndRootWindow);
}

#ifdef InternetDial
#undef InternetDial
#endif

DWORD InternetDial(HWND hwndParent, LPSTR pszConnectoid, DWORD dwFlags,
    LPDWORD lpdwConnection, DWORD dwReserved)
{
    return InternetDialA(hwndParent, pszConnectoid, dwFlags, lpdwConnection, dwReserved);
}

#ifdef InternetSetDialState
#undef InternetSetDialState
#endif

BOOLAPI InternetSetDialState(LPCSTR lpszConnectoid, DWORD dwState, DWORD dwReserved)
{
        return InternetSetDialStateA(lpszConnectoid, dwState, dwReserved);
}

#ifdef InternetGoOnline
#undef InternetGoOnline
#endif

BOOLAPI InternetGoOnline(LPSTR lpszURL, HWND hwndParent, DWORD dwFlags)
{
        return InternetGoOnlineA(lpszURL, hwndParent, dwFlags);
}

#ifdef InternetGetConnectedStateEx
#undef InternetGetConnectedStateEx
#endif

BOOL InternetGetConnectedStateEx(
    LPDWORD lpdwFlags,
    LPSTR lpszConnectionName,
    DWORD dwBufLen,
    DWORD dwReserved)
{
    return InternetGetConnectedStateExA(lpdwFlags, lpszConnectionName, dwBufLen, dwReserved);
}

#ifdef InternetGetCertByURL
#undef InternetGetCertByURL
#endif

INTERNETAPI_(BOOL) InternetGetCertByURLA(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    );

INTERNETAPI_(BOOL) InternetGetCertByURL(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
{
    return InternetGetCertByURLA(lpszURL, lpszCertText, dwcbCertText);
}


#ifdef HttpCheckDavCompliance
#undef HttpCheckDavCompliance
#endif

INTERNETAPI_(BOOL) HttpCheckDavComplianceA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    );

INTERNETAPI_(BOOL) HttpCheckDavCompliance(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )
{
    return HttpCheckDavComplianceA(lpszUrl,
                                   lpszComplianceToken,
                                   lpfFound,
                                   hWnd,
                                   lpvReserved);
}

#ifdef DAVCACHING // commenting out as per bug 15696

#ifdef HttpCheckCachedDavStatus
#undef HttpCheckCachedDavStatus
#endif

INTERNETAPI_(BOOL) HttpCheckCachedDavStatusA(
    IN LPCSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    );

INTERNETAPI_(BOOL) HttpCheckCachedDavStatus(
    IN LPCSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    )
{
    return HttpCheckCachedDavStatusA(lpszUrl, lpdwStatus);
}

#endif /* DAVCACHING */

#ifndef UNIX_BUILDS_AUTOPROXY_DETECT
/* Stub function if apdetect is not included in build */
STDAPI_(BOOL)
DetectAutoProxyUrl(
    IN OUT LPSTR lpszAutoProxyUrl,
    IN DWORD dwAutoProxyUrlLength,
    IN DWORD dwDetectFlags
    )
{
    return FALSE;
}
#endif /* UNIX_BUIDS_AUTOPROXY_DETECT */


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\asyncdl\asyncdl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    asyncdl.c

Abstract:

    Asynchronous download. Tests reading an URL entirely asynchronously

Author:

    Richard L Firth (rfirth) 19-Nov-1995

Revision History:

    19-Nov-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define DEFAULT_URL         "http://www.microsoft.com"
#define URL_SIGN            (DWORD)'UrlX'
#define DEFAULT_BUFLEN      1024
#define BUFFER_INCREMENT    DEFAULT_BUFLEN

typedef enum {
    STATE_OPEN,
    STATE_READ,
    STATE_CLOSE,
    STATE_ERROR
} URL_STATE;

typedef struct {
    DWORD Signature;
    URL_STATE State;
    LPVOID Buffer;
    DWORD BufferLength;
    DWORD BytesRead;
    DWORD NumRead;
    HINTERNET Handle;
} URL_CONTEXT, * LPURL_CONTEXT;

void _CRTAPI1 main(int, char**);
void usage(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void data_handler(LPURL_CONTEXT, LPINTERNET_ASYNC_RESULT);

BOOL Verbose = FALSE;
BOOL Completed = FALSE;
BOOL UseQuery = FALSE;

HANDLE AsyncEvent;
DWORD AsyncResult;
DWORD AsyncError;

LPURL_CONTEXT UrlContext;

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR url = NULL;
    DWORD accessMode = PRE_CONFIG_INTERNET_ACCESS;
    LPURL_CONTEXT lpContext;
    INTERNET_STATUS_CALLBACK cbres;
    HINTERNET hInternet;
    HINTERNET hUrl;
    BOOL displayData = FALSE;
    LPSTR filename = NULL;
    DWORD openFlags = 0;
    LPSTR proxy = NULL;
    BOOL expectingProxy = FALSE;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'a':
                switch (*++*argv) {
                case 'l':
                case 'd':
                    accessMode = INTERNET_OPEN_TYPE_DIRECT;
                    break;

                case 'p':
                    accessMode = INTERNET_OPEN_TYPE_PROXY;
                    proxy = ++*argv;
                    if (!*proxy) {
                        expectingProxy = TRUE;
                    }
                    break;

                default:
                    printf("error: unrecognized access mode flag: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'd':
                displayData = TRUE;
                break;

            case 'f':
                if (*++*argv) {
                    filename = *argv;
                } else {
                    printf("error: no filename found for -f flag\n");
                    usage();
                }
                break;

            case 'n':
                openFlags |= INTERNET_FLAG_NO_CACHE_WRITE;
                break;

            case 'q':
                UseQuery = TRUE;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (!url) {
            url = *argv;
        } else if (expectingProxy) {
            proxy = *argv;
            expectingProxy = FALSE;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (proxy != NULL) {
        if (!*proxy) {
            printf("error: expecting proxy server name\n");
            usage();
        }
    }

    AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!AsyncEvent) {
        print_error("asyncdl", "CreateEvent()");
        exit(1);
    }

    lpContext = (LPURL_CONTEXT)calloc(1, sizeof(URL_CONTEXT));
    if (!lpContext) {
        printf("error: calloc() failed\n");
        exit(1);
    }
    lpContext->Buffer = malloc(DEFAULT_BUFLEN);
    if (!lpContext->Buffer) {
        printf("error: malloc(%d) failed\n", DEFAULT_BUFLEN);
        exit(1);
    }
    lpContext->BufferLength = DEFAULT_BUFLEN;
    lpContext->Signature = URL_SIGN;
    lpContext->State = STATE_OPEN;
    UrlContext = lpContext;

    if (Verbose) {
        printf("opening Internet handle\n");
    }

    hInternet = InternetOpen("Async Read Test",
                             accessMode,
                             proxy,
                             NULL,
                             INTERNET_FLAG_ASYNC
                             );
    if (!hInternet) {
        print_error("asyncdl", "InternetOpen()");
        exit(1);
    } else if (Verbose) {
        printf("InternetOpen() returns handle %x\n", hInternet);
    }

    if (Verbose) {
        printf("installing callback\n");
    }

    cbres = InternetSetStatusCallback(hInternet, my_callback);
    if (cbres == INTERNET_INVALID_STATUS_CALLBACK) {
        print_error("asyncdl", "InternetSetStatusCallback()");
        exit(1);
    }

    if (Verbose) {
        printf("opening URL %s\n", url);
    }

    hUrl = InternetOpenUrl(hInternet,
                           url,
                           NULL,    // lpHeaders
                           0,       // dwHeadersLength
                           openFlags,
                           (DWORD)lpContext
                           );
    if (hUrl == NULL) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("asyncdl", "InternetOpenUrl()");
            exit(1);
        }
        if (Verbose) {
            printf("waiting for async InternetOpenUrl()...\n");
        }
        WaitForSingleObject(AsyncEvent, INFINITE);
        hUrl = (HINTERNET)AsyncResult;
        SetLastError(AsyncError);
    } else {
        printf("warning: InternetOpenUrl() returns synchronous result\n");
    }

    if (!hUrl) {
        if (!Completed) {
            print_error("asyncdl", "InternetOpenUrl()");
            exit(1);
        } else if (Verbose) {
            printf("Download completed OK!\n");
        }
    } else {
        printf("error: unexpected hUrl = %x\n", hUrl);
    }

    if (displayData) {

        int fh;
        int mode;

        if (filename) {
            fh = _open(filename, _O_CREAT|_O_TRUNC|_O_WRONLY|_O_BINARY, _S_IREAD|_S_IWRITE);
            if (fh == -1) {
                printf("error: cannot open file \"%s\" for writing\n", filename);
                filename = NULL;
            }
        }
        if (!filename) {
            if (Verbose) {
                printf("%d bytes data received:\n", lpContext->BytesRead);
            }
            mode = _setmode(1, _O_BINARY);
            fh = 1;
        }
        _write(fh, lpContext->Buffer, lpContext->BytesRead);
        if (filename) {
            _close(fh);
        } else {
            _setmode(1, mode);
        }
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("\n"
           "usage: asyncdl [-a<l|g|p>[<server>[:<port>]]] [-d] [-f<file>] [-n] [-v] <url>\n"
           "\n"
           "where: -a  = access mode. Default is pre-configured\n"
           "       -al = local internet access (same as -ad)\n"
           "       -ap = CERN proxy internet access. <server> is required\n"
           "       -d  = Display received data\n"
           "       -f  = Write data to <file>. Only if -d set\n"
           "       -n  = Don't write data to cache\n"
           "       -v  = Verbose mode\n"
           "\n"
           "If no URL is supplied, " DEFAULT_URL " will be used\n"
           );
    exit(1);
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: Hndl %x [Ctxt %x [%s]] %s ",
                Handle,
                Context,
                (Context == (DWORD)UrlContext) ? "Url"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {

                DWORD handleType;
                DWORD handleTypeSize = sizeof(handleType);
                LPSTR typeStr;

                printf("%x", *(LPHINTERNET)Info);

                if (InternetQueryOption(*(LPHINTERNET)Info,
                                        INTERNET_OPTION_HANDLE_TYPE,
                                        &handleType,
                                        &handleTypeSize
                                        )) {
                    switch (handleType) {
                    case INTERNET_HANDLE_TYPE_INTERNET:
                        typeStr = "Internet";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_FTP:
                        typeStr = "FTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
                        typeStr = "Gopher Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
                        typeStr = "HTTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND:
                        typeStr = "FTP Find";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
                        typeStr = "FTP Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE:
                        typeStr = "FTP File";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
                        typeStr = "FTP File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND:
                        typeStr = "Gopher Find";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
                        typeStr = "Gopher Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE:
                        typeStr = "Gopher File";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
                        typeStr = "Gopher File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
                        typeStr = "HTTP Request";
                        break;

                    default:
                        typeStr = "???";
                        break;
                    }
                    ((LPURL_CONTEXT)Context)->Handle = *(LPHINTERNET)Info;
                } else {
                    typeStr = "<error>";
                }
                printf(" [%s]", typeStr);
            } else if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {

                //
                // nothing
                //

            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }

    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        data_handler((LPURL_CONTEXT)Context,
                     (LPINTERNET_ASYNC_RESULT)Info
                     );
    }
}

void
data_handler(
    LPURL_CONTEXT lpContext,
    LPINTERNET_ASYNC_RESULT Results
    )
{
    BOOL ok;
    DWORD len;
    int retcode;
    DWORD available;
    HINTERNET hInternet = lpContext->Handle;

    if (lpContext->Signature != URL_SIGN) {
        printf("fatal: unrecognized context block %x\n", lpContext);
        exit(1);
    }

    while (1) {
        switch (lpContext->State) {
        case STATE_OPEN:
            if (!Results->dwResult) {
                SetLastError(Results->dwError);
                print_error("data_handler", "async InternetOpenUrl()");
                exit(1);
            }
            len = sizeof(retcode);
            ok = HttpQueryInfo(hInternet,
                               HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                               (LPVOID)&retcode,
                               &len,
                               NULL
                               );
            if (!ok) {
                print_error("data_handler", "HttpQueryInfo()");
                goto error_exit;
            }
            if (retcode != 200) {
                printf("error: server returns error %d\n", retcode);
                goto error_exit;
            } else if (Verbose) {
                printf("async InternetOpenUrl(): HTTP result code %d\n", retcode);
            }
            do {
                if (UseQuery) {
                    ok = InternetQueryDataAvailable(
                            hInternet,
                            &available,
                            0,
                            0
                            );
                } else {
                    ok = InternetReadFile(
                            hInternet,
                            (LPBYTE)lpContext->Buffer + lpContext->BytesRead,
                            lpContext->BufferLength - lpContext->BytesRead,
                            &lpContext->NumRead
                            );
                }

            } while (ok);
            if (!ok) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("initial read started...\n");
                    }
                    lpContext->State = STATE_READ;
                    return;
                } else {
                    print_error("data_handler", "InternetReadFile()");
                    exit(1);
                }
            }
            return;

        case STATE_READ:
            if (!Results->dwResult) {
                SetLastError(Results->dwError);
                print_error("data_handler", "async InternetReadFile()");
                exit(1);
            }
            if (lpContext->NumRead == 0) {
                if (Verbose) {
                    printf("finished\n");
                    lpContext->State = STATE_CLOSE;
                    continue;
                }
            } else if (Verbose) {
                printf("InternetReadFile() returns %d bytes\n", lpContext->NumRead);
            }
            lpContext->BytesRead += lpContext->NumRead;
            if (Verbose) {
                printf("reallocating buffer %x from %d (%x) to %d (%x)\n",
                        lpContext->Buffer,
                        lpContext->BufferLength,
                        lpContext->BufferLength,
                        lpContext->BufferLength + BUFFER_INCREMENT,
                        lpContext->BufferLength + BUFFER_INCREMENT
                        );
            }
            lpContext->Buffer = realloc(lpContext->Buffer,
                                        lpContext->BufferLength + BUFFER_INCREMENT
                                        );
            if (lpContext->Buffer == NULL) {
                printf("error: data_handler: realloc() failed\n");
                exit(1);
            }
            lpContext->BufferLength += BUFFER_INCREMENT;
            ok = InternetReadFile(hInternet,
                                  (LPBYTE)lpContext->Buffer + lpContext->BytesRead,
                                  lpContext->BufferLength - lpContext->BytesRead,
                                  &lpContext->NumRead
                                  );
            if (!ok) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    return;
                } else {
                    print_error("data_handler", "InternetReadFile()");
                    exit(1);
                }
            }
            return;

        case STATE_CLOSE:
            InternetCloseHandle(hInternet);
            AsyncResult = 0;
            AsyncError = 0;
            Completed = TRUE;
            SetEvent(AsyncEvent);
            return;

        case STATE_ERROR:
            return;

        default:
            printf("fatal: unrecognized state %x in context %x\n",
                lpContext->State,
                lpContext
                );
            exit(1);
        }
    }

    printf("\aerror: data_handler: didn't expect to reach here\n");

    return;

error_exit:

    AsyncResult = Results->dwResult;
    AsyncError = Results->dwError;
    InternetCloseHandle(hInternet);
    SetEvent(AsyncEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\dbginfo\dbginfo.c ===
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <windows.h>
#include <wininet.h>
#include <wininetd.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
LPVOID get_and_dump_debug_info(LPDWORD);
void dump_internet_debug_info(LPINTERNET_DEBUG_INFO);

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    DWORD length;
    LPVOID buf;
    DWORD inlength;
    LPVOID buf2;
    HINTERNET hInternet;
    HINTERNET hGopher;
    char locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
    HINTERNET hFind;
    GOPHER_FIND_DATA data;

    buf = get_and_dump_debug_info(&length);
    inlength = length;
    length += sizeof("mydebug.log");
    buf2 = malloc(length);
    if (!buf2) {
        printf("error: failed to allocate %d bytes\n", length);
        exit(1);
    }

    memcpy(buf2, buf, inlength);
    free(buf);

    ((LPINTERNET_DEBUG_INFO)buf2)->CategoryFlags = 0xffffffff;
    ((LPINTERNET_DEBUG_INFO)buf2)->ControlFlags = 0x7df;
    strcpy(((LPINTERNET_DEBUG_INFO)buf2)->Filename, "mydebug.log");

    ok = InternetSetOption(NULL,
                           INTERNET_OPTION_SET_DEBUG_INFO,
                           buf2,
                           length
                           );
    if (!ok) {
        printf("error: InternetSetOption() returns %d\n", GetLastError());
        exit(1);
    }

    //
    // make sure we set it
    //

    buf = get_and_dump_debug_info(&length);
    free(buf);

    //
    // try generating some debug info
    //

    hInternet = InternetOpen("dbginfo",
                             PRE_CONFIG_INTERNET_ACCESS,
                             NULL,
                             0,
                             0
                             );
    if (!hInternet) {
        printf("error: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    hGopher = InternetConnect(hInternet,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              INTERNET_SERVICE_GOPHER,
                              0,
                              0
                              );
    if (!hGopher) {
        printf("error: InternetConnect() returns %d\n", GetLastError());
    }

    length = sizeof(locator);
    if (!GopherCreateLocator("rfirthmips",
                             0,
                             NULL,
                             NULL,
                             GOPHER_TYPE_DIRECTORY,
                             locator,
                             &length
                             )) {
        printf("error: GopherCreateLocator() returns %d\n", GetLastError());
        exit(1);
    }

    hFind = GopherFindFirstFile(hGopher,
                                locator,
                                NULL,
                                &data,
                                0
                                );
    if (!hFind) {
        printf("error: GopherFindFirstFile() returns %d\n", GetLastError());
    }

    free(buf2);
    exit(0);
}

LPVOID get_and_dump_debug_info(LPDWORD outLen) {

    BOOL ok;
    DWORD length;
    DWORD error;
    LPVOID buf;
    DWORD inlength;

    length = 0;
    ok = InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_DEBUG_INFO,
                             (LPVOID)0x1234,
                             &length
                             );
    if (ok) {
        printf("error: InternetQueryOption() with zero length returns TRUE\n");
        exit(1);
    }

    error = GetLastError();
    if (error != ERROR_INSUFFICIENT_BUFFER) {
        printf("error: InternetQueryOption() with zero length returns %d\n", error);
    }

    printf("InternetQueryOption() with zero length returns %d\n", error);
    printf("length = %d\n", length);

    length = 65535;
    ok = InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_DEBUG_INFO,
                             NULL,
                             &length
                             );
    if (ok) {
        printf("error: InternetQueryOption() with no buffer returns %d\n", error);
        exit(1);
    }

    error = GetLastError();
    if (error != ERROR_INSUFFICIENT_BUFFER) {
        printf("error: InternetQueryOption() with no buffer returns %d\n", error);
    }

    printf("InternetQueryOption() with no buffer returns %d\n", error);
    printf("length = %d\n", length);

    buf = malloc(length);
    if (!buf) {
        printf("error: failed to allocate %d bytes\n", length);
        exit(1);
    }

    inlength = length;
    ok = InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_DEBUG_INFO,
                             buf,
                             &length
                             );
    if (!ok) {
        printf("error: InternetQueryOption() with %d byte buffer returns %d. Length = %d\n",
                inlength,
                GetLastError(),
                length
                );
        exit(1);
    }
    printf("InternetQueryOption() returns %d byte buffer\n", length);
    dump_internet_debug_info((LPINTERNET_DEBUG_INFO)buf);
    *outLen = length;
    return buf;
}

void dump_internet_debug_info(LPINTERNET_DEBUG_INFO info) {
    printf("ErrorLevel      = %d\n"
           "ControlFlags    = %x\n"
           "CategoryFlags   = %x\n"
           "BreakFlags      = %x\n"
           "IndentIncrement = %d\n"
           "Filename        = \"%s\"\n"
           "\n",
           info->ErrorLevel,
           info->ControlFlags,
           info->CategoryFlags,
           info->BreakFlags,
           info->IndentIncrement,
           info->Filename
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\ou\ou.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    openurl.c

Abstract:

    Tests InternetOpenUrl()/InternetReadFile()

Author:

    Richard L Firth (rfirth) 29-May-1995

Revision History:

    29-May-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <wininet.h>
#include <winsock.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void my_callback(DWORD, DWORD, LPVOID, DWORD);
void open_urls(LPSTR*, int);
void get_url_data(HINTERNET);
void ftp_find(HINTERNET);
void gopher_find(HINTERNET);
void read_data(HINTERNET);
void print_error(char*, char*, ...);
char* map_error(DWORD);
void get_last_internet_error(void);

//
// data
//

BOOL Verbose = FALSE;
HINTERNET InternetHandle = NULL;
INTERNET_STATUS_CALLBACK PreviousCallback;

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    LPSTR urls[64];
    int numberOfUrls = 0;
    BOOL fCallback = FALSE;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case 'c':
                fCallback = TRUE;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else {
            if (numberOfUrls == sizeof(urls)/sizeof(urls[0]) - 1) {
                break;
            }
            urls[numberOfUrls++] = *argv;
        }
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    //
    // let's have a status callback
    //

    if (fCallback) {
        PreviousCallback = InternetSetStatusCallback(my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    //
    // open gateway
    //

    InternetHandle = InternetOpen("ou",
                                  PRE_CONFIG_INTERNET_ACCESS,
                                  NULL,
                                  0,
                                  0
                                  );
    if (InternetHandle == NULL) {
        printf("error: openurl: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    if (numberOfUrls == 0) {
        printf("error: you must supply an URL\n");
        usage();
    } else {
        open_urls(urls, numberOfUrls);
    }

    ok = InternetCloseHandle(InternetHandle);
    if (!ok) {
        printf("error: openurl: InternetClose(InternetHandle) returns %d\n", GetLastError());
        exit(1);
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: ou [-c] [-v] [url]*\n"
           "where:  -c = enable status call-backs\n"
           "        -v = Verbose mode\n"
           "        url = one or more URLs to open\n"
           );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (InternetHandle != NULL) {
        printf("closing Internet handle %x\n", InternetHandle);
        if (!InternetCloseHandle(InternetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle()");
        }
    }
}

VOID
my_callback(
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    default:
        type$ = "???";
        break;
    }
    printf("callback: %s ", type$);
    if (Info) {
        printf(Info);
    }
    putchar('\n');
}

void open_urls(LPSTR* purls, int nurls) {

    HINTERNET handle;

    while (nurls--) {
        printf("\nopening URL \"%s\"\n\n", *purls);
        handle = InternetOpenUrl(InternetHandle,
                                 *purls,
                                 NULL,
                                 0,
                                 0,
                                 0
                                 );
        if (handle == NULL) {
            print_error("open_urls", "InternetOpenUrl(%s)", *purls);
        } else {
            get_url_data(handle);
        }
        ++purls;
    }
}

void get_url_data(HINTERNET handle) {

    DWORD handleType;
    DWORD handleTypeLen;

    handleTypeLen = sizeof(handleType);
    if (InternetQueryOption(handle,
                            INTERNET_OPTION_HANDLE_TYPE,
                            (LPVOID)&handleType,
                            &handleTypeLen
                            )) {
        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            printf("error: get_url_data: HANDLE_TYPE_INTERNET?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_FTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_GOPHER?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_HTTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            ftp_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_FTP_FILE:
            read_data(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            gopher_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
            read_data(handle);
            break;

        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            read_data(handle);
            break;

        default:
            printf("error: get_url_data: handleType == %d?\n", handleType);
            break;
        }
        if (!InternetCloseHandle(handle)) {
            print_error("get_url_data", "InternetCloseHandle()");
        }
    } else {
        print_error("get_url_data", "InternetQueryOption()");
    }
}

void ftp_find(HINTERNET handle) {

    WIN32_FIND_DATA ffd;
    DWORD nRead;

    while (InternetReadFile(handle, (LPVOID)&ffd, sizeof(ffd), &nRead)) {

        SYSTEMTIME stDbg;

        if (!FileTimeToSystemTime(&ffd.ftLastWriteTime, &stDbg)) {
            printf("| ftLastWriteTime = ERROR\n");
        }

        printf("%2d-%02d-%04d %2d:%02d:%02d  %15d bytes %-s%-s%-s %s\n",
               stDbg.wMonth, stDbg.wDay, stDbg.wYear,
               stDbg.wHour, stDbg.wMinute, stDbg.wSecond,
               ffd.nFileSizeLow,
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)    ? "Normal    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)  ? "ReadOnly  " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? "Directory " : "",
               ffd.cFileName
               );
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("ftp_find", "InternetReadFile()");
    }
}

void gopher_find(HINTERNET handle) {

    GOPHER_FIND_DATA data;
    int i;
    DWORD nRead;

    i = 0;
    while (InternetReadFile(handle, (LPVOID)&data, sizeof(data), &nRead)) {

        LPGOPHER_FIND_DATA p;
        SYSTEMTIME systemTime;
        char timeBuf[9];
        char sizeBuf[32];

        p = (LPGOPHER_FIND_DATA)&data;
        if ((p->LastModificationTime.dwLowDateTime != 0)
        && (p->LastModificationTime.dwHighDateTime != 0)) {
            FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
            sprintf(timeBuf,
                    "%02d-%02d-%02d",
                    systemTime.wMonth,
                    systemTime.wDay,
                    systemTime.wYear % 100
                    );
            sprintf(sizeBuf, "%d", p->SizeLow);
        } else {
            timeBuf[0] = '\0';
            sizeBuf[0] = '\0';
        }
        printf("%5d %c %7s %10s %8s %s\n",
                i,
                (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                : "\a????",
                sizeBuf,
                timeBuf,
                p->DisplayString
                );
        ++i;
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("gopher_find", "InternetReadFile()");
    }
}

void read_data(HINTERNET handle) {

    char buf[1021]; // odd number for fun!
    DWORD nread;

    while (InternetReadFile(handle, buf, sizeof(buf), &nread)) {
        if (!nread) {
            printf("=== end of file ===\n");
            break;
        } else {
            setmode(1, _O_BINARY);
            write(1, buf, nread);
        }
    }
    if (GetLastError() != ERROR_SUCCESS) {
        print_error("read_file", "InternetReadFile()");
    }
}

void print_error(char* func, char* format, ...) {

    va_list argptr;
    char buf[256];
    DWORD error;

    error = GetLastError();
    va_start(argptr, format);
    vsprintf(buf, format, argptr);
    printf("error: %s: %s returns %d [%s]\n", func, buf, error, map_error(error));
    va_end(argptr);
    if (error == ERROR_INTERNET_EXTENDED_ERROR) {
        get_last_internet_error();
    }
}

char* map_error(DWORD error) {
    switch (error) {
    case ERROR_FILE_NOT_FOUND:
        return "ERROR_FILE_NOT_FOUND";

    case ERROR_PATH_NOT_FOUND:
        return "ERROR_PATH_NOT_FOUND";

    case ERROR_ACCESS_DENIED:
        return "ERROR_ACCESS_DENIED";

    case ERROR_INVALID_HANDLE:
        return "ERROR_INVALID_HANDLE";

    case ERROR_NOT_ENOUGH_MEMORY:
        return "ERROR_NOT_ENOUGH_MEMORY";

    case ERROR_NO_MORE_FILES:
        return "ERROR_NO_MORE_FILES";

    case ERROR_INVALID_PASSWORD:
        return "ERROR_INVALID_PASSWORD";

    case ERROR_INVALID_PARAMETER:
        return "ERROR_INVALID_PARAMETER";

    case ERROR_BUFFER_OVERFLOW:
        return "ERROR_BUFFER_OVERFLOW";

    case ERROR_NO_MORE_SEARCH_HANDLES:
        return "ERROR_NO_MORE_SEARCH_HANDLES";

    case ERROR_INVALID_TARGET_HANDLE:
        return "ERROR_INVALID_TARGET_HANDLE";

    case ERROR_CALL_NOT_IMPLEMENTED:
        return "ERROR_CALL_NOT_IMPLEMENTED";

    case ERROR_INSUFFICIENT_BUFFER:
        return "ERROR_INSUFFICIENT_BUFFER";

    case ERROR_INVALID_NAME:
        return "ERROR_INVALID_NAME";

    case ERROR_INVALID_LEVEL:
        return "ERROR_INVALID_LEVEL";

    case ERROR_BAD_PATHNAME:
        return "ERROR_BAD_PATHNAME";

    case ERROR_BUSY:
        return "ERROR_BUSY";

    case ERROR_ALREADY_EXISTS:
        return "ERROR_ALREADY_EXISTS";

    case ERROR_FILENAME_EXCED_RANGE:
        return "ERROR_FILENAME_EXCED_RANGE";

    case ERROR_MORE_DATA:
        return "ERROR_MORE_DATA";

    case ERROR_NO_MORE_ITEMS:
        return "ERROR_NO_MORE_ITEMS";

    case ERROR_INVALID_ADDRESS:
        return "ERROR_INVALID_ADDRESS";

    case ERROR_OPERATION_ABORTED:
        return "ERROR_OPERATION_ABORTED";

    case ERROR_INTERNET_OUT_OF_HANDLES:
        return "ERROR_INTERNET_OUT_OF_HANDLES";

    case ERROR_INTERNET_TIMEOUT:
        return "ERROR_INTERNET_TIMEOUT";

    case ERROR_INTERNET_EXTENDED_ERROR:
        return "ERROR_INTERNET_EXTENDED_ERROR";

    case ERROR_INTERNET_INTERNAL_ERROR:
        return "ERROR_INTERNET_INTERNAL_ERROR";

    case ERROR_INTERNET_INVALID_URL:
        return "ERROR_INTERNET_INVALID_URL";

    case ERROR_INTERNET_UNRECOGNIZED_SCHEME:
        return "ERROR_INTERNET_UNRECOGNIZED_SCHEME";

    case ERROR_INTERNET_NAME_NOT_RESOLVED:
        return "ERROR_INTERNET_NAME_NOT_RESOLVED";

    case ERROR_INTERNET_PROTOCOL_NOT_FOUND:
        return "ERROR_INTERNET_PROTOCOL_NOT_FOUND";

    case ERROR_INTERNET_INVALID_OPTION:
        return "ERROR_INTERNET_INVALID_OPTION";

    case ERROR_FTP_TRANSFER_IN_PROGRESS:
        return "ERROR_FTP_TRANSFER_IN_PROGRESS";

    case ERROR_FTP_CONNECTED:
        return "ERROR_FTP_CONNECTED";

    case ERROR_FTP_DROPPED:
        return "ERROR_FTP_DROPPED";

    case ERROR_GOPHER_PROTOCOL_ERROR:
        return "ERROR_GOPHER_PROTOCOL_ERROR";

    case ERROR_GOPHER_NOT_FILE:
        return "ERROR_GOPHER_NOT_FILE";

    case ERROR_GOPHER_DATA_ERROR:
        return "ERROR_GOPHER_DATA_ERROR";

    case ERROR_GOPHER_END_OF_DATA:
        return "ERROR_GOPHER_END_OF_DATA";

    case ERROR_GOPHER_INVALID_LOCATOR:
        return "ERROR_GOPHER_INVALID_LOCATOR";

    case ERROR_GOPHER_INCORRECT_LOCATOR_TYPE:
        return "ERROR_GOPHER_INCORRECT_LOCATOR_TYPE";

    case ERROR_GOPHER_NOT_GOPHER_PLUS:
        return "ERROR_GOPHER_NOT_GOPHER_PLUS";

    case ERROR_GOPHER_ATTRIBUTE_NOT_FOUND:
        return "ERROR_GOPHER_ATTRIBUTE_NOT_FOUND";

    case ERROR_GOPHER_UNKNOWN_LOCATOR:
        return "ERROR_GOPHER_UNKNOWN_LOCATOR";

    case ERROR_HTTP_HEADER_NOT_FOUND:
        return "ERROR_HTTP_HEADER_NOT_FOUND";

    case ERROR_HTTP_DOWNLEVEL_SERVER:
        return "ERROR_HTTP_DOWNLEVEL_SERVER";

    case ERROR_HTTP_INVALID_SERVER_RESPONSE:
        return "ERROR_HTTP_INVALID_SERVER_RESPONSE";

    case WSAEINTR:
        return "WSAEINTR";

    case WSAEBADF:
        return "WSAEBADF";

    case WSAEACCES:
        return "WSAEACCES";

    case WSAEFAULT:
        return "WSAEFAULT";

    case WSAEINVAL:
        return "WSAEINVAL";

    case WSAEMFILE:
        return "WSAEMFILE";

    case WSAEWOULDBLOCK:
        return "WSAEWOULDBLOCK";

    case WSAEINPROGRESS:
        return "WSAEINPROGRESS";

    case WSAEALREADY:
        return "WSAEALREADY";

    case WSAENOTSOCK:
        return "WSAENOTSOCK";

    case WSAEDESTADDRREQ:
        return "WSAEDESTADDRREQ";

    case WSAEMSGSIZE:
        return "WSAEMSGSIZE";

    case WSAEPROTOTYPE:
        return "WSAEPROTOTYPE";

    case WSAENOPROTOOPT:
        return "WSAENOPROTOOPT";

    case WSAEPROTONOSUPPORT:
        return "WSAEPROTONOSUPPORT";

    case WSAESOCKTNOSUPPORT:
        return "WSAESOCKTNOSUPPORT";

    case WSAEOPNOTSUPP:
        return "WSAEOPNOTSUPP";

    case WSAEPFNOSUPPORT:
        return "WSAEPFNOSUPPORT";

    case WSAEAFNOSUPPORT:
        return "WSAEAFNOSUPPORT";

    case WSAEADDRINUSE:
        return "WSAEADDRINUSE";

    case WSAEADDRNOTAVAIL:
        return "WSAEADDRNOTAVAIL";

    case WSAENETDOWN:
        return "WSAENETDOWN";

    case WSAENETUNREACH:
        return "WSAENETUNREACH";

    case WSAENETRESET:
        return "WSAENETRESET";

    case WSAECONNABORTED:
        return "WSAECONNABORTED";

    case WSAECONNRESET:
        return "WSAECONNRESET";

    case WSAENOBUFS:
        return "WSAENOBUFS";

    case WSAEISCONN:
        return "WSAEISCONN";

    case WSAENOTCONN:
        return "WSAENOTCONN";

    case WSAESHUTDOWN:
        return "WSAESHUTDOWN";

    case WSAETOOMANYREFS:
        return "WSAETOOMANYREFS";

    case WSAETIMEDOUT:
        return "WSAETIMEDOUT";

    case WSAECONNREFUSED:
        return "WSAECONNREFUSED";

    case WSAELOOP:
        return "WSAELOOP";

    case WSAENAMETOOLONG:
        return "WSAENAMETOOLONG";

    case WSAEHOSTDOWN:
        return "WSAEHOSTDOWN";

    case WSAEHOSTUNREACH:
        return "WSAEHOSTUNREACH";

    case WSAENOTEMPTY:
        return "WSAENOTEMPTY";

    case WSAEPROCLIM:
        return "WSAEPROCLIM";

    case WSAEUSERS:
        return "WSAEUSERS";

    case WSAEDQUOT:
        return "WSAEDQUOT";

    case WSAESTALE:
        return "WSAESTALE";

    case WSAEREMOTE:
        return "WSAEREMOTE";

    case WSAEDISCON:
        return "WSAEDISCON";

    case WSASYSNOTREADY:
        return "WSASYSNOTREADY";

    case WSAVERNOTSUPPORTED:
        return "WSAVERNOTSUPPORTED";

    case WSANOTINITIALISED:
        return "WSANOTINITIALISED";

    case WSAHOST_NOT_FOUND:
        return "WSAHOST_NOT_FOUND";

    case WSATRY_AGAIN:
        return "WSATRY_AGAIN";

    case WSANO_RECOVERY:
        return "WSANO_RECOVERY";

    case WSANO_DATA:
        return "WSANO_DATA";

    default:
        return "???";
    }
}

void get_last_internet_error() {

    DWORD bufLength;
    char buffer[256];
    DWORD category;

    bufLength = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &bufLength)) {
        printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
        if (bufLength != 0) {
            printf("Text = \"%s\"\n", buffer);
        }
        if (strlen(buffer) != bufLength) {
            printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                    bufLength,
                    strlen(buffer)
                    );
        }
    } else {

        LPSTR errbuf;

        printf("InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        if ((errbuf = malloc(bufLength)) == NULL) {
            printf("error: get_last_internet_error: malloc(%d) failed\n", bufLength);
            return;
        }
        if (InternetGetLastResponseInfo(&category, errbuf, &bufLength)) {
            printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
            if (bufLength != 0) {
                printf("Text = \"%s\"\n", errbuf);
            }
            if (strlen(buffer) != bufLength) {
                printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                        bufLength,
                        strlen(buffer)
                        );
            }
        } else {
            printf("error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        }
        free(errbuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\cernprox\cernprox.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cernprox.c

Abstract:

    Tests CERN proxy support

Author:

    Richard L Firth (rfirth) 28-Jun-1995

Revision History:

    28-Jun-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <wininet.h>
#include <winsock.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void my_callback(DWORD, DWORD, LPVOID, DWORD);
void default_url_test(void);
void open_urls(LPSTR*, int);
void get_url_data(HINTERNET);
void ftp_find(HINTERNET);
void gopher_find(HINTERNET);
void read_data(HINTERNET);
void print_error(char*, char*, ...);
char* map_error(DWORD);
void get_last_internet_error(void);

//
// data
//

BOOL Verbose = FALSE;
HINTERNET InternetHandle = NULL;
INTERNET_STATUS_CALLBACK PreviousCallback;
LPSTR default_urls[] = {

    //
    // WEB
    //

    "http://www.microsoft.com",
    "http://www.microsoft.com/pages/misc/whatsnew.htm",

    //
    // gopher
    //

    "gopher://gopher.microsoft.com",
    "gopher://gopher.microsoft.com/11/msft/",
    "gopher://gopher.microsoft.com/00\\welcome.txt",
    "gopher://gopher.tc.umn.edu/11Information%20About%20Gopher%09%09%2B",
    "gopher://spinaltap.micro.umn.edu/11/computer",
    "gopher://mudhoney.micro.umn.edu:4325/7",
    "gopher://mudhoney.micro.umn.edu:4325/7%09gopher",
    "gopher://spinaltap.micro.umn.edu/7mindex:lotsoplaces%09gopher%09%2b",

    //
    // FTP
    //

    "ftp://ftp.microsoft.com",
    "ftp://ftp.microsoft.com/MSNBRO.TXT",
    "ftp://ftp.microsoft.com/Services/"
};

#define NUMBER_OF_DEFAULT_URLS  (sizeof(default_urls)/sizeof(default_urls[0]))

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    LPSTR urls[64];
    int numberOfUrls = 0;
    BOOL fCallback = FALSE;
    INTERNET_PORT proxyPort = 0;
    LPSTR proxy = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case 'c':
                fCallback = TRUE;
                break;

            case 'p':
                proxyPort = (INTERNET_PORT)atoi(++*argv);
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (proxy == NULL) {
            proxy = *argv;
        } else {
            if (numberOfUrls == sizeof(urls)/sizeof(urls[0]) - 1) {
                break;
            }
            urls[numberOfUrls++] = *argv;
        }
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    //
    // let's have a status callback
    //

    if (fCallback) {
        PreviousCallback = InternetSetStatusCallback(my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    //
    // open gateway
    //

    InternetHandle = InternetOpen("cernprox",
                                  CERN_PROXY_INTERNET_ACCESS,
                                  proxy,
                                  proxyPort,
                                  0
                                  );
    if (InternetHandle == NULL) {
        printf("error: cernprox: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    if (numberOfUrls == 0) {
        default_url_test();
    } else {
        open_urls(urls, numberOfUrls);
    }

    ok = InternetCloseHandle(InternetHandle);
    if (!ok) {
        printf("error: cernprox: InternetClose(InternetHandle) returns %d\n", GetLastError());
        exit(1);
    } else {
        InternetHandle = NULL;
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: cernprox [-c] [-v] <proxy> [-p#] [url]*\n"
           "where:  -c = enable status call-backs\n"
           "        -p = port for CERN proxy\n"
           "        -v = Verbose mode\n"
           "     proxy = CERN proxy server\n"
           "       url = one or more URLs to open\n"
           );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (InternetHandle != NULL) {
        printf("closing Internet handle %x\n", InternetHandle);
        if (!InternetCloseHandle(InternetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle()");
        }
    }
}

VOID
my_callback(
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    default:
        type$ = "???";
        break;
    }
    printf("callback: %s ", type$);
    if (Info) {
        printf(Info);
    }
    putchar('\n');
}

void default_url_test() {
    open_urls(default_urls, NUMBER_OF_DEFAULT_URLS);
}

void open_urls(LPSTR* purls, int nurls) {

    HINTERNET handle;

    while (nurls--) {
        printf("\nopening URL \"%s\"\n\n", *purls);
        handle = InternetOpenUrl(InternetHandle,
                                 *purls,
                                 NULL,
                                 0,
                                 0,
                                 0
                                 );
        if (handle == NULL) {
            print_error("open_urls", "InternetOpenUrl(%s)", *purls);
        } else {
            get_url_data(handle);
        }
        ++purls;
    }
}

void get_url_data(HINTERNET handle) {

    DWORD handleType;
    DWORD handleTypeLen;

    handleTypeLen = sizeof(handleType);
    if (InternetQueryOption(handle,
                            INTERNET_OPTION_HANDLE_TYPE,
                            (LPVOID)&handleType,
                            &handleTypeLen
                            )) {

        if (handleType != INTERNET_HANDLE_TYPE_HTTP_REQUEST) {
            printf("error: get_url_data: handle type %d returned, should be %d\n",
                    handleType,
                    INTERNET_HANDLE_TYPE_HTTP_REQUEST
                    );
        }

        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            printf("error: get_url_data: HANDLE_TYPE_INTERNET?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_FTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_GOPHER?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_HTTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            ftp_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            gopher_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
        case INTERNET_HANDLE_TYPE_FTP_FILE:
        case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            read_data(handle);
            break;

        default:
            printf("error: get_url_data: handleType == %d?\n", handleType);
            break;
        }
        if (!InternetCloseHandle(handle)) {
            print_error("get_url_data", "InternetCloseHandle()");
        }
    } else {
        print_error("get_url_data", "InternetQueryOption()");
    }
}

void ftp_find(HINTERNET handle) {

    WIN32_FIND_DATA ffd;

    while (InternetFindNextFile(handle, (LPVOID)&ffd)) {

        SYSTEMTIME stDbg;

        if (!FileTimeToSystemTime(&ffd.ftLastWriteTime, &stDbg)) {
            printf("| ftLastWriteTime = ERROR\n");
        }

        printf("%2d-%02d-%04d %2d:%02d:%02d  %15d bytes %-s%-s%-s %s\n",
               stDbg.wMonth, stDbg.wDay, stDbg.wYear,
               stDbg.wHour, stDbg.wMinute, stDbg.wSecond,
               ffd.nFileSizeLow,
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)    ? "Normal    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)  ? "ReadOnly  " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? "Directory " : "",
               ffd.cFileName
               );
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("ftp_find", "InternetFindNextFile()");
    }
}

void gopher_find(HINTERNET handle) {

    GOPHER_FIND_DATA data;
    int i;

    i = 0;
    while (InternetFindNextFile(handle, (LPVOID)&data)) {

        LPGOPHER_FIND_DATA p;
        SYSTEMTIME systemTime;
        char timeBuf[9];
        char sizeBuf[32];

        p = (LPGOPHER_FIND_DATA)&data;
        if ((p->LastModificationTime.dwLowDateTime != 0)
        && (p->LastModificationTime.dwHighDateTime != 0)) {
            FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
            sprintf(timeBuf,
                    "%02d-%02d-%02d",
                    systemTime.wMonth,
                    systemTime.wDay,
                    systemTime.wYear % 100
                    );
            sprintf(sizeBuf, "%d", p->SizeLow);
        } else {
            timeBuf[0] = '\0';
            sizeBuf[0] = '\0';
        }
        printf("%5d %c %7s %10s %8s %s\n",
                i,
                (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                : "\a????",
                sizeBuf,
                timeBuf,
                p->DisplayString
                );
        ++i;
    }
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("gopher_find", "InternetFindNextFile()");
    }
}

void read_data(HINTERNET handle) {

    char buf[1021]; // odd number for fun!
    DWORD nread;

    while (InternetReadFile(handle, buf, sizeof(buf), &nread)) {
        if (!nread) {
            printf("=== end of file ===\n");
            break;
        } else {
            setmode(1, _O_BINARY);
            write(1, buf, nread);
        }
    }
    if (GetLastError() != ERROR_SUCCESS) {
        print_error("read_file", "InternetReadFile()");
    }
}

void print_error(char* func, char* format, ...) {

    va_list argptr;
    char buf[256];
    DWORD error;

    error = GetLastError();
    va_start(argptr, format);
    vsprintf(buf, format, argptr);
    printf("error: %s: %s returns %d [%s]\n", func, buf, error, map_error(error));
    va_end(argptr);
    if (error == ERROR_INTERNET_EXTENDED_ERROR) {
        get_last_internet_error();
    }
}

#define ERROR_CASE(error)  case error: return # error

char* map_error(DWORD error) {
    switch (error) {

    //
    // Windows base errors
    //

    ERROR_CASE(ERROR_SUCCESS);
    ERROR_CASE(ERROR_INVALID_FUNCTION);
    ERROR_CASE(ERROR_FILE_NOT_FOUND);
    ERROR_CASE(ERROR_PATH_NOT_FOUND);
    ERROR_CASE(ERROR_ACCESS_DENIED);
    ERROR_CASE(ERROR_INVALID_HANDLE);
    ERROR_CASE(ERROR_NOT_ENOUGH_MEMORY);
    ERROR_CASE(ERROR_NO_MORE_FILES);
    ERROR_CASE(ERROR_INVALID_PASSWORD);
    ERROR_CASE(ERROR_INVALID_PARAMETER);
    ERROR_CASE(ERROR_BUFFER_OVERFLOW);
    ERROR_CASE(ERROR_NO_MORE_SEARCH_HANDLES);
    ERROR_CASE(ERROR_INVALID_TARGET_HANDLE);
    ERROR_CASE(ERROR_CALL_NOT_IMPLEMENTED);
    ERROR_CASE(ERROR_INSUFFICIENT_BUFFER);
    ERROR_CASE(ERROR_INVALID_NAME);
    ERROR_CASE(ERROR_INVALID_LEVEL);
    ERROR_CASE(ERROR_BAD_PATHNAME);
    ERROR_CASE(ERROR_BUSY);
    ERROR_CASE(ERROR_ALREADY_EXISTS);
    ERROR_CASE(ERROR_FILENAME_EXCED_RANGE);
    ERROR_CASE(ERROR_MORE_DATA);
    ERROR_CASE(ERROR_NO_MORE_ITEMS);
    ERROR_CASE(ERROR_INVALID_ADDRESS);
    ERROR_CASE(ERROR_OPERATION_ABORTED);
    ERROR_CASE(RPC_S_INVALID_STRING_BINDING);
    ERROR_CASE(RPC_S_WRONG_KIND_OF_BINDING);
    ERROR_CASE(RPC_S_INVALID_BINDING);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_SUPPORTED);
    ERROR_CASE(RPC_S_INVALID_RPC_PROTSEQ);
    ERROR_CASE(RPC_S_INVALID_STRING_UUID);
    ERROR_CASE(RPC_S_INVALID_ENDPOINT_FORMAT);
    ERROR_CASE(RPC_S_INVALID_NET_ADDR);
    ERROR_CASE(RPC_S_NO_ENDPOINT_FOUND);
    ERROR_CASE(RPC_S_INVALID_TIMEOUT);
    ERROR_CASE(RPC_S_OBJECT_NOT_FOUND);
    ERROR_CASE(RPC_S_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_TYPE_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_ALREADY_LISTENING);
    ERROR_CASE(RPC_S_NO_PROTSEQS_REGISTERED);
    ERROR_CASE(RPC_S_NOT_LISTENING);
    ERROR_CASE(RPC_S_UNKNOWN_MGR_TYPE);
    ERROR_CASE(RPC_S_UNKNOWN_IF);
    ERROR_CASE(RPC_S_NO_BINDINGS);
    ERROR_CASE(RPC_S_NO_PROTSEQS);
    ERROR_CASE(RPC_S_CANT_CREATE_ENDPOINT);
    ERROR_CASE(RPC_S_OUT_OF_RESOURCES);
    ERROR_CASE(RPC_S_SERVER_UNAVAILABLE);
    ERROR_CASE(RPC_S_SERVER_TOO_BUSY);
    ERROR_CASE(RPC_S_INVALID_NETWORK_OPTIONS);
    ERROR_CASE(RPC_S_NO_CALL_ACTIVE);
    ERROR_CASE(RPC_S_CALL_FAILED);
    ERROR_CASE(RPC_S_CALL_FAILED_DNE);
    ERROR_CASE(RPC_S_PROTOCOL_ERROR);
    ERROR_CASE(RPC_S_UNSUPPORTED_TRANS_SYN);
    ERROR_CASE(RPC_S_UNSUPPORTED_TYPE);
    ERROR_CASE(RPC_S_INVALID_TAG);
    ERROR_CASE(RPC_S_INVALID_BOUND);
    ERROR_CASE(RPC_S_NO_ENTRY_NAME);
    ERROR_CASE(RPC_S_INVALID_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UUID_NO_ADDRESS);
    ERROR_CASE(RPC_S_DUPLICATE_ENDPOINT);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_TYPE);
    ERROR_CASE(RPC_S_MAX_CALLS_TOO_SMALL);
    ERROR_CASE(RPC_S_STRING_TOO_LONG);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_FOUND);
    ERROR_CASE(RPC_S_PROCNUM_OUT_OF_RANGE);
    ERROR_CASE(RPC_S_BINDING_HAS_NO_AUTH);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_SERVICE);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_LEVEL);
    ERROR_CASE(RPC_S_INVALID_AUTH_IDENTITY);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    ERROR_CASE(EPT_S_INVALID_ENTRY);
    ERROR_CASE(EPT_S_CANT_PERFORM_OP);
    ERROR_CASE(EPT_S_NOT_REGISTERED);
    ERROR_CASE(RPC_S_NOTHING_TO_EXPORT);
    ERROR_CASE(RPC_S_INCOMPLETE_NAME);
    ERROR_CASE(RPC_S_INVALID_VERS_OPTION);
    ERROR_CASE(RPC_S_NO_MORE_MEMBERS);
    ERROR_CASE(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    ERROR_CASE(RPC_S_INTERFACE_NOT_FOUND);
    ERROR_CASE(RPC_S_ENTRY_ALREADY_EXISTS);
    ERROR_CASE(RPC_S_ENTRY_NOT_FOUND);
    ERROR_CASE(RPC_S_NAME_SERVICE_UNAVAILABLE);
    ERROR_CASE(RPC_S_INVALID_NAF_ID);
    ERROR_CASE(RPC_S_CANNOT_SUPPORT);
    ERROR_CASE(RPC_S_NO_CONTEXT_AVAILABLE);
    ERROR_CASE(RPC_S_INTERNAL_ERROR);
    ERROR_CASE(RPC_S_ZERO_DIVIDE);
    ERROR_CASE(RPC_S_ADDRESS_ERROR);
    ERROR_CASE(RPC_S_FP_DIV_ZERO);
    ERROR_CASE(RPC_S_FP_UNDERFLOW);
    ERROR_CASE(RPC_S_FP_OVERFLOW);
    ERROR_CASE(RPC_X_NO_MORE_ENTRIES);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    ERROR_CASE(RPC_X_SS_IN_NULL_CONTEXT);
    ERROR_CASE(RPC_X_SS_CONTEXT_DAMAGED);
    ERROR_CASE(RPC_X_SS_HANDLES_MISMATCH);
    ERROR_CASE(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    ERROR_CASE(RPC_X_NULL_REF_POINTER);
    ERROR_CASE(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    ERROR_CASE(RPC_X_BYTE_COUNT_TOO_SMALL);
    ERROR_CASE(RPC_X_BAD_STUB_DATA);


    //
    // WinInet errors
    //

    ERROR_CASE(ERROR_INTERNET_OUT_OF_HANDLES);
    ERROR_CASE(ERROR_INTERNET_TIMEOUT);
    ERROR_CASE(ERROR_INTERNET_EXTENDED_ERROR);
    ERROR_CASE(ERROR_INTERNET_INTERNAL_ERROR);
    ERROR_CASE(ERROR_INTERNET_INVALID_URL);
    ERROR_CASE(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    ERROR_CASE(ERROR_INTERNET_NAME_NOT_RESOLVED);
    ERROR_CASE(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPTION);
    ERROR_CASE(ERROR_INTERNET_BAD_OPTION_LENGTH);
    ERROR_CASE(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    ERROR_CASE(ERROR_INTERNET_SHUTDOWN);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_USER_NAME);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_PASSWORD);
    ERROR_CASE(ERROR_INTERNET_LOGIN_FAILURE);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPERATION);
    ERROR_CASE(ERROR_INTERNET_OPERATION_CANCELLED);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    ERROR_CASE(ERROR_INTERNET_NOT_LOCAL_HANDLE);
    ERROR_CASE(ERROR_INTERNET_NOT_PROXY_REQUEST);
    ERROR_CASE(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    ERROR_CASE(ERROR_FTP_TRANSFER_IN_PROGRESS);
    ERROR_CASE(ERROR_FTP_CONNECTED);
    ERROR_CASE(ERROR_FTP_DROPPED);
    ERROR_CASE(ERROR_GOPHER_PROTOCOL_ERROR);
    ERROR_CASE(ERROR_GOPHER_NOT_FILE);
    ERROR_CASE(ERROR_GOPHER_DATA_ERROR);
    ERROR_CASE(ERROR_GOPHER_END_OF_DATA);
    ERROR_CASE(ERROR_GOPHER_INVALID_LOCATOR);
    ERROR_CASE(ERROR_GOPHER_INCORRECT_LOCATOR_TYPE);
    ERROR_CASE(ERROR_GOPHER_NOT_GOPHER_PLUS);
    ERROR_CASE(ERROR_GOPHER_ATTRIBUTE_NOT_FOUND);
    ERROR_CASE(ERROR_GOPHER_UNKNOWN_LOCATOR);
    ERROR_CASE(ERROR_HTTP_HEADER_NOT_FOUND);
    ERROR_CASE(ERROR_HTTP_DOWNLEVEL_SERVER);
    ERROR_CASE(ERROR_HTTP_INVALID_SERVER_RESPONSE);


    //
    // Windows sockets errors
    //

    ERROR_CASE(WSAEINTR);
    ERROR_CASE(WSAEBADF);
    ERROR_CASE(WSAEACCES);
    ERROR_CASE(WSAEFAULT);
    ERROR_CASE(WSAEINVAL);
    ERROR_CASE(WSAEMFILE);
    ERROR_CASE(WSAEWOULDBLOCK);
    ERROR_CASE(WSAEINPROGRESS);
    ERROR_CASE(WSAEALREADY);
    ERROR_CASE(WSAENOTSOCK);
    ERROR_CASE(WSAEDESTADDRREQ);
    ERROR_CASE(WSAEMSGSIZE);
    ERROR_CASE(WSAEPROTOTYPE);
    ERROR_CASE(WSAENOPROTOOPT);
    ERROR_CASE(WSAEPROTONOSUPPORT);
    ERROR_CASE(WSAESOCKTNOSUPPORT);
    ERROR_CASE(WSAEOPNOTSUPP);
    ERROR_CASE(WSAEPFNOSUPPORT);
    ERROR_CASE(WSAEAFNOSUPPORT);
    ERROR_CASE(WSAEADDRINUSE);
    ERROR_CASE(WSAEADDRNOTAVAIL);
    ERROR_CASE(WSAENETDOWN);
    ERROR_CASE(WSAENETUNREACH);
    ERROR_CASE(WSAENETRESET);
    ERROR_CASE(WSAECONNABORTED);
    ERROR_CASE(WSAECONNRESET);
    ERROR_CASE(WSAENOBUFS);
    ERROR_CASE(WSAEISCONN);
    ERROR_CASE(WSAENOTCONN);
    ERROR_CASE(WSAESHUTDOWN);
    ERROR_CASE(WSAETOOMANYREFS);
    ERROR_CASE(WSAETIMEDOUT);
    ERROR_CASE(WSAECONNREFUSED);
    ERROR_CASE(WSAELOOP);
    ERROR_CASE(WSAENAMETOOLONG);
    ERROR_CASE(WSAEHOSTDOWN);
    ERROR_CASE(WSAEHOSTUNREACH);
    ERROR_CASE(WSAENOTEMPTY);
    ERROR_CASE(WSAEPROCLIM);
    ERROR_CASE(WSAEUSERS);
    ERROR_CASE(WSAEDQUOT);
    ERROR_CASE(WSAESTALE);
    ERROR_CASE(WSAEREMOTE);
    ERROR_CASE(WSAEDISCON);
    ERROR_CASE(WSASYSNOTREADY);
    ERROR_CASE(WSAVERNOTSUPPORTED);
    ERROR_CASE(WSANOTINITIALISED);
    ERROR_CASE(WSAHOST_NOT_FOUND);
    ERROR_CASE(WSATRY_AGAIN);
    ERROR_CASE(WSANO_RECOVERY);
    ERROR_CASE(WSANO_DATA);

    default:
        return "?";
    }
}

void get_last_internet_error() {

    DWORD bufLength;
    char buffer[256];
    DWORD category;

    bufLength = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &bufLength)) {
        printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
        if (bufLength != 0) {
            printf("Text = \"%s\"\n", buffer);
        }
        if (strlen(buffer) != bufLength) {
            printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                    bufLength,
                    strlen(buffer)
                    );
        }
    } else {

        LPSTR errbuf;

        printf("InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        if ((errbuf = malloc(bufLength)) == NULL) {
            printf("error: get_last_internet_error: malloc(%d) failed\n", bufLength);
            return;
        }
        if (InternetGetLastResponseInfo(&category, errbuf, &bufLength)) {
            printf("InternetGetLastResponseInfo() returns %d bytes\n", bufLength);
            if (bufLength != 0) {
                printf("Text = \"%s\"\n", errbuf);
            }
            if (strlen(buffer) != bufLength) {
                printf("\aerror: get_last_internet_error: InternetGetLastResponseInfo() returns %d bytes; strlen(buffer) = %d\n",
                        bufLength,
                        strlen(buffer)
                        );
            }
        } else {
            printf("error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d (bufLength = %d)\n",
               GetLastError(),
               bufLength
               );
        }
        free(errbuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\contype\contype.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);

BOOL Verbose = FALSE;

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR lpszUrl = NULL;
    HINTERNET hInternet;
    HINTERNET hRequest;
    char buf[256];
    DWORD buflen = sizeof(buf);

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (!lpszUrl) {
            lpszUrl = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    hInternet = InternetOpen("contype", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (!hInternet) {
        print_error("contype()", "InternetOpen()");
        exit(1);
    }
    hRequest = InternetOpenUrl(hInternet, lpszUrl, "Accept: */*", -1, 0, 0);
    if (!hRequest) {
        print_error("contype()", "InternetOpenUrl()");
        exit(1);
    }

    if (!HttpQueryInfo(hRequest, HTTP_QUERY_CONTENT_TYPE, buf, &buflen, NULL)) {
        print_error("contype()", "HttpQueryInfo()");
        exit(1);
    }

    printf("URL \"%s\": Content-Type: \"%s\"\n", lpszUrl, buf);

    InternetCloseHandle(hRequest);
    InternetCloseHandle(hInternet);
    exit(0);
}

void usage() {
    printf("usage: contype\n"
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\tproxy\tproxy.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    tproxy.c

Abstract:

    Test program for Wininet proxy settings

    Contents:

Author:

    Richard L Firth (rfirth) 23-Jul-1996

Revision History:

    23-Jul-1996 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>
#include <malloc.h>
#include <memory.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define NEW_USER_AGENT  "and now for a completely different user-agent"

void _CRTAPI1 main(int, char**);
void usage(void);
void get_proxy_info(HINTERNET);
void set_proxy_info(HINTERNET, LPINTERNET_PROXY_INFO);
void dump_proxy_info(HINTERNET, LPINTERNET_PROXY_INFO);
void get_user_agent(HINTERNET, char*, LPDWORD);
void set_user_agent(HINTERNET, char*);
void refresh_handle(HINTERNET);

BOOL Verbose = FALSE;
DWORD Failures = 0;

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet1;
    HINTERNET hInternet2;
    HINTERNET hInternet3;
    HINTERNET hInternet4;
    INTERNET_PROXY_INFO proxyInfo;
    char proxyBuffer[512];
    DWORD length;
    BOOL ok;
    char uaBuf1[128];
    char uaBuf2[128];
    DWORD uaLen1;
    DWORD uaLen2;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    //
    // get global proxy info
    //

    get_proxy_info(NULL);

    //
    // get & remember it
    //

    length = sizeof(proxyBuffer);
    ok = InternetQueryOption(NULL, INTERNET_OPTION_PROXY, (LPVOID)proxyBuffer, &length);
    if (!ok) {
        print_error("tproxy()", "InternetQueryOption()");
        ++Failures;
    }

    //
    // create handles
    //

    //
    // 1. preconfig
    //

    hInternet1 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, "foo", "bar", 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG) returns %#x\n", hInternet1);
    }
    get_proxy_info(hInternet1);

    //
    // 2. direct
    //

    hInternet2 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_DIRECT, "foo", "bar", 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(DIRECT)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(DIRECT) returns %#x\n", hInternet2);
    }
    get_proxy_info(hInternet2);

    //
    // 3. private proxy
    //

    hInternet3 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PROXY, "foo", "bar", 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PROXY)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PROXY) returns %#x\n", hInternet3);
    }
    get_proxy_info(hInternet3);

    //
    // 4. another preconfig
    //

    hInternet4 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG #2) returns %#x\n", hInternet4);
    }
    get_proxy_info(hInternet4);

    //
    // change global proxy
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "modified.global.proxy";
    proxyInfo.lpszProxyBypass = "modified.global.proxy.bypass.list, *";
    set_proxy_info(NULL, &proxyInfo);

    //
    // make sure global, hInternet1 and hInternet4 all reference same proxy info
    //

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet4);

    //
    // reload global proxy info from registry
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    proxyInfo.lpszProxy = "modified.global.proxy";
    proxyInfo.lpszProxyBypass = "modified.global.proxy.bypass.list, *";
    set_proxy_info(NULL, &proxyInfo);

    //
    // set hInternet2 to use private proxy
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "my.test.proxy";
    proxyInfo.lpszProxyBypass = "www.foo.com www.bar.com";
    set_proxy_info(hInternet2, &proxyInfo);
    get_proxy_info(hInternet2);

    //
    // set hInternet3 to use direct
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
    proxyInfo.lpszProxy = "this.is.a.bogus.proxy";
    proxyInfo.lpszProxyBypass = "this.is.a.bogus.bypass.entry";
    set_proxy_info(hInternet3, &proxyInfo);
    get_proxy_info(hInternet3);

    //
    //
    //

    //
    // get the user-agent
    //

    uaLen1 = sizeof(uaBuf1);
    get_user_agent(hInternet1, uaBuf1, &uaLen1);

    //
    // set the user-agent
    //

    set_user_agent(hInternet1, NEW_USER_AGENT);

    //
    // get it again to make sure its the correct value
    //

    uaLen2 = sizeof(uaBuf2);
    get_user_agent(hInternet1, uaBuf2, &uaLen2);

    //
    // compare 'em
    //

    if (strcmp(uaBuf2, NEW_USER_AGENT)) {
        printf("error: tproxy(): set_user_agent() failed\n");
    }

    //
    // reset global proxy info
    //

    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    proxyInfo.lpszProxy = NULL;
    proxyInfo.lpszProxyBypass = NULL;
    set_proxy_info(NULL, &proxyInfo);

    //
    // make sure global, hInternet1 and hInternet4 all reference same proxy info
    //

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet4);

    //
    // close all handles
    //

    InternetCloseHandle(hInternet1);
    InternetCloseHandle(hInternet2);
    InternetCloseHandle(hInternet3);
    InternetCloseHandle(hInternet4);

    //
    // do the AOL test
    //

    if (Verbose) {
        printf("\nThe AOL Test\n\n");
    }

    if (Verbose) {
        printf("Opening PRECONFIG Internet handle #1\n");
    }
    hInternet1 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet1 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG) returns %#x\n", hInternet1);
    }
    get_proxy_info(hInternet1);

    if (Verbose) {
        printf("Changing global proxy info\n");
    }
    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "my.test.proxy";
    proxyInfo.lpszProxyBypass = "www.foo.com www.bar.com";
    set_proxy_info(NULL, &proxyInfo);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);

    if (Verbose) {
        printf("Opening PRECONFIG Internet handle #2\n");
    }
    hInternet2 = InternetOpen("tproxy", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet2 == NULL) {
        print_error("tproxy()", "InternetOpen(PRECONFIG)");
        ++Failures;
    } else if (Verbose) {
        printf("InternetOpen(PRECONFIG) returns %#x\n", hInternet2);
    }
    get_proxy_info(hInternet2);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    if (Verbose) {
        printf("Changing proxy info on Internet handle #2\n");
    }
    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
    proxyInfo.lpszProxy = "THIS.IS.A.BOGUS.SERVER.LIST";
    proxyInfo.lpszProxyBypass = "THIS.IS.A.BOGUS.BYPASS.LIST";
    set_proxy_info(hInternet2, &proxyInfo);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // refresh handle 2 - shouldn't change
    //

    if (Verbose) {
        printf("Refreshing Internet handle #2\n");
    }
    refresh_handle(hInternet2);

    //
    // refresh the global handle - should refresh global handle & handle 1
    //

    if (Verbose) {
        printf("Refreshing global handle\n");
    }
    refresh_handle(NULL);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // change global proxy info back to registry. Global handle & handle 1
    // proxy info should change
    //

    if (Verbose) {
        printf("Changing global proxy info back to preconfig\n");
    }
    proxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    proxyInfo.lpszProxy = NULL;
    proxyInfo.lpszProxyBypass = NULL;
    set_proxy_info(NULL, &proxyInfo);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // refresh the global handle - should refresh global handle & handle 1
    //

    if (Verbose) {
        printf("Refreshing global handle\n");
    }
    refresh_handle(NULL);

    get_proxy_info(NULL);
    get_proxy_info(hInternet1);
    get_proxy_info(hInternet2);

    //
    // close all handles
    //

    InternetCloseHandle(hInternet1);
    InternetCloseHandle(hInternet2);

    //
    // pass or fail?
    //

    if (Verbose) {
        printf("\nDone.\n");
        if (Failures) {
            printf("Test failed\n");
        } else {
            printf("Test passed\n");
        }
    }
    exit(Failures);
}

void usage() {
    printf("usage: tproxy [-v]\n"
           "where: -v = Verbose mode\n"
           );
    exit(1);
}

void get_proxy_info(HINTERNET hInternet) {

    DWORD length;
    BOOL ok;

    length = 0;
    ok = InternetQueryOption(hInternet, INTERNET_OPTION_PROXY, NULL, &length);
    if (ok) {
        printf("error: get_proxy_info(%#x): InternetQueryOption() w/ no buffer succeeds\n", hInternet);
        ++Failures;
    } else {

        LPVOID buf = malloc(length);

        if (Verbose) {
            printf("get_proxy_info(%#x): %d bytes required for proxy info buffer\n", hInternet, length);
        }
        memset(buf, 0x99, length);
        ok = InternetQueryOption(hInternet, INTERNET_OPTION_PROXY, buf, &length);
        if (!ok) {
            print_error("get_proxy_info()", "InternetQueryOption()");
            ++Failures;
        } else if (Verbose) {
            dump_proxy_info(hInternet, (LPINTERNET_PROXY_INFO)buf);
        }
        free(buf);
    }
}

void set_proxy_info(HINTERNET hInternet, LPINTERNET_PROXY_INFO ProxyInfo) {

    BOOL ok;

    ok = InternetSetOption(hInternet, INTERNET_OPTION_PROXY, (LPVOID)ProxyInfo, sizeof(*ProxyInfo));
    if (!ok) {
        print_error("set_proxy_info()", "InternetSetOption()");
        ++Failures;
    }
}

void dump_proxy_info(HINTERNET hInternet, LPINTERNET_PROXY_INFO ProxyInfo) {
    printf("INTERNET_PROXY_INFO for handle %#x:\n"
           "\tAccess Type   : %s\n"
           "\tProxy Server  : \"%s\"\n"
           "\tProxy Bypass  : \"%s\"\n"
           "\n",
           hInternet,
           (ProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG)
                ? "PRECONFIG"
                : (ProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
                    ? "DIRECT"
                    : (ProxyInfo->dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                        ? "PROXY"
                        : "?",
           (ProxyInfo->lpszProxy != NULL) ? ProxyInfo->lpszProxy : "",
           (ProxyInfo->lpszProxyBypass != NULL) ? ProxyInfo->lpszProxyBypass : ""
           );
}

void get_user_agent(HINTERNET hInternet, char* Buffer, LPDWORD lpdwLen) {

    DWORD length;
    BOOL ok;

    length = 0;
    ok = InternetQueryOption(hInternet, INTERNET_OPTION_USER_AGENT, NULL, &length);
    if (ok) {
        printf("error: get_user_agent(%#x): InternetQueryOption() w/ no buffer succeeds\n", hInternet);
        ++Failures;
    } else if (length <= *lpdwLen) {
        if (Verbose) {
            printf("get_user_agent(%#x): %d bytes required for proxy info buffer\n", hInternet, length);
        }
        memset(Buffer, 0x99, *lpdwLen);
        ok = InternetQueryOption(hInternet, INTERNET_OPTION_USER_AGENT, Buffer, &length);
        if (!ok) {
            print_error("get_proxy_info()", "InternetQueryOption()");
            ++Failures;
        } else {
            if (Buffer[length] != '\0') {
                printf("error: InternetQueryOption(USER_AGENT) returns incorrectly terminated string\n");
                ++Failures;
            }
            *lpdwLen = length;
            if (Verbose) {
                printf("User-Agent for %#x = \"%s\" (%d)\n", hInternet, Buffer, length);
            }
        }
    } else {
        printf("error: get_user_agent(%#x): not enough buffer (%d)\n", hInternet, *lpdwLen);
        ++Failures;
    }
}

void set_user_agent(HINTERNET hInternet, char* String) {

    BOOL ok;

    ok = InternetSetOption(hInternet, INTERNET_OPTION_USER_AGENT, (LPVOID)String, strlen(String) + 1);
    if (!ok) {
        print_error("set_user_agent()", "InternetSetOption()");
        ++Failures;
    }
}

void refresh_handle(HINTERNET hInternet) {

    BOOL ok;
    DWORD zero;

    zero = 0;
    ok = InternetSetOption(hInternet, INTERNET_OPTION_REFRESH, &zero, sizeof(zero));
    if (!ok) {
        print_error("refresh_handle()", "InternetSetOption()");
        ++Failures;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\thh\thh.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thh.c

Abstract:

    Test program for handle hierarchy

Author:

    Richard L Firth (rfirth) 12-Jan-1996

Revision History:

    12-Jan-1996 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define OPEN_CONTEXT_VALUE      0x11
#define CONNECT_CONTEXT_VALUE   0x22

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);

BOOL Verbose = FALSE;
DWORD AsyncResult;
DWORD AsyncError;


void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet;
    HINTERNET hConnect;
    HINTERNET hRequest;
    BOOL callbacks = FALSE;
    INTERNET_STATUS_CALLBACK cbres;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'c':
                callbacks = TRUE;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    hInternet = InternetOpen("Handle Hierarchy Test Program (thh)",
                             LOCAL_INTERNET_ACCESS,
                             NULL,
                             0,
                             0
                             );
    if (!hInternet) {
        print_error("thh()", "InternetOpen()");
        exit(1);
    }

    if (Verbose) {
        printf("InternetOpen() returns handle %x\n", hInternet);
    }

    if (callbacks) {
        if (Verbose) {
            printf("installing callback\n");
        }

        cbres = InternetSetStatusCallback(hInternet, my_callback);
        if (cbres == INTERNET_INVALID_STATUS_CALLBACK) {
            print_error("thh()", "InternetSetStatusCallback()");
            exit(1);
        } else if (Verbose) {
            printf("previous callback = %x\n", cbres);
        }
    }

    if (Verbose) {
        printf("calling InternetConnect()...\n");
    }

    hConnect = InternetConnect(hInternet,
                               "foo.bar.com",
                               0,
                               "albert einstein",
                               "e=mc2",
                               INTERNET_SERVICE_HTTP,
                               0,
                               callbacks ? CONNECT_CONTEXT_VALUE : 0
                               );
    if (!hInternet) {
        print_error("thh()", "InternetConnect()");
        exit(1);
    } else if (Verbose) {
        printf("InternetConnect() returns handle %x\n", hConnect);
    }

    if (Verbose) {
        printf("calling HttpOpenRequest()...\n");
    }

    hRequest = HttpOpenRequest(hConnect,
                               NULL,    // verb
                               NULL,    // object
                               NULL,    // version
                               NULL,    // referrer
                               NULL,    // accept types
                               0,       // flags
                               callbacks ? OPEN_CONTEXT_VALUE : 0
                               );
    if (!hRequest) {
        print_error("thh()", "HttpOpenRequest()");
        exit(1);
    } else if (Verbose) {
        printf("HttpOpenRequest() returns handle %x\n", hRequest);
    }

    if (Verbose) {
        printf("closing InternetOpen() handle %x\n", hInternet);
    }

    if (InternetCloseHandle(hInternet)) {
        if (Verbose) {
            printf("closed Internet handle %x OK\n", hInternet);
        }
    } else {
        print_error("thh()", "InternetCloseHandle()");
        exit(1);
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: thh [-c] [-v]\n"
           "where: -c = use callbacks\n"
           "       -v = verbose mode\n"
           );
    exit(1);
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: H=%x [C=%x [%s]] %s ",
                Handle,
                Context,
                (Context == CONNECT_CONTEXT_VALUE)
                    ? "Connect"
                    : (Context == OPEN_CONTEXT_VALUE)
                        ? "Open   "
                        : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {

                DWORD handleType;
                DWORD handleTypeSize = sizeof(handleType);

                if (InternetQueryOption(*(LPHINTERNET)Info,
                                        INTERNET_OPTION_HANDLE_TYPE,
                                        (LPVOID)&handleType,
                                        &handleTypeSize
                                        )) {
                    switch (handleType) {
                    case INTERNET_HANDLE_TYPE_INTERNET:
                        type$ = "Internet";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_FTP:
                        type$ = "FTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
                        type$ = "Gopher Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
                        type$ = "HTTP Connect";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND:
                        type$ = "FTP Find";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
                        type$ = "FTP Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE:
                        type$ = "FTP File";
                        break;

                    case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
                        type$ = "FTP File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND:
                        type$ = "Gopher Find";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
                        type$ = "Gopher Find HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE:
                        type$ = "Gopher File";
                        break;

                    case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
                        type$ = "Gopher File HTML";
                        break;

                    case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
                        type$ = "HTTP Request";
                        break;

                    default:
                        type$ = "???";
                        break;
                    }
                } else {
                    type$ = "<error>";
                }
                printf("%x [%s]", *(LPHINTERNET)Info, type$);
            } else if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {

                //
                // nothing
                //

            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\exts\winidbg.cxx ===
/*++

Module Name:

    winidbg.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  13-May-1996

Revision History:

     13-May-1996     jroberts

        Created this module.
    Mazhar Mohammed (mazharm) 3-20-97 - changed it all for async RPC,
                                                added some cool stuff
                                                single dll for ntsd and kd

	Feroze Daud ( ferozed ) 1/21/98 - changed for Wininet.

--*/

#include <stddef.h>
#include <limits.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>
#include <windows.h>
#include <stddef.h>
#include "wdbgexts.h"

#define private public
#define protected public

//#include <wininetp.h>
#include <wininetp.h>


#include "local.hxx"

WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ProcessHandle = 0;
BOOL fKD = 0;

#define ALLOC_SIZE 500
#define MAX_ARGS 4

// #include "rpcexts.hxx"

//
// stuff not common to kernel-mode and user-mode DLLs
//

void do_fsm (
			DWORD fsm );
#if INET_DEBUG
LPSTR
MapType(
    FSM_TYPE m_Type
    );
#endif // INET_DEBUG

LPSTR
MapState(
    DWORD m_Type
    );


#define CASE_OF(x) case x : return #x; break;

// VOID do_trans( DWORD dwAddr );

DECLARE_API( fsm );
DECLARE_API( ho );
DECLARE_API( iho );
DECLARE_API( icho );
DECLARE_API( hrho );
DECLARE_API( lste );
DECLARE_API( serialist );

DECLARE_API(badproxylste);
void do_BAD_PROXY_LIST_ENTRY( DWORD addr ); 

DECLARE_API(badproxylst);
void do_BAD_PROXY_LIST( DWORD addr ); 

DECLARE_API(proxybyplste);
void do_PROXY_BYPASS_LIST_ENTRY( DWORD addr ); 

DECLARE_API(proxybyplst);
void do_PROXY_BYPASS_LIST( DWORD addr ); 

DECLARE_API(proxysrvlste);
void do_PROXY_SERVER_LIST_ENTRY( DWORD addr ); 

DECLARE_API(proxysrvlst);
void do_PROXY_SERVER_LIST( DWORD addr ); 

DECLARE_API(ICSecureSocket);
void do_ICSecureSocket( DWORD addr ); 

#define OFFSET( x, y ) \
				((DWORD)addr + offsetof(x, y)) 


// define our own operators new and delete, so that we do not have to include the crt

void * _CRTAPI1
::operator new(unsigned int dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void _CRTAPI1
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

BOOL
GetData(IN DWORD dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (fKD == 0)
        {
        return ReadProcessMemory(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = d_ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
        }

    return TRUE;
}

#define MAX_MESSAGE_BLOCK_SIZE 1024
#define BLOCK_SIZE 16
/*
RPC_CHAR *
ReadProcessRpcChar(
    unsigned short * Address
    )
{
    DWORD dwAddr = (DWORD) Address;

    char       block[BLOCK_SIZE];
    RPC_CHAR   *RpcBlock  = (RPC_CHAR *)&block;
    char *string_block = new char[MAX_MESSAGE_BLOCK_SIZE];
    RPC_CHAR   *RpcString = (RPC_CHAR *)string_block;
    int  length = 0;
    int  i      = 0;
    BOOL b;
    BOOL end    = FALSE;

    if (dwAddr == NULL) {
        return (L'\0');
    }

    for (length = 0; length < MAX_MESSAGE_BLOCK_SIZE/2; ) {
        b = GetData( dwAddr, &block, BLOCK_SIZE, NULL);
        if (b == FALSE) {
            d_printf("couldn't read address %x\n", dwAddr);
            return (L'\0');
        }
        for (i = 0; i < BLOCK_SIZE/2; i++) {
            if (RpcBlock[i] == L'\0') {
                end = TRUE;
            }
            RpcString[length] = RpcBlock[i];
            length++;
        }
        if (end == TRUE) {
            break;
        }
        dwAddr += BLOCK_SIZE;
    }
    return (RpcString);
}
*/

long
myatol(char *string)
{
    int  i         = 0;
    BOOL minus     = FALSE;
    long number    = 0;
    long tmpnumber = 0 ;
    long chknum;

    if (string[0] == '-') {
        minus = TRUE;
        i++;
    }
    else
    if (string[0] == '+') {
        i++;
    }
    for (; string[i] != '\0'; i++) {
        if ((string[i] >= '0')&&(string[i] <= '9')) {
            tmpnumber = string[i] - '0';
            if (number != 0) {
                chknum = LONG_MAX/number;
            }
            if (chknum > 11) {
                number = number*10 + tmpnumber;
            }
        }
        else
            return 0;
    }
    if (minus == TRUE) {
        number = 0 - number;
    }
    return number;
}

PCHAR
MapSymbol(DWORD dwAddr)
{
    static CHAR Name[256];
    DWORD Displacement;

    d_GetSymbol((LPVOID)dwAddr, (UCHAR *)Name, &Displacement);
    strcat(Name, "+");
#if 0
	// nuked due to build break
    PCHAR p = strchr(Name, '\0');
    _ltoa(Displacement, p, 16);
#endif
    return(Name);
}

// checks the if the uuid is null, prints the uuid
/*
void
PrintUuid(UUID *Uuid)
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;
    if (   (Vector[0] == 0)
         && (Vector[1] == 0)
         && (Vector[2] == 0)
         && (Vector[3] == 0))
    {
        d_printf("(Null Uuid)");
    }
    else
    {
        d_printf("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                       Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1],
                       Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5],
                       Uuid->Data4[6], Uuid->Data4[7] );
    }
    return;
}
*/

/*
DWORD OSF_CCONNECTION_SIZE = sizeof(OSF_CCONNECTION);
DWORD OSF_SCONNECTION_SIZE = sizeof(OSF_SCONNECTION);
DWORD OSF_ADDRESS_SIZE = sizeof(OSF_ADDRESS);
DWORD DG_ADDRESS_SIZE = sizeof(DG_ADDRESS);
*/

VOID
do_sizes(
    )
{
	d_printf("BUGBUG .... Add stuff here \n");
   // d_printf("sizeof(ASSOCIATION_HANDLE) - 0x%x\n", sizeof(ASSOCIATION_HANDLE));
}

DECLARE_API( sizes )
{
   INIT_DPRINTF();
   do_sizes();
}

char *
GetError (DWORD dwError)
{
    DWORD   dwFlag = FORMAT_MESSAGE_FROM_SYSTEM;
    static CHAR   szErrorMessage[1024];
    static HANDLE  hSource = NULL;

    if ((dwError >= 2100) && (dwError < 6000))
    {
        if (hSource == NULL)
            {
            hSource = LoadLibrary("netmsg.dll");
            }

        if (hSource == NULL)
        {
            sprintf (szErrorMessage,
                      "Unable to load netmsg.dll. Error %d occured.\n",
                      dwError);
            return(szErrorMessage);
        }

        dwFlag = FORMAT_MESSAGE_FROM_HMODULE;
    }

    if (!FormatMessage (dwFlag,
                        hSource,
                        dwError,
                        0,
                        szErrorMessage,
                        1024,
                        NULL))
       {
        sprintf (szErrorMessage,
                  "An unknown error occured: 0x%x \n",
                  dwError);
       }

    return(szErrorMessage);
}

VOID
do_error (
    DWORD dwAddr
    )
{
    d_printf("0x%x: %s\n", dwAddr, GetError(dwAddr));
}


DECLARE_API( help )
{
    INIT_DPRINTF();

    if (lpArgumentString[0] == '\0') {
        d_printf("\n"
                "wininext help:\n\n"
                "\n"
                "!obj      <address>  - Dumps an RPC object \n"
                "\n"
                "!sizes - Prints sizes of the data structures\n"
                "!error - Translates and error value into the error message\n"
                "!symbol    (<address>|<symbol name>) - Returns symbol name/address\n"
				"!fsm		<address> - Dumps the CFsm object\n"
				"!ho		<address> - Dumps the HANDLE_OBJECT object\n"
				"!iho		<address> - Dumps the INTERNET_HANDLE_OBJECT object\n"
				"!icho		<address> - Dumps the INTERNET_CONNECT_HANDLE_OBJECT object\n"
				"!hrho		<address> - Dumps the /////////////////////////////////////////////////
//
//	HEADER_STRING structure
//
/////////////////////////////////////////////////

DECLARE_API( HEADER_STRING )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_HEADER_STRING(dwAddr);
}

VOID
do_HEADER_STRING(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HEADER_STRING ) ];

	HEADER_STRING * obj  = (HEADER_STRING *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HEADER_STRING ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HEADER_STRING at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HEADER_STRING @ 0x%x \n\n", addr);

	//DWORD  m_Hash
	d_printf("\tDWORD m_Hash %d\n", obj -> m_Hash);

	//LPSTR  value
	d_printf("\tLPSTR value %s\n", obj -> value);



	d_printf("\n");

}  // HEADER_STRING



/////////////////////////////////////////////////
//
//	HTTP_HEADERS structure
//
/////////////////////////////////////////////////

DECLARE_API( HTTP_HEADERS )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_HTTP_HEADERS(dwAddr);
}

VOID
do_HTTP_HEADERS(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HTTP_HEADERS ) ];

	HTTP_HEADERS * obj  = (HTTP_HEADERS *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HTTP_HEADERS ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HTTP_HEADERS at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HTTP_HEADERS @ 0x%x \n\n", addr);

#ifndef STRESS_BUG_DEBUG
#endif
#if INET_DEBUG
	//DWORD  _Signature
	d_printf("\tDWORD _Signature %d\n", obj -> _Signature);

#endif
	//HEADER_STRING * _lpHeaders
	d_printf("\tHEADER_STRING * _lpHeaders 0x%x\n", obj -> _lpHeaders);

	//DWORD  _TotalSlots
	d_printf("\tDWORD _TotalSlots %d\n", obj -> _TotalSlots);

	//DWORD  _NextOpenSlot
	d_printf("\tDWORD _NextOpenSlot %d\n", obj -> _NextOpenSlot);

	//DWORD  _FreeSlots
	d_printf("\tDWORD _FreeSlots %d\n", obj -> _FreeSlots);

	//DWORD  _HeadersLength
	d_printf("\tDWORD _HeadersLength %d\n", obj -> _HeadersLength);

	//BOOL  _IsRequestHeaders
	d_printf("\tBOOL _IsRequestHeaders %d\n", obj -> _IsRequestHeaders);

	//LPSTR  _lpszVerb
	d_printf("\tLPSTR _lpszVerb %s\n", obj -> _lpszVerb);

	//DWORD  _dwVerbLength
	d_printf("\tDWORD _dwVerbLength %d\n", obj -> _dwVerbLength);

	//LPSTR  _lpszObjectName
	d_printf("\tLPSTR _lpszObjectName %s\n", obj -> _lpszObjectName);

	//DWORD  _dwObjectNameLength
	d_printf("\tDWORD _dwObjectNameLength %d\n", obj -> _dwObjectNameLength);

	//LPSTR  _lpszVersion
	d_printf("\tLPSTR _lpszVersion %s\n", obj -> _lpszVersion);

	//DWORD  _dwVersionLength
	d_printf("\tDWORD _dwVersionLength %d\n", obj -> _dwVersionLength);

	//DWORD  _RequestVersionMajor
	d_printf("\tDWORD _RequestVersionMajor %d\n", obj -> _RequestVersionMajor);

	//DWORD  _RequestVersionMinor
	d_printf("\tDWORD _RequestVersionMinor %d\n", obj -> _RequestVersionMinor);

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);

#ifdef STRESS_BUG_DEBUG
	//DWORD  _dwCritCount
	d_printf("\tDWORD _dwCritCount %d\n", obj -> _dwCritCount);

#endif
#ifdef STRESS_BUG_DEBUG
#endif
#if INET_DEBUG
#endif
#if INET_DEBUG
#endif
#ifdef STRESS_BUG_DEBUG
#endif
#ifdef STRESS_BUG_DEBUG
#endif
#ifdef COMPRESSED_HEADERS
#endif //COMPRESSED_HEADERS


	d_printf("\n");

}  // HTTP_HEADERS



/////////////////////////////////////////////////
//
//	HTTP_REQUEST_HANDLE_OBJECT structure
//
/////////////////////////////////////////////////

DECLARE_API( HTTP_REQUEST_HANDLE_OBJECT )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_HTTP_REQUEST_HANDLE_OBJECT(dwAddr);
}

VOID
do_HTTP_REQUEST_HANDLE_OBJECT(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HTTP_REQUEST_HANDLE_OBJECT ) ];

	HTTP_REQUEST_HANDLE_OBJECT * obj  = (HTTP_REQUEST_HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HTTP_REQUEST_HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HTTP_REQUEST_HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HTTP_REQUEST_HANDLE_OBJECT @ 0x%x \n\n", addr);

	//LIST_ENTRY  m_PipelineList
	d_printf("\tLIST_ENTRY (*) m_PipelineList 0x%x\n", OFFSET( HTTP_REQUEST_HANDLE_OBJECT, m_PipelineList) );

	//LONG  m_lPriority
	d_printf("\tLONG m_lPriority %d\n", obj -> m_lPriority);

	//ICSocket * _Socket
	d_printf("\tICSocket * _Socket 0x%x\n", obj -> _Socket);

	//BOOL  _bKeepAliveConnection
	d_printf("\tBOOL _bKeepAliveConnection %d\n", obj -> _bKeepAliveConnection);

	//BOOL  _bNoLongerKeepAlive
	d_printf("\tBOOL _bNoLongerKeepAlive %d\n", obj -> _bNoLongerKeepAlive);

	//LPVOID  _QueryBuffer
	d_printf("\tLPVOID _QueryBuffer 0X%X\n", obj -> _QueryBuffer);

	//DWORD  _QueryBufferLength
	d_printf("\tDWORD _QueryBufferLength %d\n", obj -> _QueryBufferLength);

	//DWORD  _QueryOffset
	d_printf("\tDWORD _QueryOffset %d\n", obj -> _QueryOffset);

	//DWORD  _QueryBytesAvailable
	d_printf("\tDWORD _QueryBytesAvailable %d\n", obj -> _QueryBytesAvailable);

	//DWORD  _OpenFlags
	d_printf("\tDWORD _OpenFlags %d\n", obj -> _OpenFlags);

	//HTTPREQ_STATE  _State
	d_printf("\tHTTPREQ_STATE _State %d\n", obj -> _State);

	//HTTP_HEADERS  _RequestHeaders
	d_printf("\tHTTP_HEADERS _RequestHeaders 0X%X\n", obj -> _RequestHeaders);

	//HTTP_METHOD_TYPE  _RequestMethod
	d_printf("\tHTTP_METHOD_TYPE _RequestMethod %d\n", obj -> _RequestMethod);

	//DWORD  _dwOptionalSaved
	d_printf("\tDWORD _dwOptionalSaved %d\n", obj -> _dwOptionalSaved);

	//LPVOID  _lpOptionalSaved
	d_printf("\tLPVOID _lpOptionalSaved 0X%X\n", obj -> _lpOptionalSaved);

	//BOOL  _fOptionalSaved
	d_printf("\tBOOL _fOptionalSaved %d\n", obj -> _fOptionalSaved);

	//DWORD  _iSlotContentLength
	d_printf("\tDWORD _iSlotContentLength %d\n", obj -> _iSlotContentLength);

	//DWORD  _iSlotContentRange
	d_printf("\tDWORD _iSlotContentRange %d\n", obj -> _iSlotContentRange);

	//DWORD  _StatusCode
	d_printf("\tDWORD _StatusCode %d\n", obj -> _StatusCode);

	//LPBYTE  _ResponseBuffer
	d_printf("\tLPBYTE _ResponseBuffer 0X%X\n", obj -> _ResponseBuffer);

	//DWORD  _ResponseBufferLength
	d_printf("\tDWORD _ResponseBufferLength %d\n", obj -> _ResponseBufferLength);

	//DWORD  _BytesReceived
	d_printf("\tDWORD _BytesReceived %d\n", obj -> _BytesReceived);

	//DWORD  _ResponseScanned
	d_printf("\tDWORD _ResponseScanned %d\n", obj -> _ResponseScanned);

	//DWORD  _ResponseBufferDataReadyToRead
	d_printf("\tDWORD _ResponseBufferDataReadyToRead %d\n", obj -> _ResponseBufferDataReadyToRead);

	//DWORD  _DataOffset
	d_printf("\tDWORD _DataOffset %d\n", obj -> _DataOffset);

	//DWORD  _BytesRemaining
	d_printf("\tDWORD _BytesRemaining %d\n", obj -> _BytesRemaining);

	//DWORD  _ContentLength
	d_printf("\tDWORD _ContentLength %d\n", obj -> _ContentLength);

	//DWORD  _BytesInSocket
	d_printf("\tDWORD _BytesInSocket %d\n", obj -> _BytesInSocket);

	//FILETIME  _ftLastModified
	d_printf("\tFILETIME _ftLastModified %d\n", obj -> _ftLastModified);

	//FILETIME  _ftExpires
	d_printf("\tFILETIME _ftExpires %d\n", obj -> _ftExpires);

	//FILETIME  _ftPostCheck
	d_printf("\tFILETIME _ftPostCheck %d\n", obj -> _ftPostCheck);

	//CHUNK_TRANSFER  _ctChunkInfo
	d_printf("\tCHUNK_TRANSFER (*) _ctChunkInfo 0x%x\n", OFFSET( HTTP_REQUEST_HANDLE_OBJECT, _ctChunkInfo) );

	//BOOL  _fTalkingToSecureServerViaProxy
	d_printf("\tBOOL _fTalkingToSecureServerViaProxy %d\n", obj -> _fTalkingToSecureServerViaProxy);

	//BOOL  _fRequestUsingProxy
	d_printf("\tBOOL _fRequestUsingProxy %d\n", obj -> _fRequestUsingProxy);

	//BOOL  _bWantKeepAlive
	d_printf("\tBOOL _bWantKeepAlive %d\n", obj -> _bWantKeepAlive);

	//BOOL  _bRefresh
	d_printf("\tBOOL _bRefresh %d\n", obj -> _bRefresh);

	//HEADER_STRING  _RefreshHeader
	d_printf("\tHEADER_STRING (*) _RefreshHeader 0x%x\n", OFFSET( HTTP_REQUEST_HANDLE_OBJECT, _RefreshHeader) );

	//DWORD  _dwQuerySetCookieHeader
	d_printf("\tDWORD _dwQuerySetCookieHeader %d\n", obj -> _dwQuerySetCookieHeader);



	d_printf("\n");

}  // HTTP_REQUEST_HANDLE_OBJECT


#ifndef unix
#endif /* unix */
HANDLE_OBJECT object\n"
				"!tinf		<address> - Dumps the INTERNET_THREAD_INFO structure\n"
				"!lste		<address> - Dumps the LIST_ENTRY structure\n"
				"!serialist		<address> - Dumps the SERIALIZED_LIST structure\n"
				"!proxyinfo		<address> - Dumps the PROXY_INFO structure\n"
				"!proxysrvlst		<address> - Dumps the PROXY_INFO structure\n"
				"!proxysrvlste		<address> - Dumps the PROXY_INFO_LIST structure\n"
				"!proxybyplst	<address> - Dumps the PROXY_BYPASS_LIST structure\n"
				"!proxybyplste	<address> - Dumps the PROXY_BYPASS_LIST_ENTRY structure\n"
				);
    }
}

void do_symbol(DWORD dwAddr)
{
    CHAR Symbol[64];
    DWORD Displacement;

    d_GetSymbol((LPVOID)dwAddr,(unsigned char *)Symbol,&Displacement);
    d_printf("%lx   %s+%lx\n", dwAddr, Symbol, Displacement);
}

DECLARE_API( symbol )
{
    DWORD dwAddr;
    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
    do_symbol(dwAddr);
}



USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?
#define VER_PRODUCTBUILD 10
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKD = 1;
    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    d_printf(
        "%s RPC Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}


VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

///////////////////////////////////
//
// Dump the FSM class structure
//
///////////////////////////////////

DECLARE_API( fsm )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_fsm(dwAddr);
}

VOID
do_fsm(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( CFsm ) ];

	CFsm * fsm  = (CFsm *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( CFsm ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read CFsm at 0x%x; sorry.\n", addr);
		return;
	}

	d_printf("\nCFsm at 0x%x \n", addr);

	// CFsm * m_Link;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	// DWORD m_dwError;
	d_printf("\tDWORD m_dwError = %d\n", fsm -> m_dwError );

	// LPINTERNET_THREAD_INFO m_lpThreadInfo;
	d_printf("\tm_lpThreadInfo = 0x%x\n", fsm -> m_lpThreadInfo );

	// DWORD m_dwContext;
	d_printf("\tDWORD_PTR m_dwContext = %d\n", fsm -> m_dwContext );

	// HINTERNET m_hObject;
	d_printf("\tHINTERNET m_hObject = 0x%x\n", fsm -> m_hObject );

	//INTERNET_HANDLE_OBJECT * m_hObjectMapped;
	d_printf("\tINTERNET_HANDLE_OBJECT * m_hObjectMapped = 0x%x\n", fsm -> m_hObjectMapped );

	//DWORD m_dwMappedErrorCode;
	d_printf("\tDWORD m_dwMappedErrorCode = %d\n", fsm -> m_dwMappedErrorCode );

	//FSM_STATE m_State;
	d_printf("\tFSM_STATE m_State = %d ( %s )\n", fsm -> m_State  , MapState( fsm -> m_NextState));

	//FSM_STATE m_NextState;
	d_printf("\tFSM_STATE m_NextState = %d ( %s ) \n", fsm -> m_NextState , MapState( fsm -> m_NextState));


	//FSM_STATE m_FunctionState;
	d_printf("\tFSM_STATE m_FunctionState = %d ( %s ) \n", fsm -> m_FunctionState , MapState( fsm -> m_FunctionState ));

#if INET_DEBUG
	//FSM_TYPE m_Type;
	d_printf("\tFSM_TYPE m_Type = %d(%s)\n", fsm -> m_Type, MapType( fsm -> m_Type ));
#endif

	/*
	DWORD (*m_lpfnHandler)(CFsm *);
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	LPVOID m_lpvContext;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	FSM_HINT m_Hint;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );
	*/

	//SOCKET m_Socket;
	d_printf("\tSOCKET m_Socket = 0x%x\n", fsm -> m_Socket );

	FSM_ACTION m_Action;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	/*
	DWORD m_dwBlockId;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	DWORD m_dwTimeout;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	DWORD m_dwTimer;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );

	BOOL m_bTimerStarted;
	d_printf("\tCFsm * m_Link = 0x%x\n", fsm -> m_Link );
	*/

	//BOOL m_bIsApi;
	d_printf("\tBOOL m_bIsApi = %d\n", fsm -> m_bIsApi );

	//API_TYPE m_ApiType;
	d_printf("\tAPI_TYPE m_ApiType = %d\n", fsm -> m_ApiType );

	//DWORD m_dwApiData;
	d_printf("\tDWORD m_dwApiData = %d\n", fsm -> m_dwApiData );

	d_printf("\n");

	/*
	union {
		BOOL Bool;
		HINTERNET Handle;
	} m_ApiResult;
	*/


    


}


///////////////////////////////////
//
// Dump the HANDLE_OBJECT class structure
//
///////////////////////////////////
VOID
do_handle_object(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( HANDLE_OBJECT ) ];

	HANDLE_OBJECT * fsm  = (HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("HANDLE_OBJECT @ 0x%x \n", addr);

    //LIST_ENTRY _List;
	//d_printf("\tLIST_ENTRY _List\n");
	d_printf("\tLIST_ENTRY (*) _List = 0x%x \n", ((DWORD) addr + offsetof(HANDLE_OBJECT,_List)) );
	/*
	d_printf("\t\tLIST_ENTY * Flink = 0x%x\n", (fsm -> _List).Flink);
	d_printf("\t\tLIST_ENTY * Blink = 0x%x\n", (fsm -> _List).Blink);
	*/


    //SERIALIZED_LIST _Children;
	d_printf("\tSERIALIZED_LIST (*) _Children = 0x%x \n", ((DWORD) addr + offsetof(HANDLE_OBJECT,_Children)) );

    //LIST_ENTRY _Siblings;
	d_printf("\tLIST_ENTRY (*) _Siblings = 0x%x \n", ((DWORD) addr + offsetof(HANDLE_OBJECT,_Siblings)) );

    //HANDLE_OBJECT* _Parent;

	d_printf("\tHANDLE_OBJECT * _Parent = 0x%x \n", fsm -> _Parent);

    //BOOL _DeleteWithChild;
	d_printf("\tBOOL _DeleteWithChild = %d \n", fsm -> _DeleteWithChild);

    //HINTERNET _Handle;
	d_printf("\tHINTERNET _Handle = 0x%x \n", fsm -> _Handle);

    //HINTERNET_HANDLE_TYPE _ObjectType;
	d_printf("\tHINTERNET_HANDLE_TYPE _ObjectType = %d \n", fsm -> _ObjectType);

    //LONG _ReferenceCount;
	d_printf("\tLONG _ReferenceCount = %ld \n", fsm -> _ReferenceCount);

    //BOOL _Invalid;
	d_printf("\tBOOL _Invalid = %d \n", fsm -> _Invalid);

    //DWORD _Error;
	d_printf("\tDWORD _Error = %d \n", fsm -> _Error);

    //DWORD _Signature;
	d_printf("\tDWORD _Signature = 0x%x \n", fsm -> _Signature);

    //DWORD _Context;
	d_printf("\tDWORD _Context = %d \n", fsm -> _Context);

    //DWORD _Status;
	d_printf("\tDWORD _Status = %d \n", fsm -> _Status);

	d_printf("\n");

}

DECLARE_API( ho )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_handle_object(dwAddr);
}

///////////////////////////////////
//
// Dump the Thread Info structure
//
///////////////////////////////////
VOID
do_thread_info(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( INTERNET_THREAD_INFO ) ];

	LPINTERNET_THREAD_INFO fsm  = (LPINTERNET_THREAD_INFO) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( INTERNET_THREAD_INFO ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read INTERNET_THREAD_INFO at 0x%x; sorry.\n", addr);
		return;
	}



	d_printf("INTERNET_THREAD_INFO @ 0x%x \n", addr );

    //LIST_ENTRY List;
	d_printf("\tLIST_ENTRY List = 0x%x \n", fsm -> List);


    //    DWORD ThreadId;
	d_printf("\tDWORD ThreadId = %d \n", fsm -> ThreadId);

    //DWORD ErrorNumber;
	d_printf("\tDWORD ErrorNumber = %d \n", fsm -> ErrorNumber);

    //DWORD Context;
	d_printf("\tDWORD Context = %d \n", fsm -> Context);

    //HINTERNET hObject;
	d_printf("\tHINTERNET hObject = 0x%x \n", fsm -> hObject);

     //HINTERNET hObjectMapped;
	d_printf("\tHINTERNET hObjectMapped = 0x%x \n", fsm -> hObjectMapped);

   //BOOL IsAsyncWorkerThread;
	d_printf("\tBOOL IsAsyncWorkerThread = %d \n", fsm -> IsAsyncWorkerThread);

   //BOOL InCallback;
	d_printf("\tBOOL InCallback = %d \n", fsm -> InCallback);

   //BOOL IsAutoProxyProxyThread;
	d_printf("\tBOOL IsAutoProxyProxyThread = %d \n", fsm -> IsAutoProxyProxyThread);

   //DWORD NestedRequests;
	d_printf("\tDWORD NestedRequests = %d \n", fsm -> NestedRequests);

   //DWORD dwMappedErrorCode;
	d_printf("\tDWORD dwMappedErrorCode = %d \n", fsm -> dwMappedErrorCode);

    //CFsm * Fsm;
	d_printf("\tCFsm * Fsm = 0x%x \n", fsm -> Fsm);

	d_printf("\n");
}

DECLARE_API( tinf )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_thread_info(dwAddr);
}

///////////////////////////////////
//
// Dump the INTERNET_HANDLE_OBJECT class structure
//
///////////////////////////////////
VOID
do_internet_handle_object(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( INTERNET_HANDLE_OBJECT ) ];

	INTERNET_HANDLE_OBJECT * obj  = (INTERNET_HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( INTERNET_HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read INTERNET_HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	//do_internet_handle_object( addr );

	d_printf("INTERNET_HANDLE_OBJECT @ 0x%x \n\n", addr);

	//HINTERNET  _INetHandle
	d_printf("\tHINTERNET _INetHandle = 0x%x\n", obj -> _INetHandle);

	//BOOL  _IsCopy
	d_printf("\tBOOL _IsCopy = %d\n", obj -> _IsCopy);

	//ICSTRING  _UserAgent
	d_printf("\tICSTRING _UserAgent = 0x%x\n", obj -> _UserAgent);

	//PROXY_INFO * _ProxyInfo
	d_printf("\tPROXY_INFO * _ProxyInfo = 0x%x\n", obj -> _ProxyInfo);

	//RESOURCE_LOCK  _ProxyInfoResourceLock
	d_printf("\tRESOURCE_LOCK (*) _ProxyInfoResourceLock = 0x%x\n", &(obj -> _ProxyInfoResourceLock));

	//DWORD  _dwInternetOpenFlags
	d_printf("\tDWORD _dwInternetOpenFlags = %d\n", obj -> _dwInternetOpenFlags);

	//BOOL  _WinsockLoaded
	d_printf("\tBOOL _WinsockLoaded = %d\n", obj -> _WinsockLoaded);

	//ICSocket * _pICSocket
	d_printf("\tICSocket * _pICSocket = 0x%x\n", obj -> _pICSocket);

	//DWORD  _ConnectTimeout
	d_printf("\tDWORD _ConnectTimeout = %d\n", obj -> _ConnectTimeout);

	//DWORD  _ConnectRetries
	d_printf("\tDWORD _ConnectRetries = %d\n", obj -> _ConnectRetries);

	//DWORD  _SendTimeout
	d_printf("\tDWORD _SendTimeout = %d\n", obj -> _SendTimeout);

	//DWORD  _DataSendTimeout
	d_printf("\tDWORD _DataSendTimeout = %d\n", obj -> _DataSendTimeout);

	//DWORD  _ReceiveTimeout
	d_printf("\tDWORD _ReceiveTimeout = %d\n", obj -> _ReceiveTimeout);

	//DWORD  _DataReceiveTimeout
	d_printf("\tDWORD _DataReceiveTimeout = %d\n", obj -> _DataReceiveTimeout);

	//DWORD  _SocketSendBufferLength
	d_printf("\tDWORD _SocketSendBufferLength = %d\n", obj -> _SocketSendBufferLength);

	//DWORD  _SocketReceiveBufferLength
	d_printf("\tDWORD _SocketReceiveBufferLength = %d\n", obj -> _SocketReceiveBufferLength);

	//BOOL  _Async
	d_printf("\tBOOL _Async = %d\n", obj -> _Async);

	//DWORD  _DataAvailable
	d_printf("\tDWORD _DataAvailable = %d\n", obj -> _DataAvailable);

	//BOOL  _EndOfFile
	d_printf("\tBOOL _EndOfFile = %d\n", obj -> _EndOfFile);

	d_printf("\n");

}

DECLARE_API( iho )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_internet_handle_object(dwAddr);
}

/////////////////////////////////////////////////
//
//	INTERNET_CONNECT_HANDLE_OBJECT structure
//
/////////////////////////////////////////////////

DECLARE_API( INTERNET_CONNECT_HANDLE_OBJECT )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_INTERNET_CONNECT_HANDLE_OBJECT(dwAddr);
}

VOID
do_INTERNET_CONNECT_HANDLE_OBJECT(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( INTERNET_CONNECT_HANDLE_OBJECT ) ];

	INTERNET_CONNECT_HANDLE_OBJECT * obj  = (INTERNET_CONNECT_HANDLE_OBJECT *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( INTERNET_CONNECT_HANDLE_OBJECT ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read INTERNET_CONNECT_HANDLE_OBJECT at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("INTERNET_CONNECT_HANDLE_OBJECT @ 0x%x \n\n", addr);

	//HINTERNET  _InternetConnectHandle
	d_printf("\tHINTERNET _InternetConnectHandle 0X%X\n", obj -> _InternetConnectHandle);

	//BOOL  _IsCopy
	d_printf("\tBOOL _IsCopy %d\n", obj -> _IsCopy);

	//DWORD  _ServiceType
	d_printf("\tDWORD _ServiceType %d\n", obj -> _ServiceType);

	//HINTERNET_HANDLE_TYPE  _HandleType
	d_printf("\tHINTERNET_HANDLE_TYPE _HandleType %d\n", obj -> _HandleType);

	//BOOL  _Flags
	d_printf("\tBOOL _Flags %d\n", obj -> _Flags);

	//BOOL  _InUse
	d_printf("\tBOOL _InUse %d\n", obj -> _InUse);

	//BOOL  _fDeleteDataFile
	d_printf("\tBOOL _fDeleteDataFile %d\n", obj -> _fDeleteDataFile);

	//LPSTR  _CacheCWD
	d_printf("\tLPSTR _CacheCWD %s\n", obj -> _CacheCWD);

	//LPSTR  _CacheUrlName
	d_printf("\tLPSTR _CacheUrlName %s\n", obj -> _CacheUrlName);

	//XSTRING  _xsPrimaryCacheKey
	d_printf("\tXSTRING (*) _xsPrimaryCacheKey 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsPrimaryCacheKey) );

	//XSTRING  _xsSecondaryCacheKey
	d_printf("\tXSTRING (*) _xsSecondaryCacheKey 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsSecondaryCacheKey) );

	//LPSTR  _CacheFileName
	d_printf("\tLPSTR _CacheFileName %s\n", obj -> _CacheFileName);

	//DWORD  _CacheHeaderLength
	d_printf("\tDWORD _CacheHeaderLength %d\n", obj -> _CacheHeaderLength);

	//BOOL  _CacheReadInProgress
	d_printf("\tBOOL _CacheReadInProgress %d\n", obj -> _CacheReadInProgress);

	//BOOL  _CacheWriteInProgress
	d_printf("\tBOOL _CacheWriteInProgress %d\n", obj -> _CacheWriteInProgress);

	//DWORD  _RealCacheFileSize
	d_printf("\tDWORD _RealCacheFileSize %d\n", obj -> _RealCacheFileSize);

	//DWORD  _VirtualCacheFileSize
	d_printf("\tDWORD _VirtualCacheFileSize %d\n", obj -> _VirtualCacheFileSize);

#ifdef LAZY_WRITE
	//LPBYTE  _CacheScratchBuf
	d_printf("\tLPBYTE _CacheScratchBuf 0X%X\n", obj -> _CacheScratchBuf);

	//DWORD  _CacheScratchBufLen
	d_printf("\tDWORD _CacheScratchBufLen %d\n", obj -> _CacheScratchBufLen);

	//DWORD  _CacheScratchUsedLen
	d_printf("\tDWORD _CacheScratchUsedLen %d\n", obj -> _CacheScratchUsedLen);

#endif
	//DWORD  _dwCacheFlags
	d_printf("\tDWORD _dwCacheFlags %d\n", obj -> _dwCacheFlags);

	//DWORD  _dwStreamRefCount
	d_printf("\tDWORD _dwStreamRefCount %d\n", obj -> _dwStreamRefCount);

	//DWORD  _dwCurrentStreamPosition
	d_printf("\tDWORD _dwCurrentStreamPosition %d\n", obj -> _dwCurrentStreamPosition);

	//BOOL  _fFromCache
	d_printf("\tBOOL _fFromCache %d\n", obj -> _fFromCache);

	//BOOL  _fCacheWriteDisabled
	d_printf("\tBOOL _fCacheWriteDisabled %d\n", obj -> _fCacheWriteDisabled);

	//BOOL  _fIsHtmlFind
	d_printf("\tBOOL _fIsHtmlFind %d\n", obj -> _fIsHtmlFind);

	//BOOL  _CacheCopy
	d_printf("\tBOOL _CacheCopy %d\n", obj -> _CacheCopy);

	//BOOL  _CachePerUserItem
	d_printf("\tBOOL _CachePerUserItem %d\n", obj -> _CachePerUserItem);

	//BOOL  _fForcedExpiry
	d_printf("\tBOOL _fForcedExpiry %d\n", obj -> _fForcedExpiry);

	//BOOL  _fLazyUpdate
	d_printf("\tBOOL _fLazyUpdate %d\n", obj -> _fLazyUpdate);

	//LPSTR  _OriginalUrl
	d_printf("\tLPSTR _OriginalUrl %s\n", obj -> _OriginalUrl);

#ifdef LAZY_WRITE
#endif // LAZY_WRITE
	//DWORD  _ReadBufferSize
	d_printf("\tDWORD _ReadBufferSize %d\n", obj -> _ReadBufferSize);

	//DWORD  _WriteBufferSize
	d_printf("\tDWORD _WriteBufferSize %d\n", obj -> _WriteBufferSize);

	//ICSTRING  _HostName
	d_printf("\tICSTRING (*) _HostName 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _HostName) );

	//XSTRING  _xsUser
	d_printf("\tXSTRING (*) _xsUser 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsUser) );

	//XSTRING  _xsPass
	d_printf("\tXSTRING (*) _xsPass 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsPass) );

	//XSTRING  _xsProxyUser
	d_printf("\tXSTRING (*) _xsProxyUser 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsProxyUser) );

	//XSTRING  _xsProxyPass
	d_printf("\tXSTRING (*) _xsProxyPass 0x%x\n", OFFSET( INTERNET_CONNECT_HANDLE_OBJECT, _xsProxyPass) );

	//INTERNET_PORT  _HostPort
	d_printf("\tINTERNET_PORT _HostPort %d\n", obj -> _HostPort);

	//INTERNET_SCHEME  _SchemeType
	d_printf("\tINTERNET_SCHEME _SchemeType %d\n", obj -> _SchemeType);

	//LPSTR  _LastResponseInfo
	d_printf("\tLPSTR _LastResponseInfo %s\n", obj -> _LastResponseInfo);

	//DWORD  _LastResponseInfoLength
	d_printf("\tDWORD _LastResponseInfoLength %d\n", obj -> _LastResponseInfoLength);

	//BOOL  _bViaProxy
	d_printf("\tBOOL _bViaProxy %d\n", obj -> _bViaProxy);

	//BOOL  _bNoHeaders
	d_printf("\tBOOL _bNoHeaders %d\n", obj -> _bNoHeaders);

	//BOOL  _bNetFailed
	d_printf("\tBOOL _bNetFailed %d\n", obj -> _bNetFailed);



	d_printf("\n");

}  // INTERNET_CONNECT_HANDLE_OBJECT


///////////////////////////////////
//
// Dump the LIST_ENTRY  structure
//
///////////////////////////////////
VOID
do_list_entry(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( LIST_ENTRY ) ];

	LIST_ENTRY * obj  = (LIST_ENTRY *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( LIST_ENTRY ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read LIST_ENTRY at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("LIST_ENTRY @ 0x%x \n\n", addr);

	//struct _LIST_ENTRY * Flink
	d_printf("\tstruct _LIST_ENTRY * Flink = 0x%X\n", obj -> Flink);

	//struct _LIST_ENTRY * Blink
	d_printf("\tstruct _LIST_ENTRY * Blink = 0x%X\n", obj -> Blink);


	d_printf("\n");

}

DECLARE_API( lste )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_list_entry(dwAddr);
}

///////////////////////////////////
//
// Dump the SERIALIZED_LIST structure
//
///////////////////////////////////
VOID
do_serialized_list(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( SERIALIZED_LIST ) ];

	SERIALIZED_LIST * obj  = (SERIALIZED_LIST *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( SERIALIZED_LIST ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read SERIALIZED_LIST at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("SERIALIZED_LIST @ 0x%x \n\n", addr);

#if INET_DEBUG
	//DWORD  Signature
	d_printf("\tDWORD Signature %d\n", obj -> Signature);

	//RESOURCE_INFO  ResourceInfo
	d_printf("\tRESOURCE_INFO (*) ResourceInfo 0X%X\n", 
				((DWORD)addr + offsetof(SERIALIZED_LIST, ResourceInfo)) 
			);

	//LONG  LockCount
	d_printf("\tLONG LockCount %d\n", obj -> LockCount);

#endif // INET_DEBUG

	//LIST_ENTRY  List
	d_printf("\tLIST_ENTRY (*) List 0X%X\n",
				((DWORD)addr + offsetof(SERIALIZED_LIST, List)) 
			);

	//do_list_entry( (DWORD) &obj->List );

	//LONG  ElementCount
	d_printf("\tLONG ElementCount %ld\n", obj -> ElementCount);



	d_printf("\n");

}

DECLARE_API( serialist )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_serialized_list(dwAddr);
}

/////////////////////////////////////////////////
//
//	PROXY_INFO structure
//
/////////////////////////////////////////////////
VOID
do_proxy_info(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_INFO ) ];

	PROXY_INFO * obj  = (PROXY_INFO *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_INFO ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_INFO at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_INFO @ 0x%x \n\n", addr);

	//PROXY_SERVER_LIST * _ProxyServerList
	d_printf("\tPROXY_SERVER_LIST * _ProxyServerList = 0X%X\n",obj -> _ProxyServerList);

	//AUTO_PROXY_DLLS * _AutoProxyList
	d_printf("\tAUTO_PROXY_DLLS * _AutoProxyList = 0X%X\n", obj -> _AutoProxyList);

	//PROXY_BYPASS_LIST * _ProxyBypassList
	d_printf("\tPROXY_BYPASS_LIST * _ProxyBypassList = 0X%X\n", obj -> _ProxyBypassList);

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);

	//RESOURCE_LOCK  _Lock
	d_printf("\tRESOURCE_LOCK (*) _Lock 0X%X\n", OFFSET(PROXY_INFO, _Lock));

	//BOOL  _Modified
	d_printf("\tBOOL _Modified %d\n", obj -> _Modified);

	//BAD_PROXY_LIST  _BadProxyList
	d_printf("\tBAD_PROXY_LIST _BadProxyList 0X%X\n", OFFSET(PROXY_INFO, _BadProxyList));

	d_printf("\n");

}

DECLARE_API( proxyinfo )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_proxy_info(dwAddr);
}


/////////////////////////////////////////////////
//
//	PROXY_BYPASS_LIST_ENTRY structure
//
/////////////////////////////////////////////////

DECLARE_API( proxybyplste )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_BYPASS_LIST_ENTRY(dwAddr);
}

VOID
do_PROXY_BYPASS_LIST_ENTRY(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_BYPASS_LIST_ENTRY ) ];

	PROXY_BYPASS_LIST_ENTRY * obj  = (PROXY_BYPASS_LIST_ENTRY *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_BYPASS_LIST_ENTRY ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_BYPASS_LIST_ENTRY at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_BYPASS_LIST_ENTRY @ 0x%x \n\n", addr);

	//LIST_ENTRY  _List
	d_printf("\tLIST_ENTRY (*) _List 0x%x\n", OFFSET( PROXY_BYPASS_LIST_ENTRY, _List) );

	//INTERNET_SCHEME  _Scheme
	d_printf("\tINTERNET_SCHEME _Scheme %d\n", obj -> _Scheme);

	//ICSTRING  _Name
	d_printf("\tICSTRING (*) _Name 0x%x\n", OFFSET( PROXY_BYPASS_LIST_ENTRY, _Name) );

	//INTERNET_PORT  _Port
	d_printf("\tINTERNET_PORT _Port %d\n", obj -> _Port);

	//BOOL  _LocalSemantics
	d_printf("\tBOOL _LocalSemantics %d\n", obj -> _LocalSemantics);



	d_printf("\n");

}  // PROXY_BYPASS_LIST_ENTRY



/////////////////////////////////////////////////
//
//	PROXY_BYPASS_LIST structure
//
/////////////////////////////////////////////////

DECLARE_API( proxybyplst )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_BYPASS_LIST(dwAddr);
}

VOID
do_PROXY_BYPASS_LIST(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_BYPASS_LIST ) ];

	PROXY_BYPASS_LIST * obj  = (PROXY_BYPASS_LIST *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_BYPASS_LIST ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_BYPASS_LIST at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_BYPASS_LIST @ 0x%x \n\n", addr);

	//SERIALIZED_LIST  _List
	d_printf("\tSERIALIZED_LIST (*) _List 0x%x\n", OFFSET( PROXY_BYPASS_LIST, _List) );

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);



	d_printf("\n");

}  // PROXY_BYPASS_LIST



/////////////////////////////////////////////////
//
//	PROXY_SERVER_LIST_ENTRY structure
//
/////////////////////////////////////////////////

DECLARE_API( proxysrvlste )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_SERVER_LIST_ENTRY(dwAddr);
}

VOID
do_PROXY_SERVER_LIST_ENTRY(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_SERVER_LIST_ENTRY ) ];

	PROXY_SERVER_LIST_ENTRY * obj  = (PROXY_SERVER_LIST_ENTRY *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_SERVER_LIST_ENTRY ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_SERVER_LIST_ENTRY at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_SERVER_LIST_ENTRY @ 0x%x \n\n", addr);

	//LIST_ENTRY  _List
	d_printf("\tLIST_ENTRY (*) _List 0x%x\n", OFFSET( PROXY_SERVER_LIST_ENTRY, _List) );

	//INTERNET_SCHEME  _Protocol
	d_printf("\tINTERNET_SCHEME _Protocol %d\n", obj -> _Protocol);

	//INTERNET_SCHEME  _Scheme
	d_printf("\tINTERNET_SCHEME _Scheme %d\n", obj -> _Scheme);

	//ICSTRING  _ProxyName
	d_printf("\tICSTRING (*) _ProxyName 0x%x\n", OFFSET( PROXY_SERVER_LIST_ENTRY, _ProxyName) );

	//INTERNET_PORT  _ProxyPort
	d_printf("\tINTERNET_PORT _ProxyPort %d\n", obj -> _ProxyPort);


	d_printf("\n");

}  // PROXY_SERVER_LIST_ENTRY



/////////////////////////////////////////////////
//
//	PROXY_SERVER_LIST structure
//
/////////////////////////////////////////////////

DECLARE_API( proxysrvlst )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_PROXY_SERVER_LIST(dwAddr);
}

VOID
do_PROXY_SERVER_LIST(
	   DWORD addr
    )
{
	BOOL b;
	char block[ sizeof( PROXY_SERVER_LIST ) ];

	PROXY_SERVER_LIST * obj  = (PROXY_SERVER_LIST *) &block;

    b = GetData(
			addr, 
			block, 
			sizeof( PROXY_SERVER_LIST ), 
			NULL);

	if ( !b ) {
		d_printf("couldn't read PROXY_SERVER_LIST at 0x%x; sorry.\n", addr);
		return;
	}


	d_printf("PROXY_SERVER_LIST @ 0x%x \n\n", addr);

	//SERIALIZED_LIST  _List
	d_printf("\tSERIALIZED_LIST (*) _List 0x%x\n", OFFSET( PROXY_SERVER_LIST, _List) );

	//DWORD  _Error
	d_printf("\tDWORD _Error %d\n", obj -> _Error);


	d_printf("\n");

}  // PROXY_SERVER_LIST

/////////////////////////////////////////////////
//
//      ICSocket structure
//
/////////////////////////////////////////////////

DECLARE_API( ICSocket )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_ICSocket(dwAddr);
}

VOID
do_ICSocket(
           DWORD addr
    )
{
        BOOL b;
        char block[ sizeof( ICSocket ) ];

        ICSocket * obj  = (ICSocket *) &block;

    b = GetData(
                        addr,
                        block,
                        sizeof( ICSocket ),
                        NULL);

        if ( !b ) {
                d_printf("couldn't read ICSocket at 0x%x; sorry.\n", addr);
                return;
        }


        d_printf("ICSocket @ 0x%x \n\n", addr);

        //LIST_ENTRY  m_List
        d_printf("\tLIST_ENTRY (*) m_List 0x%x\n", OFFSET( ICSocket, m_List) );

        //DWORD  m_dwTimeout
        d_printf("\tDWORD m_dwTimeout %d\n", obj -> m_dwTimeout);

        //LONG  m_ReferenceCount
        d_printf("\tLONG m_ReferenceCount %d\n", obj -> m_ReferenceCount);

        //DWORD  m_dwFlags
        d_printf("\tDWORD m_dwFlags %d\n", obj -> m_dwFlags);

	//    SOCKET m_Socket;
	d_printf("\tSOCKET m_Socket %d\n", obj -> m_Socket);

        //INTERNET_PORT  m_Port
        d_printf("\tINTERNET_PORT m_Port %d\n", obj -> m_Port);

        //INTERNET_PORT  m_SourcePort
        d_printf("\tINTERNET_PORT m_SourcePort %d\n", obj -> m_SourcePort);

        //BOOL  m_bAborted
        d_printf("\tBOOL m_bAborted %d\n", obj -> m_bAborted);

        //DWORD  m_SocksAddress
        d_printf("\tDWORD m_SocksAddress %d\n", obj -> m_SocksAddress);

        //INTERNET_PORT  m_SocksPort
        d_printf("\tINTERNET_PORT m_SocksPort %d\n", obj -> m_SocksPort);

#if INET_DEBUG
        //DWORD  m_Signature
        d_printf("\tDWORD m_Signature %d\n", obj -> m_Signature);

#endif


        d_printf("\n");

}  // ICSocket

/////////////////////////////////////////////////
//
//      ICSecureSocket structure
//
/////////////////////////////////////////////////

DECLARE_API( ICSecureSocket )
{
    DWORD dwAddr;

    INIT_DPRINTF();

    dwAddr = d_GetExpression(lpArgumentString);
    if ( !dwAddr )
        {
        return;
        }
   do_ICSecureSocket(dwAddr);
}

VOID
do_ICSecureSocket(
           DWORD addr
    )
{
        BOOL b;
        char block[ sizeof( ICSecureSocket ) ];

        ICSecureSocket * obj  = (ICSecureSocket *) &block;

	b = GetData(
                        addr,
                        block,
                        sizeof( ICSecureSocket ),
                        NULL);

        if ( !b ) {
                d_printf("couldn't read ICSecureSocket at 0x%x; sorry.\n", addr);
                return;
        }


        d_printf("ICSecureSocket @ 0x%x \n\n", addr);

        //CtxtHandle  m_hContext
        d_printf("\tCtxtHandle (*) m_hContext 0x%x\n", OFFSET( ICSecureSocket, m_hContext) );

        //DWORD  m_dwProviderIndex
        d_printf("\tDWORD m_dwProviderIndex %d\n", obj -> m_dwProviderIndex);

        //LPSTR  m_lpszHostName
        d_printf("\tLPSTR m_lpszHostName %s\n", obj -> m_lpszHostName);

        //DBLBUFFER * m_pdblbufBuffer
        d_printf("\tDBLBUFFER * m_pdblbufBuffer 0x%x\n", obj -> m_pdblbufBuffer);

        //DWORD  m_dwErrorFlags
        d_printf("\tDWORD m_dwErrorFlags %d\n", obj -> m_dwErrorFlags);

        //SECURITY_CACHE_LIST_ENTRY * m_pSecurityInfo
        d_printf("\tSECURITY_CACHE_LIST_ENTRY * m_pSecurityInfo 0x%x\n", obj -> m_pSecurityInfo);

#if INET_DEBUG
#endif


        d_printf("\n");

}  // ICSecureSocket



#if INET_DEBUG

LPSTR
MapType(
    FSM_TYPE m_Type
    ) {
    switch (m_Type) {
    case FSM_TYPE_NONE:                     return "NONE";
    case FSM_TYPE_WAIT_FOR_COMPLETION:      return "WAIT_FOR_COMPLETION";
    case FSM_TYPE_RESOLVE_HOST:             return "RESOLVE_HOST";
    case FSM_TYPE_SOCKET_CONNECT:           return "SOCKET_CONNECT";
    case FSM_TYPE_SOCKET_SEND:              return "SOCKET_SEND";
    case FSM_TYPE_SOCKET_RECEIVE:           return "SOCKET_RECEIVE";
    case FSM_TYPE_SOCKET_QUERY_AVAILABLE:   return "SOCKET_QUERY_AVAILABLE";
    case FSM_TYPE_SECURE_CONNECT:           return "SECURE_CONNECT";
    case FSM_TYPE_SECURE_HANDSHAKE:         return "SECURE_HANDSHAKE";
    case FSM_TYPE_SECURE_NEGOTIATE:         return "SECURE_NEGOTIATE";
    case FSM_TYPE_NEGOTIATE_LOOP:           return "NEGOTIATE_LOOP";
    case FSM_TYPE_SECURE_SEND:              return "SECURE_SEND";
    case FSM_TYPE_SECURE_RECEIVE:           return "SECURE_RECEIVE";
    case FSM_TYPE_GET_CONNECTION:           return "GET_CONNECTION";
    case FSM_TYPE_HTTP_SEND_REQUEST:        return "HTTP_SEND_REQUEST";
    case FSM_TYPE_MAKE_CONNECTION:          return "MAKE_CONNECTION";
    case FSM_TYPE_OPEN_CONNECTION:          return "OPEN_CONNECTION";
    case FSM_TYPE_OPEN_PROXY_TUNNEL:        return "OPEN_PROXY_TUNNEL";
    case FSM_TYPE_SEND_REQUEST:             return "SEND_REQUEST";
    case FSM_TYPE_RECEIVE_RESPONSE:         return "RECEIVE_RESPONSE";
    case FSM_TYPE_HTTP_READ:                return "HTTP_READ";
    case FSM_TYPE_HTTP_WRITE:               return "HTTP_WRITE";
    case FSM_TYPE_READ_DATA:                return "READ_DATA";
    case FSM_TYPE_HTTP_QUERY_AVAILABLE:     return "HTTP_QUERY_AVAILABLE";
    case FSM_TYPE_DRAIN_RESPONSE:           return "DRAIN_RESPONSE";
    case FSM_TYPE_REDIRECT:                 return "REDIRECT";
    case FSM_TYPE_READ_LOOP:                return "READ_LOOP";
    case FSM_TYPE_PARSE_HTTP_URL:           return "PARSE_HTTP_URL";
    case FSM_TYPE_PARSE_URL_FOR_HTTP:       return "PARSE_URL_FOR_HTTP";
    case FSM_TYPE_READ_FILE:                return "READ_FILE";
    case FSM_TYPE_READ_FILE_EX:             return "READ_FILE_EX";
    case FSM_TYPE_WRITE_FILE:               return "WRITE_FILE";
    case FSM_TYPE_QUERY_DATA_AVAILABLE:     return "QUERY_DATA_AVAILABLE";
    }
    return "?";
}

#endif // INET_DEBUG

LPSTR
MapState(
    IN DWORD State
    ) {
    switch (State) {
    CASE_OF(FSM_STATE_BAD);
    CASE_OF(FSM_STATE_INIT);
    CASE_OF(FSM_STATE_WAIT);
    CASE_OF(FSM_STATE_DONE);
    CASE_OF(FSM_STATE_ERROR);
    CASE_OF(FSM_STATE_CONTINUE);
    CASE_OF(FSM_STATE_FINISH);
    CASE_OF(FSM_STATE_1);
    CASE_OF(FSM_STATE_2);
    CASE_OF(FSM_STATE_3);
    CASE_OF(FSM_STATE_4);
    CASE_OF(FSM_STATE_5);
    CASE_OF(FSM_STATE_6);
    CASE_OF(FSM_STATE_7);
    CASE_OF(FSM_STATE_8);
    CASE_OF(FSM_STATE_9);
    CASE_OF(FSM_STATE_10);
    }
    return "?";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\dll\test\openurl\openurl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    openurl.c

Abstract:

    Tests InternetOpenUrl()

Author:

    Richard L Firth (rfirth) 29-May-1995

Revision History:

    29-May-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define VERSION_STRING  "1.0"

#define URL_CONTEXT             0x55785875  // UxXu
#define DEFAULT_BUFFER_LENGTH   1021        // odd number for fun!

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void default_url_test(LPSTR, DWORD, DWORD);
void open_urls(LPSTR*, int, LPSTR, DWORD, DWORD);
void get_url_data(HINTERNET);
void ftp_find(HINTERNET);
void gopher_find(HINTERNET);
void read_data(HINTERNET);
void get_request_flags(HINTERNET);

//
// data
//

BOOL Verbose = FALSE;
HINTERNET InternetHandle = NULL;
INTERNET_STATUS_CALLBACK PreviousCallback;
HINTERNET hCancel;
BOOL AsyncMode = FALSE;
HANDLE AsyncEvent = NULL;
DWORD AsyncResult;
DWORD AsyncError;
BOOL UseQueryData = FALSE;
BOOL NoDump = FALSE;
DWORD BufferLength = DEFAULT_BUFFER_LENGTH;
DWORD ReadLength = DEFAULT_BUFFER_LENGTH;

LPSTR default_urls[] = {

    //
    // WEB
    //

    "http://www.microsoft.com",
    "http://www.microsoft.com/pages/misc/whatsnew.htm",

    //
    // gopher
    //

    "gopher://gopher.microsoft.com",
    "gopher://gopher.microsoft.com/11/msft/",
    "gopher://gopher.microsoft.com/00\\welcome.txt",
    "gopher://gopher.tc.umn.edu/11Information%20About%20Gopher%09%09%2B",
    "gopher://spinaltap.micro.umn.edu/11/computer",
    "gopher://mudhoney.micro.umn.edu:4325/7",
    "gopher://mudhoney.micro.umn.edu:4325/7%09gopher",
    "gopher://spinaltap.micro.umn.edu/7mindex:lotsoplaces%09gopher%09%2b",

    //
    // FTP
    //

    "ftp://ftp.microsoft.com",
    "ftp://ftp.microsoft.com/MSNBRO.TXT",
    "ftp://ftp.microsoft.com/Services/"
};

#define NUMBER_OF_DEFAULT_URLS  (sizeof(default_urls)/sizeof(default_urls[0]))

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    BOOL ok;
    LPSTR urls[64];
    int numberOfUrls = 0;
    BOOL fCallback = FALSE;
    LPSTR headers = NULL;
    BOOL expectingHeaders = FALSE;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    LPSTR proxyServer = NULL;
    BOOL expectingProxy = FALSE;
    DWORD context = 0;
    DWORD flags = 0;
    LPSTR endptr;

    printf("\n"
           "OpenUrl  Version " VERSION_STRING "  " __DATE__ "\n"
           "\n"
           );

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (tolower(*++*argv)) {
            case '?':
                usage();
                break;

            case 'a':
                ++*argv;
                if (**argv == 'l') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxy = TRUE;
                    }
                } else {
                    printf("error: unrecognised access type: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'b':
                BufferLength = (DWORD)strtol(++*argv, &endptr, 0);
                if (*endptr == 'K' || *endptr == 'k') {
                    BufferLength *= 1024;
                }
                break;

            case 'c':
                fCallback = TRUE;
                break;

            case 'd':
                NoDump = TRUE;
                break;

            case 'e':
                flags |= INTERNET_FLAG_EXISTING_CONNECT;
                break;

            case 'h':
                if (*++*argv) {
                    headers = *argv;
                } else {
                    expectingHeaders = TRUE;
                }
                break;

            case 'l':
                ReadLength = (DWORD)strtol(++*argv, &endptr, 0);
                if (*endptr == 'K' || *endptr == 'k') {
                    ReadLength *= 1024;
                }
                break;

            case 'n':
                flags |= INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE;
                break;

            case 'p':
                flags |= INTERNET_FLAG_PASSIVE;
                break;

            case 'q':
                UseQueryData = TRUE;
                break;

            case 'r':
                flags |= INTERNET_FLAG_RAW_DATA;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            case 'x':
                context = URL_CONTEXT;
                break;

            case 'y':
                AsyncMode = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxy) {
            proxyServer = *argv;
            expectingProxy = FALSE;
        } else if (expectingHeaders) {
            headers = *argv;
            expectingHeaders = FALSE;
        } else {
            if (numberOfUrls == sizeof(urls)/sizeof(urls[0]) - 1) {
                break;
            }
            urls[numberOfUrls++] = *argv;
        }
    }

    if (BufferLength < ReadLength) {
        BufferLength = ReadLength;
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    if (AsyncMode) {

        //
        // create an auto-reset, initially unsignalled event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!AsyncEvent) {
            print_error("OpenUrl", "CreateEvent()");
            exit(1);
        }
    }

    //
    // get a handle to the internet - local, gateway or CERN proxy
    //

    InternetHandle = InternetOpen("OpenUrl",
                                  accessMethod,
                                  proxyServer,
                                  NULL,
                                  AsyncMode ? INTERNET_FLAG_ASYNC : 0
                                  );
    if (InternetHandle == NULL) {
        print_error("openurl()", "InternetOpen()");
        exit(1);
    }

    if (Verbose) {
        printf("InternetOpen() returns handle %x\n", InternetHandle);
    }

    //
    // let's have a status callback
    //

    if (fCallback) {
        PreviousCallback = InternetSetStatusCallback(InternetHandle, my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    if (numberOfUrls == 0) {
        default_url_test(headers, flags, context);
    } else {
        open_urls(urls, numberOfUrls, headers, flags, context);
    }

    if (Verbose) {
        printf("closing InternetHandle (%x)\n", InternetHandle);
    }
    ok = InternetCloseHandle(InternetHandle);
    if (!ok) {
        print_error("openurl()", "InternetClose(%x)", InternetHandle);
        exit(1);
    } else {
        InternetHandle = NULL;
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("\n"
           "usage: openurl [-a{l|p}[[ ]{server[:port]}] [-b#] [-c] [-d] [-h[ ]{headers}]\n"
           "               [-l#] [-n] [-p] [-q] [-r] [-v] [-x] [-y] [url]*\n"
           "\n"
           "where:  -al = local internet access\n"
           "        -ap = CERN proxy internet access\n"
           "         -b = buffer size\n"
           "         -c = enable status callbacks\n"
           "         -d = don't dump data\n"
           "         -e = use existing connection\n"
           "         -h = headers\n"
           "         -l = read length\n"
           "         -n = don't use cache\n"
           "         -p = PASSIVE mode (FTP transfers)\n"
           "         -q = use InternetQueryDataAvailable\n"
           "         -r = raw data. Default is HTML for FTP and gopher directories\n"
           "         -v = Verbose mode\n"
           "         -x = use context value when calling InternetOpenUrl()\n"
           "         -y = Async mode\n"
           "\n"
           "     server = gateway server or proxy server name\n"
           "      :port = (optional) CERN proxy port\n"
           "        url = one or more URLs to open\n"
           "\n"
           "Default internet access is pre-configured (i.e. use settings in registry)\n"
           );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (InternetHandle != NULL) {
        if (Verbose) {
            printf("closing Internet handle %x\n", InternetHandle);
        }
        if (!InternetCloseHandle(InternetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle(%x)", InternetHandle);
        }
    }
}

VOID
my_callback(
    HINTERNET hInternet,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;
    DWORD handleType;
    DWORD size;

    size = sizeof(handleType);
    if (!InternetQueryOption(hInternet,
                             INTERNET_OPTION_HANDLE_TYPE,
                             (LPVOID)&handleType,
                             &size)) {
        print_error("my_callback", "InternetQueryOption(HANDLE_TYPE)");
    } else {
        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            type$ = "Internet";
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            type$ = "FTP Connect";
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            type$ = "Gopher Connect";
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            type$ = "HTTP Connect";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            type$ = "FTP Find";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
            type$ = "FTP Find HTML";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FILE:
            type$ = "FTP File";
            break;

        case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
            type$ = "FTP File HTML";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            type$ = "Gopher Find";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
            type$ = "Gopher Find HTML";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
            type$ = "Gopher File";
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
            type$ = "Gopher File HTML";
            type$ = "Internet";
            break;

        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            type$ = "HTTP Request";
            break;

        default:
            type$ = "???";
        }
        printf("callback: handle %x = %s\n", hInternet, type$);
    }

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        hCancel = *(LPHINTERNET)Info;
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                hInternet,
                Context,
                (Context == URL_CONTEXT) ? "UrlContext" : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else if (Status != INTERNET_STATUS_REQUEST_COMPLETE) {
                printf(Info);
            }
        }
        putchar('\n');
    }
    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        if (AsyncMode) {
            SetEvent(AsyncEvent);
        } else {
            printf("error: INTERNET_STATUS_REQUEST_COMPLETE received when not async\n");
        }
    }
}

void default_url_test(LPSTR headers, DWORD flags, DWORD context) {
    open_urls(default_urls, NUMBER_OF_DEFAULT_URLS, headers, flags, context);
}

void open_urls(LPSTR* purls, int nurls, LPSTR headers, DWORD flags, DWORD context) {

    HINTERNET handle;

    if (headers) {

        LPSTR h;

        for (h = headers; *h; ++h) {
            if (*h == '\\' && *(h + 1) == 'n') {
                *h++ = '\r';
                *h = '\n';
            }
        }
    }
    while (nurls--) {
        if (Verbose) {
            printf("\nopening URL \"%s\"\n\n", *purls);
        }
        handle = InternetOpenUrl(InternetHandle,
                                 *purls,
                                 headers,
                                 headers ? -1 : 0,
                                 flags,
                                 context
                                 );
        if ((handle == NULL) && AsyncMode) {

            DWORD err;

            err = GetLastError();
            if (err == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("waiting for async InternetOpenUrl()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                handle = (HINTERNET)AsyncResult;
                SetLastError(AsyncError);
            }
        } else if (AsyncMode && Verbose) {
            printf("async InternetOpenUrl() returns sync result\n");
        }

        if (handle == NULL) {
            print_error("open_urls", "InternetOpenUrl(%s)", *purls);
        } else {
            if (Verbose) {
                printf("InternetOpenUrl() returns handle %x\n", handle);
            }
            get_request_flags(handle);
            get_url_data(handle);
        }

        ++purls;
    }
}

void get_url_data(HINTERNET handle) {

    DWORD handleType;
    DWORD handleTypeLen;

    handleTypeLen = sizeof(handleType);
    if (InternetQueryOption(handle,
                            INTERNET_OPTION_HANDLE_TYPE,
                            (LPVOID)&handleType,
                            &handleTypeLen
                            )) {
        switch (handleType) {
        case INTERNET_HANDLE_TYPE_INTERNET:
            printf("error: get_url_data: HANDLE_TYPE_INTERNET?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_FTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_FTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_GOPHER:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_GOPHER?\n");
            break;

        case INTERNET_HANDLE_TYPE_CONNECT_HTTP:
            printf("error: get_url_data: INTERNET_HANDLE_TYPE_CONNECT_HTTP?\n");
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND:
            ftp_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_GOPHER_FIND:
            gopher_find(handle);
            break;

        case INTERNET_HANDLE_TYPE_FTP_FIND_HTML:
        case INTERNET_HANDLE_TYPE_FTP_FILE:
        case INTERNET_HANDLE_TYPE_FTP_FILE_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE:
        case INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML:
        case INTERNET_HANDLE_TYPE_HTTP_REQUEST:
            read_data(handle);
            break;

        default:
            printf("error: get_url_data: handleType == %d?\n", handleType);
            break;
        }
        if (Verbose) {
            printf("closing Internet handle %x\n", handle);
        }
        if (!InternetCloseHandle(handle)) {
            print_error("get_url_data", "InternetCloseHandle(%x)", handle);
        }
    } else {
        print_error("get_url_data", "InternetQueryOption()");
    }
}

void ftp_find(HINTERNET handle) {

    WIN32_FIND_DATA data;
    BOOL ok;

    do {

        SYSTEMTIME systemTime;

        ok = InternetFindNextFile(handle, (LPVOID)&data);
        if (!ok) {
            if (AsyncMode) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetFindNextFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
        }
        if (ok && !NoDump) {
            if (!FileTimeToSystemTime(&data.ftLastWriteTime, &systemTime)) {
                print_error("ftp_find", "FileTimeToSystemTime()");
            }

            printf("%2d-%02d-%04d %2d:%02d:%02d  %15d bytes %-s%-s%-s %s\n",
                   systemTime.wMonth,
                   systemTime.wDay,
                   systemTime.wYear,
                   systemTime.wHour,
                   systemTime.wMinute,
                   systemTime.wSecond,
                   data.nFileSizeLow,
                   (data.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)
                    ? "Normal    " : "",
                   (data.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
                    ? "ReadOnly  " : "",
                   (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    ? "Directory " : "",
                   data.cFileName
                   );
        }
    } while (ok);

    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("ftp_find", "InternetFindNextFile()");
    }
}

void gopher_find(HINTERNET handle) {

    GOPHER_FIND_DATA data;
    BOOL ok;
    int i;

    i = 0;
    do {
        ok = InternetFindNextFile(handle, (LPVOID)&data);
        if (!ok) {
            if (AsyncMode) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetFindNextFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
        }
        if (ok && !NoDump) {

            LPGOPHER_FIND_DATA p;
            SYSTEMTIME systemTime;
            char timeBuf[9];
            char sizeBuf[32];

            p = (LPGOPHER_FIND_DATA)&data;
            if ((p->LastModificationTime.dwLowDateTime != 0)
            && (p->LastModificationTime.dwHighDateTime != 0)) {
                FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
                sprintf(timeBuf,
                        "%02d-%02d-%02d",
                        systemTime.wMonth,
                        systemTime.wDay,
                        systemTime.wYear % 100
                        );
                sprintf(sizeBuf, "%d", p->SizeLow);
            } else {
                timeBuf[0] = '\0';
                sizeBuf[0] = '\0';
            }
            printf("%5d %c %7s %10s %8s %s\n",
                    i,
                    (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                    (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                    : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                    : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                    : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                    : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                    : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                    : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                    : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                    : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                    : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                    : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                    : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                    : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                    : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                    : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                    : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                    : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                    : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                    : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                    : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                    : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                    : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                    : "\a????",
                    sizeBuf,
                    timeBuf,
                    p->DisplayString
                    );
            ++i;
        }
    } while (ok);

    if (GetLastError() != ERROR_NO_MORE_FILES) {
        print_error("gopher_find", "InternetFindNextFile()");
    }
}

void read_data(HINTERNET handle) {

    char* buf;
    DWORD nread;
    BOOL ok;
    int mode;

    buf = (char*)malloc(BufferLength);
    if (!buf) {
        printf("error: failed to allocate %d bytes for buffer\n", BufferLength);
        return;
    }

    mode = _setmode(1, _O_BINARY);

    do {

        DWORD avail;
        int i;

        if (UseQueryData) {
            ok = InternetQueryDataAvailable(handle, &avail, 0, 0);
            if (!ok) {
                if (GetLastError() == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetQueryDataAvailable()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
            if (!ok) {
                print_error("read_file", "InternetQueryDataAvailable()");
                break;
            }

            if (Verbose) {
                printf("InternetQueryDataAvailable() returns %d bytes\n", avail);
            }
        } else {
            avail = BufferLength;
        }

        avail = min(avail, ReadLength);

        for (i = 0; i < 2; ++i) {
            memset(buf, '@', avail);
            ok = InternetReadFile(handle, buf, avail, &nread);
            if (!ok) {
                if (AsyncMode) {
                    if (GetLastError() == ERROR_IO_PENDING) {
                        if (Verbose) {
                            printf("waiting for async InternetFindNextFile()...\n");
                        }
                        WaitForSingleObject(AsyncEvent, INFINITE);
                        ok = (BOOL)AsyncResult;
                        SetLastError(AsyncError);
                    }
                } else {
                    break;
                }
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    if (i == 1) {
                        printf("error: failed to read %d bytes in 2 attempts\n",
                            nread);
                        goto quit;
                    }

                    //
                    // second attempt with all buffer
                    //

                    avail = BufferLength;
                } else {
                    break;
                }
            }
        }
        if (ok && !NoDump) {
            if (!nread) {
                printf("=== end of file ===\n");
            } else {
                _write(1, buf, nread);
            }
        } else if (ok && NoDump && Verbose) {
            printf("InternetReadFile() returns %d bytes\n", nread);
        }
    } while (ok && nread);

    if (GetLastError() != ERROR_SUCCESS) {
        print_error("read_file", "InternetReadFile()");
    }

quit:

    free(buf);

    _setmode(1, mode);
}

void get_request_flags(HINTERNET hInternet) {

    DWORD dwFlags;
    DWORD len = sizeof(dwFlags);

    if (InternetQueryOption(hInternet,
                            INTERNET_OPTION_REQUEST_FLAGS,
                            &dwFlags,
                            &len)) {

        char buf[256];
        char * p = buf;

        p += sprintf(p, "REQUEST_FLAGS = %08x\n", dwFlags);
        p += sprintf(p, "\tRetrieved from:  %s\n",
            (dwFlags & INTERNET_REQFLAG_FROM_CACHE) ? "Cache" : "Network");
        p += sprintf(p, "\tNo Headers:      %s\n",
            (dwFlags & INTERNET_REQFLAG_NO_HEADERS) ? "TRUE" : "FALSE");
        p += sprintf(p, "\tVia Proxy:       %s\n",
            (dwFlags & INTERNET_REQFLAG_VIA_PROXY) ? "YES" : "NO");
        printf(buf);
    } else {
        print_error("get_request_flags()", "InternetQueryOption()");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\dirlist.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dirlist.h

Abstract:

    Prototypes, etc. for dirlist.c

Author:

    Richard L Firth (rfirth) 31-Jul-1995

Revision History:

    31-Jul-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
ParseDirList(
    IN LPSTR lpBuffer,
    IN DWORD lpBufferLength,
    IN LPSTR lpszFilespec OPTIONAL,
    IN OUT PLIST_ENTRY lpList
    );

BOOL
IsFilespecWild(
    IN LPCSTR lpszFilespec
    );

PRIVATE
VOID
ClearFindList(
    IN PLIST_ENTRY lpList
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\dirlist.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dirlist.cxx

Abstract:

    Contains functions for parsing directory output from LIST command

    Contents:
        ParseDirList
        IsFilespecWild
        ClearFindList
        (DetermineDirectoryFormat)
        (IsNtDateFormat)
        (GetToken)
        (IsUnixAttributeFormat)
        (ParseNtDirectory)
        (ParseUnixDirectory)
        (ParseOs2Directory)
        (ParseMacDirectory)
        (ExtractFileSize)
        (_ExtractFilename)
        (ExtractNtDate)
        (ExtractUnixDate)
        (ExtractOs2Attributes)
        (ParseWord)
        (ExtractInteger)

Author:

    Richard L Firth (rfirth) 26-Jul-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Jul-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// private manifests
//

#define MAX_YEAR_SUPPORTED  2100
#define TOKEN_BUFFER_LENGTH 128
#define RELATIVELY_SMALL_AMOUNT_OF_LS_DATA  512 // arbitrary, but allow for
                                                // prolix error text

//
// private types
//

typedef enum {
    State_Start,
    State_Error,
    State_Continue,
    State_Done
} PARSE_STATE;

typedef PARSE_STATE (*DIR_PARSER)(LPSTR*, LPDWORD, LPWIN32_FIND_DATA);

//
// private macros
//

#define ClearFileTime(fileTime) \
    (fileTime).dwLowDateTime = 0; \
    (fileTime).dwHighDateTime = 0;

#define ClearFindDataFields(lpFind) \
    ClearFileTime((lpFind)->ftCreationTime); \
    ClearFileTime((lpFind)->ftLastAccessTime); \
    (lpFind)->dwReserved0 = 0; \
    (lpFind)->dwReserved1 = 0; \
    (lpFind)->cAlternateFileName[0] = '\0';

//
// private prototypes
//

PRIVATE
BOOL
DetermineDirectoryFormat(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    OUT DIR_PARSER* ParserFunction
    );

PRIVATE
BOOL
IsNtDateFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    );

PRIVATE
BOOL
GetToken(
    IN LPSTR lpszBuffer,
    IN DWORD dwBufferLength,
    OUT LPSTR lpszToken,
    IN OUT LPDWORD lpdwTokenLength
    );

PRIVATE
BOOL
IsUnixAttributeFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    );

PRIVATE
PARSE_STATE
ParseNtDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
PARSE_STATE
ParseUnixDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
PARSE_STATE
ParseOs2Directory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
PARSE_STATE
ParseMacDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractFileSize(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
_ExtractFilename(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractNtDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractUnixDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ExtractOs2Attributes(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    );

PRIVATE
BOOL
ParseWord(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN WORD LowerBound,
    IN WORD UpperBound,
    OUT LPWORD lpNumber
    );

PRIVATE
BOOL
ExtractInteger(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    OUT LPINT lpNumber
    );

//
// private data
//

//
// DefaultSystemTime - if we fail to parse the time/date field for any reason,
// we will return this default time
//

PRIVATE static SYSTEMTIME DefaultSystemTime = {1980, 1, 0, 1, 12, 0, 0, 0};

//
// functions
//

DWORD
ParseDirList(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength,
    IN LPSTR lpszFilespec OPTIONAL,
    IN OUT PLIST_ENTRY lpList
    )

/*++

Routine Description:

    Creates a list of WIN32_FIND_DATA structures given the output from the LIST
    command run at the FTP server

Arguments:

    lpBuffer        - pointer to buffer containing LIST output

    lpBufferLength  - length of Buffer - no trailing \0

    lpszFilespec    - pointer to file specification used to generate listing.
                      May contain path components. May be NULL, in which case
                      we perform no filtering based on name (results should be
                      an exact match with request)

    lpList          - pointer to LIST_ENTRY list to add to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "ParseDirList",
                "%x, %d, %x",
                lpBuffer,
                dwBufferLength,
                lpList
                ));

    DWORD error;
    DIR_PARSER directoryParser;
    BOOL needBuffer;
    LPSTR lpszOriginalBuffer;
    DWORD dwOriginalBufferLength;

    //
    // remember the initial buffer pointer and length, in case we can't determine
    // the format - DetermineDirectoryFormat() will alter the input buffer pointer
    // and length
    //

    lpszOriginalBuffer = lpBuffer;
    dwOriginalBufferLength = dwBufferLength;

    //
    // find out the format of the directory listing. Currently we understand
    // NT and the basic Unix directory listing formats
    //

    if (!DetermineDirectoryFormat(&lpBuffer, &dwBufferLength, &directoryParser)) {

        DEBUG_PRINT(FTP,
                    ERROR,
                    ("Can't determine directory format\n"
                    ));

        //
        // if we received a relatively small amount of data, then there is a
        // good chance that what we actually received is an error message from
        // the ls command, or operating system, etc. Make it an extended error.
        // This will reduce (but not eliminate) the chances of getting back an
        // internal error
        //

        if (dwBufferLength <= RELATIVELY_SMALL_AMOUNT_OF_LS_DATA) {
            error = InternetSetLastError(0,
                                         lpszOriginalBuffer,
                                         dwOriginalBufferLength,
                                         SLE_APPEND | SLE_ZERO_TERMINATE
                                         );

            //
            // return internal error if we failed to add the text for any reason
            //

            error = (error == ERROR_SUCCESS)
                        ? ERROR_INTERNET_EXTENDED_ERROR
                        : ERROR_INTERNET_INTERNAL_ERROR
                        ;
        } else {

            //
            // BUGBUG - error code?
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // the list must be currently empty
    //

    INET_ASSERT(IsListEmpty(lpList));

    //
    // the app may have specified a path. Chances are that if there are
    // wildcards within the path then the server would have returned an
    // error. But if the app requested e.g. foo\bar\*.exe then the server
    // would have returned the directory results for foo\bar. Therefore,
    // we must skip any path components, or all tests against the filespec
    // will fail
    //

    if (ARGUMENT_PRESENT(lpszFilespec)) {

        LPSTR lpszSpec;

        lpszSpec = strrchr(lpszFilespec, '\\');
        if (lpszSpec == NULL) {
            lpszSpec = strrchr(lpszFilespec, '/');
        }
        if (lpszSpec != NULL) {
            lpszFilespec = lpszSpec + 1;
        }

        DEBUG_PRINT(FTP,
                    INFO,
                    ("lpszFilespec = %s\n",
                    lpszFilespec
                    ));

    }

    //
    // loop round, parsing the listing until we reach the end or get an
    // error
    //

    needBuffer = TRUE;
    error = ERROR_SUCCESS;
    while ((dwBufferLength != 0) && (error == ERROR_SUCCESS)) {

        PLIST_ENTRY dirEntry;
        LPWIN32_FIND_DATA lpFind;

        //
        // we need to allocate a buffer for the WIN32_FIND_DATA structure
        // unless we already have one from the previous iteration (because
        // the filename didn't match our target criteria)
        //

        if (needBuffer) {
            dirEntry = (PLIST_ENTRY)ALLOCATE_FIXED_MEMORY(
                                    sizeof(LIST_ENTRY) + sizeof(WIN32_FIND_DATA)
                                    );
            lpFind = (LPWIN32_FIND_DATA)(dirEntry + 1);
            needBuffer = FALSE;

            DEBUG_PRINT(FTP,
                        INFO,
                        ("Allocated WIN32_FIND_DATA @ %x\n",
                        lpFind
                        ));

        }
        if (dirEntry == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("Failed to allocate WIN32_FIND_DATA\n"
                        ));

        } else {

            PARSE_STATE state;

            //
            // zero initialize the WIN32_FIND_DATA fields we don't fill in
            // below
            //

            ClearFindDataFields(lpFind);

            //
            // and parse the rest of the information out of the returned FTP
            // directory listing
            //

            state = directoryParser(&lpBuffer, &dwBufferLength, lpFind);

            //
            // if the parser returns State_Continue or State_Done then we need
            // to add the structure to the list if the caller wants it, else we
            // free it and quit
            //

            if (state != State_Error) {

                BOOL addIt;

                //
                // before we put this entry on the list, see if the caller wants
                // it
                //

                if (ARGUMENT_PRESENT(lpszFilespec)) {
                    addIt = MyFsRtlIsNameInExpression(lpszFilespec,
                                                    lpFind->cFileName,
                                                    TRUE    // case-sensitive
                                                    );
                } else {
                    addIt = TRUE;
                }
                if (addIt) {

                    DEBUG_PRINT(FTP,
                                INFO,
                                ("Match: file %q, target %q\n",
                                lpFind->cFileName,
                                lpszFilespec
                                ));

                    InsertTailList(lpList, (PLIST_ENTRY)dirEntry);
                    needBuffer = TRUE;
                } else {

                    DEBUG_PRINT(FTP,
                                INFO,
                                ("No match: file %q, target %q\n",
                                lpFind->cFileName,
                                lpszFilespec
                                ));

                }
            }

            //
            // if we had an error or there's no more buffer to parse but we
            // didn't keep the last entry, then we need to free the unused
            // WIN32_FIND_DATA and get out
            //

            if ((state == State_Error) || ((state == State_Done) && !needBuffer)) {
                FREE_MEMORY(dirEntry);
                if (state == State_Error) {

                    DEBUG_PRINT(FTP,
                                ERROR,
                                ("State_Error\n"
                                ));

                    //
                    // BUGBUG - error code
                    //

                    error = ERROR_INTERNET_INTERNAL_ERROR;
                }
            }
        }
    }

quit:

    //
    // if we had an error then free up any data structures that we allocated
    //

    if (error != ERROR_SUCCESS) {
        ClearFindList(lpList);
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
IsFilespecWild(
    IN LPCSTR lpszFilespec
    )

/*++

Routine Description:

    Returns TRUE if lpszFilespec is a wild-card file specifier

Arguments:

    lpszFilespec    - pointer to string containing file specification. Cannot
                      be a NULL string

Return Value:

    BOOL

--*/

{
    int len;
    int i;

    INET_ASSERT(ARGUMENT_PRESENT(lpszFilespec));

    //
    // check if the file specifier contains a '*' or a '?'. If so, then the
    // caller is making a DOS-style search request and we have to perform our
    // own filtering, otherwise, we can leave the server to return what the
    // caller asked for
    //

    for (i = 0, len = strlen(lpszFilespec); i < len; ++i) {
        if ((lpszFilespec[i] == '*') || (lpszFilespec[i] == '?')) {
            return TRUE;
        }
    }
    return FALSE;
}


VOID
ClearFindList(
    IN PLIST_ENTRY lpList
    )

/*++

Routine Description:

    Dequeues and deallocates all WIN32_FIND_DATA structures on a directory list

Arguments:

    lpList  - pointer to list to clear

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_FTP,
                None,
                "ClearFindList",
                "%x",
                lpList
                ));

    while (!IsListEmpty(lpList)) {

        PLIST_ENTRY lpHead;

        lpHead = RemoveHeadList(lpList);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("Freeing WIN32_FIND_DATA @ %x, FileName=%q\n",
                    lpHead,
                    ((LPWIN32_FIND_DATA)(lpHead + 1))->cFileName
                    ));

        FREE_MEMORY(lpHead);
    }

    DEBUG_LEAVE(0);
}

//
// private functions
//


PRIVATE
BOOL
DetermineDirectoryFormat(
    IN LPSTR* lpBuffer,
    IN LPDWORD lpdwBufferLength,
    OUT DIR_PARSER* lpfnParserFunction
    )

/*++

Routine Description:

    Determines whether the directory listing is in Unix or NT (or other?) format
    and returns a pointer to the parser function to use

    The buffer pointer and length may be adjusted past any prologue information

Arguments:

    lpBuffer            - pointer to pointer to buffer containing directory
                          listing

    lpdwBufferLength    - pointer to length of Buffer

    lpfnParserFunction  - returned directory parser function

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Bool,
                "DetermineDirectoryFormat",
                "%x [%.40q], %x [%d], %x",
                lpBuffer,
                *lpBuffer,
                lpdwBufferLength,
                *lpdwBufferLength,
                lpfnParserFunction
                ));

    BOOL success;

    if (!SkipWhitespace(lpBuffer, lpdwBufferLength)) {
        success = FALSE;
        goto quit;
    }

    if (IsNtDateFormat(*lpBuffer, *lpdwBufferLength)) {

        DEBUG_PRINT(FTP,
                    INFO,
                    ("format is NT\n"
                    ));

        *lpfnParserFunction = ParseNtDirectory;
        success = TRUE;
        goto quit;
    }

    //
    // we think the directory output is from Unix. The listing probably
    // starts with "total #" or a number, or other random garbage. We
    // know that a Unix dir listing starts with the ls attributes, so
    // we'll search for those, but keep our search within a reasonable
    // distance of the start
    //

    LPSTR buffer;
    DWORD length;
    char tokenBuffer[TOKEN_BUFFER_LENGTH];
    int lengthChecked;
    int iteration;
    int dataLength;

    buffer = *lpBuffer;
    length = *lpdwBufferLength;
    lengthChecked = 0;
    iteration = 0;
    dataLength = min((int)*lpdwBufferLength, RELATIVELY_SMALL_AMOUNT_OF_LS_DATA);

    while (lengthChecked < dataLength) {

        DWORD tokenLength;
        DWORD previousLength;

        tokenLength = sizeof(tokenBuffer);
        if (!GetToken(buffer,
                      length,
                      tokenBuffer,
                      &tokenLength)) {
            success = FALSE;
            goto quit;
        }
        lengthChecked += tokenLength;
        if (IsUnixAttributeFormat(tokenBuffer, tokenLength)) {

            DEBUG_PRINT(FTP,
                        INFO,
                        ("format is Unix\n"
                        ));

            *lpfnParserFunction = ParseUnixDirectory;
            *lpBuffer = buffer;
            *lpdwBufferLength = length;
            success = TRUE;
            goto quit;
        } else if ((iteration == 0)
        && (tokenLength == 5)
        && !strnicmp(tokenBuffer, "total", 5)) {

            //
            // there may be nothing in the directory listing, except
            // "total 0". If this is this case, then we recognize the
            // format
            //

            buffer += tokenLength;
            length -= tokenLength;
            tokenLength = sizeof(tokenBuffer) - 1;  // for '\0'
            if (!GetToken(buffer,
                          length,
                          tokenBuffer,
                          &tokenLength)) {
                success = FALSE;
                goto quit;
            }
            tokenBuffer[tokenLength] = '\0';
            if (isdigit(tokenBuffer[0]) && (atoi(tokenBuffer) == 0)) {

                DEBUG_PRINT(FTP,
                            INFO,
                            ("format is Unix - empty directory\n"
                            ));

                *lpfnParserFunction = ParseUnixDirectory;
                SkipLine(&buffer, &length);
                *lpBuffer = buffer;
                *lpdwBufferLength = length;
                success = TRUE;
                goto quit;
            }
        }

        //
        // try the next line
        //

        previousLength = length;
        SkipLine(&buffer, &length);
        lengthChecked += previousLength - length;
        ++iteration;
    }

    //
    // not NT or Unix. Lets try for OS/2. The format of an OS/2 directory entry
    // is:
    //
    //      [<ws>]<length>[DIR|<attribute>]<date><time><filename>
    //
    // we just try to parse the first line. If this succeeds, we assume OS/2
    // format
    //

    WIN32_FIND_DATA findData;
    PARSE_STATE state;

    buffer = *lpBuffer;
    length = *lpdwBufferLength;
    state = ParseOs2Directory(&buffer, &length, &findData);
    if ((state == State_Continue) || (state == State_Done)) {

        DEBUG_PRINT(FTP,
                    INFO,
                    ("format is OS/2\n"
                    ));

        success = TRUE;
        *lpfnParserFunction = ParseOs2Directory;
        goto quit;
    }

    //
    // Mac? Mac servers return Unix-like output which will (should) have already
    // been handled by the Unix listing check, and a very simple format which
    // just consists of names with an optional '/' appended, indicating a
    // directory
    //

    //
    // the Telnet 2.6 FTP server (which just reports the ultra-simple listing
    // format) returns a weird 'hidden' entry at the start of the listing which
    // consists of "\x03\x02\x01". We will skip all leading control characters
    //

    buffer = *lpBuffer;
    length = *lpdwBufferLength;
    while (length && (*buffer < ' ')) {
        ++buffer;
        --length;
    }

    LPSTR buffer_;
    DWORD length_;

    buffer_ = buffer;
    length_ = length;

    state = ParseMacDirectory(&buffer, &length, &findData);
    if ((state == State_Continue) || (state == State_Done)) {

        DEBUG_PRINT(FTP,
                    INFO,
                    ("format is Mac\n"
                    ));

        *lpBuffer = buffer_;
        *lpdwBufferLength = length_;
        success = TRUE;
        *lpfnParserFunction = ParseMacDirectory;
        goto quit;
    }

    //
    // failed to determine the format
    //

    success = FALSE;

quit:

    DEBUG_LEAVE(success);

    return success;
}


PRIVATE
BOOL
IsNtDateFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Determines if the directory listing starts with an NT-style date field:

        MM-DD-YY

Arguments:

    lpBuffer        - pointer to buffer containing listing

    dwBufferLength  - number of bytes in lpBuffer

Return Value:

    BOOL
        TRUE    - buffer starts with NT-style date format

        FALSE   - not NT-listing

--*/

{
    if (dwBufferLength > 8) {

        LPSTR buffer;
        WORD number;

        buffer = lpBuffer;
        if (!ParseWord(&buffer, &dwBufferLength, 1, 12, &number)) {
            return FALSE;
        }
        if (!((dwBufferLength > 0) && (*buffer == '-'))) {
            return FALSE;
        }
        ++buffer;
        --dwBufferLength;
        if (!ParseWord(&buffer, &dwBufferLength, 1, 31, &number)) {
            return FALSE;
        }
        if (!((dwBufferLength > 0) && (*buffer == '-'))) {
            return FALSE;
        }
        ++buffer;
        --dwBufferLength;
        return ParseWord(&buffer, &dwBufferLength, 0, MAX_YEAR_SUPPORTED, &number);
    }
    return FALSE;
}


PRIVATE
BOOL
GetToken(
    IN LPSTR lpszBuffer,
    IN DWORD dwBufferLength,
    OUT LPSTR lpszToken,
    IN OUT LPDWORD lpdwTokenLength
    )

/*++

Routine Description:

    Copies a token out of the buffer without updating the buffer pointer or length

Arguments:

    lpszBuffer      - pointer to buffer to copy from

    lpBufferLength  - length of buffer

    lpszToken       - buffer to copy to

    lpdwTokenLength - length of buffer on input, length of token on output

Return Value:

    BOOL

--*/

{
    DWORD length;

    if (!SkipSpaces(&lpszBuffer, &dwBufferLength)) {
        return FALSE;
    }

    if (dwBufferLength == 0) {
        return FALSE;
    }

    length = *lpdwTokenLength;
    while (!isspace(*lpszBuffer) && (dwBufferLength != 0) && (length != 0)) {
        *lpszToken++ = *lpszBuffer++;
        --dwBufferLength;
        --length;
    }
    *lpdwTokenLength -= length;
    return TRUE;
}


PRIVATE
BOOL
IsUnixAttributeFormat(
    IN LPSTR lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Checks if the buffer contains a Unix ls attribute field format

Arguments:

    lpBuffer        - pointer to buffer containing token to check

    dwBufferLength  - length of buffer

Return Value:

    BOOL
        TRUE    - lpBuffer *probably* contained a Unix attribute field
        FALSE   - lpBuffer *probably didn't* contain a Unix attribute field

--*/

{
    int i;
    int hits;

    if (dwBufferLength != 10) {
        return FALSE;
    }

    //
    // the first character contains 'd' for directory, 'l' for link, '-' for
    // file, and may contain other, unspecified characters, so we just ignore
    // it. So long as the next 9 characters are in the set [-rwx] then we have
    // a Unix ls attribute field.
    //
    // N.B. it turns out that the first character can be in the set [-bcdlp]
    // and the attribute characters can be in the set [-lrsStTwx] (as of
    // 08/18/95)
    //

    ++lpBuffer;
    hits = 0;
    for (i = 0; i < 9; ++i) {

        char ch;

        ch = tolower(*lpBuffer);
        ++lpBuffer;

        if ((ch == '-')
        || (ch == 'l')
        || (ch == 'r')
        || (ch == 's')
        || (ch == 't')
        || (ch == 'w')
        || (ch == 'x')) {
            ++hits;
        }
    }

    //
    // new scheme: we decide if the token was a Unix attribute field based on
    // probability. If the hit rate was greater than 1 in 2 (5 out of 9 or
    // higher) then we say that the field was probably a Unix attribute. This
    // scheme allows us to accept future enhancements or non-standard Unix
    // implementations without changing this code (for a while) (Make the
    // attribute set a registry value (!))
    //

    return hits >= 5;
}


PRIVATE
PARSE_STATE
ParseNtDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of an NT directory listing (output from DIR) into a
    WIN32_FIND_DATA structure

    The format of an NT directory list line is:

    <date> <time> <'<DIR>'|<size>> <filename>

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

--*/

{
    //
    // not expecting the line to start with spaces, but we check anyway
    //

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto done;
    }

    if (!ExtractNtDate(lpBuffer, lpBufferLength, lpFindData)) {
        goto done;
    }

    if (!strnicmp(*lpBuffer, "<DIR>", 5)) {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        lpFindData->nFileSizeHigh = 0;
        lpFindData->nFileSizeLow = 0;
        FindToken(lpBuffer, lpBufferLength);
    } else {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        ExtractFileSize(lpBuffer, lpBufferLength, lpFindData);
        SkipSpaces(lpBuffer, lpBufferLength);
    }

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    //
    // we expect the filename to be the last thing on the line
    //

done:

    return SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;
}


PRIVATE
void
ReadUnixPermissions(
    IN LPCSTR pszBuffer,
    IN DWORD cbBufferSize,
    OUT LPDWORD pdwPermissions)
{
    // Format: rwxrwxrwx <Owner><Group><All>
    *pdwPermissions = 0;

    if (cbBufferSize > 10)
    {
        if ('r' == pszBuffer[1])
            *pdwPermissions |= 0x00000400;

        if ('w' == pszBuffer[2])
            *pdwPermissions |= 0x00000200;

        if ('x' == pszBuffer[3])
            *pdwPermissions |= 0x00000100;

        if ('r' == pszBuffer[4])
            *pdwPermissions |= 0x00000040;

        if ('w' == pszBuffer[5])
            *pdwPermissions |= 0x00000020;

        if ('x' == pszBuffer[6])
            *pdwPermissions |= 0x00000010;

        if ('r' == pszBuffer[7])
            *pdwPermissions |= 0x00000004;

        if ('w' == pszBuffer[8])
            *pdwPermissions |= 0x00000002;

        if ('x' == pszBuffer[9])
            *pdwPermissions |= 0x00000001;
    }
}


PRIVATE
PARSE_STATE
ParseUnixDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of a Unix directory listing (output from ls) into a
    WIN32_FIND_DATA structure

    The format of a Unix directory list line is:

    <attributes> <link-count> <owner> <group> <size> <date-time> <filename>

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

--*/

{
    DWORD error;
    int i;
    BOOL symbolicLink;
    char ch;

    //
    // not expecting the line to start with spaces, but we check anyway
    //

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto done;
    }

    //
    // if the item is a symbolic link then we have to trim the 'filename' below
    //

    ch = tolower(**lpBuffer);
    symbolicLink = (ch == 'l');

    //
    // attributes are first thing on line
    //

    lpFindData->dwFileAttributes = (ch == 'd') ? FILE_ATTRIBUTE_DIRECTORY
                                 : (ch == '-') ? FILE_ATTRIBUTE_NORMAL
                                 : 0;

    //
    // skip over the attributes and over the owner/creator fields to the file
    // size
    //

    // Read the Attributes and put them in the WIN32_FIND_DATA.dwReserved0 attributes.
    // It's OK to use FILE_ATTRIBUTE_REPARSE_POINT because it's unused unless
    // WIN32_FIND_DATA.dwFileAttributes contains yyy, which we don't set.
    ReadUnixPermissions(*lpBuffer, *lpBufferLength, &(lpFindData->dwReserved0));

    LPSTR lpszLastToken;
    DWORD dwLastToken;

    for (i = 0; i < 4; ++i) {
        lpszLastToken = *lpBuffer;
        dwLastToken = *lpBufferLength;
        if (!FindToken(lpBuffer, lpBufferLength)) {
            goto done;
        }
    }

    if (!ExtractFileSize(lpBuffer, lpBufferLength, lpFindData)) {
        ExtractFileSize(&lpszLastToken, &dwLastToken, lpFindData);
    }

    SkipSpaces(lpBuffer, lpBufferLength);

    if (!ExtractUnixDate(lpBuffer, lpBufferLength, lpFindData)) {
        goto done;
    }

    SkipSpaces(lpBuffer, lpBufferLength);

    //
    // we expect the filename to be the last thing on the line
    //

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    //
    // if the item is a symbolic link, then remove everything after the " -> "
    //

    if (symbolicLink) {

        LPSTR lpArrow;

        lpArrow = strstr(lpFindData->cFileName, " -> ");
        if (lpArrow != NULL) {
            *lpArrow = '\0';
        }
    }

done:

    return SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;
}


PRIVATE
PARSE_STATE
ParseOs2Directory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of an OS/2 directory listing (output from dir) into a
    WIN32_FIND_DATA structure

    The format of an OS/2 directory list line is:

    <size> <attributes> <date> <time> <filename>

    This function is also used to determine OS/2 directory format

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

        State_Error     - directory format not recognized
--*/

{
    PARSE_STATE state;

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto skip;
    }

    if (!ExtractFileSize(lpBuffer, lpBufferLength, lpFindData)) {
        state = State_Error;
        goto done;
    }

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto skip;
    }

    if (!strnicmp(*lpBuffer, "DIR", 3)) {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        FindToken(lpBuffer, lpBufferLength);
    } else if (!isdigit(**lpBuffer)) {
        if (!ExtractOs2Attributes(lpBuffer, lpBufferLength, lpFindData)) {
            state = State_Error;
            goto done;
        }
        SkipSpaces(lpBuffer, lpBufferLength);
    } else {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    if (!ExtractNtDate(lpBuffer, lpBufferLength, lpFindData)) {
        state = State_Error;
        goto done;
    }

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    //
    // we expect the filename to be the last thing on the line
    //

skip:

    state = SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;

done:

    return state;
}


PRIVATE
PARSE_STATE
ParseMacDirectory(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Parses a single line of a Mac directory listing (output from ls) into a
    WIN32_FIND_DATA structure

    The format of a Mac directory list line is:

    <dir-or-file-name>[/]

    This function is also used to determine Mac directory format

Arguments:

    lpBuffer        - pointer to pointer to directory listing

    lpBufferLength  - pointer to number of bytes remaining in lpBuffer

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    PARSE_STATE
        State_Continue  - more listing to parse

        State_Done      - fin!

        State_Error     - directory format not recognized

--*/

{
    PARSE_STATE state;

    if (!SkipSpaces(lpBuffer, lpBufferLength)) {
        goto skip;
    }

    _ExtractFilename(lpBuffer, lpBufferLength, lpFindData);

    int len;

    len = lstrlen(lpFindData->cFileName);
    if (lpFindData->cFileName[len - 1] == '/') {
        lpFindData->cFileName[len - 1] = '\0';
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    } else {
        lpFindData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
    }
    if ((*lpBufferLength != 0)
    && !((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        state = State_Error;
        goto done;
    }

    //
    // this directory format has no size or time information
    //

    lpFindData->nFileSizeLow = 0;
    lpFindData->nFileSizeHigh = 0;
    SystemTimeToFileTime(&DefaultSystemTime, &lpFindData->ftLastWriteTime);

    //
    // we expect the filename to be the last thing on the line
    //

skip:

    state = SkipLine(lpBuffer, lpBufferLength) ? State_Continue : State_Done;

done:

    return state;
}


PRIVATE
BOOL
ExtractFileSize(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts the the next token in the directory listing. The next token is
    expected to be the file size. It is extracted to the WIN32_FIND_DATA
    structure

    Assumes:    1. The file size is <= 32 bits

Arguments:

    lpBuffer        - pointer to pointer to directory listing buffer

    lpBufferLength  - pointer to remaining buffer length

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL

--*/

{
    INET_ASSERT(*lpBufferLength != 0);

    LPSTR buffer;
    char ch = **lpBuffer;

    if (isdigit(ch)) {
        lpFindData->nFileSizeLow = strtoul(*lpBuffer, &buffer, 10);
        lpFindData->nFileSizeHigh = 0;
        *lpBufferLength -= (DWORD) (buffer - *lpBuffer);
        *lpBuffer = buffer;
        return TRUE;
    }
    return FALSE;
}


PRIVATE
BOOL
_ExtractFilename(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts the filename from the current directory listing position into the
    WIN32_FIND_DATA structure

Arguments:

    lpBuffer        - pointer to pointer to directory listing buffer

    lpBufferLength  - pointer to remaining buffer length

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL

--*/

{
    LPSTR dest;
    DWORD destLength;

    dest = lpFindData->cFileName;
    destLength = sizeof(lpFindData->cFileName) - 1;
    while ((*lpBufferLength != 0)
    && (destLength != 0)
    && !((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        *dest++ = *(*lpBuffer)++;
        --*lpBufferLength;
        --destLength;
    }
    *dest = '\0';
    return TRUE;
}


PRIVATE
BOOL
ExtractNtDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts an NT date and time from the directory listing. NT dates have a
    specific format:

        MM-DD-YY hh:mmPP

Arguments:

    lpBuffer        - pointer to pointer to current position in directory list

    lpBufferLength  - number of bytes til end of directory list

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    SYSTEMTIME systemTime;
    LPSTR buffer;
    DWORD buflen;
    int number;
    LPSTR stop;
    LPSYSTEMTIME lpSystemTime;

    lpSystemTime = &DefaultSystemTime;

    //
    // BUGBUG - what about internationalization? E.g. does UK FTP server return
    //          the date as e.g. 27/07/95? Other formats?
    //

    //
    // month ::= 1..12
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 1, 12, &systemTime.wMonth)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == '-'))) {
        goto done;
    }
    ++*lpBuffer;
    --*lpBufferLength;

    //
    // date ::= 1..31
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 1, 31, &systemTime.wDay)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == '-'))) {
        goto done;
    }
    ++*lpBuffer;
    --*lpBufferLength;

    //
    // year ::= 0..2100
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, MAX_YEAR_SUPPORTED, &systemTime.wYear)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == ' '))) {
        goto done;
    }

    //
    // the oldest file can be dated 1980. We allow the following:
    //
    //  1-1-79              => 1-1-2079
    //  1-1-80..12-31-99    => 1-1-1980..12-31-1999
    //  1-1-00              => 1-1-2000
    //  1-1-1995            => 1-1-1995
    //  1-1-2001            => 1-1-2001
    //  etc.
    //

    systemTime.wYear += (systemTime.wYear < 80)
                        ? 2000
                        : (systemTime.wYear <= 99)
                            ? 1900
                            : 0
                            ;

    //
    // find start of time (er, Professor Hawking..?)
    //

    if (!FindToken(lpBuffer, lpBufferLength)) {
        goto done;
    }

    //
    // hour ::= 0..23 | 1..12
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, 23, &systemTime.wHour)) {
        goto done;
    }
    if (!((*lpBufferLength > 0) && (**lpBuffer == ':'))) {
        goto done;
    }
    ++*lpBuffer;
    --*lpBufferLength;

    //
    // minute ::= 0..59
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, 59, &systemTime.wMinute)) {
        goto done;
    }

    //
    // if the time is followed by AM or PM then convert to 24-hour time if PM
    // and skip to end of token in both cases
    //

    if (*lpBufferLength >= 2) {

        char ch_p;

        ch_p = tolower(**lpBuffer);
        if ((ch_p == 'p') || (ch_p == 'a')) {

            char ch_m;

            ch_m = tolower(*(*lpBuffer + 1));
            if ((ch_p == 'p') && (ch_m == 'm')) {
                // 12 PM = 12, 1PM = 13, 2PM = 14, etc
                if ( systemTime.wHour < 12 ) {
                    systemTime.wHour += 12;
                }
            } else if ( systemTime.wHour == 12 ) {
                // 12 AM == 0:00 24hr
                INET_ASSERT((ch_p == 'a') && (ch_m == 'm'));
                systemTime.wHour = 0;
            }
        }
    }

    //
    // seconds, milliseconds and weekday always zero
    //

    systemTime.wSecond = 0;
    systemTime.wMilliseconds = 0;
    systemTime.wDayOfWeek = 0;

    //
    // get ready to convert the parsed date/time to a FILETIME
    //

    lpSystemTime = &systemTime;

done:

    //
    // convert the system time to file time and move the buffer pointer/length
    // to the next line
    //

    if (!SystemTimeToFileTime(lpSystemTime, &lpFindData->ftLastWriteTime)) {
        SystemTimeToFileTime(&DefaultSystemTime, &lpFindData->ftLastWriteTime);
    }
    FindToken(lpBuffer, lpBufferLength);
    return TRUE;
}


PRIVATE
BOOL
ExtractUnixDate(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Extracts a Unix date and time from the directory listing. Unix dates have a
    multitude of formats:

        Jul  3 14:52
        Oct  7 1994
        Jul 26  4:05
        Jul 26 03:51

Arguments:

    lpBuffer        - pointer to pointer to current position in directory list

    lpBufferLength  - number of bytes til end of directory list

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    SYSTEMTIME systemTime;
    LPSYSTEMTIME lpSystemTime;
    static LPSTR Months = "janfebmaraprmayjunjulaugsepoctnovdec";
    char monthStr[4];
    int i;
    LPSTR offset;
    WORD wnum;

    lpSystemTime = &DefaultSystemTime;

    //
    // month ::= Jan..Dec
    //

    for (i = 0; i < 3; ++i) {
        if (*lpBufferLength == 0) {
            goto done;
        }
        monthStr[i] = *(*lpBuffer)++;
        monthStr[i] = tolower(monthStr[i]);
        --*lpBufferLength;
    }
    monthStr[i] = '\0';
    offset = strstr(Months, monthStr);
    if (offset == NULL) {
        goto done;
    }
    systemTime.wMonth = (unsigned short) ((offset-Months) / 3 + 1);

    FindToken(lpBuffer, lpBufferLength);

    //
    // date ::= 1..31
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 1, 31, &systemTime.wDay)) {
        goto done;
    }

    SkipSpaces(lpBuffer, lpBufferLength);

    //
    // year or hour
    //

    if (!ParseWord(lpBuffer, lpBufferLength, 0, 65535, &wnum)) {
        goto done;
    }

    if ((*lpBufferLength != 0) && (**lpBuffer == ':')) {

        SYSTEMTIME timeNow;

        systemTime.wHour = wnum;

        //
        // we found the hour field, now get the minutes
        //

        ++*lpBuffer;
        --*lpBufferLength;
        if (!ParseWord(lpBuffer, lpBufferLength, 0, 59, &systemTime.wMinute)) {
            goto done;
        }

        //
        // a date-time with an hour:minute field is based in this year. We need
        // to get the current year from the system. There is a slight problem in
        // that if this machine's just had a new year and the FTP server is
        // behind us, then the file can be a year out of date.
        //
        // There is no guarantees about the basis of time used by the FTP server,
        // so we'll get the UTC (aka Greenwich Mean Time) time
        //

        GetSystemTime(&timeNow);
        systemTime.wYear = timeNow.wYear;

        if(!GlobalBypassFtpTimeCheck)
        {
            //
            // apparently its not quite as straightforward as first we'd believed.
            // If the date/month is in the future then the year is last year
            //

            BOOL bLastYear = FALSE;

            if (systemTime.wMonth > timeNow.wMonth) {
                bLastYear = TRUE;
            } else if (systemTime.wMonth == timeNow.wMonth) {

                //
                // BUGBUG - leap year? I believe that in this case, because the time
                //          difference is 1 year minus 1 day, then that is great
                //          enough for the date format including year to have been
                //          used and thus making this moot. Need to prove it.
                //          Note, by that logic, everything from here on down should
                //          also be moot - we should only have to concern ourselves
                //          with the month
                //

                if (systemTime.wDay > timeNow.wDay) {
                    bLastYear = TRUE;
                } else if (systemTime.wDay == timeNow.wDay) {
                    if (systemTime.wHour > timeNow.wHour) {
                        bLastYear = TRUE;
                    } else if (systemTime.wHour == timeNow.wHour) {
                        if (systemTime.wMinute > timeNow.wMinute) {
                            bLastYear = TRUE;
                        } else if (systemTime.wMinute == timeNow.wMinute) {
                            if (systemTime.wSecond > timeNow.wSecond) {
                                bLastYear = TRUE;
                            }
                        }
                    }
                }
            }
            if (bLastYear) {
                --systemTime.wYear;
            }
        }
    } else {

        //
        // next field is the year
        //

        systemTime.wYear = wnum;

        //
        // time for a file with only a year is 00:00 (mitternacht)
        //

        systemTime.wHour = 0;
        systemTime.wMinute = 0;
    }

    //
    // seconds, milliseconds and weekday always zero
    //

    systemTime.wSecond = 0;
    systemTime.wMilliseconds = 0;
    systemTime.wDayOfWeek = 0;

    //
    // get ready to convert the parsed date/time to a FILETIME
    //

    lpSystemTime = &systemTime;

done:

    //
    // convert the system time to file time and move the buffer pointer/length
    // to the next line
    //

    if (!SystemTimeToFileTime(lpSystemTime, &lpFindData->ftLastWriteTime)) {
        SystemTimeToFileTime(&DefaultSystemTime, &lpFindData->ftLastWriteTime);
    }
    FindToken(lpBuffer, lpBufferLength);
    return TRUE;
}


PRIVATE
BOOL
ExtractOs2Attributes(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN OUT LPWIN32_FIND_DATA lpFindData
    )

/*++

Routine Description:

    Converts an OS/2 attribute string into Win32 file attribute flags in the
    WIN32_FIND_DATA structure

Arguments:

    lpBuffer        - pointer to pointer to current position in directory list

    lpBufferLength  - number of bytes til end of directory list

    lpFindData      - pointer to WIN32_FIND_DATA to update

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DWORD attributes = 0;
    BOOL done = FALSE;

    while (*lpBufferLength && !done) {

        char ch = **lpBuffer;

        switch (toupper(ch)) {
        case 'A':
            attributes |= FILE_ATTRIBUTE_ARCHIVE;
            break;

        case 'H':
            attributes |= FILE_ATTRIBUTE_HIDDEN;
            break;

        case 'R':
            attributes |= FILE_ATTRIBUTE_READONLY;
            break;

        case 'S':
            attributes |= FILE_ATTRIBUTE_SYSTEM;
            break;

        case ' ':

            //
            // if there is only one space, we will be pointing at the next token
            // after this function completes. Okay so long as we will be calling
            // SkipSpaces() next (which doesn't expect to be pointing at a space)
            //

            done = TRUE;
            break;
        }
        --*lpBufferLength;
        ++*lpBuffer;
    }

    //
    // if we are here there must have been some characters which looked like
    // OS/2 file attributes
    //

    INET_ASSERT(attributes != 0);

    lpFindData->dwFileAttributes = attributes;

    return TRUE;
}


PRIVATE
BOOL
ParseWord(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    IN WORD LowerBound,
    IN WORD UpperBound,
    OUT LPWORD lpNumber
    )

/*++

Routine Description:

    Extract a WORD value out of the buffer. To be correctly parsed the number
    field must:

        * start with numeric characters
        * not be negative
        * be >= LowerBound and <= UpperBound
        * must end with a non-numeric character or when the buffer is exhausted

Arguments:

    lpBuffer        - pointer to pointer to buffer containing number to parse

    lpBufferLength  - pointer to remaining length in buffer

    LowerBound      - lowest value converted number can have

    UpperBound      - highest value converted number can have

    lpNumber        - pointer to returned WORD value

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    int number;

    if (ExtractInteger(lpBuffer, lpBufferLength, &number)) {
        if ((number >= (int)LowerBound) && (number <= (int)UpperBound)) {
            *lpNumber = (WORD)number;
            return TRUE;
        }
    }
    return FALSE;
}


PRIVATE
BOOL
ExtractInteger(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength,
    OUT LPINT lpNumber
    )

/*++

Routine Description:

    Performs a strtoul type function, but the input string is not terminated by
    \0. It has an associated length

Arguments:

    lpBuffer        - pointer to pointer to string containing number to extract

    lpBufferLength  - pointer to length of string remaining in lpBuffer

    lpNumber        - pointer to returned value

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    BOOL success;
    int number;

    number = 0;
    if ((*lpBufferLength > 0) && isdigit(**lpBuffer)) {
        while (isdigit(**lpBuffer) && (*lpBufferLength != 0)) {
            number = number * 10 + (int)(**lpBuffer - '0');
            ++*lpBuffer;
            --*lpBufferLength;
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpNumber = number;
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpapir.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapir.h

Abstract:

    Prototypes etc. for ftpapir.c

Author:

    Richard L Firth (rfirth) 09-Mar-1995

Revision History:

    09-Mar-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
wFtpFindFirstFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    OUT LPHINTERNET lphInternet
    );

DWORD
wFtpDeleteFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName
    );

DWORD
wFtpRenameFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    );

DWORD
wFtpOpenFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    );

DWORD
wFtpCreateDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );

DWORD
wFtpRemoveDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );

DWORD
wFtpSetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );

DWORD
wFtpGetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN DWORD cchCurrentDirectory,
    OUT LPSTR lpszCurrentDirectory,
    OUT LPDWORD lpdwBytesReturned
    );

DWORD
wFtpCommand(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwTransferType,
    IN LPCSTR lpszCommand
    );

DWORD
wFtpFindNextFile(
    IN HINTERNET hFtpSession,
    OUT LPWIN32_FIND_DATA lpFindFileData
    );

DWORD
wFtpFindClose(
    IN HINTERNET hFtpSession
    );

DWORD
wFtpReadFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD nNumberOfBytesToRead,
    OUT LPDWORD lpNumberOfBytesRead
    );

DWORD
wFtpWriteFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD nNumberOfBytesToWrite,
    OUT LPDWORD lpNumberOfBytesWritten
    );

DWORD
wFtpCloseFile(
    IN HINTERNET hFtpSession
    );

DWORD
wFtpGetFileSize(
    IN  HINTERNET hMappedFtpSession,
    IN  LPFTP_SESSION_INFO lpSessionInfo,
    OUT LPDWORD lpdwFileSizeLow,
    OUT LPDWORD lpdwFileSizeHigh
    );

DWORD
wFtpFindServerType(
    IN HINTERNET hFtpSession
    );

HINTERNET
InternalFtpFindFirstFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL  fCacheOnly,
    IN BOOL  fAllowEmpty = FALSE
    );

HINTERNET
InternalFtpOpenFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fCacheOnly
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpapih.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapih.h

Abstract:

    Precompiled include header

Author:

    Richard L Firth (rfirth) 21-Dec-1994

Revision History:

    21-Dec-1994 rfirth
        Created

--*/

#include "dirlist.h"
#include "ftphelp.h"
#include "name.h"
#include "nvt.h"
#include "session.h"
#include "ftpapir.h"
#include "protocol.h"
#include "tcputil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapia.cxx

Abstract:

    ANSI versions of Windows Internet Client DLL FTP APIs

    Contents:
        FtpFindFirstFileA
        FtpGetFileA
        FtpPutFileA
        FtpDeleteFileA
        FtpRenameFileA
        FtpOpenFileA
        FtpCreateDirectoryA
        FtpRemoveDirectoryA
        FtpSetCurrentDirectoryA
        FtpGetCurrentDirectoryA
        FtpCommandA
        FtpGetFileSize
        FtpGetSystemNameA
        FtpFindNextFileA
        FtpReadFile
        FtpWriteFile
        pFtpGetUrlString

Author:

    Heath Hunnicutt [t-heathh] 13-Jul-1994

Environment:

    Win32 user-level DLL

Revision History:

    09-Mar-1995 rfirth
        moved from findfile.c, ftphelp.c

    13-Jul-1994 t-heathh
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// manifests
//

#define DEFAULT_TRANSFER_BUFFER_LENGTH  (4 K)

#define ALLOWED_FTP_FLAGS               (INTERNET_FLAGS_MASK \
                                        | FTP_TRANSFER_TYPE_MASK \
                                        )

//
// private prototypes
//

PRIVATE
BOOL
FBeginCacheReadProcessing(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL  fIsHtmlFind
    );

PRIVATE
BOOL
FFtpCanReadFromCache(
    IN HINTERNET hFtpSession
    );

PRIVATE
BOOL
FBeginCacheWriteProcessing(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL  fIsHtmlFind
    );

PRIVATE
BOOL
FFtpCanWriteToCache(
    HINTERNET   hFtpSession
    );

DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

PRIVATE
BOOL
FGetCWDFromCache(
    HINTERNET   hFtpSession,
    LPSTR       lpBuff,
    LPDWORD     lpdwBuffSize
    );

PRIVATE
BOOL
FIsFtpExpired(
    HINTERNET   handle,
    LPCACHE_ENTRY_INFO  lpCEI
    );

VOID
LocalSetObjectName(
    HINTERNET hFtpMapped,
    LPSTR   lpszFileName
    );

PRIVATE
BOOL
IsSearchFileDirectory(
    LPCSTR   lpszFileDirName
);

//
// functions
//


INTERNETAPI_(HINTERNET) FtpFindFirstFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Download the remote site's directory listing and parse it into
    WIN32_FIND_DATA structures that we can pass back to the app.

    If the FTP session is currently involved in a data transfer, such as
    a FtpOpenFile()....FtpCloseFile() series of calls, this function will
    fail.

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpOpen()

    lpszSearchFile  - Pointer to a string containing a file specification
                      that constrains the search.  (e.g., "*.txt"). A NULL
                      pointer is treated the same as an empty string

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds. If this parameter
                      is NULL, then we can still return success, but all find
                      information will be returned via InternetFindNextFile()

    dwFlags         - controlling caching, etc.

    dwContext       - app-supplied context value for call-backs

Return Value:

    HINTERNET
        Success - new find handle

        Failure - NULL. Call GetLastError() for more information:

                    ERROR_INVALID_HANDLE
                        The session handle is not recognized

                    ERROR_FTP_TRANSFER_IN_PROGRESS
                        The data connection is already in use

                    ERROR_NO_MORE_FILES
                        The end of the directory listing has been reached

                    ERROR_INTERNET_EXTENDED_ERROR
                        Call InternetGetLastResponseInfo() for the text

                    ERROR_INTERNET_INTERNAL_ERROR
                        Something bad happened

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpFindFirstFileA",
                     "%#x, %.80q, %#x, %#x, %#x",
                     hFtpSession,
                     lpszSearchFile,
                     lpFindFileData,
                     dwFlags,
                     dwContext
                     ));


    HINTERNET hFind = InternalFtpFindFirstFileA(hFtpSession,
                                                lpszSearchFile,
                                                lpFindFileData,
                                                dwFlags,
                                                dwContext,
                                                FALSE   // not a CACHE_ONLY request
                                                );

    DEBUG_LEAVE_API(hFind);

    return hFind;
}


HINTERNET
InternalFtpFindFirstFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fCacheOnly,
    IN BOOL fAllowEmpty
    )

/*++

Routine Description:

    Download the remote site's directory listing and parse it into
    WIN32_FIND_DATA structures that we can pass back to the app.

    If the FTP session is currently involved in a data transfer, such as
    a FtpOpenFile()....FtpCloseFile() series of calls, this function will
    fail.

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpOpen()

    lpszSearchFile  - Pointer to a string containing a file specification
                      that constrains the search.  (e.g., "*.txt"). A NULL
                      pointer is treated the same as an empty string

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds. If this parameter
                      is NULL, then we can still return success, but all find
                      information will be returned via InternetFindNextFile()

    dwFlags         - controlling caching, etc.

    dwContext       - app-supplied context value for call-backs,

    fCacheOnly      - don't go remote if didn't find in the cache

    fAllowEmpty     - return handle even if no files found

Return Value:

    HINTERNET
        Success - new find handle

        Failure - NULL. Call GetLastError() for more information:

                    ERROR_INVALID_HANDLE
                        The session handle is not recognized

                    ERROR_FTP_TRANSFER_IN_PROGRESS
                        The data connection is already in use

                    ERROR_NO_MORE_FILES
                        The end of the directory listing has been reached

                    ERROR_INTERNET_EXTENDED_ERROR
                        Call InternetGetLastResponseInfo() for the text

                    ERROR_INTERNET_INTERNAL_ERROR
                        Something bad happened

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Handle,
                 "InternalFtpFindFirstFileA",
                 "%#x, %.80q, %#x, %#x, %#x, %B, %B",
                 hFtpSession,
                 lpszSearchFile,
                 lpFindFileData,
                 dwFlags,
                 dwContext,
                 fCacheOnly,
                 fAllowEmpty
                 ));

    HINTERNET findHandle = NULL;
    HINTERNET hConnectMapped = NULL;
    BOOL isLocal;
    BOOL isAsync = FALSE;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    BOOL bIsWorker = FALSE;
    BOOL bNonNestedAsync = FALSE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    bIsWorker = lpThreadInfo->IsAsyncWorkerThread;
    bNonNestedAsync = bIsWorker && (lpThreadInfo->NestedRequests == 1);

    //
    // if this is the async part of the request and this function is not nested
    // then hFtpSession is actually the mapped address of the find handle
    //

    if (bNonNestedAsync) {
        findHandle = hFtpSession;
        hConnectMapped = ((FTP_FIND_HANDLE_OBJECT *)findHandle)->GetParent();
    } else {
        error = MapHandleToAddress(hFtpSession, (LPVOID *)&hConnectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hConnectMapped == NULL)) {
            goto quit;
        }
        error = RIsHandleLocal(hConnectMapped,
                               &isLocal,
                               &isAsync,
                               TypeFtpConnectHandle
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // validate parameters
        //

        if ((ARGUMENT_PRESENT(lpFindFileData)
            && IsBadWritePtr(lpFindFileData, sizeof(*lpFindFileData)))
        || (ARGUMENT_PRESENT(lpszSearchFile)
            && IsBadStringPtr(lpszSearchFile, INTERNET_MAX_PATH_LENGTH + 1))) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // convert NULL search argument to empty string
        //

        if (!ARGUMENT_PRESENT(lpszSearchFile)) {
            lpszSearchFile = "";
        }

        //
        // set the context and handle info and clear last error variables
        //

        _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hConnectMapped);
        _InternetSetContext(lpThreadInfo, dwContext);
        _InternetClearLastError(lpThreadInfo);

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        INET_ASSERT(findHandle == NULL);

        error = RMakeFtpFindObjectHandle(hConnectMapped,
                                         &findHandle,
                                         (CLOSE_HANDLE_FUNC)wFtpFindClose,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {

            INET_ASSERT(findHandle == NULL);

            goto quit;
        }

        //
        // add another reference: we need this to protect the handle against
        // closure in callbacks and across the async thread transition
        //

        ((HANDLE_OBJECT *)findHandle)->Reference();

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle(),
                                 findHandle
                                 );
    }

    //
    // check to see if the data is in the cache. Do it here so that we don't
    // waste any time going async if we already have the data locally
    //

    if (IsSearchFileDirectory(lpszSearchFile)
    && FBeginCacheReadProcessing(findHandle,
                                 lpszSearchFile,
                                 GENERIC_READ,
                                 dwFlags,
                                 dwContext,
                                 ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)
                                            ->IsHtmlFind()))// doing html finds

    {

        error = ERROR_SUCCESS;

        if (lpFindFileData) {

            DWORD dwBytes = sizeof(WIN32_FIND_DATA);

            error = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->ReadCache(
                        (LPBYTE)lpFindFileData,
                        sizeof(WIN32_FIND_DATA),
                        &dwBytes
                        );
        }
        if (error == ERROR_SUCCESS) {
            goto quit;
        } else {
            ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->EndCacheRetrieval();
        }
    }
    if (!((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->IsCacheReadInProgress()) {

        // if this is a cacheonly request or we are in OFFLINE mode
        // then fail

        if (fCacheOnly ||
            ((((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->
                GetInternetOpenFlags() | dwFlags) & INTERNET_FLAG_OFFLINE)) {
            error = ERROR_PATH_NOT_FOUND;
            goto quit;
        }
    }

    //
    // the data wasn't in the cache. If the app requested async operation and
    // we are in the app's synchronous thread context then queue the request to
    // the async scheduler
    //

    if (!bIsWorker && isAsync && (dwContext != INTERNET_NO_CALLBACK)) {

        CFsm_FtpFindFirstFile * pFsm = new CFsm_FtpFindFirstFile(
            lpszSearchFile,
            lpFindFileData,
            dwFlags,
            dwContext
            );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            if (error == ERROR_SUCCESS) {
                error = pFsm->QueueWorkItem();
                if (error == ERROR_IO_PENDING) {
                    hConnectMapped = NULL;
                    findHandle = NULL;
                }
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    //
    // if we're here then we're on the synchronous path: either async I/O was
    // not requested, or we failed to make the request asynchronous
    //

    HINTERNET protocolFtpHandle;

    error = RGetLocalHandle(hConnectMapped, &protocolFtpHandle);
    if (error == ERROR_SUCCESS) {

        HINTERNET protocolFindHandle;

        error = wFtpFindFirstFile(protocolFtpHandle,
                                  lpszSearchFile,
                                  lpFindFileData,
                                  &protocolFindHandle
                                  );

        if (error == ERROR_NO_MORE_FILES && fAllowEmpty) {

            //
            // The directory is empty.  Allow a handle to be returned,
            // but mark it empty so FtpFindNextFile doesn't complain.
            //

            ((FTP_FIND_HANDLE_OBJECT *) findHandle)->SetIsEmpty();
            error = ERROR_SUCCESS;
        }

        if (error == ERROR_SUCCESS) {
            ((FTP_FIND_HANDLE_OBJECT *)findHandle)->SetFindHandle(
                                                        protocolFindHandle
                                                        );
        }
    }

    //
    // if we succeeded in getting the data, add it to the cache
    //

    if (error == ERROR_SUCCESS) {

        //
        // don't worry about errors if cache write fails
        //

        if (IsSearchFileDirectory(lpszSearchFile)  && FBeginCacheWriteProcessing(findHandle,
                                       lpszSearchFile,
                                       GENERIC_READ,
                                       dwFlags,
                                       dwContext,
                                       ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)
                                            ->IsHtmlFind()// doing html finds
                                       )) {
            if (!((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->IsHtmlFind()
                     && lpFindFileData) {

                DWORD dwBytes = sizeof(WIN32_FIND_DATA);
                DWORD errorCache;

                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->
                                WriteCache((LPBYTE)lpFindFileData,
                                           sizeof(WIN32_FIND_DATA)
                                           );
                if (errorCache != ERROR_SUCCESS) {
                    InbLocalEndCacheWrite(findHandle,
                                          NULL,
                                          (errorCache == ERROR_NO_MORE_FILES)
                                          );
                }
            }
        }
    }

quit:

    _InternetDecNestingCount(1);

    if ((!bNonNestedAsync
         || ((error != ERROR_SUCCESS) && (error != ERROR_IO_PENDING)))
        && (findHandle != NULL)) {

        //
        // balance the extra reference we added to protect against closure in
        // callbacks and across the async thread transition. If non-nested
        // async request, this will be accomplished after REQUEST_COMPLETE
        // callback
        //

        if (((HANDLE_OBJECT *)findHandle)->Dereference()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }
    }

done:

    if (error == ERROR_SUCCESS) {

        //
        // success - return generated pseudo-handle
        //

        findHandle = ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle();
    } else {
        if (bNonNestedAsync) {
            if (((HANDLE_OBJECT *)findHandle)->IsInvalidated()) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }
        }
        if ((error != ERROR_IO_PENDING) && (findHandle != NULL)) {
            _InternetCloseHandle(((HANDLE_OBJECT *)findHandle)->GetPseudoHandle());
            if (bNonNestedAsync) {

                //
                // this handle deref'd at async completion
                //

                hConnectMapped = NULL;
            }

            if (lpThreadInfo) {
                _InternetSetContext(lpThreadInfo, dwContext);
            }
        }
        findHandle = NULL;
    }
    if (hConnectMapped != NULL) {
        DereferenceObject((LPVOID)hConnectMapped);
    }
    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE(findHandle);

    return findHandle;
}


INTERNETAPI_(BOOL) FtpGetFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszRemoteFile,
    IN LPCSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    This is a 'wrapper' function that opens/creates a local file and calls other
    FTP APIs to copy a file from an FTP server to the local file.

    This API does not get remoted, although APIs called herein do

Arguments:

    hFtpSession             - identifies the FTP server where the file resides

    lpszRemoteFile          - name of the file on the server to get

    lpszNewFile             - name of the local file to create

    fFailIfExists           - TRUE if we should not overwrite an existing file

    dwFlagsAndAttributes    - various flags

    dwFlags                 - how to transfer the file: as ASCII text or binary
                              and open options

    dwContext               - app-supplied context value for call-backs

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetFileA",
                     "%#x, %q, %q, %B, %#x, %#x, %#x",
                     hFtpSession,
                     lpszRemoteFile,
                     lpszNewFile,
                     fFailIfExists,
                     dwFlagsAndAttributes,
                     dwFlags,
                     dwContext
                     ));

    BOOL fSuccess = FALSE;
    DWORD error = ERROR_SUCCESS;

    PWSTR pwszRemoteFile = NULL, pwszNewFile = NULL;
    DWORD cc;
    
    if (IsBadStringPtr(lpszRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszRemoteFile == '\0')
        || IsBadStringPtr(lpszNewFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewFile == '\0'))
    {
        error = ERROR_INVALID_PARAMETER;
        goto done;
    }

    cc = MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, pwszRemoteFile, cc);

    cc = MultiByteToWideChar(CP_ACP, 0, lpszNewFile, -1, NULL, 0);
    pwszNewFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszNewFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;        
    }
    MultiByteToWideChar(CP_ACP, 0, lpszNewFile, -1, pwszNewFile, cc);

    fSuccess = FtpGetFileW(
                        hFtpSession,
                        pwszRemoteFile,
                        pwszNewFile,
                        fFailIfExists,
                        dwFlagsAndAttributes,
                        dwFlags,
                        dwContext);

done:
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    if (pwszNewFile)
    {
        FREE_MEMORY(pwszNewFile);
    }
    
    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(fSuccess);

    return fSuccess;
}


INTERNETAPI_(BOOL) FtpPutFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    This is a 'wrapper' function that opens/creates a local file and calls other
    FTP APIs to copy a file from an FTP server to the local file.

    This API does not get remoted, although APIs called herein do

    BUGBUG - this API is virtually the same as FtpGetFileA(). Check out
             possibility of commonalizing

Arguments:

    hFtpSession         - identifies the FTP server where the file resides

    lpszLocalFile       - name of the local file to upload

    lpszNewRemoteFile   - name of the file on the server to create

    dwFlags             - how to transfer the file: as ASCII text or binary and
                          open options

    dwContext           - app-supplied context value for call-backs

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpPutFileA",
                     "%#x, %q, %q, %#x, %#x",
                     hFtpSession,
                     lpszLocalFile,
                     lpszNewRemoteFile,
                     dwFlags,
                     dwContext
                     ));

    BOOL fSuccess = FALSE;
    DWORD error = ERROR_SUCCESS;

    PWSTR pwszRemoteFile = NULL, pwszNewFile = NULL;
    DWORD cc;
    
    if (IsBadStringPtr(lpszNewRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewRemoteFile == '\0')
        || IsBadStringPtr(lpszLocalFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszLocalFile == '\0'))
    {
        error = ERROR_INVALID_PARAMETER;
        goto done;
    }

    cc = MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, pwszRemoteFile, cc);

    cc = MultiByteToWideChar(CP_ACP, 0, lpszLocalFile, -1, NULL, 0);
    pwszNewFile = (PWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszNewFile)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;        
    }
    MultiByteToWideChar(CP_ACP, 0, lpszLocalFile, -1, pwszNewFile, cc);

    fSuccess = FtpPutFileW(
                        hFtpSession,
                        pwszNewFile,
                        pwszRemoteFile,
                        dwFlags,
                        dwContext);

done:
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    if (pwszNewFile)
    {
        FREE_MEMORY(pwszNewFile);
    }
    
    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(fSuccess);

    return fSuccess;
}


INTERNETAPI_(BOOL) FtpDeleteFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName
    )

/*++

Routine Description:

    Deletes the named file at the FTP server

Arguments:

    hFtpSession     - identifies FTP server where file is to be deleted

    lpszFileName    - name of file to delete

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpDeleteFileA",
                     "%#x, %q",
                     hFtpSession,
                     lpszFileName
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszFileName == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpDeleteFile * pFsm;

            pFsm = new CFsm_FtpDeleteFile(hFtpSession, lpszFileName);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    LocalSetObjectName(hMapped, (LPSTR)lpszFileName);

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {

        error = wFtpDeleteFile(ftpHandle, lpszFileName);

        if (error == ERROR_SUCCESS) {

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->ExpireDependents();

        }
    }

quit:

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }
    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpRenameFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    )

/*++

Routine Description:

    Renames a file on an FTP server

Arguments:

    hFtpSession     - identifies FTP server where file is to be renamed

    lpszExisting    - current file name

    lpszNew         - new file name

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRenameFileA",
                     "%#x, %q, %q",
                     hFtpSession,
                     lpszExisting,
                     lpszNew
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1))
    {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszExisting, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszExisting == '\0')
        || IsBadStringPtr(lpszNew, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNew == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpRenameFile * pFsm;

            pFsm = new CFsm_FtpRenameFile(hFtpSession, lpszExisting, lpszNew);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    LocalSetObjectName(hMapped, (LPSTR)lpszExisting);

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpRenameFile(ftpHandle,
                               lpszExisting,
                               lpszNew
                               );

        if (error == ERROR_SUCCESS) {

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->ExpireDependents();

        }
    }

quit:

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(HINTERNET) FtpOpenFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sets up the FTP session to read or write a file at the FTP server

Arguments:

    hFtpSession     - InternetConnect handle identifying FTP server

    lpszFileName    - name of file to open

    dwAccess        - how to access file - for read or write. Can be one of:
                        - GENERIC_READ
                        - GENERIC_WRITE

    dwFlags         - how to transfer file - ASCII text, or binary and open
                      options. Can be any or all of the following:
                        - INTERNET_FLAG_RELOAD

                        - INTERNET_FLAG_RAW_DATA (passed through by
                          InternetOpenUrl(), meaningless here)

                        - INTERNET_FLAG_EXISTING_CONNECT (passed through by
                          InternetOpenUrl(), meaningless here)

                        - FTP_TRANSFER_TYPE_XXX

    dwContext       - app-supplied context value for call-backs

Return Value:

    HINTERNET
        Success - handle of FTP file object

        Failure - NULL. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpOpenFileA",
                     "%#x, %q, %#x, %#x, %#x",
                     hFtpSession,
                     lpszFileName,
                     dwAccess,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET hFile = InternalFtpOpenFileA(hFtpSession,
                                           lpszFileName,
                                           dwAccess,
                                           dwFlags,
                                           dwContext,
                                           FALSE   // this is not a cachonly request
                                           );

    DEBUG_LEAVE_API(hFile);

    return hFile;
}


HINTERNET
InternalFtpOpenFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fCacheOnly
    )

/*++

Routine Description:

    Sets up the FTP session to read or write a file at the FTP server

Arguments:

    hFtpSession     - InternetConnect handle identifying FTP server

    lpszFileName    - name of file to open

    dwAccess        - how to access file - for read or write. Can be one of:
                        - GENERIC_READ
                        - GENERIC_WRITE

    dwFlags         - how to transfer file - ASCII text, or binary and open
                      options. Can be any or all of the following:
                        - INTERNET_FLAG_RELOAD

                        - INTERNET_FLAG_RAW_DATA (passed through by
                          InternetOpenUrl(), meaningless here)

                        - INTERNET_FLAG_EXISTING_CONNECT (passed through by
                          InternetOpenUrl(), meaningless here)

                        - FTP_TRANSFER_TYPE_XXX

    dwContext       - app-supplied context value for call-backs

    fCacheOnly      - TRUE if this operation must be satisfied from cache

Return Value:

    HINTERNET
        Success - handle of FTP file object

        Failure - NULL. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Handle,
                 "InternalFtpOpenFileA",
                 "%#x, %q, %#x, %#x, %#x, %B",
                 hFtpSession,
                 lpszFileName,
                 dwAccess,
                 dwFlags,
                 dwContext,
                 fCacheOnly
                 ));

    HINTERNET fileHandle = NULL;
    HINTERNET hConnectMapped;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;
    BOOL bNonNestedAsync = FALSE;

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    DWORD nestingLevel = 0;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    bNonNestedAsync = lpThreadInfo->IsAsyncWorkerThread
                    && (lpThreadInfo->NestedRequests == 0);
    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // if this is the async worker thread AND we haven't been called from
    // another API which is running asynchronously, then what we think is
    // hFtpSession is really the file handle object. Get the handles in the
    // right variables
    //

    if (bNonNestedAsync) {
        hObject = hFtpSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        fileHandle = hObjectMapped;
        hConnectMapped = ((FTP_FILE_HANDLE_OBJECT *)fileHandle)->GetParent();
    } else {
        error = MapHandleToAddress(hFtpSession, (LPVOID *)&hConnectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hConnectMapped == NULL)) {
            goto quit;
        }
        hObject = hFtpSession;
        hObjectMapped = hConnectMapped;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hObject, hObjectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszFileName == '\0')

        //
        // dwAccess must be GENERIC_READ or GENERIC_WRITE, but not both, and
        // can't be zero or have undefined bits set. Comparing for equality
        // works
        //

        || ((dwAccess != GENERIC_READ) && (dwAccess != GENERIC_WRITE))

        //
        // must be a recognized transfer type
        //

        || (((dwFlags & FTP_TRANSFER_TYPE_MASK) != 0)
            ? (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY))
            : FALSE)
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // use default transfer type if so requested
        //

        if ((dwFlags & FTP_TRANSFER_TYPE_MASK) == 0) {
            dwFlags |= FTP_TRANSFER_TYPE_BINARY;
        }

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        INET_ASSERT(fileHandle == NULL);

        error = RMakeFtpFileObjectHandle(hConnectMapped,
                                         &fileHandle,
                                         (CLOSE_HANDLE_FUNC)wFtpCloseFile,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {

            INET_ASSERT(fileHandle == NULL);

            goto quit;
        }

        //
        // add reference to keep handle alive during callbacks and across
        // async thread transition
        //

        ((HANDLE_OBJECT *)fileHandle)->Reference();

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                                 fileHandle
                                 );
    }

    if (((FTP_FILE_HANDLE_OBJECT *)fileHandle)->SetFileName(lpszFileName) != ERROR_SUCCESS)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    //
    // check to see if the data is in the cache
    //

    if (FBeginCacheReadProcessing(fileHandle,
                                  lpszFileName,
                                  dwAccess,
                                  dwFlags,
                                  dwContext, FALSE)) {
        error = ERROR_SUCCESS;
        goto quit;
    } else {
        if (fCacheOnly ||
                ((((INTERNET_CONNECT_HANDLE_OBJECT *)fileHandle)->
                    GetInternetOpenFlags() | dwFlags )& INTERNET_FLAG_OFFLINE)) {
            // if we are offline,or doing cacheonly request
            // let us give the right error and quit

            error = ERROR_FILE_NOT_FOUND;

            goto quit;
        }
    }

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (dwContext != INTERNET_NO_CALLBACK)) {

        // MakeAsyncRequest
        CFsm_FtpOpenFile * pFsm;

        pFsm = new CFsm_FtpOpenFile(((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                                     dwContext,
                                     lpszFileName,
                                     dwAccess,
                                     dwFlags
                                     );
        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if (error == ERROR_IO_PENDING) {
                fileHandle = NULL;
                hObjectMapped = NULL;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    HINTERNET protocolFtpHandle;

    error = RGetLocalHandle(hConnectMapped, &protocolFtpHandle);
    if (error == ERROR_SUCCESS) {

        HINTERNET protocolFileHandle;

        error = wFtpOpenFile(protocolFtpHandle,
                             lpszFileName,
                             dwAccess,
                             dwFlags,
                             &protocolFileHandle
                             );
        if (error == ERROR_SUCCESS) {
            ((FTP_FILE_HANDLE_OBJECT *)fileHandle)->SetFileHandle(
                                                        protocolFileHandle
                                                        );
            // Now seems like a reasonable time to remove the entry from the
            // cache IFF the open has GENERIC_WRITE access set, i.e. the
            // caller is about to write to this url and make the cache entry
            // stale. This fixes a problem in FtpParseUrl where we bypass the expiry
            // info by forcing an offline state.

            if (dwAccess & GENERIC_WRITE) {
                DeleteUrlCacheEntryA(((FTP_FILE_HANDLE_OBJECT *)fileHandle)->GetURL());
            }
        }
    }

    if (error == ERROR_SUCCESS) {

        //
        // don't worry about errors if cache write does not begin
        //

        FBeginCacheWriteProcessing(fileHandle,
                                   lpszFileName,
                                   dwAccess,
                                   dwFlags,
                                   dwContext,
                                   FALSE        // not a find
                                   );
    }

quit:

    if (fileHandle != NULL) {

        //
        // balance the refcount we added to keep the handle alive during
        // callbacks and across the async thread transition. If this is a non-
        // nested async request then the reference will be balanced after the
        // REQUEST_COMPLETE callback
        //

        ((HANDLE_OBJECT *)fileHandle)->Dereference();
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (bNonNestedAsync && (error == ERROR_SUCCESS)) {
        hObjectMapped = hConnectMapped;
    }
    if (hObjectMapped != NULL) {

        //
        // if we are about to deref the file handle BUT it is already invalidated
        // because the operation was cancelled, e.g., then do not perform the
        // deref - leave it for the close. Otherwise, the close will fail and
        // will not reinstate the callback parameters
        //

        if (!((hObjectMapped == fileHandle) && ((HANDLE_OBJECT *)fileHandle)->IsInvalidated())) {
            DereferenceObject((LPVOID)hObjectMapped);
        }
    }
    if (error != ERROR_SUCCESS) {

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (fileHandle != NULL)) {

            HANDLE_OBJECT * hConnMapped;
            HINTERNET hConn;

            hConnMapped = (HANDLE_OBJECT *)((HANDLE_OBJECT *)fileHandle)->GetParent();
            if (hConnMapped != NULL) {
                hConn = (HINTERNET)hConnMapped->GetPseudoHandle();
            }
            ((HANDLE_OBJECT *)fileHandle)->Invalidate();
            ((HANDLE_OBJECT *)fileHandle)->Dereference();
            if (hConnMapped != NULL) {
                _InternetSetObjectHandle(lpThreadInfo, hConn, hConnMapped);
                _InternetSetContext(lpThreadInfo, dwContext);
            }
        }

        //
        // error situation, or request is being processed asynchronously: return
        // a NULL handle
        //

        fileHandle = NULL;

        DEBUG_ERROR(API, error);

        SetLastError(error);
    } else {

        //
        // success - return generated pseudo-handle
        //

        fileHandle = ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle();
    }

    DEBUG_LEAVE(fileHandle);

    return fileHandle;
}


INTERNETAPI_(BOOL) FtpCreateDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Creates a directory on the FTP server

Arguments:

    hFtpSession     - identifies FTP server where directory is to be created

    lpszDirectory   - name of directory to create

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCreateDirectoryA",
                     "%#x, %q",
                     hFtpSession,
                     lpszDirectory
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszDirectory, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszDirectory == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpCreateDirectory * pFsm;

            pFsm = new CFsm_FtpCreateDirectory(hFtpSession, lpszDirectory);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    LocalSetObjectName(hMapped, (LPSTR)lpszDirectory);

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpCreateDirectory(ftpHandle,
                                    lpszDirectory
                                    );
        if (error == ERROR_SUCCESS) {

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->ExpireDependents();

        }
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;
        DEBUG_ERROR(API, error);
    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpRemoveDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Removes a directory at an FTP server

Arguments:

    hFtpSession     - identifies FTP server where directory is to be removed

    lpszDirectory   - name of directory to remove

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRemoveDirectoryA",
                     "%#x, %q",
                     hFtpSession,
                     lpszDirectory
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszDirectory, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszDirectory == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        // BUGBUG there is hole in this API, there is no dwFlags
        // so there is no way to know whether these operations are
        // happening online or offline
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->GetInternetOpenFlags() &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpRemoveDirectory * pFsm;

            pFsm = new CFsm_FtpRemoveDirectory(hFtpSession, lpszDirectory);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpRemoveDirectory(ftpHandle,
                                    lpszDirectory
                                    );
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpSetCurrentDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Sets the current directory (for this session) at an FTP server

Arguments:

    hFtpSession     - identifies FTP server at which directory is to be set

    lpszDirectory   - name of directory to make current working directory

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpSetCurrentDirectoryA",
                     "%#x, %q",
                     hFtpSession,
                     lpszDirectory
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    INTERNET_CONNECT_HANDLE_OBJECT * pMapped;

    pMapped = (INTERNET_CONNECT_HANDLE_OBJECT *)hMapped;

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtr(lpszDirectory, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszDirectory == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // if we are not going to net at all (offline), spoof setting directory
        // at the server
        //

        if (pMapped->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE) {
            goto set_object_cwd;
        }

        //
        // we have to hit the net. This will be an asynchronous operation if the
        // app requested async
        //

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync) {

            // MakeAsyncRequest
            CFsm_FtpSetCurrentDirectory * pFsm;

            pFsm = new CFsm_FtpSetCurrentDirectory(hFtpSession, lpszDirectory);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpSetCurrentDirectory(ftpHandle, lpszDirectory);
    }

set_object_cwd:

    if (error == ERROR_SUCCESS) {
        error = pMapped->SetCurrentWorkingDirectory((LPSTR)lpszDirectory);
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpGetCurrentDirectoryA(
    IN HINTERNET hFtpSession,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )

/*++

Routine Description:

    Gets the name of the current working directory for this session at the
    FTP server identified by hFtpSession

Arguments:

    hFtpSession             - identifies FTP server from which to get directory

    lpszCurrentDirectory    - buffer where name of current directory will be written

    lpdwCurrentDirectory    - IN: size of the buffer
                              OUT: number of bytes returned

Return Value:

    BOOL
        TRUE    - *lpdwCurrentDirectory contains number of characters returned

        FALSE   - Use GetLastError() to get more info. One of the following will
                  be returned:
                    ERROR_INVALID_PARAMETER

                    ERROR_INSUFFICIENT_BUFFER
                        *lpdwCurrentDirectory contains required buffer length

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetCurrentDirectoryA",
                     "%#x, %#x, %#x [%d]",
                     hFtpSession,
                     lpszCurrentDirectory,
                     lpdwCurrentDirectory,
                     lpdwCurrentDirectory ? *lpdwCurrentDirectory : 0
                     ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // perform sync work
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        //
        // lpdwCurrentDirectory must be present (and writeable - we assume it is)
        //

        if (!ARGUMENT_PRESENT(lpdwCurrentDirectory)

        //
        // lpszCurrentDirectory may be not present, but if it is must be writeable
        // by the number of bytes specified in *lpdwCurrentDirectory
        //

        || (ARGUMENT_PRESENT(lpszCurrentDirectory)
            ? IsBadWritePtr(lpszCurrentDirectory, *lpdwCurrentDirectory) : FALSE)) {

            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // we get CWD from the cache only in disconnected state
    //

    if (FGetCWDFromCache(hMapped, lpszCurrentDirectory, lpdwCurrentDirectory)) {
        error = ERROR_SUCCESS;
        goto quit;
    }

    if (!lpThreadInfo->IsAsyncWorkerThread
        && isAsync) {

        // MakeAsyncRequest
        CFsm_FtpGetCurrentDirectory * pFsm;

        pFsm = new CFsm_FtpGetCurrentDirectory(hFtpSession, lpszCurrentDirectory, lpdwCurrentDirectory);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS) {
        error = wFtpGetCurrentDirectory(
                    ftpHandle,

                    //
                    // if the caller supplied no buffer then the
                    // buffer length is 0
                    //

                    ARGUMENT_PRESENT(lpszCurrentDirectory)
                        ? *lpdwCurrentDirectory
                        : 0,
                    lpszCurrentDirectory,
                    lpdwCurrentDirectory
                    );
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) FtpCommandA(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand,
    IN DWORD_PTR dwContext,
    OUT HINTERNET *phFtpCommand OPTIONAL
    )

/*++

Routine Description:

    Runs an arbitrary command at the identified FTP server

Arguments:

    hFtpSession     - identifies FTP server where this command is to be run

    fExpectResponse - TRUE if we expect response data

    dwTransferType  - how to receive the data - as ASCII text, or as BINARY,
                      and open options

    lpszCommand     - string describing the command to run

    dwContext       - app-supplied context value for call-backs


    phFtpCommand    - pointer to an optional handle that will be created if
                        a valid data socket is opened, fExpectResponse must
                        be set to TRUE phFtpCommand to be filled
Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCommandA",
                     "%#x, %B, %#x, %q, %#x, %#x",
                     hFtpSession,
                     fExpectResponse,
                     dwFlags,
                     lpszCommand,
                     dwContext,
                     phFtpCommand
                     ));

    DWORD error;
    HINTERNET hMapped = NULL;
    HINTERNET hCommandMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }


    //
    // map the handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    INTERNET_CONNECT_HANDLE_OBJECT * pMapped;

    pMapped = (INTERNET_CONNECT_HANDLE_OBJECT *)hMapped;

    //
    // this is the handle we are currently working on
    //

    _InternetSetObjectHandle(lpThreadInfo,
                             hFtpSession,
                             hMapped
                             );
    _InternetSetContext(lpThreadInfo, dwContext);

    //
    // clear the per-thread object last error variables
    //

    InternetClearLastError();

    BOOL isLocal;
    BOOL isAsync;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );

    if ( error != ERROR_SUCCESS ) {
        goto quit;
    }

    //
    // in offline mode we can't execute commands
    //

    if ((pMapped->GetInternetOpenFlags()|dwFlags) & INTERNET_FLAG_OFFLINE) {
        error = ERROR_INTERNET_NO_DIRECT_ACCESS;
        goto quit;
    }

    //
    // validate parameters
    //

    if ( !lpThreadInfo->IsAsyncWorkerThread
         || (lpThreadInfo->NestedRequests > 1) )
    {
        //
        // BUGBUG - reasonable upper limit for command string length?
        //

        if (fExpectResponse && (phFtpCommand == NULL))
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }


        if (IsBadStringPtr(lpszCommand, 1024)
        || (*lpszCommand == '\0')
        || (fExpectResponse
            && (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY)))
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0))
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (dwContext != INTERNET_NO_CALLBACK)) {

        CFsm_FtpCommand * pFsm;

        pFsm = new CFsm_FtpCommand(hFtpSession,
                                   fExpectResponse,
                                   dwFlags,
                                   lpszCommand,
                                   dwContext,
                                   phFtpCommand
                                   );
        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }


    INET_ASSERT (error == ERROR_SUCCESS) ;

    if ( fExpectResponse )
    {

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        error = RMakeFtpFileObjectHandle(hMapped,
                                         &hCommandMapped,
                                         (CLOSE_HANDLE_FUNC)wFtpCloseFile,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this new handle will be used in callbacks
        //

    }


    HINTERNET ftpHandle;

    error = RGetLocalHandle(hMapped, &ftpHandle);
    if (error == ERROR_SUCCESS)
    {
        //InternetSetContext(dwContext);
        error = wFtpCommand(ftpHandle,
                            fExpectResponse,
                            dwFlags,
                            lpszCommand
                            );

        if ( fExpectResponse )
        {

            //
            // FTP can only have one active operation per session, so we just return
            // this session handle as the find handle
            //

            ((FTP_FILE_HANDLE_OBJECT *)hCommandMapped)->SetFileHandle(
                                                            ftpHandle
                                                            );

            *phFtpCommand = ((HANDLE_OBJECT *)hCommandMapped)->GetPseudoHandle();
        }
    }

quit:

    BOOL success;

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(DWORD) FtpGetFileSize(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwFileSizeHigh OPTIONAL
    )

/*++

Routine Description:

    Same as base Win32 GetFileSize() function. Returns size of file as reported
    by server (if known). For the IIS FTP server, the file size is reported in
    the response string when we open the file. For other (Unix) server, we need
    to send a "SIZE <filename>" command

Arguments:

    hFile               - hInternet of FTP_FILE_HANDLE_OBJECT returned by
                          FtpOpenFile()

    lpdwFileSizeHigh    - optional pointer to returned high 32 bits of file size

Return Value:

    DWORD
        Success - low 32 bits of size of file associated with hFile. If
                  0xFFFFFFFF is returned then GetLastError() must be used to
                  determine if an error occurred. If GetLastError() returns
                  ERROR_SUCCESS then the file size is 4GB-1

        Failure - 0xFFFFFFFF. GetLastError() returns possible error codes:

                    ERROR_INVALID_HANDLE
                        The handle is not a valid HINTERNET

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        The handle is a valid HINTERNET, but does not describe
                        a FTP FILE handle object

                    ERROR_INVALID_PARAMETER
                        lpdwFileSizeHigh is an invalid pointer

                    ERROR_INTERNET_OVERFLOW
                        The server reported that the file size was >0xFFFFFFFF,
                        but lpdwFileSizeHigh was NULL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "FtpGetFileSize",
                     "%#x, %#x",
                     hFile,
                     lpdwFileSizeHigh
                     ));

    DWORD error = ERROR_SUCCESS;
    DWORD dwSizeLow = 0;
    DWORD dwSizeHigh = 0;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    FTP_FILE_HANDLE_OBJECT * pFileMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnectMapped = NULL;

    HINTERNET hMapped;

    BOOL fFile = TRUE;

    BOOL isAsync;
    BOOL isLocal;
    BOOL fDeref = TRUE;
    BOOL fDerefSession = FALSE;


    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // validate parameters
    //

    if (lpdwFileSizeHigh != NULL) {
        if(IsBadWritePtr(lpdwFileSizeHigh, sizeof(*lpdwFileSizeHigh))) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        *lpdwFileSizeHigh = 0;
    }

    error = MapHandleToAddress(hFile, (LPVOID *)&pFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (pFileMapped == NULL)) {
        goto quit;
    }

    hMapped = pFileMapped;

    _InternetSetObjectHandle(lpThreadInfo, hFile, pFileMapped);
    _InternetSetContext(lpThreadInfo,
                        ((FTP_FILE_HANDLE_OBJECT *)pFileMapped)->GetContext()
                        );
    _InternetClearLastError(lpThreadInfo);

    error = RIsHandleLocal(hMapped, // mapped file handle
                           &isLocal,
                           &isAsync,
                           TypeFtpFileHandle
                           );
    if (error != ERROR_SUCCESS) {

#if 0
        error = RIsHandleLocal((HINTERNET) hMapped,
                               &isLocal,
                               &isAsync,
                               TypeFtpConnectHandle
                               );

        if ( error != ERROR_SUCESS ) {
            goto quit;
        }

        //else ...
        fFile = FALSE;
        pConnectMapped = (INTERNET_CONNECT_HANDLE_OBJECT *) pFileMapped;
        hMapped = (HINTERNET) pConnectMapped;
        pFileMapped = NULL;
#else
        goto quit;
#endif
    }

    //
    // If we're reading from the cache we need to find the file size via the cache api.
    //

    //
    // BUGBUG [arthurbi] - Need to test the cached code path, as it may be that we're
    //  not properly reading from the cached handle
    //

    if (fFile && pFileMapped->IsCacheReadInProgress())
    {
        CACHE_ENTRY_INFO ceiCacheInfo;
        DWORD dwBuffSize = sizeof(ceiCacheInfo);

        if (!pFileMapped->CacheGetUrlInfo(
                        &ceiCacheInfo,
                        &dwBuffSize
                        ))
        {
            error = GetLastError();
            goto quit;
        }

        dwSizeLow =  ceiCacheInfo.dwSizeLow;
        dwSizeHigh = ceiCacheInfo.dwSizeHigh;

        goto quit;
    }

    //
    // if we already know the size of the file from a 150 response, return it
    // immediately, else we need to send a "SIZE" request to the server to get
    // it
    //

    LPFTP_SESSION_INFO lpSessionInfo;
    HINTERNET hHandleMapped;
    HINTERNET hFtpSession;

    //
    // find the FTP_SESSION_INFO and ensure it is set up to receive data
    //

    error = RGetLocalHandle(hMapped, &hFtpSession);
    if (error == ERROR_SUCCESS) {
        if (!FindFtpSession( hFtpSession, &lpSessionInfo)) {
            error = ERROR_INVALID_HANDLE;
            goto quit;
        }
    }
    else
    {
        goto quit;
    }

    fDerefSession = TRUE;

#if 0
    if (!fFile)
    {

        if (!lpThreadInfo->IsAsyncWorkerThread && isAsync)
        {
            CFsm_FtpGetFileSize * pFsm;

            pFsm = new CFsm_FtpGetFileSize(hFile);
            if (pFsm != NULL )
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }

        error = wFtpGetFileSize(hMapped, lpSessionInfo, &dwSizeLow, &dwSizeHigh);
    }
    else
#endif
    {
        INET_ASSERT(fFile);

        //
        // if FFTP_KNOWN_FILE_SIZE is set then we already know the file size
        //

        if ( (lpSessionInfo->Flags & FFTP_KNOWN_FILE_SIZE) == 0 ) {
            error = ERROR_INTERNET_ITEM_NOT_FOUND;
            goto quit;
        }

        // set dwSizeLow here..
        dwSizeLow = lpSessionInfo->dwFileSizeLow;
    }

quit:

    if ( fDerefSession ) {
        DereferenceFtpSession(lpSessionInfo);
    }

    if (pFileMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)pFileMapped);
    }

    if ( error != ERROR_SUCCESS )
    {
        dwSizeLow = 0xffffffff;
    }

    SetLastError(error);

    DEBUG_LEAVE_API(dwSizeLow);

    return dwSizeLow;
}


INTERNETAPI_(BOOL) FtpGetSystemNameA(
        IN HINTERNET hSession,
        OUT LPSTR lpszBuffer,
        IN OUT LPDWORD lpdwBufferLength
        )

/*++

Routine Description:

    Returns the results of a "SYST" command sent to the FTP server to identify
    the FTP server/operating system type in use at the site. The server will
    return a string of the form "215 Windows_NT Version 4.0". The FTP status
    code substring "215 " will be stripped before the string is returned to the
    caller

Arguments:

    hSession            - a HINTERNET returned by InternetConnect() describing
                          an FTP session

    lpszBuffer          - pointer to buffer where output string will be stored

    lpdwBufferLength    - IN: the size of lpszBuffer in BYTEs
                          OUT: if successful, the number of CHARACTERs comprising
                          the string in lpszBuffer minus 1 for the string
                          terminator. If ERROR_INSUFFICIENT_BUFFER is returned,
                          the number of BYTEs required to hold the string,
                          including the string termination character

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError() to return the error information.
                  Possible error codes are:

                    ERROR_INVALID_HANDLE
                        The handle is not a valid HINTERNET

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        The handle is a valid HINTERNET, but does not describe
                        an FTP connect handle object

                    ERROR_INVALID_PARAMETER
                        lpszBuffer or lpdwBufferLength are invalid pointers

                    ERROR_INSUFFICIENT_BUFFER
                        The buffer size given in *lpdwBufferLength is too small
                        to hold the resultant string. The required buffer length
                        is returned in *lpdwBufferLength

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetSystemNameA",
                     "%#x, %#x, %#x [%d]",
                     hSession,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    INTERNET_CONNECT_HANDLE_OBJECT * phMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // validate parameters
    //

    if ((lpdwBufferLength == NULL)
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || IsBadWritePtr(lpszBuffer, *lpdwBufferLength)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    error = MapHandleToAddress(hSession, (LPVOID *)&phMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (phMapped == NULL)) {
        goto quit;
    }

quit:

    if (phMapped != NULL) {
        DereferenceObject((LPVOID)phMapped);
    }

    BOOL success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


//
// Internet subordinate functions
//

BOOL
FtpFindNextFileA(
    IN HINTERNET hFind,
    OUT LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    Returns the directory entry in the list returned by FtpFindFirstFile()

    Assumes:    1. We are being called from InternetFindNextFile() which has
                   already validated the parameters, set the thread variables,
                   and cleared the object last error info

Arguments:

    hFind           - find object handle, returned by FtpFindFirstFile()

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FtpFindNextFileA",
                 "%#x, %#x",
                 hFind,
                 lpFindFileData
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error, errorCache;
    BOOL isLocal;
    BOOL isAsync, fIsHtml = FALSE;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hFind,
                           &isLocal,
                           &isAsync,
                           TypeFtpFindHandle
                           );
    if (error != ERROR_SUCCESS) {

        //
        // if the handle is actually a HTML FTP find handle, then we allow the
        // operation. Note: we can do this because FtpFindNextFile() is not
        // exported, so a rogue app cannot call this function after opening the
        // handle via InternetOpenUrl()
        //

        error = RIsHandleLocal(hFind,
                               &isLocal,
                               &isAsync,
                               TypeFtpFindHandleHtml
                               );
        fIsHtml = (error == ERROR_SUCCESS);
    }

    FTP_FIND_HANDLE_OBJECT * pFind;

    pFind = (FTP_FIND_HANDLE_OBJECT *)hFind;

    if (error == ERROR_SUCCESS) {
        if (pFind->IsCacheReadInProgress()) {

            //we should never get here when the it is a findhtml type handle.
            // internetopenurl should skim it off the top.

            INET_ASSERT(!fIsHtml);

            DWORD   dwLen = sizeof(WIN32_FIND_DATA);
            error = pFind->ReadCache((LPBYTE)lpFindFileData,
                                                                dwLen,
                                                                &dwLen);
            if ((error == ERROR_SUCCESS) && !dwLen) {
                error = ERROR_NO_MORE_FILES;
            }
            goto quit;
        } else {

            INET_ASSERT(!(pFind->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE));
        }

        HINTERNET ftpHandle;

        error = RGetLocalHandle(hFind, &ftpHandle);
        if (error == ERROR_SUCCESS) {
            if (pFind->IsEmpty()) {
                error = ERROR_NO_MORE_FILES;
            } else {
                error = wFtpFindNextFile(ftpHandle, lpFindFileData);
            }
        }
    }

    errorCache = error;

    if (error == ERROR_SUCCESS) {
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->IsCacheWriteInProgress()) {

            // write here only if it is a native find handle
            // otherwise, internetreadurl will take care
            if (!fIsHtml) {
                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->WriteCache(
                                (LPBYTE)lpFindFileData,
                                sizeof(WIN32_FIND_DATA)
                                );
            }
        }

    }
    if (errorCache != ERROR_SUCCESS) {
        if (!fIsHtml) {
            InbLocalEndCacheWrite(hFind, NULL, (errorCache == ERROR_NO_MORE_FILES));
        }
    }

quit:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE(success);

    SetLastError(error);

    return success;
}


BOOL
FtpReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Reads number of bytes from file at FTP server

    Assumes:    1. We are being called from InternetReadFile() which has
                   already validated the parameters, handled the zero byte
                   read case, set the thread variables, and cleared the object
                   last error info

Arguments:

    hFile                   - file object handle, returned by FtpOpenFile()

    lpBuffer                - pointer to user's buffer

    dwNumberOfBytesToRead   - size of user's buffer

    lpdwNumberOfBytesRead   - number of bytes copied to user's buffer on output

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FtpReadFile",
                 "%#x, %#x, %d, %#x",
                 hFile,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error, errorCache;
    BOOL isLocal;
    BOOL isAsync;

    FTP_FILE_HANDLE_OBJECT * pFile = (FTP_FILE_HANDLE_OBJECT *)hFile;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hFile,
                           &isLocal,
                           &isAsync,
                           TypeFtpFileHandle
                           );
    if (error == ERROR_SUCCESS) {

        if (pFile->IsCacheReadInProgress()) {
            error = pFile->ReadCache((LPBYTE)lpBuffer,
                                     dwNumberOfBytesToRead,
                                     lpdwNumberOfBytesRead
                                     );
            if (!*lpdwNumberOfBytesRead || (error != ERROR_SUCCESS)) {

                //
                // don't do anything here so we don't barf when someone
                // does an extraneous read. The cache stream gets closed
                // when the handle is closed. bug#9086
//                ((FTP_FILE_HANDLE_OBJECT *)hFile)->EndCacheRetrieval();
                //

            }

            //
            // quit whether we succeed or we fail
            //

            goto quit;
        } else {

            INET_ASSERT(!((pFile->GetInternetOpenFlags()|pFile->GetCacheFlags())
                            & INTERNET_FLAG_OFFLINE));

        }

        HINTERNET ftpHandle;

        error = RGetLocalHandle(hFile, &ftpHandle);
        if (error == ERROR_SUCCESS) {
            error = wFtpReadFile(ftpHandle,
                                 lpBuffer,
                                 dwNumberOfBytesToRead,
                                 lpdwNumberOfBytesRead
                                 );
        }
    }

    if (error == ERROR_SUCCESS) {
        if (pFile->IsCacheWriteInProgress()) {

            if (!*lpdwNumberOfBytesRead) {

                DEBUG_PRINT(CACHE,
                            INFO,
                            ("Cache write complete\r\n"
                            ));

                errorCache = InbLocalEndCacheWrite(hFile, NULL, TRUE);

                INET_ASSERT(error == ERROR_SUCCESS);

                goto quit;
            }

            INET_ASSERT(pFile->IsCacheReadInProgress() == FALSE);

            if (pFile->WriteCache((LPBYTE)lpBuffer,
                                  *lpdwNumberOfBytesRead
                                  ) != ERROR_SUCCESS) {

                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("Error in Cache write\n"
                            ));

                errorCache = InbLocalEndCacheWrite(hFile, NULL, FALSE);

                INET_ASSERT(error == ERROR_SUCCESS);

            }
        }
    }

quit:

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}


BOOL
FtpWriteFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    Writes a number of bytes from the user's buffer to an open file on an FTP
    server

    Assumes:    1. We are being called from InternetWriteFile() which has
                   already validated the parameters, handled the zero byte
                   read case, set the thread variables, and cleared the object
                   last error info

Arguments:

    hFile                       - file object handle, returned by FtpOpenFile()

    lpBuffer                    - pointer to user's buffer

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FtpWriteFile",
                 "%#x, %#x, %d, %#x",
                 hFile,
                 lpBuffer,
                 dwNumberOfBytesToWrite,
                 lpdwNumberOfBytesWritten
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error;
    BOOL isLocal;
    BOOL isAsync;

    //
    // make RPC or local-worker function call
    //

    error = RIsHandleLocal(hFile,
                           &isLocal,
                           &isAsync,
                           TypeFtpFileHandle
                           );
    if (error == ERROR_SUCCESS) {

        HINTERNET ftpHandle;

        error = RGetLocalHandle(hFile, &ftpHandle);
        if (error == ERROR_SUCCESS) {
            error = wFtpWriteFile(ftpHandle,
                                  lpBuffer,
                                  dwNumberOfBytesToWrite,
                                  lpdwNumberOfBytesWritten
                                  );
            if (error == ERROR_SUCCESS) {

                // expire the url if it exists and it's
                // parent directory

                if( !((FTP_FILE_HANDLE_OBJECT *)hFile)->IsForcedExpirySet()){

                    ((FTP_FILE_HANDLE_OBJECT *)hFile)->ExpireDependents();

                    ((FTP_FILE_HANDLE_OBJECT *)hFile)->SetForcedExpiry(TRUE);

                    ((FTP_FILE_HANDLE_OBJECT *)hFile)->ExpireUrl();
                }
            }
        }
    }

    BOOL success;

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}


DWORD
pFtpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR    lpszTargetName,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectName,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine returns a LocaAlloc'ed buffer containing an FTP URL constructed
    from the TargetHost, CWD, and the ObjectName. The caller is responsible
    for freeing the memory.

Arguments:

    SchemeType      - protocol scheme (INTERNET_SCHEME_FTP)

    lpszTargetName  - name of server

    lpszCWD         - current directory at server

    lpszObjectName  - name of file. If NULL or empty then the URL is for a
                      directory

    lpszExtension   - file extension. NOT USED

    dwPort          - port at server

    lplpUrlName     - pointer to returned URL

    lpdwUrlLen      - pointer to returned URL length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD dwError, dwLen, dwT, dwTargetNameLen=0, dwObjectNameLen=0;
    char cBuff[INTERNET_MAX_URL_LENGTH], cBuff1[INTERNET_MAX_URL_LENGTH];//????
    URL_COMPONENTS sUrlComp;
    DWORD dwSav, i, ccFirst, ccTmp;

    INET_ASSERT(lpszTargetName);
    INET_ASSERT(lpszObjectName || lpszCWD);

    //
    // NULL or empty object name == directory
    //

    if ((lpszObjectName != NULL) && (*lpszObjectName == '\0')) {
        lpszObjectName = NULL;
    }

    memcpy(cBuff1, "/", sizeof("/"));
    ccFirst = 2;

    // add the current directory only if the path is a relative one
    if (lpszCWD && !(lpszObjectName && (*lpszObjectName == '/')) ) {
        if (*lpszCWD == '/') {
            ++lpszCWD;
        }
        ccTmp = lstrlen(lpszCWD);
        if (ccTmp > sizeof(cBuff1) - 2)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        memcpy(cBuff1 + 1, lpszCWD, ccTmp + 1);
        ccFirst += ccTmp;

        INET_ASSERT(lpszCWD[ccTmp - 1] == '/');

    }

    if (lpszObjectName) {

        if (*lpszObjectName == '/') {
            lpszObjectName++;
        }

        ccTmp = lstrlen(lpszObjectName);
        if (ccTmp > sizeof(cBuff1) - ccFirst)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        memcpy(cBuff1 + ccFirst - 1, lpszObjectName, ccTmp + 1);
    }

    memset(&sUrlComp, 0, sizeof(URL_COMPONENTS));

    sUrlComp.dwStructSize = sizeof(URL_COMPONENTS);
    sUrlComp.nScheme = INTERNET_SCHEME_FTP;
    sUrlComp.lpszHostName = lpszTargetName;
    sUrlComp.lpszUrlPath = cBuff1;
    sUrlComp.nPort = (INTERNET_PORT)dwPort;

    dwSav = sizeof(cBuff);

    if(!InternetCreateUrl(&sUrlComp, 0, cBuff, &dwSav)){
        dwError = GetLastError();
        goto Cleanup;
    }

    // BUGBUG, this is because InternetCreateUrl is not returning
    // the correct size

    dwSav = strlen(cBuff)+5;

    for(i=0;i<2;++i) {

        *lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, dwSav);

        if (*lplpUrlName) {

            if(!InternetCanonicalizeUrl(cBuff, *lplpUrlName, &dwSav, ICU_NO_ENCODE)){

                FREE_MEMORY(*lplpUrlName);

                // general paranoia
                *lplpUrlName = NULL;

                dwError = GetLastError();

                if ((i == 1) || (dwError != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            }
            else {

                dwError = ERROR_SUCCESS;
                *lpdwUrlLen = dwSav;
                break;

            }
        }
        else {
            SetLastError(dwError = ERROR_NOT_ENOUGH_MEMORY);
            goto Cleanup;
        }
    }



Cleanup:
    if (dwError != ERROR_SUCCESS) {

        INET_ASSERT(!*lplpUrlName);

        *lpdwUrlLen = 0;
    }

    return (dwError);
}


PRIVATE
BOOL
FBeginCacheReadProcessing(
    IN HINTERNET hFtp,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fIsHtmlFind
    )

/*++

Routine Description:

    Sets up to read FTP data from the cache

Arguments:

    hFtp            A mapped handle to an ftp data transfer object (FtpOpenFile/FtpFindFirstFile)

    lpszFileName    ftp file to look for in the cache

    dwAccess        Accesstype eg: GENERIC_READ

    dwFlags         caching flags

    dwContext       async context

Returns:

    TRUE of started cache reading,  FALSE otherwise

Comments:

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Bool,
                 "FBeginCacheReadProcessing",
                 "%#x, %q, %d, %08x, %x, %B",
                 hFtp,
                 lpszFileName,
                 dwAccess,
                 dwFlags,
                 dwContext,
                 fIsHtmlFind
                 ));

    DWORD dwError = ERROR_SUCCESS;
    URLGEN_FUNC fn = pFtpGetUrlString;
    LPCACHE_ENTRY_INFO lpCEI = NULL;
    FTP_FILE_HANDLE_OBJECT *pFtp = (FTP_FILE_HANDLE_OBJECT *)hFtp;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsCacheReadInProgress()) {

        //
        // BUGBUG - return FALSE surely? If there is a cache read in progress
        //          then by default, its for another request?
        //

        DEBUG_LEAVE(TRUE);

        return (TRUE);
    }

    //
    // if the object name is not set then all cache methods fail
    //

    //
    // BUGBUG - do this only when we know we are reading from cache?
    //

    ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetObjectName((LPSTR)lpszFileName,
                                                            NULL,
                                                            &fn
                                                            );
    if (dwAccess & GENERIC_WRITE) {

        DEBUG_LEAVE(FALSE);

        return (FALSE);
    }

    if (!(dwFlags & INTERNET_FLAG_NO_CACHE_WRITE)) {

        //
        // set the cache flags like RELOAD etc.
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetCacheFlags(dwFlags);
    } else {

        //
        // set flags to disable both read and write
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetCacheFlags(
                                                    INTERNET_FLAG_NO_CACHE_WRITE
                                                    | INTERNET_FLAG_RELOAD);
    }

    if (!FFtpCanReadFromCache(hFtp)) {

        DEBUG_LEAVE(FALSE);

        return (FALSE);
    }

    DEBUG_PRINT(CACHE,
                INFO,
                ("Checking in the cache\n"
                ));

    dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->BeginCacheRetrieval(&lpCEI);
    if (dwError == ERROR_SUCCESS)
    {
        //
        // found it in the cache
        //

        DEBUG_PRINT(FTP,
                    INFO,
                    ("Found in the cache\n"
                    ));

        BOOL bGetFromCache = FALSE;

        if (IsOffline()
        || (((((INTERNET_HANDLE_OBJECT *)hFtp)->GetInternetOpenFlags() | dwFlags)
            & INTERNET_FLAG_OFFLINE) && !(dwFlags & INTERNET_FLAG_RELOAD))) {
            bGetFromCache = TRUE;
            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Offline, loading from cache:\n \
                            dwFlags & INTERNET_FLAG_RELOAD = %s \n \
                            dwFlags & INTERNET_FLAG_OFFLIME = %s \n \
                            InternetOpenFlags & INTERNET_FLAG_OFFLIME = %s \n",
                            (dwFlags & INTERNET_FLAG_RELOAD) ? "TRUE" : "FALSE",
                            (dwFlags & INTERNET_FLAG_OFFLINE) ? "TRUE" : "FALSE",
                            (((INTERNET_HANDLE_OBJECT *)hFtp)->GetInternetOpenFlags()
                            & INTERNET_FLAG_OFFLINE) ? "TRUE" : "FALSE"
                        ));

        } else {
            if (!FIsFtpExpired(hFtp, lpCEI))
            {
                bGetFromCache = TRUE;
            }
        }

        if (! (( fIsHtmlFind  &&  lpCEI->lpszFileExtension) ||
               (!fIsHtmlFind  && !lpCEI->lpszFileExtension) ) )
        {
            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Mismatched HTML-type, expiring\n"
                        ));

            bGetFromCache = FALSE;
        }


        if (bGetFromCache) {
            dwError = ERROR_SUCCESS;
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetFromCache();
        } else {

            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Expired\n"
                        ));

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->EndCacheRetrieval();

            INET_ASSERT(dwError == ERROR_SUCCESS);

            dwError = ERROR_FILE_NOT_FOUND;
        }
    }

    //
    // cleanup
    //

    if (lpCEI != NULL) {
        lpCEI = (LPCACHE_ENTRY_INFO)FREE_MEMORY(lpCEI);

        INET_ASSERT(lpCEI == NULL);

    }

    DEBUG_LEAVE(dwError == ERROR_SUCCESS);

    return (dwError == ERROR_SUCCESS);
}


PRIVATE
BOOL
FFtpCanReadFromCache(
    HINTERNET hFtp
    )

/*++

Routine Description:

    This routine checks whether a cache read should even be started.

Arguments:

    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)

Returns:

    Windows Error Code.

Comments:

--*/

{
    DWORD dwFlags;

    dwFlags = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetCacheFlags();

    //
    // in offline or disconnected states client always reads
    //

    if (IsOffline()
    || (((INTERNET_HANDLE_OBJECT *)hFtp)->GetInternetOpenFlags() | dwFlags)
        & INTERNET_FLAG_OFFLINE) {
        return (TRUE);
    }

    //
    // if we are asked to reload data, it is not OK to read
    //

    if (dwFlags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_RESYNCHRONIZE)) {

        DEBUG_PRINT(CACHE,
                    INFO,
                    ("no cache option\n"
                    ));

        return (FALSE);
    }

    return (TRUE);
}


PRIVATE
BOOL
FBeginCacheWriteProcessing(
    IN HINTERNET hFtp,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    BOOL fIsHtmlFind
    )

/*++

Routine Description:

    Sets up to start writing FTP data to the cache

Arguments:

    hFtp            A mapped handle to an ftp data transfer object (FtpOpenFile/FtpFindFirstFile)

    lpszFileName    ftp file to look for in the cache

    dwAccess        Accesstype eg: GENERIC_WRITE

    dwFlags         caching flags

    dwContext       async context

Returns:

    TRUE if started cache writing,  FALSE otherwise

Comments:

--*/

{
    DWORD dwError = ERROR_INVALID_FUNCTION;
    URLGEN_FUNC fn = pFtpGetUrlString;
    char cExt[DEFAULT_MAX_EXTENSION_LENGTH + 1];
    DWORD dwBuffLen;
    LPSTR lpszFileExtension;

    if (dwAccess & GENERIC_WRITE) {
        return (FALSE);
    }

    if (!((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsCacheReadInProgress()) {

        //
        // we are not reading from the cache
        // Let us ask a routine whether we should cache this
        // stuff or not
        //

        if (FFtpCanWriteToCache(hFtp)) {

            //
            // if the object name is not set then all cache methods fail
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->
                SetObjectName((LPSTR)lpszFileName,
                              NULL,
                              &fn
                              );

            //
            // set the cache flags
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->SetCacheFlags(dwFlags);

            //
            // he says we can cache it.
            //

            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Starting cache write\n"
                        ));

            if (!fIsHtmlFind) {
                dwBuffLen = sizeof(cExt);
                lpszFileExtension = GetFileExtensionFromUrl(((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetURL(), &dwBuffLen);

                if (lpszFileExtension != NULL) {
                    memcpy(cExt, lpszFileExtension, dwBuffLen);
                    cExt[dwBuffLen] = '\0';
                    lpszFileExtension = cExt;
                }
            }
            else {
                //allways generate htm extension
                strcpy(cExt, "htm");
                lpszFileExtension = cExt;
            }

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->BeginCacheWrite(0, lpszFileExtension);

            if (dwError != ERROR_SUCCESS) {

                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("Error in BeginCacheWrite %ld\n",
                            dwError
                            ));

            }
        }
    }
    return (dwError == ERROR_SUCCESS);
}


PRIVATE
BOOL
FFtpCanWriteToCache(
    HINTERNET hFtp
    )

/*++

Routine Description:
    This routine checks whether a cache write should even be started.

Arguments:
    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)

Returns:

    TRUE if successful, FALSE otherwise

Comments:

--*/

{

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetCacheFlags() & INTERNET_FLAG_DONT_CACHE) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtp,
    LPSTR lpszFileExtension,
    IN BOOL fNormal
    )

/*++

Routine Description:
    This routine checks terminates cache writing if it was in progress and
    commits the entry to the cache

Arguments:
    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)
    fNormal TRUE if the termination is normal, in which case the collected data
            is entered in the cache, otherwise it is discarded
Returns:

    Windows error code

Comments:

--*/

{

    FILETIME ftLastModTime, ftExpiryTime, ftPostCheck;
    DWORD   dwEntryType;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsCacheWriteInProgress()) {

        ftLastModTime.dwLowDateTime =
        ftLastModTime.dwHighDateTime = 0;

        ftExpiryTime.dwLowDateTime =
        ftExpiryTime.dwHighDateTime = 0;

        ftPostCheck.dwLowDateTime =
        ftPostCheck.dwHighDateTime = 0;


        dwEntryType = (!fNormal)?0xffffffff:
                        ((((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->

                            GetCacheFlags() & INTERNET_FLAG_MAKE_PERSISTENT)
                                ? STICKY_CACHE_ENTRY:0
                        );

         DEBUG_PRINT(CACHE,
                     INFO,
                     ("Cache write EntryType = %x \
                     IsPerUserItem = %d \
                     <hFtp = 0x%x> \
                     <hFtp->GetParent() = 0x%x> \
                     <hFtp->IsPerUserItem() = %d\n",
                     dwEntryType,
                     ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsPerUserItem(),
                     hFtp,
                     ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->GetParent(),
                     ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->IsPerUserItem()
                     ));

        return (((INTERNET_CONNECT_HANDLE_OBJECT *)hFtp)->
                                EndCacheWrite(  &ftExpiryTime,
                                                &ftLastModTime,
                                                &ftPostCheck,
                                                dwEntryType,
                                                0,
                                                NULL,
                                                lpszFileExtension));
    }
    return (ERROR_SUCCESS);
}


PRIVATE
BOOL
FGetCWDFromCache(
    HINTERNET   hFtpSession,
    LPSTR       lpBuff,
    LPDWORD     lpdwBuffSize
    )

/*++

Routine Description:
    This routine returns the current working directory for an FTP session

Arguments:
    hFtpSession     a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)

    LPSTR           buffer to return the string in

    lpdwBuffSize    IN size of lpBuff, OUT size passed back
Returns:

    TRUE if successful, FALSE otherwise

Comments:

--*/

{
    if ((((INTERNET_CONNECT_HANDLE_OBJECT *)hFtpSession)->GetInternetOpenFlags()
            & INTERNET_FLAG_OFFLINE)) {
        ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtpSession)->GetCurrentWorkingDirectory(lpBuff, lpdwBuffSize);
        return (TRUE);
    }
    return (FALSE);
}


PRIVATE
BOOL
FIsFtpExpired(
    HINTERNET   hFtp,
    LPCACHE_ENTRY_INFO  lpCEI
    )

/*++

Routine Description:
    This routine checks whether an ftp item in the cache has expired

Arguments:
    hFtp    a mapped handle to an ftp download (FtpOpenFile/FtpFindFirstFile)
    lpCEI   cache entry info for the item

Returns:

    TRUE if successful, FALSE otherwise

Comments:

    Even though this is a trivial routine and can be nuked, it is good
    place holder for doing special things to check FTP expiry

--*/

{
    BOOL fExpired = FALSE;

    if (CheckExpired(   hFtp,
                        &fExpired,
                        lpCEI,
                        dwdwFtpDefaultExpiryDelta) != ERROR_SUCCESS) {
        fExpired = TRUE;
    }
    return (fExpired);
}



VOID
LocalSetObjectName(
    HINTERNET hFtpMapped,
    LPSTR   lpszFileName
    )
{
    URLGEN_FUNC fn = pFtpGetUrlString;

    ((INTERNET_CONNECT_HANDLE_OBJECT *)hFtpMapped)->
                SetObjectName((LPSTR)lpszFileName,
                              NULL,
                              &fn
                              );
}

/*++

Routine Description:
    This routine checks whether a string given to FtpFindFirstFile
    is a directory or a file

Arguments:

    lpszSearchFile string passed in to either FtpFindFirstFile

Returns:

    TRUE if successful, FALSE otherwise

Comments:

    This routine should not be used anywhere other thatn FtpFindFirstFile
    functions



--*/
BOOL IsSearchFileDirectory(
    LPCSTR   lpszSearchFile
)
{
    DWORD dwLen;

    if (!lpszSearchFile) {

        return (TRUE);

    }

    dwLen = lstrlen(lpszSearchFile);

    if (!dwLen) {

        return (TRUE);

    }


    return (lpszSearchFile[dwLen-1] == '/');

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpapir.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapir.cxx

Abstract:

    Contains the remote-side FTP API worker functions. In each case, the API
    proper validates the arguments. The worker functions contained herein just
    perform the requested operation with the supplied arguments.

    These functions are the remote side of the RPC interface. If the DLL is
    the abstract0 version (no RPC) then the A forms of the functions simply
    call the w functions

    Contents:
        wFtpFindFirstFile
        wFtpDeleteFile
        wFtpRenameFile
        wFtpOpenFile
        wFtpCreateDirectory
        wFtpRemoveDirectory
        wFtpSetCurrentDirectory
        wFtpGetCurrentDirectory
        wFtpCommand
        wFtpFindNextFile
        wFtpFindClose
        wFtpConnect
        wFtpMakeConnection
        wFtpDisconnect
        wFtpReadFile
        wFtpWriteFile
        wFtpQueryDataAvailable
        wFtpCloseFile
        wFtpFindServerType
        wFtpGetFileSize

Author:

    Heath Hunnicutt [t-heathh] 13-Jul-1994

Environment:

    Win32(s) user-level DLL

Revision History:

    09-Mar-1995 rfirth
        Created new file/worker functions from functions contained in
        findfile.c, ftphelp.c

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private debug functions
//

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
InternetMapFtpServerType(
    IN FTP_SERVER_TYPE ServerType
    );

#else

#define InternetMapFtpServerType(x) (VOID)(x)

#endif // INET_DEBUG

//
// external functions
//

extern
DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR lpszFileExtension,
    IN BOOL fNormal
    );

//
// functions
//


DWORD
wFtpFindFirstFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFilespec,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    OUT LPHINTERNET lphInternet
    )

/*++

Routine Description:

    Download the remote site's directory listing and parse it into
    WIN32_FIND_DATA structures that we can pass back to the app.

    If the FTP session is currently involved in a data transfer, such as
    a FtpOpenFile()....FtpCloseFile() series of calls, this function will
    fail.

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpOpen()

    lpszFilespec    - Pointer to a string containing a file specification
                      to find. May be empty, but not NULL

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds.
                      If this parameter is not supplied, then any find data
                      will be returned via InternetFindNextFile()

    lphInternet     - place to return open find handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    *lphInternet contains new find handle

        Failure - ERROR_INVALID_HANDLE
                    The session handle is not recognized

                  ERROR_FTP_TRANSFER_IN_PROGRESS
                    The data connection is already in use

                  ERROR_NO_MORE_FILES
                    The end of the directory listing has been reached

                  ERROR_INTERNET_EXTENDED_ERROR
                    Call InternetGetLastResponseInfo() for the text

                  ERROR_INTERNET_INTERNAL_ERROR
                    Something bad happened
--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindFirstFile",
                "%#x, %q, %#x, %#x",
                hFtpSession,
                lpszFilespec,
                lpFindFileData,
                lphInternet
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    LPSTR lpBuffer = NULL;
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;

    if (!FindFtpSession(hFtpSession, &lpSessionInfo)) {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    //
    // acquire the session lock while we check and optionally set the active
    // find flag
    //

    AcquireFtpSessionLock(lpSessionInfo);

    if (!(lpSessionInfo->Flags & FFTP_FIND_ACTIVE)) {
        lpSessionInfo->Flags |= FFTP_FIND_ACTIVE;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_FTP_TRANSFER_IN_PROGRESS;
    }

    ReleaseFtpSessionLock(lpSessionInfo);

    //
    // if we already have a directory listing on this connection, then we can
    // not allow another one, until the current listing is cleared out by the
    // app calling InternetCloseHandle()
    //

    if (error != ERROR_SUCCESS) {
        goto deref_exit;
    }

    //
    // the filespec may have a path component. We assume that any wild-cards
    // will only be in the filename part. We use the path part in the directory
    // request and the filename part when parsing the directory output
    //

    char pathBuf[INTERNET_MAX_PATH_LENGTH + 1];
    LPSTR lpszPathPart;
    LPSTR lpszFilePart;
    BOOL isWild;
    DWORD dwFilePartLength;

    lpszFilePart = (LPSTR)lpszFilespec;
    lpszPathPart = NULL;
    dwFilePartLength = lstrlen(lpszFilePart);

    if (*lpszFilePart != '\0') {

        LPSTR pathSeparator;

        pathSeparator = _memrchr(lpszFilePart, '\\', dwFilePartLength);
        if (pathSeparator == NULL) {
            pathSeparator = _memrchr(lpszFilePart, '/', dwFilePartLength);
        }
        if (pathSeparator != NULL) {

            int len = (int) (pathSeparator - lpszFilePart) + 1;

            if (len < sizeof(pathBuf)) {
                memcpy(pathBuf, lpszFilePart, len);
                pathBuf[len] = '\0';
                lpszPathPart = pathBuf;
                lpszFilePart = pathSeparator + 1;

                DEBUG_PRINT(FTP,
                            INFO,
                            ("lpszPathPart = %q, lpszFilePart = %q\n",
                            lpszPathPart,
                            lpszFilePart
                            ));

            }
        }

        //
        // determine whether the caller is asking for a fuzzy file match, or
        // (typically) the request is for the contents of a directory
        //

        isWild = IsFilespecWild(lpszFilePart);
    } else {

        //
        // empty string - not asking for wildcard search
        //

        isWild = FALSE;
    }

    //
    // and ask the FTP server for the directory listing
    //

    FTP_RESPONSE_CODE rcResponse;

    error = Command(lpSessionInfo,
                    TRUE,
                    FTP_TRANSFER_TYPE_ASCII,
                    &rcResponse,
                    ((lpszPathPart == NULL) && (isWild || (*lpszFilePart == '\0')))
                        ? "LIST"
                        : "LIST %s",
                    (lpszPathPart == NULL)
                        ? lpszFilePart
                        : isWild
                            ? lpszPathPart
                            : lpszFilespec
                    );

    //
    // quit early if we failed to send the command, or the server didn't
    // understand it
    //

    if (error != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // presumably, the server has sent us a directory listing. Receive it
    //

    DWORD bufferLength;
    DWORD bufferLeft;
    DWORD bytesReceived;
    BOOL eof;

    bufferLength = 0;
    bufferLeft = 0;
    bytesReceived = 0;

    error = lpSessionInfo->socketData->Receive((LPVOID *)&lpBuffer,
                                               &bufferLength,
                                               &bufferLeft,
                                               &bytesReceived,
                                               0,
                                               SF_EXPAND
                                               | SF_COMPRESS
                                               | SF_RECEIVE_ALL
                                               | SF_INDICATE,
                                               &eof
                                               );

    //
    // we are done with the data connection
    //

    lpSessionInfo->socketData->Close();

    //
    // quit now if we had an error while receiving
    //

    if (error != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // if the previous response was preliminary then get the final response from
    // the FTP server
    //

    if (rcResponse.Major != FTP_RESPONSE_COMPLETE) {
        error = GetReply(lpSessionInfo, &rcResponse);
        if (error != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // check response for failure
        //

        if (rcResponse.Major != FTP_RESPONSE_COMPLETE) {

            //
            // <-- Return "command failed" error code
            //
            if(rcResponse.Status == FTP_RESPONSE_ACTION_NOT_TAKEN)
            {
                error = ERROR_NO_MORE_FILES;
            }
            else
            {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }            
            goto cleanup;
        }
    }

    if (bytesReceived == 0) {

        DEBUG_PRINT(WORKER,
                    ERROR,
                    ("ReceiveData() returns 0 bytes\n"
                    ));

        error = ERROR_NO_MORE_FILES;
        goto cleanup;
    }

    //
    // trap bad servers which return a not-found message in the data stream. We
    // only do this if we are not performing a wild-card search (because the
    // wild-card match will fail to match anything if the target file or path
    // cannot be found)
    //

    LPSTR lpszSearch;
    DWORD dwSearch;

    lpszSearch = (lpszPathPart == NULL) ? lpszFilePart : (LPSTR)lpszFilespec;
    dwSearch = lstrlen(lpszSearch);

    if (!isWild && (bytesReceived > dwSearch)) {
        if (!_strnicmp(lpBuffer, lpszSearch, dwSearch)
        && (lpBuffer[dwSearch] == ':')) {

            static char testChars[] = {'\r', '\n', '\0'};
            LPSTR lpStartOfString = lpBuffer + dwSearch + 1;
            LPSTR lpEndOfString;

            for (int i = 0; i < ARRAY_ELEMENTS(testChars); ++i) {
                lpEndOfString = strchr(lpStartOfString, testChars[i]);
                if (lpEndOfString != NULL) {
                    break;
                }
            }

            //
            // we should have found at least one of the target characters
            //

            INET_ASSERT(lpEndOfString != NULL);

            if (lpEndOfString != NULL) {

                int lengthToTest = (int) (lpEndOfString - lpStartOfString);

                //
                // BUGBUG - internationalization?
                //

                if (strnistr(lpStartOfString, "not found", lengthToTest)
                || strnistr(lpStartOfString, "cannot find", lengthToTest)) {
                    error = ERROR_NO_MORE_FILES;
                    goto cleanup;
                }
            } else {
                error = ERROR_INTERNET_INTERNAL_ERROR;
                goto cleanup;
            }
        }
    }

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)bytesReceived > 0);

    error = ParseDirList(lpBuffer,
                         bytesReceived,
                         isWild ? (LPSTR)lpszFilePart : NULL,
                         &lpSessionInfo->FindFileList
                         );

    //
    // ParseDirList() may have failed
    //

    if (error != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // if there's nothing in the list then no files matching the caller's
    // specification were found
    //

    if (IsListEmpty(&lpSessionInfo->FindFileList)) {
        error = ERROR_NO_MORE_FILES;
    } else {

        //
        // if the caller supplied an output buffer then return the first entry
        // and remove it from the list
        //

        if (ARGUMENT_PRESENT(lpFindFileData)) {

            PLIST_ENTRY pEntry;

            pEntry = RemoveHeadList(&lpSessionInfo->FindFileList);
            CopyMemory(lpFindFileData,
                       (LPWIN32_FIND_DATA)(pEntry + 1),
                       sizeof(*lpFindFileData)
                       );
            FREE_MEMORY(pEntry);
        }

        //
        // FTP can only have one active operation per session, so we just return
        // this session handle as the find handle
        //

        *lphInternet = hFtpSession;
        error = ERROR_SUCCESS;
    }

cleanup:

    if (lpSessionInfo->socketData->IsValid()) {
        lpSessionInfo->socketData->SetLinger(TRUE, 0);
        lpSessionInfo->socketData->Close();
    }

    if (lpBuffer != NULL) {
        (void)FREE_MEMORY((HLOCAL)lpBuffer);
    }

    //
    // if we failed then reset the active find flag. We set it, so we know it
    // is safe to reset without acquiring the session lock
    //

    if (error != ERROR_SUCCESS) {
        lpSessionInfo->Flags &= ~FFTP_FIND_ACTIVE;
    }

deref_exit:

    DereferenceFtpSession(lpSessionInfo);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpDeleteFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName
    )

/*++

Routine Description:

    Deletes a file at an FTP server

Arguments:

    hFtpSession     - identifies the FTP server

    lpszFileName    - name of file to delete

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpDeleteFile",
                "%#x, %q",
                hFtpSession,
                lpszFileName
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "DELE %s",
                        lpszFileName
                        );

        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpRenameFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    )

/*++

Routine Description:

    Renames a file at an FTP server

Arguments:

    hFtpSession     - identifies FTP server

    lpszExisting    - current file name

    lpszNew         - new file name

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpRenameFile",
                "%#x, %q, %q",
                hFtpSession,
                lpszExisting,
                lpszNew
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "RNFR %s",
                        lpszExisting
                        );

        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_CONTINUE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        if (error == ERROR_SUCCESS) {
            error = Command(lpSessionInfo,
                            FALSE,
                            FTP_TRANSFER_TYPE_UNKNOWN,
                            &rcResponse,
                            "RNTO %s",
                            lpszNew
                            );
            if ((error == ERROR_SUCCESS)
            && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpOpenFile(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    )

/*++

Routine Description:

    Initiates the connection to read or write a file at the FTP server

Arguments:

    hFtpSession     - identifies FTP server

    lpszFileName    - name of file to open

    dwAccess        - access mode - GENERIC_READ or GENERIC_WRITE

    dwFlags         - flags controlling how to transfer the data

    lphInternet     - where to return the open file handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpOpenFile",
                "%#x, %q, %#x, %#x, %#x",
                hFtpSession,
                lpszFileName,
                dwAccess,
                dwFlags,
                lphInternet
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        //
        // control session must be established
        //

        if (! lpSessionInfo->socketControl->IsValid()) {
            error = ERROR_FTP_DROPPED;
        } else if ((lpSessionInfo->socketData->IsValid())
        || (lpSessionInfo->Flags & FFTP_FILE_ACTIVE)) {

            //
            // there is a (file) transfer in progress if the socket is valid,
            // or we are awaiting a call to InternetCloseHandle() before we can
            // open another file (FFTP_FILE_ACTIVE is set. This stops another
            // thread from closing our socket handle)
            //

            error = ERROR_FTP_TRANSFER_IN_PROGRESS;
        } else {

            FTP_RESPONSE_CODE rcResponse;

            INET_ASSERT(!lpSessionInfo->socketData->IsValid());

            //
            // Clear the session's "known size bit" before we download the next file,
            //  this is to make sure we don't read an extranous size value off it.
            //

            lpSessionInfo->Flags &= ~(FFTP_KNOWN_FILE_SIZE);

            //
            // send the connection set-up commands, and issue either the send
            // or the receive command
            //
            // Either "RETR filename" or "STOR filename"
            //

            error = NegotiateDataConnection(lpSessionInfo,
                                            dwFlags,
                                            &rcResponse,
                                            (dwAccess & GENERIC_READ)
                                                 ? "RETR %s"
                                                 : "STOR %s",
                                            lpszFileName
                                            );

            if (error == ERROR_SUCCESS) {

                //
                // Check response for failure
                //

                if ((rcResponse.Major != FTP_RESPONSE_PRELIMINARY)
                && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {

                    ICSocket * socketData;

                    //
                    // BUGBUG - RLF - don't know if this is what's intended
                    //          here, but the code just used to check
                    //          socketData != INVALID_SOCKET. Since socketData
                    //          was getting set to INVALID_SOCKET at the top
                    //          of this routine, this branch would never be
                    //          taken
                    //

                    socketData = lpSessionInfo->socketData;
                    if (socketData->IsValid()) {
                        ResetSocket(socketData);
                    }
                    error = ERROR_INTERNET_EXTENDED_ERROR;
                } else {

                    lpSessionInfo->dwTransferAccess = dwAccess;

                    //
                    // Some FTP servers will send us back both the preliminary
                    // response and the complete response so quickly that we
                    // will never see the preliminary.
                    //
                    // In order for FtpCloseFile() to know that the completion
                    // response has been received, we store the response
                    // structure in the Session Info.
                    //
                    // The response structure only needs to be stored between
                    // API calls in this situation, it is not generally
                    // referred to.
                    //

                    SetSessionLastResponseCode(lpSessionInfo, &rcResponse);

                    //
                    // set the abort flag if the file was opened for read - this
                    // lets the server know it can clean up the session if we
                    // close early
                    //

                    if (dwAccess & GENERIC_READ) {
                        lpSessionInfo->Flags |= FFTP_ABORT_TRANSFER;
                    }

                    //
                    // FTP can only have one active operation per session, so
                    // we just return this session handle as the find handle
                    //

                    *lphInternet = hFtpSession;

                    //
                    // this session has an active file operation
                    //

                    lpSessionInfo->Flags |= FFTP_FILE_ACTIVE;

                    //
                    // N.B. error == ERROR_SUCCESS from above test after call
                    // to NegotiateDataConnection
                    //

                    INET_ASSERT(error == ERROR_SUCCESS);
                }
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpCreateDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Creates a directory at the FTP server

Arguments:

    hFtpSession     - identifies the FTP server

    lpszDirectory   - directory to create

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpCreateDirectory",
                "%#x, %q",
                hFtpSession,
                lpszDirectory
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "MKD %s",
                        lpszDirectory
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpRemoveDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Removes the named directory at the FTP server

Arguments:

    hFtpSession     - identifies the FTP server

    lpszDirectory   - directory to remove

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpRemoveDirectory",
                "%#x, %q",
                hFtpSession,
                lpszDirectory
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "RMD %s",
                        lpszDirectory
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpSetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    )

/*++

Routine Description:

    Sets the current directory for this FTP server session

Arguments:

    hFtpSession     - identifies the FTP server/session

    lpszDirectory   - name of directory to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpSetCurrentDirectory",
                "%#x, %q",
                hFtpSession,
                lpszDirectory
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "CWD %s",
                        lpszDirectory
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpGetCurrentDirectory(
    IN HINTERNET hFtpSession,
    IN DWORD cchCurrentDirectory,
    OUT LPSTR lpszCurrentDirectory,
    OUT LPDWORD lpdwBytesReturned
    )

/*++

Routine Description:

    Gets the current working directory at the FTP server for this session

Arguments:

    hFtpSession             - identifies FTP server

    cchCurrentDirectory     - number of characters in lpszCurrentDirectory

    lpszCurrentDirectory    - buffer where current directory string is written

    lpdwBytesReturned       - number of characters in output string NOT including
                              terminating NUL

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

                  ERROR_INSUFFICIENT_BUFFER
                    The buffer in lpszCurrentDirectory is not large enough to
                    hold the directory string. *lpdwBytesReturned will have
                    the required size

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpGetCurrentDirectory",
                "%#x, %d, %#x, %#x",
                hFtpSession,
                cchCurrentDirectory,
                lpszCurrentDirectory,
                lpdwBytesReturned
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD cchCopied;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "PWD"
                        );
        if ((error == ERROR_SUCCESS)
        && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
        if (error == ERROR_SUCCESS) {

            LPSTR pchResponse;

            //
            // parse the returned directory name out of the response text
            //

            pchResponse = InternetLockErrorText();
            if (pchResponse != NULL) {
                pchResponse = strstr(pchResponse, "257 ");
                if (pchResponse != NULL) {
                    pchResponse = strchr(pchResponse, '\"');
                    if (pchResponse != NULL) {

                        int idx;

                        ++pchResponse;
                        for (idx = 0, cchCopied = 0; pchResponse[idx] != '\0'; idx++) {
                            if (pchResponse[idx] == '\"') {
                                if (pchResponse[idx + 1] == '\"') {
                                    continue;
                                }
                                break;
                            }
                            if (cchCopied < cchCurrentDirectory) {
                                lpszCurrentDirectory[cchCopied] = pchResponse[idx];
                            }
                            cchCopied++;
                        }
                        if (cchCopied < cchCurrentDirectory) {
                            lpszCurrentDirectory[cchCopied] = '\0';
                            error = ERROR_SUCCESS;
                        } else {
                            error = ERROR_INSUFFICIENT_BUFFER;
                            ++cchCopied;
                        }
                    } else {
                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                }
                //InternetUnlockErrorText();
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    if ((error == ERROR_SUCCESS) || (error == ERROR_INSUFFICIENT_BUFFER)) {
        *lpdwBytesReturned = cchCopied;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpCommand(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand
    )

/*++

Routine Description:

    Runs arbitrary command at an FTP server. Direct connect over Internet

Arguments:

    hFtpSession     - identifies the FTP server

    fExpectResponse - TRUE if we expect a response from the server

    dwFlags         - type of response - ASCII text or BINARY data

    lpszCommand     - pointer to string describing command to run

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpCommand",
                "%#x, %#x, %#x, %q",
                hFtpSession,
                fExpectResponse,
                dwFlags,
                lpszCommand
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    //
    // Look up the given handle.
    //

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        //
        // Issue the command.
        //

        error = Command(lpSessionInfo,
                        fExpectResponse,
                        dwFlags,
                        &rcResponse,
                        lpszCommand
                        );
        if (fExpectResponse && (error == ERROR_SUCCESS)) {

            INET_ASSERT(lpSessionInfo->socketData->IsValid());

            lpSessionInfo->dwTransferAccess |= (GENERIC_READ|GENERIC_WRITE);

        }
#if DBG
        else {

            INET_ASSERT(! lpSessionInfo->socketData->IsValid());

        }

        if (error == ERROR_SUCCESS) {

            INET_ASSERT(lpSessionInfo->socketControl->IsValid());

        }

#endif

        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


//
// Internet subordinate functions
//

DWORD
wFtpFindNextFile(
    IN HINTERNET hFtpSession,
    OUT LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    Returns the next file found from a call to FtpFindFirstFile().

Arguments:

    hFtpSession     - Handle to an FTP session, as returned from FtpConnect()

    lpFindFileData  - Pointer to a buffer that will contain WIN32_FIND_DATA
                      information when this call succeeds.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NO_MORE_FILES
                    The end of the file list has been reached.

                  ERROR_INVALID_HANDLE
                    Can't find session that knows about hFind
--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindNextFile",
                "%#x, %#x",
                hFtpSession,
                lpFindFileData
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        //
        // ISSUE this code is cut & paste from find first - they should both call a
        // fn instead
        //

        if (!IsListEmpty(&lpSessionInfo->FindFileList)) {

            PLIST_ENTRY pEntry;

            //
            // Enumerate the first entry and advance pointers
            //

            pEntry = RemoveHeadList(&lpSessionInfo->FindFileList);

            INET_ASSERT(pEntry != NULL);

            CopyMemory(lpFindFileData,
                       (LPWIN32_FIND_DATA)(pEntry + 1),
                       sizeof(WIN32_FIND_DATA)
                       );
            FREE_MEMORY(pEntry);
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NO_MORE_FILES;
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpFindClose(
    IN HINTERNET hFtpSession
    )

/*++

Routine Description:

    Frees the WIN32_FIND_DATA structures in the directory list for this session

Arguments:

    hFtpSession - handle of an FTP session, created by InternetConnect

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindClose",
                "%#x",
                hFtpSession
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {
        ClearFindList(&lpSessionInfo->FindFileList);

        //
        // this session no longer has an active directory listing
        //

        lpSessionInfo->Flags &= ~FFTP_FIND_ACTIVE;
        DereferenceFtpSession(lpSessionInfo);
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpConnect(
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUsername,
    IN LPCSTR lpszPassword,
    IN DWORD dwService,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    )

/*++

Routine Description:

    Creates a new FTP session object

Arguments:

    lpszServerName  - pointer to string identifying FTP server

    nServerPort     - port number to connect to

    lpszUsername    - pointer to string identifying user name to log on as

    lpszPassword    - pointer to string identifying password to use with user name

    dwService       - service type parameter (unused)

    dwFlags         - session flags. Currently only INTERNET_FLAG_PASSIVE
                      is defined

    lphInternet     - returned handle of created FTP session

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory while creating the session object

                  ERROR_INTERNET_OUT_OF_HANDLES
                    Ran out of handles while creating the session object

                  ERROR_INTERNET_SHUTDOWN
                    The DLL is being unloaded

--*/

{
    INET_ASSERT(lpszUsername != NULL);
    INET_ASSERT(lpszPassword != NULL);

    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpConnect",
                "%q, %d, %q, %q, %d, %#x, %#x",
                lpszServerName,
                nServerPort,
                lpszUsername,
                lpszPassword,
                dwService,
                dwFlags,
                lphInternet
                ));

    DWORD error;
    LPFTP_SESSION_INFO sessionInfo;

    UNREFERENCED_PARAMETER(lpszUsername);
    UNREFERENCED_PARAMETER(lpszPassword);
    UNREFERENCED_PARAMETER(dwService);

    //
    // create a new FTP session object
    //

    error = CreateFtpSession((LPSTR)lpszServerName,
                             nServerPort,

                             //
                             // if INTERNET_FLAG_PASSIVE then create a passive
                             // session object
                             //

                             (dwFlags & INTERNET_FLAG_PASSIVE)
                                ? FFTP_PASSIVE_MODE
                                : 0,
                             &sessionInfo
                             );
    if (error == ERROR_SUCCESS) {

        //
        // return the FTP_SESSION_INFO handle
        //

        *lphInternet = sessionInfo->Handle;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpMakeConnection(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszUsername,
    IN LPCSTR lpszPassword
    )

/*++

Routine Description:

    Connect with and log into an FTP server.

    This function is cancellable

Arguments:

    hFtpSession - handle of an FTP session, created by InternetConnect

    pszUsername - pointer to string identifying user name to log on as

    pszPassword - pointer to string identifying password to use with user name

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INCORRECT_USER_NAME
                    The server didn't like the user name

                  ERROR_INTERNET_INCORRECT_PASSWORD
                    The server didn't like the password

                  ERROR_INTERNET_LOGIN_FAILURE
                    The server rejected the login request

                  ERROR_FTP_DROPPED
                    The connection has been closed

                  ERROR_FTP_TRANSFER_IN_PROGRESS
                    There is already a transfer in progress on this connection

                  ERROR_INTERNET_NAME_NOT_RESOLVED
                    Couldn't resolve the server name

                  WSA error
                    Couldn't connect to the server, or problems while
                    communicating with it

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpMakeConnection",
                "%#x, %q, %q",
                hFtpSession,
                lpszUsername,
                lpszPassword
                ));

    LPFTP_SESSION_INFO sessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &sessionInfo)) {

        //
        // resolve the FTP server's host name and connect to the server
        //

        error = FtpOpenServer(sessionInfo);
        if (error == ERROR_SUCCESS) {

            FTP_RESPONSE_CODE rcResponse;

            //
            // set send and receive timeouts on the control channel socket.
            // Ignore any errors
            //

            sessionInfo->socketControl->SetTimeout(
                        SEND_TIMEOUT,
                        GetTimeoutValue(INTERNET_OPTION_CONTROL_SEND_TIMEOUT)
                        );

            sessionInfo->socketControl->SetTimeout(
                        RECEIVE_TIMEOUT,
                        GetTimeoutValue(INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT)
                        );

            //
            // check greeting and store in per-thread response text buffer
            //

            error = GetReply(sessionInfo, &rcResponse);
            if (error == ERROR_SUCCESS) {

                //
                // check that the server sent us an affirmative response
                //

                if (rcResponse.Major == FTP_RESPONSE_COMPLETE) {

                    //
                    // send the user name
                    //

                    error = Command(sessionInfo,
                                    FALSE,
                                    FTP_TRANSFER_TYPE_UNKNOWN,
                                    &rcResponse,
                                    "USER %s",
                                    lpszUsername
                                    );

                    //
                    // BUGBUG - is it possible to get success from Command(),
                    //          but an error from the server - e.g. 332, need
                    //          account for login?
                    //

                    if (error == ERROR_SUCCESS) {

                        //
                        // send the password if required
                        //

                        if (rcResponse.Major == FTP_RESPONSE_CONTINUE) {
                            error = Command(sessionInfo,
                                            FALSE,
                                            FTP_TRANSFER_TYPE_UNKNOWN,
                                            &rcResponse,
                                            "PASS %s",
                                            lpszPassword
                                            );

                            //
                            // if we failed to send the password, or the password
                            // was rejected, or we are attempting to log on as
                            // "anonymous" and it turns out that the server does
                            // not allow anonymous logon, then return a password
                            // error. The caller can still check the response
                            // from the server
                            //

                            if (((error == ERROR_SUCCESS)
                                && (rcResponse.Major != FTP_RESPONSE_COMPLETE))
                            || (error == ERROR_INTERNET_EXTENDED_ERROR)) {
                                if (stricmp(lpszUsername, "anonymous") == 0) {
                                    error = ERROR_INTERNET_LOGIN_FAILURE;
                                } else {
                                    error = ERROR_INTERNET_INCORRECT_PASSWORD;
                                }
                            }
                        } else if (rcResponse.Major != FTP_RESPONSE_COMPLETE) {
                            error = ERROR_INTERNET_INCORRECT_USER_NAME;
                        }

                        //
                        // get the server type
                        //

                        //if (error == ERROR_SUCCESS) {
                        //    error = wFtpFindServerType(hFtpSession);
                        //}
                    }
                } else {
                    error = ERROR_INTERNET_LOGIN_FAILURE;
                }
            }
        }

        //
        // success or fail: unlock the session object
        //

        DereferenceFtpSession(sessionInfo);

        //
        // if we failed to login then let wFtpDisconnect() clean up - it will
        // also send a "QUIT" to the server (if we have a control connection)
        // which will ensure a clean exit
        //

        if (error != ERROR_SUCCESS) {

            //
            // if we experience an error during disconnect, we will just ignore
            // it and return the error generated during our failed login attempt
            //

            (void)wFtpDisconnect(hFtpSession, CF_EXPEDITED_CLOSE);
        }
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpDisconnect(
    IN HINTERNET hFtpSession,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Closes the connection, issues the quit command, etc.,

Arguments:

    hFtpSession - FTP session created by wFtpConnect

    dwFlags     - controlling operation. Can be:

                    CF_EXPEDITED_CLOSE  - Don't send QUIT to the server, just
                                          close the control connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpDisconnect",
                "%#x, %#x",
                hFtpSession,
                dwFlags
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        ICSocket * socketControl;
        ICSocket * socketData;

        socketControl = lpSessionInfo->socketControl;
        socketData = lpSessionInfo->socketData;

        //
        // kill any active data transfer
        //

        if (socketData->IsValid()) {

            //
            // set the non-blocking state depending on whether we are called in
            // an app thread context, or in the async scheduler thread context
            //

            //socketData->SetNonBlockingMode(lpThreadInfo->IsAsyncWorkerThread);

            if (dwFlags & CF_EXPEDITED_CLOSE) {
                error = socketData->Close();
            } else {
                error = wFtpCloseFile(hFtpSession);
                if (error != ERROR_SUCCESS) {

                    DEBUG_PRINT(WORKER,
                                ERROR,
                                ("wFtpCloseFile() returns %d\n",
                                error
                                ));

                }
            }
        }

        INET_ASSERT(!lpSessionInfo->socketData->IsValid());

        //
        // perform graceful close to the server if we have a control connection
        //

        if (socketControl->IsValid()) {

            //
            // set the non-blocking state depending on whether we are called in
            // an app thread context, or in the async scheduler thread context
            //

            //socketControl->SetNonBlockingMode(lpThreadInfo->IsAsyncWorkerThread);

            if (!(dwFlags & CF_EXPEDITED_CLOSE)) {

                FTP_RESPONSE_CODE rcResponse;

                Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "QUIT"
                        );
            }
            lpSessionInfo->socketControl->Disconnect(SF_INDICATE);
        }

        //
        // finally kill the FTP_SESSION_INFO structure
        //

        TerminateFtpSession(lpSessionInfo);
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpReadFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Reads data from the FTP server. We use the data channel

Arguments:

    hFtpSession             - handle identifying FTP session

    lpBuffer                - pointer to buffer for received data

    dwNumberOfBytesToRead   - size of lpBuffer in bytes

    lpdwNumberOfBytesRead   - returned number of bytes received

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find hFtpSession

                  ERROR_ACCESS_DENIED
                    This session doesn't have read access (?)

                  ERROR_FTP_DROPPED
                    The data channel has been closed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpReadFile",
                "%#x, %#x, %d, %#x",
                hFtpSession,
                lpBuffer,
                dwNumberOfBytesToRead,
                lpdwNumberOfBytesRead
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;
    ICSocket * socketData;
    BOOL eof;
    DWORD bytesReceived;

    //
    // initialize variables in case we quit early (i.e. via goto)
    //

    bytesReceived = 0;

    //
    // find the FTP_SESSION_INFO and ensure it is set up to receive data
    //

    if (!FindFtpSession(hFtpSession, &lpSessionInfo)) {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    //
    // if FFTP_EOF is set then we already reached the end the file
    //

    if (lpSessionInfo->Flags & FFTP_EOF) {
        error = ERROR_SUCCESS;
        goto unlock_and_quit;
    }

    //
    // get the data socket. If it has become INVALID_SOCKET then the server
    // closed the connection
    //

    socketData = lpSessionInfo->socketData;
    if (!socketData->IsValid()) {
        error = ERROR_FTP_DROPPED;
        goto unlock_and_quit;
    }

    if (!(lpSessionInfo->dwTransferAccess & GENERIC_READ)) {
        error = ERROR_ACCESS_DENIED;
        goto unlock_and_quit;
    }

    //
    // read until we fill the users buffer, get an error, or get to EOF
    //

    DWORD bufferRemaining;

    bufferRemaining = dwNumberOfBytesToRead;
    error = socketData->Receive(
                          &lpBuffer,
                          &dwNumberOfBytesToRead,   // lpdwBufferLength
                          &bufferRemaining,         // lpdwBufferRemaining
                          &bytesReceived,           // lpdwBytesReceived
                          0,                        // dwExtraSpace
                          SF_RECEIVE_ALL
                          | SF_INDICATE,
                          &eof
                          );
    if (error == ERROR_SUCCESS) {

        //
        // if we got to EOF then the server will have closed the data
        // connection. We need to close the socket at our end. If this is
        // a passive connection then we initiate session termination
        //

        if (eof) {
            (void)socketData->Close();

            INET_ASSERT(lpSessionInfo->socketData == socketData);

            //
            // reset the abort flag - we no longer have to send and ABOR command
            // when we close the handle
            //

            lpSessionInfo->Flags &= ~FFTP_ABORT_TRANSFER;

            //
            // set EOF in the FTP_SESSION_INFO flags so we know next time
            // we call this function that the session is not dropped, but
            // that we already reached the end of the data
            //

            lpSessionInfo->Flags |= FFTP_EOF;
        }
    }

    //
    // BUGBUG - in error case we should probably close the socket, set
    //          INVALID_SOCKET in the FTP_SESSION_INFO, etc.
    //

unlock_and_quit:

    //
    // update the output parameters if we succeeded
    //

    if (error == ERROR_SUCCESS) {
        *lpdwNumberOfBytesRead = bytesReceived;
    }

    DereferenceFtpSession(lpSessionInfo);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpWriteFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    Writes data to the FTP server. We use the data channel

Arguments:

    hFtpSession                 - handle identifying FTP session

    lpBuffer                    - pointer to buffer containing data to write

    dwNumberOfBytesToWrite      - size of lpBuffer in bytes

    lpdwNumberOfBytesWritten    - returned number of bytes sent

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find hFtpSession

                  ERROR_ACCESS_DENIED
                    This session doesn't have write access (?)

                  ERROR_FTP_DROPPED
                    The data channel has been closed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpWriteFile",
                "%#x, %#x, %d, %#x",
                hFtpSession,
                lpBuffer,
                dwNumberOfBytesToWrite,
                lpdwNumberOfBytesWritten
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;
    ICSocket * socketData;
    int nSent;

    //
    // find the FTP_SESSION_INFO and ensure it is set up to send data
    //

    if (!FindFtpSession(hFtpSession, &lpSessionInfo)) {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    socketData = lpSessionInfo->socketData;
    if (! socketData->IsValid()) {
        error = ERROR_FTP_DROPPED;
        goto unlock_and_quit;
    }

    if (!(lpSessionInfo->dwTransferAccess & GENERIC_WRITE)) {
        error = ERROR_ACCESS_DENIED;
        goto unlock_and_quit;
    }

    error = socketData->Send(lpBuffer, dwNumberOfBytesToWrite, SF_INDICATE);
    if (error == ERROR_SUCCESS) {
        *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
    } else {

        //
        // we had a failure. We should check the control socket for any error
        // info from the server
        //

        FTP_RESPONSE_CODE response = {0};
        response.Major = FTP_RESPONSE_PERMANENT_FAILURE;
        //
        SetSessionLastResponseCode(lpSessionInfo, &response);
    }

unlock_and_quit:

    DereferenceFtpSession(lpSessionInfo);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpQueryDataAvailable(
    IN HINTERNET hFtpSession,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines amount of data available to be received on a data (file) socket

Arguments:

    hFtpSession                 - identifies FTP session

    lpdwNumberOfBytesAvailable  - returned number of bytes available

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpQueryDataAvailable",
                "%#x, %#x",
                hFtpSession,
                lpdwNumberOfBytesAvailable
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(lpThreadInfo->hObjectMapped, &handleType);

    if (error != ERROR_SUCCESS) {
        return (error);
    }

    *lpdwNumberOfBytesAvailable = 0;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPFTP_SESSION_INFO lpSessionInfo;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        //
        // if we are currently performing a directory list then return the size
        // of a dir list entry
        //

        if (lpSessionInfo->Flags & FFTP_FIND_ACTIVE) {
            *lpdwNumberOfBytesAvailable = !IsListEmpty(&lpSessionInfo->FindFileList)
                                        ? sizeof(WIN32_FIND_DATA) : 0;
        } else {

            //
            // otherwise, if we are receiving data, find out how much
            //

            ICSocket * socketData;

            socketData = lpSessionInfo->socketData;
            if (socketData->IsValid()) {
                error = socketData->DataAvailable(lpdwNumberOfBytesAvailable);
            } else {

                //
                // there is no data connection
                //

                *lpdwNumberOfBytesAvailable = 0;
                error = ERROR_SUCCESS;
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

quit:

    if ((error == ERROR_SUCCESS) && (*lpdwNumberOfBytesAvailable == 0)) {

        InbLocalEndCacheWrite(lpThreadInfo->hObjectMapped,
                                            ((handleType==TypeFtpFindHandleHtml)
                                            ?"htm":NULL),
                                            TRUE);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpCloseFile(
    IN HINTERNET hFtpSession
    )

/*++

Routine Description:

    Terminates the connection used for file transfer. The connection may already
    be closed (by the server during a READ, or by the client during a WRITE) in
    which case we just need to receive the confirmation (226) on the control
    socket. If the connection is still open, or the abort flag is set for this
    connection, then this is an abnormal termination, and we need to send an
    ABORt command

Arguments:

    hFtpSession - Identifies the session on which to terminate file transfer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the FTP_SESSION_INFO corresponding to
                    hFtpSession

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpCloseFile",
                "%#x",
                hFtpSession
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        BOOL getResponse;
        ICSocket * socketData;
        FTP_RESPONSE_CODE rcResponse;

        socketData = lpSessionInfo->socketData;
        if (socketData->IsValid()) {

            //
            // if we are performing a read/write operation and the transfer
            // isn't complete then abort the connection
            //

            if (lpSessionInfo->Flags & FFTP_ABORT_TRANSFER) {
                AbortTransfer(lpSessionInfo);
                ResetSocket(lpSessionInfo->socketData);
            } else {

                //
                // in all other cases - completed READ, complete or incomplete
                // WRITE - just close the socket
                //

                lpSessionInfo->socketData->Close();
            }
        } else if (lpSessionInfo->Flags & FFTP_ABORT_TRANSFER) {

            //
            // we have no data socket, but the abort transfer flag is set. We
            // are probably closing a file we opened for read without having
            // read any data. In this case we send an abort anyway
            //

            AbortTransfer(lpSessionInfo);
        }

        //
        // get the server response - we expect either 226 to a good transfer,
        // or 426 for an aborted transfer...
        //

        GetSessionLastResponseCode(lpSessionInfo, &rcResponse);
        if (rcResponse.Major == FTP_RESPONSE_PRELIMINARY) {
            error = GetReply(lpSessionInfo, &rcResponse);
            SetLastError(ERROR_SUCCESS);  // a-thkesa;. added from Win CE fix of BUG WinSE: 23985
            if ((error == ERROR_SUCCESS)
            && (rcResponse.Major != FTP_RESPONSE_COMPLETE)) {
                error = ERROR_INTERNET_EXTENDED_ERROR;
                SetLastError(error); // a-thkesa;. added from Win CE fix of BUG WinSE: 23985 
            }
        } else if (rcResponse.Major == FTP_RESPONSE_PERMANENT_FAILURE){
            error = ERROR_SUCCESS;
        } else {
            if(rcResponse.Major != FTP_RESPONSE_COMPLETE)
                error = GetReply(lpSessionInfo, &rcResponse);
            else
                error = ERROR_SUCCESS;
        }

        //
        // reset the ABORT, FILE_ACTIVE and EOF flags
        //

        lpSessionInfo->Flags &= ~(FFTP_ABORT_TRANSFER
                                  | FFTP_EOF
                                  | FFTP_FILE_ACTIVE
                                  );
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wFtpFindServerType(
    IN HINTERNET hFtpSession
    )

/*++

Routine Description:

    Determines the type of server we are talking to (NT or Unix)

Arguments:

    hFtpSession - identifies FTP_SESSION_INFO. The structure ServerType field
                  will be updated with the discovered info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the FTP_SESSION_INFO corresponding to
                    hFtpSession

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpFindServerType",
                "%#x",
                hFtpSession
                ));

    LPFTP_SESSION_INFO lpSessionInfo;
    DWORD error;

    if (FindFtpSession(hFtpSession, &lpSessionInfo)) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "SYST"
                        );
        if (error == ERROR_SUCCESS) {

            LPSTR lpszResponse = InternetLockErrorText();

            if (lpszResponse != NULL) {

                FTP_SERVER_TYPE serverType = FTP_SERVER_TYPE_UNKNOWN;

                //
                // "215 " must be first token in response text
                //

                lpszResponse = strstr(lpszResponse, "215 ");
                if (lpszResponse != NULL) {

                    //
                    // check for existence of "Windows_NT" or "Unix" (case
                    // insensitive comparison)
                    //

                    //
                    // BUGBUG - find out from MuraliK/TerryK the values these
                    //          ids can have
                    //

                    static struct {
                        LPCSTR lpszSystemName;
                        FTP_SERVER_TYPE ServerType;
                    } FtpServerTypes[] = {
                        "Windows_NT",   FTP_SERVER_TYPE_NT,
                        "Unix",         FTP_SERVER_TYPE_UNIX
                    };

                    DWORD textLength = strlen(lpszResponse);

                    for (int i = 0; i < ARRAY_ELEMENTS(FtpServerTypes); ++i) {
                        if (strnistr(lpszResponse,
                                     (LPSTR)FtpServerTypes[i].lpszSystemName,
                                     textLength
                                     ) != NULL) {

                            serverType = FtpServerTypes[i].ServerType;

                            DEBUG_PRINT(FTP,
                                        INFO,
                                        ("serverType = %s (%d)\n",
                                        InternetMapFtpServerType(serverType),
                                        serverType
                                        ));

                            break;
                        }
                    }
                }
                lpSessionInfo->ServerType = serverType;
                //InternetUnlockErrorText();
            }
        }
        DereferenceFtpSession(lpSessionInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}



#if 0

//
// We don't use this today, because FtpGetFileSize does not support
//   issuing backround commands through the FTP Control socket while
//   the user is doing an FTP download (with FtpOpenFile)
//


DWORD
wFtpGetFileSize(
    IN  HINTERNET hMappedFtpSession,
    IN  LPFTP_SESSION_INFO lpSessionInfo,
    OUT LPDWORD lpdwFileSizeLow,
    OUT LPDWORD lpdwFileSizeHigh
    )

/*++

Routine Description:

    Finds size of a file at server

Arguments:

    hFtpSession         - identifies mapped FTP handle obj

    lpSessionInfo       - LPFTP_SESSION_INFO structure ptr.

    lpdwFileSizeLow     - pointer to low dword of file size

    lpdwFileSizeHigh    - optional output pointer to high dword of file size

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the FTP_SESSION_INFO corresponding to
                    hFtpSession

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "wFtpGetFileSize",
                "%#x, %#x, %#x, %#x",
                hMappedFtpSession,
                lpSessionInfo,
                lpdwFileSizeLow,
                lpdwFileSizeHigh
                ));


    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;
    FTP_FILE_HANDLE_OBJECT * pFileMapped = (FTP_FILE_HANDLE_OBJECT *) hMappedFtpSession;

    *lpdwFileSizeLow  = 0;
    *lpdwFileSizeHigh = 0;

    if (lpSessionInfo) {

        FTP_RESPONSE_CODE rcResponse;

        error = Command(lpSessionInfo,
                        FALSE,
                        FTP_TRANSFER_TYPE_UNKNOWN,
                        &rcResponse,
                        "SIZE %s",
                        pFileMapped->GetFileName()
                        );
        if (error == ERROR_SUCCESS) {

            LPSTR lpszResponse = InternetLockErrorText();

            if (lpszResponse != NULL) {

                FTP_SERVER_TYPE serverType = FTP_SERVER_TYPE_UNKNOWN;

                //
                // "213 " must be first token in response text of file size
                //

                lpszResponse = strstr(lpszResponse, "213 ");
                if (lpszResponse != NULL) {
                    *lpdwFileSizeLow = atoi(lpszResponse);
                    error = ERROR_SUCCESS;
                }
            }
        }
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}
#endif

//
// private debug functions
//

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
InternetMapFtpServerType(
    IN FTP_SERVER_TYPE ServerType
    )
{
    switch (ServerType) {
    CASE_OF(FTP_SERVER_TYPE_UNKNOWN);
    CASE_OF(FTP_SERVER_TYPE_NT);
    CASE_OF(FTP_SERVER_TYPE_UNIX);
    }
    return "?";
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpapiu.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpapiu.h

Abstract:

    Header for ftpapiu.h

Author:

    Richard L Firth (rfirth) 31-May-1995

Revision History:

    31-May-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
ParseFtpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD Context
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\makefile.inc ===
lprmnmsg.h lprmnmsg.rc msg00001.bin: lprmnmsg.mc
    mc -v lprmnmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpinit.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpinit.cxx

Abstract:

    FTP package-specific initialization & termination. Used to be libmain.c

    Contents:
        FtpInitialize
        FtpTerminate

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Environment:

    Win32 user-mode

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// functions
//


VOID
FtpInitialize(
    VOID
    )

/*++

Routine Description:

    Performs FTP-specific initialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    FtpSessionInitialize();
}


VOID
FtpTerminate(
    VOID
    )

/*++

Routine Description:

    Performs FTP-specific termination/cleanup

Arguments:

    None.

Return Value:

    None.

--*/

{
    CleanupFtpSessions();
    FtpSessionTerminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpapiu.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpapiu.cxx

Abstract:

    Common sub-API level FTP functions (created from dll\parseurl.c)

    Contents:
        ParseFtpUrl

Author:

    Richard L Firth (rfirth) 31-May-1995

Environment:

    Win32 user-level DLL

Revision History:

    31-May-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

//
// functions
//


DWORD
ParseFtpUrl(
    IN OUT LPHINTERNET lphInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    )

/*++

Routine Description:

    URL parser for FTP URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls FTP APIs to
    do the work

Arguments:

    lphInternet     - IN: pointer to InternetOpen handle
                      OUT: if successful handle of opened item, else undefined

    Url             - pointer to string containing FTP URL to open

    SchemeLength    - length of the URL scheme, exluding "://"

    Headers         - unused for FTP

    HeadersLength   - unused for FTP

    OpenFlags       - optional flags for opening a file (cache/no-cache, etc.)

    Context         - app-supplied context value for call-backs

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Dword,
                 "ParseFtpUrl",
                 "%#x [%#x], %q, %d, %#x, %d, %#x, %#x",
                 lphInternet,
                 *lphInternet,
                 Url,
                 SchemeLength,
                 Headers,
                 HeadersLength,
                 OpenFlags,
                 Context
                 ));

    UNREFERENCED_PARAMETER(Headers);
    UNREFERENCED_PARAMETER(HeadersLength);

    //
    // parse out the name[:password] and host[:port] parts
    //

    DWORD urlLength;
    LPSTR pUserName;
    DWORD userNameLength;
    LPSTR pPassword;
    DWORD passwordLength;
    LPSTR pHostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR lpszUrl = NULL, lpszBackup = NULL;
    char firstUrlPathCharacter;

    HINTERNET hConnect = NULL;
    DWORD error;

    // The passed in Url string gets munged during this function.
    // Make a copy, so the proper URL is set to the mapped connection handle.
    lpszUrl = NewString((LPCSTR)Url);
    if (lpszUrl == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    lpszBackup = lpszUrl;

    lpszUrl += SchemeLength + sizeof("://") - 1;

    error = GetUrlAddress(&lpszUrl,
                          &urlLength,
                          &pUserName,
                          &userNameLength,
                          &pPassword,
                          &passwordLength,
                          &pHostName,
                          &hostNameLength,
                          &port,
                          NULL
                          );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we can safely zero-terminate the address parts - the '/' between address
    // info and url-path is not significant
    //

    //if (*Url == '/') {
    //    ++Url;
    //    --urlLength;
    //}
    if (pUserName != NULL) {
        pUserName[userNameLength] = '\0';
    }
    if (pPassword != NULL) {
        pPassword[passwordLength] = '\0';
    }

    //
    // now get the FTP file/directory information
    //

    BOOL isDirectory;

    if ((*lpszUrl == '\0') || (*(lpszUrl + 1) == '\0')) {

        //
        // if the URL just consisted of ftp://host then by default we are
        // referencing an FTP directory (the root directory)
        //

        isDirectory = TRUE;
    } else {

        LPSTR pSemiColon;

        pSemiColon = strchr(lpszUrl, ';');
        if (pSemiColon != NULL) {

            //
            // if there's not enough space left in the string after ';' for the
            // "type=?" substring, then assume this URL is bad
            //

            if ((urlLength - (pSemiColon - lpszUrl)) < 6) {
                error = ERROR_INTERNET_INVALID_URL;
                goto quit;
            }
            if (strnicmp(pSemiColon + 1, "type=", 5) == 0) {
                switch (tolower(*(pSemiColon + 6))) {
                case 'a':
                    OpenFlags |= FTP_TRANSFER_TYPE_ASCII;
                    isDirectory = FALSE;
                    *pSemiColon = '\0';
                    break;

                case 'i':
                    OpenFlags |= FTP_TRANSFER_TYPE_BINARY;
                    isDirectory = FALSE;
                    *pSemiColon = '\0';
                    break;

                case 'd':
                    isDirectory = TRUE;
                    break;

                default:
                    error = ERROR_INTERNET_INVALID_URL;
                    goto quit;
                }
            } else {

                //
                // found a ';', but not "type=". Don't understand this URL
                //

                error = ERROR_INTERNET_INVALID_URL;
                goto quit;
            }
            urlLength = (DWORD) (pSemiColon - lpszUrl);
        } else {

            //
            // there is no ;type= field to help us out. If the string ends in /
            // then it is a directory. Further, if the url-path refers to a
            // file, we don't know which mode to use to transfer it - ASCII or
            // BINARY. We'll default to binary
            //

            if (lpszUrl[urlLength - 1] == '/') {
                isDirectory = TRUE;
            } else {
                OpenFlags |= FTP_TRANSFER_TYPE_BINARY;
                isDirectory = FALSE;
            }
        }

        //
        // decode the url-path
        //
        if(FAILED(UrlUnescapeInPlace(lpszUrl, 0))){
            goto quit;
        }
        urlLength = lstrlen(lpszUrl);
    }

    //
    // we potentially need to go round this loop 3 times:
    //
    //  1. try to get the item from the cache
    //  2. try to get the item from the origin server
    //  3. only if we got an existing connect & the origin server request
    //     failed, reopen the connect handle & try step 2 again
    //
    // however, we only need make one attempt if we're in OFFLINE mode - either
    // we can get the item from the cache, or we can't
    //

    HINTERNET hInternetMapped;

    //
    // BUGBUG - this function should receive the handle already mapped
    //

    error = MapHandleToAddress(*lphInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    INET_ASSERT(hInternetMapped != NULL);

    //
    // if the InternetOpen() handle was created in OFFLINE mode then is an
    // offline request
    //
        DEBUG_PRINT(FTP,
                    INFO,
                    ("ParseFtpUrl: pre-OpenFlags check: OpenFlags = %#x\n",
                    OpenFlags
                    ));

    OpenFlags |= ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->GetInternetOpenFlags()
        & INTERNET_FLAG_OFFLINE;

        DEBUG_PRINT(FTP,
                    INFO,
                    ("ParseFtpUrl: post-OpenFlags check: OpenFlags = %#x\n",
                    OpenFlags
                    ));


    DereferenceObject((LPVOID)hInternetMapped);

    DWORD limit;

    limit = (OpenFlags & INTERNET_FLAG_OFFLINE) ? 1 : 3;

    //
    // resynchronize same as reload for FTP
    //

    if (OpenFlags & INTERNET_FLAG_RESYNCHRONIZE) {
        OpenFlags |= INTERNET_FLAG_RELOAD;
        DEBUG_PRINT(FTP,
                    INFO,
                    ("ParseFtpUrl: INTERNET_FLAG_RESYNCHRONIZE set\n"));
    }

    DWORD i;
    BOOL bFromCache;

    i = 0;
    bFromCache = (OpenFlags & INTERNET_FLAG_RELOAD || (GlobalUrlCacheSyncMode == WININET_SYNC_MODE_ALWAYS)) ? FALSE : TRUE;

    while (i < limit) {

        //
        // ok, all parts present and correct; open a handle to the FTP resource
        //

        DWORD dwFlags = OpenFlags;

        if (bFromCache) {

            //
            // attempting to get item from cache
            //

            dwFlags |= INTERNET_FLAG_OFFLINE;
        } else {

            //
            // performing net request
            //

            dwFlags |= INTERNET_FLAG_RELOAD;
            dwFlags &= ~INTERNET_FLAG_OFFLINE;
        }

        //
        // zero-terminating the host name will wipe out the first '/' of the
        // URL-path which we must restore before using
        //

        firstUrlPathCharacter = *lpszUrl;
        if (pHostName != NULL) {
            pHostName[hostNameLength] = '\0';
        }

        //
        // record current online/offline state
        //

        BOOL bOffline = IsOffline();

        //
        // create a connect handle object or find an existing one if using
        // INTERNET_FLAG_EXISTING_CONNECT
        //

        if ( hConnect )
        {
            _InternetCloseHandle(hConnect); // nuke old connect handle, otherwise we leak.
        }

        hConnect = InternetConnectA(*lphInternet,
                                    pHostName,
                                    port,
                                    pUserName,
                                    pPassword,
                                    INTERNET_SERVICE_FTP,
                                    dwFlags,

                                    //
                                    // we are creating a "hidden" handle - don't
                                    // tell the app about it
                                    //

                                    INTERNET_NO_CALLBACK
                                    );

        //
        // restore URL-path, but only if its not '\0' - we may have a const
        // string (we can't write to it - we change to "/" below, which is a
        // const string)
        //

        if (*lpszUrl == '\0') {
            *(LPSTR)lpszUrl = firstUrlPathCharacter;
        }

        HINTERNET hConnectMapped = NULL;

        if (hConnect != NULL) {

            //
            // lock the handle by mapping it
            //

            error = MapHandleToAddress(hConnect,
                                       (LPVOID *)&hConnectMapped,
                                       FALSE
                                       );

            INET_ASSERT(error == ERROR_SUCCESS);
            INET_ASSERT(hConnectMapped != NULL);

            if (error != ERROR_SUCCESS) {
                break;
            }

            INTERNET_CONNECT_HANDLE_OBJECT * pConnectMapped;

            pConnectMapped = (INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped;

            //
            // the ref count should be 2: either we created the connect handle
            // or we picked up an EXISTING_CONNECT handle which should not be
            // used by any other requests
            //

            INET_ASSERT(pConnectMapped->ReferenceCount() == 2);

            //
            // first off, associate the last response info, possibly including
            // the server welcome message, with the connection
            //

            pConnectMapped->AttachLastResponseInfo();
            pConnectMapped->SetURL(Url);

            HINTERNET hRequest;

            if (isDirectory) {
                if (*lpszUrl == '\0') {
                    lpszUrl = "/";
                }

                //
                // if we are reading from cache then set the working directory
                // locally, else also set the CWD at the server
                //

                if (bFromCache) {
                    error = pConnectMapped->SetCurrentWorkingDirectory((LPSTR)lpszUrl);
                } else if (FtpSetCurrentDirectory(hConnect, lpszUrl)) {
                    error = ERROR_SUCCESS;
                } else {
                    error = GetLastError();
                }
                if (error == ERROR_SUCCESS) {

                    // if we are not asked to give raw data
                    // then set htmlfind to TRUE

                    if (!(dwFlags & INTERNET_FLAG_RAW_DATA)) {
                        pConnectMapped->SetHtmlFind(TRUE);
                    }
                    hRequest = InternalFtpFindFirstFileA(hConnect,
                                              NULL,
                                              NULL,
                                              dwFlags,
                                              Context,
                                              bFromCache,
                                              pConnectMapped->IsHtmlFind() // allow empty
                                              );
                } else {
                    hRequest = NULL;
                }
            } else /* if (!isDirectory) */ {
                hRequest = InternalFtpOpenFileA(hConnect,
                                                lpszUrl,
                                                GENERIC_READ,
                                                dwFlags,
                                                Context,
                                                bFromCache
                                                );

                //
                // we may have failed because we're not trying to get a file
                // after all - we've been given a directory without a trailing
                // slash
                //

                if (hRequest == NULL) {
                    if (!(dwFlags & INTERNET_FLAG_RAW_DATA)) {
                        pConnectMapped->SetHtmlFind(TRUE);
                    }
                    error = pConnectMapped->SetCurrentWorkingDirectory((LPSTR)lpszUrl);

                    INET_ASSERT(error == ERROR_SUCCESS);

                    if (error == ERROR_SUCCESS) {
                        if (!bFromCache) {
                            if (!FtpSetCurrentDirectory(hConnect, lpszUrl)) {
                                error = GetLastError();
                            }
                        }
                        if (error == ERROR_SUCCESS) {
                            hRequest = InternalFtpFindFirstFileA(
                                            hConnect,
                                            NULL,
                                            NULL,
                                            dwFlags,
                                            Context,
                                            bFromCache,
                                            pConnectMapped->IsHtmlFind()
                                            );
                        }
                    }
                }
            }

            //
            // link the request and connect handles so that the connect handle
            // object will be deleted when the request handle is closed
            //

            if (hRequest != NULL) {

                HINTERNET hRequestMapped = NULL;

                error = MapHandleToAddress(hRequest,
                                           (LPVOID *)&hRequestMapped,
                                           FALSE
                                           );
                if (error == ERROR_SUCCESS) {
                    RSetParentHandle(hRequestMapped, hConnectMapped, TRUE);
                }

                //
                // dereference the handles referenced by MapHandleToAddress()
                //

                if (hRequestMapped != NULL) {
                    DereferenceObject((LPVOID)hRequestMapped);
                }

                //
                // return the request handle
                //

                *lphInternet = hRequest;
            }

            //
            // unmap and dereference the connect handle
            //

            DereferenceObject((LPVOID)hConnectMapped);

            //
            // if we succeeded in opening the item then we're done
            //

            if (hRequest != NULL) {
                break;
            } else {
                error = GetLastError();

                //
                // close the handle without modifying the per-thread handle and
                // context values
                //

                //DWORD closeError = _InternetCloseHandleNoContext(hConnect);
                DWORD closeError = ERROR_SUCCESS;

                INET_ASSERT(closeError == ERROR_SUCCESS);

                //
                // if we failed because we went offline then make a cache
                // request if we can
                //

                if (IsOffline() && !bFromCache) {

                    //
                    // this will be the last chance
                    //

                    bFromCache = TRUE;
                    continue;
                }
            }
        } else {

            //
            // InternetConnect() failed. If the offline state didn't change then
            // its a real error - quit
            //

            error = GetLastError();
            if (IsOffline() == bOffline) {
                break;
            }

            //
            // we must have transitioned offline state. If we went offline then
            // attempt to read from cache only
            //

            if (IsOffline() && !bFromCache) {
                bFromCache = TRUE;
                continue;
            }
        }

        //
        // next iteration - second & subsequent not from cache unless we are
        // offline
        //

        bFromCache = FALSE;
        ++i;
    }

quit:
    if (lpszBackup)
        FREE_MEMORY(lpszBackup);

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftphelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftphelp.h

Abstract:

    header for private FTP manifests etc

Author:

    Heath Hunnicut (t-heathh) 26-May-1995

Revision History:

    26-May-1995 t-heathh
        Created

--*/

typedef struct {
    int Major;
    int Minor;
    int Detail;
    int Status;
} FTP_RESPONSE_CODE;

//
// response categories (1st digit)
//

#define FTP_RESPONSE_PRELIMINARY        1
#define FTP_RESPONSE_COMPLETE           2
#define FTP_RESPONSE_CONTINUE           3
#define FTP_RESPONSE_TRANSIENT_FAILURE  4
#define FTP_RESPONSE_PERMANENT_FAILURE  5

//
// response codes
//

#define FTP_RESPONSE_RESTART_MARKER     110
#define FTP_RESPONSE_DATA_ALREADY_OPEN  125
#define FTP_RESPONSE_OPENING_DATA       150
#define FTP_RESPONSE_CMD_OK             200
#define FTP_RESPONSE_CMD_EXTRANEOUS     202
#define FTP_RESPONSE_DIRECTORY_STATUS   212
#define FTP_RESPONSE_FILE_STATUS        213
#define FTP_RESPONSE_SYSTEM_TYPE        215
#define FTP_RESPONSE_SEND_USER_CMD      220
#define FTP_RESPONSE_CLOSING_CONTROL    221
#define FTP_RESPONSE_CLOSING_DATA       226
#define FTP_RESPONSE_ENTERING_PASSIVE   227
#define FTP_RESPONSE_LOGGED_IN_PROCEED  230
#define FTP_RESPONSE_FILE_ACTION_OK     250
#define FTP_RESPONSE_PATHNAME_CREATED   257
#define FTP_RESPONSE_SEND_PASS_CMD      331
#define FTP_RESPONSE_NEED_LOGIN_ACCOUNT 332
#define FTP_RESPONSE_FILE_CMD_PENDING   350
#define FTP_RESPONSE_CANT_OPEN_DATA     425
#define FTP_RESPONSE_CMD_SYNTAX_ERROR   500
#define FTP_RESPONSE_ARG_SYNTAX_ERROR   501
#define FTP_RESPONSE_CMD_NOT_IMPL       502
#define FTP_RESPONSE_BAD_CMD_SEQ        503
#define FTP_RESPONSE_NOT_LOGGED_IN      530
#define FTP_RESPONSE_ACTION_NOT_TAKEN   550
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\ftpapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpapiw.cxx

Abstract:

    Wide-character versions of Windows Internet Client DLL FTP APIs and
    Internet subordinate functions

    Contents:
        FtpFindFirstFileW
        FtpGetFileW
        FtpPutFileW
        FtpDeleteFileW
        FtpRenameFileW
        FtpOpenFileW
        FtpCreateDirectoryW
        FtpRemoveDirectoryW
        FtpSetCurrentDirectoryW
        FtpGetCurrentDirectoryW
        FtpCommandW

Author:

    Heath Hunnicutt [t-heathh] 13-Jul-1994

Environment:

    Win32(s) user-level DLL

Revision History:

    09-Mar-1995 rfirth
        moved from unicode.c

    21-Jul-1994 t-heathh
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include <w95wraps.h>

#define DEFAULT_TRANSFER_BUFFER_LENGTH  (4 K)

#define ALLOWED_FTP_FLAGS               (INTERNET_FLAGS_MASK \
                                        | FTP_TRANSFER_TYPE_MASK \
                                        )

//
// functions
//


BOOL
TransformFtpFindDataToW(LPWIN32_FIND_DATAA pfdA, LPWIN32_FIND_DATAW pfdW)
{
    pfdW->dwFileAttributes = pfdA->dwFileAttributes;
    pfdW->ftCreationTime = pfdA->ftCreationTime;
    pfdW->ftLastAccessTime = pfdA->ftLastAccessTime;
    pfdW->ftLastWriteTime = pfdA->ftLastWriteTime;
    pfdW->nFileSizeHigh = pfdA->nFileSizeHigh;
    pfdW->nFileSizeLow = pfdA->nFileSizeLow;
    pfdW->dwReserved0 = pfdA->dwReserved0;
    pfdW->dwReserved1 = pfdA->dwReserved1;
    MultiByteToWideChar(CP_ACP, 0, pfdA->cFileName, -1, pfdW->cFileName, MAX_PATH);
    MultiByteToWideChar(CP_ACP, 0, pfdA->cAlternateFileName, -1, pfdW->cAlternateFileName, 14);

    return TRUE;
}


INTERNETAPI_(HINTERNET) FtpFindFirstFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszSearchFile,
    OUT LPWIN32_FIND_DATAW pffdOutput,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszSearchFile  -
    pffdOutput      -
    dwFlags         -
    dwContext       -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpFindFirstFileW",
                     "%#x, %.80wq, %#x, %#x, %#x",
                     hFtpSession,
                     lpszSearchFile,
                     pffdOutput,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpSearchFile;
    HANDLE hInternet = NULL;
    WIN32_FIND_DATAA fdA;
    
    if (!pffdOutput 
        || IsBadWritePtr(pffdOutput, sizeof(*pffdOutput))
        || (lpszSearchFile && (IsBadStringPtrW(lpszSearchFile, INTERNET_MAX_PATH_LENGTH + 1))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszSearchFile)
    {
        ALLOC_MB(lpszSearchFile,0,mpSearchFile);
        if (!mpSearchFile.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszSearchFile,mpSearchFile);
    }
    hInternet = FtpFindFirstFileA(hFtpSession,mpSearchFile.psStr,&fdA,dwFlags,dwContext);
    if (hInternet)
    {
        TransformFtpFindDataToW(&fdA, pffdOutput);
    }
cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) FtpGetFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession             -
    lpszRemoteFile          -
    lpszNewFile             -
    fFailIfExists           -
    dwFlagsAndAttributes    -
    dwFlags                 -
    dwContext               -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetFileW",
                     "%#x, %wq, %wq, %B, %#x, %#x, %#x",
                     hFtpSession,
                     lpszRemoteFile,
                     lpszNewFile,
                     fFailIfExists,
                     dwFlagsAndAttributes,
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    BOOL success;
    DWORD nestingLevel = 0;
    HINTERNET hSessionMapped = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the INTERNET_THREAD_INFO
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the connect handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hSessionMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hSessionMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hSessionMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hSessionMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we're in the async thread context then we've already validated the
    // parameters, so skip this stage
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtrW(lpszRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszRemoteFile == L'\0')
        || IsBadStringPtrW(lpszNewFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewFile == L'\0')
        || (((dwFlags & FTP_TRANSFER_TYPE_MASK) != 0)
            ? (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY))
            : FALSE)
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // use default transfer type if so requested
        //

        if ((dwFlags & FTP_TRANSFER_TYPE_MASK) == 0) {
            dwFlags |= FTP_TRANSFER_TYPE_BINARY;
        }

        //
        // if we're performing async I/O AND this we are not in the context of
        // an async worker thread AND the app supplied a non-zero context value
        // then we can make an async request
        //

        if (!lpThreadInfo->IsAsyncWorkerThread
        && isAsync
        && (dwContext != INTERNET_NO_CALLBACK)) {

            //
            // create an asynchronous request block (ARB) and copy the parameters
            //

            // MakeAsyncRequest
            CFsm_FtpGetFile * pFsm;

            pFsm = new CFsm_FtpGetFile(hFtpSession, dwContext, lpszRemoteFile, lpszNewFile, fFailIfExists,
                                            dwFlagsAndAttributes, dwFlags);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();

                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    //
    // initialize variables in case of early exit
    //

    HANDLE hLocalFile;
    HINTERNET hRemoteFile;
    LPBYTE transferBuffer;

    hLocalFile = INVALID_HANDLE_VALUE;
    hRemoteFile = NULL;
    transferBuffer = NULL;

    //
    // first off, allocate a buffer for the transfer(s) below. The caller can
    // now influence the buffer size used by setting the appropriate option
    // for this handle. If we fail to get the value then revert to the default
    // size of 4K. We want to reduce the number of RPC calls we make
    //

    DWORD optionLength;
    DWORD transferBufferLength;

    optionLength = sizeof(transferBufferLength);
    if (!InternetQueryOption(hFtpSession,
                             INTERNET_OPTION_READ_BUFFER_SIZE,
                             (LPVOID)&transferBufferLength,
                             &optionLength
                             )) {
        transferBufferLength = DEFAULT_TRANSFER_BUFFER_LENGTH;
    }
    transferBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(transferBufferLength);
    if (transferBuffer == NULL) {
        goto last_error_exit;
    }

    //
    // open/create local file
    //

    hLocalFile = CreateFileW(lpszNewFile,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            fFailIfExists ? CREATE_NEW : CREATE_ALWAYS,
                            dwFlagsAndAttributes | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL // need NULL for Win95, handle to file with attributes to copy
                            );

    if (hLocalFile == INVALID_HANDLE_VALUE) {
        goto last_error_exit;
    }

    //
    // open file at FTP server
    //

    hRemoteFile = FtpOpenFileW(hFtpSession,
                               lpszRemoteFile,
                               GENERIC_READ,
                               dwFlags,
                               dwContext
                               );
    if (hRemoteFile == NULL) {
        goto last_error_exit;
    }

    //
    // since we are going under the API, map the file handle
    //

    error = MapHandleToAddress(hRemoteFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto cleanup;
    }

    //
    // transfer remote file to local (i.e. download it)
    //

    do {

        DWORD bytesRead;

        //
        // let app invalidate out
        //

        if (((HANDLE_OBJECT *)hFileMapped)->IsInvalidated()
        || ((HANDLE_OBJECT *)hSessionMapped)->IsInvalidated()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
            goto cleanup;
        }

        success = FtpReadFile(hFileMapped,
                              transferBuffer,
                              transferBufferLength,
                              &bytesRead
                              );
        if (success) {
            if (bytesRead != 0) {

                DWORD bytesWritten;

                success = WriteFile(hLocalFile,
                                    transferBuffer,
                                    bytesRead,
                                    &bytesWritten,
                                    NULL
                                    );
            } else {

                //
                // done
                //

                error = ERROR_SUCCESS;
                goto cleanup;
            }
        }
    } while (success);

last_error_exit:

    error = GetLastError();

cleanup:

    if (transferBuffer != NULL) {
        FREE_MEMORY((HLOCAL)transferBuffer);
    }

    //
    // close local file
    //

    if (hLocalFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hLocalFile);

        //
        // if we failed, but created the local file then delete it
        //

        if ((error != ERROR_SUCCESS) && (hLocalFile != INVALID_HANDLE_VALUE)) {
            DeleteFileW(lpszNewFile);
        }
    }

    //
    // close remote file
    //

    if (hRemoteFile != NULL) {
        _InternetCloseHandle(hRemoteFile);
    }

    //
    // BUGBUG [arthurbi] SetContext should not be called from here,
    //   InternetCloseHandle should not reset the context as its
    //   doing right now, and this needs to be investigated more,
    //   as for now we're workaround this problem by calling SetContext
    //

    _InternetSetContext(lpThreadInfo, dwContext);

quit:

    if (hFileMapped != NULL) {
        INET_ASSERT(fDeref);
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (hSessionMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)hSessionMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI_(BOOL) FtpPutFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszLocalFile,
    IN LPCWSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession         -
    lpszLocalFile       -
    lpszNewRemoteFile   -
    dwFlags             -
    dwContext           -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpPutFileW",
                     "%#x, %wq, %wq, %#x, %#x",
                     hFtpSession,
                     lpszLocalFile,
                     lpszNewRemoteFile,
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    BOOL success;
    DWORD nestingLevel = 0;
    HINTERNET hSessionMapped = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the INTERNET_THREAD_INFO
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the connect handle
    //

    error = MapHandleToAddress(hFtpSession, (LPVOID *)&hSessionMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hSessionMapped == NULL)) {
        goto quit;
    }

    //
    // set the context and handle info and clear last error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hFtpSession, hSessionMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hSessionMapped,
                           &isLocal,
                           &isAsync,
                           TypeFtpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we're in the async thread context then we've already validated the
    // parameters, so skip this stage
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {

        //
        // validate parameters
        //

        if (IsBadStringPtrW(lpszNewRemoteFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszNewRemoteFile == L'\0')
        || IsBadStringPtrW(lpszLocalFile, INTERNET_MAX_PATH_LENGTH + 1)
        || (*lpszLocalFile == L'\0')
        || (((dwFlags & FTP_TRANSFER_TYPE_MASK) != 0)
            ? (((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_ASCII)
            && ((dwFlags & FTP_TRANSFER_TYPE_MASK) != FTP_TRANSFER_TYPE_BINARY))
            : FALSE)
        || ((dwFlags & ~ALLOWED_FTP_FLAGS) != 0)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // use default transfer type if so requested
        //

        if ((dwFlags & FTP_TRANSFER_TYPE_MASK) == 0) {
            dwFlags |= FTP_TRANSFER_TYPE_BINARY;
        }

        // in offline mode modifications are disallowed
        // someday we will do internet briefcase but not today

        if ((((INTERNET_CONNECT_HANDLE_OBJECT *)hSessionMapped)->
                GetInternetOpenFlags() | dwFlags) &
                INTERNET_FLAG_OFFLINE) {
            error = ERROR_WRITE_PROTECT;
            goto quit;
        }

        //
        // if we're performing async I/O AND this we are not in the context of
        // an async worker thread AND the app supplied a non-zero context value
        // then we can make an async request
        //

        if (!lpThreadInfo->IsAsyncWorkerThread
        && isAsync
        && (dwContext != INTERNET_NO_CALLBACK)) {

            // MakeAsyncRequest
            CFsm_FtpPutFile * pFsm;

            pFsm = new CFsm_FtpPutFile(hFtpSession, dwContext, lpszLocalFile, lpszNewRemoteFile, dwFlags);
            if (pFsm != NULL &&
                pFsm->GetError() == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;

                if ( pFsm )
                {
                    error = pFsm->GetError();
                    delete pFsm;
                    pFsm = NULL;
                }
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;
        }
    }

    //
    // initialize variables in case of early exit
    //

    HANDLE hLocalFile;
    HINTERNET hRemoteFile;
    LPBYTE transferBuffer;

    hLocalFile = INVALID_HANDLE_VALUE;
    hRemoteFile = NULL;
    transferBuffer = NULL;

    //
    // first off, allocate a buffer for the transfer(s) below. The caller can
    // now influence the buffer size used by setting the appropriate option
    // for this handle. If we fail to get the value then revert to the default
    // size of 4K. We want to reduce the number of RPC calls we make
    //

    DWORD optionLength;
    DWORD transferBufferLength;

    optionLength = sizeof(transferBufferLength);
    if (!InternetQueryOption(hFtpSession,
                             INTERNET_OPTION_WRITE_BUFFER_SIZE,
                             (LPVOID)&transferBufferLength,
                             &optionLength
                             )) {
        transferBufferLength = DEFAULT_TRANSFER_BUFFER_LENGTH;
    }
    transferBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(transferBufferLength);
    if (transferBuffer == NULL) {
        goto last_error_exit;
    }

    //
    // open local file
    //

    hLocalFile = CreateFileW(lpszLocalFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL // need NULL for Win95, handle to file with attributes to copy
                            );
    if (hLocalFile == INVALID_HANDLE_VALUE) {
        goto last_error_exit;
    }

    //
    // open file at FTP server
    //

    hRemoteFile = FtpOpenFileW(hFtpSession,
                               lpszNewRemoteFile,
                               GENERIC_WRITE,
                               dwFlags,
                               dwContext
                               );
    if (hRemoteFile == NULL) {
        goto last_error_exit;
    }

    //
    // since we are going under the API, map the file handle
    //

    error = MapHandleToAddress(hRemoteFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto cleanup;
    }

    //
    // transfer local file to remote (i.e. upload it)
    //

    do {

        DWORD bytesRead;

        //
        // let app invalidate out
        //

        if (((HANDLE_OBJECT *)hFileMapped)->IsInvalidated()
        || ((HANDLE_OBJECT *)hSessionMapped)->IsInvalidated()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
            goto cleanup;
        }

        success = ReadFile(hLocalFile,
                           transferBuffer,
                           transferBufferLength,
                           &bytesRead,
                           NULL
                           );
        if (success) {
            if (bytesRead != 0) {

                DWORD bytesWritten;

                success = FtpWriteFile(hFileMapped,
                                       transferBuffer,
                                       bytesRead,
                                       &bytesWritten
                                       );
            } else {

                //
                // ensure last error is really no error
                //

                error = ERROR_SUCCESS;

                goto cleanup;
            }
        }
    } while (success);

last_error_exit:

    error = GetLastError();

cleanup:

    if (transferBuffer != NULL) {
        FREE_MEMORY((HLOCAL)transferBuffer);
    }

    //
    // close local file
    //

    if (hLocalFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hLocalFile);
    }

    //
    // close remote file
    //

    if (hRemoteFile != NULL) {
        _InternetCloseHandle(hRemoteFile);
    }

    //
    // BUGBUG [arthurbi] SetContext should not be called from here,
    //   InternetCloseHandle should not reset the context as its
    //   doing right now, and this needs to be investigated more,
    //   as for now we're workaround this problem by calling SetContext
    //

    _InternetSetContext(lpThreadInfo, dwContext);

quit:
    SetLastError(ERROR_SUCCESS);  // a-thkesa. from win CE code BUG: WinSE 23985

    if (hFileMapped != NULL) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (hSessionMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)hSessionMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:
			
    // a-thkesa Becuase 23985 fix returns ERROR_INTERNET_EXTENDED_ERROR
    if(ERROR_INTERNET_EXTENDED_ERROR == GetLastError()){
         success = FALSE;
     }
    else if (error != ERROR_SUCCESS) {
        SetLastError(error);
        success = FALSE;

        DEBUG_ERROR(API, error);

    } else {
        success = TRUE;

    }

    DEBUG_LEAVE_API(success);

    return success;
}

INTERNETAPI_(BOOL) FtpGetFileEx(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetFileEx",
                     "%#x, %sq, %wq, %B, %#x, %#x, %#x",
                     hFtpSession,
                     lpszRemoteFile,
                     lpszNewFile,
                     fFailIfExists,
                     dwFlagsAndAttributes,
                     dwFlags,
                     dwContext
                     ));

    DWORD cc, dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    PWSTR pwszRemoteFile = NULL;

    cc = MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (LPWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszRemoteFile, -1, pwszRemoteFile, cc);

    fResult = FtpGetFileW(hFtpSession,pwszRemoteFile,lpszNewFile,fFailIfExists,
        dwFlagsAndAttributes,dwFlags,dwContext);

cleanup: 
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;

}


INTERNETAPI_(BOOL) FtpPutFileEx(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpPutFileEx",
                     "%#x, %wq, %sq, %#x, %#x",
                     hFtpSession,
                     lpszLocalFile,
                     lpszNewRemoteFile,
                     dwFlags,
                     dwContext
                     ));

    DWORD cc, dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    PWSTR pwszRemoteFile = NULL;

    cc = MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, NULL, 0);
    pwszRemoteFile = (LPWSTR)ALLOCATE_FIXED_MEMORY((cc*sizeof(WCHAR)));
    if (!pwszRemoteFile)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    MultiByteToWideChar(CP_ACP, 0, lpszNewRemoteFile, -1, pwszRemoteFile, cc);

    fResult = FtpPutFileW(hFtpSession,lpszLocalFile,pwszRemoteFile,dwFlags,dwContext);

cleanup: 
    if (pwszRemoteFile)
    {
        FREE_MEMORY(pwszRemoteFile);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;

}


INTERNETAPI_(BOOL) FtpDeleteFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszFileName
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszFileName    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpDeleteFileW",
                     "%#x, %wq",
                     hFtpSession,
                     lpszFileName
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpFile;

    if (!lpszFileName 
        || (IsBadStringPtrW(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1))
        || (*lpszFileName == L'\0'))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszFileName,0,mpFile);
    if (!mpFile.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszFileName,mpFile);
    fResult = FtpDeleteFileA(hFtpSession,mpFile.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpRenameFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszExisting,
    IN LPCWSTR lpszNew
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszExisting    -
    lpszNew         -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRenameFileW",
                     "%#x, %wq, %wq",
                     hFtpSession,
                     lpszExisting,
                     lpszNew
                     ));


    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpExisting, mpNew;

    if (!(lpszExisting && lpszNew)
        || (IsBadStringPtrW(lpszExisting, INTERNET_MAX_PATH_LENGTH + 1))
        || (IsBadStringPtrW(lpszNew, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszExisting,0,mpExisting);
    ALLOC_MB(lpszNew,0,mpNew);
    if (!(mpExisting.psStr && mpNew.psStr))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszExisting,mpExisting);
    UNICODE_TO_ANSI(lpszNew,mpNew);
    fResult = FtpRenameFileA(hFtpSession,mpExisting.psStr,mpNew.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(HINTERNET) FtpOpenFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    lpszFileName    -
    dwAccess        -
    dwFlags         -
    dwContext       -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "FtpOpenFileW",
                     "%#x, %wq, %#x, %#x, %#x",
                     hFtpSession,
                     lpszFileName,
                     dwAccess,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpFile;

    if (!lpszFileName
        || (IsBadStringPtrW(lpszFileName, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszFileName,0,mpFile);
    if (!mpFile.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszFileName,mpFile);
    hInternet = FtpOpenFileA(hFtpSession,mpFile.psStr,dwAccess,dwFlags,dwContext);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);

    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) FtpCreateDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR pwszDir
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession -
    pwszDir     -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCreateDirectoryW",
                     "%#x, %wq",
                     hFtpSession,
                     pwszDir
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!pwszDir
        || (IsBadStringPtrW(pwszDir, INTERNET_MAX_PATH_LENGTH + 1)
        || (*pwszDir == L'\0')))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pwszDir,0,mpDir);
    if (!mpDir.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pwszDir,mpDir);
    fResult = FtpCreateDirectoryA(hFtpSession,mpDir.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpRemoveDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR pwszDir
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession -
    pwszDir     -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpRemoveDirectoryW",
                     "%#x, %wq",
                     hFtpSession,
                     pwszDir
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!pwszDir
        || (IsBadStringPtrW(pwszDir, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pwszDir,0,mpDir);
    if (!mpDir.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pwszDir,mpDir);
    fResult = FtpRemoveDirectoryA(hFtpSession,mpDir.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpSetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR pwszDir
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession -
    pwszDir     -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpSetCurrentDirectoryW",
                     "%#x, %wq",
                     hFtpSession,
                     pwszDir
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!pwszDir
        || (IsBadStringPtrW(pwszDir, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pwszDir,0,mpDir);
    if (!mpDir.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pwszDir,mpDir);
    fResult = FtpSetCurrentDirectoryA(hFtpSession,mpDir.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpGetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession             -
    lpszCurrentDirectory    -
    lpdwCurrentDirectory    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpGetCurrentDirectoryW",
                     "%#x, %#x, %#x [%d]",
                     hFtpSession,
                     lpszCurrentDirectory,
                     lpdwCurrentDirectory,
                     lpdwCurrentDirectory ? *lpdwCurrentDirectory : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpDir;

    if (!lpdwCurrentDirectory 
        || IsBadWritePtr(lpdwCurrentDirectory, sizeof(*lpdwCurrentDirectory))
        || (lpszCurrentDirectory && IsBadWritePtr(lpszCurrentDirectory, *lpdwCurrentDirectory)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszCurrentDirectory)
    {
        mpDir.dwSize = mpDir.dwAlloc = *lpdwCurrentDirectory*sizeof(CHAR);
        mpDir.psStr = (LPSTR)ALLOC_BYTES(mpDir.dwAlloc);
        if (!mpDir.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    else
    {
        *lpdwCurrentDirectory = 0;
    }
    
    fResult = FtpGetCurrentDirectoryA(hFtpSession,mpDir.psStr,&mpDir.dwSize);
    if (fResult) 
    {
        DWORD cc = MultiByteToWideChar(CP_ACP, 0, mpDir.psStr, -1, NULL, 0);
        if (*lpdwCurrentDirectory>=cc)
        {
            *lpdwCurrentDirectory = MultiByteToWideChar(CP_ACP, 0, mpDir.psStr, -1, 
                    lpszCurrentDirectory, *lpdwCurrentDirectory);
        }
        else
        {
            *lpdwCurrentDirectory = cc*sizeof(WCHAR);
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            fResult = FALSE;
        }
    }
    else
    {
        if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
        {
            *lpdwCurrentDirectory = mpDir.dwSize*sizeof(WCHAR);
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) FtpCommandW(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCWSTR lpszCommand,
    IN DWORD_PTR dwContext,
    OUT HINTERNET *phFtpCommand OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hFtpSession     -
    fExpectResponse -
    dwFlags         -
    lpszCommand     -
    dwContext       -
    phFtpCommand    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "FtpCommandW",
                     "%#x, %B, %#x, %wq, %#x, %x",
                     hFtpSession,
                     fExpectResponse,
                     dwFlags,
                     lpszCommand,
                     dwContext,
                     phFtpCommand
                     ));

    MEMORYPACKET mpCommand;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    if (!lpszCommand 
        || IsBadStringPtrW(lpszCommand, INTERNET_MAX_URL_LENGTH) 
        || (phFtpCommand && IsBadWritePtr(phFtpCommand, sizeof(*phFtpCommand))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszCommand, 0, mpCommand);
    if (!mpCommand.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszCommand, mpCommand);

    fResult = FtpCommandA(hFtpSession, fExpectResponse, dwFlags, mpCommand.psStr, dwContext, phFtpCommand);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\name.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    name.cxx

Abstract:

    Support for pattern-matching file names versus file specs, used by
    FtpFindFirstFile() to form the list of found files.  Lifted from
    ntos\fsrtl\name.c, and trimmed to fit.

    This module was included in the ftphelp project because of the need
    for binary portability to Chicago.

    ---

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c

    The following routines are provided by this package:

      o  MyFsRtlDissectName - removed

      o  MyFsRtlColateNames - removed

      o  MyFsRtlDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  MyFsRtlIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

        Heath Hunnicutt [t-heathh] 13-Jul-1994

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include "namep.h"

//
//  Trace level for the module
//

#define Dbg                              (0x10000000)

//
//  Some special debugging stuff
//

#if DBG

extern ULONG DaveDebug;
#define DavePrint if (DaveDebug) DbgPrint

#else

#define DavePrint NOTHING

#endif

//
//  Local support routine prototypes
//

BOOLEAN
MyFsRtlIsNameInExpressionPrivate
(
    IN ANSI_STRING *Expression,
    IN ANSI_STRING *Name
);

BOOLEAN
MyFsRtlDoesNameContainWildCards
(
    IN LPCSTR pszName
)

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/

{
    ULONG i;
    USHORT Length;

//    PAGED_CODE();

    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    Length =(unsigned short) lstrlenA( pszName );
    for (i = 0; i < Length; i += 1) {

        //
        //  check for a wild card character
        //

        if (MyFsRtlIsAnsiCharacterWild( pszName[i] )) {

            //
            //  Tell caller that this name contains wild cards
            //

            return TRUE;
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}


//
//  The following routine is just a wrapper around
//  MyFsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
MyFsRtlIsNameInExpression
(
    IN LPCSTR pszExpression,
    IN LPCSTR pszName,
    IN BOOLEAN IgnoreCase
)
{
    BOOLEAN Result=FALSE;

        ANSI_STRING Expression;
        ANSI_STRING Name;

        Name.Buffer = NewString( pszName );

        if ( Name.Buffer==NULL )
            {
                return( FALSE );
            }

        Expression.Buffer = NewString( pszExpression );

        if ( Expression.Buffer==NULL )
            {
                FREE_MEMORY( Name.Buffer );
                return( FALSE );
            }

        if ( IgnoreCase )
            {
                strupr( Name.Buffer );
                strupr( Expression.Buffer );
            }

        Name.Length = (unsigned short) lstrlenA( Name.Buffer );
        Name.MaximumLength = Name.Length;

        Expression.Length = (unsigned short) lstrlenA( Expression.Buffer );
        Expression.MaximumLength = Expression.Length;

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    __try {

        Result = MyFsRtlIsNameInExpressionPrivate( &Expression,
                                                 &Name );

    } __finally {
        FREE_MEMORY(Name.Buffer);
        FREE_MEMORY(Expression.Buffer);
    }
    ENDFINALLY
    return Result;
}


#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

BOOLEAN
MyFsRtlIsNameInExpressionPrivate
(
    IN ANSI_STRING *Expression,
    IN ANSI_STRING *Name
)

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except .

               e is a null character transition

               EOF is the end of the name string


    The last construction, ~? (the DOS question mark), can either match any
    single character, or upon encountering a period or end of input string,
    advances the expression to the end of the set of contiguous ~?s.  This may
    seem somewhat convoluted, but is what DOS needs.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    ULONG StartingNameOffset;

    CHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

//    PAGED_CODE();

    INET_ASSERT(Name->Length != 0);
    INET_ASSERT(Expression->Length != 0);

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *, or *.*
    //

    if ((Expression->Length == 1 && Expression->Buffer[0] == '*')
    || (Expression->Length == 3 && memcmp(Expression->Buffer,"*.*",3)==0)) {

        return TRUE;
    }

    INET_ASSERT(MyFsRtlDoesNameContainWildCards(Expression->Buffer));

    //
    // Before special casing *X, we must special case *., as people tend
    // to use that expression incorrectly to mean "all files without
    // extensions."  However, if this case, fails, it falls through to the
    // next special case, wherein files ending in dots match *.
    //

    if ( Expression->Length == 2 && memcmp(Expression->Buffer,"*.",2)==0 ) {

        PVOID pvDot;

        //
        // Attempt to find a dot in the name buffer.  A dot would indicate
        // the presence of an extension.
        //

        pvDot = memchr( Name->Buffer, '.', Name->Length );

        //
        // If there is no dot, return that this name matches the expression "*."
        //

        if ( pvDot==NULL ) {
            return( TRUE );
        }
    }

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == '*') {

        //
        //  Only special case an expression with a single *, recognized
        //  by the fact that the tail contains no wildcards.
        //

        if ( !MyFsRtlDoesNameContainWildCards( Expression->Buffer + 1 ) ) {
            if (Name->Length < (USHORT)(Expression->Length - sizeof(CHAR))) {
                return FALSE;
            }

                        //
                        // Calculate the offset to the Name's tail.
                        //

            StartingNameOffset = ( Name->Length - ( Expression->Length - 1 ) );

            //
            //  Compare the tail of the expression with the name.
            //

            return( (BOOLEAN)
                            memcmp( Expression->Buffer + 1,
                                            Name->Buffer + StartingNameOffset,
                                            Name->Length - StartingNameOffset ) == 0 );
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[ NameOffset ];

            NameOffset ++;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount )
            {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                INET_ASSERT(ExprOffset >= 0);
                INET_ASSERT(ExprOffset <= Expression->Length);

                if ( ExprOffset == Expression->Length ) {
                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(CHAR);

                CurrentState = (USHORT)(ExprOffset*2);

                if ( ExprOffset == Expression->Length ) {
                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset];

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) && (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(CHAR);

                    AuxBuffer = (USHORT *)
                                ALLOCATE_MEMORY(LMEM_FIXED,
                                                (ExpressionChars + 1)
                                                    * sizeof(USHORT) * 2 * 2
                                                );

                    CopyMemory( AuxBuffer,
                                CurrentMatches,
                                MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    CopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                PreviousMatches,
                                MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == '*') {
                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 1;
                    continue;
                }


                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(CHAR) * 2);

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    INET_ASSERT(FALSE);

                    if ( NameFinished ) {
                        continue;
                    }

                    if (NameChar == '.') {
                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {
                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == '?') {
                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Check if the expression char matches the name char
                //

                if ( !NameFinished && ExprChar == NameChar ) {
                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            } // while() that tries to use up expression chars


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) && (PreviousDestCount < DestCount) ) {
                while (PreviousDestCount < DestCount) {
                    if ( PreviousMatches[SrcCount] < CurrentMatches[PreviousDestCount] ) {
                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        } // while() that uses up name chars

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {
            if (AuxBuffer != NULL) {
                FREE_MEMORY(AuxBuffer);
            }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) {
        FREE_MEMORY(AuxBuffer);
    }


    return (BOOLEAN)(CurrentState == MaxState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\name.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Name.h

Abstract:

    This module defines all of the name.c routines

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

    Heath Hunnicutt [T-HeathH]  13-Jul-1994 - Ported this file to ftphelp
        project.

--*/

#ifndef _NAME_H_INCLUDED_
#define _NAME_H_INCLUDED_

#if defined(__cplusplus)
extern "C" {
#endif

//
//  The following enumerated type is used to denote the result of name
//  comparisons
//

typedef enum _MY_FSRTL_COMPARISON_RESULT {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} MY_FSRTL_COMPARISON_RESULT;
//
//  These following bit values are set in the MyFsRtlLegalDbcsCharacterArray
//

extern PUCHAR MyFsRtlLegalAnsiCharacterArray;

#define MY_FSRTL_FAT_LEGAL         0x01
#define MY_FSRTL_HPFS_LEGAL        0x02
#define MY_FSRTL_NTFS_LEGAL        0x04
#define MY_FSRTL_WILD_CHARACTER    0x08

//
//  The following macro is used to determine if an Ansi character is wild.
//

#define MyFsRtlIsAnsiCharacterWild(C) (                                 \
        ((SCHAR)(C) < 0) ? FALSE :                                    \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)], \
                                   MY_FSRTL_WILD_CHARACTER )             \
)

//
//  The following macro is used to determine if an Ansi character is Fat legal.
//

#define MyFsRtlIsAnsiCharacterLegalFat(C,WILD_OK) (                           \
        ((SCHAR)(C) < 0) ? TRUE :                                           \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)],       \
                                   MY_FSRTL_FAT_LEGAL |                        \
                                   ((WILD_OK) ? MY_FSRTL_WILD_CHARACTER : 0) ) \
)

//
//  The following macro is used to determine if an Ansi character is Hpfs legal.
//

#define MyFsRtlIsAnsiCharacterLegalHpfs(C,WILD_OK) (                          \
        ((SCHAR)(C) < 0) ? TRUE :                                           \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)],       \
                                   MY_FSRTL_HPFS_LEGAL |                       \
                                   ((WILD_OK) ? MY_FSRTL_WILD_CHARACTER : 0) ) \
)

//
//  The following macro is used to determine if an Ansi character is Ntfs legal.
//

#define MyFsRtlIsAnsiCharacterLegalNtfs(C,WILD_OK) (                          \
        ((SCHAR)(C) < 0) ? TRUE :                                           \
                           FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)],       \
                                   MY_FSRTL_NTFS_LEGAL |                       \
                                   ((WILD_OK) ? MY_FSRTL_WILD_CHARACTER : 0) ) \
)

//
//  Unicode Name support routines, implemented in Name.c
//
//  The routines here are used to manipulate unicode names
//

//
//  The following macro is used to determine if a character is wild.
//

#define MyFsRtlIsUnicodeCharacterWild(C) (                                  \
      (((C) >= 0x40) ? FALSE : FlagOn( MyFsRtlLegalAnsiCharacterArray[(C)], \
                                       MY_FSRTL_WILD_CHARACTER ) )           \
)

BOOLEAN
MyFsRtlIsNameInExpression
(
    IN LPCSTR pszExpression,
    IN LPCSTR pszName,
    IN BOOLEAN IgnoreCase
);


#if defined(__cplusplus)
}
#endif

#endif // _NAME_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\namep.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NameP.h

Abstract:

    This module defines private part of the File System Rtl component, used by
        name.c.

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

        [t-HeathH]  17-Jul-1994 Moved this header file into the ftphelp porject, to
        maintain a single source base for Chicago and NT.

--*/

#ifndef _NAMEP_H_INCLUDED_
#define _NAMEP_H_INCLUDED_

#if defined(__cplusplus)
extern "C" {
#endif

//#include "ftp.h"
#include <name.h>

//
//  The global MyFsRtl debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001      Error conditions
//      0x00000002      Debug hooks
//      0x00000004
//      0x00000008
//
//      0x00000010
//      0x00000020
//      0x00000040
//      0x00000080
//
//      0x00000100
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000
//      0x00002000
//      0x00004000
//      0x00008000
//
//      0x00010000
//      0x00020000
//      0x00040000
//      0x00080000
//
//      0x00100000
//      0x00200000
//      0x00400000
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000      NotifyChange routines
//      0x08000000      Oplock routines
//
//      0x10000000      Name routines
//      0x20000000      FileLock routines
//      0x40000000      Vmcb routines
//      0x80000000      Mcb routines
//

//
//  Debug trace support
//

#ifdef FSRTLDBG

extern LONG MyFsRtlDebugTraceLevel;
extern LONG MyFsRtlDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                        \
    LONG _i;                                                  \
    if (((LEVEL) == 0) || (MyFsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        if ((INDENT) < 0) {                                   \
            MyFsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
        if (MyFsRtlDebugTraceIndent < 0) {                      \
            MyFsRtlDebugTraceIndent = 0;                        \
        }                                                     \
        for (_i=0; _i<MyFsRtlDebugTraceIndent; _i+=1) {         \
            DbgPrint(" ");                                     \
        }                                                     \
        DbgPrint(X,Y);                                         \
        if ((INDENT) > 0) {                                   \
            MyFsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
    }                                                         \
}

#define DebugDump(STR,LEVEL,PTR) {                            \
    ULONG _i;                                                 \
    VOID MyFsRtlDump();                                         \
    if (((LEVEL) == 0) || (MyFsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        DbgPrint(STR);                                         \
        if (PTR != NULL) {MyFsRtlDump(PTR);}                    \
        DbgBreakPoint();                                      \
    }                                                         \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#endif // FSRTLDBG

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  This macro takes a ulong and returns its value rounded up to a sector
//  boundary
//

#define SectorAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 511) & 0xfffffe00) \
    )

//
//  This macro takes a number of bytes and returns the number of sectors
//  required to contain that many bytes, i.e., it sector aligns and divides
//  by the size of a sector.
//

#define SectorsFromBytes(bytes) ( \
    ((bytes) + 511) / 512         \
    )

//
//  This macro takes a number of sectors and returns the number of bytes
//  contained in that many sectors.
//

#define BytesFromSectors(sectors) ( \
    (sectors) * 512                 \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#if defined(__cplusplus)
}
#endif

#endif // _FSRTLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\protocol.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    protocol.h

Abstract:

    Prototypes, etc. for protocol.c

Author:

    Richard L Firth (rfirth) 16-Mar-1995

Revision History:

    16-Mar-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
Command(
    IN OUT LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE * prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    );

DWORD
I_Command(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN FTP_RESPONSE_CODE * prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    );

DWORD
__cdecl
NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    OUT FTP_RESPONSE_CODE * prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    );

DWORD
GetReply(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    OUT FTP_RESPONSE_CODE * prcResponse
    );

DWORD
ReceiveFtpResponse(
    IN ICSocket * Socket,
    OUT LPVOID * lpBuffer,
    OUT LPDWORD lpdwBufferLength,
    IN BOOL bEndOfLineCheck,
    IN FTP_RESPONSE_CODE * prcResponse
    );

DWORD
AbortTransfer(
    IN LPFTP_SESSION_INFO lpSessionInfo
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\nvt.h ===
#ifndef _NVT_H_INCLUDED_
#define _NVT_H_INCLUDED_

#define NVT_IAC_STRING "\377"
#define NVT_INTERRUPT_PROCESS_STRING "\377\364"
#define NVT_DATA_MARK_STRING "\377\362"

#endif // _NVT_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\namep.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    namep.cxx

Abstract:

    This module declares the global data used by the Name Module

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

    Heath Hunnicutt [T-HeathH]  17-Jul-1994 - adopted and stripped of most
        stuff for ftphelp api.

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include "namep.h"

//
//  The global static legal ANSI character array.  Wild characters
//  are not considered legal, they should be checked seperately if
//  allowed.
//

static UCHAR LocalLegalAnsiCharacterArray[128] = {

    0,                                                     // 0x00 ^@
    0,                                                     // 0x01 ^A
    0,                                                     // 0x02 ^B
    0,                                                     // 0x03 ^C
    0,                                                     // 0x04 ^D
    0,                                                     // 0x05 ^E
    0,                                                     // 0x06 ^F
    0,                                                     // 0x07 ^G
    0,                                                     // 0x08 ^H
    0,                                                     // 0x09 ^I
    0,                                                     // 0x0A ^J
    0,                                                     // 0x0B ^K
    0,                                                     // 0x0C ^L
    0,                                                     // 0x0D ^M
    0,                                                     // 0x0E ^N
    0,                                                     // 0x0F ^O
    0,                                                     // 0x10 ^P
    0,                                                     // 0x11 ^Q
    0,                                                     // 0x12 ^R
    0,                                                     // 0x13 ^S
    0,                                                     // 0x14 ^T
    0,                                                     // 0x15 ^U
    0,                                                     // 0x16 ^V
    0,                                                     // 0x17 ^W
    0,                                                     // 0x18 ^X
    0,                                                     // 0x19 ^Y
    0,                                                     // 0x1A ^Z
    0,                                                     // 0x1B
    0,                                                     // 0x1C
    0,                                                     // 0x1D
    0,                                                     // 0x1E
    0,                                                     // 0x1F
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x20
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x21 !
    MY_FSRTL_WILD_CHARACTER,                                  // 0x22 "
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x23 #
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x24 $
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x25 %
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x26 &
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x27 '
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x28 (
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x29 )
    MY_FSRTL_WILD_CHARACTER,                                  // 0x2A *
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x2B +
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x2C ,
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x2D -
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x2E .
    0,                                                     // 0x2F /
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x30 0
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x31 1
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x32 2
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x33 3
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x34 4
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x35 5
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x36 6
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x37 7
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x38 8
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x39 9
    MY_FSRTL_NTFS_LEGAL,                                      // 0x3A :
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x3B ;
    MY_FSRTL_WILD_CHARACTER,                                  // 0x3C <
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x3D =
    MY_FSRTL_WILD_CHARACTER,                                  // 0x3E >
    MY_FSRTL_WILD_CHARACTER,                                  // 0x3F ?
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x40 @
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x41 A
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x42 B
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x43 C
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x44 D
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x45 E
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x46 F
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x47 G
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x48 H
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x49 I
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4A J
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4B K
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4C L
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4D M
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4E N
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x4F O
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x50 P
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x51 Q
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x52 R
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x53 S
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x54 T
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x55 U
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x56 V
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x57 W
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x58 X
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x59 Y
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x5A Z
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x5B [
    0,                                                     // 0x5C backslash
    MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL,                   // 0x5D ]
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x5E ^
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x5F _
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x60 `
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x61 a
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x62 b
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x63 c
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x64 d
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x65 e
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x66 f
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x67 g
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x68 h
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x69 i
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6A j
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6B k
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6C l
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6D m
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6E n
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x6F o
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x70 p
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x71 q
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x72 r
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x73 s
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x74 t
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x75 u
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x76 v
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x77 w
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x78 x
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x79 y
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7A z
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7B {
    0,                                                     // 0x7C |
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7D }
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7E ~
    MY_FSRTL_FAT_LEGAL | MY_FSRTL_HPFS_LEGAL | MY_FSRTL_NTFS_LEGAL, // 0x7F ^?
};

PUCHAR MyFsRtlLegalAnsiCharacterArray = &LocalLegalAnsiCharacterArray[0];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\protocol.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    protocol.cxx

Abstract:

    Contains functions to negotiate data connections with, send commands to and
    receive data from, the FTP server

    Contents:
        Command
        I_Command
        NegotiateDataConnection
        GetReply
        ReceiveFtpResponse
        AbortTransfer
        (SendCommand)
        (I_SendCommand)
        (I_AttemptDataNegotiation)
        (I_NegotiateDataConnection)

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Environment:

    Win32 user-level DLL

Revision History:

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// private prototypes
//

PRIVATE
DWORD
__cdecl
SendCommand(
    IN ICSocket * s,
    IN LPCSTR lpszFormat,
    IN ...
    );

PRIVATE
DWORD
I_SendCommand(
    IN ICSocket * s,
    IN LPCSTR lpszFormat,
    va_list arglist
    );

PRIVATE
DWORD
I_AttemptDataNegotiation(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    );

PRIVATE
DWORD
I_NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist,
    IN BOOL bOverridePassive
    );

//
// functions
//


DWORD
Command(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    )

/*++

Routine Description:

    Sends a command to the FTP server on the control connection and optionally
    sets up a data connection. Wrapper for I_Command()

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing FTP server and
                          our connection to it

    fExpectResponse     - TRUE if we need a data connection

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to response code returned from server

    lpszCommandFormat   - pointer to command string

    ...                 - optional arguments for command string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "Command",
                "%#x, %B, %#x, %#x, %q",
                lpSessionInfo,
                fExpectResponse,
                dwFlags,
                prcResponse,
                lpszCommandFormat
                ));

    DWORD error;
    va_list arglist;

    va_start(arglist, lpszCommandFormat);

    error = I_Command(lpSessionInfo,
                      fExpectResponse,
                      dwFlags,
                      prcResponse,
                      lpszCommandFormat,
                      arglist
                      );

    va_end(arglist);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
I_Command(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    )

/*++

Routine Description:

    Sends a command to the FTP server, and if requested, negotiates a data
    connection

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing the FTP server
                          and our connection to it

    fExpectResponse     - TRUE if we need a data connection

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to returned server response

    lpszCommandFormat   - command to send to server

    arglist             - optional arguments for lpszCommandFormat

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_Command",
                "%#x, %B, %#x, %#x, %q, %#x",
                lpSessionInfo,
                fExpectResponse,
                dwFlags,
                prcResponse,
                lpszCommandFormat,
                arglist
                ));

    DWORD error;

    INET_ASSERT(lpSessionInfo != NULL);
    INET_ASSERT(prcResponse != NULL);
    INET_ASSERT(lpszCommandFormat != NULL);
    INET_ASSERT(   ((dwFlags & FTP_TRANSFER_TYPE_MASK) == FTP_TRANSFER_TYPE_UNKNOWN)
                || ((dwFlags & FTP_TRANSFER_TYPE_MASK) == FTP_TRANSFER_TYPE_ASCII)
                || ((dwFlags & FTP_TRANSFER_TYPE_MASK) == FTP_TRANSFER_TYPE_BINARY)
                );

    //
    // if the control socket is not valid, return "connection dropped"
    //

    if (!lpSessionInfo->socketControl->IsValid()) {
        error = ERROR_FTP_DROPPED;
        goto quit;
    }

    //
    // there can only be one data connection established for each FTP session
    //

    if (lpSessionInfo->socketData->IsValid()) {
        error = ERROR_FTP_TRANSFER_IN_PROGRESS;
        goto quit;
    }

    //
    // if we need a data connection then send the connection set-up commands
    // and issue the command
    //

    if (fExpectResponse) {
        error = I_AttemptDataNegotiation(lpSessionInfo,
                                         dwFlags,
                                         prcResponse,
                                         lpszCommandFormat,
                                         arglist
                                         );
        if (error == ERROR_SUCCESS) {

            //
            // check the server response for failure
            //

            if ((prcResponse->Major != FTP_RESPONSE_PRELIMINARY)
            && (prcResponse->Major != FTP_RESPONSE_COMPLETE)) {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }
        }
    } else {

        //
        // no data connection required, just send the command and check any
        // response from the server for a failure indication
        //

        error = I_SendCommand(lpSessionInfo->socketControl,
                              lpszCommandFormat,
                              arglist
                              );
        if (error == ERROR_SUCCESS) {
            error = GetReply(lpSessionInfo, prcResponse);
            if (error == ERROR_SUCCESS) {
                if ((prcResponse->Major != FTP_RESPONSE_COMPLETE)
                && (prcResponse->Major != FTP_RESPONSE_CONTINUE)
                && (prcResponse->Major != FTP_RESPONSE_PRELIMINARY)) {
                    error = ERROR_INTERNET_EXTENDED_ERROR;
                }
            }
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN ...
    )

/*++

Routine Description:

    Sets up a data connection between this client and the FTP server. Wrapper
    for I_AttemptDataNegotiation()

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing the FTP server
                          and our connection to it

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to returned server response code

    lpszCommandFormat   - command string to send

    ...                 - optional arguments for lpszCommandFormat

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    error returned by Windows sockets

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "NegotiateDataConnection",
                "%#x, %#x, %#x, %q",
                lpSessionInfo,
                dwFlags,
                prcResponse,
                lpszCommandFormat
                ));

    va_list arglist;

    va_start(arglist, lpszCommandFormat);

    DWORD error = I_AttemptDataNegotiation(lpSessionInfo,
                                           dwFlags,
                                           prcResponse,
                                           lpszCommandFormat,
                                           arglist
                                           );

    va_end(arglist);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GetReply(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    OUT FTP_RESPONSE_CODE *prcResponse
    )

/*++

Routine Description:

    Gets the response code from the server. The response text is stored in the
    per-thread last response text field, and the FTP response code is parsed
    off the start of the text and returned in prcResponse

Arguments:

    lpSessionInfo   - pointer to FTP_SESSION_INFO for which to get response text

    prcResponse     - pointer to the response code structure

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "GetReply",
                "%#x, %#x",
                lpSessionInfo,
                prcResponse
                ));

    PCHAR pchReplyBuffer;
    DWORD cchBufferLength;
    DWORD error;

    INET_ASSERT(prcResponse != NULL);

    //
    // set up a default error code
    //

    prcResponse->Major = FTP_RESPONSE_PERMANENT_FAILURE;
    prcResponse->Minor = 0;
    prcResponse->Detail = 0;
    prcResponse->Status = 0;

    pchReplyBuffer = NULL;

    //
    // receive the last response on the control socket
    //

    error = ReceiveFtpResponse(lpSessionInfo->socketControl,
                               (LPVOID *)&pchReplyBuffer,
                               &cchBufferLength,
                               TRUE,
                               prcResponse
                               );
    if (error == ERROR_SUCCESS) {

        INET_ASSERT(pchReplyBuffer != NULL);

        //
        // append this response text to that already stored in this thread's
        // data object
        //

        InternetSetLastError(0,
                             pchReplyBuffer,
                             cchBufferLength,
                             SLE_APPEND | SLE_ZERO_TERMINATE
                             );

        //
        // extract status code
        //

        LPSTR lpszError = pchReplyBuffer;

        ExtractInt(&lpszError, 0, &prcResponse->Status);

        DEBUG_PRINT(PROTOCOL, INFO, ("FTP status = %d\n", prcResponse->Status));

    } else {

        INET_ASSERT(pchReplyBuffer == NULL);

    }

    //
    // finished with the buffer
    //

    if (pchReplyBuffer != NULL) {
        pchReplyBuffer = (PCHAR)FREE_MEMORY((HLOCAL)pchReplyBuffer);

        INET_ASSERT(pchReplyBuffer == NULL);

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReceiveFtpResponse(
    IN ICSocket * Socket,
    OUT LPVOID * lpBuffer,
    OUT LPDWORD lpdwBufferLength,
    IN BOOL fEndOfLineCheck,
    IN FTP_RESPONSE_CODE * prcResponse
    )

/*++

Routine Description:

    Receives data from the FTP server. Optionally parses it for end-of-line
    sequence

    This function is typically going to receive one or more lines of response
    data, i.e. a small amount of data. Also typically, we will not normally
    expect to get EOF(connection) because we are usually reading the control
    connection

Arguments:

    Socket              - socket on which to receive data

    lpBuffer            - pointer to pointer to returned data buffer

    lpdwBufferLength    - pointer to returned length of (returned) data buffer

    fEndOfLineCheck     - TRUE if we are to perform an end-of-line check

    prcResponse         - pointer to returned server response code

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "ReceiveFtpResponse",
                "%#x, %#x, %#x, %B, %#x",
                Socket,
                lpBuffer,
                lpdwBufferLength,
                fEndOfLineCheck,
                prcResponse
                ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT(lpdwBufferLength != NULL);

    if (fEndOfLineCheck) {

        INET_ASSERT(prcResponse != NULL);

    }

    LPSTR pchBuffer;
    DWORD bufferLength;
    DWORD bufferLeft;
    DWORD bytesReceived;
    int idxPosInLine;
    BOOL fLastLineDigitsSeen;
    BOOL fAtEOL;
    int nNumericReply;
    DWORD error;

    //
    // initialize variables (for SocketReceive())
    //

    pchBuffer = NULL;
    bufferLength = 0;
    bufferLeft = 0;
    bytesReceived = 0;

    //
    // get per-thread info block to determine blocking/non-blocking socket calls
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //DWORD asyncFlags;
    //
    //asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // this flag is set to FALSE once the digits are definitely NOT seen, and
    // needs to be TRUE at the start of each new line
    //

    fLastLineDigitsSeen = TRUE;
    nNumericReply = 0;
    idxPosInLine = 0;
    fAtEOL = FALSE;

    BOOL eofData;

    while (TRUE) {

        //
        // get the next chunk of response data from the server. Since we are
        // expecting a response (i.e. small amount of data (< 1K)) we shouldn't
        // have to do this too many times
        //

        error = Socket->Receive(
                              (LPVOID *)&pchBuffer,
                              &bufferLength,
                              &bufferLeft,
                              &bytesReceived,
                              sizeof('\0'),     // dwExtraSpace
                              SF_EXPAND         // SocketReceive will allocate/grow the buffer
                              | SF_COMPRESS     //  and compress any unused space at EOF
                              | SF_INDICATE,     //  and make indications to app
                              &eofData
                              );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if we have hit the end of the data then zero-terminate the buffer
        //

        if (eofData) {

            INET_ASSERT(bufferLeft > 0);

            pchBuffer[bytesReceived] = '\0';
        }

        //
        // if requested, find out if we got the end-of-line (on the last line)
        //

        if (fEndOfLineCheck) {

            //
            // look for the final line of the response
            //

            for (DWORD bytesChecked = 0;
                bytesChecked < bytesReceived;
                ++bytesChecked, ++idxPosInLine) {

                //
                // ISSUE: fAtEOL && fLastLineDigitsSeen ==> protocol error,
                // since there is data after the response line
                //

                //
                // if the previous character was an EOL, then the next one must
                // be the start of the next line. Reinitialize the response-
                // decoding state
                //

                if (fAtEOL) {
                    fLastLineDigitsSeen = TRUE;
                    nNumericReply = 0;
                    idxPosInLine = 0;
                    fAtEOL = FALSE;
                }

                //
                // if (so far) this line has been of the form we expect for a
                // response last-line, check the chars we just received to see
                // if it maintains that form
                //
                // since this form is completely determined by the first four
                // characters of the line, limit the checking to those chars
                //

                if (fLastLineDigitsSeen && (idxPosInLine < 4)) {
                    if (idxPosInLine < 3) {

                        //
                        // if one of the first three chars is not a digit, mark
                        // this line as a non-response
                        //

                        if (!isdigit(pchBuffer[bytesChecked])) {
                            fLastLineDigitsSeen = FALSE;
                        } else {

                            //
                            // store the numeric reply in an int
                            //

                            nNumericReply *= 10;
                            nNumericReply += (int)(pchBuffer[bytesChecked] - '0');
                        }
                    } else if (idxPosInLine == 3) {

                        //
                        // the first three chars must be digits.  If the fourth is a
                        // space, then this line has the right form
                        //

                        if (pchBuffer[bytesChecked] != ' ') {
                            fLastLineDigitsSeen = FALSE;
                        }
                    }
                }

                //
                // if at the end of a line, reset vars for the next line
                //

                if (pchBuffer[bytesChecked] == '\n') {

                    DEBUG_PRINT(PROTOCOL,
                                INFO,
                                ("At EOL, and fDigits = %B\n",
                                fLastLineDigitsSeen
                                ));

                    fAtEOL = TRUE;
                }
            }
        }

        //
        // if this data is expected to end in a proper response line, and that
        // line has been received, stop receiving more data
        //

        if (fEndOfLineCheck && fLastLineDigitsSeen && fAtEOL) {

            //
            // we found the end of the response, although we may not have
            // received an EOF(transmission) indication, because the server
            // didn't close the connection. Zero terminate the buffer
            //

            INET_ASSERT(bufferLeft > 0);

            pchBuffer[bytesReceived] = '\0';

            //
            // tear the numeric reply up by digit, placing it into our nicer
            // reply structure
            //

            INET_ASSERT(nNumericReply >= 0);
            INET_ASSERT(nNumericReply < 1000);

            prcResponse->Major = (nNumericReply / 100) % 10;
            prcResponse->Minor = (nNumericReply / 10) % 10;
            prcResponse->Detail = (nNumericReply) % 10;
            error = ERROR_SUCCESS;
            goto done;
        }

        //
        // if we were receiving data that was supposed to end in an EOL then this
        // is an error condition. Otherwise, it is the expected way to signal the
        // end of transmission
        //

        if (eofData) {
            if (fEndOfLineCheck) {
                error = ERROR_FTP_DROPPED;
                goto quit;
            } else {

                //
                // caller just receiving data. We're done
                //

                error = ERROR_SUCCESS;
                goto done;
            }
        }
    }

    INET_ASSERT(FALSE);

quit:

    INET_ASSERT(error != ERROR_SUCCESS);

    if (pchBuffer != NULL) {
        pchBuffer = (LPSTR)FREE_MEMORY((HLOCAL)pchBuffer);

        INET_ASSERT(pchBuffer == NULL);

    }

done:

    *lpBuffer = pchBuffer;
    *lpdwBufferLength = bytesReceived;

    INET_ASSERT((pchBuffer != NULL) ? (*(LPDWORD)pchBuffer != 0xc5c5c5c5) : TRUE);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
AbortTransfer(
    IN LPFTP_SESSION_INFO lpSessionInfo
    )

/*++

Routine Description:

    Aborts an ongoing transfer. Typically used to terminate a read file
    operation early. We don't expect a response from the server in this case

Arguments:

    lpSessionInfo   - pointer to FTP_SESSION_INFO containing context for sesion
                      to abort

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_EXTENDED_ERROR

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "AbortTransfer",
                "%#x",
                lpSessionInfo
                ));

    //
    // get per-thread info block to determine blocking/non-blocking socket calls
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //DWORD asyncFlags;
    //
    //asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // send an ABORT preceded by the following NVT/Telnet sequences:
    //
    //  FF F4 = Interrupt Process (IP)
    //  FF F2 = Data Mark (DM)
    //

#define ABORT_COMMAND NVT_INTERRUPT_PROCESS_STRING  \
                      NVT_DATA_MARK_STRING          \
                      "ABOR"                        \
                      "\r\n"

    //
    // BUGBUG - the IP/DM sequence should be sent as URGENT data
    //

    error = lpSessionInfo->socketControl->Send((LPBYTE)ABORT_COMMAND,
                                               sizeof(ABORT_COMMAND) - 1,
                                               SF_INDICATE
                                               );

quit:

    DEBUG_LEAVE(error);

    return error;
}

//
// private functions
//


PRIVATE
DWORD
__cdecl
SendCommand(
    IN ICSocket * Socket,
    IN LPCSTR lpszFormat,
    IN ...
    )

/*++

Routine Description:

    Sends a command string to the FTP server. Wrapper for I_SendCommand()

Arguments:

    Socket      - socket to send data on

    lpszFormat  - printf-style format string

    ...         - arguments for lpszFormat

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "SendCommand",
                "%#x, %q",
                Socket,
                lpszFormat
                ));

    va_list arglist;
    DWORD error;

    va_start(arglist, lpszFormat);

    error = I_SendCommand(Socket,
                          lpszFormat,
                          arglist
                          );

    va_end(arglist);

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
I_SendCommand(
    IN ICSocket * Socket,
    IN LPCSTR lpszFormat,
    va_list arglist
    )

/*++

Routine Description:

    Sends a command string to a server

Arguments:

    Socket      - socket to send command on

    lpszFormat  - printf-style format string for command

    arglist     - variable list of arguments for format string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    error returned from Windows Sockets

                  ERROR_INTERNET_INTERNAL_ERROR
                    The string was too large to fit into our stack buffer

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_SendCommand",
                "%#x, %q, %#x",
                Socket,
                lpszFormat,
                arglist
                ));

#define I_SEND_COMMAND_BUFFER_LENGTH    2048    // Arbitrary (but large)

    //
    // get per-thread info block to determine blocking/non-blocking socket calls
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // we need a buffer large enough to be able to handle the longest path plus
    // the command overhead. Typically, we will only be getting short strings
    // (USER, PORT, etc.)
    //

    //
    // BUGBUG
    // use _vsnprintf() to create the buffer - this allows us to specify the
    // maximum offset in the buffer, so avoiding a stack crash but this
    // brings in the cruntimes which we don't want to do.
    //

    CHAR buf[I_SEND_COMMAND_BUFFER_LENGTH];

    {
        int numChars = wvnsprintf(buf, I_SEND_COMMAND_BUFFER_LENGTH, lpszFormat, arglist);

        INET_ASSERT(numChars <= I_SEND_COMMAND_BUFFER_LENGTH - 2);
        INET_ASSERT(numChars > 0);

        if (numChars <= I_SEND_COMMAND_BUFFER_LENGTH - 2) {

            //
            // append trailing "\r\n"
            //

            buf[numChars++] = '\r';
            buf[numChars++] = '\n';

            error = Socket->Send((LPVOID)buf, numChars, SF_INDICATE);
        } else {

            DEBUG_PRINT(PROTOCOL,
                        ERROR,
                        ("%d chars blows internal buffer limit (%d chars)\n",
                        numChars,
                        I_SEND_COMMAND_BUFFER_LENGTH
                        ));

            error = ERROR_INVALID_PARAMETER;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
I_AttemptDataNegotiation(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist
    )

/*++

Routine Description:

    Attempts to generate a data connection with server. If passive mode is
    selected & passive mode fails, then we back-down to non-passive

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing server to
                          connect to

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to response code variable

    lpszCommandFormat   - command to send

    arglist             - any arguments for command

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - same as I_NegotiateDataConnection

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_AttemptDataNegotiation",
                "%#x, %#x, %#x, %q, %#x",
                lpSessionInfo,
                dwFlags,
                prcResponse,
                lpszCommandFormat,
                arglist
                ));

    //
    // first try it without overriding passive mode
    //

    DWORD error = I_NegotiateDataConnection(lpSessionInfo,
                                            dwFlags,
                                            prcResponse,
                                            lpszCommandFormat,
                                            arglist,
                                            FALSE
                                            );

    //
    // if the negotiation failed because passive mode wasn't supported or not
    // allowed then try non-passive (if ok to do so)
    //

    if (error == ERROR_FTP_NO_PASSIVE_MODE) {

        INET_ASSERT(IsPassiveModeSession(lpSessionInfo));

        error = I_NegotiateDataConnection(lpSessionInfo,
                                          dwFlags,
                                          prcResponse,
                                          lpszCommandFormat,
                                          arglist,
                                          TRUE  // no passive mode this time
                                          );
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
I_NegotiateDataConnection(
    IN LPFTP_SESSION_INFO lpSessionInfo,
    IN DWORD dwFlags,
    IN OUT FTP_RESPONSE_CODE *prcResponse,
    IN LPCSTR lpszCommandFormat,
    IN va_list arglist,
    IN BOOL bOverridePassive
    )

/*++

Routine Description:

    Sends a command to the FTP server and opens a data channel

Arguments:

    lpSessionInfo       - pointer to FTP_SESSION_INFO describing server to
                          connect to

    dwFlags             - controlling how to transfer data between the client
                          and server data connection, and how to set up data
                          connection

    prcResponse         - pointer to response code variable

    lpszCommandFormat   - command to send

    arglist             - any arguments for command

    bOverridePassive    - TRUE if OK to override passive mode (set at connect
                          level)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "I_NegotiateDataConnection",
                "%#x, %#x, %#x, %q, %#x, %B",
                lpSessionInfo,
                dwFlags,
                prcResponse,
                lpszCommandFormat,
                arglist,
                bOverridePassive
                ));

    PUCHAR puchAddr;
    PCHAR pch;

    ICSocket * socketControl;
    ICSocket * socketData ;
    ICSocket * socketListener ;
    DWORD error;
    int serr;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL isAsync;
    BOOL bPassiveMode = FALSE;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    isAsync = lpThreadInfo->IsAsyncWorkerThread;

//Command(lpSessionInfo,
//        FALSE,
//        FTP_TRANSFER_TYPE_UNKNOWN,
//        prcResponse,
//        "MODE B"
////        "MODE S"
//        );

    //
    // tell the server the type of transfer we want - ASCII ('A') or Binary ('I')
    //

    error = Command(lpSessionInfo,
                    FALSE,
                    FTP_TRANSFER_TYPE_UNKNOWN,
                    prcResponse,
                    "TYPE %s",
                    ((dwFlags & FTP_TRANSFER_TYPE_MASK)
                        == FTP_TRANSFER_TYPE_ASCII) ? "A" : "I"
                    );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (prcResponse->Major != FTP_RESPONSE_COMPLETE) {
        error = ERROR_INTERNET_EXTENDED_ERROR;
        goto quit;
    }

    socketControl = lpSessionInfo->socketControl;
    socketData = lpSessionInfo->socketData;
    socketListener = lpSessionInfo->socketListener;

    INET_ASSERT(!socketData->IsValid());
    INET_ASSERT(!socketListener->IsValid());

    //
    // Get the address of our control socket.  We need to know what address
    // family (IPv4 or IPv6) to use for our data connection.  And in the
    // active case, we need to provide this address to the server.
    //

    SOCKADDR_STORAGE ourCtrlAddr;
    error = socketControl->GetSockName((LPSOCKADDR)&ourCtrlAddr,
                                       sizeof(ourCtrlAddr));
    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // we make passive connection if passive mode was specified in
    // InternetConnect() AND we are not overriding it
    //

    bPassiveMode = IsPassiveModeSession(lpSessionInfo) && !bOverridePassive;

    //
    // make the required type of data connection
    //

    if (!bPassiveMode) {

        SOCKADDR_STORAGE ourDataAddr;
        int cbAddrLen;

        //
        // standard (non-passive (ACTIVE?)) transfers. We create a socket and
        // tell the server which socket to connect to. The server then initiates
        // the connection with this client
        //

        error = socketListener->CreateSocket(0, ourCtrlAddr.ss_family,
                                             SOCK_STREAM, IPPROTO_TCP);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

#if INET_DEBUG
        socketListener->SetSourcePort();
#endif

        error = socketListener->Listen();
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Now tell the server what address and port number it should use to
        // connect to us.  The address is the local side of our control
        // connection, and the port number is that of the listening socket.
        //

        error = socketListener->GetSockName((LPSOCKADDR)&ourDataAddr,
                                            sizeof(ourDataAddr));
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // BUGBUG - using (global) winsock ntohs() (i.e. not SOCKS)
        //

        u_short port;

        if (ourCtrlAddr.ss_family == AF_INET) {
            //
            // Legacy IPv4.  The PORT command consists of our IP address
            // formatted as 4 decimal numbers (one per byte) followed by
            // the port number as 2 decimals numbers (one per byte).
            // Byte order is big-endian.
            //
            // REVIEW: RFC 2428 describes the EPRT command, which is
            // intended to replace the PORT command.  Should we try it
            // first?  At the moment, we only attempt EPRT over IPv6.
            //
            port = _I_ntohs(((LPSOCKADDR_IN)&ourDataAddr)->sin_port);
            puchAddr = (PUCHAR)&((LPSOCKADDR_IN)&ourCtrlAddr)->sin_addr;
            error = SendCommand(socketControl,
                                "PORT %d,%d,%d,%d,%d,%d",
                                puchAddr[0],
                                puchAddr[1],
                                puchAddr[2],
                                puchAddr[3],
                                HIBYTE(port),
                                LOBYTE(port)
                );
        } else {
            //
            // IPv6.  The EPRT command is defined in RFC 2428, and has the
            // following format:
            //     EPRT<space><d><address-family><d><address><d><port><d>
            // where <d> is a delimiter character ('|' recommended),
            // <address-family> is an IANA defined number (1=IPv4, 2=IPv6),
            // <address> is the IP address in common string notation,
            // <port> is the port number in common string notation.
            //
#define MAX_IPV6_ADDR_LIT_LEN (sizeof("1111:2222:3333:4444:5555:6666:255.255.255.255%4294967295"))
            char Address[MAX_IPV6_ADDR_LIT_LEN];
            error = _I_getnameinfo((LPSOCKADDR)&ourCtrlAddr,
                                   sizeof(SOCKADDR_IN6), Address,
                                   sizeof(Address), NULL, 0, NI_NUMERICHOST);
            if (error) {
                goto error_exit;
            }
            port = _I_ntohs(((LPSOCKADDR_IN6)&ourDataAddr)->sin6_port);
            error = SendCommand(socketControl, "EPRT |2|%s|%u", Address, port);
        }
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // read the response from the server. We are expecting something along
        // the lines: "200 PORT Command Successful"
        //

        error = GetReply(lpSessionInfo, prcResponse);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }
        if (prcResponse->Major != FTP_RESPONSE_COMPLETE) {

            //
            // Some IPv6 servers use LPRT instead of EPRT.  So we try that.
            // REVIEW: If we change the IPv4 case above to try EPRT first
            // (see REVIEW comment above) then we'd try PORT here for IPv4.
            //

            if ((ourCtrlAddr.ss_family == AF_INET6) &&
                (prcResponse->Status == FTP_RESPONSE_CMD_NOT_IMPL) ||
                (prcResponse->Status == FTP_RESPONSE_CMD_SYNTAX_ERROR)) {

                error = SendCommand(socketControl,
                                    "LPRT 6,16,%u,%u,%u,%u,"
                                    "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,"
                                    "2,%u,%u",
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[0],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[1],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[2],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[3],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[4],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[5],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[6],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[7],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[8],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[9],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[10],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[11],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[12],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[13],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[14],
                                    ((LPSOCKADDR_IN6)(&ourCtrlAddr))->sin6_addr.s6_addr[15],
                                    HIBYTE(port), LOBYTE(port)
                                    );
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                error = GetReply(lpSessionInfo, prcResponse);
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                if (prcResponse->Major == FTP_RESPONSE_COMPLETE)
                    goto GotActiveReply;
            }

            error = ERROR_INTERNET_EXTENDED_ERROR;
            goto error_exit;
        }
    } else {

        PCHAR pchTemp;

        //
        // PASSIVE mode. Due to problems with firewalls not allowing incoming
        // connection requests, we have to ask the server to create a new socket
        // which we then connect to. This is the inverse of the non-PASV connect
        // case above
        //

        error = socketData->CreateSocket(0, ourCtrlAddr.ss_family,
                                         SOCK_STREAM, IPPROTO_TCP);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // send the PASV request to the server
        //

        if (ourCtrlAddr.ss_family == AF_INET) {
            // REVIEW: Attempt EPSV first for IPv4 as well?
            error = SendCommand(socketControl, "PASV");
        } else {
            error = SendCommand(socketControl, "EPSV");
        }
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Read the response.  For the "PASV" command, we are expecting it
        // to return the full address information for the port in the form
        //     "227 (h1,h2,h3,h4,p1,p2)"
        // meaning that the server is entering PASSIVE mode (227), and the
        // IP address and socket to connect to being h1.h2.h3.h4, p1p2.
        //
        // For the "EPSV" command, we are expecting a response of the form
        //     "229 (<d><d><d><port><d>)"
        // meaning that the server is entering PASSIVE mode (229), the
        // IP address to connect to is that of the control connection, and
        // the port number to connect to is given by <port>.
        //

        error = GetReply(lpSessionInfo, prcResponse);
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }
        if (prcResponse->Major != FTP_RESPONSE_COMPLETE) {

            //
            // Some IPv6 servers use LPSV instead of EPSV.
            // The wonderful thing about standards is that
            // there are so many to choose from.
            //
            if ((ourCtrlAddr.ss_family == AF_INET6) &&
                ((prcResponse->Status == FTP_RESPONSE_CMD_NOT_IMPL) ||
                 (prcResponse->Status == FTP_RESPONSE_CMD_SYNTAX_ERROR))) {

                error = SendCommand(socketControl, "LPSV");
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                error = GetReply(lpSessionInfo, prcResponse);
                if (error != ERROR_SUCCESS) {
                    goto error_exit;
                }

                if (prcResponse->Major == FTP_RESPONSE_COMPLETE)
                    goto GotPassiveReply;
            }

            //
            // If we get 500 or 502 (command not implemented), 425
            // (can't open data connection), or 530 (not logged in)
            // then return ERROR_FTP_NO_PASSIVE_MODE, else
            // ERROR_INTERNET_EXTENDED_ERROR.
            //

            if ((prcResponse->Status == FTP_RESPONSE_CANT_OPEN_DATA)
            ||  (prcResponse->Status == FTP_RESPONSE_CMD_NOT_IMPL)
            ||  (prcResponse->Status == FTP_RESPONSE_CMD_SYNTAX_ERROR)
            ||  (prcResponse->Status == FTP_RESPONSE_NOT_LOGGED_IN)) {
                error = ERROR_FTP_NO_PASSIVE_MODE;
            } else {
                error = ERROR_INTERNET_EXTENDED_ERROR;
            }
            goto error_exit;
        }

      GotPassiveReply:

        //
        // parse the endpoint out of the server response (stored in the per-
        // thread last response info buffer).
        //
        // If we fail to lock the response text, then that's an internal error.
        // If we fail to parse the required information out of the response text
        // then we return an extended error indication, since presumably the
        // server sent response text, but not what we were expecting
        //

        pch = (PCHAR)InternetLockErrorText();
        if (pch != NULL) {
            if (ourCtrlAddr.ss_family == AF_INET) {
                //
                // Parse respone to PASV command.
                //
                pch = strstr(pch, "227 ");
                if (pch != NULL) {
                    pch += sizeof("227 ") - 1;
                    while (!isdigit(*pch) && *pch) {
                        ++pch;
                    }
                    if (isdigit(*pch)) {

                        int i;
                        DWORD octets[6];

                        //
                        // parse the individual address parts out of the response
                        //

                        for (i = 0; (i < ARRAY_ELEMENTS(octets)) && isdigit(*pch); ++i) {
                            if (!ExtractInt(&pch, 0, (LPINT)&octets[i])) {
                                break;
                            }
                            if (octets[i] > 255) {
                                break;
                            }
                            if (i < ARRAY_ELEMENTS(octets) - 1) {
                                while (!isdigit(*pch) && *pch) {
                                    ++pch;
                                }
                            }
                        }

                        //
                        // if we successfully parsed the server's address info then
                        // try to connect with the address it sent us
                        //

                        if ((i == ARRAY_ELEMENTS(octets)) && (octets[i - 1] <= 255)) {

                            SOCKADDR_IN remoteSockaddr;

                            memset(&remoteSockaddr, 0, sizeof(remoteSockaddr));
                            remoteSockaddr.sin_family = AF_INET;

                            //
                            // N.B. Using (global) winsock ntohs() (i.e. not SOCKS)
                            //

                            remoteSockaddr.sin_port = _I_htons(
                                (USHORT)((octets[4] << 8)
                                         | (USHORT)octets[5]));
                            puchAddr = (PUCHAR)&remoteSockaddr.sin_addr;
                            puchAddr[0] = (UCHAR)octets[0];
                            puchAddr[1] = (UCHAR)octets[1];
                            puchAddr[2] = (UCHAR)octets[2];
                            puchAddr[3] = (UCHAR)octets[3];
                            error = socketData->DirectConnect(
                                (LPSOCKADDR)&remoteSockaddr);
                        } else {

                            DEBUG_PRINT(PROTOCOL,
                                        ERROR,
                                        ("failed to parse 6 address elements\n"
                                        ));

                            error = ERROR_INTERNET_EXTENDED_ERROR;
                        }
                    } else {

                        DEBUG_PRINT(PROTOCOL,
                                    ERROR,
                                    ("failed to locate start of address info in response text\n"
                                    ));

                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                } else {

                    DEBUG_PRINT(PROTOCOL,
                                ERROR,
                                ("failed to locate \"227\" in response text\n"
                                ));

                    error = ERROR_INTERNET_EXTENDED_ERROR;
                }
            } else {
                CHAR delim;
                //
                // Parse respone to EPSV or LPSV command.
                //
                pchTemp = strstr(pch, "229 ");
                if (pchTemp != NULL) {
                    pch = pchTemp + sizeof("229 ") - 1;
                    while ((*pch != '(') && (*pch != '\0')) {
                        ++pch;
                    }
                    if ((pch[0] == '(') &&
                        ((delim = pch[1]) != '\0') &&
                        (pch[2] == delim) &&
                        (pch[3] == delim)) {

                        DWORD port;

                        //
                        // parse the port out of the response
                        //
                        pch += 4;
                        if (ExtractInt(&pch, 0, (LPINT)&port)) {

                            //
                            // if we successfully parsed the port then
                            // try to connect with it
                            //

                            SOCKADDR_IN6 remoteSockaddr;

                            error = socketControl->GetPeerName(
                                (LPSOCKADDR)&remoteSockaddr,
                                sizeof(SOCKADDR_IN6));

                            if (error == ERROR_SUCCESS) {
                                //
                                // N.B. Using (global) winsock ntohs()
                                // (i.e. not SOCKS)
                                //
                                remoteSockaddr.sin6_port =
                                    _I_htons((USHORT)port);
                                error = socketData->DirectConnect(
                                    (LPSOCKADDR)&remoteSockaddr);
                            }
                        } else {
                            DEBUG_PRINT(PROTOCOL,
                                        ERROR,
                                        ("failed to parse port\n"
                                        ));

                            error = ERROR_INTERNET_EXTENDED_ERROR;
                        }
                    } else {

                        DEBUG_PRINT(PROTOCOL,
                                    ERROR,
                                    ("failed to locate start of address info in response text\n"
                                    ));

                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                } else if ((pchTemp = strstr(pch, "228 ")) != NULL) {
                    pch = pchTemp + sizeof("228 ") - 1;
                    while (!isdigit(*pch) && *pch) {
                        ++pch;
                    }
                    if (isdigit(*pch)) {

                        int i;
                        DWORD octets[21];

                        //
                        // Parse the individual address parts out of
                        // the response.
                        //

                        for (i = 0; (i < ARRAY_ELEMENTS(octets)) && isdigit(*pch); ++i) {
                            if (!ExtractInt(&pch, 0, (LPINT)&octets[i])) {
                                break;
                            }
                            if (octets[i] > 255) {
                                break;
                            }
                            if (i < ARRAY_ELEMENTS(octets) - 1) {
                                while (!isdigit(*pch) && *pch) {
                                    ++pch;
                                }
                            }
                        }

                        //
                        // If we successfully parsed the server's address info
                        // then try to connect with the address it sent us.
                        //

                        if ((i == ARRAY_ELEMENTS(octets)) &&
                            (octets[i - 1] <= 255) &&
                            (octets[0] == 6) &&
                            (octets[1] == 16) &&
                            (octets[18] == 2)) {

                            SOCKADDR_IN6 remoteSockaddr;

                            memset(&remoteSockaddr, 0, sizeof remoteSockaddr);
                            remoteSockaddr.sin6_family = AF_INET6;

                            //
                            // N.B. Using (global) winsock ntohs()
                            // (i.e. not SOCKS)
                            //

                            remoteSockaddr.sin6_port = _I_htons(
                                (USHORT)((octets[19] << 8)
                                         | (USHORT)octets[20]));
                            for (i = 0; i < 16; i++)
                                remoteSockaddr.sin6_addr.s6_addr[i] = (UCHAR)octets[i + 2];

                            error = socketData->DirectConnect(
                                (LPSOCKADDR)&remoteSockaddr);
                        } else {

                            DEBUG_PRINT(PROTOCOL,
                                        ERROR,
                                        ("failed to parse 20 address elements\n"
                                        ));

                            error = ERROR_INTERNET_EXTENDED_ERROR;
                        }
                    } else {

                        DEBUG_PRINT(PROTOCOL,
                                    ERROR,
                                    ("failed to locate start of address info in response text\n"
                                    ));

                        error = ERROR_INTERNET_EXTENDED_ERROR;
                    }
                } else {

                    DEBUG_PRINT(PROTOCOL,
                                ERROR,
                                ("failed to locate \"229\" or \"228\" in response text\n"
                                ));

                    error = ERROR_INTERNET_EXTENDED_ERROR;
                }
            }

            //
            // unlock the response text
            //

            //InternetUnlockErrorText();
        } else {

            DEBUG_PRINT(PROTOCOL,
                        ERROR,
                        ("failed to lock last response text\n"
                        ));

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }

        //
        // bail out if we met with any errors
        //

        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

  GotActiveReply:

    //
    // issue SIZE command to get file size
    //
    if(StrCmpNI(lpszCommandFormat, "RETR", 4) == 0) {   // If we're downloading a file
        error = I_SendCommand(socketControl,
                              "SIZE %s",
                              arglist
                              );
        if (error != ERROR_SUCCESS) {
            goto error_exit;
        }

        error = GetReply(lpSessionInfo, prcResponse);
        if (error != ERROR_SUCCESS) {
            if (socketData->IsValid()) {
                ResetSocket(socketData);
            }
            goto error_exit;
        }

        if (prcResponse->Major == FTP_RESPONSE_COMPLETE) {
            pch = (PCHAR)InternetLockErrorText();
            if (pch != NULL) {
                pch = strstr(pch, "213 ");
                if (pch != NULL) {

                    pch += sizeof("213 ") - 1;
                    if ( pch )
                    {
                        if (*pch && isdigit(*pch)) {
                            if (ExtractInt(&pch, 0, (int *) &(lpSessionInfo->dwFileSizeLow))) {
                                lpSessionInfo->Flags |= FFTP_KNOWN_FILE_SIZE;
                            }
                        }
                    }

                }
            }
        }
    }

    //
    // we have the data connection, send the command
    //

    error = I_SendCommand(socketControl,
                          lpszCommandFormat,
                          arglist
                          );
    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // get the preliminary reply from the FTP server
    //

    error = GetReply(lpSessionInfo, prcResponse);
    if (error != ERROR_SUCCESS) {
        if (socketData->IsValid()) {
            ResetSocket(socketData);
        }
        goto error_exit;
    }

    if ((prcResponse->Major != FTP_RESPONSE_PRELIMINARY)
    && (prcResponse->Major != FTP_RESPONSE_COMPLETE)) {
        if (socketData->IsValid()) {
            ResetSocket(socketData);
        }
        error = ERROR_INTERNET_EXTENDED_ERROR;
        goto error_exit;
    }

    //
    // Parse out file size if its around
    // Assumes the substring containing the file size looks like; "(99999 bytes)"
    //
    if(!(lpSessionInfo->Flags & FFTP_KNOWN_FILE_SIZE)) {  // Don't already have the size
        pch = (PCHAR)InternetLockErrorText();
        if (pch != NULL) {
            pch = strstr(pch, "150 ");
            if (pch != NULL) {

                pch += sizeof("150 ") - 1;
                PCHAR pchEnd = strstr(pch, " bytes)");
                if (pchEnd) {
                    DWORD dwFileSize = 0;
                    DWORD dwMul = 1;
                    PCHAR pchBeg = pch;
                    pch = pchEnd - 1;
                    while (pch && (pch > pchBeg) && isdigit(*pch)) {
                        dwFileSize += ((*pch - '0') * dwMul);
                        dwMul *= 10;
                        pch--;
                    }
                    
                    if (pch && (*pch == '(') && (dwFileSize > 0)) {
                        lpSessionInfo->dwFileSizeLow = dwFileSize;
                        lpSessionInfo->Flags |= FFTP_KNOWN_FILE_SIZE;
                    }
                }
            }
        }
    }

    //
    // unlock the response text
    //

    //InternetUnlockErrorText();

    //
    // if we are expecting the server to create the connection (ACTIVE mode)
    // then perform an accept() on our listening socket in order to establish
    // the connection
    //

    if (!bPassiveMode) {

        //
        // if we just accept(), we may hang forever if the server doesn't call
        // back (servers are all alike), so we use select() to wait for the
        // socket to be acceptable before calling accept() proper
        //

        error = socketListener->SelectAccept(
                                    *socketData,

                                    //
                                    // BUGBUG - call GetTimeoutValue()
                                    //

                                    GlobalFtpAcceptTimeout
                                    );

        if ( error != ERROR_SUCCESS ) {
            goto error_exit;
        }

        //
        // we no longer require the socket we created for listening for the
        // incoming server connection request
        //

        INET_ASSERT(socketListener != socketControl);
        INET_ASSERT(socketListener != socketData);
        INET_ASSERT(socketListener->GetSocket() != socketControl->GetSocket());
        INET_ASSERT(socketListener->GetSocket() != socketData->GetSocket());

#if INET_DEBUG
        socketData->SetSourcePort();
#endif

        socketListener->Close();
        if (!socketData->IsValid()) {
            goto error_exit;
        }
    }

    //
    // set send and receive timeouts for data socket. If we get an error, ignore
    // it. Note this probably means that the socket is (somehow) invalid, and
    // that we should really return an error. But for now (as with the other
    // protocols), I will presume that the error is non-fatal (but note it)
    //

    socketData->SetTimeout(
                SEND_TIMEOUT,
                (int)GetTimeoutValue(INTERNET_OPTION_DATA_SEND_TIMEOUT)
                );
    socketData->SetTimeout(
                RECEIVE_TIMEOUT,
                (int)GetTimeoutValue(INTERNET_OPTION_DATA_RECEIVE_TIMEOUT)
                );

    INET_ASSERT(error == ERROR_SUCCESS);

    INET_ASSERT(lpSessionInfo->socketData == socketData);

quit:

    DEBUG_LEAVE(error);

    return error;


error_exit:

    if (socketData->IsValid()) {
        socketData->Close();
    }
    if (socketListener->IsValid()) {
        socketListener->Close();
    }
    goto quit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\session.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    session.h

Abstract:

    Structures, prototypes for session.c

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Revision History:

    21-Jun-1994 t-heathh
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define FTP_SESSION_SIGNATURE   0x53707446  // "FtpS" (when viewed via db/dc)

//
// macros
//

#if INET_DEBUG

#define SetSessionSignature(lpSessionInfo)  \
    (lpSessionInfo)->Signature = FTP_SESSION_SIGNATURE

#else

#define SetSessionSignature(lpSessionInfo)

#endif

#define SetSessionLastResponseCode(pSession, prc) \
    CopyMemory(&((pSession)->rcResponseOpenFile), (prc), sizeof(FTP_RESPONSE_CODE))

#define GetSessionLastResponseCode(pSession, prc) \
    CopyMemory((prc), &((pSession)->rcResponseOpenFile), sizeof(FTP_RESPONSE_CODE))

#define IsPassiveModeSession(lpSessionInfo) \
    (((lpSessionInfo)->Flags & FFTP_PASSIVE_MODE) ? TRUE : FALSE)

//
// types
//

typedef enum {
    FTP_SERVER_TYPE_UNKNOWN = 0,
    FTP_SERVER_TYPE_NT = 1,
    FTP_SERVER_TYPE_UNIX = 2
} FTP_SERVER_TYPE;

//
// FTP_SESSION_INFO - describes an FTP server and our connection to it
//

typedef struct {

    //
    // List - SESSION_INFOs are maintained on double-linked list
    //

    LIST_ENTRY List;

    //
    // Host - name of the server we are connected to. We only need this for
    // diagnositic purposes - e.g. knowing which server to talk to to
    // reproduce a problem
    //

    LPSTR Host;

    //
    // Port - the port at which the FTP server listens
    //

    INTERNET_PORT Port;

    //
    // socketListener - listening socket
    //

    ICSocket *socketListener;


    //
    // socketControl - control connection socket
    //

    ICSocket *socketControl;

    //
    // socketData - data connection socket
    //

    ICSocket *socketData;

    //
    // ServerType - type of FTP server, e.g. NT or *nix
    //

    FTP_SERVER_TYPE ServerType;

    //
    // Handle - internally identifies this FTP session
    //

    HANDLE Handle;

    //
    // Flags - bitmask of various flags - see below
    //

    DWORD Flags;

    //
    // ReferenceCount - keeps object alive whilst we are not holding
    // CriticalSection
    //

    LONG ReferenceCount;

    //
    // dwTransferAccess - Indicates, for an ongoing transfer, whether the
    // transfer was begun with GENERIC_READ or GENERIC_WRITE access.
    //
    // {dwTransferAccess} = {GENERIC_READ, GENERIC_WRITE}
    //

    DWORD dwTransferAccess;

    //
    // rcResponseOpenFile - The response code sent back when a data connection
    // was opened, either by FtpOpenFile or FtpCommand.
    //
    // Used by FtpCloseFile to determine whether the completion
    // code was already received.
    //

    FTP_RESPONSE_CODE rcResponseOpenFile;

    //
    // FindFileList - A linked-list of WIN32_FIND_DATA structures, formed by a
    // call to FtpFindFirstFile, used by FtpFindNextFile and
    // FtpFindClose.
    //

    LIST_ENTRY FindFileList;

    //
    // CriticalSection - Synchronize access to this structure's contents
    //

    CRITICAL_SECTION CriticalSection;

    //
    // dwFileSizeLow - Size of the file found on the FTP server, should be gotten
    //   from response data on openning a data connection
    //

    DWORD dwFileSizeLow;
    DWORD dwFileSizeHigh;

#if INET_DEBUG

    //
    // Signature - to help us know this is what its supposed to be in debug build
    //

    DWORD Signature;

#endif

} FTP_SESSION_INFO, *LPFTP_SESSION_INFO;

//
// Flags defines
//

//
// FFTP_PASSIVE_MODE - set if the session uses passive mode data connections
//

#define FFTP_PASSIVE_MODE       0x00000001

//
// FFTP_ABORT_TRANSFER - set if we have not completed a file transfer on this
// (data) connection, and therefore need to send an ABOR command when we close
// the connection
//

#define FFTP_ABORT_TRANSFER     0x00000002

//
// FFTP_FIND_ACTIVE - set when a directory listing is active on this session
//

#define FFTP_FIND_ACTIVE        0x00000004

//
// FFTP_IN_DESTRUCTOR - set when this session is being terminated
//

#define FFTP_IN_DESTRUCTOR      0x00000008

//
// FFTP_EOF - set when we have reached the end of a (receive) data connection
//

#define FFTP_EOF                0x00000010

//
// FFTP_FILE_ACTIVE - set when a file is open on this session
//

#define FFTP_FILE_ACTIVE        0x00000020

//
// FFTP_KNOWN_FILE_SIZE - set when we know the size of the file we're downloading
//

#define FFTP_KNOWN_FILE_SIZE    0x00000040

//
// prototypes
//

VOID
CleanupFtpSessions(
    VOID
    );

VOID
TerminateFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    );

VOID
DereferenceFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    );

DWORD
CreateFtpSession(
    IN LPSTR lpszHost,
    IN INTERNET_PORT Port,
    IN DWORD dwFlags,
    OUT LPFTP_SESSION_INFO* lpSessionInfo
    );

BOOL
FindFtpSession(
    IN HANDLE Handle,
    OUT LPFTP_SESSION_INFO* lpSessionInfo
    );

#if INET_DEBUG

VOID
FtpSessionInitialize(
    VOID
    );

VOID
FtpSessionTerminate(
    VOID
    );

VOID
AcquireFtpSessionList(
    VOID
    );

VOID
ReleaseFtpSessionList(
    VOID
    );

VOID
AcquireFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    );

VOID
ReleaseFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    );

#else

//
// one-line functions replaced by macros in retail version
//

extern SERIALIZED_LIST FtpSessionList;

#define FtpSessionInitialize() \
    InitializeSerializedList(&FtpSessionList)

#define FtpSessionTerminate() \
    TerminateSerializedList(&FtpSessionList)

#define AcquireFtpSessionList() \
    LockSerializedList(&FtpSessionList)

#define ReleaseFtpSessionList() \
    UnlockSerializedList(&FtpSessionList)

#define AcquireFtpSessionLock(lpSessionInfo) \
    EnterCriticalSection(&lpSessionInfo->CriticalSection)

#define ReleaseFtpSessionLock(lpSessionInfo) \
    LeaveCriticalSection(&lpSessionInfo->CriticalSection)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\tcputil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    tcputil.cxx

Abstract:

    Contains functions to connect to an FTP server

    Contents:
        FtpOpenServer
        ResetSocket

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Environment:

    Win32 user-level DLL

Revision History:

--*/

#include <wininetp.h>
#include "ftpapih.h"

//
// functions
//

DWORD
FtpOpenServer(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Resolves a host name and makes a connection to the FTP server at that host.
    If successful, the controlSocket field of the FTP_SESSION_INFO object will
    contain an opened socket handle

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO describing host to connect to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_NAME_NOT_RESOLVED
                  WSA error

--*/

{
    DEBUG_ENTER((DBG_FTP,
                Dword,
                "FtpOpenServer",
                "%#x",
                SessionInfo
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    BOOL  fUseSocksProxy = FALSE;
    INTERNET_CONNECT_HANDLE_OBJECT *pConnect;
    AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery = NULL;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // attempt to resolve the host name, server port, and possibly service GUID
    // to socket address(es)
    //

    SessionInfo->socketControl->SetPort(SessionInfo->Port);


    //
    // Using the object handle, check to see if we have a socks proxy.
    //  If so, use it to do our connections.
    //

    INTERNET_HANDLE_OBJECT * pInternet;
    HINTERNET hConnectMapped;

    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(SessionInfo->Host != NULL);

    //
    // Get the Mapped Connect Handle Object
    //

    hConnectMapped = lpThreadInfo->hObjectMapped;

    INET_ASSERT(hConnectMapped);

    //
    // Finally get the Internet Object, so we can query proxy information
    //  out of it.
    //

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *) hConnectMapped;


    pInternet = (INTERNET_HANDLE_OBJECT *)
                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetParent();

    INET_ASSERT(pInternet);

    {
        CHAR szUrl[INTERNET_MAX_URL_LENGTH + sizeof("ftp:// /")];

        PROXY_STATE * pProxyState = NULL;

        INTERNET_SCHEME scheme = INTERNET_SCHEME_DEFAULT;

        if (lstrlen(SessionInfo->Host)>INTERNET_MAX_URL_LENGTH)
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
        wsprintf(szUrl, "ftp://%s/", SessionInfo->Host);

        AUTO_PROXY_ASYNC_MSG proxyInfoQuery(
                                    INTERNET_SCHEME_FTP,
                                    szUrl,
                                    lstrlen(szUrl),
                                    SessionInfo->Host,
                                    lstrlen(SessionInfo->Host),
                                    (INTERNET_PORT) SessionInfo->Port
                                    );

        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);

        pProxyInfoQuery = &proxyInfoQuery;

        error = pInternet->GetProxyInfo(
                                &pProxyInfoQuery
                                );

        if ( error != ERROR_SUCCESS)
        {
            goto quit2;
        }


        if ( pProxyInfoQuery->IsUseProxy() &&
             pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_SOCKS &&
             pProxyInfoQuery->_lpszProxyHostName )
        {

            //
            //  If Socks is enabled, then turn it on.
            //

            error = SessionInfo->socketControl->EnableSocks(
                                                             pProxyInfoQuery->_lpszProxyHostName,
                                                             pProxyInfoQuery->_nProxyHostPort
                                                             );

            if ( error != ERROR_SUCCESS)
            {
                goto quit2;
            }

            error = SessionInfo->socketData->EnableSocks(
                                                             pProxyInfoQuery->_lpszProxyHostName,
                                                             pProxyInfoQuery->_nProxyHostPort
                                                             );


            if ( error != ERROR_SUCCESS)
            {
                goto quit2;
            }

            //
            // Force Passive Mode, since Socks Firewalls may not
            //  support connections from the outside in.
            //

            SessionInfo->Flags |= FFTP_PASSIVE_MODE;

        }

        pConnect->SetServerInfo(SessionInfo->Host,
                                lstrlen(SessionInfo->Host));



        //
        // name was resolved ok, now let's try to connect to the server. Here
        // we create the control socket
        //

        error = SessionInfo->socketControl->Connect(
                              GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                              GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                              SF_INDICATE | asyncFlags
                              );

    quit2:

        if ( pProxyInfoQuery && pProxyInfoQuery->IsAlloced() )
        {
            delete pProxyInfoQuery;
            pProxyInfoQuery = NULL;
        }
    }

quit:


    DEBUG_LEAVE(error);

    return error;
}


BOOL
ResetSocket(
    IN ICSocket * Socket
    )

/*++

Routine Description:

    Sets linger time to zero on a socket, then closes the socket, causing a
    "hard" close

Arguments:

    Socket  - The socket to reset the connection on

Return Value:

    BOOL
        Success - TRUE
        Failure - FALSE

--*/

{
    //
    // ignore return code from linger - if error, socket is closed or aborted
    //

    Socket->SetLinger(TRUE, 0);
    return (Socket->Close() == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\session.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    Contains functions to create and delete FTP_SESSION_INFOs

    Contents:
        FtpSessionInitialize
        FtpSessionTerminate
        AcquireFtpSessionList
        ReleaseFtpSessionList
        AcquireFtpSessionLock
        ReleaseFtpSessionLock
        CleanupFtpSessions
        TerminateFtpSession
        DereferenceFtpSession
        CreateFtpSession
        (DestroyFtpSession)
        FindFtpSession

Author:

    Richard L Firth (rfirth) 09-Jun-95

Environment:

    Win32 user-level DLL

Revision History:

    09-Jun-95 rfirth
        Created

--*/

#include <wininetp.h>
#include "ftpapih.h"
#include "..\urlcache\debug.h"
//
// private prototypes
//

PRIVATE
VOID
DestroyFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    );

//
// public data
//

//
// FtpSessionList - a doubly-linked list of all the FTP_SESSION_INFOs owned by
// this process
//

PUBLIC SERIALIZED_LIST FtpSessionList;

//
// external data
//

extern BOOL InDllCleanup;

//
// functions
//

#if INET_DEBUG


VOID
FtpSessionInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes any global data items for this module.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Initializing ftp session list\r\n"));
    InitializeSerializedList(&FtpSessionList);
}


VOID
FtpSessionTerminate(
    VOID
    )

/*++

Routine Description:

    Terminates any items initialized by FtpSessionInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Terminating ftp session list\r\n"));
    TerminateSerializedList(&FtpSessionList);
}


VOID
AcquireFtpSessionList(
    VOID
    )

/*++

Routine Description:

    Acquires the FtpSessionList lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Trying to acquiring ftp session list\r\n"));
    LockSerializedList(&FtpSessionList);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Acquired ftp session list\r\n"));
}


VOID
ReleaseFtpSessionList(
    VOID
    )

/*++

Routine Description:

    Releases the FtpSessionList lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Trying to release ftp session list\r\n"));
    UnlockSerializedList(&FtpSessionList);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSIONLIST: Release ftp session list\r\n"));
}


VOID
AcquireFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Acquires an individual session info lock

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to lock

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Trying to acquire %d\r\n", &SessionInfo->CriticalSection));
    EnterCriticalSection(&SessionInfo->CriticalSection);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Acquired ftp session %d\r\n", &SessionInfo->CriticalSection));
}


VOID
ReleaseFtpSessionLock(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Releases an individual session info lock

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to unlock

Return Value:

    None.

--*/

{
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Trying to release %d\r\n", &SessionInfo->CriticalSection));
    LeaveCriticalSection(&SessionInfo->CriticalSection);
    DEBUG_PRINT(FTP, INFO, 
                ("FTPSESSION: Released ftp session %d\r\n", &SessionInfo->CriticalSection));
}

#endif // INET_DEBUG


VOID
CleanupFtpSessions(
    VOID
    )

/*++

Routine Description:

    Terminates all active FTP sessions owned by this process

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPFTP_SESSION_INFO info;

    DEBUG_ENTER((DBG_FTP,
                None,
                "CleanupFtpSessions",
                NULL
                ));

    //
    // walk the session list. For each FTP_SESSION_INFO, close the data and
    // control sockets, if open, then destroy the session
    //

    do {

        DWORD error;

        AcquireFtpSessionList();

        info = (LPFTP_SESSION_INFO)HeadOfSerializedList(&FtpSessionList);
        if (info == (LPFTP_SESSION_INFO)&FtpSessionList.List.Flink) {
            ReleaseFtpSessionList();
            break;
        }

        //
        // kill the data and control sockets. Remorselessly. If the sockets are
        // set to INVALID_SOCKET, then Close() will do the right thing
        //

        error = info->socketData->Close();
        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(SESSION,
                        ERROR,
                        ("Data: Close(%x) returns %d\n",
                        info->socketData,
                        error
                        ));

        }

        error = info->socketControl->Close();
        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(SESSION,
                        ERROR,
                        ("Control: Close(%x) returns %d\n",
                        info->socketControl,
                        error
                        ));

        }

        ReleaseFtpSessionList();
        DestroyFtpSession(info);
    } while (1);

    DEBUG_LEAVE(0);
}


VOID
TerminateFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Initiates termination of the FTP_SESSION_INFO object

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to terminate

Return Value:

    None.

--*/

{
    BOOL destroy;
    int i;

    INET_ASSERT(SessionInfo != NULL);
    INET_ASSERT(!(SessionInfo->Flags & FFTP_IN_DESTRUCTOR));
    INET_ASSERT(SessionInfo->ReferenceCount >= 2);

    DEBUG_ENTER((DBG_FTP,
                None,
                "TerminateFtpSession",
                "%x",
                SessionInfo
                ));

    //
    // first off, set the in-destructor flag. This will cause any other threads
    // trying to find & reference this object to fail
    //

    SessionInfo->Flags |= FFTP_IN_DESTRUCTOR;

    //
    // now we need to decrement the reference count by 2, which should cause
    // the FTP_SESSION_INFO to be destroyed
    //

    AcquireFtpSessionLock(SessionInfo);
    INET_ASSERT(SessionInfo->ReferenceCount>=2);
    if (InterlockedDecrement(&SessionInfo->ReferenceCount))
    {
        InterlockedDecrement(&SessionInfo->ReferenceCount);
    }
    
    if (SessionInfo->ReferenceCount == 0) {
        DestroyFtpSession(SessionInfo);
    } else {
        ReleaseFtpSessionLock(SessionInfo);
        DEBUG_PRINT(REFCOUNT,
                    WARNING,
                    ("unexpected: SessionInfo(%x)->ReferenceCount = %d\n",
                    SessionInfo,
                    SessionInfo->ReferenceCount
                    ));
    }    
    DEBUG_LEAVE(0);
}


VOID
DereferenceFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Reduces the reference count on an FTP_SESSION_INFO object by 1. If the
    reference count goes to 0, the FTP_SESSION_INFO is destroyed

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to dereference

Return Value:

    None.

--*/

{
    INET_ASSERT(SessionInfo->ReferenceCount >= 1);

    DEBUG_ENTER((DBG_FTP,
                None,
                "DereferenceFtpSession",
                "%x",
                SessionInfo
                ));

    AcquireFtpSessionLock(SessionInfo);
    INET_ASSERT(SessionInfo->ReferenceCount>1);
    if (InterlockedDecrement(&SessionInfo->ReferenceCount) == 0) {
        if (SessionInfo->socketControl->IsValid()
            || SessionInfo->socketData->IsValid())
        {
            // All sockets should have been closed by now. However
            // there's a case where two wFtpDisconnect closes the connection
            // but another thread revives those sockets.
            // In this case, shutting down the session would be inappropriate.
            // We should reset the ref count so that it may continue
            INET_ASSERT((SessionInfo->Flags & FFTP_IN_DESTRUCTOR));
            InterlockedIncrement(&SessionInfo->ReferenceCount);
            ReleaseFtpSessionLock(SessionInfo);           
        }
        else
        {
            DestroyFtpSession(SessionInfo);
        }
    } else {
        ReleaseFtpSessionLock(SessionInfo);
        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("SessionInfo(%x)->ReferenceCount = %d\n",
                    SessionInfo,
                    SessionInfo->ReferenceCount
                    ));
    }

    DEBUG_LEAVE(0);
}


DWORD
CreateFtpSession(
    IN LPSTR lpszHost,
    IN INTERNET_PORT Port,
    IN DWORD dwFlags,
    OUT LPFTP_SESSION_INFO* lpSessionInfo
    )

/*++

Routine Description:

    Creates a new FTP_SESSION_INFO object. If successful, adds the new object
    to the FtpSessionList; the reference count of the new object will be 1 (i.e.
    it is unowned)

Arguments:

    lpszHost        - pointer to name of the host we are connecting to. Mainly
                      for diagnostic purposes (can remove it later)

    Port            - Port at which the FTP server listens. Only in anomalous
                      circumstances will this not be 21

    dwFlags         - flags controlling session creation. Can be:
                        - FFTP_PASSIVE_MODE

    lpSessionInfo   - pointer to returned session info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory

                  ERROR_INTERNET_OUT_OF_HANDLES
                    Couldn't allocate a handle

                  ERROR_INTERNET_SHUTDOWN
                    The DLL is being unloaded

--*/

{
    LPFTP_SESSION_INFO sessionInfo;
    DWORD error;

    DEBUG_ENTER((DBG_FTP,
                Dword,
                "CreateFtpSession",
                "%q, %d, %x",
                lpszHost,
                Port,
                lpSessionInfo
                ));

    //
    // if the DLL is being unloaded then return the shutdown error
    //

    if (InDllCleanup) {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    //
    // allocate the FTP_SESSION_INFO 'object' and its various sub-assemblies
    //

    sessionInfo = NEW(FTP_SESSION_INFO);
    if (sessionInfo != NULL) {
        sessionInfo->Host = NEW_STRING(lpszHost);
        if (sessionInfo->Host != NULL) {
            error = AllocateHandle((LPVOID)sessionInfo, &sessionInfo->Handle);
            if (error == ERROR_SUCCESS) {

                INET_ASSERT(sessionInfo->ServerType == FTP_SERVER_TYPE_UNKNOWN);

                //
                // initialize any non-zero fields
                //

                InitializeListHead(&sessionInfo->List);
                sessionInfo->Port = Port;
                sessionInfo->Flags = dwFlags;
                sessionInfo->ReferenceCount = 1;
                InitializeListHead(&sessionInfo->FindFileList);
                InitializeCriticalSection(&sessionInfo->CriticalSection);
                SetSessionSignature(sessionInfo);

                //
                // Allocate Our Socket Objects.
                //

                //
                // Isn't this kinda of messy?  I've copied the format of
                // surrounding block, since there is no clean quit case in this
                // function... arhh.
                //

                sessionInfo->socketControl = new ICSocket();
                if ( sessionInfo->socketControl )
                {
                    sessionInfo->socketData = new ICSocket();
                    if ( sessionInfo->socketData )
                    {
                        sessionInfo->socketListener = new ICSocket();
                        if ( sessionInfo->socketListener  == NULL )
                        {
                            sessionInfo->socketControl->Dereference();
                            sessionInfo->socketData->Dereference();
                            error = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                    else
                    {
                        sessionInfo->socketControl->Dereference();
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }

                }
                else
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }
    if (error == ERROR_SUCCESS) {

        //
        // add this FTP_SESSION_INFO to the object list
        //

        InsertAtHeadOfSerializedList(&FtpSessionList, &sessionInfo->List);
        *lpSessionInfo = sessionInfo;

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("handle = %x, SessionInfo = %x\n",
                    sessionInfo->Handle,
                    sessionInfo
                    ));

    } else if (sessionInfo != NULL) {
        if (sessionInfo->Host != NULL) {
            DEL_STRING(sessionInfo->Host);
        }
        DEL(sessionInfo);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
VOID
DestroyFtpSession(
    IN LPFTP_SESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Removes an FTP_SESSION_INFO object from the session list and destroys it.

    Note: SessionInfo MUST be owned by the current thread (critical section held
    but reference count == 0)

Arguments:

    SessionInfo - pointer to FTP_SESSION_INFO to delete

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_FTP,
                None,
                "DestroyFtpSession",
                "%x",
                SessionInfo
                ));

    INET_DEBUG_ASSERT(SessionInfo->Signature == FTP_SESSION_SIGNATURE);
    INET_ASSERT(!SessionInfo->socketControl->IsValid());
    INET_ASSERT(!SessionInfo->socketData->IsValid());
    INET_ASSERT(SessionInfo->ReferenceCount == 0);

    RemoveFromSerializedList(&FtpSessionList, (PLIST_ENTRY)&SessionInfo->List);

    INET_DEBUG_ASSERT(SessionInfo->List.Flink == NULL);
    INET_DEBUG_ASSERT(SessionInfo->List.Blink == NULL);

    ReleaseFtpSessionLock(SessionInfo);

    if (SessionInfo->Handle) {
        FreeHandle(SessionInfo->Handle);
    }

    if (SessionInfo->Host != NULL) {
        DEL_STRING(SessionInfo->Host);
    }

    if ( SessionInfo->socketControl )
        SessionInfo->socketControl->Dereference();

    if ( SessionInfo->socketData )
        SessionInfo->socketData->Dereference();

    if ( SessionInfo->socketListener )
        SessionInfo->socketListener->Dereference();

    ClearFindList(&SessionInfo->FindFileList);

    DeleteCriticalSection(&SessionInfo->CriticalSection);

    DEL(SessionInfo);

    DEBUG_LEAVE(0);
}


BOOL
FindFtpSession(
    IN HANDLE Handle,
    OUT LPFTP_SESSION_INFO *lpSessionInfo
    )

/*++

Routine Description:

    Searches the session list for an FTP_SESSION_INFO object. If found, the
    FTP_SESSION_INFO's reference count is incremented by 1

Arguments:

    Handle          - handle to search for

    lpSessionInfo   - pointer to returned FTP_SESSION_INFO if found

Return Value:

    BOOL
        Success - TRUE, *lppSessionInfo is pointer to FTP_SESSION_INFO

        Failure - FALSE

--*/

{
    BOOL found;
    LPFTP_SESSION_INFO sessionInfo;

    DEBUG_ENTER((DBG_FTP,
                Bool,
                "FindFtpSession",
                "%x",
                Handle
                ));

    //
    // lock the list, to prevent the element from moving under us
    //

    AcquireFtpSessionList();

    found = FALSE;
    for (sessionInfo = (LPFTP_SESSION_INFO)FtpSessionList.List.Flink;
        sessionInfo != (LPFTP_SESSION_INFO)&FtpSessionList.List;
        sessionInfo = (LPFTP_SESSION_INFO)(sessionInfo->List.Flink)) {

        if (sessionInfo->Handle == Handle) {
            AcquireFtpSessionLock(sessionInfo);

            //
            // if the destructor flag is set then another thread is already
            // destroying this session - we cannot return it. Treat as not
            // found
            //

            if (!(sessionInfo->Flags & FFTP_IN_DESTRUCTOR)) {

                //
                // although we're holding the session info lock (a critical
                // section), we still need to perform interlocked increment
                // on the reference count
                //

                InterlockedIncrement(&sessionInfo->ReferenceCount);
                found = TRUE;
            }
            ReleaseFtpSessionLock(sessionInfo);
            break;
        }
    }

    ReleaseFtpSessionList();

    if (found) {
        *lpSessionInfo = sessionInfo;

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("handle = %x, FTP_SESSION_INFO = %x\n",
                    Handle,
                    sessionInfo
                    ));

    } else {

        DEBUG_PRINT(SESSION,
                    ERROR,
                    ("handle %x: not found\n",
                    Handle
                    ));

    }

    DEBUG_LEAVE(found);

    return found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\tcputil.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    tcputil.h

Abstract:

    Contains prototypes etc. for tcputil.c

Author:

    Heath Hunnicutt (t-hheath) 21-Jun-1994

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
FtpOpenServer(
    IN LPFTP_SESSION_INFO SessionInfo
    );

BOOL
ResetSocket(
    IN ICSocket * Socket
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\test\ftpcat\ftpcatp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpcatp.h

Abstract:

    (Precompiled) Header file for ftpcat

Author:

    Richard L Firth (rfirth) 03-Nov-1995

Revision History:

    03-Nov-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <signal.h>
#include <conio.h>
#include <process.h>
#include <windows.h>
#include <wininet.h>
#include <wininetd.h>
#include <catlib.h>

#ifdef UNICODE

#include <wchar.h>
#define lstrtok(s,t)    wcstok((s),(t))
#define lstrchr(s,c)    wcschr((s),(c))
#define lstrdup(s)      wcsdup((s))

#define lprintf             wprintf

#else

#include <string.h>
#define lstrtok(s,t)    strtok((s),(t))
#define lstrchr(s,c)    strchr((s),(c))
#define lstrdup(s)      _strdup((s))

#define lprintf             printf

#endif // UNICODE


#define nelems(a) ((sizeof(a))/sizeof((a)[0]))

extern DWORD GetProcessHandleCount(void);

//
// manifests
//

#define FTPCAT_CONNECT_CONTEXT  0x1
#define FTPCAT_FIND_CONTEXT     0x2
#define FTPCAT_FILE_CONTEXT     0x3
#define FTPCAT_GET_CONTEXT      0x4
#define FTPCAT_PUT_CONTEXT      0x5
#define FTPCAT_COMMAND_CONTEXT  0x6
#define FTPCAT_OPEN_CONTEXT     0x7

//
// prototypes
//

//
// ftpcat.c
//

void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void close_handle(HINTERNET);

//
// cmds.c
//

void get_response(HINTERNET hFtpSession);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\test\ftpcat\cmds.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cmds.c

Abstract:

    FTP commands

Author:

    Richard L Firth (rfirth) 03-Nov-1995

Revision History:

    03-Nov-1995 rfirth
        Created

--*/

#include "ftpcatp.h"

//
// manifests
//

#define MAX_ARGV            20
#define COMMAND_WHITESPACE  TEXT(" ,\r\n")

//
// external functions
//

extern
BOOL
Prompt(
    IN LPCTSTR pszPrompt,
    OUT LPTSTR* ppszCommand
    );

//
// prototypes
//

BOOL dbgbreak(HINTERNET, int, PTCHAR *);
BOOL chdir(HINTERNET, int, PTCHAR *);
BOOL del(HINTERNET, int, PTCHAR *);
BOOL dir(HINTERNET, int, PTCHAR *);
BOOL get(HINTERNET, int, PTCHAR *);
BOOL help(HINTERNET, int, PTCHAR *);
BOOL lcd(HINTERNET, int, char**);
BOOL mkdir(HINTERNET, int, PTCHAR *);
BOOL put(HINTERNET, int, PTCHAR *);
BOOL pwd(HINTERNET, int, PTCHAR *);
BOOL quit(HINTERNET, int, PTCHAR *);
BOOL rb(HINTERNET, int, char**);
BOOL rename_file(HINTERNET, int, PTCHAR *);
BOOL rmdir(HINTERNET, int, PTCHAR *);
BOOL wb(HINTERNET, int, char**);
BOOL toggle_verbose(HINTERNET, int, PTCHAR *);
BOOL set_type(HINTERNET, int, PTCHAR *);
BOOL open_file(HINTERNET, int, PTCHAR *);
BOOL close_file(HINTERNET, int, PTCHAR *);
BOOL read_file(HINTERNET, int, PTCHAR *);
BOOL write_file(HINTERNET, int, PTCHAR *);
BOOL DispatchCommand(LPTSTR, HINTERNET);

#if DBG

BOOL CheckHandles(HINTERNET, int, PTCHAR*);

#endif

//
// external data
//

extern DWORD Verbose;
extern INTERNET_STATUS_CALLBACK PreviousCallback;
extern HINTERNET hCancel;
extern BOOL AsyncMode;
extern HANDLE AsyncEvent;
extern DWORD AsyncResult;
extern DWORD AsyncError;
extern BOOL UseQueryData;

//
// data
//

typedef struct {
    LPCSTR pszCommand;
    LPCSTR HelpText;
    BOOL (*fn)(HINTERNET, int, PTCHAR []);
} COMMAND_ENTRY;

COMMAND_ENTRY Commands[] = {

#if DBG
    {"b",       "Break into debugger",              dbgbreak},
#endif

    {"!",       "Shell escape",                     NULL},
    {"?",       "This list",                        help},
    {"cd",      "Change to a remote directory",     chdir},
    {"close",   "Close an open file handle",        close_file},
    {"dir",     "List a directory",                 dir},
    {"del",     "Delete a remote file",             del},
    {"get",     "Copy a file from the server",      get},

#if DBG
    {"hndl",    "Get current handle count",         CheckHandles},
#endif

    {"lcd",     "Change local directory",           lcd},
    {"md",      "Create a remote directory",        mkdir},
    {"open",    "Open a file for read or write",    open_file},
    {"put",     "Copy a file to the server",        put},
    {"pwd",     "Display the current directory",    pwd},
    {"quit",    "Terminate this program",           quit},
    {"rb",      "Get/set Read buffer size",         rb},
    {"rd",      "Remove a remote directory",        rmdir},
    {"read",    "Read data from a file",            read_file},
    {"ren",     "Rename a remote file",             rename_file},
    {"type",    "Set transfer type",                set_type},
    {"verbose", "Toggle verbose mode",              toggle_verbose},
    {"wb",      "Get/set Write buffer size",        wb},
    {"write",   "Write data to a file",             write_file},
    {NULL,      NULL,                               NULL}
};

BOOL fQuit = FALSE;
DWORD CacheFlags = 0;
HINTERNET FileHandle = NULL;

//
// functions
//

void get_response(HINTERNET hFtp) {

    DWORD buflen;
    char buffer[2048];
    DWORD category;

    buflen = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &buflen)) {
        if (hFtp && (Verbose >= 2)) {

            DWORD len = sizeof(DWORD);
            DWORD dwFlags;

            if (InternetQueryOption(hFtp,
                                    INTERNET_OPTION_REQUEST_FLAGS,
                                    &dwFlags,
                                    &len)) {
                if (dwFlags & INTERNET_REQFLAG_FROM_CACHE) {
                    fprintf(stderr, "****** Got from the cache ***** \n");
                } else {
                    fprintf(stderr, "****** From the wire ***** \n");
                }
            }
        }
        if (buflen || (Verbose >= 2)) {
            print_response(buffer, buflen, TRUE);
        }
    } else {

        DWORD error;

        error = GetLastError();
        if (Verbose || (error != ERROR_INSUFFICIENT_BUFFER)) {

            LPSTR errString;

            errString = (error == ERROR_INSUFFICIENT_BUFFER)
                            ? "InternetGetLastResponseInfo() returns error %d (buflen = %d)\n"
                            : "InternetGetLastResponseInfo() returns error %d\n"
                            ;
            printf(errString, error, buflen);
        }
        if (error = ERROR_INSUFFICIENT_BUFFER) {

            LPSTR errbuf;

            if ((errbuf = malloc(buflen)) == NULL) {
                printf("error: get_response: malloc(%d) failed\n", buflen);
                return;
            }
            if (InternetGetLastResponseInfo(&category, errbuf, &buflen)) {
                if (buflen || (Verbose >= 2)) {
                    print_response(errbuf, buflen, TRUE);
                }
            } else {
                printf("error: get_response: InternetGetLastResponseInfo() returns error %d (buflen = %d)\n",
                   GetLastError(),
                   buflen
                   );
            }
            free(errbuf);
        }
    }
}

BOOL
quit(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    fQuit = TRUE;

    return TRUE;
}

BOOL
get(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszFilename;
    LPTSTR pszLocalfile;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("remote-name: "), &pszFilename)) {
            return FALSE;
        }
    } else {
        pszFilename = argv[1];
    }

    if (argc >= 3) {
        pszLocalfile = argv[2];
    } else {
        pszLocalfile = pszFilename;
    }

    ok = FtpGetFile(hFtpSession,
                    pszFilename,
                    pszLocalfile,
                    FALSE,
                    FILE_ATTRIBUTE_NORMAL,
                    CacheFlags
                    | FTP_TRANSFER_TYPE_BINARY,
                    FTPCAT_GET_CONTEXT
                    );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("get", "FtpGetFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpGetFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("get", "%sFtpGetFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
put(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszFilename;
    LPTSTR pszLocalfile;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("remote-name: "), &pszFilename)) {
            return FALSE;
        }
    } else {
        pszFilename = argv[1];
    }

    if (argc >= 3) {
        pszLocalfile = argv[2];
    } else {
        pszLocalfile = pszFilename;
    }

    ok = FtpPutFile(hFtpSession,
                    pszLocalfile,
                    pszFilename,
                    FTP_TRANSFER_TYPE_BINARY,
                    FTPCAT_PUT_CONTEXT
                    );
    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("put", "FtpPutFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpPutFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("put", "%sFtpPutFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
rename_file(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszTemp;
    LPTSTR pszOldFilename;
    LPTSTR pszNewFilename;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Old name: "), &pszTemp)) {
            return FALSE;
        }

        pszOldFilename = lstrdup(pszTemp);

        if (pszOldFilename == NULL) {
            return FALSE;
        }
    } else {
        pszOldFilename = argv[1];
    }

    if (argc < 3) {
        if (!Prompt(TEXT("New name: "), &pszNewFilename)) {
            return FALSE;
        }
    } else {
        pszNewFilename = argv[2];
    }

    ok = FtpRenameFile(hFtpSession,
                       pszOldFilename,
                       pszNewFilename
                       );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("rename_file", "FtpRenameFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpRenameFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("rename_file", "%sFtpRenameFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    if (argc < 2) {
        LocalFree(pszOldFilename);
    }

    return ok;
}

BOOL
del(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszFilename;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("File name: "), &pszFilename)) {
            return FALSE;
        }
    } else {
        pszFilename = argv[1];
    }

    ok = FtpDeleteFile(hFtpSession, pszFilename);

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("del", "FtpDeleteFile()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpDeleteFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("del",
                    "%sFtpDeleteFile()",
                    AsyncMode ? "async " : ""
                    );
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
mkdir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszDirname;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Directory name: "), &pszDirname)) {
            return FALSE;
        }
    } else {
        pszDirname = argv[1];
    }

    ok = FtpCreateDirectory(hFtpSession,
                            pszDirname
                            );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("mkdir", "FtpCreateDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpCreateDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("mkdir", "%sFtpCreateDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
chdir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszDirname;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Directory name: "), &pszDirname)) {
            return FALSE;
        }
    } else {
        pszDirname = argv[1];
    }

    ok = FtpSetCurrentDirectory(hFtpSession,
                                pszDirname
                                );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("chdir", "FtpSetCurrentDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpSetCurrentDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("chdir", "%sFtpSetCurrentDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
rmdir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    LPTSTR pszDirname;
    BOOL ok;

    if (argc < 2) {
        if (!Prompt(TEXT("Directory name: "), &pszDirname)) {
            return FALSE;
        }
    } else {
        pszDirname = argv[1];
    }

    ok = FtpRemoveDirectory(hFtpSession,
                            pszDirname
                            );

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("rmdir", "FtpRemoveDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpRemoveDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
        }
    }

    if (!ok) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("rmdir", "%sFtpRemoveDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
    }

    return ok;
}

BOOL
dir(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    BOOL ok;
    WIN32_FIND_DATA ffd;
    SYSTEMTIME st;
    LPTSTR pszFileSpec;
    TCHAR EmptyExpression[] = "";
    HINTERNET hFind;
    HINTERNET hPrevious;
    static LPSTR month[] = {
        "",
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    };

    if (argc < 2) {
        pszFileSpec = EmptyExpression;
    } else {
        pszFileSpec = argv[1];
    }

    hFind = FtpFindFirstFileA(hFtpSession,
                              pszFileSpec,
                              &ffd,
                              CacheFlags,   // dwFlags
                              FTPCAT_FIND_CONTEXT
                              );

    if (AsyncMode && (hFind == NULL)) {
        if (GetLastError() == ERROR_IO_PENDING) {
            if (Verbose) {
                printf("waiting for async FtpFindFirstFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            hFind = (HINTERNET)AsyncResult;
            if (hFind == NULL) {
                SetLastError(AsyncError);
            }
        }
    }

    if (hFind == NULL) {
        print_error("dir", "%sFtpFindFirstFile()", AsyncMode ? "async " : "");
        return FALSE;
    }

    hPrevious = hCancel;
    hCancel = hFind;

    get_response(hFind);
    putchar('\n');

    ok = TRUE;
    while (ok) {
        if (!FileTimeToSystemTime(&ffd.ftLastWriteTime, &st)) {
            printf("| ftLastWriteTime = ERROR\n");
        }

        printf("%02d-%s-%04d %02d:%02d:%02d  %15d bytes %-s%-s%-s%-s%-s%-s %s\n",
               st.wDay,
               month[st.wMonth],
               st.wYear,
               st.wHour,
               st.wMinute,
               st.wSecond,
               ffd.nFileSizeLow,
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)   ? "Archive   " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)    ? "Normal    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)    ? "System    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)    ? "Hidden    " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)  ? "ReadOnly  " : "",
               (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? "Directory " : "",
               ffd.cFileName
               );

        if (UseQueryData) {

            DWORD error;
            DWORD avail;

            ok = InternetQueryDataAvailable(hFind, &avail, 0, 0);
            if (!ok) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetQueryDataAvailable()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    SetLastError(AsyncError);
                }
            }
            if (!ok) {
                print_error("dir", "%sSYNC InternetQueryDataAvailable()", AsyncMode ? "A" : "");
                break;
            }

            if (Verbose) {
                printf("InternetQueryDataAvailable() returns %d available\n", avail);
            }

            if (avail == 0) {
                break;
            }
        }

        ok = InternetFindNextFile(hFind, &ffd);

        if (!ok && AsyncMode) {
            if (GetLastError() == ERROR_IO_PENDING) {
                if (Verbose) {
                    printf("waiting for async InternetFindNextFile()...\n");
                }
                WaitForSingleObject(AsyncEvent, INFINITE);
                ok = (BOOL)AsyncResult;
                if (!ok) {
                    SetLastError(AsyncError);
                }
            }
        }

        if (!ok) {
            if (GetLastError() != ERROR_NO_MORE_FILES) {
                print_error("dir", "%sInternetFindNextFile()", AsyncMode ? "async " : "");
                break;
            }
        }
    }

    putchar('\n');

    close_handle(hFind);

    hCancel = hPrevious;

    return ok;
}

BOOL
pwd(
    IN HINTERNET hFtpSession,
    IN int argc,
    IN PTCHAR argv[]
    )
{
    BOOL ok;
    char* buf;
    DWORD len;

    len = 0;
    ok = FtpGetCurrentDirectory(hFtpSession, NULL, &len);

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("pwd", "async FtpGetCurrentDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpGetCurrentDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
            SetLastError(AsyncError);
        }
    }

    if (ok) {
        printf("error: FtpGetCurrentDirectory() w/ no buffer returns ok\n");
        return FALSE;
    } else if (Verbose) {
        printf("FtpGetCurrentDirectory() returns %d, %d bytes in cur dir\n",
               GetLastError(),
               len
               );
    }

    buf = (char*)malloc(len);

    ok = FtpGetCurrentDirectory(hFtpSession, buf, &len);

    if (AsyncMode && !ok) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("pwd", "async FtpGetCurrentDirectory()");
        } else {
            if (Verbose) {
                printf("waiting for async FtpGetCurrentDirectory()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            ok = (BOOL)AsyncResult;
            SetLastError(AsyncError);
        }
    }

    if (!ok) {
        print_error("pwd", "%sFtpGetCurrentDirectory()", AsyncMode ? "async " : "");
    } else {
        get_response(hFtpSession);
        lprintf(TEXT("Current directory: %s\n"), buf);
    }

    free(buf);

    return ok;
}

BOOL help(IN HINTERNET hFtpSession, IN int argc, IN PTCHAR argv[]) {

    int i;

    for (i = 0; Commands[i].pszCommand != NULL; ++i) {
        lprintf(TEXT("\t%s\t%s\n"),
                Commands[i].pszCommand,
                Commands[i].HelpText
                );
    }

    return TRUE;
}

#if DBG

BOOL CheckHandles(HINTERNET hFtpSession, int argc, PTCHAR argv[]) {
    printf("handle count = %d\n", GetProcessHandleCount());
    return TRUE;
}

#endif

BOOL lcd(HINTERNET hInternet, int argc, char** argv) {

    char curDir[MAX_PATH + 1];
    DWORD curDirLen;

    if (argc == 2) {
        if (!SetCurrentDirectory(argv[1])) {
            print_error("lcd", "SetCurrentDirectory()");
            return FALSE;
        }
    } else if (argc != 1) {
        printf("error: lcd: incorrect number of arguments\n");
        return FALSE;
    }

    curDirLen = sizeof(curDir);
    if (GetCurrentDirectory(curDirLen, curDir)) {
        printf("Current directory is %s\n", curDir);
        return TRUE;
    } else {
        print_error("lcd", "GetCurrentDirectory()");
        return FALSE;
    }
}

BOOL rb(HINTERNET hInternet, int argc, char** argv) {

    DWORD value;
    DWORD valueLength;

    if (argc > 1) {
        value = atoi(argv[1]);
        if (!InternetSetOption(hInternet,
                               INTERNET_OPTION_READ_BUFFER_SIZE,
                               (LPVOID)&value,
                               sizeof(DWORD)
                               )) {
            print_error("rb", "InternetSetOption()");
            return FALSE;
        }
    }
    valueLength = sizeof(value);
    if (InternetQueryOption(hInternet,
                            INTERNET_OPTION_READ_BUFFER_SIZE,
                            (LPVOID)&value,
                            &valueLength
                            )) {
        printf("Read buffer size = %d bytes\n", value);
        return TRUE;
    } else {
        print_error("rb", "InternetQueryOption()");
        return FALSE;
    }
}

BOOL wb(HINTERNET hInternet, int argc, char** argv) {

    DWORD value;
    DWORD valueLength;

    if (argc > 1) {
        value = atoi(argv[1]);
        if (!InternetSetOption(hInternet,
                               INTERNET_OPTION_WRITE_BUFFER_SIZE,
                               (LPVOID)&value,
                               sizeof(DWORD)
                               )) {
            print_error("wb", "InternetSetOption()");
            return FALSE;
        }
    }
    valueLength = sizeof(value);
    if (InternetQueryOption(hInternet,
                            INTERNET_OPTION_WRITE_BUFFER_SIZE,
                            (LPVOID)&value,
                            &valueLength
                            )) {
        printf("Write buffer size = %d bytes\n", value);
        return TRUE;
    } else {
        print_error("wb", "InternetQueryOption()");
        return FALSE;
    }
}

BOOL toggle_verbose(HINTERNET hInternet, int argc, PTCHAR * argv) {

    static DWORD PreviousVerbose = 0;

    if (Verbose) {
        PreviousVerbose = Verbose;
        Verbose = 0;
    } else {
        Verbose = PreviousVerbose;
        if (Verbose == 0) {
            Verbose = 1;
        }
    }
    printf("Verbose mode is o%s\n", Verbose ? "n" : "ff");
    return TRUE;
}

BOOL toggle_callback(HINTERNET hInternet, int argc, PTCHAR * argv) {

    INTERNET_STATUS_CALLBACK callback;

    if (PreviousCallback != NULL && PreviousCallback != my_callback) {
        printf("error: PreviousCallback %x not recognized\n", PreviousCallback);
    } else {
        PreviousCallback = InternetSetStatusCallback(hInternet, PreviousCallback);
        if (PreviousCallback == INTERNET_INVALID_STATUS_CALLBACK) {
            print_error("toggle_callback", "InternetSetStatusCallback()");
        } else if (PreviousCallback != NULL && PreviousCallback != my_callback) {
            printf("error: PreviousCallback %x not recognized\n", PreviousCallback);
        } else if (Verbose) {
            printf("callback toggled Ok\n");
        }
    }

    printf("Verbose mode is o%s\n", Verbose ? "n" : "ff");
    return TRUE;
}

BOOL dbgbreak(HINTERNET hInternet, int argc, PTCHAR * argv) {
    DebugBreak();
    return TRUE;
}

BOOL set_type(HINTERNET hInternet, int argc, PTCHAR * argv) {
    return TRUE;
}

BOOL open_file(HINTERNET hInternet, int argc, PTCHAR * argv) {

    HINTERNET hFile;
    BOOL bOk;

    if (argc < 2) {
        printf("error: required filename missing\n");
        return FALSE;
    }
    hFile = FtpOpenFile(hInternet,
                        argv[1],
                        GENERIC_READ,
                        0,
                        AsyncMode ? FTPCAT_OPEN_CONTEXT : 0
                        );
    if (AsyncMode && !hFile) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("open_file", "async FtpOpenFile()");
            return FALSE;
        }
        if (Verbose) {
            printf("waiting for async FtpOpenFile()...\n");
        }
        WaitForSingleObject(AsyncEvent, INFINITE);
        hFile = (HINTERNET)AsyncResult;
        SetLastError(AsyncError);
    }
    if (!hFile) {
        print_error("open_file", "%sFtpOpenFile()", AsyncMode ? "async " : "");
    } else {
        get_response(hInternet);
        printf("returned handle is %#x\n", hFile);
    }
    return hFile != NULL;
}

BOOL close_file(HINTERNET hInternet, int argc, PTCHAR * argv) {

    HINTERNET hFile;
    BOOL bOk;

    if (argc < 2) {
        printf("error: required handle missing\n");
        return FALSE;
    }
    hFile = (HINTERNET)strtol(argv[1], NULL, 0);
    bOk = InternetCloseHandle(hFile);
    if (!bOk) {
        print_error("close_file", "InternetCloseHandle()");
    } else if (Verbose) {
        printf("handle %#x closed OK\n", hFile);
    }
    return bOk;
}

BOOL read_file(HINTERNET hInternet, int argc, PTCHAR * argv) {
    return TRUE;
}

BOOL write_file(HINTERNET hInternet, int argc, PTCHAR * argv) {
    return TRUE;
}

BOOL
DispatchCommand(
    IN LPTSTR pszCommand,
    IN HINTERNET hFtpSession
    )
{
    COMMAND_ENTRY *pce;
    PTCHAR ArgV[MAX_ARGV];
    int index;
    int state;

    if (*pszCommand == TEXT('!')) {

        LPSTR shellPath;

        shellPath = getenv("COMSPEC");
        if (shellPath == NULL) {
            printf("error: COMSPEC environment variable not set\n");
            return FALSE;
        }

        ++pszCommand;
        while (isspace(*pszCommand)) {
            ++pszCommand;
        }

        if (*pszCommand != TEXT('\0')) {
            _spawnlp(_P_WAIT, shellPath, "/C", pszCommand, NULL);
        } else {
            printf("\nSpawning command interpreter. Type \"exit\" to return to FTP\n\n");
            _spawnlp(_P_WAIT, shellPath, "/K", NULL);
            putchar('\n');
        }
        return TRUE;
    }

    state = 0;
    index = 0;

    while (*pszCommand) {
        switch (state) {
        case 0:
            if (!isspace(*pszCommand)) {
                if (*pszCommand == '"') {
                    state = 2;
                } else {
                    state = 1;
                }
                ArgV[index++] = (state == 2) ? (pszCommand + 1) : pszCommand;
            }
            break;

        case 1:
            if (isspace(*pszCommand)) {
                *pszCommand = '\0';
                state = 0;
            }
            break;

        case 2:
            if (*pszCommand == '"') {
                *pszCommand = '\0';
                state = 0;
            }
            break;
        }
        ++pszCommand;
    }

    if (index == 0) {
        return FALSE;
    }

    for (pce = Commands; pce->pszCommand != NULL; pce++) {
        if (lstrcmpi(pce->pszCommand, ArgV[0]) == 0) {
            return pce->fn(hFtpSession, index, ArgV);
        }
    }

    if (!lstrcmpi(ArgV[0], "q")) {
        return quit(hFtpSession, index, ArgV);
    }

    printf("error: unrecognized command: \"%s\"\n", ArgV[0]);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\test\ftpclose\ftpclose.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpclose.c

Abstract:

    Tests FTP open/read/close. Main purpose is to make sure we do the right
    thing with ABOR

Author:

    Richard L Firth (rfirth) 11-Oct-1995

Revision History:

    11-Oct-1995 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

#define DEFAULT_BUFFER_SIZE 1024

void _CRTAPI1 main(int, char**);
void usage(void);

BOOL Verbose = FALSE;

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet;
    HINTERNET hFtpSession;
    HINTERNET hFile;
    LPSTR server = NULL;
    LPSTR username = NULL;
    LPSTR password = NULL;
    LPSTR filename = NULL;
    LPBYTE buffer;
    int buflen = DEFAULT_BUFFER_SIZE;
    DWORD bytesRead;
    DWORD totalBytes;
    DWORD closeAfter = 0xffffffff;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    BOOL expectingProxyServer = FALSE;
    LPSTR proxyServer = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'a':
                ++*argv;
                if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxyServer = TRUE;
                    }
                } else if (**argv == 'l') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else {
                    if (**argv) {
                        printf("error: unrecognised access type: '%c'\n", **argv);
                    } else {
                        printf("error: missing access type\n");
                    }
                    usage();
                }
                break;

            case 'b':
                buflen = atoi(++*argv);
                break;

            case 'f':
                filename = ++*argv;
                break;

            case 'n':
                closeAfter = (DWORD)atoi(++*argv);
                break;

            case 'p':
                password = ++*argv;
                break;

            case 's':
                server = ++*argv;
                break;

            case 'u':
                username = ++*argv;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxyServer) {
            proxyServer = *argv;
            expectingProxyServer = FALSE;
        }
    }

    if (!server) {
        printf("error: must supply server name\n");
        usage();
    }

    if (!filename) {
        printf("error: must supply file name\n");
        usage();
    }

    hInternet = InternetOpen("ftpclose",
                             accessMethod,
                             proxyServer,
                             NULL,
                             0);
    if (!hInternet) {
        printf("error: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    } else if (Verbose) {
        printf("opened Internet handle %x\n", hInternet);
    }

    hFtpSession = InternetConnect(hInternet,
                                  server,
                                  INTERNET_INVALID_PORT_NUMBER,
                                  username,
                                  password,
                                  INTERNET_SERVICE_FTP,
                                  0,
                                  0
                                  );
    if (!hFtpSession) {
        printf("error: InternetConnect() returns %d\n", GetLastError());
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP connect handle %x\n", hFtpSession);
    }

    hFile = FtpOpenFile(hFtpSession,
                        filename,
                        GENERIC_READ,
                        FTP_TRANSFER_TYPE_BINARY,
                        0,
                        0
                        );
    if (!hFile) {
        printf("error: FtpOpenFile(%s) returns %d\n", filename, GetLastError());
        InternetCloseHandle(hFtpSession);
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP File handle %x\n", hFile);
    }

    buffer = (LPBYTE)malloc(buflen);
    if (!buffer) {
        printf("error: failed to allocate %u bytes\n", buflen);
        InternetCloseHandle(hFile);
        InternetCloseHandle(hFtpSession);
        InternetCloseHandle(hInternet);
        exit(1);
    }

    if (closeAfter == 0) {
        if (Verbose) {
            printf("not reading file (close after 0)\n");
        }
    } else {
        if (Verbose) {
            printf("reading file %s", filename);
            if (closeAfter != 0xffffffff) {
                printf(" closing after %d bytes", closeAfter);
            }
            putchar('\n');
        }

        totalBytes = 0;
        while (InternetReadFile(hFile, buffer, buflen, &bytesRead)) {
            if (Verbose) {
                printf("read %d bytes\n", bytesRead);
            }
            if (bytesRead == 0) {
                break;
            }
            totalBytes += bytesRead;
            if (totalBytes >= closeAfter) {
                break;
            }
        }

        if (GetLastError() != ERROR_SUCCESS) {
            printf("error: InternetReadFile() returns %d\n", GetLastError());
            InternetCloseHandle(hFile);
            InternetCloseHandle(hFtpSession);
            InternetCloseHandle(hInternet);
            exit(1);
        }

        if (Verbose) {
            printf("%d bytes read\n", totalBytes);
        }
    }

    InternetCloseHandle(hFile);
    InternetCloseHandle(hFtpSession);
    InternetCloseHandle(hInternet);

    exit(0);
}

void usage() {
    printf("\n"
           "usage: ftpclose [-a{l|p}] [-b#] [-v] [-n#] <-sserver> [-uuser] [-ppassword]\n"
           "                <-ffile>\n"
           "\n"
           "where:  -a = Access mode: l = local; p = proxy\n"
           "        -b = Buffer size. Default is %d\n"
           "        -n = Number of bytes to read before closing file. Default is all\n"
           "        -p = Password (with -u)\n"
           "        -s = FTP server\n"
           "        -u = User name\n"
           "        -v = Verbose mode\n",
           DEFAULT_BUFFER_SIZE
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\test\ftpszcls\ftpszcls.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpszcls.cxx

Abstract:

    Tests FTP abort during FtpGetFileSize(). Ensure we overcome IE5 bug #71219

Author:

    Richard L Firth (rfirth) 09-Feb-1999

Revision History:

    09-Feb-1999 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))
#define SESSION_CONTEXT 0x01010101
#define FILE_CONTEXT    0x02020202

void _CRTAPI1 main(int, char**);
void usage(void);
VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    );

BOOL Verbose = FALSE;

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET hInternet;
    HINTERNET hFtpSession;
    HINTERNET hFile;
    char server[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    char username[INTERNET_MAX_USER_NAME_LENGTH];
    char password[INTERNET_MAX_PASSWORD_LENGTH];
    LPSTR filename = NULL;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    BOOL expectingProxyServer = FALSE;
    LPSTR proxyServer = NULL;
    LPSTR pszUrl = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();

            case 'a':
                ++*argv;
                if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                } else if (**argv == 'd') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else {
                    if (**argv) {
                        printf("error: unrecognised access type: '%c'\n", **argv);
                    } else {
                        printf("error: missing access type\n");
                    }
                    usage();
                }
                break;

            case 'v':
                Verbose = TRUE;
                break;

            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxyServer) {
            proxyServer = *argv;
            expectingProxyServer = FALSE;
        } else if (!pszUrl) {
            pszUrl = *argv;
        }
    }

    if (!pszUrl) {
        printf("error: must supply file URL\n");
        usage();
    }

    URL_COMPONENTS urlbits;

    memset(&urlbits, 0, sizeof(urlbits));
    urlbits.dwStructSize = sizeof(urlbits);
    urlbits.lpszHostName = (LPSTR)server;
    urlbits.dwHostNameLength = (DWORD)-1;
    urlbits.lpszUserName = (LPSTR)username;
    urlbits.dwUserNameLength = (DWORD)-1;
    urlbits.lpszPassword = (LPSTR)password;
    urlbits.dwPasswordLength = (DWORD)-1;
    urlbits.dwUrlPathLength = (DWORD)-1;

    BOOL ok;

    ok = InternetCrackUrl(pszUrl, (DWORD)-1, 0, &urlbits);
    if (!ok) {
        print_error("ftpszcls()", "InternetCrackUrl()");
        exit(1);
    }

    hInternet = InternetOpen("ftpszcls",
                             accessMethod,
                             proxyServer,
                             NULL,
                             0);
    if (!hInternet) {
        print_error("ftpszcls()", "InternetOpen()");
        exit(1);
    } else if (Verbose) {
        printf("opened Internet handle %#x\n", hInternet);
    }

    hFtpSession = InternetConnect(hInternet,
                                  server,
                                  INTERNET_INVALID_PORT_NUMBER,
                                  username,
                                  password,
                                  INTERNET_SERVICE_FTP,
                                  0,
                                  SESSION_CONTEXT
                                  );
    if (!hFtpSession) {
        print_error("ftpszcls()", "InternetConnect()");
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP connect handle %#x\n", hFtpSession);
    }

    filename = urlbits.lpszUrlPath;

    hFile = FtpOpenFile(hFtpSession,
                        filename,
                        GENERIC_READ,
                        FTP_TRANSFER_TYPE_BINARY,
                        FILE_CONTEXT
                        );
    if (!hFile) {
        print_error("ftpszcls()", "FtpOpenFile(%s)", filename);
        InternetCloseHandle(hFtpSession);
        InternetCloseHandle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("opened FTP File handle %#x\n", hFile);
    }

    InternetSetStatusCallback(hInternet, my_callback);

    DWORD dwFileSizeLow, dwFileSizeHigh;

    //
    // force TLS handle value to be not FTP file handle object
    //

    HINTERNET hInternet2;

    hInternet2 = InternetOpen("ftpszcls",
                              INTERNET_OPEN_TYPE_PRECONFIG,
                              NULL,
                              NULL,
                              0
                              );
    InternetCloseHandle(hInternet2);

    //
    // get the size of the FTP file. Buggy wininet now has TLS handle and
    // mapped handle values set to hInternet2
    //

    dwFileSizeLow = FtpGetFileSize(hFile, &dwFileSizeHigh);

    if (dwFileSizeLow == (DWORD)-1) {
        print_error("ftpszcls()", "FtpGetFileSize()");
        exit(1);
    } else if (Verbose) {
        printf("size of \"%s\" is %d\n", pszUrl, dwFileSizeLow);
    }

    InternetCloseHandle(hFile);
    InternetCloseHandle(hFtpSession);
    InternetCloseHandle(hInternet);

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("\n"
           "usage: ftpszcls [-a{d|p}] [-v] fileURL\n"
           "\n"
           "where:  -a = Access mode: d = direct; p = proxy. Default is pre-config\n"
           "        -v = Verbose mode\n"
           );
    exit(1);
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        //hCancel = *(LPHINTERNET)Info;
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        //AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        //AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                Handle,
                Context,
                (Context == SESSION_CONTEXT) ? "Session"
                : (Context == FILE_CONTEXT) ? "File"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf((LPSTR)Info);
            }
        }
        putchar('\n');
    }
    //if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
    //    get_response(Handle);
    //    if (AsyncMode) {
    //        SetEvent(AsyncEvent);
    //    } else {
    //        printf("error: INTERNET_STATUS_REQUEST_COMPLETE returned. Not async\n");
    //    }
    //}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\test\ftpcat\ftpcat.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftpcat.c

Abstract:

    Windows Internet API FTP test program

    Provides the same functionality as a cut-down version of the venerable
    (console-mode) ftp program

Author:

    Richard L Firth (rfirth) 05-Jun-1995

Environment:

    Win32 user-mode console app

Revision History:

    05-Jun-1995 rfirth
        Created

--*/

#include "ftpcatp.h"

#undef tolower

//
// macros
//

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// manifests
//

#define MAX_COMMAND_LENGTH 100

//
// external data
//

extern BOOL fQuit;
extern DWORD CacheFlags;

//
// data
//

DWORD Verbose = 0;
INTERNET_STATUS_CALLBACK PreviousCallback;
HINTERNET hCancel = NULL;
BOOL AsyncMode = FALSE;
BOOL fOffline = FALSE;
DWORD Context = 0;
DWORD AsyncResult = 0;
DWORD AsyncError = 0;
HANDLE AsyncEvent = NULL;
BOOL UseQueryData = FALSE;

#if DBG
BOOL CheckHandleLeak = FALSE;
#endif

//
// external functions
//

extern BOOL DispatchCommand(LPCTSTR, HANDLE);

//
// prototypes
//

void __cdecl main(int, char**);
void __cdecl control_c_handler(int);
void usage(void);
BOOL Prompt(LPCTSTR, LPTSTR*);

//
// functions
//

void __cdecl main(int argc, char** argv) {

    LPTSTR ptszSite = NULL;
    LPTSTR ptszUser = NULL;
    LPTSTR ptszPass = NULL;
    HINTERNET hInternet;
    HINTERNET hFtpSession;
    DWORD dwLocalAccessFlags;
    LPTSTR lpszCmd;
    DWORD lastError;
    DWORD bufLen;
    BOOL enableCallbacks = FALSE;
    DWORD flags = 0;
    DWORD accessMethod = INTERNET_OPEN_TYPE_PRECONFIG;
    BOOL expectingProxy = FALSE;
    LPSTR proxyServer = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'a':
                ++*argv;
                if ((**argv == 'l') || (**argv == 'd')) {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxy = TRUE;
                    }
                } else {
                    printf("error: unrecognised access type: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'c':
                enableCallbacks = TRUE;
                break;

#if DBG
            case 'l':
                CheckHandleLeak = TRUE;
                break;
#endif

            case 'n':
                CacheFlags |= INTERNET_FLAG_DONT_CACHE;
                break;

            case 'p':
                flags |= INTERNET_FLAG_PASSIVE;
                break;

            case 'q':
                UseQueryData = TRUE;
                break;

            case 'v':
                if (*++*argv == '\0') {
                    Verbose = 1;
                } else {
                    Verbose = atoi(*argv);
                }
                break;

            case 'x':
                Context = (DWORD)atoi(++*argv);
                break;

            case 'y':
                AsyncMode = TRUE;
                break;
            case 'o':
                fOffline = TRUE;
                break;
            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxy) {
            proxyServer = *argv;
            expectingProxy = FALSE;
        } else if (ptszSite == NULL) {
            ptszSite = *argv;
        } else if (ptszUser == NULL) {
            ptszUser = *argv;
        } else if (ptszPass == NULL) {
            ptszPass = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (ptszSite == NULL) {
        printf("error: required server name argument missing\n");
        exit(1);
    }

    if (AsyncMode) {

        //
        // create auto-reset, initially unsignalled event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (AsyncEvent == NULL) {
            print_error("ftpcat", "CreateEvent()");
            exit(1);
        }
    }

    //
    // add a control-c handler
    //

    signal(SIGINT, control_c_handler);

#if DBG
    if (CheckHandleLeak) {
        printf("initial handle count = %d\n", GetProcessHandleCount());
    }
#endif

#if DBG
    if (CheckHandleLeak && Verbose) {
        printf("Initial handle count = %d\n", GetProcessHandleCount());
    }
#endif

    if (Verbose) {
        printf("calling InternetOpen()...\n");
    }
    hInternet = InternetOpen("ftpcat",
                             accessMethod,
                             proxyServer,
                             NULL,
                             AsyncMode ? INTERNET_FLAG_ASYNC : 0
                             | (fOffline ? INTERNET_FLAG_OFFLINE : 0)
                             );
    if (hInternet == NULL) {
        print_error("ftpcat", "InternetOpen()");
        exit(1);
    } else if (Verbose) {
        printf("Internet handle = %x\n", hInternet);
        hCancel = hInternet;
    }

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetOpen(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    if (enableCallbacks) {

        //
        // let's have a status callback
        //
        // Note that callbacks can be set even before we have opened a handle
        // to the internet/gateway
        //

        PreviousCallback = InternetSetStatusCallback(hInternet, my_callback);
        if (PreviousCallback == INTERNET_INVALID_STATUS_CALLBACK) {
            print_error("ftpcat", "InternetSetStatusCallback()");
        } else if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    if (Verbose) {
        printf("calling InternetConnect()...\n");
    }
    hFtpSession = InternetConnect(hInternet,
                                  ptszSite,
                                  0,
                                  ptszUser,
                                  ptszPass,
                                  INTERNET_SERVICE_FTP,
                                  flags,
                                  FTPCAT_CONNECT_CONTEXT
                                  );
    if ((hFtpSession == NULL) && AsyncMode) {
        if (Verbose) {
            printf("waiting for async InternetConnect()...\n");
        }
        WaitForSingleObject(AsyncEvent, INFINITE);
        hFtpSession = (HINTERNET)AsyncResult;
        SetLastError(AsyncError);
    }
    if (hFtpSession == NULL) {
        if (AsyncMode) {
            SetLastError(AsyncError);
        }
        print_error("ftpcat",
                    "%sInternetConnect()",
                    AsyncMode ? "async " : ""
                    );
        get_response(hFtpSession);
        close_handle(hInternet);
        exit(1);
    } else if (Verbose) {
        printf("FTP session handle = %x\n", hFtpSession);
    }

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetConnect(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    printf("Connected to %s.\n", ptszSite);

    get_response(hFtpSession);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetGetLastResponseInfo(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    //
    // set the (top level) cancellable handle
    //

    hCancel = hFtpSession;

    while (!fQuit) {
        if (Prompt(TEXT("ftp> "), &lpszCmd)) {
            DispatchCommand(lpszCmd, hFtpSession);
        }
    }

    if (Verbose) {
        printf("Closing %x\n", hFtpSession);
    }

    close_handle(hFtpSession);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetCloseHandle(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    get_response(hFtpSession);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetGetLastResponseInfo(): handle count = %d\n", GetProcessHandleCount());
    }
#endif

    close_handle(hInternet);

#if DBG
    if (CheckHandleLeak) {
        printf("after InternetCloseHandle(): handle count = %d\n", GetProcessHandleCount());
    }

    if (CheckHandleLeak && Verbose) {
        printf("Final handle count = %d\n", GetProcessHandleCount());
    }
#endif

    exit(0);
}

void __cdecl control_c_handler(int sig) {

    //
    // disable signals
    //

    signal(SIGINT, SIG_IGN);

    //
    // cancel the current operation
    //

    if (Verbose) {
        printf("control-c handler\n");
    }
    if (hCancel == NULL) {
        if (Verbose) {
            printf("control-c handler: no Internet operation in progress\n");
        }
    } else {
        close_handle(hCancel);
    }

    //
    // re-enable this signal handler
    //

    signal(SIGINT, control_c_handler);
}

void usage() {
    printf("\n"
           "usage: ftpcat [-a{g{[ ]server}|l|d|p}] [-c] [-d] [-n] [-p] [-v] [-x#] [-y]\n"
           "              {servername} [username] [password]\n"
           "\n"
           "where: -a = access type. Default is pre-configured:\n"
           "            g = gateway access via <gateway server>\n"
           "            l = local internet access\n"
           "            d = local internet access\n"
           "            p = CERN proxy access\n"
           "       -c = Enable callbacks\n"
           "       -n = Don't cache\n"
           "       -p = Use Passive transfer mode\n"
           "       -v = Verbose mode. Default is off\n"
           "       -x = Set context value\n"
           "       -y = Asynchronous APIs\n"
           );
    exit(1);
}

BOOL
Prompt(
    IN LPCTSTR pszPrompt,
    OUT LPTSTR* ppszCommand
    )
{
    static CHAR Command[MAX_COMMAND_LENGTH + sizeof(TEXT('\0'))];

#ifdef UNICODE

    static WCHAR wchBuf[MAX_COMMAND_LENGTH + sizeof(L'\0')];

#endif

    DWORD dwBytesRead;
    PTCHAR pch;

    lprintf(TEXT("%s"), pszPrompt);

    if (!ReadFile(GetStdHandle(STD_INPUT_HANDLE),
                  Command,
                  MAX_COMMAND_LENGTH * sizeof(CHAR),
                  &dwBytesRead,
                  NULL)) {
        return FALSE;
    }

    Command[dwBytesRead] = '\0';

#ifdef UNICODE

    wsprintf(wchBuf, L"%S", Command);
    *ppszCommand = wchBuf;

#else

    *ppszCommand = Command;

#endif

    pch = lstrchr(*ppszCommand, TEXT('\r'));

    if (pch) {
        *pch = TEXT('\0');
    }

    return TRUE;
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        hCancel = *(LPHINTERNET)Info;
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                Handle,
                Context,
                (Context == FTPCAT_CONNECT_CONTEXT) ? "Connect"
                : (Context == FTPCAT_FIND_CONTEXT) ? "Find"
                : (Context == FTPCAT_FILE_CONTEXT) ? "File"
                : (Context == FTPCAT_GET_CONTEXT) ? "Get"
                : (Context == FTPCAT_PUT_CONTEXT) ? "Put"
                : (Context == FTPCAT_COMMAND_CONTEXT) ? "Command"
                : (Context == FTPCAT_OPEN_CONTEXT) ? "Open"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else {
                printf(Info);
            }
        }
        putchar('\n');
    }
    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        get_response(Handle);
        if (AsyncMode) {
            SetEvent(AsyncEvent);
        } else {
            printf("error: INTERNET_STATUS_REQUEST_COMPLETE returned. Not async\n");
        }
    }
}

void close_handle(HINTERNET handle) {
    if (Verbose) {
        printf("closing handle %#x\n", handle);
    }
    if (!InternetCloseHandle(handle)) {
        print_error("close_handle", "InternetCloseHandle(%x)", handle);
    }
}

#if DBG

DWORD GetProcessHandleCount() {

    DWORD error;
    DWORD count;
    DWORD countSize;

    countSize = sizeof(count);
    if (!InternetQueryOption(NULL,
                             INTERNET_OPTION_GET_HANDLE_COUNT,
                             &count,
                             &countSize
                             )) {
        print_error("GetProcessHandleCount", "InternetQueryOption()");
        return 0;
    }
    return count;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\test\ftpcat\error.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    error.c

Abstract:

    Wininet error handlers

Author:

    Richard L Firth (rfirth) 03-Nov-1995

Revision History:

    03-Nov-1995 rfirth
        Created

--*/

#include "ftpcatp.h"

//
// data
//

BOOL NoAlerts = TRUE;

//
// external data
//

extern BOOL Verbose;

//
// private prototypes
//

LPSTR get_error_string(DWORD);

//
// functions
//

void print_error(char* func, char* format, ...) {

    va_list argptr;
    char buf[256];
    DWORD error;

    error = GetLastError();
    va_start(argptr, format);
    vsprintf(buf, format, argptr);
    printf("error: %s: %s returns %d [%s]\n", func, buf, error, map_error(error));
    va_end(argptr);
    if (error == ERROR_INTERNET_EXTENDED_ERROR) {
        get_last_internet_error();
    }
}

#define ERROR_CASE(error)  case error: return # error

char* map_error(DWORD error) {
    switch (error) {

    //
    // Windows base errors
    //

    ERROR_CASE(ERROR_SUCCESS);
    ERROR_CASE(ERROR_INVALID_FUNCTION);
    ERROR_CASE(ERROR_FILE_NOT_FOUND);
    ERROR_CASE(ERROR_PATH_NOT_FOUND);
    ERROR_CASE(ERROR_ACCESS_DENIED);
    ERROR_CASE(ERROR_INVALID_HANDLE);
    ERROR_CASE(ERROR_NOT_ENOUGH_MEMORY);
    ERROR_CASE(ERROR_NO_MORE_FILES);
    ERROR_CASE(ERROR_INVALID_PASSWORD);
    ERROR_CASE(ERROR_INVALID_PARAMETER);
    ERROR_CASE(ERROR_BUFFER_OVERFLOW);
    ERROR_CASE(ERROR_NO_MORE_SEARCH_HANDLES);
    ERROR_CASE(ERROR_INVALID_TARGET_HANDLE);
    ERROR_CASE(ERROR_CALL_NOT_IMPLEMENTED);
    ERROR_CASE(ERROR_INSUFFICIENT_BUFFER);
    ERROR_CASE(ERROR_INVALID_NAME);
    ERROR_CASE(ERROR_INVALID_LEVEL);
    ERROR_CASE(ERROR_BAD_PATHNAME);
    ERROR_CASE(ERROR_BUSY);
    ERROR_CASE(ERROR_ALREADY_EXISTS);
    ERROR_CASE(ERROR_FILENAME_EXCED_RANGE);
    ERROR_CASE(ERROR_MORE_DATA);
    ERROR_CASE(ERROR_NO_MORE_ITEMS);
    ERROR_CASE(ERROR_INVALID_ADDRESS);
    ERROR_CASE(ERROR_OPERATION_ABORTED);
    ERROR_CASE(ERROR_IO_PENDING);
    ERROR_CASE(RPC_S_INVALID_STRING_BINDING);
    ERROR_CASE(RPC_S_WRONG_KIND_OF_BINDING);
    ERROR_CASE(RPC_S_INVALID_BINDING);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_SUPPORTED);
    ERROR_CASE(RPC_S_INVALID_RPC_PROTSEQ);
    ERROR_CASE(RPC_S_INVALID_STRING_UUID);
    ERROR_CASE(RPC_S_INVALID_ENDPOINT_FORMAT);
    ERROR_CASE(RPC_S_INVALID_NET_ADDR);
    ERROR_CASE(RPC_S_NO_ENDPOINT_FOUND);
    ERROR_CASE(RPC_S_INVALID_TIMEOUT);
    ERROR_CASE(RPC_S_OBJECT_NOT_FOUND);
    ERROR_CASE(RPC_S_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_TYPE_ALREADY_REGISTERED);
    ERROR_CASE(RPC_S_ALREADY_LISTENING);
    ERROR_CASE(RPC_S_NO_PROTSEQS_REGISTERED);
    ERROR_CASE(RPC_S_NOT_LISTENING);
    ERROR_CASE(RPC_S_UNKNOWN_MGR_TYPE);
    ERROR_CASE(RPC_S_UNKNOWN_IF);
    ERROR_CASE(RPC_S_NO_BINDINGS);
    ERROR_CASE(RPC_S_NO_PROTSEQS);
    ERROR_CASE(RPC_S_CANT_CREATE_ENDPOINT);
    ERROR_CASE(RPC_S_OUT_OF_RESOURCES);
    ERROR_CASE(RPC_S_SERVER_UNAVAILABLE);
    ERROR_CASE(RPC_S_SERVER_TOO_BUSY);
    ERROR_CASE(RPC_S_INVALID_NETWORK_OPTIONS);
    ERROR_CASE(RPC_S_NO_CALL_ACTIVE);
    ERROR_CASE(RPC_S_CALL_FAILED);
    ERROR_CASE(RPC_S_CALL_FAILED_DNE);
    ERROR_CASE(RPC_S_PROTOCOL_ERROR);
    ERROR_CASE(RPC_S_UNSUPPORTED_TRANS_SYN);
    ERROR_CASE(RPC_S_UNSUPPORTED_TYPE);
    ERROR_CASE(RPC_S_INVALID_TAG);
    ERROR_CASE(RPC_S_INVALID_BOUND);
    ERROR_CASE(RPC_S_NO_ENTRY_NAME);
    ERROR_CASE(RPC_S_INVALID_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    ERROR_CASE(RPC_S_UUID_NO_ADDRESS);
    ERROR_CASE(RPC_S_DUPLICATE_ENDPOINT);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_TYPE);
    ERROR_CASE(RPC_S_MAX_CALLS_TOO_SMALL);
    ERROR_CASE(RPC_S_STRING_TOO_LONG);
    ERROR_CASE(RPC_S_PROTSEQ_NOT_FOUND);
    ERROR_CASE(RPC_S_PROCNUM_OUT_OF_RANGE);
    ERROR_CASE(RPC_S_BINDING_HAS_NO_AUTH);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_SERVICE);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHN_LEVEL);
    ERROR_CASE(RPC_S_INVALID_AUTH_IDENTITY);
    ERROR_CASE(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    ERROR_CASE(EPT_S_INVALID_ENTRY);
    ERROR_CASE(EPT_S_CANT_PERFORM_OP);
    ERROR_CASE(EPT_S_NOT_REGISTERED);
    ERROR_CASE(RPC_S_NOTHING_TO_EXPORT);
    ERROR_CASE(RPC_S_INCOMPLETE_NAME);
    ERROR_CASE(RPC_S_INVALID_VERS_OPTION);
    ERROR_CASE(RPC_S_NO_MORE_MEMBERS);
    ERROR_CASE(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    ERROR_CASE(RPC_S_INTERFACE_NOT_FOUND);
    ERROR_CASE(RPC_S_ENTRY_ALREADY_EXISTS);
    ERROR_CASE(RPC_S_ENTRY_NOT_FOUND);
    ERROR_CASE(RPC_S_NAME_SERVICE_UNAVAILABLE);
    ERROR_CASE(RPC_S_INVALID_NAF_ID);
    ERROR_CASE(RPC_S_CANNOT_SUPPORT);
    ERROR_CASE(RPC_S_NO_CONTEXT_AVAILABLE);
    ERROR_CASE(RPC_S_INTERNAL_ERROR);
    ERROR_CASE(RPC_S_ZERO_DIVIDE);
    ERROR_CASE(RPC_S_ADDRESS_ERROR);
    ERROR_CASE(RPC_S_FP_DIV_ZERO);
    ERROR_CASE(RPC_S_FP_UNDERFLOW);
    ERROR_CASE(RPC_S_FP_OVERFLOW);
    ERROR_CASE(RPC_X_NO_MORE_ENTRIES);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    ERROR_CASE(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    ERROR_CASE(RPC_X_SS_IN_NULL_CONTEXT);
    ERROR_CASE(RPC_X_SS_CONTEXT_DAMAGED);
    ERROR_CASE(RPC_X_SS_HANDLES_MISMATCH);
    ERROR_CASE(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    ERROR_CASE(RPC_X_NULL_REF_POINTER);
    ERROR_CASE(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    ERROR_CASE(RPC_X_BYTE_COUNT_TOO_SMALL);
    ERROR_CASE(RPC_X_BAD_STUB_DATA);


    //
    // WinInet errors
    //

    ERROR_CASE(ERROR_INTERNET_OUT_OF_HANDLES);
    ERROR_CASE(ERROR_INTERNET_TIMEOUT);
    ERROR_CASE(ERROR_INTERNET_EXTENDED_ERROR);
    ERROR_CASE(ERROR_INTERNET_INTERNAL_ERROR);
    ERROR_CASE(ERROR_INTERNET_INVALID_URL);
    ERROR_CASE(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    ERROR_CASE(ERROR_INTERNET_NAME_NOT_RESOLVED);
    ERROR_CASE(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPTION);
    ERROR_CASE(ERROR_INTERNET_BAD_OPTION_LENGTH);
    ERROR_CASE(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    ERROR_CASE(ERROR_INTERNET_SHUTDOWN);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_USER_NAME);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_PASSWORD);
    ERROR_CASE(ERROR_INTERNET_LOGIN_FAILURE);
    ERROR_CASE(ERROR_INTERNET_INVALID_OPERATION);
    ERROR_CASE(ERROR_INTERNET_OPERATION_CANCELLED);
    ERROR_CASE(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    ERROR_CASE(ERROR_INTERNET_NOT_PROXY_REQUEST);
    ERROR_CASE(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    ERROR_CASE(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    ERROR_CASE(ERROR_INTERNET_NO_DIRECT_ACCESS);
    ERROR_CASE(ERROR_INTERNET_CONNECTION_BUSY);
    ERROR_CASE(ERROR_INTERNET_NO_CONTEXT);
    ERROR_CASE(ERROR_INTERNET_NO_CALLBACK);
    ERROR_CASE(ERROR_INTERNET_ASYNC_REQUEST_PENDING);

    ERROR_CASE(ERROR_FTP_TRANSFER_IN_PROGRESS);
    ERROR_CASE(ERROR_FTP_DROPPED);

    ERROR_CASE(ERROR_GOPHER_PROTOCOL_ERROR);
    ERROR_CASE(ERROR_GOPHER_NOT_FILE);
    ERROR_CASE(ERROR_GOPHER_DATA_ERROR);
    ERROR_CASE(ERROR_GOPHER_END_OF_DATA);
    ERROR_CASE(ERROR_GOPHER_INVALID_LOCATOR);
    ERROR_CASE(ERROR_GOPHER_INCORRECT_LOCATOR_TYPE);
    ERROR_CASE(ERROR_GOPHER_NOT_GOPHER_PLUS);
    ERROR_CASE(ERROR_GOPHER_ATTRIBUTE_NOT_FOUND);
    ERROR_CASE(ERROR_GOPHER_UNKNOWN_LOCATOR);

    ERROR_CASE(ERROR_HTTP_HEADER_NOT_FOUND);
    ERROR_CASE(ERROR_HTTP_DOWNLEVEL_SERVER);
    ERROR_CASE(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    ERROR_CASE(ERROR_HTTP_NO_KEEP_ALIVE);


    //
    // Windows sockets errors
    //

    ERROR_CASE(WSAEINTR);
    ERROR_CASE(WSAEBADF);
    ERROR_CASE(WSAEACCES);
    ERROR_CASE(WSAEFAULT);
    ERROR_CASE(WSAEINVAL);
    ERROR_CASE(WSAEMFILE);
    ERROR_CASE(WSAEWOULDBLOCK);
    ERROR_CASE(WSAEINPROGRESS);
    ERROR_CASE(WSAEALREADY);
    ERROR_CASE(WSAENOTSOCK);
    ERROR_CASE(WSAEDESTADDRREQ);
    ERROR_CASE(WSAEMSGSIZE);
    ERROR_CASE(WSAEPROTOTYPE);
    ERROR_CASE(WSAENOPROTOOPT);
    ERROR_CASE(WSAEPROTONOSUPPORT);
    ERROR_CASE(WSAESOCKTNOSUPPORT);
    ERROR_CASE(WSAEOPNOTSUPP);
    ERROR_CASE(WSAEPFNOSUPPORT);
    ERROR_CASE(WSAEAFNOSUPPORT);
    ERROR_CASE(WSAEADDRINUSE);
    ERROR_CASE(WSAEADDRNOTAVAIL);
    ERROR_CASE(WSAENETDOWN);
    ERROR_CASE(WSAENETUNREACH);
    ERROR_CASE(WSAENETRESET);
    ERROR_CASE(WSAECONNABORTED);
    ERROR_CASE(WSAECONNRESET);
    ERROR_CASE(WSAENOBUFS);
    ERROR_CASE(WSAEISCONN);
    ERROR_CASE(WSAENOTCONN);
    ERROR_CASE(WSAESHUTDOWN);
    ERROR_CASE(WSAETOOMANYREFS);
    ERROR_CASE(WSAETIMEDOUT);
    ERROR_CASE(WSAECONNREFUSED);
    ERROR_CASE(WSAELOOP);
    ERROR_CASE(WSAENAMETOOLONG);
    ERROR_CASE(WSAEHOSTDOWN);
    ERROR_CASE(WSAEHOSTUNREACH);
    ERROR_CASE(WSAENOTEMPTY);
    ERROR_CASE(WSAEPROCLIM);
    ERROR_CASE(WSAEUSERS);
    ERROR_CASE(WSAEDQUOT);
    ERROR_CASE(WSAESTALE);
    ERROR_CASE(WSAEREMOTE);
    ERROR_CASE(WSAEDISCON);
    ERROR_CASE(WSASYSNOTREADY);
    ERROR_CASE(WSAVERNOTSUPPORTED);
    ERROR_CASE(WSANOTINITIALISED);
    ERROR_CASE(WSAHOST_NOT_FOUND);
    ERROR_CASE(WSATRY_AGAIN);
    ERROR_CASE(WSANO_RECOVERY);
    ERROR_CASE(WSANO_DATA);

    default:
        return "?";
    }
}

void get_last_internet_error() {

    DWORD buflen;
    char buffer[256];
    DWORD category;

    buflen = sizeof(buffer);
    if (InternetGetLastResponseInfo(&category, buffer, &buflen)) {
        print_response(buffer, buflen, FALSE);
    } else {

        DWORD error;

        error = GetLastError();
        if (Verbose || (error != ERROR_INSUFFICIENT_BUFFER)) {
            printf(get_error_string(error), error, buflen);
        }
        if (error == ERROR_INSUFFICIENT_BUFFER) {

            LPSTR errbuf;

            if ((errbuf = malloc(buflen)) != NULL) {
                if (InternetGetLastResponseInfo(&category, errbuf, &buflen)) {
                    print_response(errbuf, buflen, FALSE);
                } else {
                    error = GetLastError();
                    printf(get_error_string(GetLastError()), error, buflen);
                }
                free(errbuf);
            } else {
                printf("error: get_last_internet_error: malloc(%d) failed\n", buflen);
            }
        }
    }
}

LPSTR get_error_string(DWORD error) {

    static LPSTR errText_1 = "error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d (buflen = %d)\n";
    static LPSTR errText_2 = "error: get_last_internet_error: InternetGetLastResponseInfo() returns error %d\n";

    return (error == ERROR_INSUFFICIENT_BUFFER) ? errText_1 : errText_2;
}

void print_response(LPSTR buffer, DWORD buflen, BOOL isMessage) {
    if (Verbose || !isMessage) {
        printf("InternetGetLastResponseInfo() returns %d bytes\n", buflen);
    }
    if (buflen != 0) {
        if (isMessage) {

            int mode;

            mode = _setmode(1, _O_BINARY);
            write(1, buffer, buflen);
            _setmode(1, mode);
        } else {
            printf("Text = \"%s\"\n", buffer);
        }
    }
    if (strlen(buffer) != buflen) {
        alert();
        printf("error: print_response: InternetGetLastResponseInfo(): buflen = %d; strlen(buffer) = %d\n",
                buflen,
                strlen(buffer)
                );
    }
}

void alert() {
    if (!NoAlerts) {
        putchar('\a');
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\buffer.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains functions for managing BUFFER_INFO 'objects'

    Contents:
        CreateBuffer
        DestroyBuffer
        AcquireBufferLock
        ReleaseBufferLock
        ReferenceBuffer
        DereferenceBuffer

Author:

    Richard L Firth (rfirth) 02-Nov-1994

Revision History:

    02-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// data
//

DEBUG_DATA(LONG, NumberOfBuffers, 0);

//
// functions
//


LPBUFFER_INFO
CreateBuffer(
    OUT LPDWORD Error
    )

/*++

Routine Description:

    Creates and initializes a BUFFER_INFO

Arguments:

    Error   - pointer to returned error

Return Value:

    LPBUFFER_INFO
        Success - pointer to new BUFFER_INFO
        Failure - NULL

--*/

{
    LPBUFFER_INFO bufferInfo;
    DWORD error;
    HANDLE hEvent;

    bufferInfo = NEW(BUFFER_INFO);
    if (bufferInfo != NULL) {

        //
        // create an event that is initially unsignalled. The thread that
        // creates this buffer info will signal the event when the response
        // has been received from the server. At that point, any other
        // concurrent requesters can access the data
        //

//        bufferInfo->RequestEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
//        if (bufferInfo->RequestEvent != NULL) {
            //bufferInfo->ConnectedSocket.Socket = INVALID_SOCKET;

//            InitializeCriticalSection(&bufferInfo->CriticalSection);
            bufferInfo->Socket = new ICSocket();

            if ( bufferInfo->Socket != NULL )
            {
                error = ERROR_SUCCESS;

                BUFFER_CREATED();
            }
            else
                error = ERROR_NOT_ENOUGH_MEMORY;


//        } else {
//            error = GetLastError();
//        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error != ERROR_SUCCESS) {
        if (bufferInfo != NULL) {
            DEL(bufferInfo);
        }
        *Error = error;
    }

    return bufferInfo;
}


VOID
DestroyBuffer(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Frees resources belonging to BUFFER_INFO and frees memory occupied by
    BUFFER_INFO. BufferInfo must have been removed from any lists first

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to destroy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "DestroyBuffer",
                "%x",
                BufferInfo
                ));

    INET_ASSERT(BufferInfo != NULL);
    INET_ASSERT(BufferInfo->ReferenceCount == 0);
//    INET_ASSERT(! BufferInfo->Socket->IsValid());

    //if (BufferInfo->ConnectedSocket.Socket != INVALID_SOCKET) {
    INET_ASSERT(BufferInfo->Socket);

    if (BufferInfo->Socket->IsValid()) {

        //
        // BUGBUG - do we need to set linger or don't linger?
        //

        //
        // close the socket
        //

        BufferInfo->Socket->Close();
    }

    BufferInfo->Socket->Dereference();

//    if (BufferInfo->RequestEvent != NULL) {
//        CloseHandle(BufferInfo->RequestEvent);
//    }

    //
    // if we allocated a buffer for the response then free it
    //

    if ((BufferInfo->Buffer != NULL)
    && (BufferInfo->Flags & BI_BUFFER_RESPONSE)) {

        FREE_FIXED_MEMORY(BufferInfo->Buffer);

    }

//    DeleteCriticalSection(&BufferInfo->CriticalSection);

    DEL(BufferInfo);

    BUFFER_DESTROYED();

    DEBUG_LEAVE(0);
}


VOID
AcquireBufferLock(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Locks the BUFFER_INFO against simultaneous updates of the Buffer

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to lock

Return Value:

    None.

--*/

{
    INET_ASSERT(BufferInfo != NULL);

//    EnterCriticalSection(&BufferInfo->CriticalSection);
}


VOID
ReleaseBufferLock(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Opposite of AcquireBufferLock

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to unlock

Return Value:

    None.

--*/

{
    INET_ASSERT(BufferInfo != NULL);

//    LeaveCriticalSection(&BufferInfo->CriticalSection);
}


VOID
ReferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Increments the BUFFER_INFO reference count

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to reference (by 1)

Return Value:

    None.

--*/

{
    INET_ASSERT(BufferInfo != NULL);

    InterlockedIncrement(&BufferInfo->ReferenceCount);
}


LPBUFFER_INFO
DereferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    )

/*++

Routine Description:

    Reduces the BUFFER_INFO reference count by 1. If the reference count goes
    to zero, the BUFFER_INFO is destroyed

Arguments:

    BufferInfo  - pointer to BUFFER_INFO to dereference/destroy

Return Value:

    DWORD
        previous value of reference count

--*/

{
    INET_ASSERT(BufferInfo != NULL);
    INET_ASSERT(BufferInfo->ReferenceCount >= 1);

    if (InterlockedDecrement(&BufferInfo->ReferenceCount) == 0) {
        DestroyBuffer(BufferInfo);
        BufferInfo = NULL;
    }
    return BufferInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\ftp\test\multfind\multfind.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);

void _CRTAPI1 main(int argc, char** argv) {

    HINTERNET h1;
    HINTERNET h2;
    HINTERNET h3;
    HINTERNET h4;
    LPSTR search;

    search = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case 'v':
                printf("Ha! There is no verbose mode, sucker. Try again\n");
                break;

            default:
                printf("error: unrecognized command line flag '%c'\n", **argv);
                usage();
            }
        } else if (!search) {
            search = *argv;
        } else {
            printf("error: unrecognized command line argument \"%s\"\n", *argv);
            usage();
        }
    }

    h1 = InternetOpen("multfind", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (!h1) {
        printf("error: InternetOpen() returns %d\n", GetLastError());
        exit(1);
    }

    h2 = InternetConnect(h1,
                         "rfirthmips",
                         0,
                         NULL,
                         NULL,
                         INTERNET_SERVICE_FTP,
                         0,
                         0
                         );
    if (!h2) {
        printf("error: InternetConnect() returns %d\n", GetLastError());
        exit(1);
    }

    h3 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (!h3) {
        printf("error: FtpFindFirstFile() #1 returns %d\n", GetLastError());
        exit(1);
    }

    //
    // try simultaneous search for same thing - should fail
    //

    h4 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (h4) {
        printf("error: FtpFindFirstFile() #2 returns OK\n");
        exit(1);
    } else {
        printf("FtpFindFirstFile() #2 returns %d\n", GetLastError());
    }

    //
    // close first handle and try again - should succeed
    //

    if (!InternetCloseHandle(h3)) {
        printf("error: InternetCloseHandle() returns %d\n", GetLastError());
    }

    h3 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (!h3) {
        printf("error: FtpFindFirstFile() returns %d\n", GetLastError());
        exit(1);
    }

    //
    // try a second time again - should fail again
    //

    h4 = FtpFindFirstFile(h2, search, NULL, INTERNET_FLAG_RELOAD, 0);
    if (h4) {
        printf("error: FtpFindFirstFile() #2 returns OK\n");
        exit(1);
    } else {
        printf("FtpFindFirstFile() #2 returns %d\n", GetLastError());
    }

    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: multfind [-v] [search argument]\n"
           "where: -v = Verbose mode\n"
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\buffer.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    Contains manifests, macros, types and typedefs for buffer.c

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

//
// LOOK_AHEAD_LENGTH - read enough characters to comprise the maximum (32-bit)
// length returned by gopher+
//

#define LOOK_AHEAD_LENGTH   sizeof("+4294967296\r\n")   // 12

//
// BUFFER_INFO - structure maintains information about responses from gopher
// server. The same data can be shared amongst many requests
//

typedef struct {

    //
    // ReferenceCount - number of VIEW_INFO structures referencing this buffer
    //

    LONG ReferenceCount;

    //
    // Flags - information about the buffer
    //

    DWORD Flags;

    //
    // RequestEvent - the owner of this event is the only thread which can
    // make the gopher request that creates this buffer info. All other
    // requesters for the same information wait for the first thread to signal
    // the event, then just read the data returned by the first thread
    //

//    HANDLE RequestEvent;

    //
    // RequestWaiters - used in conjunction with RequestEvent. If this field
    // is 0 by the time the initial requester thread comes to signal the
    // event, it can do away with the event altogether, since it was only
    // required to stop those other threads from making a redundant request
    //

//    DWORD RequestWaiters;

    //
    // ConnectedSocket - contains socket we are using to receive the data in
    // the buffer, and the index into the parent SESSION_INFO's
    // ADDRESS_INFO_LIST of the address used to connect the socket
    //

//    CONNECTED_SOCKET ConnectedSocket;
    ICSocket * Socket;

    //
    // ResponseLength - the response length as told to us by the gopher+ server
    //

    int ResponseLength;

    //
    // BufferLength - length of Buffer
    //

    DWORD BufferLength;

    //
    // Buffer - containing response
    //

    LPBYTE Buffer;

    //
    // ResponseInfo - we read the gopher+ header information (i.e. length) here.
    // The main reason is so that we can determine the length of a gopher+ file
    // even though we were given a zero-length user buffer
    //

    char ResponseInfo[LOOK_AHEAD_LENGTH];

    //
    // BytesRemaining - number of bytes left in ResponseInfo that are data
    //

    int BytesRemaining;

    //
    // DataBytes - pointer into ResponseInfo where data bytes start
    //

    LPBYTE DataBytes;

    //
    // CriticalSection - used to serialize readers
    //

//    CRITICAL_SECTION CriticalSection;

} BUFFER_INFO, *LPBUFFER_INFO;

//
// BUFFER_INFO flags
//

#define BI_RECEIVE_COMPLETE 0x00000001  // receiver thread has finished
#define BI_DOT_AT_END       0x00000002  // buffer terminated with ".\r\n"
#define BI_BUFFER_RESPONSE  0x00000004  // response is buffered internally
#define BI_ERROR_RESPONSE   0x00000008  // the server responded with an error
#define BI_MOVEABLE         0x00000010  // buffer is moveable memory
#define BI_FIRST_RECEIVE    0x00000020  // this is the first receive
#define BI_OWN_BUFFER       0x00000040  // set if we own the buffer (directory)

//
// external data
//

DEBUG_DATA_EXTERN(LONG, NumberOfBuffers);

//
// prototypes
//

LPBUFFER_INFO
CreateBuffer(
    OUT LPDWORD Error
    );

VOID
DestroyBuffer(
    IN LPBUFFER_INFO BufferInfo
    );

VOID
AcquireBufferLock(
    IN LPBUFFER_INFO BufferInfo
    );

VOID
ReleaseBufferLock(
    IN LPBUFFER_INFO BufferInfo
    );

VOID
ReferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    );

LPBUFFER_INFO
DereferenceBuffer(
    IN LPBUFFER_INFO BufferInfo
    );

//
// macros
//

#if INET_DEBUG

#define BUFFER_CREATED()    ++NumberOfBuffers
#define BUFFER_DESTROYED()  --NumberOfBuffers
#define ASSERT_NO_BUFFERS() \
    if (NumberOfBuffers != 0) { \
        INET_ASSERT(FALSE); \
    }

#else

#define BUFFER_CREATED()    /* NOTHING */
#define BUFFER_DESTROYED()  /* NOTHING */
#define ASSERT_NO_BUFFERS() /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapiu.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapiu.h

Abstract:

    Contains prototypes etc. for gfrapiu.c

Author:

    Richard L Firth (rfirth) 19-Nov-1994

Revision History:

    19-Nov-1994
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
TestLocatorType(
    IN LPCSTR Locator,
    IN DWORD TypeMask
    );

DWORD
GetAttributes(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN LPSTR InBuffer,
    IN DWORD InBufferLength,
    OUT LPBYTE OutBuffer,
    IN DWORD OutBufferLength,
    OUT LPDWORD CharactersReturned
    );

LPSTR
MakeAttributeRequest(
    IN LPSTR Selector,
    IN LPSTR Attribute
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapir.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapir.c

Abstract:

    Manifests, macros, types, prototypes for gfrapir.c

Author:

    Richard L Firth (rfirth) 14-Oct-1994

Environment:

    Win32 DLL

Revision History:

    14-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

#define IS_GOPHER_SEARCH_SERVER(type) \
    (BOOL)(((type) & (GOPHER_TYPE_CSO | GOPHER_TYPE_INDEX_SERVER)))

//
// prototypes
//

DWORD
wGopherFindFirst(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATA lpBuffer OPTIONAL,
    OUT LPHINTERNET lpHandle
    );

DWORD
wGopherFindNext(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpszBuffer
    );

DWORD
wGopherFindClose(
    IN HINTERNET hFind
    );

DWORD
wGopherOpenFile(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    OUT LPHINTERNET lpHandle
    );

DWORD
wGopherReadFile(
    IN HINTERNET hFile,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    );

DWORD
wGopherCloseHandle(
    IN HINTERNET hFile
    );

DWORD
wGopherGetAttribute(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttribute,
    OUT LPBYTE lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapih.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapih.h

Abstract:

    Includes all headers for precompiled header to build GFRAPI.DLL

Author:

    Richard L Firth (rfirth) 26-Oct-1994

Revision History:

    26-Oct-1994 rfirth
        Created

--*/

#include "buffer.h"
#include "view.h"
#include "session.h"
#include "gfrapip.h"
#include "gfrapiu.h"
#include "gfrapir.h"
#include "parse.h"
#include "sockets.h"
#include "inet.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapiu.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapiu.cxx

Abstract:

    Common sub-API level functions

    Contents:
        TestLocatorType
        GetAttributes
        MakeAttributeRequest
        ParseGopherUrl
        GopherLocatorToUrl

Author:

    Richard L Firth (rfirth) 19-Nov-1994

Environment:

    Win32 user-level DLL

Revision History:

    19-Nov-1994
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

#define INTERNET_DEFAULT_CSO_PORT     105
#define INTERNET_MAX_WELL_KNOWN_PORT 1023
//
// functions
//

BOOL IsInappropriateGopherPort (INTERNET_PORT port)
/*++

Routine Description:

    Gopher URLs can encode arbitrary data to arbitrary ports.  This characteristic
    enables malicious web pages to redirect IE to exploit security holes, for
    example, to spoof a mailer daemon inside a firewall.  Based on experimentation,
    Netscape apparently disables gopher on ports 1 and 7 though 25 odd.  That range
    covers many of the well-known ports catalogued by IANA but misses many others
    like 137 through 139, assigned for netbios over tcp/ip .  Since gopher is
    becoming increasingly irrelevant, we prefer to be stricter .  IE3 now disables
    gopher on ports less than 1024, except for 70, the standard gopher port, and
    105, typically used for CSO name searches.

Arguments: Port number

Return Value: TRUE for success, FALSE for failure

--*/
{
    if (port > INTERNET_MAX_WELL_KNOWN_PORT)
        return FALSE;
    switch (port) {
        case INTERNET_INVALID_PORT_NUMBER:
        case INTERNET_DEFAULT_GOPHER_PORT:
        case INTERNET_DEFAULT_CSO_PORT:
            return FALSE;
        default:
            return TRUE;
    }
}




DWORD
TestLocatorType(
    IN LPCSTR Locator,
    IN DWORD TypeMask
    )

/*++

Routine Description:

    Checks that Locator is valid and checks if it is of the specified type.
    This function is mainly for use by GfrIsXxxx APIs

Arguments:

    Locator     - pointer to app-supplied locator string

    TypeMask    - gopher type mask to check for

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Locator is good and of the specified type

        Failure - ERROR_INVALID_PARAMETER
                    Locator is bad

                  ERROR_INVALID_FUNCTION
                    Locator is good, but not of the specified type

--*/

{
    DWORD error;
    BOOL success = FALSE;

    //
    // BUGBUG - 1. Do we really want to test this parameter?
    //          2. If so, is the length sufficient?
    //

    if (IsBadStringPtr(Locator, MAX_GOPHER_LOCATOR_LENGTH)) {
        error = ERROR_INVALID_PARAMETER;
    } else {

        DWORD gopherType;

        gopherType = GopherCharToType(*Locator);
        if (gopherType == INVALID_GOPHER_TYPE) {

            //
            // not a recognizable type - Locator is bogus
            //

            error = ERROR_INVALID_PARAMETER;
        } else if (gopherType & TypeMask) {
            error = ERROR_SUCCESS;
        } else {

            //
            // slight bogosity - need an error code to differentiate matched
            // vs. not-matched: INVALID_FUNCTION will do
            //

            error = ERROR_INVALID_FUNCTION;
        }
    }
    return error;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
GetAttributes(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN LPSTR InBuffer,
    IN DWORD InBufferLength,
    OUT LPBYTE OutBuffer,
    IN DWORD OutBufferLength,
    OUT LPDWORD CharactersReturned
    )

/*++

Routine Description:

    Pulls attributes out of a buffer and puts them in the caller's buffer or
    enumerates them (if Enumerator supplied)

Arguments:

    Enumerator          - address of caller's enumerator function

    CategoryId          - category of attribute(s)

    AttributeId         - the attribute to return

    AttributeName       - name of the attribute if not a known attribute

    InBuffer            - pointer to buffer containing gopher+ attributes

    InBufferLength      - length of attribute buffer

    OutBuffer           - pointer to caller's buffer where attributes returned

    OutBufferLength     - length of caller's buffer

    CharactersReturned  - pointer to returned buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_ATTRIBUTE_NOT_FOUND
                    We couldn't find the requested attribute/category

                  ERROR_INSUFFICIENT_BUFFER
                    The caller's buffer isn't large enough to contain the
                    attributes. *lpdwCharactersReturned will contain the
                    required length

                  ERROR_GOPHER_DATA_ERROR
                    We couldn't parse the attributes for some reason

--*/

{
    DWORD error;

    *CharactersReturned = 0;

    //
    // the buffer starts with the "+INFO:" attribute describing the locator. We
    // don't return this as an attribute
    //

    if (SkipLine(&InBuffer, &InBufferLength)) {

        LPSTR endSection;
        BOOL done;
        BOOL found;
        BOOL more;

        if (CategoryId != GOPHER_CATEGORY_ID_ALL) {

            //
            // advance InBuffer to the line that contains the requested
            // attribute
            //

            found = FindAttribute(CategoryId,
                                  AttributeId,
                                  AttributeName,
                                  &InBuffer,
                                  &InBufferLength
                                  );
            if (found) {

                //
                // if the caller requested that we return all attributes in a
                // section, then skip the line containing the category name
                //

                if (AttributeId == GOPHER_ATTRIBUTE_ID_ALL) {
                    found = SkipLine(&InBuffer, &InBufferLength);
                }
                if (found) {

                    DWORD bufferLeft;

                    //
                    // get the end of the section or line in endSection
                    //

                    endSection = InBuffer;
                    bufferLeft = InBufferLength;
                    FindNextAttribute(CategoryId,
                                      AttributeId,
                                      &endSection,
                                      &bufferLeft
                                      );
                }
            }
            error = found ? ERROR_SUCCESS : ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;
        } else {
            endSection = InBuffer + InBufferLength;
        }

        more = TRUE;
        done = FALSE;

        while ((error == ERROR_SUCCESS) && (InBuffer < endSection) && more) {

            LPSTR linePtr;
            char lineBuffer[256];  // arbitrary
            DWORD lineLength;
            BOOL ok;

            linePtr = lineBuffer;
            lineLength = sizeof(lineBuffer);
            ok = CopyToEol(&linePtr,
                           &lineLength,
                           &InBuffer,
                           &InBufferLength
                           );
            if (ok) {
                if (Enumerator != NULL) {

                    //
                    // if the line starts with a '+' then (we assume) we are
                    // enumerating all attributes, in which case this line
                    // just serves to identify the next attribute section. We
                    // don't return any info
                    //

                    if (*linePtr == '+') {

                        char newCategory[32];   // arbitrary
                        int i;

                        for (i = 0; i < sizeof(newCategory); ++i) {

                            char ch;

                            ch = linePtr[i];
                            if ((ch == '\r') || (ch == '\n') || (ch == ' ') || (ch == ':')) {
                                break;
                            }
                            newCategory[i] = ch;
                        }
                        newCategory[i] = '\0';
                        MapAttributeToIds((LPCSTR)newCategory,
                                          &CategoryId,
                                          &AttributeId
                                          );
                        if (CategoryId == GOPHER_CATEGORY_ID_ABSTRACT) {

                            //
                            // BUGBUG - the remainder of this line may contain
                            //          a locator identifying the location of
                            //          a file containing the abstract
                            //

                        }
                    } else {
                        error = EnumerateAttribute(Enumerator,
                                                   linePtr,
                                                   lineLength,
                                                   OutBuffer,
                                                   OutBufferLength,
                                                   &more
                                                   );
                        done = TRUE;
                    }
                } else {

                    //
                    // get the length of the line in lineLength. N.B. We have
                    // to subtract an extra 1 because CopyToEol adds a '\0'
                    //

                    lineLength = sizeof(lineBuffer) - lineLength - 1;
                    if (OutBufferLength >= lineLength) {
                        memcpy(OutBuffer, lineBuffer, lineLength);
                        OutBuffer += lineLength;
                        OutBufferLength -= lineLength;
                        done = TRUE;
                    } else {
                        error = ERROR_INSUFFICIENT_BUFFER;
                    }

                    //
                    // always update the characters copied/required parameter
                    //

                    *CharactersReturned += lineLength;
                }
            } else {
                error = ERROR_GOPHER_DATA_ERROR;
            }
        }

        //
        // if nothing was copied or enumerated then the attribute was not found
        //

        if (!done && (error == ERROR_SUCCESS)) {
            error = ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;
        }
    } else {
        error = ERROR_GOPHER_DATA_ERROR;
    }
    return error;
}


LPSTR
MakeAttributeRequest(
    IN LPSTR Selector,
    IN LPSTR Attribute
    )

/*++

Routine Description:

    Converts a gopher+ request into a request for attributes. E.g. turns
    "0Foo" into "0Foo\t!+ADMIN"

Arguments:

    Selector    - pointer to identifier of gopher+ item to get attributes for

    Attribute   - pointer to name of attribute(s) to retrieve

Return Value:

    LPSTR
        Success - pointer to allocated memory containing attribute requester

        Failure - NULL

--*/

{
    INT selectorLength;
    INT attributeLength;
    LPSTR request;

    selectorLength = (Selector != NULL) ? strlen(Selector) : 0;
    attributeLength = (Attribute != NULL) ? strlen(Attribute) : 0;
    request = NEW_MEMORY(selectorLength

                         //
                         // sizeof(GOPHER_PLUS_INFO_REQUEST) includes 2 for
                         // <CR><LF> and 1 for terminator
                         //

                         + sizeof(GOPHER_PLUS_INFO_REQUEST)
                         + attributeLength,
                         CHAR
                         );
    if (request != NULL) {
        if (Selector != NULL) {
            memcpy(request, Selector, selectorLength);
        }
        memcpy(&request[selectorLength],
               GOPHER_PLUS_ITEM_INFO,
               sizeof(GOPHER_PLUS_ITEM_INFO) - 1
               );
        selectorLength += sizeof(GOPHER_PLUS_ITEM_INFO) - 1;
        if (Attribute != NULL) {
            memcpy(&request[selectorLength], Attribute, attributeLength);
            selectorLength += attributeLength;
        }
        memcpy(&request[selectorLength],
               GOPHER_REQUEST_TERMINATOR,
               sizeof(GOPHER_REQUEST_TERMINATOR)
               );
    }
    return request;
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
ParseGopherUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    )

/*++

Routine Description:

    URL parser for gopher URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls gopher APIs to
    do the work

Arguments:

    hInternet       - IN: Internet gateway handle
                      OUT: if successful handle of opened item, else undefined

    Url             - pointer to string containing gopher URL to open

    SchemeLength    - length of the URL scheme, exluding "://"

    Headers         - unused for gopher

    HeadersLength   - unused for gopher

    OpenFlags       - optional flags for opening a file (cache/no-cache, etc.)

    Context         - app-supplied context value for call-backs

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                 Dword,
                 "ParseGopherUrl",
                 "%#x [%#x], %q, %d, %#x, %d, %#x, %#x",
                 hInternet,
                 *hInternet,
                 Url,
                 SchemeLength,
                 Headers,
                 HeadersLength,
                 OpenFlags,
                 Context
                 ));

    DWORD error;
    DWORD gopherType;
    LPSTR selector;
    LPSTR searchString;
    HINTERNET hMapped = NULL;

    UNREFERENCED_PARAMETER(Headers);
    UNREFERENCED_PARAMETER(HeadersLength);

    //
    // extract the address information - no user name or password
    //

    DWORD urlLength;
    LPSTR pHostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR lpszUrl = Url;

    Url += SchemeLength + sizeof("://") - 1;
    error = GetUrlAddress(&Url,
                          &urlLength,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &pHostName,
                          &hostNameLength,
                          &port,
                          NULL
                          );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (IsInappropriateGopherPort(port)) {
        error = ERROR_INTERNET_INVALID_URL;
        goto quit;
    }

    //
    // a '/' between address and url-path is not significant to gopher
    //

    if (*Url == '/') {
        ++Url;
        --urlLength;

        //
        // the fact that we can ignore the '/' between address and url-path
        // means that it is okay to write a '\0' at the end of the host name
        //

        pHostName[hostNameLength] = '\0';
    }

    //
    // if the URL just consisted of gopher://host[:port] then by default we are
    // referencing the root gopher directory
    //

    if (*Url != '\0') {

        //
        // Before decoding, convert '?' to tab and thereafter any '+' to ' '
        //

        LPSTR lpszScan = strchr (Url, '?');
        if (lpszScan)
        {
            *lpszScan++ = '\t';
            while (*lpszScan)
            {
                INET_ASSERT (*lpszScan != '?'); // should be encoded
                if (*lpszScan == '+')
                    *lpszScan = ' ';
                lpszScan++;
            }
        }

        //
        // we need to convert the url-path before checking it for the search
        // string and gopher+ fields because we need to search for '\t' which
        // is currently encoded
        //

        if(FAILED(UrlUnescapeInPlace(Url, 0))){
            goto quit;
        }
        urlLength = lstrlen(Url);

        //
        // find the type of the gopher resource; if unknown, treat as a file
        //

        gopherType = GopherCharToType(Url[0]);
        selector = &Url[1];

        //
        // urlLength is now the length of the converted selector
        //

        --urlLength;
        searchString = (LPSTR)memchr((LPVOID)selector, '\t', urlLength);
        if (searchString != NULL) {

            LPSTR plusString;

            //
            // zero-terminate the search string, then check if for a gopher+
            // component
            //

            *searchString++ = '\0';
            plusString = (LPSTR)memchr((LPVOID)searchString,
                                       '\t',
                                       urlLength - (DWORD) (searchString - selector)
                                       );
            if (plusString != NULL) {
                *plusString++ = '\0';
                gopherType |= GOPHER_TYPE_GOPHER_PLUS;

                //
                // if the URL defines a file then we may have a view type
                //

                //
                // BUGBUG - need to handle:
                //
                //      - alternate file views
                //      - attribute requests (?)
                //      - ASK forms
                //
            }
        }
    } else {
        gopherType = GOPHER_TYPE_DIRECTORY;
        selector = NULL;
        searchString = NULL;
    }

    HINTERNET hConnect;

    //
    // initialize in case of error
    //

    hConnect = NULL;

    //
    // get the offline state
    //

    BOOL bOffline;
    DWORD dwFlags;

    bOffline = IsOffline();
    if (bOffline || (OpenFlags & INTERNET_FLAG_OFFLINE)) {
        dwFlags = INTERNET_FLAG_OFFLINE;
    } else {
        dwFlags = 0;
    }

    //
    // try to create a locator from the various parts
    //

    char locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
    DWORD locatorLength;

    locatorLength = sizeof(locator);
    if (GopherCreateLocator(pHostName,
                            port,
                            NULL,
                            selector,
                            gopherType,
                            locator,
                            &locatorLength
                            )) {

        //
        // ok, all parts present and correct; open a handle to the gopher
        // resource
        //

        hConnect = InternetConnect(*hInternet,
                                   pHostName,
                                   port,
                                   NULL,    // lpszUserName
                                   NULL,    // lpszPassword
                                   INTERNET_SERVICE_GOPHER,
                                   dwFlags,

                                   //
                                   // we are creating a "hidden" handle - don't
                                   // tell the app about it
                                   //

                                   INTERNET_NO_CALLBACK
                                   );

try_again:

        if (hConnect != NULL) {

            HINTERNET handle;

            if ( hMapped == NULL )
            {
                error = MapHandleToAddress(hConnect, (LPVOID *)&hMapped, FALSE);

                if ( (error != ERROR_SUCCESS) && (hMapped == NULL) )
                {
                    goto error_quit;
                }

                error = ERROR_SUCCESS;
            }

            INET_ASSERT(hMapped != NULL);

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->SetURL(lpszUrl);

            if (  IS_GOPHER_DIRECTORY(gopherType)
               || IS_GOPHER_SEARCH_SERVER(gopherType)) {

                // set htmlfind only if RAW is not asked

                if (!(OpenFlags & INTERNET_FLAG_RAW_DATA)) {

                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hMapped)->SetHtmlFind(TRUE);

                    //
                    // BUGBUG: we don't have time to handle CSO searches
                    //
                    if (IS_GOPHER_PHONE_SERVER (gopherType))
                        goto cso_hack;

                    if ( IS_GOPHER_SEARCH_SERVER(gopherType)
                          && (!searchString || !searchString[0])) {

cso_hack:
                        handle = NULL;

                        if (ERROR_SUCCESS == RMakeGfrFixedObjectHandle
                            (hMapped, &handle, gopherType)) {
                            handle = ((HANDLE_OBJECT *)handle)->GetPseudoHandle();
                        }

                        DereferenceObject((LPVOID)hMapped);
                        goto got_handle;
                    }

                }

                handle = GopherFindFirstFile(hConnect,
                                             locator,
                                             searchString,
                                             NULL,
                                             OpenFlags | dwFlags,
                                             Context
                                             );


            } else {

                handle = GopherOpenFile(hConnect,
                                        locator,
                                        NULL,
                                        OpenFlags | dwFlags,
                                        Context
                                        );
            }

got_handle:

            if (handle != NULL) {

                //
                // map the handles
                //

                HINTERNET hRequestMapped;
                error = MapHandleToAddress(handle, (LPVOID *)&hRequestMapped, FALSE);
                INET_ASSERT(error == ERROR_SUCCESS);

                HINTERNET hConnectMapped;
                error = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
                INET_ASSERT(error == ERROR_SUCCESS);

                //
                // link the request and connect handles so that the connect handle
                // object will be deleted when the request handle is closed
                //

                RSetParentHandle(hRequestMapped, hConnectMapped, TRUE);

                //
                // reduce the reference counts incremented by MapHandleToAddress()
                //

                if (hRequestMapped != NULL) {
                    DereferenceObject((LPVOID)hRequestMapped);
                }
                if (hConnectMapped != NULL) {
                    DereferenceObject((LPVOID)hConnectMapped);
                }

                //
                // return the request handle to the caller
                //

                *hInternet = handle;

                error = ERROR_SUCCESS;
                goto quit;
            } else if (!bOffline && IsOffline() && !(dwFlags & INTERNET_FLAG_OFFLINE)) {

                //
                // we went offline during the request. Try again, this time
                // from cache
                //

                dwFlags = INTERNET_FLAG_OFFLINE;
                goto try_again;
            }
        }
    }

error_quit:

    if ( hMapped != NULL )
    {
        DereferenceObject((LPVOID)hMapped);
        hMapped = NULL;
    }


    error = GetLastError();
    if (hConnect != NULL) {

        //
        // BUGBUG - this should close the item handle also (if open)
        //

        _InternetCloseHandle(hConnect);
    }

    INET_ASSERT(error != ERROR_SUCCESS);

quit:


    DEBUG_LEAVE(error);
    return error;
}


DWORD
GopherLocatorToUrl(
    IN LPSTR Locator,
    OUT LPSTR Buffer,
    IN DWORD BufferLength,
    OUT LPDWORD UrlLength
    )

/*++

Routine Description:

    Converts a gopher locator to a gopher URL. E.g. converts:

        1foo\tFoo Directory\tfoo.host\t77\t+

    to the URL:

        gopher://foo.host:77/1Foo%20Directory%09%09%2B

Arguments:

    Locator         - pointer to gopher locator to convert

    Buffer          - pointer to buffer where URL is written

    BufferLength    - size of Buffer in bytes

    UrlLength       - number of bytes written to Buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INTERNAL_ERROR
                    We blew an internal buffer limit

                  ERROR_INSUFFICIENT_BUFFER
                    Buffer is not large enough to hold the converted URL

--*/

{
    DWORD gopherType;
    char selector[MAX_GOPHER_SELECTOR_TEXT + 1];
    DWORD selectorLength;
    char hostName[MAX_GOPHER_HOST_NAME + 1];
    DWORD hostNameLength;
    DWORD gopherPort;
    LPSTR gopherPlus;
    char urlBuf[INTERNET_MAX_URL_LENGTH];
    DWORD urlBufferLength;
    LPSTR urlBuffer;
    DWORD error;
    DWORD bufLen;

    urlBufferLength = sizeof(urlBuf);
    urlBuffer = urlBuf;
    bufLen = BufferLength;

    //
    // start with the gopher protocol specifier
    //

    if (bufLen > sizeof("gopher://")) {
        memcpy(Buffer, "gopher://", sizeof("gopher://") - 1);
        Buffer += sizeof("gopher://") - 1;
        bufLen -= sizeof("gopher://") - 1;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // use CrackLocator() to get the individual parts of the locator
    //

    selectorLength = sizeof(selector);
    hostNameLength = sizeof(hostName);
    if (!CrackLocator(Locator,
                      &gopherType,
                      NULL,  // DisplayString - we don't care about this in the URL
                      NULL,  // DisplayStringLength
                      selector,
                      &selectorLength,
                      hostName,
                      &hostNameLength,
                      &gopherPort,
                      &gopherPlus
                      )) {

        //
        // most likely we bust a limit!
        //

        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    //
    // add in the host name
    //

    if (bufLen > hostNameLength) {
        memcpy(Buffer, hostName, hostNameLength);
        Buffer += hostNameLength;
        bufLen -= hostNameLength;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // add the port, but only if it is not the default (70)
    //

    if (gopherPort != INTERNET_DEFAULT_GOPHER_PORT) {
        if (bufLen > 1 + INTERNET_MAX_PORT_NUMBER_LENGTH) {

            int n;

            n = wsprintf(Buffer, ":%u", gopherPort);
            Buffer += n;
            bufLen -= (DWORD)n;
        } else {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // add the URL-path separator and the locator type character
    //

    if (bufLen > 2) {
        *Buffer++ = '/';
        *Buffer++ = *Locator;
        bufLen -= 2;
    }

    //
    // copy the selector string, and any gopher+ addenda to a separater buffer
    //

    if (urlBufferLength > selectorLength) {
        memcpy(urlBuffer, selector, selectorLength);
        urlBuffer += selectorLength;
        urlBufferLength -=  selectorLength;
    }

    //
    // if the locator specifies a gopher+ item then add the gopher+ indicator
    //

    if (gopherPlus != NULL) {
        if (urlBufferLength > 3) {
            memcpy(urlBuffer, "\t\t+", 3);
            urlBufferLength -= 3;
            urlBuffer += 3;
        }
    }

    //
    // finally terminate the URL
    //

    if (urlBufferLength >= 1) {
        *urlBuffer++ = '\0';
        --urlBufferLength;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // now escape any special characters (e.g. space, tab, etc.) in the url-path
    //

    *UrlLength = bufLen;

    error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                          SCHEME_GOPHER,
                          urlBuf,
                          sizeof(urlBuf) - urlBufferLength - 1,
                          Buffer,
                          UrlLength
                          );
    if (error == ERROR_SUCCESS) {
        *UrlLength += BufferLength - bufLen;
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapir.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapir.cxx

Abstract:

    Contains the remote-side gopher API worker functions. In each case, the API
    proper validates the arguments. The worker functions contained herein just
    perform the requested operation with the supplied arguments.

    These functions are the remote side of the RPC interface. If the DLL is
    the abstract0 version (no RPC) then the A forms of the functions simply
    call the w functions

    Contents:
        wGopherFindFirst
        wGopherFindNext
        wGopherFindClose
        wGopherOpenFile
        wGopherReadFile
        wGopherQueryDataAvailable
        wGopherCloseHandle
        wGopherGetAttribute
        wGopherConnect
        wGopherDisconnect
        (GetView)

Author:

    Richard L Firth (rfirth) 14-Oct-1994

Environment:

    Win32 DLL

Revision History:

    14-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define DEFAULT_REQUEST_BUFFER_LENGTH   (MAX_GOPHER_SELECTOR_TEXT + GOPHER_REQUEST_TERMINATOR_LENGTH + 1)

//
// private data
//

char szQuery[] = "query "; // prepend to CSO searches

//
// private prototypes
//

PRIVATE
DWORD
GetView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    IN BOOL RequestIsGopherPlus,
    IN DWORD ResponseFlags,
    OUT LPVIEW_INFO* pViewInfo
    );

extern
DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

//
// functions
//


DWORD
wGopherFindFirst(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATA lpBuffer OPTIONAL,
    OUT LPHINTERNET lpHandle
    )

/*++

Routine Description:

    Connects to the gopher server, sends a request to get directory information,
    gets the response and converts the gopher descriptor strings to
    GOPHER_FIND_DATA structures

Arguments:

    lpszLocator         - pointer to descriptor of information to get

    lpszSearchString    - pointer to strings to search for if Locator is search
                          server. This argument MUST be present if Locator is
                          an search server

    lpBuffer            - pointer to user-allocated buffer in which to return
                          info

    lpHandle            - pointer to returned handle if ERROR_SUCCESS returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  WSA error

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherFindFirst",
                "%q, %q, %#x, %#x",
                lpszLocator,
                lpszSearchString,
                lpBuffer,
                lpHandle
                ));

    DWORD gopherType;
    LPSTR requestPtr;
    DWORD requestLen;
    char hostName[MAX_GOPHER_HOST_NAME + 1];
    DWORD hostNameLen;
    DWORD port;
    LPSTR gopherPlus;
    LPSESSION_INFO sessionInfo;
    DWORD error;
    HINTERNET findHandle;
    LPVIEW_INFO viewInfo;
    DWORD newRequestLength;
    DWORD searchStringsLength;

    //
    // initialise variables in case of early exit (via goto)
    //

    sessionInfo = NULL;

    //
    // grab a buffer for the request string
    //

    requestLen = DEFAULT_REQUEST_BUFFER_LENGTH;
    requestPtr = (LPSTR)ResizeBuffer(NULL, requestLen, FALSE);
    if (requestPtr == NULL) {

        DEBUG_LEAVE(ERROR_NOT_ENOUGH_MEMORY);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // pull the individual fields out of the locator. Not interested in display
    // string
    //

    hostNameLen = sizeof(hostName);
    if (!CrackLocator(lpszLocator,
                      &gopherType,
                      NULL,         // DisplayString
                      NULL,         // DisplayStringLength
                      requestPtr,   // SelectorString
                      &requestLen,  // SelectorStringLength
                      hostName,
                      &hostNameLen,
                      &port,
                      &gopherPlus
                      )) {
        error = ERROR_GOPHER_INVALID_LOCATOR;
        goto quit;
    }

    //
    // find the session 'object'. If we don't have one describing the requested
    // gopher server then create one
    //

    sessionInfo = FindOrCreateSession(hostName, port, &error);
    if (sessionInfo == NULL) {
        goto quit;
    }

    //
    // if the request is gopher+ or plain gopher but we know the server is
    // gopher+ then we automatically promote the request to be gopher+. It
    // potentially makes life easier for this DLL (the server could tell us
    // the exact length of the response or be more discerning about errors)
    // and potentially gives more information to the app. Either way, the app
    // doesn't lose by this
    //

    if (gopherPlus || IsGopherPlusSession(sessionInfo)) {
        gopherType |= GOPHER_TYPE_GOPHER_PLUS;
    }

    //
    // calculate the length of the extra strings we have to add to the selector
    //

    newRequestLength = requestLen;

    if (  IS_GOPHER_SEARCH_SERVER(gopherType)) {

        INET_ASSERT(lpszSearchString != NULL);
        INET_ASSERT(*lpszSearchString != '\0');

        //
        // add search strings length
        //

        searchStringsLength = strlen(lpszSearchString);
        newRequestLength += searchStringsLength;

        if (IS_GOPHER_INDEX_SERVER(gopherType)) {
            newRequestLength++; // for tab
        } else {
            newRequestLength += sizeof(szQuery) - 1;
        }

    } else {
        searchStringsLength = 0;
    }

    //
    // gopher+ requests have "\t+" or "\t$" at the end of the request
    //

    if (IS_GOPHER_PLUS(gopherType)) {
        newRequestLength += 2;
    }

    //
    // all requests terminated by "\r\n". Add 1 for string terminator
    //

    newRequestLength += sizeof(GOPHER_REQUEST_TERMINATOR);

    //
    // grow the buffer if necessary
    //

    if (newRequestLength > DEFAULT_REQUEST_BUFFER_LENGTH) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr, newRequestLength, FALSE);
        if (requestPtr == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    //
    // add the additional strings
    //

    if (searchStringsLength != 0) {

        if (IS_GOPHER_INDEX_SERVER(gopherType)) {
            requestPtr[requestLen++] = GOPHER_FIELD_SEPARATOR;
        } else {
            memcpy (requestPtr + requestLen, szQuery, sizeof(szQuery) - 1);
            requestLen += sizeof(szQuery) - 1;
        }
        memcpy(&requestPtr[requestLen], lpszSearchString, searchStringsLength);
        requestLen += searchStringsLength;
    }
    if (IS_GOPHER_PLUS(gopherType)) {
        requestPtr[requestLen++] = GOPHER_FIELD_SEPARATOR;
        requestPtr[requestLen++] =
            IS_GOPHER_SEARCH_SERVER(gopherType)? '+' : '$';
    }
    memcpy(&requestPtr[requestLen],
           GOPHER_REQUEST_TERMINATOR,
           sizeof(GOPHER_REQUEST_TERMINATOR)    // don't scrub the '\0' in this case
           );

    //
    // selector munged; get the directory listing
    //

    error = GetView(sessionInfo,
                    ViewTypeFind,
                    requestPtr,
                    IS_GOPHER_PLUS(gopherType) ? TRUE : FALSE,
                    BI_DOT_AT_END,
                    &viewInfo
                    );

    //
    // if no error was reported then we can return a directory entry
    //

    if (error == ERROR_SUCCESS) {

        //
        // if the caller supplied an output buffer then convert the first
        // directory entry to the API buffer format, else the caller wants
        // all gopher directory information returned by InternetFindNextFile()
        //

        if (ARGUMENT_PRESENT(lpBuffer)) {
            error = GetDirEntry(viewInfo, lpBuffer);
        }
        if (error == ERROR_SUCCESS) {
            findHandle = viewInfo->Handle;
        } else {
            DereferenceView(viewInfo);
        }
    }

quit:

    //
    // dereference the session. If we have an active VIEW_INFO then the
    // reference count will still be > 0
    //

    if (sessionInfo != NULL) {
        DereferenceSession(sessionInfo);
    }

    //
    // if we allocated a new request buffer for a large search request then
    // free it
    //

    if (requestPtr != NULL) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr, 0, FALSE);

        INET_ASSERT(requestPtr == NULL);

    }

    //
    // set the handle value - ignored by caller if we don't return ERROR_SUCCESS
    //

    *lpHandle = findHandle;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherFindNext(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpBuffer
    )

/*++

Routine Description:

    Remote side of GopherFindNext API. All parameters have been validated by the
    time this function is called, so we know that Buffer is large enough to
    hold all the returned data

Arguments:

    hFind       - handle of FIND_DATA, created by GopherFindFirstFile()

    lpBuffer    - pointer to user-allocated buffer for GOPHER_FIND_DATA

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Buffer contains next GOPHER_FIND_DATA structure

        Failure - ERROR_INVALID_HANDLE
                    Can't find the VIEW_INFO corresponding to hFind

                  ERROR_NO_MORE_FILES
                    We have reached the end of the directory info

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherFindNext",
                "%#x, %#x",
                hFind,
                lpBuffer
                ));

    LPVIEW_INFO viewInfo;
    DWORD error;

    //
    // locate the VIEW_INFO corresponding to hFind and the SESSION_INFO
    // that owns it
    //

    viewInfo = FindViewByHandle(hFind, ViewTypeFind);
    if (viewInfo != NULL) {

        //
        // just read out the next directory entry
        //

        error = GetDirEntry(viewInfo, lpBuffer);

        //
        // if the Find has been closed or this was the last entry, the following
        // dereference will cause the VIEW_INFO to be deleted, and if there are no
        // more requests outstanding on the SESSION_INFO then it too will be
        // deleted (via a dereference)
        //

        DereferenceView(viewInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherFindClose(
    IN HINTERNET hFind
    )

/*++

Routine Description:

    Causes the VIEW_INFO described by hFind to be removed from the SESSION_INFO
    and freed. If there are no other links to the data buffer then it too is
    deallocated

Arguments:

    hFind   - handle describing the VIEW_INFO to terminate

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherFindClose",
                "%#x",
                hFind
                ));

    DWORD error;

    //
    // atomically find and dereference the VIEW_INFO given the handle
    //

    error = DereferenceViewByHandle(hFind, ViewTypeFind);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherOpenFile(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    OUT LPHINTERNET lpHandle
    )

/*++

Routine Description:

    'Opens' a gopher file by copying it locally and returning a handle to the
    buffer

Arguments:

    lpszLocator - pointer to locator describing file to open

    lpszView    - pointer to view name - identifies type of file to retrieve

    lpHandle    - pointer to returned handle if ERROR_SUCCESS returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  WSA error

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherOpenFile",
                "%q, %q, %#x",
                lpszLocator,
                lpszView,
                lpHandle
                ));

    DWORD error;
    DWORD gopherType;
    LPSTR requestPtr;
    DWORD requestLen;
    char hostName[MAX_GOPHER_HOST_NAME + 1];
    DWORD hostNameLen;
    DWORD port;
    LPSTR gopherPlus;
    LPSESSION_INFO sessionInfo;
    LPVIEW_INFO viewInfo;
    HINTERNET fileHandle;
    DWORD viewLen;

    //
    // initialise variables in case of early exit (via goto)
    //

    sessionInfo = NULL;
    fileHandle = NULL;

    //
    // grab a buffer for the request string
    //

    requestLen = MAX_GOPHER_SELECTOR_TEXT + 1;
    requestPtr = (LPSTR)ResizeBuffer((HLOCAL)NULL, requestLen, FALSE);
    if (requestPtr == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull the individual fields out of the locator. Not interested in display
    // string
    //

    hostNameLen = sizeof(hostName);
    if (!CrackLocator(lpszLocator,
                      &gopherType,
                      NULL,         // DisplayString
                      NULL,         // DisplayStringLength
                      requestPtr,   // SelectorString
                      &requestLen,  // SelectorStringLength
                      hostName,
                      &hostNameLen,
                      &port,
                      &gopherPlus
                      )) {
        error = ERROR_GOPHER_INVALID_LOCATOR;
        goto quit;
    }

    //
    // find the session 'object'. If we don't have one describing the requested
    // gopher server then create one
    //

    sessionInfo = FindOrCreateSession(hostName, port, &error);
    if (sessionInfo == NULL) {
        goto quit;
    }

    //
    // (see GopherFindFirstFile()). If gopher+ is requested or available then
    // make this a gopher+ request
    //

    if (gopherPlus || IsGopherPlusSession(sessionInfo)) {
        gopherType |= GOPHER_TYPE_GOPHER_PLUS;

        //
        // we at least need some space for "\t+"
        //

        viewLen = sizeof(GOPHER_PLUS_INDICATOR) - 1;

        //
        // get the amount of space required for the alternate view, if supplied
        //

        if (ARGUMENT_PRESENT(lpszView)) {

            //
            // the extra +1 here is for the '+' between the selector and the
            // alternate view string: the '\0' is handled by
            // sizeof(GOPHER_REQUEST_TERMINATOR)
            //

            viewLen += strlen(lpszView);
        }
    } else {

        //
        // the caller may have supplied an alternate view for a gopher0 even
        // though it is meaningless. Ensure that it is not used
        //

        lpszView = NULL;
        viewLen = 0;
    }

    //
    // grow the buffer if it is not large enough to hold the view etc. Note, if
    // this is true, then we have bust one of our internal limits, which is
    // unexpected to say the least. But this way, we can allow apps to present
    // completely bogus (so we think) parameters, and at least give them a try
    //

    if ((requestLen + viewLen + sizeof(GOPHER_REQUEST_TERMINATOR))
    > (MAX_GOPHER_SELECTOR_TEXT + 1)) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr,
                                         requestLen
                                         + viewLen
                                         + sizeof(GOPHER_REQUEST_TERMINATOR),
                                         FALSE
                                         );
        if (requestPtr == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    //
    // if this is a gopher plus request, then add the "\t+". If there is an
    // alternate view then it will be appended to the plus, else we just add
    // the line terminator
    //

    if (IS_GOPHER_PLUS(gopherType)) {
        memcpy(&requestPtr[requestLen],
               GOPHER_PLUS_INDICATOR,
               sizeof(GOPHER_PLUS_INDICATOR) - 1
               );
        requestLen += sizeof(GOPHER_PLUS_INDICATOR) - 1;
    }

    //
    // add the alternate view information, if any was supplied
    //

    if (ARGUMENT_PRESENT(lpszView)) {
        memcpy(&requestPtr[requestLen], lpszView, viewLen);
        requestLen += viewLen;
    }

    //
    // in gopher0 and gopher+ cases we must terminate the selector by CR-LF
    //

    memcpy(&requestPtr[requestLen],
           GOPHER_REQUEST_TERMINATOR,
           sizeof(GOPHER_REQUEST_TERMINATOR)
           );

    //
    // selector munged; get the file
    //

    error = GetView(sessionInfo,
                    ViewTypeFile,
                    requestPtr,
                    (gopherPlus != NULL)
                        ? TRUE
                        : FALSE,
                    IS_DOT_TERMINATED_REQUEST(gopherType)
                        ? BI_DOT_AT_END
                        : 0,
                    &viewInfo
                    );
    if (error == ERROR_SUCCESS) {
        fileHandle = viewInfo->Handle;
    }

quit:

    //
    // free the request buffer
    //

    if (requestPtr != NULL) {
        requestPtr = (LPSTR)ResizeBuffer((HLOCAL)requestPtr, 0, FALSE);

        INET_ASSERT(requestPtr == NULL);

    }

    //
    // dereference the session - this may cause it to be deleted
    //

    if (sessionInfo != NULL) {
        DereferenceSession(sessionInfo);
    }

    //
    // set the handle value - ignored by caller if we don't return ERROR_SUCCESS
    //

    *lpHandle = fileHandle;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherReadFile(
    IN HINTERNET hFile,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    )

/*++

Routine Description:

    Reads the next dwBufferLength bytes (or as much as is remaining) from the
    file identified by hFile and writes to lpBuffer

Arguments:

    hFile               - identifies file

    lpBuffer            - place to return file data

    dwBufferLength      - length of Buffer

    lpdwBytesReturned   - amount of data written to Buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    *lpdwBytesReturned written to lpBuffer

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find the VIEW_INFO corresponding to hFile

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherReadFile",
                "%#x, %#x, %d, %#x",
                hFile,
                lpBuffer,
                dwBufferLength,
                lpdwBytesReturned
                ));

    LPVIEW_INFO viewInfo;
    DWORD error;

    viewInfo = FindViewByHandle(hFile, ViewTypeFile);
    if (viewInfo != NULL) {

        LPBUFFER_INFO bufferInfo;

        INET_ASSERT(viewInfo->BufferInfo != NULL);

        bufferInfo = viewInfo->BufferInfo;

        bufferInfo->Buffer = lpBuffer;
        bufferInfo->BufferLength = dwBufferLength;
        error = ReadData(viewInfo, lpdwBytesReturned);
        DereferenceView(viewInfo);
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data available to be read on the socket

Arguments:

    hFile                       - identifies gopher file

    lpdwNumberOfBytesAvailable  - where number of available bytes returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherQueryDataAvailable",
                "%#x, %#x",
                hFile,
                lpdwNumberOfBytesAvailable
                ));

    DWORD bytesAvailable = 0;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(lpThreadInfo->hObjectMapped, &handleType);

    if (error != ERROR_SUCCESS) {
        return (error);
    }

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPVIEW_INFO viewInfo;
    VIEW_TYPE viewType;

    //
    // assume this is a directory list first
    //

    if ((viewInfo = FindViewByHandle(hFile, ViewTypeFind)) != NULL) {
        viewType = ViewTypeFind;
        error = ERROR_SUCCESS;
        if (viewInfo->ViewOffset < viewInfo->BufferInfo->BufferLength) {
            bytesAvailable = sizeof(GOPHER_FIND_DATA);
        }
    } else if ((viewInfo = FindViewByHandle(hFile, ViewTypeFile)) != NULL) {
        viewType = ViewTypeFile;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }
    if ((error == ERROR_SUCCESS) && (bytesAvailable == 0)) {

        INET_ASSERT(viewInfo->BufferInfo != NULL);

        ICSocket *socket = viewInfo->BufferInfo->Socket;

        if (socket->IsValid()) {
            error = socket->DataAvailable(&bytesAvailable);
        }
        if ((error == ERROR_SUCCESS)
        && (viewType == ViewTypeFind)
        && (bytesAvailable != 0)) {
            bytesAvailable = sizeof(GOPHER_FIND_DATA);
        }
    } else {
        error = ERROR_SUCCESS;
    }

    if (viewInfo != NULL) {
        DereferenceView(viewInfo);
    }

    *lpdwNumberOfBytesAvailable = bytesAvailable;

quit:

    if ((error == ERROR_SUCCESS) && !bytesAvailable) {
        InbGopherLocalEndCacheWrite(lpThreadInfo->hObjectMapped,
                                    ((handleType==TypeFtpFindHandleHtml)
                                    ?"htm":NULL),
                                    TRUE);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
wGopherCloseHandle(
    IN HINTERNET hFile
    )

/*++

Routine Description:

    Causes the VIEW_INFO described by hFile to be removed from the
    SESSION_INFO and freed. If there are no other links to the data buffer
    then it too is deallocated

Arguments:

    hFile   - handle describing the VIEW_INFO to terminate

Return Value:

    BOOL
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherCloseHandle",
                "%#x",
                hFile
                ));

    DWORD error;

    //
    // atomically find and dereference the VIEW_INFO given the handle
    //

    error = DereferenceViewByHandle(hFile, ViewTypeFile);

    DEBUG_LEAVE(error);

    return error;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
wGopherGetAttribute(
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttribute,
    OUT LPBYTE lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Retrieves the requested attribute

Arguments:

    lpszLocator         - descriptor of item for which attribute information will
                          be retrieved

    lpszAttribute       - the attribute name, e.g. +VIEWS

    lpBuffer            - to receive attributes

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_ATTRIBUTE_NOT_FOUND
                  ERROR_GOPHER_NOT_GOPHER_PLUS
                  ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "wGopherGetAttribute",
                "%q, %q, %#x, %#x [%d]",
                lpszLocator,
                lpszAttribute,
                lpBuffer,
                lpdwBufferLength
                ));

    DWORD error;

    //
    // the locator we are requested to get attributes for may have come from a
    // server other than that identified in the locator. We will search any
    // VIEW_INFO buffers we have looking for the locator. In the worst case
    // we won't find it and will have to send a request to the server
    //

    error = SearchSessionsForAttribute((LPSTR)lpszLocator,
                                       (LPSTR)lpszAttribute,
                                       lpBuffer,
                                       lpdwBufferLength
                                       );
    if (error == ERROR_GOPHER_ATTRIBUTE_NOT_FOUND) {

        char request[MAX_GOPHER_SELECTOR_TEXT + 1];
        DWORD requestLen;
        char hostName[MAX_GOPHER_HOST_NAME + 1];
        DWORD hostNameLen;
        DWORD port;
        LPSTR gopherPlus;
        LPSESSION_INFO sessionInfo;
        DWORD requestType;

        //
        // its the worst case - we don't (or no longer) have the requested
        // locator/attributes. We must request them again from the server
        //

        //
        // pull the individual fields out of the locator. Not interested in display
        // string
        //

        requestLen = sizeof(request);
        hostNameLen = sizeof(hostName);
        if (!CrackLocator(lpszLocator,
                          &requestType,
                          NULL,         // DisplayString
                          NULL,         // DisplayStringLength
                          request,      // SelectorString
                          &requestLen,  // SelectorStringLength
                          hostName,
                          &hostNameLen,
                          &port,
                          &gopherPlus
                          )) {
            error = ERROR_GOPHER_INVALID_LOCATOR;
            goto quit;
        }

        //
        // if we already have a session to the server identified in the locator
        // then we will check if we already have the information stored in a
        // VIEW_INFO. If not then we must send the request for the attribute info
        //

        sessionInfo = FindOrCreateSession(hostName, port, &error);
        if (sessionInfo != NULL) {

            //
            // BUGBUG - IsGopherPlusSession needs to perform discovery if
            //          unknown
            //

//            if (IsGopherPlusSession(sessionInfo)) {
            if (TRUE) {

                LPSTR attributeRequest;

                //
                // convert the request to a request for attributes that the
                // gopher server understands
                //

                attributeRequest = MakeAttributeRequest(request,
                                                        (LPSTR)lpszAttribute
                                                        );
                if (attributeRequest != NULL) {

                    LPVIEW_INFO viewInfo;

                    error = GetView(sessionInfo,
                                    ViewTypeFind,
                                    attributeRequest,
                                    TRUE,   // RequestIsGopherPlus
                                    0,
                                    &viewInfo
                                    );

                    //
                    // done with attribute request buffer (created by
                    // MakeAttributeRequest)
                    //

                    DEL(attributeRequest);

                    //
                    // copy everything that came back to the caller's buffer
                    // if there's enough space
                    //

                    if (error == ERROR_SUCCESS) {

                        DWORD amountToCopy;

                        INET_ASSERT(viewInfo->BufferInfo->Flags & BI_RECEIVE_COMPLETE);

                        AcquireBufferLock(viewInfo->BufferInfo);
                        amountToCopy = viewInfo->BufferInfo->BufferLength;

                        //
                        // if the buffer contains dot-terminated info, then
                        // account for the dot
                        //

                        if ((viewInfo->BufferInfo->Flags & BI_DOT_AT_END)

                        //
                        // this *SHOULD* always be true, but just in case we
                        // have an anomalous situation, we don't want to
                        // return a negative value (i.e. a large DWORD value)
                        //

                        && (amountToCopy > GOPHER_DOT_TERMINATOR_LENGTH)) {
                            amountToCopy -= GOPHER_DOT_TERMINATOR_LENGTH;
                        }
                        if (amountToCopy <= *lpdwBufferLength) {

                            LPBYTE attributeBuffer;

                            attributeBuffer = viewInfo->BufferInfo->Buffer;

                            INET_ASSERT(attributeBuffer != NULL);

                            memcpy(lpBuffer, attributeBuffer, amountToCopy);
                        }

                        //
                        // whether we copied the data or not, indicate to the
                        // caller how much data is available
                        //

                        *lpdwBufferLength = amountToCopy;

                        //
                        // we are done with the buffer. Unlock the BUFFER_INFO
                        // and the VIEW_INFO. Both will probably be destroyed
                        //

                        ReleaseBufferLock(viewInfo->BufferInfo);
                        DereferenceView(viewInfo);
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                error = ERROR_GOPHER_NOT_GOPHER_PLUS;
            }

            //
            // dereference the session, possibly destroying it
            //

            DereferenceSession(sessionInfo);
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)

//
//DWORD
//wGopherConnect(
//    IN LPCSTR lpszServerName,
//    IN INTERNET_PORT nServerPort,
//    IN LPCSTR lpszUsername,
//    IN LPCSTR lpszPassword,
//    IN DWORD dwService,
//    IN DWORD dwFlags,
//    OUT LPHINTERNET lpConnectHandle
//    )
//
///*++
//
//Routine Description:
//
//    Creates a default gopher connection information 'object' from the
//    parameters supplied in InternetConnect()
//
//Arguments:
//
//    lpszServerName  - pointer to default gopher server
//
//    nServerPort     - default configured gopher port (0 for use default of 70)
//
//    lpszUsername    - our user's name
//
//    lpszPassword    - and password
//
//    dwService       - INTERNET_SERVICE_GOPHER
//
//    dwFlags         - unused
//
//    lpConnectHandle - where we return the pointer to the 'object'
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_NOT_ENOUGH_MEMORY
//
//--*/
//
//{
//    LPGOPHER_DEFAULT_CONNECT_INFO info;
//    DWORD error;
//
//    DEBUG_ENTER((DBG_GOPHER,
//                Dword,
//                "wGopherConnect",
//                "%q, %d, %q, %q, %d, %#x, %#x",
//                lpszServerName,
//                nServerPort,
//                lpszUsername,
//                lpszPassword,
//                dwService,
//                dwFlags,
//                lpConnectHandle
//                ));
//
//    UNREFERENCED_PARAMETER(dwService);
//    UNREFERENCED_PARAMETER(dwFlags);
//
//    info = NEW(GOPHER_DEFAULT_CONNECT_INFO);
//    if (info != NULL) {
//        error = ERROR_SUCCESS;
//        if (lpszServerName != NULL) {
//            info->HostName = NEW_STRING((LPSTR)lpszServerName);
//            if (info->HostName == NULL) {
//                error = ERROR_NOT_ENOUGH_MEMORY;
//            }
//        }
//        info->Port = nServerPort;
//        if ((lpszUsername != NULL) && (error == ERROR_SUCCESS)) {
//            info->UserName = NEW_STRING((LPSTR)lpszUsername);
//            if (info->UserName == NULL) {
//                error = ERROR_NOT_ENOUGH_MEMORY;
//            }
//        }
//        if ((lpszPassword != NULL) && (error == ERROR_NOT_ENOUGH_MEMORY)) {
//            info->Password = NEW_STRING((LPSTR)lpszPassword);
//            if (info->Password == NULL) {
//                error = ERROR_NOT_ENOUGH_MEMORY;
//            }
//        }
//    } else {
//        error = ERROR_NOT_ENOUGH_MEMORY;
//    }
//    if (error == ERROR_SUCCESS) {
//        *lpConnectHandle = (HINTERNET)info;
//    } else {
//        if (info != NULL) {
//            if (info->HostName != NULL) {
//                DEL_STRING(info->HostName);
//            }
//            if (info->UserName != NULL) {
//                DEL_STRING(info->UserName);
//            }
//            if (info->Password != NULL) {
//                DEL_STRING(info->Password);
//            }
//            DEL(info);
//        }
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//wGopherDisconnect(
//    IN HINTERNET hInternet
//    )
//
///*++
//
//Routine Description:
//
//    Undoes the work of wGopherConnect
//
//Arguments:
//
//    hInternet   - handle to object created by wGopherConnect. Actually just a
//                  pointer to GOPHER_DEFAULT_CONNECT_INFO structure
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_INTERNET_INTERNAL_ERROR
//                    hInternet does not identify a GOPHER_DEFAULT_CONNECT_INFO
//
//--*/
//
//{
//    LPGOPHER_DEFAULT_CONNECT_INFO info;
//    DWORD error;
//
//    DEBUG_ENTER((DBG_GOPHER,
//                Dword,
//                "wGopherDisconnect",
//                "%#x",
//                hInternet
//                ));
//
//    //
//    // BUGBUG - not expecting bogus pointer?!
//    //
//
//    info = (LPGOPHER_DEFAULT_CONNECT_INFO)hInternet;
//    if (info != NULL) {
//        if (info->HostName != NULL) {
//            DEL_STRING(info->HostName);
//        }
//        if (info->UserName != NULL) {
//            DEL_STRING(info->UserName);
//        }
//        if (info->Password != NULL) {
//            DEL_STRING(info->Password);
//        }
//        DEL(info);
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PRIVATE
DWORD
GetView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    IN BOOL RequestIsGopherPlus,
    IN DWORD ResponseFlags,
    OUT LPVIEW_INFO* pViewInfo
    )

/*++

Routine Description:

    Creates a 'view object'. Sends a request to the gopher server and receives
    the response. The response data is the view. Multiple simultaneous
    requests for the same data from the same server are serialized. It is
    possible that when this function terminates, the entire response may not
    have been received, but we have enough to return to the caller. In this
    case, a background thread may be actively receiving the remainder of the
    response

Arguments:

    SessionInfo         - pointer to SESSION_INFO describing the gopher server

    ViewType            - type of view being requested, File or Find

    Request             - gopher request string

    RequestIsGopherPlus - TRUE if this is a gopher+ request

    ResponseFlags       - bit-mask describing expected response buffer

    pViewInfo           - returned view info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "GetView",
                "%#x, %s, %q, %B, %#x, %#x",
                SessionInfo,
                (ViewType == ViewTypeFile) ? "File" : "Find",
                Request,
                RequestIsGopherPlus,
                ResponseFlags,
                pViewInfo
                ));

    DWORD error;
    LPVIEW_INFO viewInfo;
    BOOL viewCloned;

    //
    // find the view info that contains the results of sending Request to
    // the server identified by the session info. If this succeeds then we
    // will have added another reference to the session info
    //

    viewInfo = CreateView(SessionInfo, ViewType, Request, &error, &viewCloned);
    if (viewInfo != NULL) {

        LPBUFFER_INFO bufferInfo;

        //
        // if this is a gopher+ request then mark it in the VIEW_INFO
        //

        if (RequestIsGopherPlus) {
            viewInfo->Flags |= VI_GOPHER_PLUS;
        }

        bufferInfo = viewInfo->BufferInfo;

        INET_ASSERT(bufferInfo != NULL);

        //
        // set the expected response type (dot-terminated or not.) Only really
        // useful if request is gopher0 file
        //

        bufferInfo->Flags |= ResponseFlags;

        if (!viewCloned) {

            BOOL receiveComplete;

            //
            // if this is a directory view then we need to communicate the fact
            // that ReceiveResponse needs to allocate a buffer
            //

            if (ViewType == ViewTypeFind) {
                bufferInfo->Flags |= BI_BUFFER_RESPONSE;
            }

            //
            // the view was created. We must make the request to the gopher
            // server
            //

            error = GopherTransaction(viewInfo);

            //
            // if there were multiple simultaneous requests for the same data
            // then we must signal the request event to restart those other
            // threads. If no other threads are waiting then we can dispense
            // with the request event
            //

//            AcquireViewLock(SessionInfo, ViewType);

//            if (bufferInfo->RequestWaiters != 0) {

                //
                // the request has completed, maybe with an error. In both
                // cases, we signal the event in the BUFFER_INFO to allow
                // any concurrent requesters of the same information to
                // continue
                //

//                SetEvent(bufferInfo->RequestEvent);
//            } else {

                //
                // no other concurrent waiters. The system can have an event
                // back
                //

//                CloseHandle(bufferInfo->RequestEvent);
//                bufferInfo->RequestEvent = NULL;
//            }

//            ReleaseViewLock(SessionInfo, ViewType);

        } else {

            //
            // we no longer allow file views to be cloned - each request for a
            // file must now make a separate connection to the server
            //

            INET_ASSERT(ViewType != ViewTypeFile);

            //
            // the view was cloned. If we made the request at the same time
            // another thread was making the same request to the server then
            // wait for that other thread to signal the request event. If the
            // request event handle is NULL then we don't have to wait
            //

//            if (bufferInfo->RequestEvent != NULL) {
//                WAIT_FOR_SINGLE_OBJECT(bufferInfo->RequestEvent, error);
//            } else {
//                error = WAIT_OBJECT_0;
//            }

            //
            // if RequestEvent existed when this clone was generated then we
            // decrement the number of waiters, now that we have access to the
            // data.
            // If the number of requesters goes to zero, we grab the view lock
            // for this list. If the number of requesters is still zero then
            // we close the event handle.
            // The event handle was only required for a special purpose - to
            // hold off multiple simultaneous requesters of the same data from
            // the same server. Once the data has been retrieved, there is no
            // need to keep the event
            //

//            if (bufferInfo->RequestWaiters != 0) {
//                if (InterlockedDecrement(&bufferInfo->RequestWaiters) == 0) {

//                    AcquireViewLock(SessionInfo, ViewType);

//                    if (bufferInfo->RequestWaiters == 0) {
//                        CloseHandle(bufferInfo->RequestEvent);
//                        bufferInfo->RequestEvent = NULL;
//                    }

//                    ReleaseViewLock(SessionInfo, ViewType);
//                }
//            }
        }

        //
        // if an error occurred then dereferencing the view should destroy it
        //

        if (error != ERROR_SUCCESS) {
            viewInfo = DereferenceView(viewInfo);
        }
    }

    *pViewInfo = viewInfo;

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapia.cxx

Abstract:

    ANSI versions of Windows Internet Extensions Gopher Protocol APIs

    Contents:
        GopherCreateLocatorA
        GopherGetLocatorTypeA
        GopherFindFirstFileA
        GopherFindNextA
        GopherOpenFileA
        GopherReadFile
        GopherGetAttributeA
        GopherSendDataA
        pGfrGetUrlInfo
        pGopherGetUrlString

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Environment:

    Win32 user-level DLL

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define GOPHER_ATTRIBUTE_BUFFER_LENGTH  (4 K)   // arbitrary
#define MAX_GOPHER_SEARCH_STRING_LENGTH (1 K)   // arbitrary

// used as delimiter in creating a unique cache name to append
// searchstring or viewtype to a url
#define GOPHER_EXTENSION_DELIMITER_SZ   "<>"

DWORD
pGopherGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR    lpszTargetHost,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectLocator,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

//
// private functions
//

PRIVATE
BOOL
FGopherBeginCacheReadProcessing(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    BOOL    fIsHtmlFind
    );

PRIVATE
BOOL
FGopherCanReadFromCache(
    HINTERNET   hGopherSession
    );

PRIVATE
BOOL
FGopherBeginCacheWriteProcessing(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    BOOL    fIsHtmlFind
    );

PRIVATE
BOOL
FGopherCanWriteToCache(
    HINTERNET   hGopherSession
    );

DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );


PRIVATE
BOOL
FIsGopherExpired(
    HINTERNET hGopher,
    LPCACHE_ENTRY_INFO lpCEI
    );

//
// functions
//


INTERNETAPI_(BOOL) GopherCreateLocatorA(
    IN LPCSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszDisplayString OPTIONAL,
    IN LPCSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Creates a gopher locator string. The string should be an opaque type so far
    as the app is concerned.

    This API mainly exists for situations where the app may want to request
    explicit information, without first having contacted a server and asked for
    a list of available information

Arguments:

    lpszHost            - Name of the host where the gopher server lives

    nServerPort         - Port at which the gopher server listens. The default
                          value 70 will be substituted if 0 is passed in

    lpszDisplayString   - Optional display string. Mainly a place holder. Can be
                          NULL, or NUL string, in which case a default string
                          will be substituted (just \t)

    lpszSelectorString  - The string used to select the item at the gopher
                          server. Can be NULL

    dwGopherType        - Tells us that the item to return is a file or
                          directory, graphics image, audio file, etc...
                          If 0, the default GOPHER_TYPE_DIRECTORY is used

    lpszLocator         - Place where the locator is returned

    lpdwBufferLength    - IN: Length of Buffer
                          OUT: Required length of Buffer only if
                          ERROR_INSUFFICIENT_BUFFER returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError()/InternetGetLastResponseInfo() to
                  get more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherCreateLocatorA",
                     "%q, %d, %q, %q, %#x, %#x, %#x [%d]",
                     lpszHost,
                     nServerPort,
                     lpszDisplayString,
                     lpszSelectorString,
                     dwGopherType,
                     lpszLocator,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD requiredLength;
    char portBuffer[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    char gopherChar;
    DWORD displayStringLength;
    DWORD selectorStringLength;
    DWORD hostNameLength;
    DWORD portLength;
    BOOL gopherPlus;
    BOOL success;

    //
    // default is directory, ordinary gopher (i.e. not gopher+)
    //

    if (dwGopherType == 0) {
        dwGopherType = GOPHER_TYPE_DIRECTORY;
    }

    gopherChar = GopherTypeToChar(dwGopherType);

    //
    // validate parameters
    //

    if (IsBadStringPtr(lpszHost, MAX_GOPHER_HOST_NAME)
    || (*lpszHost == '\0')
    || (ARGUMENT_PRESENT(lpszDisplayString)
        && IsBadStringPtr(lpszDisplayString, MAX_GOPHER_DISPLAY_TEXT))
    || (ARGUMENT_PRESENT(lpszSelectorString)
        && IsBadStringPtr(lpszSelectorString, MAX_GOPHER_SELECTOR_TEXT))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszLocator)
        && IsBadWritePtr(lpszLocator, *lpdwBufferLength))
    || (gopherChar == INVALID_GOPHER_TYPE)) {

        DEBUG_ERROR(API, ERROR_INVALID_PARAMETER);

        DEBUG_LEAVE(FALSE);

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // ensure that if the caller passed in a NULL locator pointer then the size
    // of the buffer is 0
    //

    if (!ARGUMENT_PRESENT(lpszLocator)) {
        *lpdwBufferLength = 0;
    }

    if (nServerPort == 0) {
        nServerPort = INTERNET_DEFAULT_GOPHER_PORT;
    }

    //ULTOA(nServerPort, portBuffer, 10);
    wsprintf (portBuffer, "%u", nServerPort);


    if (!(ARGUMENT_PRESENT(lpszDisplayString) && (*lpszDisplayString != '\0'))) {
        lpszDisplayString = DEFAULT_GOPHER_DISPLAY_STRING;
    }

    if (!(ARGUMENT_PRESENT(lpszSelectorString) && (*lpszSelectorString != '\0'))) {
        lpszSelectorString = DEFAULT_GOPHER_SELECTOR_STRING;
    }

    gopherPlus = IS_GOPHER_PLUS(dwGopherType);

    displayStringLength = lstrlen(lpszDisplayString);
    selectorStringLength = lstrlen(lpszSelectorString);
    hostNameLength = lstrlen(lpszHost);
    portLength = lstrlen(portBuffer);

    //
    // calculate how many bytes of buffer required for the locator
    //

    requiredLength = sizeof(char)           // descriptor character
                   + displayStringLength
                   + sizeof(char)           // TAB
                   + selectorStringLength
                   + sizeof(char)           // TAB
                   + hostNameLength
                   + sizeof(char)           // TAB
                   + portLength
                   + (gopherPlus ? 2 : 0)   // TAB, '+'
                   + sizeof(char)           // CR
                   + sizeof(char)           // LF
                   + sizeof(char)           // EOS
                   ;

    //
    // and if the caller supplied at least that much, then create the locator,
    // else just return the size of buffer needed
    //

    if (*lpdwBufferLength >= requiredLength) {
        *lpszLocator++ = gopherChar;

        CopyMemory(lpszLocator, lpszDisplayString, displayStringLength);
        lpszLocator += displayStringLength;
        *lpszLocator++ = '\t';

        CopyMemory(lpszLocator, lpszSelectorString, selectorStringLength);
        lpszLocator += selectorStringLength;
        *lpszLocator++ = '\t';

        CopyMemory(lpszLocator, lpszHost, hostNameLength);
        lpszLocator += hostNameLength;
        *lpszLocator++ = '\t';

        CopyMemory(lpszLocator, portBuffer, portLength);
        lpszLocator += portLength;

        if (gopherPlus) {
            *lpszLocator++ = '\t';
            *lpszLocator++ = '+';
        }

        *lpszLocator++ = '\r';
        *lpszLocator++ = '\n';
        *lpszLocator = '\0';

        //
        // in the case of a successful copy, we return *lpdwBufferLength as the
        // number of characters in the string, as if returned by lstrlen()
        //

        --requiredLength;
        success = TRUE;
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);

        DEBUG_ERROR(API, ERROR_INSUFFICIENT_BUFFER);

        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) GopherGetLocatorTypeA(
    IN LPCSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    )

/*++

Routine Description:

    Returns the type of the locator

Arguments:

    lpszLocator     - pointer to locator to return type of

    lpdwGopherType  - pointer to DWORD where type is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Check GetLastError() for more information:
                    ERROR_INVALID_PARAMETER
                    ERROR_GOPHER_UNKNOWN_LOCATOR

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetLocatorTypeA",
                     "%q, %#x",
                     lpszLocator,
                     lpdwGopherType
                     ));

    DWORD error;

    if (IsValidLocator(lpszLocator, MAX_GOPHER_LOCATOR_LENGTH)
    && !IsBadWritePtr(lpdwGopherType, sizeof(*lpdwGopherType))) {

        DWORD gopherType;

        gopherType = GopherCharToType(*lpszLocator);
        if (gopherType != INVALID_GOPHER_CHAR) {
            gopherType |= IsGopherPlus(lpszLocator)
                            ? GOPHER_TYPE_GOPHER_PLUS
                            : 0
                            ;
            *lpdwGopherType = gopherType;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_GOPHER_UNKNOWN_LOCATOR;
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }

    DWORD success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(HINTERNET) GopherFindFirstFileA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator OPTIONAL,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAA lpBuffer OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Used to return directory/hierarchy information from the gopher server

Arguments:

    hGopherSession      - identifies gopher server context to use - either via
                          gateway, or straight to internet

    lpszLocator         - descriptor of information to get. If NULL then we get
                          the default directory at the server

    lpszSearchString    - if this request is to an search server, this
                          parameter specifies the string(s) to search for. If
                          Locator does not specify a search server then
                          the paraneter is not used, but it IS validated

    lpBuffer            - pointer to user-allocated buffer in which to return
                          info. This parameter may be NULL, in which case if
                          this function returns success, then the results of
                          the request will be returned via InternetFindNextFile()

    dwFlags             - controlling caching, etc.

    dwContext           - app-supplied context value for use in call-backs

Return Value:

    HINTERNET
        Success - valid handle value
                    If lpBuffer was not NULL, a GOPHER_FIND_DATA structure has
                    been returned in lpBuffer. Use InternetFindNextFile() to
                    retrieve the remainder of the directory entries.
                    If lpBuffer was NULL, then this call is still successful,
                    but all directory entries (including the first) will be
                    returned via InternetFindNextFile()

        Failure - NULL
                    Use GetLastError()/InternetGetLastResponseInfo() to get
                    more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherFindFirstFileA",
                     "%#x, %q, %q, %#x, %#x, %$x",
                     hGopherSession,
                     lpszLocator,
                     lpszSearchString,
                     lpBuffer,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET findHandle;
    HINTERNET hConnectMapped = NULL;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // if this is the async worker thread then what we think is hGopherSession
    // is really the find handle object. Get the handles in the right variables
    //

    if (lpThreadInfo->IsAsyncWorkerThread
    && (lpThreadInfo->NestedRequests == 1)) {
        hObject = hGopherSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        findHandle = hObjectMapped;
        hConnectMapped = ((FTP_FIND_HANDLE_OBJECT *)findHandle)->GetParent();
    } else {

        //
        // map the handle
        //

        hObject = hGopherSession;
        error = MapHandleToAddress(hGopherSession, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        hConnectMapped = hObjectMapped;
        findHandle = NULL;
    }

    //
    // set the context info and clear the error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hObject, hObjectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters - check handle and discover sync/async and
    // local/remote
    //

    BOOL isLocal, isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeGopherConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // skip rest of validation if we're in the async worker thread context -
    // we already did this
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    || (lpThreadInfo->NestedRequests > 1)) {
        if ((ARGUMENT_PRESENT(lpBuffer)
            && IsBadWritePtr(lpBuffer, sizeof(GOPHER_FIND_DATA)))
        || (ARGUMENT_PRESENT(lpszSearchString)

            //
            // BUGBUG - limit on search string?
            //

            && IsBadStringPtr(lpszSearchString,
                              MAX_GOPHER_SEARCH_STRING_LENGTH))) {

            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        if (ARGUMENT_PRESENT(lpszLocator)) {

            //
            // BUGBUG - limit on locator?
            //

            if (IsValidLocator(lpszLocator, MAX_GOPHER_LOCATOR_LENGTH)) {

                DWORD locatorType;

                locatorType = GopherCharToType(*lpszLocator);

                //
                // we only allow directories and index/cso servers to be searched
                //

                if (  !IS_GOPHER_DIRECTORY(locatorType)
                   && !IS_GOPHER_SEARCH_SERVER(locatorType)) {
                    error = ERROR_GOPHER_INCORRECT_LOCATOR_TYPE;
                    goto quit;
                }

                //
                // if this is an search server then there must be search strings
                // - the server will only tell us that we need to supply them,
                // so no point in going to the expense of sending a request just
                // to get this response
                //

                if (  IS_GOPHER_SEARCH_SERVER (locatorType)
                   && (  !ARGUMENT_PRESENT(lpszSearchString)
                      || (*lpszSearchString == '\0'))) {

                    error = ERROR_INVALID_PARAMETER;
                    goto quit;
                }
            } else {
                error = ERROR_GOPHER_INVALID_LOCATOR;
                goto quit;
            }
        }

        //
        // create the handle object now. This can be used to cancel the async
        // operation, or the sync operation if InternetCloseHandle() is called
        // from a different thread
        //

        INET_ASSERT(findHandle == NULL);

        error = RMakeGfrFindObjectHandle(hConnectMapped,
                                         &findHandle,
                                         (CLOSE_HANDLE_FUNC)wGopherFindClose,
                                         dwContext
                                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle(),
                                 findHandle
                                 );

        //
        // get the OFFLINE flag whether set globally (@ InternetOpen() level) or
        // locally (for this function)
        //

        if ((((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->GetInternetOpenFlags()
             | dwFlags) & INTERNET_FLAG_OFFLINE) {
            dwFlags |= INTERNET_FLAG_OFFLINE;
        }

try_again:

        //
        // check to see if the data is in the cache. Do it here so that we don't
        // waste any time going async if we already have the data locally
        //

        //
        // can't do it for default locator
        //

        if ((lpszLocator != NULL)
        && FGopherBeginCacheReadProcessing(findHandle,
                                           lpszLocator,
                                           lpszSearchString,
                                           dwFlags,
                                           dwContext,
                                           ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->IsHtmlFind()
                                           )) {

            error = ERROR_SUCCESS;

            if (lpBuffer) {

                DWORD dwBytes = sizeof(GOPHER_FIND_DATA);

                error = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->ReadCache(
                            (LPBYTE)lpBuffer,
                            sizeof(GOPHER_FIND_DATA),
                            &dwBytes
                            );
            }
            if (error == ERROR_SUCCESS) {
                goto quit;
            } else {
                ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->EndCacheRetrieval();
            }
        }

        if (dwFlags & INTERNET_FLAG_OFFLINE) {

            //
            // we are supposed to be in offline mode
            // if we are not reading from the cache, let us bailout
            //

            if (!((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->IsCacheReadInProgress()) {
                error = ERROR_PATH_NOT_FOUND;
                goto quit;
            }
        }
    }

    //
    // if the handle was created for async I/O AND there is a non-zero context
    // value AND we are not in the context of an async worker thread then queue
    // the request
    //

    if (isAsync
    && (dwContext != INTERNET_NO_CALLBACK)
    && !lpThreadInfo->IsAsyncWorkerThread) {

        // MakeAsyncRequest
        CFsm_GopherFindFirstFile * pFsm;

        pFsm = new CFsm_GopherFindFirstFile(((HANDLE_OBJECT *)findHandle)->GetPseudoHandle(),
                                             dwContext,
                                             lpszLocator,
                                             lpszSearchString,
                                             lpBuffer,
                                             dwFlags
                                             );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

    //
    // make the request
    //

    char defaultLocator[MAX_GOPHER_LOCATOR_LENGTH * 2];

    //
    // if we were given a NULL locator then create a locator to access
    // the default directory at the configured default server.
    //
    // N.B. This only gives us gopher access (i.e. not gopher+)
    //

    if (!ARGUMENT_PRESENT(lpszLocator)) {

        BOOL ok;
        DWORD defaultLocatorLength;

        defaultLocatorLength = sizeof(defaultLocator);
        ok = GopherCreateLocator(
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetHostName(),
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetHostPort(),
            NULL,
            NULL,
            GOPHER_TYPE_DIRECTORY,
            defaultLocator,
            &defaultLocatorLength
            );
        if (ok) {
            lpszLocator = defaultLocator;
        } else {

            //
            // set error to ERROR_SUCCESS so that cleanup doesn't set it
            // again (already set by GopherCreateLocator)
            //

            error = ERROR_SUCCESS;
            goto quit;
        }
    }

    HINTERNET protocolFindHandle;

    error = wGopherFindFirst(lpszLocator,
                             lpszSearchString,
                             lpBuffer,
                             &protocolFindHandle
                             );
    if (error == ERROR_SUCCESS) {
        ((GOPHER_FIND_HANDLE_OBJECT *)findHandle)->SetFindHandle(protocolFindHandle);

        //
        // if we succeeded in getting the data, add it to the cache. Don't worry
        // about errors if cache write fails
        //

        if (FGopherBeginCacheWriteProcessing(
            findHandle,
            lpszLocator,
            lpszSearchString,
            0,
            dwContext,
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->IsHtmlFind())) {

            if (lpBuffer != NULL) {

                DWORD dwBytes = sizeof(GOPHER_FIND_DATA);
                DWORD errorCache;

                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)findHandle)->WriteCache(
                    (LPBYTE)lpBuffer,
                    sizeof(GOPHER_FIND_DATA)
                    );
                if (errorCache != ERROR_SUCCESS) {
                    InbGopherLocalEndCacheWrite(findHandle,
                                                NULL,
                                                (errorCache == ERROR_NO_MORE_FILES)
                                                );
                }
            }
        }
    } else if (IsOffline() && !(dwFlags & INTERNET_FLAG_OFFLINE)) {

        //
        // if we failed because we went offline before retrieving it from the
        // cache, then try from the cache again
        //

        dwFlags |= INTERNET_FLAG_OFFLINE;
        goto try_again;
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    //
    // if we got an error then set this thread's error variable and return
    // NULL. The app must call GetLastError()
    //

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (findHandle != NULL)) {
            InternetCloseHandle(((HANDLE_OBJECT *)findHandle)->GetPseudoHandle());
        }

        //
        // error situation, or request is being processed asynchronously: return
        // a NULL handle
        //

        findHandle = NULL;
    } else {

        //
        // success - return generated pseudo-handle
        //

        findHandle = ((HANDLE_OBJECT *)findHandle)->GetPseudoHandle();
    }

    if ((hConnectMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    if ( error != ERROR_SUCCESS ) {
        SetLastError(error);
    }

    DEBUG_LEAVE_API(findHandle);

    return findHandle;
}


BOOL
GopherFindNextA(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpBuffer
    )

/*++

Routine Description:

    Continues a search created by GopherFindFirstFile(). The same search
    criteria as specfied in GopherFindFirstFile() will be applied

    Assumes:    1. We are being called from InternetFindNextFile() which has
                   already validated the parameters, set the thread variables,
                   and cleared the object last error info

Arguments:

    hFind       - search handle created by call to GopherFindFirstFile()

    lpBuffer    - pointer to user-allocated buffer in which to return info

Return Value:

    BOOL
        TRUE    - Information has been returned in lpBuffer

        FALSE   - Use GetLastError()/InternetGetLastResponseInfo() to get nore
                  information

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "GopherFindNextA",
                 "%#x, %#x",
                 hFind,
                 lpBuffer
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error;

    //
    // find path from internet handle
    //

    BOOL isLocal;
    BOOL isAsync, fIsHtml = FALSE;

    error = RIsHandleLocal(hFind,
                           &isLocal,
                           &isAsync,
                           TypeGopherFindHandle
                           );
    if (error != ERROR_SUCCESS) {

        //
        // if the handle is actually a HTML gopher find handle, then we allow
        // the operation. Note: we can do this because GopherFindNext() is not
        // exported, so a rogue app cannot call this function after opening the
        // handle via InternetOpenUrl()
        //

        error = RIsHandleLocal(hFind,
                               &isLocal,
                               &isAsync,
                               TypeGopherFindHandleHtml
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        fIsHtml = TRUE;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->IsCacheReadInProgress()) {
        DWORD   dwLen = sizeof(GOPHER_FIND_DATA);
        error = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->ReadCache((LPBYTE)lpBuffer,
                                                            dwLen,
                                                            &dwLen);
        if ((error == ERROR_SUCCESS) && !dwLen) {
            error = ERROR_NO_MORE_FILES;
        }
        goto quit;
    }

    HINTERNET localHandle;

    error = RGetLocalHandle(hFind, &localHandle);
    if (error == ERROR_SUCCESS) {
        error = wGopherFindNext(localHandle, lpBuffer);
    }

    DWORD errorCache;

    errorCache = error;

    if (error == ERROR_SUCCESS) {
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->IsCacheWriteInProgress()) {
            if (!fIsHtml) {
                errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFind)->WriteCache((LPBYTE)lpBuffer,
                                                                sizeof(GOPHER_FIND_DATA));
            }
        }

    }
    if (errorCache != ERROR_SUCCESS) {
        if (!fIsHtml) {
            InbGopherLocalEndCacheWrite(hFind,
                                        NULL,
                                        (errorCache == ERROR_NO_MORE_FILES)
                                        );
        }
    }

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        success = FALSE;
    }

    DEBUG_LEAVE(success);

    SetLastError(error);

    return success;
}


INTERNETAPI_(HINTERNET) GopherOpenFileA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    'Opens' a file at a gopher server. Right now this means transferring the
    file locally, keeping it in a buffer

Arguments:

    hGopherSession  - defines where to go for the file - gateway or internet

    lpszLocator     - descriptor of file to get

    lpszView        - optional type of file to read as MIME content-type

    dwFlags         - open options

    dwContext       - app-supplied context value for use in call-backs

Return Value:

    HINTERNET
        Success - valid handle value

        Failure - NULL
                    Use GetLastError()/InternetGetLastResponseInfo() to get
                    more information

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherOpenFileA",
                     "%#x, %q, %q, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszView,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET fileHandle = NULL;
    HINTERNET hConnectMapped = NULL;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD error;
    DWORD nestingLevel = 0;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // need the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // if this is the async worker thread then what we think is hGopherSession
    // is really the file handle object. Get the handles in the right variables
    //

    if (lpThreadInfo->IsAsyncWorkerThread
    && (lpThreadInfo->NestedRequests == 1)) {
        hObject = hGopherSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        fileHandle = hObjectMapped;
        hConnectMapped = ((FTP_FIND_HANDLE_OBJECT *)fileHandle)->GetParent();
    } else {

        //
        // map the handle
        //

        hObject = hGopherSession;
        error = MapHandleToAddress(hObject, (LPVOID *)&hObjectMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hObjectMapped == NULL)) {
            goto quit;
        }
        hConnectMapped = hObjectMapped;
    }

    //
    // handle must be valid type
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeGopherConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // set the context info & clear the error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hObject, hObjectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // if this is an async request and we're in the context of an async worker
    // thread then skip the rest of parameter validation - it was already done
    // when the request was originally queued
    //

    if (isAsync
    && lpThreadInfo->IsAsyncWorkerThread
    && (lpThreadInfo->NestedRequests == 1)) {
        goto synchronous_path;
    }

    //
    // validate parameters - locator must identify a file (and be a valid
    // locator), and the flags parameter cannot contain any undefined flags.
    // lpszView must be NULL or valid string
    //

    if (dwFlags & ~INTERNET_FLAGS_MASK) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (ARGUMENT_PRESENT(lpszView)) {

        int len;

        __try {
            len = lstrlen(lpszView);
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    error = TestLocatorType(lpszLocator, GOPHER_FILE_MASK);
    if (error != ERROR_SUCCESS) {

        //
        // TestLocatorType uses ERROR_INVALID_FUNCTION to mean Locator is not
        // the specified type. Map this to ERROR_SUCCESS and NOT SUCCESS
        //

        if (error == ERROR_INVALID_FUNCTION) {
            error = ERROR_GOPHER_NOT_FILE;
        }
        goto quit;
    }

    //
    // create the handle object now. This can be used to cancel the async
    // operation, or the sync operation if InternetCloseHandle() is called
    // from a different thread
    //

    fileHandle = NULL;
    error = RMakeGfrFileObjectHandle(hConnectMapped,
                                     &fileHandle,
                                     (CLOSE_HANDLE_FUNC)wGopherCloseHandle,
                                     dwContext
                                     );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // this new handle will be used in callbacks
    //

    _InternetSetObjectHandle(lpThreadInfo,
                             ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                             fileHandle
                             );

    //
    // get the OFFLINE flag whether set globally (@ InternetOpen() level) or
    // locally (for this function)
    //

    if ((((GOPHER_FILE_HANDLE_OBJECT *)fileHandle)->GetInternetOpenFlags()
         | dwFlags) & INTERNET_FLAG_OFFLINE) {
        dwFlags |= INTERNET_FLAG_OFFLINE;
    }

try_again:

    //
    // check to see if the data is in the cache
    //

    if (FGopherBeginCacheReadProcessing(fileHandle,
                                        lpszLocator,
                                        lpszView,
                                        dwFlags,
                                        dwContext,
                                        FALSE)) {
        error = ERROR_SUCCESS;
        goto quit;
    } else if (dwFlags & INTERNET_FLAG_OFFLINE) {

        //
        // we are supposed to be in offline mode, let us bailout
        //

        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    //
    // if we're here then we know we're not in the context of an async worker
    // thread, so if the request is async, we queue it and get out
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (dwContext != INTERNET_NO_CALLBACK))
    {
        // MakeAsyncRequest
        CFsm_GopherOpenFile * pFsm;

        pFsm = new CFsm_GopherOpenFile(((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle(),
                                        dwContext,
                                        lpszLocator,
                                        lpszView,
                                        dwFlags
                                        );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

synchronous_path:

    //
    // local call, call the worker directly.
    //

    HINTERNET protocolFileHandle;

    error = wGopherOpenFile(lpszLocator,
                            lpszView,
                            &protocolFileHandle
                            );
    if (error == ERROR_SUCCESS) {
        ((GOPHER_FILE_HANDLE_OBJECT *)fileHandle)->SetFileHandle(protocolFileHandle);

        //
        // don't worry about errors if cache write does not begin
        //

        FGopherBeginCacheWriteProcessing(fileHandle,
                                         lpszLocator,
                                         lpszView,
                                         dwFlags,
                                         dwContext,
                                         FALSE
                                         );
    } else if (IsOffline() && !(dwFlags & INTERNET_FLAG_OFFLINE)) {

        //
        // if we failed because we went offline before retrieving it from the
        // cache, then try from the cache again
        //

        dwFlags |= INTERNET_FLAG_OFFLINE;
        goto try_again;
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (fileHandle != NULL)) {
            InternetCloseHandle(((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle());
        }

        //
        // error situation, or request is being processed asynchronously: return
        // a NULL handle
        //

        fileHandle = NULL;
    } else {

        //
        // success - return generated pseudo-handle
        //

        fileHandle = ((HANDLE_OBJECT *)fileHandle)->GetPseudoHandle();
    }

    if ((hConnectMapped != NULL) && fDeref ) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    DEBUG_LEAVE_API(fileHandle);

    return fileHandle;
}


BOOL
GopherReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Reads from a file opened by GopherOpenFile into the caller's buffer. The
    number of bytes returned is the smaller of dwNumberOfBytesToRead and the
    number of bytes between the current file pointer and the end of the file

    Assumes:    1. We are being called from InternetReadFile() which has
                   already validated the parameters, handled the zero byte
                   read case, set the thread variables, and cleared the object
                   last error info

Arguments:

    hFile                   - file handle created by GopherOpenFile

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - pointer to length of Buffer

    lpdwNumberOfBytesRead   - number of bytes copied into Buffer

Return Value:

    BOOL
        TRUE    - lpdwNumberOfBytesRead contains amount of data written to
                  lpBuffer

        FALSE   - use GetLastError()/InternetGetLastResponseInfo() to get more
                  info

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "GopherReadFile",
                 "%#x, %#x, %d, %#x",
                 hFile,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error;

    //
    // find path from file handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFile,
                           &isLocal,
                           &isAsync,
                           TypeGopherFileHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (((GOPHER_FILE_HANDLE_OBJECT *)hFile)->IsCacheReadInProgress()) {
        error = ((GOPHER_FILE_HANDLE_OBJECT *)hFile)->ReadCache((LPBYTE)lpBuffer,
                                                  dwNumberOfBytesToRead,
                                                  lpdwNumberOfBytesRead
                                                  );
        if (!*lpdwNumberOfBytesRead || (error != ERROR_SUCCESS)) {
            // Don't end cache retrieval. So any extraneous reads
            // continue down this path. bug #9086
//            ((GOPHER_FILE_HANDLE_OBJECT *)hFile)->EndCacheRetrieval();
        }

        // quit whether we succeed or we fail

        goto quit;
    }

    HINTERNET localHandle;

    error = RGetLocalHandle(hFile, &localHandle);
    if (error == ERROR_SUCCESS) {
        error = wGopherReadFile(localHandle,
                                (LPBYTE)lpBuffer,
                                dwNumberOfBytesToRead,
                                lpdwNumberOfBytesRead
                                );
    }

    if (error == ERROR_SUCCESS) {
        DWORD   errorCache;
        if (((GOPHER_FILE_HANDLE_OBJECT *)hFile)->IsCacheWriteInProgress()) {

            if(!*lpdwNumberOfBytesRead) {

                DEBUG_PRINT(GOPHER,
                            INFO,
                            ("Cache write complete\r\n"
                            ));

                errorCache = InbGopherLocalEndCacheWrite(hFile, NULL, TRUE);

                INET_ASSERT(error == ERROR_SUCCESS);

                goto quit;
            }

            INET_ASSERT(((GOPHER_FILE_HANDLE_OBJECT *)hFile)->IsCacheReadInProgress()==FALSE);

            if (((GOPHER_FILE_HANDLE_OBJECT *)hFile)->WriteCache((LPBYTE)lpBuffer,
                                                   *lpdwNumberOfBytesRead
                                                   ) != ERROR_SUCCESS) {

                DEBUG_PRINT(GOPHER,
                            ERROR,
                            ("Error in Cache write\n"
                            ));

                errorCache = InbGopherLocalEndCacheWrite(hFile, NULL, FALSE);

                INET_ASSERT(error == ERROR_SUCCESS);

            }
        }

    }

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        success = TRUE;
    } else {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);

    return success;
}


INTERNETAPI_(BOOL) GopherGetAttributeA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Gets an attribute from a server

    BUGBUG - it should be possible for a caller to specify e.g. "+VIEWS+ABSTRACT"
             (according to gopher plus documentation) and get both types back

Arguments:

    hGopherSession          - identifies the gopher session object

    lpszLocator             - pointer to locator identifying item to get
                              attribute for

    lpszAttributeName       - name of attribute to return. May be NULL,
                              meaning return everything

    lpBuffer                - pointer to buffer where attributes are to be
                              returned

    dwBufferLength          - length of buffer

    lpdwCharactersReturned  - pointer to variable which will receive the
                              number of bytes in lpBuffer on output (if no
                              error occurs)

    lpfnEnumerator          - optional enumerator. If supplied, we return an
                              enumerated series of GOPHER_ATTRIBUTE_TYPE
                              items, else we just return the info in the
                              caller's buffer

    dwContext               - app-supplied context value for use in call-backs

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Use GetLastError()/InternetGetLastResponseInfo() for
                  more information

--*/

{
#if !defined(GOPHER_ATTRIBUTE_SUPPORT)

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;

#else

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetAttributeA",
                     "%#x, %q, %q, %#x, %d, %#x, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszAttributeName,
                     lpBuffer,
                     dwBufferLength,
                     lpdwCharactersReturned,
                     lpfnEnumerator,
                     dwContext
                     ));

    DWORD error;
    DWORD gopherType;
    LPSTR gopherPlusInfo;
    DWORD categoryId;
    DWORD attributeId;
    DWORD attributeLength;
    LPBYTE attributeBuffer = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD bufferSize;
    HINTERNET hMapped = NULL;
    BOOL fDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(hGopherSession, (LPVOID *)&hMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hMapped == NULL)) {
        goto quit;
    }

    //
    // set the call context info & clear the error variables
    //

    _InternetSetObjectHandle(lpThreadInfo, hGopherSession, hMapped);
    _InternetSetContext(lpThreadInfo, dwContext);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle is invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle on all paths
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hMapped,
                           &isLocal,
                           &isAsync,
                           TypeGopherConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we're in the async worker thread context then we've already validated
    // the parameters - skip validation and go straight to local/remote path
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        goto synchronous_path;
    }

    //
    // validate parameters
    //

    if (!IsValidLocator(lpszLocator, MAX_GOPHER_LOCATOR_LENGTH)

    //
    // we say Buffer must be >= MIN_GOPHER_ATTRIBUTE_LENGTH to give us a chance
    // of returning enumerated attributes
    //

    || (dwBufferLength < MIN_GOPHER_ATTRIBUTE_LENGTH)
    || IsBadWritePtr(lpBuffer, dwBufferLength)
    || IsBadWritePtr(lpdwCharactersReturned, sizeof(*lpdwCharactersReturned))
    || ARGUMENT_PRESENT(lpfnEnumerator) && IsBadCodePtr((FARPROC)lpfnEnumerator)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // crack open the locator. We want the type and to know if its a gopher+
    // locator. Note that we could *really* accept a gopher0 locator if the
    // server identified therein was actually a gopher+ server, but that
    // would require more work just to identify whether we could proceed or
    // not. If the caller doesn't supply a gopher+ locator then 1) the caller
    // supplied their own locator and it won't be painful to recreate a
    // locator of the correct type, or 2) the locator was returned from a
    // previous find first/find next call and therefore we are justified in
    // refusing the request
    //

    CrackLocator(lpszLocator,
                 &gopherType,
                 NULL,  // DisplayString
                 NULL,  // DisplayStringLength
                 NULL,  // SelectorString
                 NULL,  // SelectorStringLength
                 NULL,  // HostName
                 NULL,  // HostNameLength
                 NULL,  // GopherPort
                 &gopherPlusInfo
                 );

    //
    // the locator must identify a gopher+ item - i.e. there must at least be a
    // "\t+" after the gopher server port number in the locator
    //

    if (!gopherPlusInfo) {
        error = ERROR_GOPHER_NOT_GOPHER_PLUS;
        goto quit;
    }

    //
    // and must be a file or directory
    //
    // BUGBUG - I can't find a gopher+ index server. It may be wrong to preclude
    //          this type from getting attributes. Likewise for telnet sessions,
    //          TN3270 sessions, etc. etc.?
    //

    if (!(IS_GOPHER_FILE(gopherType) || IS_GOPHER_DIRECTORY(gopherType))) {
        error = ERROR_GOPHER_INCORRECT_LOCATOR_TYPE;
        goto quit;
    }

    //
    // convert a NULL string to a NULL pointer, indicating that the caller wants
    // all available attributes for the locator
    //

    if (ARGUMENT_PRESENT(lpszAttributeName) && (*lpszAttributeName == '\0')) {
        lpszAttributeName = NULL;
    }

    //
    // we don't allow the app to request the +INFO attribute - we would have to
    // return it as a GOPHER_FIND_DATA which is already catered for by
    // GopherFindFirstFile()/GopherFindNext()
    //

    MapAttributeToIds(lpszAttributeName, &categoryId, &attributeId);
    if (categoryId == GOPHER_CATEGORY_ID_INFO) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // queue async request if that's what we're asked to do. We know we're not
    // in the async worker thread context at this point
    //

    INET_ASSERT(!lpThreadInfo->IsAsyncWorkerThread);

    if (isAsync && (dwContext != INTERNET_NO_CALLBACK))
    {
        // MakeAsyncRequest
        CFsm_GopherGetAttribute * pFsm;

        pFsm = new CFsm_GopherGetAttribute(hGopherSession, dwContext, lpszLocator, lpszAttributeName, lpBuffer,
                                            dwBufferLength, lpdwCharactersReturned, lpfnEnumerator );

        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fDeref = FALSE;
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

synchronous_path:

    //
    // we will allocate a buffer to receive the attributes into. Since we
    // won't be growing the buffer, we have to loop until we receive all
    // attribute information, or until an error occurs
    //

    bufferSize = GOPHER_ATTRIBUTE_BUFFER_LENGTH;
    error = ERROR_INSUFFICIENT_BUFFER;
    while (error == ERROR_INSUFFICIENT_BUFFER) {

        //
        // we need to allocate an intermediate buffer to receive the
        // attributes into, for two reasons: 1) we don't return the +INFO
        // attribute, 2) we probably need to filter the returned attributes
        // before returning the requested attributes to the caller
        //

        attributeBuffer = NEW_MEMORY(bufferSize, BYTE);
        if (attributeBuffer != NULL) {
            attributeLength = bufferSize;
            error = wGopherGetAttribute(lpszLocator,
                                        lpszAttributeName,
                                        attributeBuffer,
                                        &attributeLength
                                        );

        } else {

            DEBUG_PRINT(GOPHER,
                        ERROR,
                        ("failed to allocate %d byte attribute buffer\n",
                        GOPHER_ATTRIBUTE_BUFFER_LENGTH
                        ));

            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we have tried up to 64K then something serious has gone wrong.
        // Return an internal error (BUGBUG?)
        //

        if (error == ERROR_INSUFFICIENT_BUFFER) {
            if (bufferSize >= 64 K) {
                error = ERROR_INTERNET_INTERNAL_ERROR;
            } else {
                DEL(attributeBuffer);
                bufferSize += GOPHER_ATTRIBUTE_BUFFER_LENGTH;

                DEBUG_PRINT(GOPHER,
                            WARNING,
                            ("attribute buffer too small: trying %d\n",
                            bufferSize
                            ));

            }
        }
    }
    if (error == ERROR_SUCCESS) {

        //
        // we successfully got a buffer of attributes. Return the attributes
        // requested, either in the user buffer or via the enumerator
        //

        error = GetAttributes(lpfnEnumerator,
                              categoryId,
                              attributeId,
                              lpszAttributeName,
                              (LPSTR)attributeBuffer,
                              attributeLength,
                              lpBuffer,
                              dwBufferLength,
                              lpdwCharactersReturned
                              );
    }
    if (attributeBuffer != NULL) {
        DEL(attributeBuffer);
    }

quit:

    BOOL success;

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    } else {
        success = TRUE;
    }

    if ((hMapped != NULL) && fDeref) {
        DereferenceObject((LPVOID)hMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;

#endif
}

//
//INTERNETAPI_(BOOL) GopherSendDataA(
//    IN HINTERNET hGopherSession,
//    IN LPCSTR lpszLocator,
//    IN LPCSTR lpszBuffer,
//    IN DWORD dwNumberOfCharactersToSend,
//    OUT LPDWORD lpdwNumberOfCharactersSent,
//    IN DWORD dwContext
//    )
//
///*++
//
//Routine Description:
//
//    Sends arbitrary text to a gopher server. This function is used primarily
//    for returning the results of a gopher+ ASK item
//
//Arguments:
//
//    hGopherSession              - identifies the gopher session object
//
//    lpszLocator                 - pointer to locator identifying item to send
//                                  data for
//
//    lpszBuffer                  - pointer to buffer containing data to send
//
//    dwNumberOfCharactersToSend  - number of bytes in lpszBuffer
//
//    lpdwNumberOfCharactersSent  - pointer to returned number of bytes sent
//
//    dwContext                   - app-supplied context value for use in call-backs
//
//Return Value:
//
//    BOOL
//        Success - TRUE
//
//        Failure - FALSE. Call GetLastError()/InternetGetLastResponseInfo() for
//                  more information
//
//--*/
//
//{
//    DEBUG_ENTER_API((DBG_API,
//                     Bool,
//                     "GopherSendDataA",
//                     "%#x, %q, %#x, %d, %#x, %#x",
//                     hGopherSession,
//                     lpszLocator,
//                     lpszBuffer,
//                     dwNumberOfCharactersToSend,
//                     lpdwNumberOfCharactersSent,
//                     dwContext
//                     ));
//
//    DEBUG_ERROR(API, ERROR_CALL_NOT_IMPLEMENTED);
//
//    //
//    // this is the handle we are currently working on
//    //
//
//    InternetSetObjectHandle(hGopherSession, hGopherSession);
//
//    //
//    // clear the per-handle object last error variables
//    //
//
//    InternetClearLastError();
//
//    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
//
//    DEBUG_LEAVE_API(FALSE);
//
//    return FALSE;
//}

//
//DWORD
//pGfrGetUrlInfo(
//    IN HANDLE InternetConnectHandle,
//    OUT LPSTR Url
//    )
//
///*++
//
//Routine Description:
//
//    description-of-function.
//
//Arguments:
//
//    InternetConnectHandle   -
//    Url                     -
//
//Return Value:
//
//    DWORD
//
//--*/
//
//{
//    return( ERROR_CALL_NOT_IMPLEMENTED );
//}


DWORD
pGopherGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR    lpszTargetHost,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectLocator,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    Creates an URL for a gopher entity

Arguments:

    SchemeType          - protocol scheme (INTERNET_SCHEME_GOPHER)

    lpszTargetHost      - server

    lpszCWD             - current directory at server

    lpszObjectLocator   - gopher locator string

    lpszExtension       - file extension

    dwPort              - port at server

    lplpUrlName         - pointer to returned URL

    lpdwUrlLen          - pointer to returned URL length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

                  ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error, dwUrlLen, dwExtensionLength;
    BOOL fDoneOnce = FALSE;

    if (lpszExtension) {
        dwExtensionLength = lstrlen(lpszExtension)
                            + lstrlen(GOPHER_EXTENSION_DELIMITER_SZ);
    } else {
        dwExtensionLength = 0;
    }
    *lplpUrlName = NULL;
    *lpdwUrlLen = 128 + dwExtensionLength;  // let us try with less first

    BOOL isDir;

    error = TestLocatorType(lpszObjectLocator, GOPHER_TYPE_DIRECTORY);
    isDir = error == ERROR_SUCCESS;

    error = ERROR_INVALID_PARAMETER;

    do {

        INET_ASSERT(*lplpUrlName == NULL);

        //
        // BUGBUG - LPTR!
        //

        //*lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, *lpdwUrlLen);

        *lplpUrlName = (LPSTR)ALLOCATE_FIXED_MEMORY(*lpdwUrlLen);
        if (!*lplpUrlName) {
            error = GetLastError();
            goto Cleanup;
        }
        dwUrlLen = *lpdwUrlLen;
#ifdef MAYBE
        if (isDir) {
            **lplpUrlName = '~';
        }
#endif //MAYBE
        error = GopherLocatorToUrl(lpszObjectLocator,
#ifdef MAYBE
                                   isDir ? (*lplpUrlName + 1) : *lplpUrlName,
                                   isDir ? (*lpdwUrlLen - 1) : *lpdwUrlLen,
#endif //MAYBE
                                   *lplpUrlName,
                                   *lpdwUrlLen,
                                   &dwUrlLen
                                   );
        if (error != ERROR_SUCCESS) {

            //
            // BUGBUG - *lplpUrlName cannot be non-NULL?
            //

            if (*lplpUrlName) {
                FREE_MEMORY(*lplpUrlName);
                *lplpUrlName = NULL;
            }
        }
        if (!fDoneOnce) {
            if (error != ERROR_INSUFFICIENT_BUFFER) {
                break;
            } else {
                *lpdwUrlLen = INTERNET_MAX_URL_LENGTH + dwExtensionLength;
                fDoneOnce = TRUE;
            }
        } else {
            break;
        }
    } while (TRUE);

    if (error == ERROR_SUCCESS) {
        if (lpszExtension) {

            INET_ASSERT(dwExtensionLength);

            lstrcat(*lplpUrlName, GOPHER_EXTENSION_DELIMITER_SZ);
            lstrcat(*lplpUrlName, lpszExtension);
        }
    }

Cleanup:

    return error;
}


PRIVATE
BOOL
FGopherBeginCacheReadProcessing(
    IN HINTERNET hGopher,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fIsHtmlFind
    )
{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "FGopherBeginCacheReadProcessing",
                 "%#x, %q, %q, %#x, %#x, %B",
                 hGopher,
                 lpszFileName,
                 lpszViewType,
                 dwFlags,
                 dwContext,
                 fIsHtmlFind
                 ));

    DWORD dwError = ERROR_SUCCESS;
    URLGEN_FUNC fn = pGopherGetUrlString;
    LPCACHE_ENTRY_INFO lpCEI = NULL;
    BOOL ok;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->IsCacheReadInProgress()) {
        goto quit;
    }

    if (!(dwFlags & INTERNET_FLAG_NO_CACHE_WRITE)) {

        //
        // if the object name is not set then all cache methods fail
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetObjectName(
                                                        (LPSTR)lpszFileName,
                                                        (LPSTR)lpszViewType,
                                                        &fn
                                                        );

        //
        // set the cache flags like RELOAD etc.
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetCacheFlags(dwFlags);
    } else {

        //
        // set flags to disable both read and write
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetCacheFlags(
                                                        INTERNET_FLAG_DONT_CACHE
                                                        | INTERNET_FLAG_RELOAD
                                                        );
    }

    if (!FGopherCanReadFromCache(hGopher)) {
        dwError = !ERROR_SUCCESS;
        goto quit;
    }

    DEBUG_PRINT(GOPHER,
                INFO,
                ("Checking in the cache\n"
                ));

    dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->BeginCacheRetrieval(&lpCEI);
    if (dwError == ERROR_SUCCESS) {

        //
        // found it in the cache
        //

        DEBUG_PRINT(GOPHER,
                    INFO,
                    ("Found in the cache\n"
                    ));

        if (IsOffline()
        || (!FIsGopherExpired(hGopher, lpCEI)
            && ((fIsHtmlFind && lpCEI->lpszFileExtension)
            || (!fIsHtmlFind && !lpCEI->lpszFileExtension)))) {

            dwError = ERROR_SUCCESS;
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetFromCache();
        } else {

            DEBUG_PRINT(GOPHER,
                        INFO,
                        ("Expired or invalid datatype\n"
                        ));

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->EndCacheRetrieval();

            INET_ASSERT(dwError == ERROR_SUCCESS);

            dwError = ERROR_FILE_NOT_FOUND;
        }
    }

    if (lpCEI != NULL) {
        lpCEI = (LPCACHE_ENTRY_INFO)FREE_MEMORY(lpCEI);

        INET_ASSERT(lpCEI == NULL);

    }

quit:

    ok = (dwError == ERROR_SUCCESS);

    DEBUG_LEAVE(ok);

    return ok;
}


PRIVATE
BOOL
FGopherCanReadFromCache(
    HINTERNET hGopher
    )
{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "FGopherCanReadFromCache",
                 "%#x",
                 hGopher
                 ));

    DWORD dwOpenFlags = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->GetInternetOpenFlags();
    DWORD dwCacheFlags = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->GetCacheFlags();
    BOOL ok = TRUE;

    //
    // in disconnected state client always reads
    //

    if (((dwOpenFlags | dwCacheFlags) & INTERNET_FLAG_OFFLINE) || IsOffline()) {

        DEBUG_PRINT(GOPHER,
                    INFO,
                    ("open flags=%#x, cache flags=%#x, offline=%B\n",
                    dwOpenFlags,
                    dwCacheFlags,
                    IsOffline()
                    ));

    } else if (dwCacheFlags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_RESYNCHRONIZE)) {

        //
        // if we are asked to reload data, it is not OK to read from cache
        //

        DEBUG_PRINT(GOPHER,
                    INFO,
                    ("no cache option\n"
                    ));

        ok = FALSE;
    }

    DEBUG_LEAVE(ok);

    return ok;
}


PRIVATE
BOOL
FGopherBeginCacheWriteProcessing(
    IN HINTERNET hGopher,
    IN LPCSTR lpszFileName,
    IN LPCSTR lpszViewType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN BOOL fIsHtmlFind
    )
{
    DWORD   dwError = ERROR_INVALID_FUNCTION;
    URLGEN_FUNC fn = pGopherGetUrlString;
    LPSTR   lpszFileExtension, lpTemp;
    char cExt[DEFAULT_MAX_EXTENSION_LENGTH + sizeof("%09%09%2B") + 1];
    DWORD dwBuffLen;


    if (!((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->IsCacheReadInProgress()) {

        //
        // we are not reading from the cache
        // Let us ask a routine whether we should cache this
        // stuff or not
        //

        if (FGopherCanWriteToCache(hGopher)) {

            //
            // if the object name is not set then all cache methods fail
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetObjectName(
                                                            (LPSTR)lpszFileName,
                                                            (LPSTR)lpszViewType,
                                                            &fn
                                                            );

            //
            // set the cache flags
            //

            ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->SetCacheFlags(dwFlags);

            //
            // he says we can cache it.
            //

            DEBUG_PRINT(GOPHER,
                        INFO,
                        ("Starting cache write\n"
                        ));

            if (!fIsHtmlFind) {
                dwBuffLen = sizeof(cExt);

                lpszFileExtension = GetFileExtensionFromUrl(
                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->GetURL(),
                    &dwBuffLen
                    );

                if (lpszFileExtension != NULL) {

                    //
                    // strip off gopher+ strings
                    //

                    for (lpTemp = lpszFileExtension;
                        *lpTemp != 0 && * lpTemp != '%';
                        ++lpTemp) {

                        //
                        // EMPTY LOOP
                        //

                    }

                    dwBuffLen = (DWORD) PtrDifference(lpTemp, lpszFileExtension);
                    memcpy(cExt, lpszFileExtension, dwBuffLen);
                    cExt[dwBuffLen] = '\0';
                    lpszFileExtension = cExt;
                }
            }
            else {
                //generate htm extension
                strcpy(cExt, "htm");
                lpszFileExtension = cExt;
            }

            dwError = ((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->BeginCacheWrite(
                0,
                lpszFileExtension
                );

            if (dwError != ERROR_SUCCESS) {

                DEBUG_PRINT(GOPHER,
                            ERROR,
                            ("Error in BeginCacheWrite %ld\n",
                            dwError
                            ));

            }
        }
    }
    return (dwError == ERROR_SUCCESS);
}


PRIVATE
BOOL
FGopherCanWriteToCache(
    HINTERNET   hGopher
    )
{
    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->
    GetCacheFlags() & INTERNET_FLAG_DONT_CACHE) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopher,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    )
{

    FILETIME ftLastModTime, ftExpiryTime, ftPostCheck;
    DWORD   dwEntryType;

    if (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->IsCacheWriteInProgress()) {

        ftLastModTime.dwLowDateTime =
        ftLastModTime.dwHighDateTime = 0;

        ftExpiryTime.dwLowDateTime =
        ftExpiryTime.dwHighDateTime = 0;

        ftPostCheck.dwLowDateTime =
        ftPostCheck.dwHighDateTime = 0;


        dwEntryType = (!fNormal)?0xffffffff:
                        ((((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->

                            GetCacheFlags() & INTERNET_FLAG_MAKE_PERSISTENT)
                                ? STICKY_CACHE_ENTRY:0
                        );

         DEBUG_PRINT(GOPHER,
                     INFO,
                     ("Cache write EntryType = %x\r\n", dwEntryType
                     ));

        return (((INTERNET_CONNECT_HANDLE_OBJECT *)hGopher)->EndCacheWrite(
                    &ftExpiryTime,
                    &ftLastModTime,
                    &ftPostCheck,
                    dwEntryType,
                    0,
                    NULL,
                    lpszFileExtension
                    ));
    }
    return (ERROR_SUCCESS);
}


PRIVATE
BOOL
FIsGopherExpired(
    HINTERNET hGopher,
    LPCACHE_ENTRY_INFO lpCEI
    )
{
    DEBUG_ENTER((DBG_GOPHER,
                 Bool,
                 "FIsGopherExpired",
                 "%#x, %#x",
                 hGopher,
                 lpCEI
                 ));

    FILETIME ft;
    BOOL fExpired = TRUE;

    GetCurrentGmtTime(&ft);
    if (CheckExpired(   hGopher,
                        &fExpired,
                        lpCEI,
                        dwdwGopherDefaultExpiryDelta) != ERROR_SUCCESS) {
        fExpired = TRUE;
    }

    DEBUG_LEAVE(fExpired);

    return (fExpired);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapip.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapip.h

Abstract:

    Contains private or internal definitions for client gopher protocol
    provider

Author:

    Richard L Firth (rfirth) 13-Oct-1994

Revision History:

    13-Oct-1994 rfirth
        Created

--*/

//
// manifests
//

//
// gopher strings
//

#define GOPHER_REQUEST_TERMINATOR               "\r\n"
#define GOPHER_REQUEST_TERMINATOR_LENGTH        (sizeof(GOPHER_REQUEST_TERMINATOR) - 1)
#define GOPHER_DOT_TERMINATOR                   ".\r\n"
#define GOPHER_DOT_TERMINATOR_LENGTH            (sizeof(GOPHER_DOT_TERMINATOR) - 1)

//
// gopher+ strings
//

#define GOPHER_PLUS_INDICATOR                   "\t+"
#define GOPHER_PLUS_INDICATOR_LENGTH            (sizeof(GOPHER_PLUS_INDICATOR) - 1)
#define GOPHER_PLUS_ITEM_INFO                   "\t!"
#define GOPHER_PLUS_ITEM_INFO_LENGTH            (sizeof(GOPHER_PLUS_ITEM_INFO) - 1)
#define GOPHER_PLUS_INFO_REQUEST                "\t!\r\n"
#define GOPHER_PLUS_INFO_REQUEST_LENGTH         (sizeof(GOPHER_PLUS_INFO_REQUEST) - 1)
#define GOPHER_PLUS_DIRECTORY_REQUEST           "\t$"
#define GOPHER_PLUS_DIRECTORY_REQUEST_LENGTH    (sizeof(GOPHER_PLUS_DIRECTORY_REQUEST) - 1)
#define GOPHER_PLUS_INFO_TOKEN                  "+INFO"
#define GOPHER_PLUS_INFO_TOKEN_LENGTH           (sizeof(GOPHER_PLUS_INFO_TOKEN) - 1)
#define GOPHER_PLUS_ADMIN_TOKEN                 "+ADMIN"
#define GOPHER_PLUS_ADMIN_TOKEN_LENGTH          (sizeof(GOPHER_PLUS_ADMIN_TOKEN) - 1)
#define GOPHER_PLUS_VIEWS_TOKEN                 "+VIEWS"
#define GOPHER_PLUS_VIEWS_TOKEN_LENGTH          (sizeof(GOPHER_PLUS_VIEWS_TOKEN) - 1)

//
// single characters
//

#define GOPHER_FIELD_SEPARATOR          '\t'
#define GOPHER_PLUS_SUCCESS_INDICATOR   '+'
#define GOPHER_PLUS_ERROR_INDICATOR     '-'

//
// misc.
//

#define INVALID_GOPHER_CHAR             0
#define INVALID_GOPHER_TYPE             0
#define DEFAULT_GOPHER_DISPLAY_STRING   ""
#define DEFAULT_GOPHER_SELECTOR_STRING  ""
#define UNKNOWN_GOPHER_TYPE             0

//
// types and masks
//

#define VALID_GOPHER_TYPES              (GOPHER_TYPE_TEXT_FILE          \
                                        | GOPHER_TYPE_DIRECTORY         \
                                        | GOPHER_TYPE_CSO               \
                                        | GOPHER_TYPE_MAC_BINHEX        \
                                        | GOPHER_TYPE_DOS_ARCHIVE       \
                                        | GOPHER_TYPE_UNIX_UUENCODED    \
                                        | GOPHER_TYPE_INDEX_SERVER      \
                                        | GOPHER_TYPE_TELNET            \
                                        | GOPHER_TYPE_BINARY            \
                                        | GOPHER_TYPE_REDUNDANT         \
                                        | GOPHER_TYPE_TN3270            \
                                        | GOPHER_TYPE_GIF               \
                                        | GOPHER_TYPE_IMAGE             \
                                        | GOPHER_TYPE_BITMAP            \
                                        | GOPHER_TYPE_MOVIE             \
                                        | GOPHER_TYPE_SOUND             \
                                        | GOPHER_TYPE_HTML              \
                                        | GOPHER_TYPE_PDF               \
                                        | GOPHER_TYPE_CALENDAR          \
                                        | GOPHER_TYPE_INLINE            \
                                        )

#define GOPHER_TYPE_MASK                (~(GOPHER_TYPE_GOPHER_PLUS))

#define GOPHER_ATTRIBUTE_MASK           (GOPHER_TYPE_GOPHER_PLUS)

#define GOPHER_FILE_MASK                (GOPHER_TYPE_TEXT_FILE          \
                                        | GOPHER_TYPE_MAC_BINHEX        \
                                        | GOPHER_TYPE_DOS_ARCHIVE       \
                                        | GOPHER_TYPE_UNIX_UUENCODED    \
                                        | GOPHER_TYPE_BINARY            \
                                        | GOPHER_TYPE_GIF               \
                                        | GOPHER_TYPE_IMAGE             \
                                        | GOPHER_TYPE_BITMAP            \
                                        | GOPHER_TYPE_MOVIE             \
                                        | GOPHER_TYPE_SOUND             \
                                        | GOPHER_TYPE_HTML              \
                                        | GOPHER_TYPE_PDF               \
                                        | GOPHER_TYPE_CALENDAR          \
                                        | GOPHER_TYPE_INLINE            \
                                        )

#define GOPHER_DIRECTORY_MASK           (GOPHER_TYPE_DIRECTORY)


#define GOPHER_DOT_TERMINATED_TYPES     (GOPHER_TYPE_TEXT_FILE          \
                                        | GOPHER_TYPE_DIRECTORY         \
                                        | GOPHER_TYPE_MAC_BINHEX        \
                                        | GOPHER_TYPE_UNIX_UUENCODED    \
                                        | GOPHER_TYPE_INDEX_SERVER      \
                                        )

//
// gopher locator characters
//

#define GOPHER_CHAR_REDUNDANT           '+'
#define GOPHER_CHAR_TEXT_FILE           '0'
#define GOPHER_CHAR_DIRECTORY           '1'
#define GOPHER_CHAR_CSO                 '2'
#define GOPHER_CHAR_ERROR               '3'
#define GOPHER_CHAR_MAC_BINHEX          '4'
#define GOPHER_CHAR_DOS_ARCHIVE         '5'
#define GOPHER_CHAR_UNIX_UUENCODED      '6'
#define GOPHER_CHAR_INDEX_SERVER        '7'
#define GOPHER_CHAR_TELNET              '8'
#define GOPHER_CHAR_BINARY              '9'
#define GOPHER_CHAR_BITMAP              ':'
#define GOPHER_CHAR_MOVIE               ';'
#define GOPHER_CHAR_SOUND               '<'
#define GOPHER_CHAR_IMAGE               'I'
//#define GOPHER_CHAR_BIG_M               'M'
#define GOPHER_CHAR_PDF                 'P'
#define GOPHER_CHAR_TN3270              'T'
#define GOPHER_CHAR_CALENDAR            'c'
//#define GOPHER_CHAR_LITTLE_E            'e'
#define GOPHER_CHAR_GIF                 'g'
#define GOPHER_CHAR_INLINE              'i'
#define GOPHER_CHAR_HTML                'h'
#define GOPHER_CHAR_SOUND_2             's'

//
// macros
//

#define IS_DOT_TERMINATED_REQUEST(request) \
    ((request & GOPHER_DOT_TERMINATED_TYPES) ? TRUE : FALSE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gfrapiw.cxx

Abstract:

    UNICODE versions of Windows Internet Extensions (WINX) Gopher Protocol APIs
    (in gfrapia.c)

    Contents:
        GopherCreateLocatorW
        GopherGetLocatorType
        GopherFindFirstFileW
        GopherFindNextW
        GopherOpenFileW
        GopherGetAttributeW
        GopherSendDataW

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Environment:

    Win32 user-level DLL

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"


//
// functions
//


INTERNETAPI_(BOOL) GopherCreateLocatorW(
    IN LPCWSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszDisplayString OPTIONAL,
    IN LPCWSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPWSTR lpszLocator,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherCreateLocatorW",
                     "%wq, %d, %wq, %wq, %#x, %#x, %#x [%d]",
                     lpszHost,
                     nServerPort,
                     lpszDisplayString,
                     lpszSelectorString,
                     dwGopherType,
                     lpszLocator,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpLocator,mpDisplay,mpSelector,mpHost;
    BOOL fResult = FALSE;

    if (!lpszHost || !lpdwBufferLength
        || (IsBadStringPtrW(lpszHost, INTERNET_MAX_PATH_LENGTH + 1))
        || (IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszHost,0,mpHost);
    if (!mpHost.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszHost,mpHost);
    if (lpszDisplayString)
    {
        ALLOC_MB(lpszDisplayString,0,mpDisplay);
        if (!mpDisplay.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszDisplayString,mpDisplay);
    }
    if (lpszSelectorString)
    {
        ALLOC_MB(lpszSelectorString,0,mpSelector);
        if (!mpSelector.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszSelectorString,mpSelector);
    }
    mpLocator.dwSize = *lpdwBufferLength;

    if (lpszLocator)
    {
        mpLocator.dwAlloc = *lpdwBufferLength*sizeof(CHAR);
        mpLocator.psStr = (LPSTR)ALLOC_BYTES(mpLocator.dwAlloc);
        if (!mpLocator.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = GopherCreateLocatorA(mpHost.psStr,nServerPort,mpDisplay.psStr,mpSelector.psStr,
        dwGopherType,mpLocator.psStr,&mpLocator.dwSize);

    *lpdwBufferLength = mpLocator.dwSize*sizeof(WCHAR);

    if (fResult && (*lpdwBufferLength <= mpLocator.dwAlloc))
    {
        *lpdwBufferLength = (MultiByteToWideChar(CP_ACP, 0, mpLocator.psStr, -1,
                    lpszLocator, mpLocator.dwAlloc/sizeof(WCHAR))+1)*sizeof(WCHAR);
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) GopherGetLocatorTypeW(
    IN LPCWSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetLocatorTypeW",
                     "%wq, %#x",
                     lpszLocator,
                     lpdwGopherType
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpLocator;

    if (!lpszLocator)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszLocator,0,mpLocator);
    if (!mpLocator.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszLocator,mpLocator);
    fResult = GopherGetLocatorTypeA(mpLocator.psStr,lpdwGopherType);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL
TransformGopherFindDataToW(LPGOPHER_FIND_DATAA pgfdA, LPGOPHER_FIND_DATAW pgfdW)
{
    pgfdW->GopherType = pgfdA->GopherType;
    pgfdW->SizeLow = pgfdA->SizeLow;
    pgfdW->SizeHigh = pgfdA->SizeHigh;
    pgfdW->LastModificationTime = pgfdA->LastModificationTime;
    MultiByteToWideChar(CP_ACP, 0, pgfdA->DisplayString, -1,
            pgfdW->DisplayString, MAX_GOPHER_DISPLAY_TEXT + 1);
    MultiByteToWideChar(CP_ACP, 0, pgfdA->Locator, -1,
            pgfdW->Locator, MAX_GOPHER_LOCATOR_LENGTH + 1);

    return TRUE;
}


INTERNETAPI_(HINTERNET) GopherFindFirstFileW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator OPTIONAL,
    IN LPCWSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAW lpBuffer OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherFindFirstFileW",
                     "%#x, %wq, %wq, %#x, %#x, %$x",
                     hGopherSession,
                     lpszLocator,
                     lpszSearchString,
                     lpBuffer,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet=NULL;
    MEMORYPACKET mpLocator, mpSearch;
    GOPHER_FIND_DATAA gfda;

    if (lpszLocator && (IsBadStringPtrW(lpszLocator, INTERNET_MAX_PATH_LENGTH + 1)))
    {
        dwErr = ERROR_GOPHER_INVALID_LOCATOR;
        goto cleanup;
    }
    if ((lpszSearchString && (IsBadStringPtrW(lpszSearchString, INTERNET_MAX_PATH_LENGTH + 1)))
        || (lpBuffer && (IsBadWritePtr(lpBuffer, sizeof(*lpBuffer)))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpszLocator)
    {
        ALLOC_MB(lpszLocator,0,mpLocator);
        if (!mpLocator.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszLocator,mpLocator);
    }
    if (lpszSearchString)
    {
        ALLOC_MB(lpszSearchString,0,mpSearch);
        if (!mpSearch.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszSearchString,mpSearch);
    }
    hInternet = GopherFindFirstFileA(hGopherSession, mpLocator.psStr, mpSearch.psStr,
                                    &gfda, dwFlags, dwContext);
    if (hInternet && lpBuffer)
    {
        TransformGopherFindDataToW(&gfda, lpBuffer);
    }


cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOL
GopherFindNextW(
    IN HINTERNET hFind,
    OUT LPGOPHER_FIND_DATA lpBuffer
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(HINTERNET) GopherOpenFileW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "GopherOpenFileW",
                     "%#x, %wq, %wq, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszView,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpLocator,mpView;

    if (!lpszLocator)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszLocator,0,mpLocator);
    if (!mpLocator.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszLocator,mpLocator);
    if (lpszView)
    {
        ALLOC_MB(lpszView,0,mpView);
        if (!mpView.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszView,mpView);
    }
    hInternet = GopherOpenFileA(hGopherSession,mpLocator.psStr,mpView.psStr,dwFlags,dwContext);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) GopherGetAttributeW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD_PTR dwContext
    )
{
#if !defined(GOPHER_ATTRIBUTE_SUPPORT)

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;

#else
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "GopherGetAttributeW",
                     "%#x, %wq, %wq, %#x, %d, %#x, %#x, %#x",
                     hGopherSession,
                     lpszLocator,
                     lpszAttributeName,
                     lpBuffer,
                     dwBufferLength,
                     lpdwCharactersReturned,
                     lpfnEnumerator,
                     dwContext
                     ));

    // WARNING: This function may not function after all; You've been warned.
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpLocator,mpAttribute;

    ALLOC_MB(lpszLocator,0,mpLocator);
    if (!mpLocator.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszLocator,mpLocator);
    if (lpszAttributeName)
    {
        ALLOC_MB(lpszAttributeName,0,mpAttribute);
        if (!mpAttribute.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszAttributeName,mpAttribute);
    }
    fResult = GopherGetAttributeA(hGopherSession,mpLocator.psStr,mpAttribute.psStr,
        lpBuffer,dwBufferLength,lpdwCharactersReturned, lpfnEnumerator, dwContext);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        DEBUG_ERROR(API, dwErr);
        SetLastError(dwErr); 
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)
}

//
//INTERNETAPI_(BOOL) GopherSendDataW(
//    IN HINTERNET hGopherSession,
//    IN LPCWSTR lpszLocator,
//    IN LPCWSTR lpszBuffer,
//    IN DWORD dwNumberOfCharactersToSend,
//    OUT LPDWORD lpdwNumberOfCharactersSent,
//    IN DWORD dwContext
//    )
//{
//#if 1
//    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
//    return FALSE;
//#else
//    DWORD dwErr;
//    MEMORYPACKET mpLocator,mpView;
//
//    MAKE_ANSI(lpszLocator,0,mpLocator);
//    if (lpszView)
//    {
//       MAKE_ANSI(lpszView,0,mpView);
//    }
//    return GopherSendDataA(hGopherSession,mpLocator.psStr,mpView.psStr,dwFlags);
//
//    LEAVE_API_CALL(FALSE);
//#endif
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\gfrinit.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    gfrinit.cxx

Abstract:

    Gopher protocol initialization. This used to be gfrdll.c. All DLL specific
    code has moved to internet\client\dll

    Contents:
        GopherInitialize
        GopherTerminate

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Environment:

    Win32 user-mode

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// functions
//


VOID
GopherInitialize(
    VOID
    )

/*++

Routine Description:

    Performs gopher-specific initialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // initialize any critical sections, lists, etc.
    //

    InitializeSerializedList(&SessionList);
}


VOID
GopherTerminate(
    VOID
    )

/*++

Routine Description:

    Performs gopher-specific termination/cleanup

Arguments:

    None.

Return Value:

    None.

--*/

{
    CleanupSessions();
    TerminateSerializedList(&SessionList);

    //
    // make sure we returned all gopher resources
    //

    ASSERT_NO_BUFFERS();
    ASSERT_NO_VIEWS();
    ASSERT_NO_SESSIONS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\parse.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    parse.h

Abstract:

    Manifests, macros, types and prototypes for parse.c

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

BOOL
IsValidLocator(
    IN LPCSTR Locator,
    IN DWORD MaximumLength
    );

BOOL
IsGopherPlus(
    IN LPCSTR Locator
    );

BOOL
CrackLocator(
    IN LPCSTR Locator,
    OUT LPDWORD Type OPTIONAL,
    OUT LPSTR DisplayString OPTIONAL,
    IN OUT LPDWORD DisplayStringLength OPTIONAL,
    OUT LPSTR SelectorString OPTIONAL,
    IN OUT LPDWORD SelectorStringLength OPTIONAL,
    OUT LPSTR HostName OPTIONAL,
    IN OUT LPDWORD HostNameLength OPTIONAL,
    OUT LPDWORD GopherPort OPTIONAL,
    OUT LPSTR* ExtraStuff OPTIONAL
    );

DWORD
GopherCharToType(
    IN CHAR GopherChar
    );

CHAR
GopherTypeToChar(
    IN DWORD Attribute
    );

DWORD
GetDirEntry(
    IN LPVIEW_INFO ViewInfo,
    OUT LPGOPHER_FIND_DATA FindData
    );

DWORD
ReadData(
    IN LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReturned
    );

BOOL
CopyToEol(
    IN OUT LPSTR* Destination,
    IN OUT LPDWORD DestinationLength,
    IN OUT LPSTR* Source,
    IN OUT LPDWORD SourceLength
    );

DWORD
IsGopherPlusToken(
    IN LPSTR Token,
    IN DWORD TokenLength,
    IN LPSTR Buffer,
    IN DWORD BufferLength
    );

DWORD
MapAttributeNameToId(
    IN LPCSTR AttributeName
    );

VOID
MapAttributeToIds(
    IN LPCSTR AttributeName,
    OUT LPDWORD CategoryId,
    OUT LPDWORD AttributeId
    );

BOOL
MapAttributeIdToNames(
    IN DWORD AttributeId,
    OUT LPSTR* CategoryName,
    OUT LPSTR* AttributeName
    );

DWORD
GetGopherNumber(
    IN OUT LPSTR* pString
    );

BOOL
ExtractDateAndTime(
    IN OUT LPSTR* pString,
    OUT LPFILETIME pFileTime
    );

BOOL
ExtractView(
    IN OUT LPSTR* pString,
    OUT LPSTR ContentType,
    IN OUT LPDWORD ContentTypeLength,
    OUT LPSTR Language,
    IN OUT LPDWORD LanguageLength,
    OUT LPDWORD Size
    );

BOOL
FindAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    );

VOID
FindNextAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    );

DWORD
EnumerateAttribute(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN LPSTR LinePtr,
    IN DWORD LineLength,
    IN LPBYTE Buffer,
    IN DWORD BufferLength,
    OUT LPBOOL ResumeEnumeration
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\parse.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    parse.cxx

Abstract:

    Contains functions to parse gopher information received from the server

    Contents:
        IsValidLocator
        IsGopherPlus
        CrackLocator
        GopherCharToType
        GopherTypeToChar
        GetDirEntry
        (GopherLocatorToFindData)
        ReadData
        (ExtractLine)
        (ExtractDisplayString)
        CopyToEol
        IsGopherPlusToken
        MapAttributeNameToId
        MapAttributeToIds
        MapAttributeIdToNames
        GetGopherNumber
        ExtractDateAndTime
        ExtractView
        FindAttribute
        FindNextAttribute
        EnumerateAttribute
        ParseIntField
        ParseDwordField
        ParseStringField
        ParseAdminAttribute
        ParseModDateAttribute
        ParseAbstractAttribute
        ParseViewAttribute
        ParseTreewalkAttribute
        ParseUnknownAttribute
        (ExtractAttributeName)
        (CharacterCount)
        (CountCharactersToEol)
        (CopyString)

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Environment:

    Win32 user-level DLL

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"
#include "iert.h"

//
// manifests
//

#define DEFAULT_LINE_BUFFER_LENGTH          1024    // arbitrary
#define DEFAULT_ATTRIBUTE_NAME_LENGTH       64      // "
#define DEFAULT_LANGUAGE_NAME_LENGTH        32      // "
#define DEFAULT_CONTENT_TYPE_NAME_LENGTH    80      // "
#define SEARCH_TYPE_MOD_DATE                1
#define SEARCH_TYPE_VIEW                    2

//
// macros
//

#define NUMERIC_CHARACTER_TO_NUMBER(c)  ((int)(c) - (int)('0'))

//
// prototypes
//

PRIVATE
DWORD
GopherLocatorToFindData(
    IN LPCSTR Locator,
    IN DWORD Length,
    OUT LPGOPHER_FIND_DATA FindData
    );

PRIVATE
DWORD
ExtractLine(
    IN LPVIEW_INFO ViewInfo,
    OUT LPBYTE LineBuffer,
    IN OUT LPDWORD LineBufferLength,
    IN OUT LPDWORD DataOffset
    );

PRIVATE
DWORD
ExtractDisplayString(
    IN LPCSTR Locator,
    IN OUT LPSTR* StringPointer,
    IN DWORD BufferLength
    );

PRIVATE
BOOL
SkipLeading(
    IN OUT LPSTR* String,
    IN OUT LPDWORD Length
    );

PRIVATE
DWORD
ExtractAttributeName(
    OUT LPSTR AttributeName,
    IN OUT LPDWORD AttributeNameLength,
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    );

PRIVATE
DWORD
CharacterCount(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    IN LPSTR TerminationSet
    );

PRIVATE
DWORD
CountCharactersToEol(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    );

PRIVATE
VOID
CopyString(
    IN OUT LPSTR* String,
    IN LPSTR Source,
    IN DWORD Length
    );

//
// functions
//


BOOL
IsValidLocator(
    IN LPCSTR Locator,
    IN DWORD MaximumLength
    )

/*++

Routine Description:

    Given a locator string, determines whether it is a valid gopher locator. A
    valid gopher locator must have the form:

    <GopherChar><DisplayString>TAB<SelectorString>TAB<HostName>TAB<Port>[TAB<Gopher+Stuff>]<CR><LF><EOS>

    We don't care about the contents of DisplayString, SelectorString, HostName,
    Port or Gopher+Stuff, since these will be sorted out by sockets functions or
    the gopher protocol

Arguments:

    Locator         - pointer to locator string

    MaximumLength   - maximum number characters that can be in the locator

Return Value:

    BOOL
        TRUE    - Locator is valid

        FALSE   - Locator does not look like kosher gopher locator, already

--*/

{
    BOOL success;

    success = FALSE;
    __try {

        DWORD locatorLength;

        locatorLength = strlen(Locator);

        //
        // 1. Since there are all sorts of unspecified gopher types in the world,
        // we no longer test the type, but just make sure its not 0 (which would
        // have yielded a zero locatorLength). Also check that the locator doesn't
        // break the maximum length limit
        //

        if ((locatorLength != 0) && (locatorLength <= MaximumLength)) {

            //
            // 2. <DisplayString>. Can be empty. This can be any character, ANSI
            // or otherwise, we just don't care about its contents
            //

            ++Locator;
            --locatorLength;
            while ((*Locator != '\t') && (locatorLength != 0)) {
                --locatorLength;
                ++Locator;
            }

            if ((*Locator == '\t') && (locatorLength != 0)) {

                //
                // 3. <SelectorString>. Same rules as for DisplayString: contents
                // not interesting
                //

                ++Locator;
                --locatorLength;
                while ((*Locator != '\t') && (locatorLength != 0)) {
                    --locatorLength;
                    ++Locator;
                }

                if ((*Locator == '\t') && (locatorLength != 0)) {

                    //
                    // 4. <HostName>. Again, we don't care about the characters
                    // that comprise HostName, or the length. We used to require
                    // a non-zero length
                    //

                    ++Locator;
                    --locatorLength;
                    while ((*Locator != '\t') && (locatorLength != 0)) {
                        --locatorLength;
                        ++Locator;
                    }

                    if ((*Locator == '\t') && (locatorLength != 0)) {

                        DWORD number;

                        //
                        // 5. Port. This must comprise 0..5 digit characters
                        //

                        ++Locator;
                        --locatorLength;
                        number = 0;
                        while ((*Locator != '\t')
                        && (*Locator != '\r')
                        && (*Locator != '\n')
                        && (*Locator >= '0')
                        && (*Locator <= '9')) {

                            //
                            // we are kind of assuming no leading zeroes...
                            //

                            number = number * 10 + (DWORD)(*Locator - '0');
                            --locatorLength;
                            ++Locator;
                        }

                        if (number <= (DWORD)INTERNET_MAX_PORT_NUMBER_VALUE) {

                            //
                            // 6. Optional gopher+ characters. We ignore the
                            // rest of the locator, and assume that it is
                            // correct
                            //

                            if ((*Locator == '\t') && (locatorLength >= 2)) {
                                do {
                                    ++Locator;
                                    --locatorLength;
                                } while (  (*Locator != '\r')
                                        && (*Locator != '\n')
                                        && (locatorLength != 0) );
                            }

                            //
                            // check for line termination. Because of the random
                            // nature of gopher servers, we allow 0 or more '\r'
                            // followed by '\n'. The locator MUST be terminated
                            // by '\n'
                            //

                            while ((*Locator == '\r') && (locatorLength != 0)) {
                                ++Locator;
                                --locatorLength;
                            }
                            if ((*Locator == '\n') && (locatorLength == 1)) {
                                success = TRUE;
                            }
                        }
                    }
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        success = FALSE;
    }
    ENDEXCEPT
    return success;
}


BOOL
IsGopherPlus(
    IN LPCSTR Locator
    )

/*++

Routine Description:

    Returns TRUE if Locator describes a gopher+ request

    ASSUMES:    1. Locator is valid

Arguments:

    Locator - pointer to locator to check

Return Value:

    BOOL

--*/

{
    LPSTR plusStuff;

    if (!IsValidLocator(Locator, strlen(Locator))) {
        return FALSE;
    }

    //
    // use CrackLocator to see if there is gopher+ info on this locator
    //

    CrackLocator(Locator,
                 NULL,  // Type
                 NULL,  // DisplayString
                 NULL,  // DisplayStringLength
                 NULL,  // SelectorString
                 NULL,  // SelectorStringLength
                 NULL,  // HostName
                 NULL,  // HostNameLength
                 NULL,  // GopherPort
                 &plusStuff
                 );
    return (BOOL)(plusStuff != NULL);
}


BOOL
CrackLocator(
    IN LPCSTR Locator,
    OUT LPDWORD Type OPTIONAL,
    OUT LPSTR DisplayString OPTIONAL,
    IN OUT LPDWORD DisplayStringLength OPTIONAL,
    OUT LPSTR SelectorString OPTIONAL,
    IN OUT LPDWORD SelectorStringLength OPTIONAL,
    OUT LPSTR HostName OPTIONAL,
    IN OUT LPDWORD HostNameLength OPTIONAL,
    OUT LPDWORD GopherPort OPTIONAL,
    OUT LPSTR* ExtraStuff OPTIONAL
    )

/*++

Routine Description:

    Given a locator, break it into its constituent parts. The Locator argument
    is NOT modified

    ASSUMES:    1. Locator is valid

                2. If an optional pointer is supplied, the associated length
                   parameter (if applicable) must also be supplied

Arguments:

    Locator                 - pointer to locator to crack

    Type                    - optional returned type character

    DisplayString           - optional returned display string

    DisplayStringLength     - optional in/out display string buffer length

    SelectorString          - optional returned selector string

    SelectorStringLength    - optional in/out selector string buffer length

    HostName                - optional returned host name

    HostNameLength          - optional in/out host name buffer length

    GopherPort              - optional returned gopher port

    ExtraStuff              - optional returned extra (gopher+) data from end of locator.
                              This argument is a returned pointer, not a buffer. Care
                              should be taken since this argument aliases Locator (or
                              part thereof)

Return Value:

    TRUE    - locator cracked ok

    FALSE   - problem encountered cracking locator, probably substring
              breaks buffer limit

--*/

{
    LPSTR pTab;
    DWORD len;
    LPSTR extraStuff;
    DWORD locatorLength;

    locatorLength = strlen(Locator);
    if (ARGUMENT_PRESENT(Type)) {
        *Type = GopherCharToType(*Locator);
    }

    ++Locator;  // past type character
    --locatorLength;
    pTab = (LPSTR)memchr((LPVOID)Locator, '\t', locatorLength);

    INET_ASSERT(pTab != NULL);

    len = (DWORD) (pTab - Locator);
    if (ARGUMENT_PRESENT(DisplayString)) {

        INET_ASSERT(DisplayStringLength != NULL);

        if (*DisplayStringLength <= len) {
            return FALSE;
        }
        memcpy(DisplayString, Locator, len);
        DisplayString[len] = '\0';
        *DisplayStringLength = len;
    }

    Locator = pTab + 1; // past display string and TAB
    locatorLength -= (len + 1);

    pTab = (LPSTR)memchr((LPVOID)Locator, '\t', locatorLength);

    INET_ASSERT(pTab != NULL);

    len = (DWORD) (pTab - Locator);
    if (ARGUMENT_PRESENT(SelectorString)) {

        INET_ASSERT(SelectorStringLength != NULL);

        if (*SelectorStringLength <= len) {
            return FALSE;
        }
        memcpy(SelectorString, Locator, len);
        SelectorString[len] = '\0';
        *SelectorStringLength = len;
    }

    Locator = pTab + 1; // past selector string and TAB
    locatorLength -= (len + 1);

    pTab = (LPSTR)memchr((LPVOID)Locator, '\t', locatorLength);

    INET_ASSERT(pTab != NULL);

    len = (DWORD) (pTab - Locator);
    if (ARGUMENT_PRESENT(HostName)) {

        INET_ASSERT(HostNameLength != NULL);

        if (*HostNameLength <= len) {
            return FALSE;
        }
        memcpy(HostName, Locator, len);
        HostName[len] = '\0';
        *HostNameLength = len;
    }

    Locator = pTab + 1; // past host name and TAB
    locatorLength -= (len + 1);
    pTab = (LPSTR)memchr(Locator, '\t', locatorLength);
    if (pTab != NULL) {
        extraStuff = pTab + 1;  // past port and TAB
    } else {
        extraStuff = NULL;
    }

    if (ARGUMENT_PRESENT(GopherPort)) {
        *GopherPort = (DWORD)STRTOUL(Locator, NULL, 10);
    }

    if (ARGUMENT_PRESENT(ExtraStuff)) {
        *ExtraStuff = extraStuff;
    }

    return TRUE;
}


DWORD
GopherCharToType(
    IN CHAR GopherChar
    )

/*++

Routine Description:

    Converts the gopher descriptor character to a Gfr attribute

Arguments:

    GopherChar  - the gopher character to convert

Return Value:

    DWORD
        mapped gopher type or GOPHER_TYPE_UNKNOWN if we don't recognise the
        character

--*/

{
    //
    // these are the types currently specified in RFC 1436 (plus a few that
    // aren't)
    //

    switch (GopherChar) {
    case GOPHER_CHAR_TEXT_FILE:
        return GOPHER_TYPE_TEXT_FILE;

    case GOPHER_CHAR_DIRECTORY:
        return GOPHER_TYPE_DIRECTORY;

    case GOPHER_CHAR_CSO:
        return GOPHER_TYPE_CSO;

    case GOPHER_CHAR_ERROR:
        return GOPHER_TYPE_ERROR;

    case GOPHER_CHAR_MAC_BINHEX:
        return GOPHER_TYPE_MAC_BINHEX;

    case GOPHER_CHAR_DOS_ARCHIVE:
        return GOPHER_TYPE_DOS_ARCHIVE;

    case GOPHER_CHAR_UNIX_UUENCODED:
        return GOPHER_TYPE_UNIX_UUENCODED;

    case GOPHER_CHAR_INDEX_SERVER:
        return GOPHER_TYPE_INDEX_SERVER;

    case GOPHER_CHAR_TELNET:
        return GOPHER_TYPE_TELNET;

    case GOPHER_CHAR_BINARY:
        return GOPHER_TYPE_BINARY;

    case GOPHER_CHAR_REDUNDANT:
        return GOPHER_TYPE_REDUNDANT;

    case GOPHER_CHAR_TN3270:
        return GOPHER_TYPE_TN3270;

    case GOPHER_CHAR_GIF:
        return GOPHER_TYPE_GIF;

    case GOPHER_CHAR_IMAGE:
        return GOPHER_TYPE_IMAGE;

    case GOPHER_CHAR_BITMAP:
        return GOPHER_TYPE_BITMAP;

    case GOPHER_CHAR_MOVIE:
        return GOPHER_TYPE_MOVIE;

    case GOPHER_CHAR_SOUND:     // '<'
    case GOPHER_CHAR_SOUND_2:   // 's'
        return GOPHER_TYPE_SOUND;

    case GOPHER_CHAR_HTML:
        return GOPHER_TYPE_HTML;

    case GOPHER_CHAR_PDF:
        return GOPHER_TYPE_PDF;

    case GOPHER_CHAR_CALENDAR:
        return GOPHER_TYPE_CALENDAR;

    case GOPHER_CHAR_INLINE:
        return GOPHER_TYPE_INLINE;
    }
    return GOPHER_TYPE_UNKNOWN;
}


CHAR
GopherTypeToChar(
    IN DWORD GopherType
    )

/*++

Routine Description:

    Opposite of GopherCharToType

Arguments:

    GopherType  - bitmap of attributes. Only one file type and gopher plus
                  attributes can be set simultaneously

Return Value:

    CHAR
        Success - mapped gopher char
        Failure - INVALID_GOPHER_TYPE

--*/

{
    switch (GopherType & GOPHER_TYPE_MASK) {
    case GOPHER_TYPE_TEXT_FILE:
        return GOPHER_CHAR_TEXT_FILE;

    case GOPHER_TYPE_DIRECTORY:
        return GOPHER_CHAR_DIRECTORY;

    case GOPHER_TYPE_CSO:
        return GOPHER_CHAR_CSO;

    case GOPHER_TYPE_ERROR:
        return GOPHER_CHAR_ERROR;

    case GOPHER_TYPE_MAC_BINHEX:
        return GOPHER_CHAR_MAC_BINHEX;

    case GOPHER_TYPE_DOS_ARCHIVE:
        return GOPHER_CHAR_DOS_ARCHIVE;

    case GOPHER_TYPE_UNIX_UUENCODED:
        return GOPHER_CHAR_UNIX_UUENCODED;

    case GOPHER_TYPE_INDEX_SERVER:
        return GOPHER_CHAR_INDEX_SERVER;

    case GOPHER_TYPE_TELNET:
        return GOPHER_CHAR_TELNET;

    case GOPHER_TYPE_BINARY:
        return GOPHER_CHAR_BINARY;

    case GOPHER_TYPE_REDUNDANT:
        return GOPHER_CHAR_REDUNDANT;

    case GOPHER_TYPE_TN3270:
        return GOPHER_CHAR_TN3270;

    case GOPHER_TYPE_GIF:
        return GOPHER_CHAR_GIF;

    case GOPHER_TYPE_IMAGE:
        return GOPHER_CHAR_IMAGE;

    case GOPHER_TYPE_BITMAP:
        return GOPHER_CHAR_BITMAP;

    case GOPHER_TYPE_MOVIE:
        return GOPHER_CHAR_MOVIE;

    case GOPHER_TYPE_SOUND:
        return GOPHER_CHAR_SOUND;

    case GOPHER_TYPE_HTML:
        return GOPHER_CHAR_HTML;

    case GOPHER_TYPE_PDF:
        return GOPHER_CHAR_PDF;

    case GOPHER_TYPE_CALENDAR:
        return GOPHER_CHAR_CALENDAR;

    case GOPHER_TYPE_INLINE:
        return GOPHER_CHAR_INLINE;
    }
    return UNKNOWN_GOPHER_TYPE;
}


DWORD
GetDirEntry(
    IN LPVIEW_INFO ViewInfo,
    OUT LPGOPHER_FIND_DATA FindData
    )

/*++

Routine Description:

    Retrieves the next directory entry from the current VIEW_INFO data buffer.
    The buffer pointer will be updated to point to the start of the next line
    or 1 character past the end of the buffer

Arguments:

    ViewInfo    - pointer to VIEW_INFO which points to BUFFER_INFO which
                  points to buffer containing directory listing

    FindData    - pointer to user's GOPHER_FIND_DATA structure to fill in

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NO_MORE_FILES
                    End of the directory

                  ERROR_GOPHER_PROTOCOL_ERROR

--*/

{
    DWORD error;
    char lineBuf[DEFAULT_LINE_BUFFER_LENGTH];
    DWORD lineLen;
    LPSTR linePtr;
    BOOL haveLocator;

    //
    // get the next line from the buffer. If we don't have all the data that
    // constitutes a line, ExtractLine will endeavour to get it
    //

    haveLocator = FALSE;
    lineLen = sizeof(lineBuf);
    linePtr = lineBuf;
    error = ExtractLine(ViewInfo,
                        (LPBYTE)linePtr,
                        &lineLen,
                        &ViewInfo->ViewOffset
                        );

    //
    // convert lineLen to the number of characters actually extracted, minus
    // one for the '\0'. Doesn't matter if ExtractLine() failed
    //

    lineLen = sizeof(lineBuf) - (lineLen + 1);

    //
    // if we got a line of data, but the buffer contains gopher+ info then we
    // need to move the locator pointer past the "+INFO: " token
    //

    if ((error == ERROR_SUCCESS) && (ViewInfo->Flags & VI_GOPHER_PLUS)) {

        DWORD tokenLength;

        tokenLength = IsGopherPlusToken(GOPHER_PLUS_INFO_TOKEN,
                                        GOPHER_PLUS_INFO_TOKEN_LENGTH,
                                        linePtr,
                                        lineLen
                                        );
        if (tokenLength != 0) {
            linePtr += tokenLength;
            lineLen -= tokenLength;
        } else {

            //
            // hola! The "+INFO: " doesn't exist. We'll treat this as gopher0
            // info (or return an error?)
            //

            INET_ASSERT(FALSE);

            ViewInfo->Flags &= ~VI_GOPHER_PLUS;
        }
    }

    //
    // if no error occurred, convert the locator just retrieved into the
    // GOPHER_FIND_DATA structure
    //

    if (error == ERROR_SUCCESS) {
        error = GopherLocatorToFindData(linePtr, lineLen, FindData);

        //
        // if we parsed the locator OK and the buffer contains gopher+ info
        // then we must get the date and size information from the +ADMIN
        // section Mod-Date line and +VIEWS section resp.
        //

        if ((error == ERROR_SUCCESS) && (ViewInfo->Flags & VI_GOPHER_PLUS)) {

            DWORD dataOffset;
            DWORD previousOffset;
            DWORD searchType;
            BOOL done;

            haveLocator = TRUE;

            dataOffset = ViewInfo->ViewOffset;
            searchType = 0;
            done = FALSE;

            //
            // loop, reading the next line from the directory buffer. For each
            // line, parse the gopher+ token looking for the Mod-Date line,
            // or the first view line. We just skip all other lines
            //

            do {
                previousOffset = dataOffset;
                lineLen = sizeof(lineBuf);
                error = ExtractLine(ViewInfo,
                                    (LPBYTE)linePtr,
                                    &lineLen,
                                    &dataOffset
                                    );
                if (error == ERROR_SUCCESS) {

                    //
                    // again, convert lineLen to the number of characters
                    // extracted
                    //

                    lineLen = sizeof(lineBuf) - (lineLen + 1);

                    //
                    // if we found a line containing a categpry type on the
                    // previous iteration, then parse the per-category info
                    //

                    if (searchType == SEARCH_TYPE_VIEW) {

                        char contentType[DEFAULT_CONTENT_TYPE_NAME_LENGTH + 1];
                        char language[DEFAULT_LANGUAGE_NAME_LENGTH + 1];
                        DWORD contentTypeLength;
                        DWORD languageLength;
                        BOOL ok;

                        //
                        // must be views line. Just extract the first one
                        //

                        contentTypeLength = sizeof(contentType);
                        languageLength = sizeof(language);
                        ok = ExtractView(&linePtr,
                                         contentType,
                                         &contentTypeLength,
                                         language,
                                         &languageLength,
                                         &FindData->SizeLow
                                         );

                        INET_ASSERT(ok);
                        if (!ok) {
                            error = ERROR_GOPHER_DATA_ERROR;
                            break;
                        }

                        //
                        // we have the first view line. We aren't interested in
                        // the rest
                        //

                        searchType = 0;
                    } else {

                        LPSTR pAttribute;
                        char attributeBuffer[DEFAULT_CONTENT_TYPE_NAME_LENGTH + 1];
                        int i;
                        DWORD len;
                        LPSTR argPtr;

                        //
                        // pull out the first token on the line
                        //

                        i = 0;
                        len = lineLen;
                        pAttribute = linePtr;

                        //
                        // if this line has leading space, then skip it
                        //

                        while (*pAttribute == ' ') {
                            ++pAttribute;
                            --len;
                        }
                        while (len
                        && (i < sizeof(attributeBuffer) - 1)
                        && (pAttribute[i] != ' ')
                        && (pAttribute[i] != ':')
                        && (pAttribute[i] != '\r')
                        && (pAttribute[i] != '\n')) {
                            attributeBuffer[i] = pAttribute[i];
                            ++i;
                            --len;
                        }
                        attributeBuffer[i] = '\0';
                        switch (MapAttributeNameToId((LPCSTR)attributeBuffer)) {
                        case GOPHER_CATEGORY_ID_INFO:

                            //
                            // update the offset in the VIEW_INFO
                            //

                            ViewInfo->ViewOffset = previousOffset;

                            //
                            // we have got to the next directory entry. Quit
                            //

                            done = TRUE;
                            break;

                        case GOPHER_ATTRIBUTE_ID_MOD_DATE:

                            //
                            // this is the "Mod-Date" line. Find the start of
                            // the date-time field (in angle brackets) and
                            // extract the time and date to the GOPHER_FIND_DATE
                            // structure
                            //

                            argPtr = strchr(linePtr, '<');
                            if (argPtr != NULL) {
                                ExtractDateAndTime(&argPtr,
                                                   &FindData->LastModificationTime
                                                   );
                            }
                            break;

                        case GOPHER_CATEGORY_ID_VIEWS:

                            //
                            // we have found the +VIEWS section. Next thing to
                            // find is the views proper
                            //

                            searchType = SEARCH_TYPE_VIEW;
                            break;

                        default:

                            //
                            // we just skip all other lines except the line(s)
                            // containing view information, in which case
                            // searchType will be set to indicate that this line
                            // contains a view
                            //

                            break;
                        }
                    }

                } else {

                    //
                    // ExtractLine had an error
                    //

                     ViewInfo->ViewOffset = dataOffset;
                    done = TRUE;
                }
            } while ( !done );
        }
    }
    if (error == ERROR_GOPHER_END_OF_DATA) {
        if (haveLocator) {
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NO_MORE_FILES;
        }
    }
    return error;
}


PRIVATE
DWORD
GopherLocatorToFindData(
    IN LPCSTR Locator,
    IN DWORD Length,
    OUT LPGOPHER_FIND_DATA FindData
    )

/*++

Routine Description:

    Fills in the GOPHER_FIND_DATA fields from a gopher locator string. The
    strings in the GOPHER_FIND_DATA are appended after the fixed structure.

    ASSUMES 1. The buffer pointed to by FindData is large enough to hold the
               fixed and variable parts of the GOPHER_FIND_DATA

Arguments:

    Locator     - pointer to (ASCII) locator string

    Length      - length of Locator

    FindData    - pointer to GOPHER_FIND_DATA structure

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_PROTOCOL_ERROR

--*/

{
    LPSTR stringPointer;
    DWORD bufferLength;
    LPSTR locator;
    DWORD locatorLength;

    FindData->GopherType = GopherCharToType(*Locator);

    if (IsGopherPlus(Locator)) {
        FindData->GopherType |= GOPHER_TYPE_GOPHER_PLUS;
    }

    stringPointer = FindData->DisplayString;

    //
    // copy the display string into the GOPHER_FIND_DATA. We no longer care
    // about the length copied
    //

    ExtractDisplayString(Locator,
                         &stringPointer,
                         sizeof(FindData->DisplayString)
                         );

    //
    // default the size and time/date fields to zero. If we received a gopher+
    // directory list, we will fill in these fields from the attribute info
    //

    FindData->SizeLow = 0;
    FindData->SizeHigh = 0;
    FindData->LastModificationTime.dwLowDateTime = 0;
    FindData->LastModificationTime.dwHighDateTime = 0;

    //
    // copy the locator into the GOPHER_FIND_DATA
    //

    stringPointer = FindData->Locator;
    bufferLength = sizeof(FindData->Locator);
    locator = (LPSTR)Locator;
    locatorLength = Length;
    if (CopyToEol(&stringPointer, &bufferLength, &locator, &locatorLength)) {

        if (FindData->GopherType == GOPHER_TYPE_UNKNOWN) {

            DEBUG_PRINT(PARSE,
                        ERROR,
                        ("GopherLocatorToFindData(): unknown locator type: \"%s\"\n",
                        FindData->Locator
                        ));

        }

        return ERROR_SUCCESS;
    }

    //
    // CopyToEol failed to find the end-of-line in the Locator string.
    // Either something's bust, or we have received a locator that breaks
    // our locator length limit
    //

    if ((bufferLength == 0) && (locatorLength != 0)) {

        char bigLocator[2 * MAX_GOPHER_LOCATOR_LENGTH + 1];

        //
        // blown our locator length limit. We will reconstruct a slightly
        // modified (smaller) locator
        //

        stringPointer = bigLocator;
        bufferLength = sizeof(bigLocator);
        locator = (LPSTR)Locator;
        locatorLength = Length;
        if (!CopyToEol(&stringPointer, &bufferLength, &locator, &locatorLength)) {

            //
            // CopyToEol() still fails! Either this is an extremely long
            // locator, or we are not parsing a directory output
            //

            // skip to \r\n?

            INET_ASSERT(FALSE);

            return ERROR_GOPHER_DATA_ERROR;
        }

        //
        // if we think this is a locator, albeit one that breaks our internal
        // locator length limit, crack it open, and then reconstitute
        //

        if (IsValidLocator(bigLocator, sizeof(bigLocator))) {

            DWORD gopherType;
            char displayString[MAX_GOPHER_DISPLAY_TEXT * 2 + 1];
            DWORD displayStringLength;
            char selectorString[MAX_GOPHER_SELECTOR_TEXT * 2 + 1];
            DWORD selectorStringLength;
            char hostName[MAX_GOPHER_HOST_NAME * 2 + 1];
            DWORD hostNameLength;
            DWORD port;

            displayStringLength = sizeof(displayString);
            selectorStringLength = sizeof(selectorString);
            hostNameLength = sizeof(hostName);
            if (CrackLocator(bigLocator,
                             &gopherType,
                             displayString,
                             &displayStringLength,
                             selectorString,
                             &selectorStringLength,
                             hostName,
                             &hostNameLength,
                             &port,
                             NULL)) {

                //
                // we really want to ensure that only the display string is
                // broken, but we can get some weird FTP-based locators that
                // contain long selector strings. As a compromise, just add
                // an extra terminator at the relevamt maximum offset in each
                // string
                //

                displayString[MAX_GOPHER_DISPLAY_TEXT] = '\0';
                selectorString[MAX_GOPHER_SELECTOR_TEXT] = '\0';
                hostName[MAX_GOPHER_HOST_NAME] = '\0';

                //
                // and reconstruct the locator
                //

                bufferLength = sizeof(FindData->Locator);
                if (gopherType == GOPHER_TYPE_UNKNOWN) {

                    //
                    // BUGBUG - should change GopherCreateLocator() so that it
                    //          is more forgiving of 'unknown' types (accept
                    //          a character, not a bit)
                    //

                    gopherType = GOPHER_TYPE_ERROR;
                }
                if (GopherCreateLocator((LPCSTR)hostName,
                                        (INTERNET_PORT)port,
                                        (LPCSTR)displayString,
                                        (LPCSTR)selectorString,
                                        gopherType,
                                        FindData->Locator,
                                        &bufferLength)) {
                    return ERROR_SUCCESS;
                } else {

                    //
                    // GopherCreateLocator() failed
                    //

                    INET_ASSERT(FALSE);

                }
            } else {

                //
                // CrackLocator() failed
                //

                INET_ASSERT(FALSE);

            }
        } else {

            //
            // IsValidLocator() returned FALSE
            //

            INET_ASSERT(FALSE);

        }
    } else {

        //
        // ran off the end of the directory list without finding "\r\n"?
        //

        INET_ASSERT(FALSE);

    }
    return ERROR_GOPHER_DATA_ERROR;
}


DWORD
ReadData(
    IN LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Reads data from a file buffer into the caller's buffer

Arguments:

    ViewInfo        - pointer to VIEW_INFO structure

    BytesReturned   - amount of data copied to caller's buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    BytesReturned contains amount of data copied to user buffer

        Failure - ERROR_GOPHER_DATA_ERROR
                    There is an inconsistency between the VIEW_INFO and the
                    BUFFER_INFO

                  ERROR_GOPHER_END_OF_DATA
                    All data has been copied to the user buffer

                  ERROR_GOPHER_TIMEOUT
                    We got a timeout trying to communicate with the gopher
                    server

                  Win32 error
                    Returned if we have a memory or heap problem

                  WSA error
                    Socket specific error returned by ReceiveResponse()

--*/

{
    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->ViewType == ViewTypeFile);
    INET_ASSERT(ViewInfo->BufferInfo != NULL);

    if (ViewInfo->BufferInfo->Flags & BI_RECEIVE_COMPLETE) {
        *BytesReturned = 0;
        return ERROR_SUCCESS;
    } else {
        return GopherReceiveResponse(ViewInfo, BytesReturned);
    }
}


PRIVATE
DWORD
ExtractLine(
    IN LPVIEW_INFO ViewInfo,
    OUT LPBYTE LineBuffer,
    IN OUT LPDWORD LineBufferLength,
    IN OUT LPDWORD DataOffset
    )

/*++

Routine Description:

    Extracts a line from a response buffer into a local buffer. If the buffer
    does not contain all of the current line we retrieve the next chunk by
    calling ReceiveResponse()

Arguments:

    ViewInfo        - describes VIEW_INFO from which to extract line

    LineBuffer      - pointer to buffer where line will be copied

    LineBufferLength- IN: length of line buffer
                      OUT: number of bytes remaining in LineBuffer

    DataOffset      - IN: the point in the data buffer corresponding to
                      ViewInfo->BufferInfo->Buffer at which to start the
                      extraction

                      OUT: The next offset in buffer at which to start

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_DATA_ERROR
                    We had an error parsing the data

                  ERROR_GOPHER_END_OF_DATA
                    We reached the end of the info - API returns
                    ERROR_NO_MORE_FILES

                  Win32 error

--*/

{
    DWORD error;
    BOOL copied;
    LPBYTE startOfLine;
    LPBUFFER_INFO bufferInfo;

    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->BufferInfo != NULL);

    bufferInfo = ViewInfo->BufferInfo;
    startOfLine = LineBuffer;
    error = ERROR_SUCCESS;

    do {

        LPBYTE bufferPointer;
        LPBYTE responsePointer;
        DWORD bufferAvailable;
        DWORD oldBufferAvailable;

        if (*DataOffset > bufferInfo->BufferLength) {

            //
            // we think we're further into buffer than there is available data
            //

            INET_ASSERT(FALSE);

            error = ERROR_GOPHER_DATA_ERROR;

            DEBUG_PRINT(PARSE,
                        ERROR,
                        ("ExtractLine(): *DataOffset (%d) > BufferLength (%d)\n",
                        *DataOffset,
                        bufferInfo->BufferLength
                        ));

            goto quit;
        }

        if ((bufferInfo->Flags & BI_RECEIVE_COMPLETE)
        && (*DataOffset == bufferInfo->BufferLength)) {

            //
            // the caller has already reached the end of the buffer
            //

            DEBUG_PRINT(PARSE,
                        INFO,
                        ("ExtractLine(): already at EOF buffer\n"
                        ));

            error = ERROR_GOPHER_END_OF_DATA;
            goto quit;
        }

        //
        // get a pointer to the start of the buffer
        //

        bufferPointer = bufferInfo->Buffer;

        INET_ASSERT(bufferPointer != NULL);

        if (bufferPointer == NULL) {
            goto last_error_exit;
        }

        //
        // now point to the offset in the buffer where the caller thinks the
        // next line begins and reduce the buffer length by the same amount
        //

        responsePointer = bufferPointer + *DataOffset;
        bufferAvailable = bufferInfo->BufferLength - *DataOffset;

        //
        // copy from the current buffer position to the end of the line
        //

        oldBufferAvailable = bufferAvailable;
        copied = CopyToEol((LPSTR *)&LineBuffer,
                           LineBufferLength,
                           (LPSTR *)&responsePointer,
                           &bufferAvailable
                           );

        //
        // oldBufferAvailable - bufferAvailable is the amount we copied
        //

        *DataOffset += oldBufferAvailable - bufferAvailable;

        //
        // copied is TRUE if CopyToEol copied a full line
        //

        if (copied) {

            //
            // test again for ".\r\n" terminator. Someones servers terminate
            // with ".\r\r\n" which would have escaped our test in
            // ReceiveResponse(), but has now been compressed to ".\r\n" by
            // CopyToEol(). Other, equally unintelegent servers, terminate
            // with e.g. ".\r\n\x1a"  (presumably this directory was read from
            // a file and squirted out via send())
            //

            if (memcmp(startOfLine, ".\r\n", 3) == 0) {

                //
                // there should be very few bytes left in the buffer, if any,
                // depending on how the server terminated the buffer (".\r\r\n"
                // or ".\r\n\x1a", e.g.)
                //
                // N.B. 8 is an arbitrary number. I don't expect too many
                // garbage characters at the end of the buffer, but if there's
                // more than a relatively small number, we could have a ".\r\n"
                // embedded half-way down the directory listing. Implausable,
                // yes, but then there's nothing so unpredictable as the results
                // from a gopher server
                //
                // 05/23/95
                //
                // server at sutro.sfsu.edu returns a pile of garbage after the
                // end-of-buffer mark. Probably unintentional, but causes the
                // following assertion to go off:
                //
                //  INET_ASSERT(bufferInfo->BufferLength - *DataOffset <= 8);
                //

                if (bufferInfo->BufferLength - *DataOffset <= 8) {

                    DEBUG_PRINT(PARSE,
                                WARNING,
                                ("ExtractLine(): Buffer handle %#x contains data after end-of-buffer mark\n",
                                bufferInfo->Buffer
                                ));
                }

                error = ERROR_GOPHER_END_OF_DATA;
            }
        } else {

            //
            // at the time we called CopyToEol, all of the current line was
            // not in the response buffer. Get the next part of the response
            //

            AcquireBufferLock(bufferInfo);
            if (!(bufferInfo->Flags & BI_RECEIVE_COMPLETE)) {

                DWORD bytesReceived;

                error = GopherReceiveResponse(ViewInfo, &bytesReceived);
            }
            ReleaseBufferLock(bufferInfo);
        }
    } while (!copied && (error == ERROR_SUCCESS));

quit:

    return error;

last_error_exit:

    error = GetLastError();
    goto quit;
}


PRIVATE
DWORD
ExtractDisplayString(
    IN LPCSTR Locator,
    IN OUT LPSTR* StringPointer,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    Given a gopher locator string, extract the display string part

Arguments:

    Locator         - pointer to gopher locator

    StringPointer   - pointer to pointer to output string. Updated on output

    BufferLength    - amount of space in *StringPointer

Return Value:

    DWORD   Length of string extracted

--*/

{
    LPSTR originalPointer = *StringPointer;
    char ch;

    //
    // Locator starts off pointing at the type character. Move past it then
    // copy everything up to the tab character
    //

    while (((ch = *++Locator) != '\t') && BufferLength--) {
        *(*StringPointer)++ = ch;
    }
    *(*StringPointer)++ = '\0';
    return (DWORD) (*StringPointer - originalPointer);
}


BOOL
CopyToEol(
    IN OUT LPSTR* Destination,
    IN OUT LPDWORD DestinationLength,
    IN OUT LPSTR* Source,
    IN OUT LPDWORD SourceLength
    )

/*++

Routine Description:

    Copies the current gopher response line up to the end of the current line
    in the buffer. The destination string is zero terminated if TRUE is
    returned

    On exit, all parameters are updated to reflect the current positions and
    lengths of the buffers so this function can be called iteratively until
    the entire line is copied

    ASSUMES 1. The Length is absolutely reliable - i.e. when Length == 2 and
               **Source == '\r', then *(*Source + 1) == '\n'

Arguments:

    Destination         - pointer to place to copy to

    DestinationLength   - pointer to length of destination buffer, updated on output

    Source              - pointer to place to copy from (gopher response buffer)

    SourceLength        - pointer tp length of source buffer, updated on output

Return Value:

    BOOL
        TRUE    - we copied the entire line up to \r\n

        FALSE   - none or part of a line was copied

--*/

{
    LPSTR src;
    LPSTR dest;
    DWORD srcLen;
    DWORD destLen;
    BOOL copied;

    //
    // make smaller code (i.e. don't deref the parms every time)
    //

    src = *Source;
    dest = *Destination;
    srcLen = *SourceLength;
    destLen = *DestinationLength;

    while ((*src != '\r') && (*src != '\n') && (destLen != 0) && (srcLen != 0)) {
        *dest++ = *src++;
        --destLen;
        --srcLen;
    }

    //
    // we can receive multiple carriage-returns, presumably because the server
    // uses sprintf("\r\n") in text mode which expands "\n" to be \r\n in the
    // output buffer. We will collapse multiple carriage-returns
    //

    while ((*(src + 1) == '\r') && (srcLen != 0)) {
        ++src;
        --srcLen;
    }

    //INET_ASSERT((srcLen > 1) ? (*(src + 1) == '\n') : TRUE);

    //
    // if \r\n exist in the source buffer then copy them and update the length
    //

    copied = FALSE;
    if (destLen >= 3) {
        if ((srcLen >= 2) && (*src == '\r')) {
            ++src;
            --srcLen;
        }
        if ((srcLen >= 1) && (*src == '\n')) {
            ++src;
            --srcLen;

            //
            // we have reached a line-feed. It either exists on its own or was
            // prefixed by a carriage-return. This is the end of the line...
            //
            // Note, even if we did not find \r\n in the source, we create \r\n
            // in the destination
            //

            destLen -= 3;   // 1 for \r, 1 for \n, 1 for \0
            *dest++ = '\r';
            *dest++ = '\n';
            *dest++ = '\0';
            copied = TRUE;
        }
    }

    *Source = src;
    *Destination = dest;
    *SourceLength = srcLen;
    *DestinationLength = destLen;
    return copied;
}


DWORD
IsGopherPlusToken(
    IN LPSTR Token,
    IN DWORD TokenLength,
    IN LPSTR Buffer,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    Determines if a token is the gopher+ token. In order to match we need to
    match a trailing space character also. Seems that some servers return
    "+INFO" and some "+INFO:". We must handle both

Arguments:

    Token           - pointer to gopher+ token string

    TokenLength     - length of PlusToken

    Buffer          - pointer to buffer containing token to check

    BufferLength    - number of bytes in BufferPointer

Return Value:

    DWORD
        Success - Returns number of characters matched, including trailing ' '

        Failure - 0. TokenPointer does not point at PlusToken or we ran out of
                  buffer before we could make the distinction

--*/

{
    //
    // Length must contain at least the trailing space, and possibly a ':'
    //

    if (BufferLength >= TokenLength + 2) {
        if (memcmp(Buffer, Token, TokenLength) == 0) {
            if (Buffer[TokenLength] == ':') {
                ++TokenLength;
            }

            //
            // if there's a space after the token then we know its really what we
            // are searching for
            //

            if (Buffer[TokenLength] == ' ') {
                return ++TokenLength;
            }
        }
    }
    return 0;
}


DWORD
MapAttributeNameToId(
    IN LPCSTR AttributeName
    )

/*++

Routine Description:

    Given a category or attribute name, returns an identifier to avoid having
    to perform extraneous string comparisons

    ASSUMES:    1. AttributeName has correct case. Comparisons are CASE-SENSITIVE

Arguments:

    AttributeName   - name of category or attribute

Return Value:

    DWORD
        relevant identifer or GOPHER_ATTRIBUTE_ID_UNKNOWN

--*/

{
    if (AttributeName == NULL) {
        return GOPHER_CATEGORY_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_INFO_CATEGORY)) {
        return GOPHER_CATEGORY_ID_INFO;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_CATEGORY)) {
        return GOPHER_CATEGORY_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_VIEWS_CATEGORY)) {
        return GOPHER_CATEGORY_ID_VIEWS;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_CATEGORY)) {
        return GOPHER_CATEGORY_ID_ABSTRACT;
    } else if (!stricmp(AttributeName, GOPHER_VERONICA_CATEGORY)) {
        return GOPHER_CATEGORY_ID_VERONICA;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_MOD_DATE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_MOD_DATE;
    } else if (!stricmp(AttributeName, GOPHER_TTL_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_TTL;
    } else if (!stricmp(AttributeName, GOPHER_SCORE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_SCORE;
    } else if (!stricmp(AttributeName, GOPHER_RANGE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_RANGE;
    } else if (!stricmp(AttributeName, GOPHER_SITE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_SITE;
    } else if (!stricmp(AttributeName, GOPHER_ORG_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_ORG;
    } else if (!stricmp(AttributeName, GOPHER_LOCATION_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_LOCATION;
    } else if (!stricmp(AttributeName, GOPHER_GEOG_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_GEOG;
    } else if (!stricmp(AttributeName, GOPHER_TIMEZONE_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_TIMEZONE;
    } else if (!stricmp(AttributeName, GOPHER_PROVIDER_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_PROVIDER;
    } else if (!stricmp(AttributeName, GOPHER_VERSION_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_VERSION;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_ABSTRACT;
    } else if (!stricmp(AttributeName, GOPHER_VIEW_ATTRIBUTE)) {
        return GOPHER_ATTRIBUTE_ID_VIEW;
    }
    return GOPHER_ATTRIBUTE_ID_UNKNOWN;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)


VOID
MapAttributeToIds(
    IN LPCSTR AttributeName,
    OUT LPDWORD CategoryId,
    OUT LPDWORD AttributeId
    )

/*++

Routine Description:

    Given a category or attribute name, returns an identifier to avoid having
    to perform extraneous string comparisons

    ASSUMES:    1. AttributeName has correct case. Comparisons are CASE-SENSITIVE

Arguments:

    AttributeName   - name of category or attribute

    CategoryId      - returned GOPHER_CATEGORY_ id

    AttributeId     - returned GOPHER_ATTRIBUTE_ id

Return Value:

    None.

--*/

{
    DWORD category;
    DWORD attribute;

    if (AttributeName == NULL) {
        category = GOPHER_CATEGORY_ID_ALL;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_INFO_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_INFO;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_VIEWS_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_VIEWS;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_ABSTRACT;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_VERONICA_CATEGORY)) {
        category = GOPHER_CATEGORY_ID_VERONICA;
        attribute = GOPHER_ATTRIBUTE_ID_ALL;
    } else if (!stricmp(AttributeName, GOPHER_ADMIN_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_MOD_DATE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_MOD_DATE;
    } else if (!stricmp(AttributeName, GOPHER_TTL_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_TTL;
    } else if (!stricmp(AttributeName, GOPHER_SCORE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_SCORE;
    } else if (!stricmp(AttributeName, GOPHER_RANGE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_RANGE;
    } else if (!stricmp(AttributeName, GOPHER_SITE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_SITE;
    } else if (!stricmp(AttributeName, GOPHER_ORG_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_ORG;
    } else if (!stricmp(AttributeName, GOPHER_LOCATION_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_LOCATION;
    } else if (!stricmp(AttributeName, GOPHER_GEOG_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_CATEGORY_ID_ADMIN;
    } else if (!stricmp(AttributeName, GOPHER_TIMEZONE_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_TIMEZONE;
    } else if (!stricmp(AttributeName, GOPHER_PROVIDER_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_PROVIDER;
    } else if (!stricmp(AttributeName, GOPHER_VERSION_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ADMIN;
        attribute = GOPHER_ATTRIBUTE_ID_VERSION;
    } else if (!stricmp(AttributeName, GOPHER_ABSTRACT_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_ABSTRACT;
        attribute = GOPHER_ATTRIBUTE_ID_ABSTRACT;
    } else if (!stricmp(AttributeName, GOPHER_VIEW_ATTRIBUTE)) {
        category = GOPHER_CATEGORY_ID_VIEWS;
        attribute = GOPHER_ATTRIBUTE_ID_VIEW;
    } else {
        category = GOPHER_CATEGORY_ID_UNKNOWN;
        attribute = GOPHER_ATTRIBUTE_ID_UNKNOWN;
    }
    *CategoryId = category;
    *AttributeId = attribute;
}


BOOL
MapAttributeIdToNames(
    IN DWORD AttributeId,
    OUT LPSTR* CategoryName,
    OUT LPSTR* AttributeName
    )

/*++

Routine Description:

    Do reverse transformation: given attribute ID, return the category and
    attribute names if known

Arguments:

    AttributeId     - id to map

    CategoryName    - pointer to pointer to category name

    AttributeName   - pointer to pointer to attribute name

Return Value:

    BOOL
        TRUE    - id was mapped

        FALSE   - id not recognized

--*/

{
    BOOL success = TRUE;

    switch (AttributeId) {
    case GOPHER_CATEGORY_ID_ALL:
        *CategoryName = NULL;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_INFO:
        *CategoryName = GOPHER_INFO_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_ADMIN:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_VIEWS:
        *CategoryName = GOPHER_VIEWS_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_ABSTRACT:
        *CategoryName = GOPHER_ABSTRACT_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_CATEGORY_ID_VERONICA:
        *CategoryName = GOPHER_VERONICA_CATEGORY;
        *AttributeName = NULL;
        break;

    case GOPHER_ATTRIBUTE_ID_ADMIN:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_ADMIN_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_MOD_DATE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_MOD_DATE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_TTL:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_TTL_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_SCORE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_SCORE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_RANGE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_RANGE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_SITE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_SITE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_ORG:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_ORG_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_LOCATION:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_LOCATION_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_GEOG:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_GEOG_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_TIMEZONE:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_TIMEZONE_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_PROVIDER:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_PROVIDER_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_VERSION:
        *CategoryName = GOPHER_ADMIN_CATEGORY;
        *AttributeName = GOPHER_VERSION_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_ABSTRACT:
        *CategoryName = GOPHER_ABSTRACT_CATEGORY;
        *AttributeName = GOPHER_ABSTRACT_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_VIEW:
        *CategoryName = GOPHER_VIEWS_CATEGORY;
        *AttributeName = GOPHER_VIEW_ATTRIBUTE;
        break;

    case GOPHER_ATTRIBUTE_ID_UNKNOWN:
        success = FALSE;
        break;

    default:
        success = FALSE;
        break;
    }
    return success;
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)


DWORD
GetGopherNumber(
    IN OUT LPSTR* pString
    )

/*++

Routine Description:

    Converts a 'gopher number' to a DWORD. A gopher number is the value usually
    contained with angle brackets in e.g. a +VIEWS line, and is usually a
    fractional number with a 'k' suffix

Arguments:

    pString - pointer to pointer to string which points at the start of the
              number. The number may start with a period, indicating that it
              is less than one (hence the reason why we use a double).

              On output, the parameter points at the character after what we
              took to be the number

Return Value:

    DWORD
        DWORD representation of the number at *pString

--*/

{

    double number;

    //
    // the gopher number is usually inside angle brackets. Move the string
    // pointer past the opening bracket, if the caller has not already
    // done so
    //

    if (**pString == '<') {
        ++*pString;
    }

    //
    // allow strtod to move the string pointer forward
    //

    number = StrToDbl(*pString, pString);

    return (DWORD)number;
}


BOOL
ExtractDateAndTime(
    IN OUT LPSTR* pString,
    OUT LPFILETIME pFileTime
    )

/*++

Routine Description:

    Converts a 'gopher time-and-date' field to a WIN32 FILETIME structure. The
    gopher date-time field is a string representation of the date and time,
    contained within angle brackets and has the following format:

        <YYYYMMDDhhmmss>

    Where:

        YYYY = year (e.g. "1995")
        MM   = month (1..12)
        DD   = day of month
        hh   = hour of day in 24-hour format
        mm   = minute of hour
        ss   = second of minute

    Assumes:    1. On input, *pString contains entire field

Arguments:

    pString     - IN: points to the first character in the date-time field
                  OUT: points to the next character in the input stream

    pFileTime   - pointer to returned FILETIME structure

Return Value:

    BOOL
        Success - TRUE  - field was converted

        Failure - FALSE - a problem occurred while parsing the field

--*/

{
    SYSTEMTIME systemTime;

    if (**pString == '<') {
        ++*pString;
    }
    if (ExtractWord(pString, 4, &systemTime.wYear)
    && ExtractWord(pString, 2, &systemTime.wMonth)
    && ExtractWord(pString, 2, &systemTime.wDay)
    && ExtractWord(pString, 2, &systemTime.wHour)
    && ExtractWord(pString, 2, &systemTime.wMinute)
    && ExtractWord(pString, 2, &systemTime.wSecond)) {

        INET_ASSERT(**pString == '>');

        ++*pString;
        systemTime.wDayOfWeek = 0;
        systemTime.wMilliseconds = 0;
        return SystemTimeToFileTime(&systemTime, pFileTime);
    } else {

        INET_ASSERT(FALSE);

        return FALSE;
    }
}


BOOL
ExtractView(
    IN OUT LPSTR* pString,
    OUT LPSTR ContentType,
    IN OUT LPDWORD ContentTypeLength,
    OUT LPSTR Language,
    IN OUT LPDWORD LanguageLength,
    OUT LPDWORD Size
    )

/*++

Routine Description:

    Given a pointer to a line containing a view, parse it into its constituent
    parts. A view line has the following format:

        "{space}{content-type}{space}[{language-id}:]<{size}><CR><LF>"

    The language-id field is optional

Arguments:

    pString             - pointer to pointer to view line

    ContentType         - pointer to returned MIME content-type string

    ContentTypeLength   - IN: size of content-type buffer
                          OUT: length of content-type without terminating 0

    Language            - pointer to ISO-693 language-id (or NUL string)

    LanguageLength      - IN: size of language buffer
                          OUT: length of language without terminating 0

    Size                - pointer to returned size of view

Return Value:

    BOOL

--*/

{
    LPSTR string;
    DWORD contLen = 0;
    DWORD langLen = 0;

    string = *pString;
    while (*string == ' ') {
        ++string;
    }
    while (*string != ' ') {
        if (contLen >= *ContentTypeLength)
            return FALSE;
        *ContentType++ = *string++;
        contLen++;
    }
    *ContentType = '\0';
    *ContentTypeLength = contLen;
    while (*string == ' ') {
        ++string;
    }
    if (*string != '<') {

        //
        // must be the language field. Copy up to the terminating ':' or ' '
        //

        while ((*string != ' ') && (*string != ':')) {
            if (langLen >= *LanguageLength)
                return FALSE;
            *Language++ = *string++;
            langLen++;
        }

        //
        // move the string pointer to the start of the size field
        //

        while (*string != '<') {
            ++string;
        }
    }
    *Language = '\0';
    *LanguageLength = langLen;
    *Size = GetGopherNumber(&string);
    *pString = string;
    return TRUE;
}

#if defined(GOPHER_ATTRIBUTE_SUPPORT)

//
// manifests
//

#define SIZE_OF_GOPHER_ATTRIBUTE_FIXED_PART (2 * sizeof(DWORD))

//
// private types
//

typedef struct {
    DWORD CategoryId;
    DWORD AttributeId;
    DWORD (*Parser)(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
    DWORD NumberOfFields;
    DWORD FixedSize;
} ATTRIBUTE_PARSER, *LPATTRIBUTE_PARSER;

typedef struct {
    LPCSTR String;
} SINGLE_STRING_TYPE, *LPSINGLE_STRING_TYPE;

//
// private parser prototypes
//

PRIVATE DWORD ParseAdminAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseModDateAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseAbstractAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseViewAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseTreewalkAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseIntField(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseDwordField(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseStringField(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);
PRIVATE DWORD ParseUnknownAttribute(LPSTR*, LPDWORD, LPBYTE, LPDWORD, DWORD, DWORD);

//
// data
//

ATTRIBUTE_PARSER AttributeParsers[] = {
    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_ADMIN,
            ParseAdminAttribute,
                2,
                    sizeof(GOPHER_ADMIN_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_MOD_DATE,
            ParseModDateAttribute,
                1,
                    sizeof(GOPHER_MOD_DATE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_TTL,
            ParseDwordField,
                1,
                    sizeof(GOPHER_TTL_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_SCORE,
            ParseIntField,
                1,
                    sizeof(GOPHER_SCORE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_RANGE,
            ParseIntField,
                2,
                    sizeof(GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_SITE,
            ParseStringField,
                1,
                    sizeof(GOPHER_SITE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_ORG,
            ParseStringField,
                1,
                    sizeof(GOPHER_ORGANIZATION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_LOCATION,
            ParseStringField,
                1,
                    sizeof(GOPHER_LOCATION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_GEOG,
            ParseIntField,
                6,
                    sizeof(GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_TIMEZONE,
            ParseIntField,
                1,
                    sizeof(GOPHER_TIMEZONE_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_PROVIDER,
            ParseStringField,
                1,
                    sizeof(GOPHER_PROVIDER_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ADMIN,
        GOPHER_ATTRIBUTE_ID_VERSION,
            ParseStringField,
                1,
                    sizeof(GOPHER_VERSION_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_ABSTRACT,
        GOPHER_ATTRIBUTE_ID_ABSTRACT,
            ParseAbstractAttribute,
                2,
                    sizeof(GOPHER_ABSTRACT_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_VIEWS,
        GOPHER_ATTRIBUTE_ID_VIEW,
            ParseViewAttribute,
                3,
                    sizeof(GOPHER_VIEW_ATTRIBUTE_TYPE),

    GOPHER_CATEGORY_ID_VERONICA,
        GOPHER_ATTRIBUTE_ID_TREEWALK,
            ParseTreewalkAttribute,
                1,
                    sizeof(GOPHER_VERONICA_ATTRIBUTE_TYPE),

    //
    // N.B. Unknown must be the last parser in the list
    //

    GOPHER_CATEGORY_ID_UNKNOWN,
        GOPHER_ATTRIBUTE_ID_UNKNOWN,
            ParseUnknownAttribute,
                1,
                sizeof(GOPHER_UNKNOWN_ATTRIBUTE_TYPE)
};

#define NUMBER_OF_PARSERS   ARRAY_ELEMENTS(AttributeParsers)

//
// functions
//


BOOL
FindAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN LPCSTR AttributeName,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    CategoryId      -
    AttributeId     -
    AttributeName   -
    Buffer          -
    BufferLength    -

Return Value:

    BOOL

--*/

{
    BOOL ok;
    LPSTR categoryName;
    LPSTR attributeName;
    char searchName[DEFAULT_ATTRIBUTE_NAME_LENGTH + 1];
    DWORD id;
    int index;
    int len;

    if (AttributeId == GOPHER_ATTRIBUTE_ID_ALL) {
        id = CategoryId;
    } else {
        id = AttributeId;
    }
    ok = MapAttributeIdToNames(id, &categoryName, &attributeName);
    if (!ok) {
        attributeName = (LPSTR)AttributeName;
    }
    if (AttributeId != GOPHER_ATTRIBUTE_ID_ALL) {
        searchName[0] = ' ';
        index = 1;
    } else {
        index = 0;
        attributeName = categoryName;
    }
    len = strlen(attributeName);
    if (len >= sizeof(searchName)) {
        return FALSE;
    }
    strcpy(&searchName[index], attributeName);
    len += index;
    if (AttributeId != GOPHER_ATTRIBUTE_ID_ALL) {
        searchName[len++] = ':';
        searchName[len] = '\0';
    }
    do {
        if (*BufferLength < (DWORD)len) {
            return FALSE;
        }
        if (memcmp(*Buffer, searchName, len) == 0) {
            return TRUE;
        }
        SkipLine(Buffer, BufferLength);
    } while (*BufferLength != 0);
    return FALSE;
}


VOID
FindNextAttribute(
    IN DWORD CategoryId,
    IN DWORD AttributeId,
    IN OUT LPSTR* Buffer,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    CategoryId      -
    AttributeId     -
    Buffer          -
    BufferLength    -

Return Value:

    None.

--*/

{
    BOOL found;

    INET_ASSERT((**Buffer == '+') || (**Buffer == ' '));

    if (CategoryId == GOPHER_CATEGORY_ID_UNKNOWN) {
        AttributeId = !GOPHER_ATTRIBUTE_ID_ALL;
    }

    //
    // loop looking at the next line until we find:
    //
    //  a) the end of the buffer
    //  b) the next section line (starts with '+')
    //  c) the next attribute line (starts with ' ')
    //

    for (found = FALSE; !found; ) {
        if (SkipLine(Buffer, BufferLength)) {
            if (AttributeId == GOPHER_ATTRIBUTE_ID_ALL) {
                found = (BOOL)(**Buffer == '+');
            } else {
                found = TRUE;
            }
        } else {

            //
            // end of buffer
            //

            found = TRUE;
        }
    }
}


DWORD
EnumerateAttribute(
    IN GOPHER_ATTRIBUTE_ENUMERATOR Enumerator,
    IN LPSTR LinePtr,
    IN DWORD LineLength,
    IN LPBYTE Buffer,
    IN DWORD BufferLength,
    OUT LPBOOL ResumeEnumeration
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Enumerator          -
    LinePtr             -
    LineLength          -
    Buffer              -
    BufferLength        -
    ResumeEnumeration   -

Return Value:

    DWORD

--*/

{
    DWORD error;
    char attributeName[DEFAULT_ATTRIBUTE_NAME_LENGTH + 1];
    DWORD nameLength;

    nameLength = sizeof(attributeName);
    error = ExtractAttributeName(attributeName,
                                 &nameLength,
                                 &LinePtr,
                                 &LineLength
                                 );
    if (error == ERROR_SUCCESS) {

        int i;
        DWORD categoryId;
        DWORD attributeId;
        BOOL found;

        MapAttributeToIds((LPCSTR)attributeName,
                          &categoryId,
                          &attributeId
                          );

        //
        // loop, looking fot the parser to handle this particular type. If we
        // don't find it, we will be conveniently left at the unknown parser
        // (that's why we have (NUMBER_OF_PARSERS - 1) and the unknown parser
        // at the end of the list)
        //

        for (i = 0; i < NUMBER_OF_PARSERS - 1; ++i) {
            if ((AttributeParsers[i].CategoryId == categoryId)
            && (AttributeParsers[i].AttributeId == attributeId)) {
                break;
            }
        }
        if (BufferLength >= SIZE_OF_GOPHER_ATTRIBUTE_FIXED_PART) {
            ((LPGOPHER_ATTRIBUTE_TYPE)Buffer)->CategoryId = categoryId;
            ((LPGOPHER_ATTRIBUTE_TYPE)Buffer)->AttributeId = attributeId;

            //
            // remove the fixed part from the buffer size before converting
            // the attribute
            //

            BufferLength -= SIZE_OF_GOPHER_ATTRIBUTE_FIXED_PART;
        } else {
            BufferLength = 0;
        }
        error = AttributeParsers[i].Parser(
                    &LinePtr,
                    &LineLength,
                    (LPBYTE)&((LPGOPHER_ATTRIBUTE_TYPE)Buffer)->AttributeType,
                    &BufferLength,
                    AttributeParsers[i].NumberOfFields,
                    AttributeParsers[i].FixedSize
                    );

        //
        // add back the amount of buffer space used by/required for the
        // fixed part of the GOPHER_ATTRIBUTE_TYPE structure
        //
        *ResumeEnumeration = Enumerator((LPGOPHER_ATTRIBUTE_TYPE)Buffer, error);
    }
    return error;
}


PRIVATE
DWORD
ParseIntField(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD error;

    if (*BufferLength < FixedSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = FixedSize;
    while ((error == ERROR_SUCCESS) && NumberOfFields--) {
        if (SkipLeading(LinePtr, LineLength)) {
            ExtractInt(LinePtr, 0, (LPINT)Buffer);
            Buffer = (LPBYTE)((LPINT)Buffer + 1);
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseDwordField(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD error;

    if (*BufferLength < FixedSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = FixedSize;
    while ((error == ERROR_SUCCESS) && NumberOfFields--) {
        if (SkipLeading(LinePtr, LineLength)) {
            ExtractDword(LinePtr, 0, (LPDWORD)Buffer);
            Buffer = (LPBYTE)((LPDWORD)Buffer + 1);
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseStringField(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;
    DWORD stringLength;
    LPSTR stringPtr;
    LPSTR* fieldPtr;

    structureSize = 0;
    error = ERROR_SUCCESS;
    stringPtr = (LPSTR)((LPSTR)Buffer + NumberOfFields);
    fieldPtr = (LPSTR*)Buffer;
    while (NumberOfFields--) {
        SkipLeading(LinePtr, LineLength);
        stringLength = CharacterCount(LinePtr, LineLength, "\r\n");
        structureSize = sizeof(LPSTR)
                      + stringLength
                      + 1
                      ;
        if (*BufferLength >= structureSize) {
            *fieldPtr++ = stringPtr;
            CopyString(&stringPtr, *LinePtr, stringLength);
            *LinePtr += stringLength - 1;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    *BufferLength = structureSize;
    return error;
}


PRIVATE
DWORD
ParseAdminAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    LPSTR comment;
    DWORD commentLength;
    LPSTR emailAddress;
    DWORD emailAddressLength;
    LPSTR pstr;
    DWORD len;
    DWORD structureSize;
    DWORD error;

    SkipLeading(LinePtr, LineLength);
    comment = *LinePtr;
    emailAddress = strchr(*LinePtr, '<');
    if (emailAddress == NULL) {
        return ERROR_GOPHER_DATA_ERROR;
    }
    ++emailAddress;
    pstr = emailAddress;
    emailAddressLength = 0;
    len = *LineLength;
    while ((*pstr != '>') && (len != 0)) {
        ++pstr;
        ++emailAddressLength;
    }
    commentLength = (DWORD)(emailAddress - comment);
    structureSize = sizeof(GOPHER_ADMIN_ATTRIBUTE_TYPE)
                  + commentLength + 1
                  + emailAddressLength + 1
                  ;
    if (*BufferLength < structureSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = structureSize;
    if (error == ERROR_SUCCESS) {

        LPGOPHER_ADMIN_ATTRIBUTE_TYPE pStruct;
        LPSTR stringPtr;

        pStruct = (LPGOPHER_ADMIN_ATTRIBUTE_TYPE)Buffer;
        stringPtr = (LPSTR)pStruct + sizeof(GOPHER_ADMIN_ATTRIBUTE_TYPE);
        pStruct->Comment = (LPCSTR)stringPtr;
        CopyString(&stringPtr, comment, commentLength);
        pStruct->EmailAddress = (LPCSTR)stringPtr;
        CopyString(&stringPtr, emailAddress, emailAddressLength);
    }
    return error;
}


PRIVATE
DWORD
ParseModDateAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;

    structureSize = sizeof(GOPHER_MOD_DATE_ATTRIBUTE_TYPE);
    if (*BufferLength < structureSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = structureSize;
    if (error == ERROR_SUCCESS) {

        LPSTR dateField;

        dateField = strchr(*LinePtr, '<');
        if (dateField != NULL) {
            ExtractDateAndTime(
                &dateField,
                &((LPGOPHER_MOD_DATE_ATTRIBUTE_TYPE)Buffer)->DateAndTime
                );
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseAbstractAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD error;
    error = ERROR_SUCCESS;
    return error;
}


PRIVATE
DWORD
ParseViewAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    char contentType[DEFAULT_CONTENT_TYPE_NAME_LENGTH + 1];
    DWORD contentTypeLength;
    char language[DEFAULT_LANGUAGE_NAME_LENGTH + 1];
    DWORD languageLength;
    DWORD viewSize;
    BOOL ok;
    DWORD error;

    contentTypeLength = sizeof(contentType);
    languageLength = sizeof(language);
    SkipLeading(LinePtr, LineLength);
    ok = ExtractView(LinePtr,
                     contentType,
                     &contentTypeLength,
                     language,
                     &languageLength,
                     &viewSize
                     );
    if (ok) {

        DWORD structureSize;

        contentTypeLength = sizeof(contentType) - contentTypeLength;
        languageLength = sizeof(language) - languageLength;
        structureSize = sizeof(GOPHER_VIEW_ATTRIBUTE_TYPE)
                      + contentTypeLength
                      + languageLength
                      ;
        if (*BufferLength >= structureSize) {

            LPSTR stringPtr;

            stringPtr = (LPSTR)((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer + 1);
            ((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer)->ContentType = stringPtr;
            memcpy(stringPtr, contentType, contentTypeLength);
            stringPtr += contentTypeLength;
            ((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer)->Language = stringPtr;
            memcpy(stringPtr, language, languageLength);
            ((LPGOPHER_VIEW_ATTRIBUTE_TYPE)Buffer)->Size = viewSize;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        *BufferLength = structureSize;
    } else {
        error = ERROR_GOPHER_DATA_ERROR;
    }
    return error;
}


PRIVATE
DWORD
ParseTreewalkAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;

    structureSize = sizeof(GOPHER_VERONICA_ATTRIBUTE_TYPE);
    if (*BufferLength < structureSize) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        error = ERROR_SUCCESS;
    }
    *BufferLength = structureSize;
    if (error == ERROR_SUCCESS) {
        SkipLeading(LinePtr, LineLength);
        if (*LineLength >= 3) {

            BOOL ok;

            ok = (BOOL)(_strnicmp(*LinePtr, "YES", 3) == 0);

            ((LPGOPHER_VERONICA_ATTRIBUTE_TYPE)Buffer)->TreeWalk = ok;
        } else {
            error = ERROR_GOPHER_DATA_ERROR;
        }
    }
    return error;
}


PRIVATE
DWORD
ParseUnknownAttribute(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    OUT LPBYTE Buffer,
    IN OUT LPDWORD BufferLength,
    IN DWORD NumberOfFields,
    IN DWORD FixedSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    LinePtr         -
    LineLength      -
    Buffer          -
    BufferLength    -
    NumberOfFields  -
    FixedSize       -

Return Value:

    DWORD

--*/

{
    DWORD structureSize;
    DWORD error;
    DWORD stringLength;
    LPSTR stringPtr;

    stringPtr = (LPSTR)((LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE)Buffer + 1);
    ((LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE)Buffer)->Text = stringPtr;
    SkipLeading(LinePtr, LineLength);
    structureSize = sizeof(GOPHER_UNKNOWN_ATTRIBUTE_TYPE)
                  + *LineLength
                  + 1
                  ;
    if (*BufferLength >= structureSize) {
        CopyString(&stringPtr, *LinePtr, *LineLength);
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *BufferLength = structureSize;
    return error;
}


PRIVATE
DWORD
ExtractAttributeName(
    OUT LPSTR AttributeName,
    IN OUT LPDWORD AttributeNameLength,
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    AttributeName       -
    AttributeNameLength -
    LinePtr             -
    LineLength          -

Return Value:

    DWORD

--*/

{
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CharacterCount(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength,
    IN LPSTR TerminationSet
    )

/*++

Routine Description:

    Returns the number of characters in a string, up to, but not including
    the termination character. Termination character is defined as being a
    member of TerminationSet

Arguments:

    LinePtr         - IN: Pointer to string to count characters in
                      OUT: Pointer to string at character found from
                      TerminationSet

    LineLength      - IN: Current length of LinePtr
                      OUT: Remaining length of LinePtr

    TerminationSet  - Pointer to string containing characters which will
                      terminate counting

Return Value:

    DWORD
        Number of character in LinePtr, up to, but not including the
        termination character

--*/

{
    char terminationChars[256];
    int i;
    DWORD count;

    //
    // zap discovery matrix, 4 bytes at a time
    //

    for (i = 0; i < ARRAY_ELEMENTS(terminationChars); i += sizeof(DWORD)) {
        *(LPDWORD)&terminationChars[i] = 0;
    }

    //
    // for each character that we are interested in, set its matrix entry to
    // non-zero
    //

    for (i = 0; TerminationSet[i] != '\0'; ++i) {
        terminationChars[(int)TerminationSet[i]] = 1;
    }

    //
    // loop, looking for end-of-string (LineLength decremented to 0) or one
    // of the termination characters
    //

    for (count = 0; *LineLength != 0; ) {

        char ch;

        ch = *(*LinePtr)++;
        --*LineLength;
        if (terminationChars[(int)ch]) {
            break;
        }
        ++count;
    }
    return count;
}


PRIVATE
DWORD
CountCharactersToEol(
    IN OUT LPSTR* LinePtr,
    IN OUT LPDWORD LineLength
    )

/*++

Routine Description:

    Special-case version of CharacterCount - knows that the termination set
    comprised <CR>, <LF>

Arguments:

    LinePtr     - Pointer to pointer to string to count. Updated on output

    LineLength  - Pointer to length of string. Updated on output

Return Value:

    DWORD
        Length of string

--*/

{
    int i;
    DWORD count;

    //
    // loop, looking for end-of-string (LineLength decremented to 0) or one
    // of the termination characters
    //

    for (count = 0; *LineLength != 0; ) {

        char ch;

        ch = *(*LinePtr)++;
        --*LineLength;
        if ((ch == '\r') || (ch == '\n')) {
            break;
        }
        ++count;
    }
    return count;
}


PRIVATE
BOOL
SkipLeading(
    IN OUT LPSTR* String,
    IN OUT LPDWORD Length
    )
{
    while (((**String == ' ') || (**String == ':')) && (*Length != 0)) {
        ++*String;
        --*Length;
    }
    return (BOOL)(*Length != 0);
}


PRIVATE
VOID
CopyString(
    IN OUT LPSTR* String,
    IN LPSTR Source,
    IN DWORD Length
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    String  -
    Source  -
    Length  -

Return Value:

    None.

--*/

{
    memcpy(*String, Source, Length);
    *String += Length;
    *((*String)++) = '\0';
}

#endif // defined(GOPHER_ATTRIBUTE_SUPPORT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\session.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    session.h

Abstract:

    Manifests, macros, types, prototypes for session.c

Author:

    Richard L Firth (rfirth) 25-Oct-1994

Revision History:

    25-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// types
//

//
// SESSION_INFO - describes a session with a gopher server. We will keep a cache
// of these. Only one 'conversation' can be active at any one time with a gopher
// server. Threads must wait on the mutex handle
//

typedef struct _SESSION_INFO {

    //
    // List - SESSION_INFOs are maintained on double-linked list
    //

    LIST_ENTRY List;

    //
    // ReferenceCount - used to keep this session alive when there are
    // concurrent creates/deletes on different threads
    //

    LONG ReferenceCount;

    //
    // Handle - identifies this session to the application
    //

    HANDLE Handle;

    //
    // Flags - various control flags. See below
    //

    DWORD Flags;

    //
    // Host - name of host with which we have a connection
    //

    LPSTR Host;

    //
    // Port - port number at which gopher server listens at Host
    //

    DWORD Port;

    //
    // FindList - protected, doubly-linked list of VIEW_INFO 'object's generated
    // by gopher directory requests
    //

    SERIALIZED_LIST FindList;

    //
    // FileList - protected, doubly-linked list of VIEW_INFO 'object's generated
    // by gopher document (file) requests
    //

    SERIALIZED_LIST FileList;

} SESSION_INFO, *LPSESSION_INFO;

//
// SESSION_INFO flags
//

#define SI_GOPHER_PLUS      0x00000001  // gopher server at Host is gopher+
#define SI_CLEANUP          0x00000002  // set by CleanupSession()
#define SI_PERSISTENT       0x80000000  // connection to gopher server kept alive

//
// macros
//

#define UNKNOWN_GOPHER(session) ((session)->Flags & (SI_GOPHER_ZERO | SI_GOPHER_PLUS) == 0)

//
// public data
//

extern SERIALIZED_LIST SessionList;

DEBUG_DATA_EXTERN(LONG, NumberOfSessions);

//
// prototypes
//

VOID
AcquireSessionLock(
    VOID
    );

VOID
ReleaseSessionLock(
    VOID
    );

VOID
CleanupSessions(
    VOID
    );

LPSESSION_INFO
FindOrCreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    );

VOID
ReferenceSession(
    IN LPSESSION_INFO SessionInfo
    );

LPSESSION_INFO
DereferenceSession(
    IN LPSESSION_INFO SessionInfo
    );

VOID
AcquireViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    );

VOID
ReleaseViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    );

DWORD
GopherTransaction(
    IN LPVIEW_INFO ViewInfo
    );

BOOL
IsGopherPlusSession(
    IN LPSESSION_INFO SessionInfo
    );

DWORD
SearchSessionsForAttribute(
    IN LPSTR Locator,
    IN LPSTR Attribute,
    IN LPBYTE Buffer,
    IN OUT LPDWORD BufferLength
    );

//
// macros
//

#if INET_DEBUG

#define SESSION_CREATED()   ++NumberOfBuffers
#define SESSION_DESTROYED() --NumberOfBuffers
#define ASSERT_NO_SESSIONS() \
    if (NumberOfSessions != 0) { \
        INET_ASSERT(FALSE); \
    }

#else

#define SESSION_CREATED()       /* NOTHING */
#define SESSION_DESTROYED()     /* NOTHING */
#define ASSERT_NO_SESSIONS()    /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\sockets.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sockets.cxx

Abstract:

    Contains functions to interface between gopher APIs and Winsock

    Contents:
        GopherConnect
        GopherDisconnect
        GopherSendRequest
        GopherReceiveResponse

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Environment:

    Win32(s) user-mode DLL

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define DEFAULT_RESPONSE_BUFFER_LENGTH  (4 K)

//
// functions
//


DWORD
GopherConnect(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Makes a connection to a (gopher) server. Sets a receive timeout on the
    connected socket

Arguments:

    ViewInfo    - pointer to VIEW_INFO containing pointer to SESSION_INFO which
                  describes server to connect to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherConnect",
                "%#x",
                ViewInfo
                ));

    DWORD error;
    BOOL  fSuccess;
    INTERNET_CONNECT_HANDLE_OBJECT *pConnect;
    PROXY_STATE *pProxyState = NULL;

    INET_ASSERT(ViewInfo->BufferInfo != NULL);
    INET_ASSERT(ViewInfo->SessionInfo != NULL);

    //
    // determine sync or async
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // Set the port we're using on the socket object.
    //

    ViewInfo->BufferInfo->Socket->SetPort((INTERNET_PORT) ViewInfo->SessionInfo->Port);

    //
    // Using the object handle, check to see if we have a socks proxy.
    //  If so, use it to do our connections.
    //

    INTERNET_HANDLE_OBJECT * pInternet;
    HINTERNET hConnectMapped;

    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(ViewInfo->SessionInfo->Host != NULL);

    //
    // Get the Mapped Connect Handle Object...
    //

    INET_ASSERT( (ViewInfo->ViewType == ViewTypeFile) ||
                 (ViewInfo->ViewType == ViewTypeFind) );

    hConnectMapped = ((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetParent();

    INET_ASSERT(hConnectMapped);

    //
    // Finally get the Internet Object, so we can query proxy information
    //  out of it.
    //

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *) hConnectMapped;

    pInternet = (INTERNET_HANDLE_OBJECT *)
                    ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->GetParent();

    INET_ASSERT(pInternet);

    {

        AUTO_PROXY_ASYNC_MSG proxyInfoQuery(
                                    INTERNET_SCHEME_GOPHER,
                                    pConnect->GetURL(),
                                    lstrlen(pConnect->GetURL()),
                                    ViewInfo->SessionInfo->Host,
                                    lstrlen(ViewInfo->SessionInfo->Host),
                                    (INTERNET_PORT) ViewInfo->SessionInfo->Port
                                    );

        AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery;

        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);

        pProxyInfoQuery = &proxyInfoQuery;

        error = pInternet->GetProxyInfo(
                                &pProxyInfoQuery
                                );

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }

        if (pProxyInfoQuery->IsUseProxy() &&
            pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_SOCKS &&
            pProxyInfoQuery->_lpszProxyHostName )
        {
            //
            //  If there is Socks enabled, then turned it on.
            //

            error = ViewInfo->BufferInfo->Socket->EnableSocks(
                                                               pProxyInfoQuery->_lpszProxyHostName,
                                                               pProxyInfoQuery->_nProxyHostPort
                                                               );
        }

        if ( pProxyInfoQuery && pProxyInfoQuery->IsAlloced() )
        {
            delete pProxyInfoQuery;
            pProxyInfoQuery = NULL;
        }

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }

    }


    error = ViewInfo->BufferInfo->Socket->Connect(
                          GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                          GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                          SF_INDICATE | asyncFlags
                          );

    if (error == ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("GopherConnect(): ConnectSocket() returns socket %#x\n",
                    //ViewInfo->BufferInfo->ConnectedSocket.Socket
                    ViewInfo->BufferInfo->Socket->GetSocket()
                    ));

        //
        // we have made a connection with the server. Set the receive timeout.
        // If this fails for any reason, ignore it (although the socket is
        // probably bad if this is true)
        //

        ViewInfo->BufferInfo->Socket->SetTimeout(
                                RECEIVE_TIMEOUT,
                                GetTimeoutValue(INTERNET_OPTION_RECEIVE_TIMEOUT)
                                );
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("GopherConnect(): ConnectSocket() returns %d\n",
                    error
                    ));

    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GopherDisconnect(
    IN LPVIEW_INFO ViewInfo,
    IN BOOL AbortConnection
    )

/*++

Routine Description:

    Disconnects from the gopher server if the session is not flagged as
    persistent. The socket is closed

Arguments:

    ViewInfo        - pointer to VIEW_INFO containing pointer to SESSION_INFO
                      which describes connection to gopher server

    AbortConnection - TRUE if the connection is to be terminated, even if it is
                      a persistent connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherDisconnect",
                "%#x, %B",
                ViewInfo,
                AbortConnection
                ));

    DWORD error;
    LPSESSION_INFO sessionInfo;

    INET_ASSERT(ViewInfo->SessionInfo != NULL);

    sessionInfo = ViewInfo->SessionInfo;
    if (!(sessionInfo->Flags & SI_PERSISTENT) || AbortConnection) {

        LPBUFFER_INFO bufferInfo;

        INET_ASSERT(ViewInfo->BufferInfo != NULL);

        bufferInfo = ViewInfo->BufferInfo;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("GopherDisconnect(): closing socket %#x\n",
                    //bufferInfo->ConnectedSocket.Socket
                    bufferInfo->Socket->GetSocket()
                    ));

        error = bufferInfo->Socket->Disconnect();

        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("GopherDisconnect(): Disconnect(%#x) returns %d\n",
                        ViewInfo->BufferInfo->Socket->GetSocket(),
                        error
                        ));

        }
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GopherSendRequest(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Sends a gopher request to the server we are currently connected to. The
    request is the selector string used to tell the gopher server what to return

Arguments:

    ViewInfo    - pointer to VIEW_INFO describing request. Contains pointer to
                  CR/LF terminated text string gopher request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherSendRequest",
                "%#x",
                ViewInfo
                ));

    DWORD error;

    //
    // determine sync or async
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    error = ViewInfo->BufferInfo->Socket->Send(ViewInfo->Request,
                                               ViewInfo->RequestLength,
                                               SF_INDICATE
                                               );

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
GopherReceiveResponse(
    IN OUT LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReceived
    )

/*++

Routine Description:

    This function is called iteratively to receive the gopher response data. The
    first time this function is called, we determine the type of response -
    success or failure, gopher0 or gopher+.

    The buffer information passed in can refer to a buffer that we maintain
    internally (for directories), or to a buffer that the caller supplies to the
    GopherReadFile() function. In the latter case, the buffer address and length
    may be 0.

    This function assumes that directory responses will be received into a
    buffer which we allocate in this function, and that file requests are
    received into caller-supplied (user-supplied) buffers

Arguments:

    ViewInfo        - pointer to VIEW_INFO structure (including BUFFER_INFO)
                      describing the gopher request and the response from the
                      server

    BytesReceived   - number of bytes received in this response

Return Value:

     DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_EXTENDED_ERROR
                    The server sent us some form of error text. The app should
                    use InternetGetLastResponseInfo() to get the text

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "GopherReceiveResponse",
                "%#x, %#x",
                ViewInfo,
                BytesReceived
                ));

    LPBUFFER_INFO bufferInfo;
    DWORD error;
    int bufferLength;
    LPBYTE buffer;
    LPBYTE responseBuffer;
    int bytesReceived;
    BOOL discardBuffer;
    BOOL terminateConnection;
    BOOL checkResponse;

    *BytesReceived = 0;

    bytesReceived = 0;
    terminateConnection = FALSE;
    checkResponse = FALSE;

    //
    // variables for SocketReceive()
    //

    LPVOID psrBuffer;
    DWORD srLength;
    DWORD srLeft;
    DWORD srReceived;
    BOOL eof;

    bufferInfo = ViewInfo->BufferInfo;

    INET_ASSERT(bufferInfo != NULL);

    //
    // determine sync or async
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }

    DWORD asyncFlags;

    asyncFlags = 0;
    //asyncFlags = lpThreadInfo->IsAsyncWorkerThread ? SF_NON_BLOCKING : 0;

    //
    // if this is the first receive for this buffer then figure out what we
    // received. At this point we may have no buffer (GopherOpenFile()) so we
    // set up the BUFFER_INFO with the required information for the next
    // GopherReadFile()
    //

    if (bufferInfo->Flags & BI_FIRST_RECEIVE) {

        //
        // determine what we have received
        //

        psrBuffer = (LPVOID)bufferInfo->ResponseInfo;
        srLength = sizeof(bufferInfo->ResponseInfo);
        srLeft = sizeof(bufferInfo->ResponseInfo);
        srReceived = 0;

        error = bufferInfo->Socket->Receive(&psrBuffer,
                                            &srLength,
                                            &srLeft,
                                            &srReceived,
                                            0,    // dwExtraSpace
                                            SF_INDICATE,
                                            &eof
                                            );
        if (error != ERROR_SUCCESS) {
            goto cleanup;
        } else if (srReceived == 0) {

            INET_ASSERT(eof);

            //
            // the server has closed the connection already.  We either end up
            // with a zero-length file, or return ERROR_NO_MORE_FILES from a
            // directory listing
            //

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("SocketsReceive() returns 0 bytes on initial read\n"
                        ));

            bufferInfo->Flags |= BI_RECEIVE_COMPLETE;
            goto cleanup;
        }

        //
        // BytesRemaining is the number of data bytes in ResponseInfo
        //

        bufferInfo->BytesRemaining = srReceived;
        bufferInfo->DataBytes = (LPBYTE)bufferInfo->ResponseInfo;

        if (ViewInfo->Flags & VI_GOPHER_PLUS) {

            //
            // gopher+ request: expecting gopher+ response: +/-#\r\n
            //

            if (bufferInfo->ResponseInfo[0] == GOPHER_PLUS_ERROR_INDICATOR) {
                bufferInfo->Flags |= BI_ERROR_RESPONSE;
            } else if (bufferInfo->ResponseInfo[0] != GOPHER_PLUS_SUCCESS_INDICATOR) {

                //
                // buffer does not start with + or -; assume we received a
                // gopher0 response, and down-grade the request
                //

                ViewInfo->Flags &= ~VI_GOPHER_PLUS;

                DEBUG_PRINT(SOCKETS,
                            WARNING,
                            ("Gopher+ request resulted in gopher0 response!\n"
                            ));

            }
        } else if ((ViewInfo->ViewType != ViewTypeFile)
        && (bufferInfo->ResponseInfo[0] == GOPHER_PLUS_ERROR_INDICATOR)) {

            //
            // if this is a gopher+ error response then we promote the request/
            // response to gopher+ and handle the error below. If it actually
            // turns out that someone has invented a locator that starts '-'
            // then we will again down-grade the request
            //

            bufferInfo->Flags |= BI_ERROR_RESPONSE;
            ViewInfo->Flags |= VI_GOPHER_PLUS;

            DEBUG_PRINT(SOCKETS,
                        WARNING,
                        ("Gopher0 request resulted in gopher+ response!\n"
                        ));

        }

        //
        // if we still think the request/response is gopher+ then extract the
        // response length
        //

        if (ViewInfo->Flags & VI_GOPHER_PLUS) {

            BOOL ok;
            LPSTR pNumber;

            pNumber = &bufferInfo->ResponseInfo[1];
            ok = ExtractInt(&pNumber,
                            0,
                            &bufferInfo->ResponseLength
                            );
            if (!ok || (*pNumber != '\r') || (*(pNumber + 1) != '\n')) {
                ViewInfo->Flags &= ~VI_GOPHER_PLUS;

                DEBUG_PRINT(SOCKETS,
                            WARNING,
                            ("Gopher+ request resulted in gopher0 response!\n"
                            ));

                //
                // probably isn't an error either
                //

                bufferInfo->Flags &= ~BI_ERROR_RESPONSE;
            } else {

                int numberLength;

                //
                // this is the number of bytes we copied to the ResponseInfo
                // buffer that belong in the response proper
                //

                numberLength = (int) (pNumber - bufferInfo->ResponseInfo) + 2;
                bufferInfo->DataBytes = (LPBYTE)&bufferInfo->ResponseInfo[numberLength];
                bufferInfo->BytesRemaining -= numberLength;
            }
        }

        //
        // if we are receiving a gopher0 (directory) response then we need to
        // check below if we really received an error
        //

        if (!(ViewInfo->Flags & VI_GOPHER_PLUS)) {
            checkResponse = TRUE;
        }

        //
        // no longer the first time receive
        //

        bufferInfo->Flags &= ~BI_FIRST_RECEIVE;
    }

    //
    // either get the user buffer pointer, or allocate/resize a moveable buffer
    // (for directory listings and errors)
    //
    // N.B. A special case here is an error received in response to a gopher0
    // directory request: we don't know at this point if a gopher0 directory
    // request has resulted in an error, but we have to allocate a buffer
    // anyway, so we will determine error status after we have received the
    // data
    //

    discardBuffer = FALSE;
    if (!(bufferInfo->Flags & (BI_BUFFER_RESPONSE | BI_ERROR_RESPONSE))) {
        buffer = bufferInfo->Buffer;
        bufferLength = bufferInfo->BufferLength;

        //
        // if we are given a zero length user buffer then quit now; the bytes
        // received parameter has already been zeroed
        //

        if (bufferLength == 0) {
            goto quit;
        }
    } else {

        //
        // if we know how much data is in the response AND it is less than the
        // default length, then allocate a buffer that will exactly fit the
        // response. Otherwise allocate a buffer large enough to fit the default
        // response length
        //

        if (bufferInfo->ResponseLength > 0) {
            bufferLength = min(bufferInfo->ResponseLength,
                               DEFAULT_RESPONSE_BUFFER_LENGTH
                               );
        } else {

            //
            // the response length is -1 or -2, or its a gopher0 response: we
            // don't know how large it is
            //

            bufferLength = DEFAULT_RESPONSE_BUFFER_LENGTH;
        }

        //
        // if this is the first time we have called this function, allocate the
        // buffer, else grow it to the new size
        //

        bufferInfo->Buffer = (LPBYTE)ResizeBuffer(bufferInfo->Buffer,
                                                  bufferInfo->BufferLength
                                                  + bufferLength,
                                                  FALSE
                                                  );
        if (bufferInfo->Buffer == NULL) {
            terminateConnection = TRUE;

            INET_ASSERT(FALSE);

            goto last_error_exit;
        }

        bufferInfo->Flags |= BI_OWN_BUFFER;

        //
        // start receiving the next chunk at the end of the previous one
        //

        buffer = bufferInfo->Buffer + bufferInfo->BufferLength;
    }

    //
    // if we haven't already received all the data (in DetermineGopherResponse)
    // then receive the next chunk
    //

    responseBuffer = buffer;
    bytesReceived = bufferLength;

    //
    // receive the data. N.B. Don't change this loop without first examining
    // the checks below
    //

    int n;

    for (n = 0; bufferLength > 0; ) {

        //
        // if there is still data to copy in ResponseInfo then copy that
        //

        if (bufferInfo->BytesRemaining) {
            n = min(bufferInfo->BytesRemaining, bufferLength);
            memcpy(buffer, bufferInfo->DataBytes, n);
            bufferInfo->BytesRemaining -= n;
            bufferInfo->DataBytes += n;
        } else {

            //
            // if there is data left to copy in the look-ahead buffer that we
            // allocated in DetermineGopherResponse() then copy that data to
            // the response buffer
            //

            psrBuffer = (LPVOID)buffer;
            srLength = bufferLength;
            srLeft = bufferLength;
            srReceived = 0;

            error = bufferInfo->Socket->Receive(&psrBuffer,
                                                &srLength,
                                                &srLeft,
                                                &srReceived,
                                                0,    // dwExtraSpace
                                                SF_INDICATE,
                                                &eof
                                                );
            if (error != ERROR_SUCCESS) {
                discardBuffer = TRUE;
                terminateConnection = TRUE;
                goto cleanup;
            }
            n = srReceived;
            if (n == 0) {
                break;
            }
        }
        bufferLength -= n;
        buffer += n;
    }

    //
    // at this point we have one of the following:
    //
    //  * we reached the end of the response (n == 0)
    //  * we reached the end of the buffer (n != 0 && bufferLength == 0)
    //

    //
    // get the actual number of bytes received for this iteration
    //

    bytesReceived -= bufferLength;

    //
    // if we are receiving a gopher0 directory response then we need to check
    // whether we actually received an error
    //

    if (checkResponse) {

        //
        // allow for long locators (!)
        //

        char locator[2 * MAX_GOPHER_LOCATOR_LENGTH + 1];
        LPSTR destination;
        LPSTR source;
        DWORD destinationLength;
        DWORD sourceLength;

        //
        // we have a gopher0 error if the response starts with a '3' but there
        // is only one locator, or the response data is unformatted
        //

        //
        // N.B. We are making an assumption here that the locator(s) in the
        // response is(are) not larger than our buffer above. This should be a
        // safe assumption, but this test could fail if we get a large locator
        // but then a large locator will probably break all other gopher
        // clients? The reason we copy the locator is so that we get a zero-
        // terminated string for IsValidLocator(), and CopyToEol() compresses
        // multiple carriage-returns which some servers are uninteligent to
        // return
        //

        source = (LPSTR)responseBuffer;
        sourceLength = bytesReceived;
        destination = locator;
        destinationLength = sizeof(locator);
        if (CopyToEol(&destination,
                      &destinationLength,
                      &source,
                      &sourceLength)) {

            if (IsValidLocator(locator, sizeof(locator))) {

                //
                // response contains at least one valid locator. If it starts
                // with the gopher0 error indicator ('3') and its the only one
                // then this is an error response (although it *could* be the
                // one and only locator describing the directory, and the admin
                // decided to make it an error for some reason. We can't
                // differentiate in this case)
                //

                if (locator[0] == GOPHER_CHAR_ERROR) {
                    destination = locator;
                    destinationLength = sizeof(locator);
                    if (!CopyToEol(&destination,
                                   &destinationLength,
                                   &source,
                                   &sourceLength)) {
                        bufferInfo->Flags |= BI_ERROR_RESPONSE;
                    } else if (!IsValidLocator(locator, sizeof(locator))) {
                        bufferInfo->Flags |= BI_ERROR_RESPONSE;
                    }
                }
            } else {

                //
                // response doesn't contain a valid locator: must be an error
                //

                bufferInfo->Flags |= BI_ERROR_RESPONSE;
            }
        } else {

            //
            // we are receiving 4K but couldn't find an end-of-line? Must be an
            // error
            //

            bufferInfo->Flags |= BI_ERROR_RESPONSE;
        }
    }

    //
    // if we finished receivig the response then we can set the error code or
    // shrink the buffer
    //

    if ((n == 0)
    || (bytesReceived == bufferInfo->ResponseLength)
    || (bufferInfo->Flags & BI_ERROR_RESPONSE)) {

        //
        // no more data in the response. We have completed the transfer
        //

        bufferInfo->Flags |= BI_RECEIVE_COMPLETE;

        //
        // if this response type is terminated with a line containing only a dot
        // then remove the dot
        //

        if (bufferInfo->Flags & BI_DOT_AT_END) {

            //
            // BUGBUG - this is insufficient - need to check for different line
            //          termination schemes ('\n', '\r\r\n', '\r\n', etc.)
            //

            if ((bytesReceived >= 3) && (memcmp(buffer - 3, ".\r\n", 3) == 0)) {
                bytesReceived -= 3;
            }
            bufferInfo->Flags &= ~BI_DOT_AT_END;
        }

        //
        // if we received an error response then we must set the last error
        // response data
        //

        if (bufferInfo->Flags & BI_ERROR_RESPONSE) {
            if (bytesReceived > 0) {
                InternetSetLastError(0,
                                     (LPSTR)responseBuffer,
                                     bytesReceived,
                                     SLE_ZERO_TERMINATE
                                     );

                //
                // let the app know that it needs to call InternetGetLastResponseInfo()
                // to retrieve the error text
                //

                error = ERROR_INTERNET_EXTENDED_ERROR;
            } else {
                error = ERROR_SUCCESS;
            }

            //
            // we have copied the data in the error response, no more need for
            // the buffer
            //

            discardBuffer = TRUE;

            //
            // need to indicate to the caller that they need to get the last
            // error response
            //

        } else {
            error = ERROR_SUCCESS;
        }
    } else {

        //
        // this chunk received OK, more to go
        //

        error = ERROR_SUCCESS;
    }

cleanup:

    //
    // if we no longer need the buffer then discard it, else if we have completed
    // receiving the response, shrink the buffer to free up any unused space
    //

    if (bufferInfo->Flags & BI_OWN_BUFFER) {

        DWORD newBufferLength;
        BOOL resize;

        if (discardBuffer) {
            newBufferLength = 0;
            resize = TRUE;
        } else {

            //
            // update the amount of data received - i.e. the number of bytes in
            // the buffer (excluding header info)
            //

            bufferInfo->BufferLength += bytesReceived;
            if (bufferInfo->Flags & BI_RECEIVE_COMPLETE) {
                newBufferLength = bufferInfo->BufferLength;
                resize = TRUE;

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("received 0 bytes in response\n"
                            ));

            } else {
                resize = FALSE;
            }
        }

        //
        // if resize is TRUE then we are either shrinking the data buffer to
        // exclude any unused space, or we are shrinking it to nothing because
        // we have no data or it is being discarded
        //

        if (resize) {
            bufferInfo->Buffer = (LPBYTE)ResizeBuffer(bufferInfo->Buffer,
                                                      newBufferLength,
                                                      FALSE
                                                      );

            if (newBufferLength == 0) {

                //
                // we no longer own the buffer
                //

                bufferInfo->Flags &= ~BI_OWN_BUFFER;

                //
                // DEBUG version: ensure that the buffer has really been freed
                //

                INET_ASSERT(bufferInfo->Buffer == NULL);

            }
        }
    }

    //
    // if this is a gopher+ response and we know the length of the response then
    // reduce the outstanding size of the response by the amount we received
    //

    if (bufferInfo->ResponseLength > 0) {
        bufferInfo->ResponseLength -= bytesReceived;
    }

    //
    // if we completed the response and the connection is not persistent, or an
    // error occurred, close the connection
    //

    if ((bufferInfo->Flags & BI_RECEIVE_COMPLETE) || (error != ERROR_SUCCESS)) {

        //
        // let the app know we have finished receiving data
        //

        InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
                               &bytesReceived,
                               sizeof(bytesReceived)
                               );

        GopherDisconnect(ViewInfo, terminateConnection);
    }

    //
    // if we didn't receive error text from the server then we return the amount
    // of data received. This is only interesting to ReadData()
    //

    if (!(bufferInfo->Flags & BI_ERROR_RESPONSE)) {
        *BytesReceived = bytesReceived;
    }

quit:

    DEBUG_LEAVE(error);

    return error;

last_error_exit:

    error = GetLastError();

    INET_ASSERT(error != ERROR_SUCCESS);

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\sockets.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    sockets.h

Abstract:

    Contains manifests, macros, types and prototypes for sockets.c

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

DWORD
GopherConnect(
    IN LPVIEW_INFO ViewInfo
    );

DWORD
GopherDisconnect(
    IN LPVIEW_INFO ViewInfo,
    IN BOOL AbortConnection
    );

DWORD
GopherSendRequest(
    IN LPVIEW_INFO ViewInfo
    );

DWORD
GopherReceiveResponse(
    IN LPVIEW_INFO ViewInfo,
    OUT LPDWORD BytesReceived
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\inet.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inet.h

Abstract:

    Contains types, prototypes, manifests, macros, etc., for internet support
    functions

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Revision History:

    20-Mar-1995
        Created

--*/

//
// types
//

typedef struct {
    LPSTR HostName;
    INTERNET_PORT Port;
    LPSTR UserName;
    LPSTR Password;
} GOPHER_DEFAULT_CONNECT_INFO, *LPGOPHER_DEFAULT_CONNECT_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\session.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    Contains functions for maintaining the global session list and SESSION_INFO
    specific functions

    Contents:
        AcquireSessionLock
        ReleaseSessionLock
        CleanupSessions
        (CleanupViewList)
        FindOrCreateSession
        (CreateSession)
        (DestroySession)
        ReferenceSession
        DereferenceSession
        AcquireViewLock
        ReleaseViewLock
        GopherTransaction
        IsServerGopherPlus
        IsGopherPlusSession
        SearchSessionsForAttribute

Author:

    Richard L Firth (rfirth) 19-Oct-1994

Environment:

    Win32 DLL

Revision History:

    19-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// manifests
//

#define NULL_HANDLE ((HANDLE)0)

//
// private prototypes
//

PRIVATE
VOID
CleanupViewList(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    );

PRIVATE
LPSESSION_INFO
CreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    );

PRIVATE
VOID
DestroySession(
    IN LPSESSION_INFO SessionInfo
    );

//
// data
//

PUBLIC SERIALIZED_LIST SessionList;

DEBUG_DATA(LONG, NumberOfSessions, 0);

//
// functions
//


VOID
AcquireSessionLock(
    VOID
    )

/*++

Routine Description:

    Acquires the SESSION_INFO list lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    LockSerializedList(&SessionList);
}


VOID
ReleaseSessionLock(
    VOID
    )

/*++

Routine Description:

    Releases the SESSION_INFO list lock

Arguments:

    None.

Return Value:

    None.

--*/

{
    UnlockSerializedList(&SessionList);
}


VOID
CleanupSessions(
    VOID
    )

/*++

Routine Description:

    Tries to Remove all SESSION_INFOs from the session list, and terminate all
    active operations

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "CleanupSessions",
                NULL
                ));

    while (1) {

        LPSESSION_INFO sessionInfo;

        //
        // find the next SESSION_INFO to delete. Because we may cause the entry
        // currently at the head of the list to be deleted during this loop, we
        // must walk the list each time. We may also end up with a list of items
        // that are marked for delete, but cannot be deleted until the threads
        // that own them complete their current operations
        //

        AcquireSessionLock();

        for (sessionInfo = (LPSESSION_INFO)HeadOfSerializedList(&SessionList);
            (sessionInfo != (LPSESSION_INFO)&SessionList.List.Flink)
            && !(sessionInfo->Flags & SI_CLEANUP);
            sessionInfo = (LPSESSION_INFO)sessionInfo->List.Flink) {

            //
            // empty loop
            //

        }
        if (sessionInfo == (LPSESSION_INFO)&SessionList.List.Flink) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("end of list\n"
                        ));

            ReleaseSessionLock();
            break;
        }

        //
        // mark this SESSION_INFO as being cleaned up, in case it does not get
        // removed from the list (some other thread is accessing it)
        //

        sessionInfo->Flags |= SI_CLEANUP;

        //
        // increment the reference count so that we can release the list lock
        //

        ReferenceSession(sessionInfo);
        ReleaseSessionLock();

        //
        // now we have a pointer to a SESSION_INFO that cannot be deleted until
        // after we have dereferenced it. Dereference any items in the Find and
        // File lists. Note that had we not referenced the SESSION_INFO above,
        // it might have gotten deleted after cleaning up the Find list, and we
        // would be in danger of passing a bogus pointer to the second cleanup
        // view list call below
        //

        CleanupViewList(sessionInfo, ViewTypeFind);
        CleanupViewList(sessionInfo, ViewTypeFile);

        //
        // finally, dereference the session. This may cause it to be deleted,
        // and for the list to be changed
        //

        DereferenceSession(sessionInfo);
    }

    DEBUG_LEAVE(0);
}


PRIVATE
VOID
CleanupViewList(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Cleans up a VIEW_INFO list on a SESSION_INFO

Arguments:

    SessionInfo - pointer to SESSION_INFO we are cleaning up

    ViewType    - identifies which VIEW_INFO list to clean up

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "CleanupViewList",
                "%x, %x",
                SessionInfo,
                ViewType
                ));

    //
    // walk this VIEW_INFO list trying to delete everything by dereferencing
    //

    while (1) {

        LPSERIALIZED_LIST viewList;
        LPVIEW_INFO viewInfo;
        HINTERNET handle;

        AcquireViewLock(SessionInfo, ViewType);

        viewList = &SessionInfo->FindList;
        for (viewInfo = (LPVIEW_INFO)HeadOfSerializedList(viewList);
            (viewInfo != (LPVIEW_INFO)&viewList->List.Flink)
            && !(viewInfo->Flags & VI_CLEANUP);
            viewInfo = (LPVIEW_INFO)viewInfo->List.Flink) {

            //
            // empty loop
            //

        }

        if (viewInfo == (LPVIEW_INFO)&viewList->List.Flink) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("end of list\n"
                        ));

            ReleaseViewLock(SessionInfo, ViewType);
            break;
        }

        //
        // mark this VIEW_INFO as being cleaned-up, so we don't hit it again if
        // we don't delete it from the list this time
        //

        viewInfo->Flags |= VI_CLEANUP;

        //
        // safe to release the view lock
        //

        ReleaseViewLock(SessionInfo, ViewType);

        //
        // now dereference the VIEW_INFO. This may destroy it, but cannot
        // destroy the SESSION_INFO, since we added an extra reference in
        // CleanupSessions()
        //

        DereferenceView(viewInfo);
    }

    DEBUG_LEAVE(0);
}


LPSESSION_INFO
FindOrCreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    )

/*++

Routine Description:

    Locates a SESSION_INFO that contains (Host, Port), or creates a new
    SESSION_INFO

    BUGBUG - need to do the following:

        resolve the host name
        find host by name/port or address/port

Arguments:

    Host    - pointer to host name where gopher server lives

    Port    - port at which gopher server listens

    Error   - place to return error

Return Value:

    LPSESSION_INFO
        Success - pointer to session info. Created contains TRUE if we created
                  the SESSION_INFO, else FALSE

        Failure - NULL
                    Error contains reason for failure

--*/

{
    LPSESSION_INFO sessionInfo;
    BOOL found;

    AcquireSessionLock();

    found = FALSE;
    for (sessionInfo = (LPSESSION_INFO)SessionList.List.Flink;
        sessionInfo != (LPSESSION_INFO)&SessionList.List;
        sessionInfo = (LPSESSION_INFO)(sessionInfo->List.Flink)) {

        if (!stricmp(sessionInfo->Host, Host) && (sessionInfo->Port == Port)) {
            found = TRUE;
            break;
        }
    }
    if (!found) {
        sessionInfo = CreateSession(Host, Port, Error);
        if (sessionInfo != NULL) {
            InsertAtHeadOfSerializedList(&SessionList, &sessionInfo->List);
        }
    }
    if (sessionInfo != NULL) {

        //
        // the reference count will be at least 2
        //

        ReferenceSession(sessionInfo);
    }

    ReleaseSessionLock();

    return sessionInfo;
}


PRIVATE
LPSESSION_INFO
CreateSession(
    IN LPSTR Host,
    IN DWORD Port,
    OUT LPDWORD Error
    )

/*++

Routine Description:

    Creates and initializes a SESSION_INFO 'object'

Arguments:

    Host    - pointer to host name/ip address

    Port    - host port

    Error   - place to return reason for failure

Return Value:

    LPSESSION_INFO
        Success - pointer to initialized session info

        Failure - NULL
                    Error contains reason for failure

--*/

{
    LPSESSION_INFO sessionInfo;
    LPSTR hostName = NULL;
    DWORD error;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "CreateSession",
                "%q, %d, %x",
                Host,
                Port,
                Error
                ));

    sessionInfo = NEW(SESSION_INFO);
    if (sessionInfo != NULL) {
        hostName = NEW_STRING(Host);
        if (hostName != NULL) {
            error = AllocateHandle((LPVOID)sessionInfo, &sessionInfo->Handle);
            if (error == ERROR_SUCCESS) {

                InitializeListHead(&sessionInfo->List);
                sessionInfo->Host = hostName;
                sessionInfo->Port = Port;
                InitializeSerializedList(&sessionInfo->FindList);
                InitializeSerializedList(&sessionInfo->FileList);

                SESSION_CREATED();

            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error != ERROR_SUCCESS) {
        if (hostName != NULL) {
            DEL_STRING(hostName);
        }
        if (sessionInfo != NULL) {
            DEL(sessionInfo);
        }
        sessionInfo = NULL;
    }

    DEBUG_ERROR(SESSION, error);

    *Error = error;

    DEBUG_LEAVE(sessionInfo);

    return sessionInfo;
}


PRIVATE
VOID
DestroySession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Opposite of CreateSession - removes a SESSION_INFO from SessionList and
    frees all resources owned by the SESSION_INFO and finally frees the memory

    Assumes:    1. SessionListLock is held
                2. SessionInfo is not on any lists
                3. The SERIALIZED_LISTs have already been created

Arguments:

    SessionInfo - pointer to SESSION_INFO to delete

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "DestroySession",
                "%x",
                SessionInfo
                ));

    INET_DEBUG_ASSERT(SessionInfo->List.Flink == NULL);
    INET_DEBUG_ASSERT(SessionInfo->List.Blink == NULL);
    INET_ASSERT(SessionInfo->ReferenceCount == 0);
    INET_ASSERT(IsSerializedListEmpty(&SessionInfo->FindList));
    INET_DEBUG_ASSERT(!IsLockHeld(&SessionInfo->FindList));
    INET_ASSERT(IsSerializedListEmpty(&SessionInfo->FileList));
    INET_DEBUG_ASSERT(!IsLockHeld(&SessionInfo->FileList));

    if (SessionInfo->Handle) {
        FreeHandle(SessionInfo->Handle);
    }

    if (SessionInfo->Host != NULL) {
        DEL(SessionInfo->Host);
    }

    TerminateSerializedList(&SessionInfo->FindList);
    TerminateSerializedList(&SessionInfo->FileList);

    DEL(SessionInfo);

    SESSION_DESTROYED();

    DEBUG_LEAVE(0);
}


VOID
ReferenceSession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Increases the reference count of a SESSION_INFO

Arguments:

    Session - pointer to SESSION_INFO to reference

Return Value:

    None.

--*/

{
    INET_ASSERT(SessionInfo != NULL);

    InterlockedIncrement(&SessionInfo->ReferenceCount);
}


LPSESSION_INFO
DereferenceSession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Reduces the reference count of a SESSION_INFO. If it goes to zero, the
    SESSION_INFO is removed from the SessionList and is deallocated

Arguments:

    SessionInfo - pointer to SESSION_INFO to dereference

Return Value:

    LPSESSION_INFO
        NULL    - SessionInfo was deleted

        !NULL   - Reference count still >0

--*/

{
    INET_ASSERT(SessionInfo);
    INET_ASSERT(SessionInfo->ReferenceCount >= 1);

    //
    // use InterlockedDecrement to dereference the session. If it goes to zero
    // acquire the session lock, check if the reference count is still zero,
    // and if so, remove the session from the session list
    //

    if (InterlockedDecrement(&SessionInfo->ReferenceCount) == 0) {
        AcquireSessionLock();
        if (SessionInfo->ReferenceCount == 0) {
            RemoveFromSerializedList(&SessionList, (PLIST_ENTRY)SessionInfo);
            DestroySession(SessionInfo);
            SessionInfo = NULL;
        }
        ReleaseSessionLock();
    }
    return SessionInfo;
}


VOID
AcquireViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Acquires one of the SessionInfo View locks

Arguments:

    SessionInfo - pointer to SESSION_INFO

    ViewType    - identifies which list to lock

Return Value:

    None.

--*/

{
    LPSERIALIZED_LIST list;

    INET_ASSERT(SessionInfo != NULL);
    INET_ASSERT((ViewType == ViewTypeFile) || (ViewType == ViewTypeFind));

    list = (ViewType == ViewTypeFile)
        ? &SessionInfo->FileList
        : &SessionInfo->FindList
        ;
    LockSerializedList(list);
}


VOID
ReleaseViewLock(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Releases the SessionInfo View lock

Arguments:

    SessionInfo - pointer to SESSION_INFO

    ViewType    - identifies which list to lock

Return Value:

    None.

--*/

{
    LPSERIALIZED_LIST list;

    INET_ASSERT(SessionInfo != NULL);
    INET_ASSERT((ViewType == ViewTypeFile) || (ViewType == ViewTypeFind));

    list = (ViewType == ViewTypeFile)
        ? &SessionInfo->FileList
        : &SessionInfo->FindList
        ;
    UnlockSerializedList(list);
}


DWORD
GopherTransaction(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Performs an 'atomic' gopher operation. Connects to a server (if it isn't
    already connected (in the future?)), sends a request and receives the
    entire response message. The connection is terminated

Arguments:

    ViewInfo    - pointer to VIEW_INFO describing gopher server to talk to,
                  request and buffer for response

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Winsock error

--*/

{
    DWORD error;

    INET_ASSERT(ViewInfo != NULL);

    error = GopherConnect(ViewInfo);
    if (error == ERROR_SUCCESS) {
        error = GopherSendRequest(ViewInfo);
        if (error == ERROR_SUCCESS) {

            DWORD bytesReceived;

            //
            // receive the first part of the response. We don't care about the
            // number of bytes received at this point
            //
            // If the response is completed and the connection is not persistent
            // or an error occurs, the connection will be closed
            //

            ViewInfo->BufferInfo->Flags |= BI_FIRST_RECEIVE;
            error = GopherReceiveResponse(ViewInfo, &bytesReceived);
        }
    }
    return error;
}


DWORD
IsServerGopherPlus(
    IN LPSESSION_INFO SessionInfo,
    OUT LPBOOL Answer
    )

/*++

Routine Description:

    Tries to determine whether a gopher server identified by Session is gopher+.
    The caller should already have determined that we don't know the type of
    gopher server described by Session and should modify the flags based on a
    successful return from this function

Arguments:

    SessionInfo - pointer to SESSION_INFO describing the (unknown) gopher server

    Answer      - pointer to place to put the answer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
/*
    DWORD error;
    BYTE buffer[GOPHER_PLUS_INFO_TOKEN_LENGTH + 2]; // "+INFO"
                                                    // + 1 for possible ':'
                                                    // + 1 for ' '
    BOOL receiveComplete;

    //
    // in order to find out the type of gopher server, we send a request for
    // gopher+ info of the root directory. We will get back either the gopher+
    // information or a gopher0 server will return the directory list (or we
    // will get an error). Therefore, if the transaction doesn't result in an
    // error, we can say that if the buffer starts with "+INFO" then the
    // server is gopher+ else plain gopher
    //

    error = GopherTransaction(SessionInfo,
                              GOPHER_PLUS_INFO_REQUEST,
                              TRUE,
                              sizeof(buffer),
                              buffer,
                              NULL,
                              &receiveComplete
                              );

    //
    // in both gopher+ and gopher server cases, the server should want to
    // return more data than we've supplied buffer for (7 bytes!). In the
    // case of gopher+, it will be trying to return the +INFO block for
    // the directory entry. In the case of gopher, it will be trying to
    // return the entire default directory list. Either way, we don't care
    // to take the data: "+INFO[:] " being present or not at the start of
    // the buffer is good enough for us, so just close the session and
    // examine what we have
    //

    DisconnectFromServer(SessionInfo, );
    if (error == ERROR_SUCCESS) {

        register DWORD matchLength;

        matchLength = IsGopherPlusToken(GOPHER_PLUS_INFO_TOKEN,
                                        GOPHER_PLUS_INFO_TOKEN_LENGTH,
                                        buffer,
                                        sizeof(buffer)
                                        );
        *Answer = (BOOL)(matchLength != 0);

        IF_DEBUG(SESSION) {
            DBGPRINT(DBG_INFO,
                     "IsServerGopherPlus",
                     ("Server \"%s\" %s gopher+\n",
                     SessionInfo->Host,
                     (matchLength == 0) ? "NOT" : "IS"
                     ));
        }
    } else {
        IF_DEBUG(SESSION) {
            DBGPRINT(DBG_ERROR,
                     "IsServerGopherPlus",
                     ("GopherTransaction() returns %d\n",
                     error
                     ));
        }
    }
    return error;
*/
    *Answer = FALSE;
    return ERROR_SUCCESS;
}


BOOL
IsGopherPlusSession(
    IN LPSESSION_INFO SessionInfo
    )

/*++

Routine Description:

    Returns TRUE if Session is a session with a gopher+ server

Arguments:

    SessionInfo - pointer to SESSION_INFO describing gopher[+] server

Return Value:

    BOOL

--*/

{
    return (BOOL)SessionInfo->Flags & SI_GOPHER_PLUS;
}


DWORD
SearchSessionsForAttribute(
    IN LPSTR Locator,
    IN LPSTR Attribute,
    IN LPBYTE Buffer,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Searches all VIEW_INFO buffers for a requested Locator and extracts the
    attributes if found

Arguments:

    Locator         - pointer to locator describing item to get attributes for

    Attribute       - pointer to string describing attribute(s) to get

    Buffer          - pointer to buffer in which to return attribute strings

    BufferLength    - IN: length of Buffer in bytes
                      OUT: length of returned attribute strings in bytes,
                           excluding any terminating NUL

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_GOPHER_ATTRIBUTE_NOT_FOUND
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    LPSESSION_INFO session;
    BOOL found = FALSE;
    DWORD error = ERROR_SUCCESS;

    AcquireSessionLock();
/*
    for (session = (LPSESSION_INFO)SessionList.Flink;
        session != (LPSESSION_INFO)&SessionList.Flink;
        session = (LPSESSION_INFO)session->List.Flink) {

        LPVIEW_INFO viewInfo;

        AcquireFindLock(session);
        for (findInfo = (LPVIEW_INFO)session->FindList.Flink;
            findInfo != (LPVIEW_INFO)&session->FindList;
            findInfo = (LPVIEW_INFO)findInfo->List.Flink) {

            ReferenceFind(findInfo);
            if (findInfo->Handle) {
                found = TRUE;
                break;  // out of for()
            }
        }
        if (found) {
            break;  // out of while()
        }
        ReleaseFindLock(session);
    }
    if (found) {
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;
    }
*/
    ReleaseSessionLock();

    error = ERROR_GOPHER_ATTRIBUTE_NOT_FOUND;

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\view.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    view.h

Abstract:

    Manifests, macros, types prototypes for view.c

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// have to forward-define LPSESSION_INFO
//

typedef struct _SESSION_INFO * LPSESSION_INFO;

//
// VIEW_TYPE - which type of view are we talking about, FIND or FILE?
//

typedef enum {
    ViewTypeFile = 0xff010101,  // arbitrary values always good for a few laughs
    ViewTypeFind
} VIEW_TYPE;

//
// VIEW_INFO - describes a data view, either the results of a FindFirst or a
// GetFile
//

typedef struct {

    //
    // List - the list of VIEW_INFO structures owned by the parent SESSION_INFO
    //

    LIST_ENTRY List;

    //
    // ViewType - lets us know which of the Session view lists this is on
    //

    VIEW_TYPE ViewType;

    //
    // Handle - the handle returned by GopherFindFirst/GopherGetFile
    //

    HINTERNET Handle;

    //
    // Request - the request string which generated Buffer
    //

    LPSTR Request;

    //
    // RequestLength - number of bytes in Request (excluding terminating \0)
    //

    DWORD RequestLength;

    //
    // Set to 1 when this 'object' is created. Any time it is used thereafter
    // this field must be incremented and decremented when no longer being
    // used. Closing the handle that corresponds to this view will dereference
    // it a final time and cause the view to be deleted
    //

    LONG ReferenceCount;

    //
    // Flags - various control flags, see below
    //

    DWORD Flags;

    //
    // ViewOffset - offset in buffer described by BufferInfo->Buffer which will
    // be used to generate the results of the next request on this view
    //

    DWORD ViewOffset;

    //
    // Buffer - pointer to BUFFER_INFO containing data returned from gopher
    // server
    //

    LPBUFFER_INFO BufferInfo;

    //
    // SessionInfo - back-pointer to the owning SESSION_INFO. Used when we
    // create or destroy this view - the owning session must be referenced
    // or dereferenced accordingly
    //

    LPSESSION_INFO SessionInfo;

} VIEW_INFO, *LPVIEW_INFO;

//
// VIEW_INFO flags
//

#define VI_GOPHER_PLUS      0x00000001  // the data buffer contains gopher+ data
#define VI_CLEANUP          0x00000002  // set by CleanupSessions()

//
// external data
//

DEBUG_DATA_EXTERN(LONG, NumberOfViews);

//
// prototypes
//

LPVIEW_INFO
CreateView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    OUT LPDWORD Error,
    OUT LPBOOL Cloned
    );

LPVIEW_INFO
FindViewByHandle(
    IN HINTERNET Handle,
    IN VIEW_TYPE ViewType
    );

VOID
ReferenceView(
    IN LPVIEW_INFO ViewInfo
    );

LPVIEW_INFO
DereferenceView(
    IN LPVIEW_INFO ViewInfo
    );

DWORD
DereferenceViewByHandle(
    IN HINTERNET Handle,
    IN VIEW_TYPE ViewType
    );

//
// macros
//

#if INET_DEBUG

#define VIEW_CREATED()      ++NumberOfViews
#define VIEW_DESTROYED()    --NumberOfViews
#define ASSERT_NO_VIEWS() \
    if (NumberOfViews != 0) { \
        INET_ASSERT(FALSE); \
    }

#else

#define VIEW_CREATED()      /* NOTHING */
#define VIEW_DESTROYED()    /* NOTHING */
#define ASSERT_NO_VIEWS()   /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\view.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    view.cxx

Abstract:

    Functions to manage VIEW 'object's

    Contents:
        CreateView
        (DestroyView)
        FindViewByHandle
        ReferenceView
        DereferenceView
        DereferenceViewByHandle

Author:

    Richard L Firth (rfirth) 17-Oct-1994

Environment:

    Win/32 user-mode DLL

Revision History:

    17-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include "gfrapih.h"

//
// private prototypes
//

PRIVATE
VOID
DestroyView(
    IN LPVIEW_INFO ViewInfo
    );

//
// private data
//

DEBUG_DATA(LONG, NumberOfViews, 0);

//
// functions
//


LPVIEW_INFO
CreateView(
    IN LPSESSION_INFO SessionInfo,
    IN VIEW_TYPE ViewType,
    IN LPSTR Request,
    OUT LPDWORD Error,
    OUT LPBOOL Cloned
    )

/*++

Routine Description:

    Creates or clones a VIEW_INFO. There will only ever be one VIEW_INFO for a
    particular request to the same server. Other requests for the same data
    just reference the first view

Arguments:

    SessionInfo - pointer to SESSION_INFO describing gopher server

    ViewType    - type of view - ViewTypeFile or ViewTypeFind

    Request     - gopher request string

    Error       - returned error

    Cloned      - returned TRUE if we cloned the view

Return Value:

    LPVIEW_INFO
        Success - pointer to created or cloned view; check Cloned

        Failure - NULL

--*/

{
    LPVIEW_INFO viewInfo;
    DWORD error;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "CreateView",
                "%x, %x, %q, %x, %x",
                SessionInfo,
                ViewType,
                Request,
                Error,
                Cloned
                ));

    //
    // in both cases, we need a new VIEW_INFO
    //

    viewInfo = NEW(VIEW_INFO);
    if (viewInfo != NULL) {
        error = AllocateHandle((LPVOID)viewInfo, &viewInfo->Handle);
        if (error == ERROR_SUCCESS) {
            viewInfo->Request = NEW_STRING(Request);
            viewInfo->RequestLength = strlen(Request);
            if (viewInfo->Request != NULL) {
                InitializeListHead(&viewInfo->List);
                viewInfo->ViewType = ViewType;
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // now search for an already existing view
    //

    if (error == ERROR_SUCCESS) {

        PLIST_ENTRY listPtr;
        PLIST_ENTRY list;
        PLIST_ENTRY listAddress;
        BOOL found;
        LPBUFFER_INFO bufferInfo;

        AcquireViewLock(SessionInfo, ViewType);

        //
        // new scheme: we now only buffer Find views: we always create a new
        // file request because file requests go straight to the user buffer
        // (keeping the connection alive until the caller finishes reading)
        //

        found = FALSE;
        if (ViewType == ViewTypeFind) {
//            list = SessionInfo->FindList.List.Flink;
            listAddress = &SessionInfo->FindList.List;
//            for (listPtr = list; listPtr != listAddress; listPtr = listPtr->Flink) {
//                if (!STRICMP(((LPVIEW_INFO)listPtr)->Request, Request)) {
//                    found = TRUE;
//                    break;
//                }
//            }
        } else {
            listAddress = &SessionInfo->FileList.List;
        }

        //
        // create a buffer info, or get a pointer to the current buffer info
        // depending on whether we located a view of the same request at the
        // same server
        //
/* N.B. found is never true because the above code is commented out. */
        if (found) {
//            bufferInfo = ((LPVIEW_INFO)listPtr)->BufferInfo;

            //
            // this is a clone. If there is a thread which is concurrently
            // requesting the data - right now - then we must wait on the
            // RequestEvent until gives us the green light. If there is no
            // RequestEvent then the data has already been received and
            // some kind soul has seen fit to close the request handle. I.e.
            // we don't have to wait
            //

//            if (bufferInfo->RequestEvent != NULL) {
//                ++bufferInfo->RequestWaiters;
//            }

            *Cloned = TRUE;
        } else {
            bufferInfo = CreateBuffer(&error);
            if (bufferInfo != NULL) {
                *Cloned = FALSE;
            }
        }

        if (error == ERROR_SUCCESS) {

            //
            // whilst holding the view lock, we add the view to the list, set
            // the view's reference count to 1, increment the session's
            // reference count, and point the view at the session
            //

            viewInfo->ReferenceCount = 1;
            viewInfo->BufferInfo = bufferInfo;
            viewInfo->SessionInfo = SessionInfo;

            //
            // also whilst holding the view lock, we increment the reference
            // count on the buffer info
            //

            ReferenceBuffer(bufferInfo);
            InsertHeadList(listAddress, &viewInfo->List);

            //
            // N.B. this will acquire the session list lock (then release it)
            //

            ReferenceSession(SessionInfo);

            VIEW_CREATED();

        }

        ReleaseViewLock(SessionInfo, ViewType);
    }

    if (error != ERROR_SUCCESS) {
        if (viewInfo != NULL) {
            viewInfo = DereferenceView(viewInfo);

            INET_ASSERT(viewInfo == NULL);

        }
    }

    DEBUG_PRINT(VIEW,
                INFO,
                ("ViewInfo %x is %scloned\n",
                viewInfo,
                (*Cloned == TRUE) ? "" : "NOT "
                ));

    DEBUG_ERROR(SESSION, error);

    *Error = error;

    DEBUG_LEAVE(viewInfo);

    return viewInfo;
}


PRIVATE
VOID
DestroyView(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Destroys a VIEW_INFO after freeing all resources that it owns. ViewInfo
    must have been removed from the relevant session view list by the time
    this function is called

Arguments:

    ViewInfo    - pointer to VIEW_INFO to destroy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GOPHER,
                None,
                "DestroyView",
                "%x",
                ViewInfo
                ));

    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->ReferenceCount == 0);

    if (ViewInfo->Handle) {

        DWORD error;

        error = FreeHandle(ViewInfo->Handle);

        INET_ASSERT(error == ERROR_SUCCESS);

    }

    if (ViewInfo->Request) {
        DEL_STRING(ViewInfo->Request);
    }

    DEL(ViewInfo);

    VIEW_DESTROYED();

    DEBUG_LEAVE(0);
}


LPVIEW_INFO
FindViewByHandle(
    IN HANDLE Handle,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Finds a VIEW_INFO given a handle. If found, the VIEW_INFO reference count
    is incremented

Arguments:

    Handle      - handle associated with VIEW_INFO

    ViewType    - identifies which list to look on

Return Value:

    LPVIEW_INFO
        Success - pointer to VIEW_INFO; Session points at SESSION_INFO

        Failure - NULL

--*/

{
    LPVIEW_INFO viewInfo;
    LPSESSION_INFO sessionInfo;
    BOOL found = FALSE;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "FindViewByHandle",
                "%x, %x",
                Handle,
                ViewType
                ));

    AcquireSessionLock();

    sessionInfo = (LPSESSION_INFO)SessionList.List.Flink;
    while (sessionInfo != (LPSESSION_INFO)&SessionList.List) {

        PLIST_ENTRY endOfList;
        PLIST_ENTRY list;

        AcquireViewLock(sessionInfo, ViewType);

        INET_ASSERT((ViewType == ViewTypeFile) || (ViewType == ViewTypeFind));

        if (ViewType == ViewTypeFile) {
            list = sessionInfo->FileList.List.Flink;
            endOfList = &sessionInfo->FileList.List;
        } else {
            list = sessionInfo->FindList.List.Flink;
            endOfList = &sessionInfo->FindList.List;
        }

        for (viewInfo = (LPVIEW_INFO)list;
            viewInfo != (LPVIEW_INFO)endOfList;
            viewInfo = (LPVIEW_INFO)(viewInfo->List.Flink)) {

            if (viewInfo->Handle == Handle) {

                //
                // we found the one we were looking for. Make sure that we
                // increase the reference count before we release the lock
                //

                INET_ASSERT(viewInfo->ViewType == ViewType);

                ReferenceView(viewInfo);
                found = TRUE;
                break;  // out of for()
            }
        }

        ReleaseViewLock(sessionInfo, ViewType);

        if (found) {
            break;  // out of while()
        } else {
            sessionInfo = (LPSESSION_INFO)sessionInfo->List.Flink;
        }
    }
    if (!found) {
        viewInfo = NULL;
    }

    ReleaseSessionLock();

    DEBUG_LEAVE(viewInfo);

    return viewInfo;
}


VOID
ReferenceView(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Increments reference count on VIEW_INFO

Arguments:

    ViewInfo    - pointer to VIEW_INFO to reference

Return Value:

    None.

--*/

{
    INET_ASSERT(ViewInfo != NULL);

    InterlockedIncrement(&ViewInfo->ReferenceCount);

    DEBUG_PRINT(REFCOUNT,
                INFO,
                ("ReferenceView(): ViewInfo{%x}->ReferenceCount = %d\n",
                ViewInfo,
                ViewInfo->ReferenceCount
                ));
}


LPVIEW_INFO
DereferenceView(
    IN LPVIEW_INFO ViewInfo
    )

/*++

Routine Description:

    Reduces the reference count of a VIEW_INFO by 1. If it goes to zero, the
    VIEW_INFO is removed from its owner's list and is deallocated

Arguments:

    ViewInfo    - pointer to VIEW_INFO to dereference

Return Value:

    LPVIEW_INFO
        NULL    - ViewInfo was deleted

        !NULL   - Reference count still >0

--*/

{
    BOOL deleteViewInfo;

    DEBUG_ENTER((DBG_GOPHER,
                Pointer,
                "DereferenceView",
                "%x",
                ViewInfo
                ));

    INET_ASSERT(ViewInfo != NULL);
    INET_ASSERT(ViewInfo->ReferenceCount >= 1);

    deleteViewInfo = FALSE;
    if (InterlockedDecrement(&ViewInfo->ReferenceCount) == 0) {

        //
        // perform any reference count manipulation within the view lock
        //

        AcquireViewLock(ViewInfo->SessionInfo, ViewInfo->ViewType);

        //
        // if the reference count is still zero, then it is safe to remove it
        // from the SESSION_INFO, and delete
        //

        if (ViewInfo->ReferenceCount == 0) {

            RemoveEntryList(&ViewInfo->List);

            INET_ASSERT(ViewInfo->BufferInfo != NULL);

            //
            // perform buffer info reference count manipulation within the view
            // lock
            //

            DereferenceBuffer(ViewInfo->BufferInfo);
            deleteViewInfo = TRUE;
        }

        ReleaseViewLock(ViewInfo->SessionInfo, ViewInfo->ViewType);
    } else {

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("DereferenceView(): ViewInfo{%x}->ReferenceCount = %d\n",
                    ViewInfo,
                    ViewInfo->ReferenceCount
                    ));

    }

    //
    // safe to delete this view info outside of the view lock
    //

    if (deleteViewInfo) {

        LPSESSION_INFO sessionInfo;

        sessionInfo = ViewInfo->SessionInfo;

        DestroyView(ViewInfo);
        ViewInfo = NULL;
        DereferenceSession(sessionInfo);
    }

    DEBUG_LEAVE(ViewInfo);

    return ViewInfo;
}


DWORD
DereferenceViewByHandle(
    IN HINTERNET Handle,
    IN VIEW_TYPE ViewType
    )

/*++

Routine Description:

    Atomically searches for the VIEW_INFO identified by Handle and if found
    dereferences it. This may cause the VIEW_INFO to be deleted

Arguments:

    Handle      - identifying VIEW_INFO to dereference

    ViewType    - identifies which list to look on

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Handle was dereferenced, but not necessarily deleted

        Failure - ERROR_INVALID_HANDLE
                    Couldn't find Handle

--*/

{
    LPVIEW_INFO viewInfo;
    DWORD error;

    DEBUG_ENTER((DBG_GOPHER,
                Dword,
                "DereferenceViewByHandle",
                "%x",
                Handle
                ));

    //
    // we have to perform this operation whilst holding the session lock. We
    // find the VIEW_INFO then dereference it twice - once to counteract the
    // reference added by FindViewByHandle(), and once for the reference we
    // were asked to remove by the caller.
    //
    // Since we are holding the Session lock, no other thread can dereference
    // the VIEW_INFO or SESSION_INFO. The second derereference may cause the
    // SESSION_INFO to be destroyed
    //

    AcquireSessionLock();

    viewInfo = FindViewByHandle(Handle, ViewType);
    if (viewInfo != NULL) {
        DereferenceView(viewInfo);
        DereferenceView(viewInfo);
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INVALID_HANDLE;
    }

    ReleaseSessionLock();

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\gopher\test\gc\gc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gc.c

Abstract:

    Gopher client test program

    Basically a real console-mode (win32) gopher client that uses the gopher
    client APIs

    Contents:

Author:

    Richard L Firth (rfirth) 08-Nov-1994

Environment:

    Win32 console mode user executable

Revision History:

    08-Nov-1994 rfirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <wininetd.h>
#include <string.h>
#include <malloc.h>
#include <ctype.h>
#include <fcntl.h>
#include <io.h>
#include <catlib.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

//
// manifests
//

#define HOME    -1

#define GC_CONNECT_CONTEXT  0x47474747
#define GC_FIND_CONTEXT     0x47474644
#define GC_FILE_CONTEXT     0x47474645

//
// prototypes
//

void _CRTAPI1 main(int, char**);
void usage(void);
void _CRTAPI1 my_cleanup(void);
void gopher(LPSTR, WORD, CHAR, LPSTR);
BOOL get_dir(LPSTR, LPSTR);
void get_file(LPSTR);
int get_user_request(LPSTR);
void clear_items(void);
void my_callback(HINTERNET, DWORD, DWORD, LPVOID, DWORD);
void print_error(char*, char*, ...);
char hex_to_char(char);
char* decontrol(char*, char*);
void toodle_pip(void);

//
// global data
//

BOOL Verbose = FALSE;
BOOL MakeRequestGopherPlus = FALSE;
HINTERNET InetHandle = NULL;
HINTERNET hGopherSession = NULL;
BOOL NewHome = FALSE;
INTERNET_STATUS_CALLBACK PreviousCallback;
BOOL AsyncMode = FALSE;
HANDLE AsyncEvent = NULL;
DWORD AsyncResult;
DWORD AsyncError;
DWORD CacheFlags = 0;
BOOL UseQueryData = FALSE;
DWORD UserContext = 0;
BOOL UseUserContext = FALSE;

//
// functions
//

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR server = NULL;
    LPSTR selector = NULL;
    WORD port = 70;
    BOOL fCallback = FALSE;
    char selectorType = '1';
    DWORD accessMethod = PRE_CONFIG_INTERNET_ACCESS;
    BOOL expectingProxy = FALSE;
    LPSTR proxyServer = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case '+':
                MakeRequestGopherPlus = TRUE;
                break;

            case 'a':
                ++*argv;
                if (**argv == 'l') {
                    accessMethod = INTERNET_OPEN_TYPE_DIRECT;
                } else if (**argv == 'p') {
                    accessMethod = INTERNET_OPEN_TYPE_PROXY;
                    if (*++*argv) {
                        proxyServer = *argv;
                    } else {
                        expectingProxy = TRUE;
                    }
                } else {
                    printf("error: unrecognised access type: '%c'\n", **argv);
                    usage();
                }
                break;

            case 'c':
                fCallback = TRUE;
                break;

            case 'n':
                CacheFlags |= INTERNET_FLAG_DONT_CACHE;
                break;

            case 'p':
                port = atoi(++*argv);
                break;

            case 'q':
                UseQueryData = TRUE;
                break;

            case 't':
                selectorType = *++*argv;
                break;

            case 'v':
                Verbose = TRUE;
                break;

            case 'x':
                UseUserContext = TRUE;
                if (*++*argv) {
                    UserContext = (DWORD)strtoul(*argv, NULL, 0);
                }
                break;

            case 'y':
                AsyncMode = TRUE;
                break;

            default:
                printf("unknown command line flag: '%c'\n", **argv);
                usage();
            }
        } else if (expectingProxy) {
            proxyServer = *argv;
            expectingProxy = FALSE;
        } else if (!server) {
            server = *argv;
        } else if (!selector) {
            selector = *argv;
        } else {
            printf("unknown command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (!server) {
        usage();
    }

    //
    // exit function
    //

    atexit(my_cleanup);

    if (AsyncMode) {

        //
        // create an auto-reset, initially unsignalled event
        //

        AsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!AsyncEvent) {
            print_error("gc", "CreateEvent()");
            exit(1);
        }
    }

    //
    // open gateway
    //

    InetHandle = InternetOpen("gc",
                              accessMethod,
                              proxyServer,
                              NULL,
                              AsyncMode ? INTERNET_FLAG_ASYNC : 0
                              );

    if (InetHandle == NULL) {
        print_error("gc", "InternetOpen()");
        exit(1);
    }

    if (fCallback) {

        //
        // let's have a status callback
        //

        PreviousCallback = InternetSetStatusCallback(InetHandle, my_callback);
        if (Verbose) {
            printf("previous Internet callback = %x\n", PreviousCallback);
        }
    }

    hGopherSession = InternetConnect(InetHandle,
                                     server,
                                     0,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_GOPHER,
                                     0,
                                     UseUserContext ? UserContext : GC_CONNECT_CONTEXT
                                     );
    if (AsyncMode && (hGopherSession == NULL)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            print_error("gc", "InternetConnect()");
            exit(1);
        } else {
            if (Verbose) {
                printf("Waiting for async InternetConnect()\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            hGopherSession = (HINTERNET)AsyncResult;
            SetLastError(AsyncError);
        }
    }

    if (hGopherSession == NULL) {
        print_error("gc", "InternetConnect()");
        exit(1);
    }

    gopher(server, port, selectorType, selector);

    if (Verbose) {
        printf("closing InternetConnect handle %x\n", hGopherSession);
    }
    if (!InternetCloseHandle(hGopherSession)) {
        print_error("gc", "InternetCloseHandle(%#x)", hGopherSession);
    } else {
        hGopherSession = NULL;
    }

    if (Verbose) {
        printf("closing InternetOpen handle %x\n", InetHandle);
    }
    if (!InternetCloseHandle(InetHandle)) {
        print_error("gc", "InternetCloseHandle(%#x)", InetHandle);
    } else {
        InetHandle = NULL;
    }

    toodle_pip();
    exit(0);
}

void toodle_pip() {

    static LPSTR intl[] = {
        "Goodbye",
        "Au revoir",
        "Auf wiederzehen",
        "Cheers",
        "Ciao"
    };

    srand(GetTickCount());
    printf("%s.\n", intl[rand() % (sizeof(intl) / sizeof(intl[0]))]);
}

void usage() {
    printf("\n"
           "usage: gc [-+] [-a{l|p[ ]proxy}] [-c] [-p#] [-n] [-v] [-y] [-q] [-t<char>]\n"
           "          [-x#] [selector] <server>\n"
           "\n"
           "where: -+ = First request is gopher+\n"
           "       -a = Access type. Default is pre-configured:\n"
           "        l = direct internet access\n"
           "        p = proxy access\n"
           "       -c = Enable status callbacks\n"
           "       -n = Don't cache\n"
           "       -p = Port number to connect to at <server>. Default is 70\n"
           "       -q = use InternetQueryDataAvailable\n"
           "       -t = Selector type character, e.g. -t9 for binary file. Default is dir\n"
           "       -v = Verbose mode\n"
           "       -x = Context value. # is number to use as context\n"
           "       -y = Asynchronous APIs\n"
          );
    exit(1);
}

void _CRTAPI1 my_cleanup() {
    if (hGopherSession != NULL) {
        printf("closing InternetConnect handle %x\n", hGopherSession);
        if (!InternetCloseHandle(hGopherSession)) {
            print_error("my_cleanup", "InternetCloseHandle(%#x)", hGopherSession);
        }
    }
    if (InetHandle != NULL) {
        printf("closing InternetOpen handle %x\n", InetHandle);
        if (!InternetCloseHandle(InetHandle)) {
            print_error("my_cleanup", "InternetCloseHandle(%#x)", InetHandle);
        }
    }
}

char HomeLocator[MAX_GOPHER_SELECTOR_TEXT];

typedef struct {
    LPSTR display_string;
    LPSTR locator;
} GINFO;

GINFO items[4096];
int nitems = 0;

void gopher(LPSTR server, WORD port, CHAR selectorType, LPSTR selector) {

    LPSTR request = "";
    char locator[MAX_GOPHER_SELECTOR_TEXT];
    DWORD len;
    BOOL done = FALSE;
    HINTERNET h;
    BOOL unknownType;
    DWORD gopherType;

    //
    // if the user supplied a gopher type character then create a default
    // text locator, then change the type (evil!). Otherwise, the default
    // is directory
    //

    gopherType = selector ? GOPHER_TYPE_TEXT_FILE : GOPHER_TYPE_DIRECTORY;
    if (MakeRequestGopherPlus) {
        gopherType |= GOPHER_TYPE_GOPHER_PLUS;
    }

    len = sizeof(HomeLocator);
    if (!GopherCreateLocator(server,
                             port,
                             NULL,
                             selector,
                             gopherType,
                             locator,
                             &len
                             )) {
        print_error("gopher", "GopherCreateLocator()");
        return;
    }

    if (selector) {
        *locator = selectorType;
    }

    NewHome = TRUE;

    while (!done) {

        DWORD gopherType;

        unknownType = FALSE;
        if (!GopherGetLocatorType(locator, &gopherType)) {
            print_error("gopher", "GopherGetLocatorType()");
            exit(1);
        }
        if (gopherType & GOPHER_TYPE_DIRECTORY) {
            if (get_dir(locator, NULL)) {
                if (NewHome) {
                    strcpy(HomeLocator, locator);
                    NewHome = FALSE;
                }
            }
        } else if (gopherType & GOPHER_TYPE_FILE_MASK) {
            get_file(locator);
        } else {
            if (gopherType & GOPHER_TYPE_INDEX_SERVER) {

                char searchBuf[256];

                printf("\nEnter Text To Search For: ");
                gets(searchBuf);
                get_dir(locator, searchBuf);
            } else {
                unknownType = TRUE;
            }
        }
        if (unknownType) {

            char dcbuf[1024];

            printf("error: gopher: locator %s is unknown type\n",
                    decontrol(locator, dcbuf)
                    );
            return;
        }
        done = get_user_request(locator) == 0;
    }
}

char CurrentDirLocator[256];

BOOL get_dir(LPSTR locator, LPSTR search) {

    HINTERNET h;
    GOPHER_FIND_DATA data;
    DWORD error;

    h = GopherFindFirstFile(hGopherSession,
                            locator,
                            search,
                            &data,
                            CacheFlags, // dwFlags
                            UseUserContext ? UserContext : GC_FIND_CONTEXT
                            );

    if (AsyncMode && (h == NULL)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            if (Verbose) {
                printf("waiting for async GopherFindFirstFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            h = (HINTERNET)AsyncResult;
            error = AsyncError;
        }
        if (h == NULL) {
            SetLastError(error);
        }
    }

    if (h != NULL) {

        LPGOPHER_FIND_DATA p = (LPGOPHER_FIND_DATA)&data;
        SYSTEMTIME systemTime;
        int i = 0;
        char timeBuf[9];
        char sizeBuf[32];
        BOOL ok;

        clear_items();
        strcpy(CurrentDirLocator, locator);
        do {
            items[i].display_string = _strdup(p->DisplayString);
            items[i].locator = _strdup(p->Locator);
            ++i;
            if ((p->LastModificationTime.dwLowDateTime != 0)
            && (p->LastModificationTime.dwHighDateTime != 0)) {
                FileTimeToSystemTime(&p->LastModificationTime, &systemTime);
                sprintf(timeBuf,
                        "%02d-%02d-%02d",
                        systemTime.wMonth,
                        systemTime.wDay,
                        systemTime.wYear % 100
                        );
                sprintf(sizeBuf, "%d", p->SizeLow);
            } else {
                timeBuf[0] = '\0';
                sizeBuf[0] = '\0';
            }
            printf("%5d %c %7s %10s %8s %s\n",
                    i,
                    (p->GopherType & GOPHER_TYPE_GOPHER_PLUS) ? '+' : ' ',
                    (p->GopherType & GOPHER_TYPE_TEXT_FILE)         ? "Text"
                    : (p->GopherType & GOPHER_TYPE_DIRECTORY)       ? "Dir"
                    : (p->GopherType & GOPHER_TYPE_CSO)             ? "Phone"
                    : (p->GopherType & GOPHER_TYPE_ERROR)           ? "Error"
                    : (p->GopherType & GOPHER_TYPE_MAC_BINHEX)      ? "MAC"
                    : (p->GopherType & GOPHER_TYPE_DOS_ARCHIVE)     ? "Archive"
                    : (p->GopherType & GOPHER_TYPE_UNIX_UUENCODED)  ? "UNIX"
                    : (p->GopherType & GOPHER_TYPE_INDEX_SERVER)    ? "Index"
                    : (p->GopherType & GOPHER_TYPE_TELNET)          ? "Telnet"
                    : (p->GopherType & GOPHER_TYPE_BINARY)          ? "Binary"
                    : (p->GopherType & GOPHER_TYPE_REDUNDANT)       ? "Backup"
                    : (p->GopherType & GOPHER_TYPE_TN3270)          ? "TN3270"
                    : (p->GopherType & GOPHER_TYPE_GIF)             ? "GIF"
                    : (p->GopherType & GOPHER_TYPE_IMAGE)           ? "Image"
                    : (p->GopherType & GOPHER_TYPE_BITMAP)          ? "Bitmap"
                    : (p->GopherType & GOPHER_TYPE_MOVIE)           ? "Movie"
                    : (p->GopherType & GOPHER_TYPE_SOUND)           ? "Sound"
                    : (p->GopherType & GOPHER_TYPE_HTML)            ? "HTML"
                    : (p->GopherType & GOPHER_TYPE_PDF)             ? "PDF"
                    : (p->GopherType & GOPHER_TYPE_CALENDAR)        ? "Cal"
                    : (p->GopherType & GOPHER_TYPE_INLINE)          ? "Inline"
                    : (p->GopherType & GOPHER_TYPE_UNKNOWN)         ? "Unknown"
                    : "\a????",
                    sizeBuf,
                    timeBuf,
                    p->DisplayString
                    );

            if (UseQueryData) {

                DWORD avail;

                ok = InternetQueryDataAvailable(h, &avail, 0, 0);
                if (!ok) {
                    error = GetLastError();
                    if (error == ERROR_IO_PENDING) {
                        if (Verbose) {
                            printf("waiting for async InternetQueryDataAvailable()...\n");
                        }
                        WaitForSingleObject(AsyncEvent, INFINITE);
                        ok = (BOOL)AsyncResult;
                        SetLastError(AsyncError);
                    }
                }
                if (ok) {
                    if (Verbose) {
                        printf("%sSYNC IQDA(): %d available\n", AsyncMode ? "A" : "", avail);
                    }
                } else {
                    print_error("get_dir()", "InternetQueryDataAvailable()");
                    break;
                }
            }

            ok = InternetFindNextFile(h, (LPGOPHER_FIND_DATA)&data);

            if (AsyncMode && !ok) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetFindNextFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    error = AsyncError;
                }
                SetLastError(error);
            }
        } while (ok);

        if (GetLastError() != ERROR_NO_MORE_FILES) {
            print_error("get_dir", "InternetFindNextFile()");
        }

        nitems = i;

        if (Verbose) {
            printf("closing Find handle %x\n", h);
        }
        if (!InternetCloseHandle(h)) {
            print_error("get_dir", "InternetCloseHandle(%#x)", h);
        }

        return TRUE;
    } else {
        print_error("get_dir", "GopherFindFirstFile()");
        return FALSE;
    }
}

void get_file(LPSTR locator) {

    HINTERNET h;
    char buf[4096];
    DWORD error;

    h = GopherOpenFile(hGopherSession,
                       locator,
                       NULL,
                       CacheFlags,
                       UseUserContext ? UserContext : GC_FILE_CONTEXT
                       );

    if (AsyncMode && (h == NULL)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            if (Verbose) {
                printf("waiting for async GopherOpenFile()...\n");
            }
            WaitForSingleObject(AsyncEvent, INFINITE);
            h = (HINTERNET)AsyncResult;
            error = AsyncError;
        }
        SetLastError(error);
    }

    if (h == NULL) {
        print_error("get_file", "GopherOpenFile()");
    } else {

        DWORD nread;
        BOOL ok;
        DWORD avail;

        do {
            if (UseQueryData) {
                ok = InternetQueryDataAvailable(h, &avail, 0, 0);
                if (!ok) {
                    error = GetLastError();
                    if (error == ERROR_IO_PENDING) {
                        if (Verbose) {
                            printf("waiting for async InternetQueryDataAvailable()...\n");
                        }
                        WaitForSingleObject(AsyncEvent, INFINITE);
                        ok = (BOOL)AsyncResult;
                        SetLastError(AsyncError);
                    }
                }
                if (ok) {
                    if (Verbose) {
                        printf("%sSYNC IQDA(): %d available\n", AsyncMode ? "A" : "", avail);
                    }
                } else {
                    print_error("get_dir()", "InternetQueryDataAvailable()");
                    break;
                }
            } else {
                avail = sizeof(buf);
            }

            avail = min(avail, sizeof(buf));
            if (avail == 0) {
                break;
            }

            ok = InternetReadFile(h, buf, avail, &nread);

            if (!ok && AsyncMode) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    if (Verbose) {
                        printf("waiting for async InternetReadFile()...\n");
                    }
                    WaitForSingleObject(AsyncEvent, INFINITE);
                    ok = (BOOL)AsyncResult;
                    error = AsyncError;
                }
                SetLastError(error);
            }

            if (ok) {
                if (!nread) {
                    printf("=== end of file ===\n");
                    break;
                } else {
                    _setmode(1, _O_BINARY);
                    _write(1, buf, nread);
                }
            }
        } while (ok);

        if (!ok) {
            error = GetLastError();
            if (error != ERROR_SUCCESS) {
                print_error("get_file", "InternetReadFile()");
            }
        }
        if (Verbose) {
            printf("closing File handle %x\n", h);
        }
        if (!InternetCloseHandle(h)) {
            print_error("get_file", "InternetCloseHandle(%#x)", h);
        }
    }
}

int get_user_request(LPSTR locator) {

    int n;
    char buf[80];
    BOOL got = FALSE;
    char newLocator[256];
    char serverBuf[80];
    char portBuf[32];
    DWORD len = sizeof(newLocator);
    int i;
    BOOL ok;
    DWORD handles;
    DWORD size_handles;

    while (!got) {
        printf("\nEnter selection: ");
        gets(buf);
        if (isdigit(buf[0])) {
            n = atoi(buf);
            if (n >= 1 && n <= nitems) {
                strcpy(locator, items[n - 1].locator);
                got = TRUE;
            } else {
                printf("\n"
                       "error: must enter number in the range 1 to %d\n", nitems);
            }
        } else {
            switch (buf[0]) {
            case '+':
                printf("NYI\n");
                break;

            case '.':
                strcpy(locator, CurrentDirLocator);
                got = TRUE;
                break;

            case 'g':
                for (i = 1; buf[i] && isspace(buf[i]); ) {
                    ++i;
                }
                if (buf[i]) {

                    int j = 0;

                    while (buf[i] && !isspace(buf[i])) {
                        serverBuf[j++] = buf[i++];
                    }
                    serverBuf[j] = 0;
                    while (buf[i] && isspace(buf[i])) {
                        ++i;
                    }
                } else {
                    printf("server: ");
                    gets(serverBuf);
                }
                if (buf[i]) {

                    int j = 0;

                    while (buf[i] && !isspace(buf[i])) {
                        portBuf[j++] = buf[i++];
                    }
                    portBuf[j] = 0;
                } else {
                    printf("port:   ");
                    gets(portBuf);
                }
                if (!GopherCreateLocator(serverBuf,
                                         (WORD)atoi(portBuf),
                                         NULL,
                                         NULL,
                                         GOPHER_TYPE_DIRECTORY,
                                         newLocator,
                                         &len
                                         )) {
                    print_error("get_user_request", "GopherCreateLocator()");
                } else {
                    strcpy(locator, newLocator);
                    got = TRUE;
                }
                NewHome = TRUE;
                break;

            case 'h':
                n = HOME;
                strcpy(locator, HomeLocator);
                got = TRUE;
                break;

            case 'l':
                size_handles = sizeof(handles);
                ok = InternetQueryOption(NULL,
                                         INTERNET_OPTION_GET_HANDLE_COUNT,
                                         (LPVOID)&handles,
                                         &size_handles
                                         );
                if (!ok) {
                    print_error("get_user_request", "InternetQueryOption(handle count)");
                } else {
                    printf("current handle count = %d\n", handles);
                }
                break;

            case 'q':
                toodle_pip();
                exit(0);

            case 's':
                PreviousCallback = InternetSetStatusCallback(InetHandle,
                                                             PreviousCallback
                                                             );
                if (Verbose) {
                    printf("previous Internet callback = %x\n", PreviousCallback);
                }
                if ((PreviousCallback != NULL) && (PreviousCallback != my_callback)) {
                    printf("error: get_gopher_request: previous callback not recognised\n");
                }
                got = TRUE;
                break;

            case 'v':
                Verbose = !Verbose;
                printf("verbose mode %s\n", Verbose ? "on" : "off");
                break;

            default:
                printf("\n"
                       "enter the number of your selection or one of the following:\n"
                       "\n"
                       "\t+ = toggle gopher+\n"
                       "\t. = list current directory\n"
                       "\tg = go to new server\n"
                       "\th = list home directory\n"
                       "\t1 = display handle usage\n"
                       "\tq = quit\n"
                       "\ts = toggle status callback\n"
                       "\tv = toggle verbose mode\n"
                       );
            }
        }
    }
    putchar('\n');

    return n;
}

void clear_items() {
    while (nitems) {
        --nitems;
        free(items[nitems].display_string);
        free(items[nitems].locator);
    }
}

VOID
my_callback(
    HINTERNET Handle,
    DWORD Context,
    DWORD Status,
    LPVOID Info,
    DWORD Length
    )
{
    char* type$;

    switch (Status) {
    case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

    case INTERNET_STATUS_HANDLE_CREATED:
        type$ = "HANDLE CREATED";
        break;

    case INTERNET_STATUS_HANDLE_CLOSING:
        type$ = "HANDLE CLOSING";
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        AsyncResult = ((LPINTERNET_ASYNC_RESULT)Info)->dwResult;
        AsyncError = ((LPINTERNET_ASYNC_RESULT)Info)->dwError;
        break;

    default:
        type$ = "???";
        break;
    }
    if (Verbose) {
        printf("callback: handle %x [context %x [%s]] %s ",
                Handle,
                Context,
                (Context == GC_CONNECT_CONTEXT) ? "Connect"
                : (Context == GC_FIND_CONTEXT) ? "Find"
                : (Context == GC_FILE_CONTEXT) ? "File"
                : "???",
                type$
                );
        if (Info) {
            if ((Status == INTERNET_STATUS_HANDLE_CREATED)
            || (Status == INTERNET_STATUS_HANDLE_CLOSING)) {
                printf("%x", *(LPHINTERNET)Info);
            } else if (Length == sizeof(DWORD)) {
                printf("%d", *(LPDWORD)Info);
            } else if (Status != INTERNET_STATUS_REQUEST_COMPLETE) {
                printf(Info);
            }
        }
        putchar('\n');
    }
    if (Status == INTERNET_STATUS_REQUEST_COMPLETE) {
        if (AsyncMode) {
            SetEvent(AsyncEvent);
        } else {
            printf("error: INTERNET_STATUS_REQUEST_COMPLETE received when not async\n");
        }
    }
}

char hex_to_char(char b) {
    return (b <= 9) ? (b + '0') : ((b - 10) + 'a');
}

char* decontrol(char* instr, char* outstr) {

    char* outp;

    for (outp = outstr; *instr; ++instr) {
        if (*instr < 0x20) {
            *outp++ = '\\';
            switch (*instr) {
            case '\t':
                *outp++ = 't';
                break;

            case '\r':
                *outp++ = 'r';
                break;

            case '\n':
                *outp++ = 'n';
                break;

            default:
                *outp++ = 'x';
                *outp++ = hex_to_char((char)(*instr >> 4));
                *outp++ = hex_to_char((char)(*instr & 15));
            }
        } else {
            *outp++ = *instr;
        }
    }
    *outp = 0;
    return outstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\ftp.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ftp.cxx

Abstract:

    Contains methods for FTP_FIND_HANDLE_OBJECT and FTP_FILE_HANDLE_OBJECT classes

    Contents:
        RMakeFtpFindObjectHandle
        RMakeFtpFileObjectHandle
        RMakeFtpErrorObjectHandle
        FTP_ERROR_HANDLE_OBJECT::SetErrorText
        FTP_ERROR_HANDLE_OBJECT::QueryHtmlDataAvailable

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeFtpFindObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an FTP_FIND_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of FTP_FIND_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    FTP_FIND_HANDLE_OBJECT * hFind;

    hFind = new FTP_FIND_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFind != NULL) {
        error = hFind->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFind);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFind = NULL;
            }
        } else {
            delete hFind;
            hFind = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFind;

    return error;
}


DWORD
RMakeFtpFileObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an FTP_FILE_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of FTP_FILE_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    FTP_FILE_HANDLE_OBJECT * hFile;
    DEBUG_PRINT(FTP,
                INFO,
                ("RMakeFtpFileObject(0x%x 0x%x 0x%x 0x%x)\r\n", 
                ParentHandle, ChildHandle, wCloseFunc, dwContext));


    hFile = new FTP_FILE_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFile != NULL) {
        error = hFile->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFile);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFile = NULL;
            }
        } else {
            delete hFile;
            hFile = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFile;

    return error;
}

#ifdef EXTENDED_ERROR_HTML

DWORD
RMakeFtpErrorObjectHandle(
    IN HINTERNET hConnect,
    OUT LPHINTERNET lphError
    )

/*++

Routine Description:

    Creates an FTP_ERROR_HANDLE_OBJECT. Used to return extended error info as
    HTML

Arguments:

    hConnect    - pointer to INTERNET_CONNECT_HANDLE_OBJECT

    lphError    - pointer to returned FTP_ERROR_HANDLE_OBJECT

Return Value:

    DWORD

--*/

{
    FTP_ERROR_HANDLE_OBJECT * hError;

    hError = new FTP_ERROR_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)hConnect
                    );

    DWORD error;

    if (hError != NULL) {
        error = hError->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hError);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hError = NULL;
            }
        } else {
            delete hError;
            hError = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *lphError = (HINTERNET)hError;

    return error;
}
#endif

//
// FTP_FIND_HANDLE_OJBECT class implementation
//

FTP_FIND_HANDLE_OBJECT::FTP_FIND_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FindHandle = Child;
    _wCloseFunction = wCloseFunc;
    _dwFtpFindBools = 0;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _Context = dwContext;
    SetObjectType(TypeFtpFindHandle);
}

FTP_FIND_HANDLE_OBJECT::~FTP_FIND_HANDLE_OBJECT(
    VOID
    )
{
    //
    // if local internet handle, closed by local close function
    //

    if (_FindHandle != NULL) {
        _Status = _wCloseFunction(_FindHandle);

        //INET_ASSERT(_Status == ERROR_SUCCESS);

    } else {
        _Status = ERROR_SUCCESS;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }

    //
    // and the query buffer
    //

    FreeQueryBuffer();
}

HANDLE
FTP_FIND_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FindHandle;
}

DWORD
FTP_FIND_HANDLE_OBJECT::QueryHtmlDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DWORD error;

    if (_QueryBuffer != NULL) {
        error = ERROR_SUCCESS;
    } else {
        error = AllocateQueryBuffer();
    }

    INET_ASSERT(_QueryBytesAvailable == 0);

    if (error == ERROR_SUCCESS) {
        _QueryOffset = 0;
        if (ReadHtmlUrlData((HINTERNET)this,
                            _QueryBuffer,
                            _QueryBufferLength,
                            lpdwNumberOfBytesAvailable
                            )) {
            _QueryBytesAvailable = *lpdwNumberOfBytesAvailable;
            //SetAvailableDataLength(_QueryBytesAvailable);
            if (_QueryBytesAvailable == 0) {
                SetEndOfFile();
            }
        } else {
            error = GetLastError();
        }
    }
    return error;
}

//
// FTP_FILE_HANDLE_OJBECT class implementation
//

FTP_FILE_HANDLE_OBJECT::FTP_FILE_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FileHandle = Child;
    _wCloseFunction = wCloseFunc;
    _IsHtml = FALSE;
    _lpszFileName = NULL;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _Context = dwContext;
    SetObjectType(TypeFtpFileHandle);
}

FTP_FILE_HANDLE_OBJECT::~FTP_FILE_HANDLE_OBJECT(
    VOID
    )
{

    //
    // if local internet handle, closed by local close function
    //

    if (_FileHandle != NULL) {
        _Status = _wCloseFunction(_FileHandle);

        //INET_ASSERT(_Status == ERROR_SUCCESS);

    } else {
        _Status = ERROR_INVALID_HANDLE;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }
    if (_lpszFileName != NULL) {
        DEL_STRING(_lpszFileName);
    }
}

HINTERNET
FTP_FILE_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FileHandle;
}

#ifdef EXTENDED_ERROR_HTML

//
// FTP_ERROR_HANDLE_OBJECT class implementation
//

FTP_ERROR_HANDLE_OBJECT::FTP_ERROR_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT* hConnect
    ) : INTERNET_CONNECT_HANDLE_OBJECT(hConnect)
{
    m_lpszErrorText = NULL;
    m_dwErrorTextLength = 0;
    m_QueryBuffer = NULL;
    m_QueryBufferLength = 0;
    m_QueryOffset = 0;
    m_QueryBytesAvailable = 0;
    m_HtmlState = HTML_STATE_START;
    SetObjectType(TypeFtpFileHandle);
    SetErrorText();
}

FTP_ERROR_HANDLE_OBJECT::~FTP_ERROR_HANDLE_OBJECT(
    VOID
    )
{
    //
    // clear out any strings we allocated
    //

    if (m_lpszErrorText != NULL) {
        DEL_STRING(m_lpszErrorText);
    }

    //
    // and the query buffer
    //

    FreeQueryBuffer();
}

DWORD
FTP_ERROR_HANDLE_OBJECT::SetErrorText(
    VOID
    )

/*++

Routine Description:

    Copies last error info to this handle object

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    INET_ASSERT(m_lpszErrorText == NULL);
    INET_ASSERT(m_dwErrorTextLength == 0);

    DWORD error;
    DWORD category;

    if (!InternetGetLastResponseInfo(&category, NULL, &m_dwErrorTextLength)) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            m_lpszErrorText = (LPSTR)ALLOCATE_MEMORY(
                                        LMEM_FIXED,
                                        m_dwErrorTextLength
                                        );
            if (m_lpszErrorText != NULL) {
                if (!InternetGetLastResponseInfo(&category,
                                                 m_lpszErrorText,
                                                 &m_dwErrorTextLength)) {
                    m_lpszErrorText[0] = '\0';
                    m_dwErrorTextLength = 0;
                }
                error = ERROR_SUCCESS;
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return error;
}

DWORD
FTP_ERROR_HANDLE_OBJECT::QueryHtmlDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DWORD error;

    if (m_QueryBuffer != NULL) {
        error = ERROR_SUCCESS;
    } else {
        error = AllocateQueryBuffer();
    }

    INET_ASSERT(m_QueryBytesAvailable == 0);

    if (error == ERROR_SUCCESS) {
        m_QueryOffset = 0;
        if (ReadHtmlUrlData((HINTERNET)this,
                            m_QueryBuffer,
                            m_QueryBufferLength,
                            lpdwNumberOfBytesAvailable
                            )) {
            m_QueryBytesAvailable = *lpdwNumberOfBytesAvailable;
            if (m_QueryBytesAvailable == 0) {
                SetEndOfFile();
            }
        } else {
            error = GetLastError();
        }
    }
    return error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\connect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    Contains methods for INTERNET_CONNECT_HANDLE_OBJECT class

    Contents:
        RMakeInternetConnectObjectHandle
        FindExistingConnectObject
        FlushExistingConnectObjects
        INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT
        INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT
        INTERNET_CONNECT_HANDLE_OBJECT::AttachLastResponseInfo
        INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer
        INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(INTERNET_SCHEME, BOOL, BOOL)
        INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(LPSTR, DWORD)

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

#define DEFAULT_VARIABLE_CACHE_INFO_SIZE    512

//
// data
//
LONG GlobalExistingConnectHandles = 0;

extern DWORD dwCacheWriteBufferSize;

BOOL
GetCanonicalizedParentUrl(
    LPSTR   lpszChildUrl,
    LPSTR   lpszParentUrlBuff,
    DWORD   dwBuffSize);

//
// functions
//


DWORD
RMakeInternetConnectObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CONNECT_CLOSE_HANDLE_FUNC wCloseFunc,
    IN LPSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPSTR lpszUserName OPTIONAL,
    IN LPSTR lpszPassword OPTIONAL,
    IN DWORD ServiceType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates an INTERNET_CONNECT_HANDLE_OBJECT. Wrapper function callable from
    C code

Arguments:

    ParentHandle    - parent InternetOpen() handle

    ChildHandle     - IN: protocol-specific child handle
                      OUT: address of handle object

    wCloseFunc      - pointer to function to close when object deleted

    lpszServerName  - pointer to server name

    nServerPort     - server port to connect to

    lpszUserName    - optional user name

    lpszPassword    - optional password

    ServiceType     - type of service required, e.g. INTERNET_SERVICE_HTTP

    dwFlags         - various open flags from InternetConnect()

    dwContext       - app-supplied context value to associate with the handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    INTERNET_CONNECT_HANDLE_OBJECT * hConnect;

    hConnect = new INTERNET_CONNECT_HANDLE_OBJECT(
                                (INTERNET_HANDLE_OBJECT *)ParentHandle,
                                *ChildHandle,
                                wCloseFunc,
                                lpszServerName,
                                nServerPort,
                                lpszUserName,
                                lpszPassword,
                                ServiceType,
                                dwFlags,
                                dwContext
                                );

    if (hConnect != NULL) {
        error = hConnect->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hConnect);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hConnect = NULL;
            }
        } else {
            delete hConnect;
            hConnect = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hConnect;

    return error;
}


HINTERNET
FindExistingConnectObject(
    IN HINTERNET hInternet,
    IN LPSTR lpHostName,
    IN INTERNET_PORT nPort,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    IN DWORD dwServiceType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Attempts to find an existing INTERNET_CONNECT_HANDLE_OBJECT with the
    desired attributes

Arguments:

    hInternet       - required parent handle

    lpHostName      - pointer to host name to connect to

    nPort           - port at server to connect to

    lpszUserName    - name of user making requests

    lpszPassword    - password required to establish connection

    dwServiceType   - type of service required

    dwFlags         - extra control information

    dwContext       - required context value

Return Value:

    HINTERNET
        Success - handle of found object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Handle,
                 "FindExistingConnectObject",
                 "%#x, %q, %d, %q, %q, %s (%d), %#x, %#x",
                 hInternet,
                 lpHostName,
                 nPort,
                 lpszUserName,
                 lpszPassword,
                 InternetMapService(dwServiceType),
                 dwServiceType,
                 dwFlags,
                 dwContext
                 ));

    HINTERNET hConnect = NULL;
    HINTERNET_HANDLE_TYPE handleType;
    INTERNET_PORT defaultPort;

    switch (dwServiceType) {
    case INTERNET_SERVICE_FTP:
        handleType = TypeFtpConnectHandle;
        defaultPort = INTERNET_DEFAULT_FTP_PORT;
        break;

    case INTERNET_SERVICE_GOPHER:
        handleType = TypeGopherConnectHandle;
        defaultPort = INTERNET_DEFAULT_GOPHER_PORT;
        break;

    case INTERNET_SERVICE_HTTP:
        handleType = TypeHttpConnectHandle;
        defaultPort = (dwFlags & INTERNET_FLAG_SECURE)
                        ? INTERNET_DEFAULT_HTTPS_PORT
                        : INTERNET_DEFAULT_HTTP_PORT;
        break;

    default:

        INET_ASSERT(FALSE);

        break;
    }

    if (nPort == INTERNET_INVALID_PORT_NUMBER) {
        nPort = defaultPort;
    }

    LockSerializedList(&GlobalObjectList);

    PLIST_ENTRY entry;

    for (entry = HeadOfSerializedList(&GlobalObjectList);
        entry != (PLIST_ENTRY)SlSelf(&GlobalObjectList);
        entry = entry->Flink) {

        HANDLE_OBJECT * pObject = CONTAINING_RECORD(entry, HANDLE_OBJECT, _List);

        //
        // check elements of the HANDLE_OBJECT first (DWORDs)
        //

        HANDLE_OBJECT * pParent = (HANDLE_OBJECT *)pObject->GetParent();

        if ((pObject->GetHandleType() == handleType)
        && ((pParent != NULL) && (pParent->GetPseudoHandle() == hInternet))
        && (pObject->GetContext() == dwContext)

        //
        // the handle may be invalidated - its been closed, but is still alive
        // because it has children which are in the process of being closed
        //

        && !pObject->IsInvalidated()) {

            //
            // handle is correct type & has the right parent & context values.
            // Next, check if its reusable and currently unused, and has the
            // correct destination attributes
            //

            INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

            pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pObject;
            if (!pConnect->IsInUse() && (pConnect->GetHostPort() == nPort)) {

                LPSTR hostName = pConnect->GetHostName();

                if (((lpHostName == NULL) && (hostName == NULL))
                || ((lpHostName != NULL) && (hostName != NULL)
                    && !stricmp(lpHostName, hostName))) {

                    //
                    // must have same name and password, or no name and/or
                    // password
                    //

                    LPSTR userName = pConnect->GetUserOrPass (TRUE, IS_SERVER);

                    if (((lpszUserName == NULL) && (userName == NULL))
                    || ((lpszUserName != NULL) && (userName != NULL)
                        && !strcmp(lpszUserName, userName))) {

                        LPSTR password = pConnect->GetUserOrPass (FALSE, IS_SERVER);

                        if (((lpszPassword == NULL) && (password == NULL))
                        || ((lpszPassword != NULL) && (password != NULL)
                            && !strcmp(lpszPassword, password))) {

                            //
                            // this one will do - should be no other users
                            //

                            //INET_ASSERT(pConnect->ReferenceCount() == 1);
//{
//    if (pConnect->ReferenceCount() != 1) {
//        dprintf("handle %#x [%#x]: refcount = %d\n",
//            pConnect,
//            pConnect->GetPseudoHandle(),
//            pConnect->ReferenceCount()
//            );
//    }
//}
                            if (pConnect->ReferenceCount() == 1) {

                                //
                                // reset the CWD - ignore any error
                                //

                                DWORD error = pConnect->SetCurrentWorkingDirectory("/");

                                INET_ASSERT(error == ERROR_SUCCESS);

                                //
                                // this handle is back in use
                                //

                                pConnect->SetInUse();
                                hConnect = (HINTERNET)pConnect;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    UnlockSerializedList(&GlobalObjectList);

    DEBUG_LEAVE(hConnect);

    return hConnect;
}


INT
FlushExistingConnectObjects(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes all unused EXISTING_CONNECT objects that are children of hInternet

Arguments:

    hInternet   - parent handle

Return Value:

    INT
        Number of handles flushed

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "FlushExistingConnectObjects",
                 "%#x",
                 hInternet
                 ));

    INT nFlushed = 0;

    if (GlobalExistingConnectHandles > 0) {

        LockSerializedList(&GlobalObjectList);

        PLIST_ENTRY previous = (PLIST_ENTRY)SlSelf(&GlobalObjectList);
        PLIST_ENTRY entry = HeadOfSerializedList(&GlobalObjectList);

        while (entry != (PLIST_ENTRY)SlSelf(&GlobalObjectList)) {

            HANDLE_OBJECT * pObject = CONTAINING_RECORD(entry, HANDLE_OBJECT, _List);
            HANDLE_OBJECT * pParent = (HANDLE_OBJECT *)pObject->GetParent();
            BOOL flushed = FALSE;

            if ((pParent != NULL) && (pParent->GetPseudoHandle() == hInternet)) {

                HINTERNET_HANDLE_TYPE handleType = pObject->GetHandleType();

                if ((handleType == TypeFtpConnectHandle)
                || (handleType == TypeGopherConnectHandle)
                || (handleType == TypeHttpConnectHandle)) {

                    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

                    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)pObject;
                    if (!pConnect->IsInUse() && !pConnect->IsInvalidated()) {

                        //INET_ASSERT(pConnect->ReferenceCount() == 1);

                        IF_DEBUG_CONTROL(ANY) {

                            if (pConnect->ReferenceCount() != 1) {

                                DEBUG_PRINT(OBJECTS,
                                            WARNING,
                                            ("handle %#x [%#x]: refcount = %d\n",
                                            pConnect,
                                            pConnect->GetPseudoHandle(),
                                            pConnect->ReferenceCount()
                                            ));

                                //dprintf("handle %#x [%#x]: refcount = %d\n",
                                //        pConnect,
                                //        pConnect->GetPseudoHandle(),
                                //        pConnect->ReferenceCount()
                                //        );
                            }

                        }

                        //
                        // invalidate the object (stops an assert - we normally
                        // expect the handle to be invalidated by
                        // MapHandleToAddress(), but we're simply dereferencing
                        // the object, which would usually be done by the second
                        // of 2 calls to DereferenceObject(), so we save ourselves
                        // from jumping through hoops just to destroy the object)
                        //

                        pConnect->Invalidate();
                        flushed = pConnect->Dereference();

                        //
                        // the entry was unused; it should have been destroyed
                        //

                        //INET_ASSERT(flushed);

                        DEBUG_PRINT(OBJECTS,
                                    INFO,
                                    ("flushed object %#x\n",
                                    pConnect
                                    ));

                    }
                }
            }

            //
            // if we just destroyed the object pointed at by entry then we need
            // to dereference the previous pointer for the next object
            //

            if (flushed) {
                ++nFlushed;
                entry = previous->Flink;
            } else {
                previous = entry;
                entry = entry->Flink;
            }
        }

        UnlockSerializedList(&GlobalObjectList);
    }

    DEBUG_LEAVE(nFlushed);

//dprintf("*** flushed %d objects\n", nFlushed);
    return nFlushed;
}

//
// INTERNET_CONNECT_HANDLE_OBJECT class implementation
//


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *InternetConnectObj
    ) : INTERNET_HANDLE_OBJECT((INTERNET_HANDLE_OBJECT *)InternetConnectObj)

/*++

Routine Description:

    Constructor that creates a copy of an INTERNET_CONNECT_HANDLE_OBJECT when
    generating a derived handle object, such as a HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    InternetConnectObj  - INTERNET_CONNECT_HANDLE_OBJECT to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x",
                 InternetConnectObj
                 ));

    _InternetConnectHandle = InternetConnectObj->_InternetConnectHandle;
    _wCloseFunction = InternetConnectObj->_wCloseFunction;
    _HandleType = InternetConnectObj->_HandleType;
    _ServiceType = InternetConnectObj->_ServiceType;
    _IsCopy = TRUE;

    //
    // copy the flags except EXISTING_CONNECT - we don't want to influence the
    // number of flushable handles just by closing a request handle
    //

    _Flags = InternetConnectObj->_Flags & ~INTERNET_FLAG_EXISTING_CONNECT;

    //
    // in this case, we are not dealing with a real connect handle object, but a
    // derived object, hence _InUse is FALSE
    //

    _InUse = FALSE;

    _ReadBufferSize = InternetConnectObj->_ReadBufferSize;
    _WriteBufferSize = InternetConnectObj->_WriteBufferSize;

    //
    // copy the name objects and server port
    //

    _HostName = InternetConnectObj->_HostName;
    _HostPort = InternetConnectObj->_HostPort;

    //
    // _SchemeType is actual scheme we use. May be different than original
    // object type when going via CERN proxy. Initially set to default (HTTP)
    //

    _SchemeType = InternetConnectObj->_SchemeType;

    //
    // _LastResponseInfo points to a buffer containing the last response info
    // from an FTP URL operation
    //

    _LastResponseInfo = NULL;

    InitCacheVariables();
    if (InternetConnectObj->_CacheUrlName != NULL) {
        SetURL (InternetConnectObj->_CacheUrlName);
    }
    if (InternetConnectObj->_CacheCWD != NULL) {
        _CacheCWD = NEW_STRING(InternetConnectObj->_CacheCWD);
    }

    // Inherit the PerUserItem status of the parent
    _CachePerUserItem = InternetConnectObj->_CachePerUserItem;
    
    _bViaProxy = InternetConnectObj->_bViaProxy;
    _bNoHeaders = InternetConnectObj->_bNoHeaders;
    _bNetFailed = InternetConnectObj->_bNetFailed;
    _ServerInfo = InternetConnectObj->_ServerInfo;
    _OriginServer = InternetConnectObj->_OriginServer;
    _dwErrorMask = 0;

    _pwcServerCreds = NULL;
    _pwcProxyCreds  = NULL;

    //
    // reference the server info to balance the deref in our destructor
    //

    if (_ServerInfo != NULL) {

        //
        // could be cache-only handle
        //

        _ServerInfo->Reference();
    }
    if (_OriginServer != NULL) {
        _OriginServer->Reference();
    }

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_HANDLE_OBJECT * Parent,
    HINTERNET Child,
    CONNECT_CLOSE_HANDLE_FUNC wCloseFunc,
    LPTSTR lpszServerName,
    INTERNET_PORT nServerPort,
    LPTSTR lpszUsername OPTIONAL,
    LPTSTR lpszPassword OPTIONAL,
    DWORD SrvType,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_HANDLE_OBJECT(Parent)

/*++

Routine Description:

    Constructor for direct-to-net INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    Parent          - pointer to parent handle (INTERNET_HANDLE_OBJECT as
                      created by InternetOpen())

    Child           - handle of child object - typically an identifying value
                      for the protocol-specific code

    wCloseFunc      - pointer to function that handles closes when
                      InternetCloseHandle() called for this object

    lpszServerName  - name of the server we are connecting to. May also be the
                      IP address expressed as a string

    nServerPort     - the port number at the server to which we connect

    lpszUsername    - user name for logon at server (if required)

    lpszPassword    - password for logon at server (if required)

    SrvType         - Type of service, e.g. INTERNET_SERVICE_HTTP that this
                      object represents

    dwFlags         - creation flags from InternetConnect():

                        - INTERNET_FLAG_PASSIVE

    dwContext       - context value for call-backs

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x, %#x, %#x, %q, %d, %q, %q, %s (%d), %#x, %#x",
                 Parent,
                 Child,
                 wCloseFunc,
                 lpszServerName,
                 nServerPort,
                 lpszUsername,
                 lpszPassword,
                 InternetMapService(SrvType),
                 SrvType,
                 dwFlags,
                 dwContext
                 ));

    _pwcServerCreds = NULL;
    _pwcProxyCreds  = NULL;
    _fHasCredsTimestamp = FALSE;

    _InternetConnectHandle = Child;
    _wCloseFunction = wCloseFunc;
    _ServiceType = SrvType;
    _Context = dwContext;
    _IsCopy = FALSE;

    SetHandleType(SrvType);

    //
    // remember the creation flags. Mainly (currently) for HTTP Keep-Alive
    //

    _Flags = dwFlags;

    //
    // setting _InUse to TRUE stops any EXISTING_CONNECT requests from acquiring
    // it
    //

    _InUse = TRUE;

    InitCacheVariables();

    //
    // set the read/write buffer sizes to the default values (4K)
    //

    _ReadBufferSize = (4 K);
    _WriteBufferSize = (4 K);

    //
    // create the string buffer and copy the port number
    //

    _HostName = lpszServerName;
    if (lpszUsername) {
        SetUserOrPass(lpszUsername, TRUE, FALSE);
    }
    if (lpszPassword) {
        SetUserOrPass(lpszPassword, FALSE, FALSE);
        TimeStampCreds();
    }
    _HostPort = nServerPort;

    //
    // set the scheme and object types based on the service type
    //

    INTERNET_SCHEME schemeType;
    HINTERNET_HANDLE_TYPE handleType;

    switch (_ServiceType) {
    case INTERNET_SERVICE_HTTP:
        schemeType = INTERNET_SCHEME_HTTP;
        handleType = TypeHttpConnectHandle;
        break;

    case INTERNET_SERVICE_FTP:
        schemeType = INTERNET_SCHEME_FTP;
        handleType = TypeFtpConnectHandle;
        break;

    case INTERNET_SERVICE_GOPHER:
        schemeType = INTERNET_SCHEME_GOPHER;
        handleType = TypeGopherConnectHandle;
        break;

    default:
        schemeType = INTERNET_SCHEME_DEFAULT;
        handleType = TypeWildHandle;
        break;
    }
    SetSchemeType(schemeType);
    SetObjectType(handleType);

    //
    // _LastResponseInfo points to a buffer containing the last response info
    // from an FTP URL operation
    //

    _LastResponseInfo = NULL;
    _bViaProxy = FALSE;
    _bNoHeaders = TRUE;
    _bNetFailed = FALSE;
    _HandleFlags.fServerUserPassValid = TRUE;
    _HandleFlags.fProxyUserPassValid = TRUE;

    //
    // we need to get the server info that we are going to connect to. In the
    // HTTPS case, we don't yet have enough info to make a proper decision, so
    // we defer that until HttpOpenRequest() at which point we may get another
    // SERVER_INFO
    //

    _ServerInfo = NULL;
    _OriginServer = NULL;
    _Status = SetServerInfo(schemeType, FALSE);

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT(VOID)

/*++

Routine Description:

    Destructor for INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT",
                 NULL
                 ));

    if ((!_IsCopy) && (_InternetConnectHandle != INET_INVALID_HANDLE_VALUE)) {

        HINTERNET _INetHandle;
        DWORD LocalError = ERROR_SUCCESS;

        _INetHandle = this->GetInternetHandle();

        if (_INetHandle == LOCAL_INET_HANDLE) {
            if (_wCloseFunction != NULL) {
                LocalError = ERROR_SUCCESS;
                if (!(this->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE)) {
                    LocalError = _wCloseFunction(_InternetConnectHandle,
                                                 _ServiceType
                                                 );
                }
            } else {

                INET_ASSERT(LocalError == ERROR_SUCCESS);

            }
        }

        //INET_ASSERT( LocalError == ERROR_SUCCESS );

    }

    if (_CacheReadInProgress) {

        INET_ASSERT(_CacheWriteInProgress == FALSE);

        EndCacheRetrieval();
    } else if (_CacheWriteInProgress) {

        // Abort cache write operation
        //

        EndCacheWrite(NULL, NULL, NULL, 0xffffffff, 0, NULL, NULL);
    }

    // background update if the flag is set
    if( _fLazyUpdate )
    {
        LazyUpdate();
    }


    if (_hLockRequestInfo) {

        //
        // If the request is locked, the last InternetUnlockRequestFile
        // will clean up so there is no need to check _fDeleteDataFile.
        //

        if (_fDeleteDataFile) {

            // We let InternetUnlockRequestFile know that it doesn't
            // have to do a cache lookup and if DeleteFile fails that
            // it should add the file to the leaked list.

            LPLOCK_REQUEST_INFO pLock = (LPLOCK_REQUEST_INFO) _hLockRequestInfo;
            pLock->fNoCacheLookup = TRUE;

        }

        InternetUnlockRequestFile(_hLockRequestInfo);

    } else if (_fDeleteDataFile) {

        //
        // This flag is set if we are not committing a download file to cache,
        // either because we never intended to or the download was aborted.
        //

        if (!DeleteFile (_CacheFileName)) {

            switch (GetLastError()) {
                case ERROR_SHARING_VIOLATION:
                case ERROR_ACCESS_DENIED:
                 UrlCacheAddLeakFile (_CacheFileName);
            }
        }
    }

    // delete the staled entry (to prevent back/fwd see the staled entry)
    if( _fDeleteDataFile && _CacheUrlName ) {
        DeleteUrlCacheEntry(_CacheUrlName);
    }


    FreeCacheFileName();

    INET_ASSERT(_CacheFileName == NULL);
    INET_ASSERT(_CacheFileHandle == INVALID_HANDLE_VALUE);

    if (_CacheCWD) {
        _CacheCWD = (LPSTR)FREE_MEMORY((HLOCAL)_CacheCWD);

        INET_ASSERT(_CacheCWD == NULL);

    }


    // if there is refcount, then remove it


    FreeURL();

    SetOriginalUrl(NULL);

#ifdef LAZY_WRITE
    if (_CacheScratchBuf) {
        _CacheScratchBuf = (LPBYTE)FREE_MEMORY((HLOCAL)_CacheScratchBuf);

        INET_ASSERT(_CacheScratchBuf == NULL);

    }
#endif

    FreeLastResponseInfo();

    if ((_Flags & INTERNET_FLAG_EXISTING_CONNECT) && !_InUse) {

        //
        // one less handle that can be flushed right now
        //

//dprintf("GlobalExistingConnectHandles = %d\n", GlobalExistingConnectHandles);

        if (InterlockedDecrement(&GlobalExistingConnectHandles) < 0) {

            INET_ASSERT(FALSE);

            GlobalExistingConnectHandles = 0;
        }
    }

    PWC_Free(_pwcServerCreds);
    PWC_Free(_pwcProxyCreds);

    if (_ServerInfo != NULL) {
        _ServerInfo->Dereference();
    }
    if (_OriginServer != NULL) {
        _OriginServer->Dereference();
    }

    DEBUG_LEAVE(0);
}

BOOL INTERNET_CONNECT_HANDLE_OBJECT::SetURL (LPSTR lpszUrl)
{
    LPSTR lpszNew;

    if (!_xsSecondaryCacheKey.GetPtr()) {

        // Make an undecorated copy of the URL.

        lpszNew = NewString(lpszUrl);
        if (!lpszNew) {
            return FALSE;
        }

    } else {

        // Decorate the URL by appending the secondary cache key.

        lpszNew = CatString (lpszUrl, _xsSecondaryCacheKey.GetPtr());
        if (!lpszNew) {
            return FALSE;
        }

        // Restore the undecorated URL as the primary cache key.

        if (!_xsPrimaryCacheKey.SetData (lpszUrl)) {
            FREE_MEMORY (lpszNew);
            return FALSE;
        }

    }

    // Clear any previous cache key and record the new one.

    FreeURL();
    INET_ASSERT (lpszNew);
    _CacheUrlName = lpszNew;
    return TRUE;
}

BOOL INTERNET_CONNECT_HANDLE_OBJECT::SetURLPtr(LPSTR* ppszUrl)
{
    LPSTR lpszNew;

    if (!_xsSecondaryCacheKey.GetPtr()) {

        // Swap in the new URL as the cache key.

        FreeURL();
        _CacheUrlName = *ppszUrl;
        *ppszUrl = NULL;

    } else {

        // Decorate the URL by appending the secondary cache key.

        lpszNew = CatString (*ppszUrl, _xsSecondaryCacheKey.GetPtr());
        if (!lpszNew) {
            return FALSE;
        }

        // Back up the undecorated URL as the primary cache key.

        _xsPrimaryCacheKey.SetPtr (ppszUrl);
        INET_ASSERT (!*ppszUrl);

        // Clear any previous cache key and record the new one.

        FreeURL();
        _CacheUrlName = lpszNew;
    }

    return TRUE;
}


BOOL INTERNET_CONNECT_HANDLE_OBJECT::SetSecondaryCacheKey (LPSTR lpszKey)
{
    LPSTR lpszTemp = NULL;


    if (_CacheUrlName) {

        // Decorate the URL by appending the secondary cache key.

        // BUGBUG: what if it is already decorated?  The app
        // better not set the secondary cache key more than once.

        lpszTemp = CatString (_CacheUrlName, lpszKey);
        if (!lpszTemp)
            return FALSE;
    }

    // Save the secondary cache key in case we later change the URL.

    if (!_xsSecondaryCacheKey.SetData (lpszKey)) {

        if (lpszTemp) {
            FREE_MEMORY (lpszTemp);
        }
        return FALSE;
    }

    if (lpszTemp)
    {
        // Back up the undecorated URL as the primary cache key.

        _xsPrimaryCacheKey.SetPtr (&_CacheUrlName);
        INET_ASSERT (!_CacheUrlName);
        _CacheUrlName = lpszTemp;
    }

    return TRUE;
}

void INTERNET_CONNECT_HANDLE_OBJECT::FreeSecondaryCacheKey (void)
{
    if (_xsSecondaryCacheKey.GetPtr()) {

        // Free the secondary key and the decorated URL.

        _xsSecondaryCacheKey.Free();
        FreeURL();

        // Back up the cache key from the undecorated URL.

        LPSTR lpszOld = _xsPrimaryCacheKey.ClearPtr();
        _CacheUrlName = lpszOld;
    }
}


HINTERNET
INTERNET_CONNECT_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _InternetConnectHandle;
}

//
// Cache methods.
//

char* back_up(char* stopper, char* ptr) {

    INET_ASSERT(stopper <= ptr);

    while ((*ptr != '/') && (ptr >= stopper)) --ptr;
    return ((ptr >= stopper) && (*ptr == '/')) ? ptr : NULL;
}

char* convert_macros(char* path) {

    char* ls = NULL;    // last slash
    char* pls = NULL;   // previous last slash
    char* p = path;

    while (*p) {
        if (*p == '/') {
            pls = ls;
            ls = p;
        }
        if (*p == '.') {
            if (*(p + 1) == '/') {
                p = lstrcpy(ls, p + 1);
            } else if (*(p + 1) == '\0') {
                if (*(p - 1) == '/') {
                    *p = '\0';
                }
            } else if (!strncmp(p, "../", 3)) {
                if ((!pls) || (ls != p - 1)) {
                    return NULL;
                }
                p = lstrcpy(pls, p + 2);
                ls = pls;
                pls = back_up(path, max(path, pls - 1));
            } else if (!lstrcmp(p, "..")) {
                if ((*(p - 1) != '/') || !pls) {
                    return NULL;
                } else {
                    *(pls + 1) = 0;
                    p = pls - 1;
                }
            }
        }
        ++p;
    }
    return path;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetCurrentWorkingDirectory(
    IN LPSTR lpszCWD
    )
{
    INET_ASSERT(lpszCWD != NULL);

    //
    // BUGBUG - we assume lpszCWD is clean which might not be true....
    //

    int clen;
    int slen;
    LPSTR cwd;

    if (*lpszCWD == '/') {
        cwd = NULL;
        ++lpszCWD;
    } else {
        cwd = _CacheCWD;
    }

    if (!cwd) {
        clen = 1;
    } else {
        clen = lstrlen(cwd);
    }

    slen = lstrlen(lpszCWD);

    LPSTR buffer = (LPSTR)ALLOCATE_FIXED_MEMORY(clen + 1 + slen + 1);

    if (buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (clen == 1) {
        buffer[0] = '/';
    } else {
        memcpy(buffer, _CacheCWD, clen);
    }

    memcpy(&buffer[clen], lpszCWD, slen);
    clen += slen;
    if ((clen > 1) && (lpszCWD[slen - 1] != '/')) {
        buffer[clen++] = '/';
    }
    buffer[clen] = '\0';

    LPSTR p = convert_macros(buffer);

    if (p) {
        if (_CacheCWD != NULL) {
            FREE_MEMORY(_CacheCWD);
            _CacheCWD = NULL;
        }
        _CacheCWD = NewString(p);
    }

    FREE_MEMORY(buffer);

    return (p == NULL) ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::GetCurrentWorkingDirectory(
    LPSTR   lpszCWD,
    LPDWORD lpdwLen
    )
{
    DWORD   dwlenCWD;

    if (!_CacheCWD) {
        *lpdwLen = 0;
    }
    else {
        // do something if the guy gave us any buffer
        if (*lpdwLen) {
            dwlenCWD = lstrlen(_CacheCWD);

            // if the buffer is not enough, copy the size of the buffer
            if (dwlenCWD >= *lpdwLen) {
                memcpy(lpszCWD, _CacheCWD, *lpdwLen);
            }
            else {
                strcpy(lpszCWD, _CacheCWD);
                *lpdwLen = dwlenCWD;
            }
        }
    }
    return (ERROR_SUCCESS);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetObjectName(
    LPSTR lpszObjectName,
    LPSTR lpszExtension,
    URLGEN_FUNC * procProtocolUrl
    )
{
    DWORD   dwLen, dwError;
    INTERNET_SCHEME schemeType;

    // BUGBUG move this to protocol specific object

    //
    // if there is already an object name, then free it. We are replacing it
    //

    //
    // BUGBUG - make _CacheUrlString an ICSTRING
    //

    FreeURL();

    //
    // get protocol specific url
    //

    if (procProtocolUrl) {

        //
        // if we are going via proxy AND this is an FTP object AND the user name
        // consists of <username>@<servername> then <servername> is the real
        // server name, and _HostName is the name of the proxy
        //

        //
        // BUGBUG - this is a bit of a hack(!)
        //

        LPSTR target = _HostName.StringAddress();

        if (IsProxy()
        && (GetSchemeType() == INTERNET_SCHEME_FTP)
        && (_pwcServerCreds && _pwcServerCreds->lpszUser)) {

            LPSTR at = strchr(_pwcServerCreds->lpszUser, '@');

            if (at != NULL) {
                target = at + 1;

                INET_ASSERT(*target);

            }
        }
        schemeType = GetSchemeType();

        // make the scheme type https if necessary

        schemeType = (((schemeType == INTERNET_SCHEME_DEFAULT)||
                      (schemeType == INTERNET_SCHEME_HTTP)) &&
                      (_dwCacheFlags & INTERNET_FLAG_SECURE))?
                      INTERNET_SCHEME_HTTPS: schemeType;

        LPSTR lpszNewUrl = NULL;

        dwError = (*procProtocolUrl)(schemeType,
                                     target,
                                     _CacheCWD,
                                     lpszObjectName,
                                     lpszExtension,
                                     _HostPort,
                                     &lpszNewUrl,
                                     &dwLen
                                     );

        if (dwError == ERROR_SUCCESS) {

            if (!SetURLPtr (&lpszNewUrl)) {
                FREE_MEMORY (lpszNewUrl);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
	}
	else
	{
		dwError = ERROR_INVALID_PARAMETER;
	}

    if (dwError == ERROR_SUCCESS) {

        DEBUG_PRINT(HANDLE,
                    INFO,
                    ("Url: %s\n",
                    _CacheUrlName
                    ));

    }
    return dwError;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheRetrieval(
    LPCACHE_ENTRY_INFO  *lplpCacheEntryInfo
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheRetrieval",
                 "{%q} %#x",
                 _CacheUrlName,
                 lplpCacheEntryInfo
                 ));

    DWORD Error = ERROR_NOT_SUPPORTED;
    DWORD dwBufferSize = 0;
    int i;

    INET_ASSERT( _CacheReadInProgress == FALSE );
    INET_ASSERT( _CacheWriteInProgress == FALSE );
    //INET_ASSERT( _CacheFileName == NULL );
    INET_ASSERT( _CacheFileHandle == INVALID_HANDLE_VALUE );
    INET_ASSERT( _hCacheStream == NULL);

    *lplpCacheEntryInfo = NULL;

    if (!_CacheUrlName) {

        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("Cache: No UrlName\n"
                    ));

        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);

        return (ERROR_INVALID_PARAMETER);
    }

    dwBufferSize = sizeof(CACHE_ENTRY_INFO) + DEFAULT_VARIABLE_CACHE_INFO_SIZE;
    for (i=0; i<2; ++i) {

        if (*lplpCacheEntryInfo != NULL) {
            FREE_MEMORY(*lplpCacheEntryInfo);
        }

        *lplpCacheEntryInfo = (LPCACHE_ENTRY_INFO)ALLOCATE_MEMORY(
                                    LPTR
                                    , dwBufferSize);
        if (*lplpCacheEntryInfo) {
            _hCacheStream = RetrieveUrlCacheEntryStream( _CacheUrlName,
                                       *lplpCacheEntryInfo,
                                        &dwBufferSize,
                                        FALSE, // Not Random, sequential
                                        0);
            if (_hCacheStream == NULL) {

                //
                // second time around the buffer must be sufficient
                //

                INET_ASSERT(!((i == 1) && (Error == ERROR_INSUFFICIENT_BUFFER)));

                Error = GetLastError();

                if ((i == 1) || (Error != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            } else {

                break; // success
            }
        }
    }

    Error = RecordCacheRetrieval (*lplpCacheEntryInfo);

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        if (*lplpCacheEntryInfo) {
            FREE_MEMORY(*lplpCacheEntryInfo);
            *lplpCacheEntryInfo = NULL;
        }
        FreeCacheFileName();
    }

    DEBUG_LEAVE(Error);

    return( Error );
}

DWORD INTERNET_CONNECT_HANDLE_OBJECT::RecordCacheRetrieval
    (LPCACHE_ENTRY_INFO lpCacheEntryInfo)
{
    //
    // save cache file name.
    //
    FreeCacheFileName();
    INET_ASSERT(!_CacheFileName);
    _CacheFileName = NewString((lpCacheEntryInfo)->lpszLocalFileName);
    if (!_CacheFileName) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    _dwStreamRefCount = 0;
    _dwCurrentStreamPosition = 0;

    //
    // we have this much data immediately available to the application
    //

    SetAvailableDataLength((lpCacheEntryInfo)->dwSizeLow);

    //
    // and we automatically have the end-of-file indication
    //

    SetEndOfFile();

    _CacheReadInProgress = TRUE;

    return ERROR_SUCCESS;
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::ReadCache(
    LPBYTE lpbBuffer,
    DWORD dwBufferLen,
    LPDWORD lpdwBytesRead
    )
{
    DWORD dwError = ERROR_NOT_SUPPORTED;
    BOOL fOk;

    INET_ASSERT( _CacheReadInProgress == TRUE );

    *lpdwBytesRead = dwBufferLen;

    fOk = ReadUrlCacheEntryStream(
                                    _hCacheStream,
                                    _dwCurrentStreamPosition,
                                    lpbBuffer,
                                    lpdwBytesRead,
                                    0);
    if (fOk) {
        _dwCurrentStreamPosition += *lpdwBytesRead;
    }

    if( !fOk ) {
        dwError = GetLastError() ;
    }
    else {
        dwError =  ERROR_SUCCESS;

        DEBUG_PRINT(CACHE,
                    INFO,
                    ("read %d bytes from cache\n",
                    *lpdwBytesRead
                    ));

    }

    return(dwError);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::EndCacheRetrieval(
    VOID
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "EndCacheRetrieval",
                 "Url=%s, File=%s",
                 _CacheUrlName, _CacheFileName
                 ));

    DWORD Error = ERROR_SUCCESS;

    INET_ASSERT( _CacheUrlName != NULL );
    INET_ASSERT( _CacheReadInProgress == TRUE );
    INET_ASSERT( _CacheWriteInProgress == FALSE );


    INET_ASSERT(_hCacheStream != NULL);

    if (!_dwStreamRefCount) {    // if the caller obtained it using GetCacheStream
                                // then it is his responsibility to call
                                // UnlockCacheStream
        DEBUG_PRINT(CACHE,
                        INFO,
                        ("Wininet.EndCacheRetrieval: Calling UnlockUrlCacheEntryStream for %s\n",
                        _CacheUrlName
                        ));
        if (!UnlockUrlCacheEntryStream(_hCacheStream, 0)) {
            Error = GetLastError();
        }
    }

    if (Error == ERROR_SUCCESS) {
        _CacheReadInProgress = FALSE;
        _hCacheStream = NULL;
        _dwCurrentStreamPosition = 0;
        _dwStreamRefCount = 0;
    }

    DEBUG_LEAVE(Error);
    return( Error );
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::LazyUpdate()
{
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;
    INET_ASSERT(_CacheUrlName);

    dwError = CreateAndQueueBackgroundWorkItem(_CacheUrlName);
    return dwError;
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::GetCacheStream(
    LPBYTE  lpBuffer,
    DWORD   dwLen
    )
{
    DWORD   dwError = ERROR_INVALID_FUNCTION;
    if (_CacheReadInProgress) {
        if (dwLen > sizeof(_hCacheStream)) {
            ++_dwStreamRefCount;
            *(HANDLE *)lpBuffer = _hCacheStream;
            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    return (dwError);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::ReleaseCacheStream(
    HANDLE  hStream
    )
{
    DWORD   dwError = ERROR_INVALID_FUNCTION;
    if (_CacheReadInProgress) {
        if (_hCacheStream == hStream) {
            --_dwStreamRefCount;
            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_INVALID_PARAMETER;
        }
    }
    return (dwError);
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::BeginCacheWrite(
    DWORD   dwExpectedLength,
    LPCSTR  lpszFileExtension,
    LPCSTR  lpszFileName
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "BeginCacheWrite",
                 "%d, %q",
                 dwExpectedLength,
                 lpszFileExtension
                 ));

    DWORD Error=ERROR_NOT_SUPPORTED;

    CHAR FileName[MAX_PATH];
    CHAR* pFileName;

    // BUGBUG   uncode version needs to be fixed


    INET_ASSERT( _CacheReadInProgress == FALSE );
    INET_ASSERT( _CacheWriteInProgress == FALSE );
    FreeCacheFileName(); // may be left over from Begin/EndCacheRetrieval
                         // in case of ftp/gopher dir raw/html mismatch
    INET_ASSERT( _CacheFileHandle == INVALID_HANDLE_VALUE);

    if (!_CacheUrlName) {

        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("Invalid parameter\n"
                    ));

        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);

        return (ERROR_INVALID_PARAMETER);
    }

    // lpszFileName passed in indicates that
    // we want to create a filename from scratch.
    if (!lpszFileName)
    {
        *FileName = '\0';
        pFileName = FileName;
    }
    // Otherwise, attempt to use the filename passed in.
    else
        pFileName = (CHAR*) lpszFileName;


    // Create the cache file.

    Error = UrlCacheCreateFile(
                    _CacheUrlName,
                    (CHAR*) lpszFileExtension,
                    pFileName,
                    &_CacheFileHandle,
                    IsPerUserItem());

    if (Error != ERROR_SUCCESS)
    {
        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("Cache: Error %ld createurlcacheentry failed for %s\n",
                    Error,
                    _CacheUrlName
                    ));

        DEBUG_LEAVE(Error);

        return( Error); // BUGBUG refine this error
    } else IF_DEBUG(CACHE) {
        DEBUG_PRINT(CACHE, INFO, ("cache filename = %q\n", pFileName));
    }

//dprintf("caching %s (%s) in %s\n", _CacheUrlName, _OriginalUrl, FileName);

    //
    // save names.
    //

    INET_ASSERT(!_CacheFileName);
    _CacheFileName = NewString(pFileName);
    if (!_CacheFileName) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Error = ERROR_SUCCESS;

    INET_ASSERT(_CacheFileHandle != INVALID_HANDLE_VALUE);

    _CacheWriteInProgress = TRUE;
    Error =  ERROR_SUCCESS;


Cleanup:

    if( Error != ERROR_SUCCESS ) {

        if( _CacheFileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( _CacheFileHandle );
            _CacheFileHandle = INVALID_HANDLE_VALUE;
        }

        FreeCacheFileName();

        //
        // delete file temp file
        //

        BOOL BoolError;

        BoolError = DeleteFile( pFileName );
        INET_ASSERT( BoolError == TRUE );
    }

    DEBUG_LEAVE(Error);

    return( Error );
}

DWORD
INTERNET_CONNECT_HANDLE_OBJECT::WriteCache(
    LPBYTE Buffer,
    DWORD BufferLen
    )
{
    DWORD   dwError = ERROR_NOT_SUPPORTED;
    DWORD   dwSize, dwUsed, dwRemain;
    BOOL    fWriteToDisk = TRUE;

    DWORD BytesWritten;

    INET_ASSERT( _CacheWriteInProgress == TRUE );

/*
    DEBUG_PRINT( CACHE, INFO,
                ("Writecache: _virtualCacheFileSize=%d, realfilesize= %d, inputsize=%d\n",
                        _VirtualCacheFileSize, _RealCacheFileSize, BufferLen));
*/

#ifdef LAZY_WRITE

    LPBYTE   lpScratch, lpBuffer;

    if (_dwCacheFlags & INTERNET_FLAG_NEED_FILE) {

        lpScratch = GetCacheScratchBuf(&dwSize, &dwUsed);

        if (lpScratch) {

            // don't do default writes to disk
            fWriteToDisk = FALSE;

            lpBuffer = Buffer;
            dwRemain = BufferLen;

            INET_ASSERT(dwSize >= dwUsed);


            while ((dwUsed+dwRemain) >= dwSize) {

                DEBUG_PRINT( CACHE, INFO,
                            ("remaining=%d\n",
                             dwRemain));

                // Fill the buffer to the brim

                CopyToScratch(lpBuffer, (dwSize-dwUsed));

                lpBuffer += (dwSize-dwUsed);

                dwRemain -= (dwSize-dwUsed);

                // and write it out
                dwError = WriteToDisk(lpScratch, dwSize, &BytesWritten);

                if( dwError != ERROR_SUCCESS ) {

                    goto bailout;

                }

                INET_ASSERT( BytesWritten == dwSize );

                //mark the buffer as empty
                ResetScratchUseSize();

                // get it's location and new used size
                lpScratch = GetCacheScratchBuf(NULL, &dwUsed);
                INET_ASSERT(dwUsed == 0);

            }

            // if anything remain after our disk-writing frenzy
            // then keep it in the buffer

            if (dwRemain) {

                CopyToScratch(lpBuffer, dwRemain);

            }

        }
    }
#endif //LAZY_WRITE

    if (fWriteToDisk){

        // DEBUG_PRINT( CACHE, INFO, ("no lazy write, flushing to disk\n"));

        dwError = WriteToDisk(Buffer, BufferLen, &BytesWritten);

        if( dwError != ERROR_SUCCESS ) {

            goto bailout;

        }

        INET_ASSERT( BytesWritten == BufferLen );
    }


    _VirtualCacheFileSize += BufferLen;

#ifdef LAZY_WRITE
    INET_ASSERT(_VirtualCacheFileSize == (_RealCacheFileSize+_CacheScratchUsedLen));
#else
    INET_ASSERT(_VirtualCacheFileSize == (_RealCacheFileSize));
#endif

    dwError =  ERROR_SUCCESS;

bailout:

    DEBUG_PRINT( CACHE, INFO,
        ("WriteCache: _CacheFileSize=%d, inputsize=%d, dwError=%d\n",
        _VirtualCacheFileSize, BufferLen, dwError));

    return (dwError);
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::WriteToDisk(
    LPBYTE Buffer,
    DWORD BufferLen,
    LPDWORD lpdwBytesWritten
    )
{
    BOOL BoolError;

    BoolError = WriteFile(
                    _CacheFileHandle,
                    Buffer,
                    BufferLen,
                    lpdwBytesWritten,
                    NULL );
    if( !BoolError ) {
        return( GetLastError() );
    }

    _RealCacheFileSize += *lpdwBytesWritten;

    return (ERROR_SUCCESS);
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::EndCacheWrite(
    FILETIME    *lpftExpireTime,
    FILETIME    *lpftLastModifiedTime,
    FILETIME    *lpftPostCheckTime,
    DWORD       dwCacheEntryType,
    DWORD       dwHeaderLen,
    LPSTR       lpHeaderInfo,
    LPSTR       lpszFileExtension,
    BOOL        fImage
    )
{
    LPBYTE lpBuff;
    DWORD  dwBytesWritten, dwUsed;
    FILETIME ftCreate;

    DEBUG_ENTER((DBG_CACHE,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::EndCacheWrite",
                 "{%q} %#x, %#x,, %#x, %d, %d, %.32q",
                 _CacheUrlName,
                 lpftExpireTime,
                 lpftLastModifiedTime,
                 lpftPostCheckTime,
                 dwCacheEntryType,
                 dwHeaderLen,
                 lpHeaderInfo
                 ));

    DWORD Error = ERROR_NOT_SUPPORTED;

    INET_ASSERT( _CacheUrlName != NULL );
    INET_ASSERT( _CacheFileName != NULL );
    INET_ASSERT( _CacheReadInProgress == FALSE );
    INET_ASSERT( _CacheWriteInProgress == TRUE );
    INET_ASSERT( _CacheFileHandle != INVALID_HANDLE_VALUE );

    //
    // close the file.
    //

    if( _CacheFileHandle != INVALID_HANDLE_VALUE ) {

        GetFileTime( _CacheFileHandle, &ftCreate, NULL, NULL );
        
        CloseHandle( _CacheFileHandle );

        _CacheFileHandle = INVALID_HANDLE_VALUE;

    } else {

        DEBUG_PRINT(CACHE,
                    ERROR,
                    ("_CacheFileHandle = %x\n",
                    _CacheFileHandle
                    ));

    }

    if( _CacheFileHandleRead != INVALID_HANDLE_VALUE ) {
        CloseHandle( _CacheFileHandleRead );
        _CacheFileHandleRead = INVALID_HANDLE_VALUE;
    }

    //
    // Cache the file.
    //

    if( (_CacheUrlName != NULL) && (_CacheFileName != NULL) ) {

        //
        // if the cache file is successfully made, cache it, otherwise
        // mark it for deletion.
        //

        if( dwCacheEntryType == 0xffffffff ) {


            _fDeleteDataFile = TRUE;
        }

        if (!_fDeleteDataFile)
        {
            if (((GetHandleType() == TypeFtpConnectHandle) ||
                 (GetHandleType() == TypeFtpFileHandle) ||
                 (GetHandleType() == TypeFtpFileHandleHtml))
                 && IsPerUserItem())
            {
                char buff[256];
                DEBUG_PRINT(CACHE, 
                            INFO,
                            ("EndCacheWrite():FTP:PerUserItem = TRUE\n")
                            //("EndCacheWrite():PerUserItem = TRUE: <pConnect = 0x%x>.\n",pConnect)
                            );
                INET_ASSERT(vdwCurrentUserLen);

                // Store the total length to get copied to the args for AddUrl
                dwHeaderLen = sizeof(vszUserNameHeader) - 1
                                 + vdwCurrentUserLen
                                 + sizeof("\r\n");
                if (sizeof(buff) >= dwHeaderLen)
                {
                    memcpy(buff, vszUserNameHeader, sizeof(vszUserNameHeader) - 1);

                    DWORD dwSize = lstrlen(vszCurrentUser);
                    memcpy(&buff[sizeof(vszUserNameHeader) - 1],
                           vszCurrentUser,
                           dwSize);
                    dwSize += sizeof(vszUserNameHeader) - 1;
                    memcpy(&buff[dwSize], "\r\n", sizeof("\r\n"));

                    // Copy over to lpHeaderInfo which gets copied into the args for AddUrl
                    lpHeaderInfo = buff;
                    DEBUG_PRINT(CACHE, 
                                INFO,
                                ("EndCacheWrite():FTP: lpHeaderInfo = %q dwHeaderLen = %d\n",
                                lpHeaderInfo, dwHeaderLen)
                                );
                }
                else
                {
                    // if it failed, mark it as expired
/*
                    dwUserNameHeader = 0;
                    GetCurrentGmtTime(&_ftExpires);
                    *(LONGLONG *)&_ftExpires -= ONE_HOUR_DELTA;
*/              }
                                
            }
            else
            {
                DEBUG_PRINT(CACHE, 
                            INFO,
                            ("EndCacheWrite():FTP:PerUserItem = FALSE\n")
                            );

            }
        
            AddUrlArg Args;
            memset(&Args, 0, sizeof(Args));
            Args.pszUrl      = _CacheUrlName;
            Args.pszFilePath = _CacheFileName;
            Args.dwFileSize  = _RealCacheFileSize;
            Args.qwExpires   = *((LONGLONG*)lpftExpireTime);
            Args.qwLastMod   = *((LONGLONG*)lpftLastModifiedTime);
            Args.qwPostCheck = *((LONGLONG*)lpftPostCheckTime);
            Args.ftCreate    = ftCreate;
            Args.dwEntryType = dwCacheEntryType;
            Args.pbHeaders   = lpHeaderInfo;
            Args.cbHeaders   = dwHeaderLen;
            Args.pszFileExt  = lpszFileExtension;
            Args.pszRedirect = _OriginalUrl;
            Args.fImage      = fImage;
            Args.dwIdentity  = IsPerUserItem() ? GlobalIdentity : 0;
            
            Error = UrlCacheCommitFile(&Args);

            if (Error != ERROR_SUCCESS)
            {
                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("CommitUrlCacheEntry(%q) failed\n",
                            _CacheUrlName
                            ));

                _fDeleteDataFile = TRUE;

                if (Error == ERROR_SHARING_VIOLATION) {

                    // we got new URL data, but the old one is in use.
                    // expire it, so any new user's will go to the net

                    ExpireUrl();

                }
            }
        }
    }

    _CacheWriteInProgress = FALSE;

    DEBUG_LEAVE(Error);

    return( Error );
}

BOOL
INTERNET_CONNECT_HANDLE_OBJECT::ExpireDependents(VOID
    )
{
    char szUrlParent[INTERNET_MAX_URL_LENGTH];
    BOOL fRet = FALSE;

    ExpireUrl();

    if (GetCanonicalizedParentUrl( _CacheUrlName,
                                       szUrlParent,
                                       sizeof(szUrlParent))){

        ExpireUrl(szUrlParent);

        fRet = TRUE;

    }
    return(fRet);

}


#ifdef LAZY_WRITE

LPBYTE
INTERNET_CONNECT_HANDLE_OBJECT::GetCacheScratchBuf(
    LPDWORD Length, LPDWORD lpdwUsed
    )
/*++

Routine Description:

    Get existing scratch buffer for use.

Arguments:

    Length : pointer to a location where the buffer length is returned.

Return Value:

    return scratch buffer pointer.

--*/
{
    //
    // no one else is using this buffer.
    //


    if(( _CacheScratchBuf != NULL )||(Length==NULL)) {


        INET_ASSERT(!((_CacheScratchBuf == NULL)&&(_CacheScratchUsedLen != 0)));

        if (Length) {

            *Length = _CacheScratchBufLen;

        }

        *lpdwUsed = _CacheScratchUsedLen;

        return( _CacheScratchBuf );
    }

    INET_ASSERT( _CacheScratchBufLen == 0 );

    //
    // create a default buffer.
    //

    *lpdwUsed = _CacheScratchUsedLen = 0;

    _CacheScratchBufLen = dwCacheWriteBufferSize;    //  default size;

    INET_ASSERT(dwCacheWriteBufferSize >= 4096);

    _CacheScratchBuf = (LPBYTE)ALLOCATE_MEMORY(LMEM_FIXED | LMEM_ZEROINIT,
                                          _CacheScratchBufLen
                                          );

    if( _CacheScratchBuf == NULL ) {

        //
        // we couldn't make one.
        //

        _CacheScratchBufLen = 0;


        *Length = 0;

        return( NULL );
    }

    *Length = _CacheScratchBufLen;

    return( _CacheScratchBuf );
}

#endif // LAZY_WRITE

BOOL
GetCanonicalizedParentUrl(
    LPSTR   lpszChildUrl,
    LPSTR   lpszParentUrlBuff,
    DWORD   dwBuffSize)
{

    char szUrlT[INTERNET_MAX_URL_LENGTH];
    LPSTR lpT;
    BOOL fRet = FALSE;
    DWORD dwT = dwBuffSize;

    if(lstrlen(lpszChildUrl) >= sizeof(szUrlT) / sizeof(szUrlT[0]))
	{
		INET_ASSERT(FALSE);
		return FALSE;
	}

	lstrcpy(szUrlT, lpszChildUrl);

    lpT = szUrlT+lstrlen(szUrlT);

    if ( lpT > szUrlT ) {

        --lpT;
        if (*lpT == '/') {
            --lpT;
        }

        for(; lpT >= szUrlT; --lpT){

            if (*lpT == '/') {

                *(lpT+1) = 0;

                if(InternetCanonicalizeUrl(szUrlT, lpszParentUrlBuff, &dwT, 0)) {

                    fRet = TRUE;

                }

                goto done;
            }

        }
    }

done:

    return (fRet);

}


VOID
INTERNET_CONNECT_HANDLE_OBJECT::AttachLastResponseInfo(
    VOID
    )

/*++

Routine Description:

    Called when we are performing an FTP URL operation & we want to display
    the welcome message contained in the last response info as part of the
    generated HTML. We need to keep hold of it in this object in case the
    app calls an API which wipes out the last response info before getting
    the HTML data

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSTR buffer = NULL;
    DWORD bufferLength = 0;
    DWORD category;
    BOOL ok = InternetGetLastResponseInfo(&category,
                                          buffer,
                                          &bufferLength
                                          );
    if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        buffer = (LPSTR)ResizeBuffer(NULL, bufferLength, FALSE);
        if (buffer != NULL) {
            ok = InternetGetLastResponseInfo(&category,
                                             buffer,
                                             &bufferLength
                                             );
            if (ok) {
                SetLastResponseInfo(buffer, bufferLength);
            } else {
                (void)ResizeBuffer((HLOCAL)buffer, 0, FALSE);
            }
        }
    }
}


VOID
INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer(
    IN CServerInfo * pServerInfo,
    IN BOOL fForceUpdate  /* = FALSE */
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pServerInfo -

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer",
                 "%#x{%q}",
                 pServerInfo,
                 pServerInfo ? pServerInfo->GetHostName() : ""
                 ));

    if (_OriginServer == NULL || fForceUpdate) {
        if (_OriginServer) {
            _OriginServer->Dereference();
        }
        _OriginServer = pServerInfo;
        if (pServerInfo != NULL) {
            pServerInfo->Reference();
        }
    }

    DEBUG_LEAVE(0);
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(
    IN INTERNET_SCHEME tScheme,
    IN BOOL bDoResolution,
    IN OPTIONAL BOOL fNtlm
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name for which this object was created and an optional scheme
    type

Arguments:

    tScheme         - scheme type we want SERVER_INFO for

    bDoResolution   - TRUE if we are to resolve the host name if creating a new
                      SERVER_INFO object

    fNtlm           - TRUE if we are tunnelling for NTLM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%s (%d), %B, %B",
                 InternetMapScheme(tScheme),
                 tScheme,
                 bDoResolution,
                 fNtlm
                 ));

    //INTERNET_SCHEME proxyScheme = INTERNET_SCHEME_DEFAULT;
    //INTERNET_HANDLE_OBJECT * lpParent = (INTERNET_HANDLE_OBJECT *)GetParent();
    //
    //INET_ASSERT(lpParent != NULL);
    //
    ////
    //// this may be called from an INTERNET_CONNECT_HANDLE_OBJECT within a
    //// derived handle (HTTP_REQUEST_HANDLE_OBJECT), in which case we need to go
    //// one level higher to the INTERNET_HANDLE_OBJECT
    ////
    //
    //if (lpParent->GetHandleType() != TypeInternetHandle) {
    //    lpParent = (INTERNET_HANDLE_OBJECT *)lpParent->GetParent();
    //
    //    INET_ASSERT(lpParent != NULL);
    //    INET_ASSERT(lpParent->GetHandleType() == TypeInternetHandle);
    //
    //}

    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

//dprintf("getting server info for %q (current = %q)\n", hostName, GetHostName());
    DWORD error = ::GetServerInfo(GetHostName(),
                                  _ServiceType,
                                  bDoResolution,
                                  &_ServerInfo
                                  );

    ////
    //// if _ServerInfo is NULL then we didn't find a SERVER_INFO and couldn't
    //// create one, therefore we must be out of memory
    ////
    //
    //if (_ServerInfo != NULL) {
    //    if (proxyScheme == INTERNET_SCHEME_HTTP) {
    //        _ServerInfo->SetCernProxy();
    //    } else if (proxyScheme == INTERNET_SCHEME_FTP) {
    //        _ServerInfo->SetFTPProxy();
    //    }
    //
    //    INET_ASSERT(error == ERROR_SUCCESS);
    //
    //} else {
    //
    //    INET_ASSERT(error != ERROR_SUCCESS);
    //
    //}

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo(
    IN LPSTR lpszServerName,
    IN DWORD dwServerNameLength
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name in the parameters

Arguments:

    lpszServerName      - name of server

    dwServerNameLength  - length of lpszServerName

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%q, %d",
                 lpszServerName,
                 dwServerNameLength
                 ));

    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

    char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    int copyLength = (int)min(sizeof(hostName) - 1, dwServerNameLength);

    memcpy(hostName, lpszServerName, copyLength);
    hostName[copyLength] = '\0';

    DWORD error = ::GetServerInfo(hostName,
                                  _ServiceType,
                                  FALSE,
                                  &_ServerInfo
                                  );

    DEBUG_LEAVE(error);

    return error;
}

BOOL INTERNET_CONNECT_HANDLE_OBJECT::GetUserAndPass (BOOL fProxy, LPSTR *pszUser, LPSTR *pszPass)
{
    // How the credentials (username + password) are retrieved from handles during
    // authentication (see AuthOnRequest)
    //
    //             Connect      Request
    //  Server        4     <-     3
    //  Proxy         2     <-     1
    //
    //
    //
    // When credentials are transferred from the handle to the password cache, they
    // are invalidated on the handle for internal calls from wininet so that they
    // are not inadvertently used therafter. The handle credentials are maintained
    // for external apps which expect these values to be available via InternetQueryOption.
    // When GetUserAndPass is called, if a credential is found on the handle its validity is
    // checked for internal calls. If no credential is found or the credential is no longer
    // valid GetUserAndPass is called recursively on the parent connect handle if it exists.
    //
    // When transferring credentials from a handle to the password cache it is IMPORTANT
    // GetUserAndPass is called to invalidate the credentials. The credentials (both username
    // and password) are re-validated as a pair if either of them is reset via SetUserOrPass.

    if (fProxy)
    {
        // If proxy credentials are valid and exist invalidate and return.
        if (_HandleFlags.fProxyUserPassValid
            && _pwcProxyCreds
            && _pwcProxyCreds->lpszUser
            && _pwcProxyCreds->lpszPass)
        {
            *pszUser = _pwcProxyCreds->GetUser();
            *pszPass = _pwcProxyCreds->GetPass();
            _HandleFlags.fProxyUserPassValid = FALSE;
            return TRUE;
        }
    }
    else
    {
        // If server credentials are valid and exist, invalidate and return.
        if (_HandleFlags.fServerUserPassValid
            && _pwcServerCreds
            && _pwcServerCreds->lpszUser
            && _pwcServerCreds->lpszPass)
        {
            *pszUser = _pwcServerCreds->GetUser();
            *pszPass = _pwcServerCreds->GetPass();
            _HandleFlags.fServerUserPassValid = FALSE;
            return TRUE;
        }
    }


    // Either credentials not found or are invalid on this handle.
    // Walk up to any existing connect handle and repeat call.
    if (GetHandleType() == TypeHttpRequestHandle)
    {
        INTERNET_CONNECT_HANDLE_OBJECT * pConnect =
            (INTERNET_CONNECT_HANDLE_OBJECT *) GetParent();

        return pConnect->GetUserAndPass (fProxy, pszUser, pszPass);
    }

    // Connect handle returns FALSE and null values if none/invalid.
    *pszUser = *pszPass = NULL;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\hinet.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hinet.cxx

Abstract:

    contains methods for INTERNET_HANDLE_OBJECT class

    Contents:
        ContainingHandleObject
        CancelActiveSyncRequests
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::Reference()
        HANDLE_OBJECT::Dereference()
        HANDLE_OBJECT::IsValid()
        INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(LPCSTR, ...)
        INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(INTERNET_HANDLE_OBJECT*)
        INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT()
        INTERNET_HANDLE_OBJECT::SetAbortHandle(ICSocket)
        INTERNET_HANDLE_OBJECT::ResetAbortHandle()
        INTERNET_HANDLE_OBJECT::AbortSocket()
        INTERNET_HANDLE_OBJECT::CheckGlobalProxyUpdated()
        INTERNET_HANDLE_OBJECT::SetProxyInfo()
        INTERNET_HANDLE_OBJECT::GetProxyInfo(LPVOID, LPDWORD)
        INTERNET_HANDLE_OBJECT::GetProxyInfo(INTERNET_SCHEME, LPINTERNET_SCHEME, LPSTR *, LPDWORD, LPINTERNET_PORT)

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "autodial.h"

//
// private manifests
//

#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// functions
//


HANDLE_OBJECT *
ContainingHandleObject(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of containing HANDLE_OBJECT from address of _List member

Arguments:

    lpAddress   - address of _List in this object

Return Value:

    HANDLE_OBJECT *

--*/

{
    return CONTAINING_RECORD(lpAddress, HANDLE_OBJECT, _List);
}


VOID
CancelActiveSyncRequests(
    IN DWORD dwError
    )

/*++

Routine Description:

    For all currently active synchronous requests, cancels them with the error
    code supplied

Arguments:

    dwError - error code to complete requests

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                 None,
                 "CancelActiveSyncRequests",
                 "%s",
                 InternetMapError(dwError)
                 ));

    LockSerializedList(&GlobalObjectList);

    for (PLIST_ENTRY pEntry = (PLIST_ENTRY)HeadOfSerializedList(&GlobalObjectList);
         pEntry != (PLIST_ENTRY)SlSelf(&GlobalObjectList);
         pEntry = pEntry->Flink) {

        HANDLE_OBJECT * pObject = ContainingHandleObject(pEntry);
        HINTERNET_HANDLE_TYPE objectType = pObject->GetObjectType();

        //
        // check handle types in decreasing order of expectation for IE
        //

        if ((objectType == TypeHttpRequestHandle)
        || (objectType == TypeFtpFindHandleHtml)
        || (objectType == TypeFtpFindHandle)
        || (objectType == TypeFtpFileHandle)
        || (objectType == TypeGopherFindHandleHtml)
        || (objectType == TypeGopherFindHandle)
        || (objectType == TypeGopherFileHandle)) {

            //
            // all these handle types are descended from INTERNET_HANDLE_OBJECT
            // which in turn is descended from HANDLE_OBJECT
            //

            if (!((INTERNET_HANDLE_OBJECT *)pObject)->IsAsyncHandle()) {

                //
                // sync request
                //

                DEBUG_PRINT(INET,
                            INFO,
                            ("cancelling %s sync request on handle %#x (%#x) \n",
                            InternetMapHandleType(objectType),
                            pObject->GetPseudoHandle(),
                            pObject
                            ));

                pObject->InvalidateWithError(dwError);
            }
        }
    }

    UnlockSerializedList(&GlobalObjectList);

    DEBUG_LEAVE(0);
}

//
// methods
//


HANDLE_OBJECT::HANDLE_OBJECT(
    IN HANDLE_OBJECT * Parent
    )

/*++

Routine Description:

    HANDLE_OBJECT constructor

Arguments:

    Parent  - pointer to parent HANDLE_OBJECT

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "HANDLE_OBJECT",
                "%#x",
                this
                ));

    //InitializeListHead(&_List);
    InitializeSerializedList(&_Children);
    //InitializeListHead(&_Siblings);
    _Parent = Parent;
    if (_Parent != NULL) {
        _Parent->AddChild(&_Siblings);
    } else {
        InitializeListHead(&_Siblings);
    }
    _DeleteWithChild = FALSE;
    _Status = AllocateHandle(this, &_Handle);
    _ObjectType = TypeGenericHandle;
    _ReferenceCount = 1;
    _Invalid = FALSE;
    _Error = ERROR_SUCCESS;
    _Signature = OBJECT_SIGNATURE;
    _Context = INTERNET_NO_CALLBACK;
    InsertAtTailOfSerializedList(&GlobalObjectList, &_List);

    //
    // if AllocateHandle() failed then we cannot create this handle object.
    // Invalidate it ready for the destructor
    //

    if (_Status != ERROR_SUCCESS) {
        _Invalid = TRUE;
        _ReferenceCount = 0;
    }

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x created; address %#x; %d objects\n",
                _Handle,
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


HANDLE_OBJECT::~HANDLE_OBJECT(VOID)

/*++

Routine Description:

    HANDLE_OBJECT destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // remove this object from global object list
    //

    LockSerializedList(&GlobalObjectList);
    RemoveFromSerializedList(&GlobalObjectList, &_List);
    if (IsSerializedListEmpty(&GlobalObjectList)) {
        OnLastHandleDestroyed();
    }
    UnlockSerializedList(&GlobalObjectList);

    INET_DEBUG_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    //
    // inform the app that this handle is completely closed, but only if we
    // can make callbacks at all
    //

    if (_Context != INTERNET_NO_CALLBACK) {

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        HINTERNET hCurrent = _InternetGetObjectHandle(lpThreadInfo);
        HINTERNET hCurrentMapped = _InternetGetMappedObjectHandle(lpThreadInfo);
        DWORD_PTR currentContext = _InternetGetContext(lpThreadInfo);

        _InternetSetObjectHandle(lpThreadInfo, _Handle, (HINTERNET)this);
        _InternetSetContext(lpThreadInfo, _Context);

        InternetIndicateStatus(INTERNET_STATUS_HANDLE_CLOSING,
                               (LPVOID)&_Handle,
                               sizeof(_Handle)
                               );

        _InternetSetObjectHandle(lpThreadInfo, hCurrent, hCurrentMapped);
        _InternetSetContext(lpThreadInfo, currentContext);
    } else {

        DEBUG_PRINT(OBJECTS,
                    WARNING,
                    ("handle %#x [%#x] no context: no callback\n",
                    _Handle,
                    this
                    ));

    }

    //
    // remove object from parent's child list (if we have a parent object)
    //

    if (_Parent != NULL) {
        _Parent->RemoveChild(&_Siblings);

        INET_DEBUG_ASSERT((_Siblings.Flink == NULL) && (_Siblings.Blink == NULL));

    }

    //
    // now we can free up the API handle value
    //

    if (_Handle != NULL) {
        _Status = FreeHandle(_Handle);

        INET_ASSERT(_Status == ERROR_SUCCESS);

    }

    //
    // there should be no child objects
    //

    INET_ASSERT(IsSerializedListEmpty(&_Children));

    TerminateSerializedList(&_Children);

    //
    // set the signature to a value that indicates the handle has been
    // destroyed (not useful in debug builds)
    //

    _Signature = DESTROYED_OBJECT_SIGNATURE;

    INET_ASSERT((_ReferenceCount == 0) && _Invalid);

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x destroyed; type %s; address %#x; %d objects\n",
                _Handle,
                InternetMapHandleType(_ObjectType),
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


DWORD
HANDLE_OBJECT::Reference(
    VOID
    )

/*++

Routine Description:

    Increases the reference count on the HANDLE_OBJECT

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Handle has already been invalidated
                  ERROR_ACCESS_DENIED
                    Handle object is being destroyed, cannot use it

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "HANDLE_OBJECT::Reference",
                 "{%#x}",
                 _Handle
                 ));

    DWORD error;

    if (_Invalid) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("handle object %#x [%#x] is invalid\n",
                    _Handle,
                    this
                    ));

        error = ERROR_INVALID_HANDLE;
    } else {
        error = ERROR_SUCCESS;
    }

    //
    // even if the handle has been invalidated (i.e. closed), we allow it
    // to continue to be referenced. The caller should return the fact
    // that the handle has been invalidated, but may require information
    // from the object in order to do so (e.g. in async thread)
    //

    do
    {
        LONG lRefCountBeforeIncrement = _ReferenceCount;

        //
        // refcount is > 0 means that the object's destructor has not been called yet
        //
        if (lRefCountBeforeIncrement > 0)
        {
            //
            // try to increment the refcount using compare-exchange
            //
#ifndef _WIN64
            LONG lRefCountCurrent = (LONG)SHInterlockedCompareExchange((LPVOID*)&_ReferenceCount,
                                                                       (LPVOID)(lRefCountBeforeIncrement + 1),
                                                                       (LPVOID)lRefCountBeforeIncrement);
#else
            //
            // can't use SHInterlockedCompareExchange on win64 because the values are really LONG's (32-bits) but they
            // are treated as pointers (64-bits) because SHInterlockedCompareExchange should really be called 
            // SHInterlockedCompareExchangePointer (sigh...).
            //
            LONG lRefCountCurrent = InterlockedCompareExchange(&_ReferenceCount,
                                                               lRefCountBeforeIncrement + 1,
                                                               lRefCountBeforeIncrement);
#endif        
            if (lRefCountCurrent == lRefCountBeforeIncrement)
            {
                //
                // since SHInterlockedCompareExchange returns the value in _ReferenceCount 
                // before the exchange, we know the exchange sucessfully took place (i.e. we 
                // sucessfully incremented the refrence count of the object by one)
                //
                INET_ASSERT(lRefCountCurrent > 0);
                break;
            }
        }
        else
        {
            //
            // the refcount dropped to zero before we could increment it,
            // so the object is being destroyed. 
            //
            error = ERROR_ACCESS_DENIED;
            break;
        }

    } while (TRUE);

    DEBUG_PRINT(REFCOUNT,
                INFO,
                ("handle object %#x [%#x] ReferenceCount = %d\n",
                _Handle,
                this,
                _ReferenceCount
                ));

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HANDLE_OBJECT::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count on the HANDLE_OBJECT, and if it goes to zero,
    the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - this object was deleted

        FALSE   - this object is still valid

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Bool,
                 "HANDLE_OBJECT::Dereference",
                 "{%#x}",
                 _Handle
                 ));

    //
    // by the time we get here, the reference count should not be 0. There
    // should be 1 call to Dereference() for each call to Reference()
    //

    INET_ASSERT(_ReferenceCount != 0);

    BOOL deleted = FALSE;

    if (InterlockedDecrement(&_ReferenceCount) == 0)
    {
        deleted = TRUE;
    }


    if (deleted)
    {
        //
        // if we are calling the destructor, the handle had better be invalid!
        //
        INET_ASSERT(_Invalid);
        
        //
        // this handle has now been closed. If there is no activity on it
        // then it will be destroyed
        //

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));

        delete this;
    } else {

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));
    }

    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD
HANDLE_OBJECT::IsValid(
    IN HINTERNET_HANDLE_TYPE ExpectedHandleType
    )

/*++

Routine Description:

    Checks a HANDLE_OBJECT for validity

Arguments:

    ExpectedHandleType  - type of object we are testing for. Can be
                          TypeWildHandle which matches any valid handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    The handle object is invalid

                  ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    The handle object is valid, but not the type we want

--*/

{
    DWORD error;
    BOOL IsOkHandle = TRUE;

    //
    // test handle object within try..except in case we are given a bad address
    //

    __try {
        if (_Signature == OBJECT_SIGNATURE) {

            error = ERROR_SUCCESS;

            //
            // check handle type if we are asked to do so.
            //

            if (ExpectedHandleType != TypeWildHandle) {
                if (ExpectedHandleType != this->GetHandleType()) {
                    error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
                }
            }
        } else {
            error = ERROR_INVALID_HANDLE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_HANDLE;
    }
    ENDEXCEPT
    return error;
}


INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(
    LPCSTR UserAgent,
    DWORD AccessMethod,
    LPSTR ProxyServerList,
    LPSTR ProxyBypassList,
    DWORD Flags
    ) : HANDLE_OBJECT(NULL)

/*++

Routine Description:

    Creates the handle object for InternetOpen()

Arguments:

    UserAgent       - name of agent (user-agent string for HTTP)

    AccessMethod    - DIRECT, PROXY or PRECONFIG

    ProxyServerList - one or more proxy servers. The string has the form:

                        [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

    ProxyBypassList - zero or more addresses which if matched will result in
                      requests NOT going via the proxy (only if PROXY access).
                      The string has the form:

                        bp_entry ::= [<scheme>"://"]<server>[":"<port>]
                        bp_macro ::= "<local>"
                        bp_list ::= [<> | bp_entry bp_macro][";"*]

    Flags           - various open flags:

                        INTERNET_FLAG_ASYNC

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT",
                 NULL
                 ));


    //
    // if the HANDLE_OBJECT constructor failed then bail out now
    //

    if (_Status != ERROR_SUCCESS) {

        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("early-exit: _Status = %d\n",
                    _Status
                    ));

        DEBUG_LEAVE(0);

        return;
    }

    //
    // BUGBUG - remove _INetHandle
    //
    _fExemptConnLimit = FALSE;

    if (GlobalPlatformWhistler)
    {
        _fDisableTweener = FALSE; // Tweener (Passport1.4 is enabled by default for Windows XP)
    }
    else
    {
        _fDisableTweener = TRUE; // by default disable Tweener for downlevels
    }

    _PPContext = 0;

    _INetHandle = INET_INVALID_HANDLE_VALUE;

    _IsCopy = FALSE;
    _UserAgent = (LPSTR)UserAgent;
    _ProxyInfo = NULL;
    _dwInternetOpenFlags = Flags;
    _WinsockLoaded = FALSE;

    //
    // BUGBUG - post-beta: move to HANDLE_OBJECT
    //

    _Context = INTERNET_NO_CALLBACK;

    //
    // initialize the timeout/retry values for this object from the
    // global (DLL) values
    //

    _ConnectTimeout = GlobalConnectTimeout;
    _ConnectRetries = GlobalConnectRetries;
    _SendTimeout = GlobalSendTimeout;
    _DataSendTimeout = GlobalDataSendTimeout;
    _ReceiveTimeout = GlobalReceiveTimeout;
    _DataReceiveTimeout = GlobalDataReceiveTimeout;
    _FromCacheTimeout = GlobalFromCacheTimeout;
    _SocketSendBufferLength = GlobalSocketSendBufferLength;
    _SocketReceiveBufferLength = GlobalSocketReceiveBufferLength;

    //
    // set _Async based on the INTERNET_FLAG_ASYNC supplied to InternetOpen()
    //

    _Async = (Flags & INTERNET_FLAG_ASYNC) ? TRUE : FALSE;

    //
    // no data available yet
    //

    SetAvailableDataLength(0);

    //
    // not yet end of file
    //

    ResetEndOfFile();

    //
    // no status callback by default
    //

    _StatusCallback = NULL;
    _StatusCallbackType = FALSE;

    //
    // the number of pending async requests is 0. The clash test variable is
    // used to test for ownership using InterlockedIncrement()
    //

    //
    // BUGBUG - RLF 03/16/98. See hinet.hxx
    //

    //_PendingAsyncRequests = 0;
    //_AsyncClashTest = -1;

    InitializeCriticalSection(&_UiCritSec);
    _dwUiBlocked = FALSE;
    SetObjectType(TypeInternetHandle);

    _ProxyInfoResourceLock.Initialize();

    _Status = SetProxyInfo(AccessMethod, ProxyServerList, ProxyBypassList);

    //
    // if _pICSocket is not NULL then this is the socket that this object handle
    // is currently working on. We close it to cancel the operation
    //

    _pICSocket = NULL;

    //
    // load winsock now. We always want to go via winsock since the demise of
    // catapult
    //

    if (_Status == ERROR_SUCCESS) {
        _INetHandle = LOCAL_INET_HANDLE;
        _Status = LoadWinsock();
        _WinsockLoaded = (_Status == ERROR_SUCCESS);

        if ( _Status == ERROR_SUCCESS )
        {
             LONG lOpenHandleCnt;

             LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

             if ( lpThreadInfo && ! lpThreadInfo->IsAutoProxyProxyThread )
             {
                 lOpenHandleCnt = InterlockedIncrement((LPLONG)&GlobalInternetOpenHandleCount);

                 if ( lOpenHandleCnt == 0 )
                 {
                    DWORD fAlreadyInInit = (DWORD) InterlockedExchange((LPLONG) &GlobalAutoProxyInInit, TRUE);

                    INET_ASSERT (! fAlreadyInInit );

                    GlobalProxyInfo.ReleaseQueuedRefresh();

                    InterlockedExchange((LPLONG)&GlobalAutoProxyInInit, FALSE);
                 }
             }
        
            // Passport's implementation is Sync and therefore only Sync session can be re-used.        
            /*
            if (!IsAsyncHandle())
            {
                _PPContext = ::PP_InitContext(L"WinInet.Dll", GetPseudoHandle());
            }
            */
        }
    }

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT(
    INTERNET_HANDLE_OBJECT *INetObj
    ) : HANDLE_OBJECT((HANDLE_OBJECT*)INetObj)

/*++

Routine Description:

    Constructor for derived handle object. We are creating this handle as part
    of an INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    INetObj - pointer to INTERNET_HANDLE_OBJECT to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT",
                 "{IsCopy}"
                 ));

    _PPContext = INetObj->_PPContext;
    _fDisableTweener = INetObj->_fDisableTweener;
    _fExemptConnLimit = INetObj->_fExemptConnLimit;

    _INetHandle = INetObj->_INetHandle;
    _IsCopy = TRUE;

    //
    // copy user agent string
    //

    //
    // BUGBUG - compiler generated copy constructor (no new string)
    //

    _UserAgent = INetObj->_UserAgent;

    //
    // do not inherit the proxy info - code must go to parent handle
    //

    _ProxyInfo = NULL;

    _dwInternetOpenFlags = INetObj->_dwInternetOpenFlags;

    //
    // creating this handle didn't load winsock
    //

    _WinsockLoaded = FALSE;

    //
    // inherit the context, timeout values, async flag and status callback from
    // the parent object handle
    //

    _Context = INetObj->_Context;

    _ConnectTimeout = INetObj->_ConnectTimeout;
    _ConnectRetries = INetObj->_ConnectRetries;
    _SendTimeout = INetObj->_SendTimeout;
    _DataSendTimeout = INetObj->_DataSendTimeout;
    _ReceiveTimeout = INetObj->_ReceiveTimeout;
    _DataReceiveTimeout = INetObj->_DataReceiveTimeout;
    _FromCacheTimeout = INetObj->_FromCacheTimeout;

    //
    // inherit the async I/O mode and callback function
    //

    _Async = INetObj->_Async;
    SetAvailableDataLength(0);
    ResetEndOfFile();
    _StatusCallback = INetObj->_StatusCallback;
    _StatusCallbackType = INetObj->_StatusCallbackType;

    //
    // this is a new object: we need a new pending async request count and clash
    // test variable
    //

    //
    // BUGBUG - RLF 03/16/98. See hinet.hxx
    //

    //_PendingAsyncRequests = 0;
    //_AsyncClashTest = -1;

    //
    // no socket operation to abort yet
    //

    _pICSocket = NULL;

    //
    // BUGBUG - this overwrites status set above?
    //

    _Status = INetObj->_Status;
    _dwUiBlocked = FALSE;

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT(
    VOID
    )

/*++

Routine Description:

    INTERNET_HANDLE_OBJECT destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT",
                 ""
                 ));

    //
    // if this handle is not a copy then delete proxy information if we are not
    // using the global proxy info, and unload the sockets package if we loaded
    // it in the first place
    //


    if (!IsCopy()) {

        if (_PPContext)
        {
            ::PP_FreeContext(_PPContext);
        }

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Not a Copy...\n"
                    ));

        DeleteCriticalSection(&_UiCritSec);

        if (IsProxy()) {

            DEBUG_PRINT(OBJECTS,
                        INFO,
                        ("A Proxy is enabled\n"
                        ));


            if (!IsProxyGlobal()) {

                DEBUG_PRINT(OBJECTS,
                            INFO,
                            ("Free-ing ProxyInfo\n"
                            ));

                delete _ProxyInfo;
                _ProxyInfo = NULL;
            }
        }

        //
        // don't unload winsock. There really is no need to unload separately
        // from process detach and if we do unload, we first have to terminate
        // async support. Dynaloading and unloading winsock is vestigial
        //

        //if (_WinsockLoaded) {
        //    UnloadWinsock();
        //}

//        if ( _Status == ERROR_SUCCESS )
//        {
//             LONG lOpenHandleCnt;
//
//             LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//
//             if ( lpThreadInfo && ! lpThreadInfo->IsAutoProxyProxyThread )
//             {
//                 lOpenHandleCnt = InterlockedDecrement((LPLONG)&GlobalInternetOpenHandleCount);
//
//                 if ( lOpenHandleCnt < 0 )
//                 {
//                     GlobalProxyInfo.FreeAutoProxyInfo();                     
//                     GlobalProxyInfo.SetRefreshDisabled(TRUE);
//                 }
//             }
//        }
    }

    DEBUG_LEAVE(0);
}

HINTERNET
INTERNET_HANDLE_OBJECT::GetInternetHandle(
    VOID
    )
{
    return _INetHandle;
}

HINTERNET
INTERNET_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _INetHandle;
}

VOID
INTERNET_HANDLE_OBJECT::SetTimeout(
    IN DWORD TimeoutOption,
    IN DWORD TimeoutValue
    )
{
    switch (TimeoutOption) {
    case INTERNET_OPTION_SEND_TIMEOUT:
        _SendTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_RECEIVE_TIMEOUT:
        _ReceiveTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
        _DataSendTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
        _DataReceiveTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_CONNECT_TIMEOUT:
        _ConnectTimeout = TimeoutValue;
        break;

    case INTERNET_OPTION_CONNECT_RETRIES:
        _ConnectRetries = TimeoutValue;
        break;

    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        _FromCacheTimeout = TimeoutValue;
        break;
    }
}

DWORD
INTERNET_HANDLE_OBJECT::GetTimeout(
    IN DWORD TimeoutOption
    )
{
    switch (TimeoutOption) {
    case INTERNET_OPTION_SEND_TIMEOUT:
        return _SendTimeout;

    case INTERNET_OPTION_RECEIVE_TIMEOUT:
        return _ReceiveTimeout;

    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
        return _DataSendTimeout;

    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
        return _DataReceiveTimeout;

    case INTERNET_OPTION_CONNECT_TIMEOUT:
        return _ConnectTimeout;

    case INTERNET_OPTION_CONNECT_RETRIES:
        return _ConnectRetries;

    case INTERNET_OPTION_CONNECT_BACKOFF:
        return 0;   // Backoff no longer used

    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        return _FromCacheTimeout;

    case INTERNET_OPTION_LISTEN_TIMEOUT:

        //
        // BUGBUG - not per-object
        //

        return GlobalFtpAcceptTimeout;
    }

    INET_ASSERT(FALSE);

    //
    // we should not be here, but in case we are, return a random timeout
    //

    return DEFAULT_CONNECT_TIMEOUT;
}

//VOID INTERNET_HANDLE_OBJECT::AcquireAsyncSpinLock(VOID) {
//
//    //
//    // wait until we're the exclusive owner of the async info
//    //
//
//    while (TRUE) {
//        if (InterlockedIncrement(&_AsyncClashTest) == 0) {
//            return;
//        } else {
//            InterlockedDecrement(&_AsyncClashTest);
//            Sleep(0);
//        }
//    }
//}
//
//VOID INTERNET_HANDLE_OBJECT::ReleaseAsyncSpinLock(VOID) {
//    InterlockedDecrement(&_AsyncClashTest);
//}

DWORD
INTERNET_HANDLE_OBJECT::ExchangeStatusCallback(
    LPINTERNET_STATUS_CALLBACK lpStatusCallback,
    BOOL fType
    )
{
    DWORD error;

    //
    // we can only change the status callback if there are no async requests
    // pending
    //

    //AcquireAsyncSpinLock();

    //
    // BUGBUG - RFirth 03/16/98 - _PendingAsyncRequests is no longer being
    //          updated. It is always 0, hence always safe to change. Since
    //          no-one (that we know of) does this, we can let it go for
    //          now, but it needs to be fixed by RTM
    //
    //          (R)AddAsyncRequest() and (R)RemoveAsyncRequest() have been
    //          commented-out until this is fixed
    //

    //if (_PendingAsyncRequests == 0) {

        INTERNET_STATUS_CALLBACK callback;

        //
        // exchange new and current callbacks
        //

        callback = _StatusCallback;
        _StatusCallback = *lpStatusCallback;
        *lpStatusCallback = callback;
        _StatusCallbackType = fType;
        error = ERROR_SUCCESS;
    //} else {
    //    error = ERROR_INTERNET_REQUEST_PENDING;
    //}
    //
    //ReleaseAsyncSpinLock();

    return error;
}

//DWORD INTERNET_HANDLE_OBJECT::AddAsyncRequest(BOOL fNoCallbackOK) {
//    DWORD error;
//
//    AcquireAsyncSpinLock();
//
//    if (fNoCallbackOK || _StatusCallback != NULL) {
//        ++_PendingAsyncRequests;
//
//        INET_ASSERT(_PendingAsyncRequests > 0);
//
//        error = ERROR_SUCCESS;
//    } else {
//
//        INET_ASSERT(_PendingAsyncRequests == 0);
//
//        error = ERROR_INTERNET_NO_CALLBACK;
//    }
//
//    ReleaseAsyncSpinLock();
//
//    return error;
//}
//
//VOID INTERNET_HANDLE_OBJECT::RemoveAsyncRequest(VOID) {
//
//    INET_ASSERT(_PendingAsyncRequests > 0);
//
//    InterlockedDecrement(&_PendingAsyncRequests);
//}


VOID
INTERNET_HANDLE_OBJECT::SetAbortHandle(
    IN ICSocket * Socket
    )

/*++

Routine Description:

    Associates with this request handle the ICSocket object currently being used
    for network I/O

Arguments:

    Socket  - pointer to ICSocket

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_OBJECT::SetAbortHandle",
                 "{%#x} %#x [sock=%#x ref=%d]",
                 GetPseudoHandle(),
                 Socket,
                 Socket ? Socket->GetSocket() : 0,
                 Socket ? Socket->ReferenceCount() : 0
                 ));

    INET_ASSERT(Socket != NULL);

    //
    // first off, increase the socket reference count to stop any other threads
    // killing it whilst we are performing the socket operation. The only way
    // another thread can dereference the socket is by calling our AbortSocket()
    // method
    //

    Socket->Reference();

    //
    // now associate the socket object with this handle object. We should not
    // have a current association
    //

    ICSocket * pSocket;

    pSocket = (ICSocket *) InterlockedExchangePointer((PVOID*)&_pICSocket, Socket);

    //
    // because ConnectSocket() can call this method multiple times without
    // intervening calls to ResetAbortHandle(), pSocket can legitimately be
    // non-NULL at this point
    //

    //INET_ASSERT(pSocket == NULL);

    //
    // if the handle was invalidated on another thread before we got
    // chance to set the socket to close, then abort the request now
    //

    //
    // BUGBUG - screws up normal FTP close handle processing - we
    //          have to communicate with the server in order to
    //          drop the connection
    //

    //if (IsInvalidated()) {
    //    AbortSocket();
    //}

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::ResetAbortHandle(
    VOID
    )

/*++

Routine Description:

    Disassociates this request handle and the ICSocket object when the network
    operation has completed

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_OBJECT::ResetAbortHandle",
                 "{%#x}",
                 GetPseudoHandle()
                 ));

    //
    // there really should be a ICSocket associated with this object, otherwise
    // our handle close/invalidation logic is broken
    //

    //
    // however, we can call ResetAbortHandle() from paths where we completed
    // early, not having called SetAbortHandle()
    //

    //INET_ASSERT(pSocket != NULL);

    //
    // so if there was a ICSocket associated with this object then remove the
    // reference added in SetAbortHandle()
    //


    ICSocket * pICSocket;

    pICSocket = (ICSocket *)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pICSocket != NULL) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket=%#x ref=%d\n",
                    pICSocket->GetSocket(),
                    pICSocket->ReferenceCount()
                    ));

        pICSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::AbortSocket(
    VOID
    )

/*++

Routine Description:

    If there is a ICSocket associated with this handle object then abort it. This
    forces the current network operation aborted and the request to complete
    with ERROR_INTERNET_OPERATION_CANCELLED

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_OBJECT::AbortSocket",
                 "{%#x, %#x [sock=%#x, ref=%d]}",
                 GetPseudoHandle(),
                 (_pICSocket != NULL)
                    ? (LPVOID)_pICSocket
                    : (LPVOID)_pICSocket,
                 _pICSocket
                    ? _pICSocket->GetSocket()
                    : (_pICSocket
                        ? _pICSocket->GetSocket()
                        : 0),
                 _pICSocket
                    ? _pICSocket->ReferenceCount()
                    : (_pICSocket
                        ? _pICSocket->ReferenceCount()
                        : 0)
                 ));

    //
    // get the associated ICSocket. It may have already been removed by a call
    // to ResetAbortHandle()
    //

    //
    // if there is an associated ICSocket then abort it (close the socket handle)
    // which will complete the current network I/O (if active) with an error.
    // Once the ICSocket is aborted, we reduce the reference count that was added
    // in SetAbortHandle(). This may cause the ICSocket to be deleted
    //

    LPVOID pAddr;

    pAddr = (LPVOID)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pAddr != NULL) {

        ICSocket * pSocket = (ICSocket *)pAddr;
//dprintf(">>>>>>>> %#x AbortSocket %#x [%#x]\n", GetCurrentThreadId(), pSocket, pSocket->GetSocket());
        pSocket->Abort();
        pSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::CheckGlobalProxyUpdated(
    VOID
    )

/*++

Routine Description:

    Tests whether we need to update the global proxy info structure from the registry

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                None,
                "INTERNET_HANDLE_OBJECT::CheckGlobalProxyUpdated",
                NULL
                ));

    if (IsProxyGlobal() && InternetSettingsChanged()) {

        //
        // acquire the pointer for exclusive access
        //

        AcquireProxyInfo(TRUE);

        //
        // check to make sure we are still using the global proxy info
        //

        if (IsProxyGlobal() && !GlobalProxyInfo.IsModifiedInProcess()) {
            //GlobalProxyInfo.SetProxyInfo(INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL);
        }
        ReleaseProxyInfo();

//dprintf("CheckGlobalProxyUpdated()\n");
        ChangeGlobalSettings();
    }

    DEBUG_LEAVE(0);
}

DWORD
INTERNET_HANDLE_OBJECT::Refresh(
    IN DWORD dwInfoLevel
    ) 
/*++

Routine Description:

    Refreshes the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    dwInfoLevel     -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

--*/
{

    if (dwInfoLevel == 0) {

        DWORD error;

        //
        // this refresh value means reload the proxy info from registry,
        // but we ONLY do this if we're using the global proxy info AND
        // we haven't set it to something other than the registry contents
        //

        if (IsProxyGlobal() && !GlobalProxyInfo.IsModifiedInProcess()) {

            FixProxySettingsForCurrentConnection(TRUE);
            return ERROR_SUCCESS;

        } else {

            //
            // not using global proxy or it has been set to something other
            // than the registry contents. Just return success
            //

            return ERROR_SUCCESS;
        }
    } else {
        return ERROR_INVALID_PARAMETER;
    }
}



DWORD
INTERNET_HANDLE_OBJECT::SetProxyInfo(
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL
    )

/*++

Routine Description:

    Sets the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    dwAccessType    - type of proxy access required

    lpszProxy       - pointer to proxy server list

    lpszProxyBypass - pointer to proxy bypass list

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_OBJECT::SetProxyInfo",
                "%s (%d), %#x (%q), %#x (%q)",
                InternetMapOpenType(dwAccessType),
                dwAccessType,
                lpszProxy,
                lpszProxy,
                lpszProxyBypass,
                lpszProxyBypass
                ));

    //
    // we only set proxy information on the top-level InternetOpen() handle
    //

    INET_ASSERT(!IsCopy());

/*

    We are setting the proxy information for an InternetOpen() handle. Based on
    the current and new settings we do the following (Note: the handle is
    initialized to DIRECT operation):

                                        current access
                +---------------------------------------------------------------
        new     |      DIRECT        |       PROXY        |      PRECONFIG
       access   |                    |                    |
    +-----------+--------------------+--------------------+---------------------
    | DIRECT    | No action          | Delete proxy info  | Remove reference to
    |           |                    |                    | global proxy info
    +-----------+--------------------+--------------------+---------------------
    | PROXY     | Set new proxy info | Delete proxy info. | Remove reference to
    |           |                    | Set new proxy info | global proxy info.
    |           |                    |                    | Set new proxy info
    +-----------+--------------------+--------------------+---------------------
    | PRECONFIG | Set proxy info to  | Delete proxy info. | No action
    |           | global proxy info  | Set proxy info to  |
    |           |                    | global proxy info  |
    +-----------+--------------------+--------------------+---------------------
*/

    DWORD error = ERROR_SUCCESS;
    PROXY_INFO * proxyInfo = NULL;

    //
    // acquire proxy info for exclusive access
    //

    AcquireProxyInfo(TRUE);

    if (IsProxy()) {

        //
        // delete private proxy info, or unlink from global proxy info
        //

        SafeDeleteProxyInfo();
    }

    //
    // Map Various Proxy types to their internal counterparts,
    //   note that I've ordered them in what I think is their 
    //   use frequency (how often each one is most likely to get hit).
    //

    switch (dwAccessType)
    {
        case INTERNET_OPEN_TYPE_PRECONFIG:
            proxyInfo = &GlobalProxyInfo;
            break;

        case INTERNET_OPEN_TYPE_DIRECT:
            proxyInfo = NULL;
            break;

        case INTERNET_OPEN_TYPE_PROXY:     
            {
                INET_ASSERT(!IsProxy());

                proxyInfo = new PROXY_INFO;
                if (proxyInfo != NULL) {
                    proxyInfo->InitializeProxySettings();
                    error = proxyInfo->GetError();
                    if (error == ERROR_SUCCESS &&
                        lpszProxy ) 
                    {

                        INTERNET_PROXY_INFO_EX info;
                        memset(&info, 0, sizeof(info));
                        info.dwStructSize = sizeof(info);
                        info.dwFlags = (PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY);

                        info.lpszProxy = lpszProxy;
                        info.lpszProxyBypass = lpszProxyBypass;

                        error = proxyInfo->SetProxySettings(&info, TRUE /*modified*/);

                    }
                    if (error != ERROR_SUCCESS) {
                        delete proxyInfo;
                        proxyInfo = NULL;
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }

                break;
            }

        case INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY:
            {
                proxyInfo = new PROXY_INFO_GLOBAL_WRAPPER;
                if (proxyInfo == NULL) {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
                break;
            }

        default:
            proxyInfo = NULL;
            break;
    }

    SetProxyInfo(proxyInfo);

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_OBJECT::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the current proxy information for this INTERNET_HANDLE_OBJECT

Arguments:

    lpBuffer            - pointer to buffer where INTERNET_PROXY_INFO will be
                          written, and any proxy strings (if sufficient space)

    lpdwBufferLength    - IN: number of bytes in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer doesn't have enough space to hold the proxy
                    information. *lpdwBufferLength has the required size

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_OBJECT::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                lpdwBufferLength ? *lpdwBufferLength : 0
                ));

    INET_ASSERT(!IsCopy());

    AcquireProxyInfo(FALSE);

    DWORD error;

    if (IsProxy()) {
        error = _ProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
    } else {
        if (*lpdwBufferLength >= sizeof(INTERNET_PROXY_INFO)) {

            LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

            lpInfo->dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
            lpInfo->lpszProxy = NULL;
            lpInfo->lpszProxyBypass = NULL;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        *lpdwBufferLength = sizeof(INTERNET_PROXY_INFO);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_OBJECT::GetProxyInfo(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Returns all proxy information based on a protocol scheme

Arguments:

    tProtocol           - protocol to get proxy info for

    lptScheme           - returned scheme

    lplpszHostName      - returned proxy name

    lpdwHostNameLength  - returned length of proxy name

    lpHostPort          - returned proxy port

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "INTERNET_HANDLE_OBJECT::GetProxyInfo",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT(!IsCopy());

    DWORD error;
    BOOL rc;

    //if (IsProxyGlobal()) {
    //    CheckGlobalProxyUpdated();
    //}

    AcquireProxyInfo(FALSE);

    if ( _ProxyInfo )
    {
        error = _ProxyInfo->QueryProxySettings(ppQueryForProxyInfo);
    }
    else
    {
        error = ERROR_SUCCESS;
        (*ppQueryForProxyInfo)->SetUseProxy(FALSE);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
INTERNET_HANDLE_OBJECT::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
{

    INET_ASSERT(!IsCopy());

    BOOL rc;

   AcquireProxyInfo(FALSE);

    if ( _ProxyInfo )
    {
        rc = _ProxyInfo->RedoSendRequest(
                                         lpdwError,
                                         pQueryForProxyInfo,
                                         pOriginServer,
                                         pProxyServer
                                         );
    }
    else
    {
        rc = FALSE;
    }

    ReleaseProxyInfo();

    return rc;
}

VOID
UnicodeStatusCallbackWrapper(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
)
{
    DWORD dwErr = ERROR_SUCCESS;
    INTERNET_STATUS_CALLBACK iscCallback;
    INET_ASSERT(hInternet != NULL);
    MEMORYPACKET mpBuffer;
    HINTERNET hInternetMapped = NULL;

    dwErr = MapHandleToAddress(hInternet, (LPVOID*)&hInternetMapped, FALSE);
    if (dwErr!=ERROR_SUCCESS)
        goto Cleanup;

    dwErr = ((HANDLE_OBJECT *)hInternetMapped)->IsValid(TypeWildHandle);
    if (dwErr==ERROR_SUCCESS)
    {
        iscCallback = ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->GetTrueStatusCallback();
        INET_ASSERT(iscCallback);

        switch (dwInternetStatus)
        {
        case INTERNET_STATUS_RESOLVING_NAME:
        case INTERNET_STATUS_NAME_RESOLVED:
        case INTERNET_STATUS_REDIRECT:
        case INTERNET_STATUS_CONNECTING_TO_SERVER:
        case INTERNET_STATUS_CONNECTED_TO_SERVER:
            mpBuffer.dwSize = dwStatusInformationLength;
            if (lpvStatusInformation)
            {
                mpBuffer.dwAlloc = (MultiByteToWideChar(CP_ACP,0,(LPSTR)lpvStatusInformation,-1,NULL,0)+1)
                                    *sizeof(WCHAR);
                mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc);
                if (!mpBuffer.psStr)
                {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    goto Cleanup;
                }
                mpBuffer.dwSize = MultiByteToWideChar(CP_ACP,0,(LPSTR)lpvStatusInformation,-1,
                                    (LPWSTR)mpBuffer.psStr, mpBuffer.dwAlloc/sizeof(WCHAR));
            }
            iscCallback(hInternet, dwContext, dwInternetStatus, (LPVOID)mpBuffer.psStr,
                    mpBuffer.dwSize);
            break;

        default:
            iscCallback(hInternet, dwContext, dwInternetStatus, lpvStatusInformation,
                dwStatusInformationLength);
        }
    }

Cleanup:
    if (hInternetMapped)
    {
        DereferenceObject(hInternetMapped);
    }
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\gopher.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gopher.cxx

Abstract:

    Contains methods for GOPHER_FIND_HANDLE_OBJECT and GOPHER_FILE_HANDLE_OBJECT
    classes

    Contents:
        RMakeGfrFindObjectHandle
        RMakeGfrFileObjectHandle
        RMakeGfrFixedObjectHandle

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeGfrFindObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

Routine Description:

    C-callable wrapper for creating a GOPHER_FIND_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of GOPHER_FIND_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    GOPHER_FIND_HANDLE_OBJECT * hFind;

    hFind = new GOPHER_FIND_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFind != NULL) {
        error = hFind->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFind);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFind = NULL;
            }
        } else {
            delete hFind;
            hFind = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFind;

    return error;
}



DWORD
RMakeGfrFixedObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN DWORD dwFixedType
    )

/*++

Routine Description:

Routine Description:

    C-callable wrapper for creating a GOPHER_FIND_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of GOPHER_FIND_HANDLE_OBJECT

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    GOPHER_FIND_HANDLE_OBJECT * hFind;

    hFind = new GOPHER_FIND_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    dwFixedType
                    );

    if (!hFind) {
        error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        error = hFind->GetStatus();
        if (error != ERROR_SUCCESS) {
            delete hFind;
            hFind = NULL;
        }
    }

    *ChildHandle = (HINTERNET)hFind;
    return error;
}



DWORD
RMakeGfrFileObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating a GOPHER_FILE_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                      OUT: mapped address of GOPHER_FILE_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    GOPHER_FILE_HANDLE_OBJECT * hFile;

    hFile = new GOPHER_FILE_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwContext
                    );

    if (hFile != NULL) {
        error = hFile->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hFile);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hFile = NULL;
            }
        } else {
            delete hFile;
            hFile = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hFile;

    return error;
}

//
// GOPHER_FIND_HANDLE_OBJECT class implementation
//

GOPHER_FIND_HANDLE_OBJECT::GOPHER_FIND_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FindHandle = Child;
    _wCloseFunction = wCloseFunc;
    _IsHtml = FALSE;
    _dwFixedType = 0;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _Context = dwContext;
    SetObjectType(TypeGopherFindHandle);
}

//
// Constructor for poser find handle to return html form...
//

GOPHER_FIND_HANDLE_OBJECT::GOPHER_FIND_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    DWORD dwFixedType
    ) : INTERNET_CONNECT_HANDLE_OBJECT (Parent)
{
    _FindHandle = Child;
    _wCloseFunction = NULL;
    _IsHtml = FALSE;  // must set FALSE so RSetHtmlHandleType can set TRUE!
    _dwFixedType = dwFixedType;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _Context = 0;
    SetObjectType(TypeGopherFindHandle);
}


GOPHER_FIND_HANDLE_OBJECT::~GOPHER_FIND_HANDLE_OBJECT(
    VOID
    )
{
    //
    // close local handle with appropriate function.
    //

    if (_FindHandle != NULL) {
        _Status = _wCloseFunction(_FindHandle);
    } else {
        _Status = ERROR_SUCCESS;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }

    //
    // and the query buffer
    //

    FreeQueryBuffer();
}

HINTERNET
GOPHER_FIND_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FindHandle;
}

DWORD
GOPHER_FIND_HANDLE_OBJECT::QueryHtmlDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )
{
    DWORD error;

    if (_QueryBuffer != NULL) {
        error = ERROR_SUCCESS;
    } else {
        error = AllocateQueryBuffer();
    }

    INET_ASSERT(_QueryBytesAvailable == 0);

    if (error == ERROR_SUCCESS) {

        DWORD nRead;

        _QueryOffset = 0;
        if (ReadHtmlUrlData((HINTERNET)this,
                            _QueryBuffer,
                            _QueryBufferLength,
                            lpdwNumberOfBytesAvailable
                            )) {
            _QueryBytesAvailable = *lpdwNumberOfBytesAvailable;
            //SetAvailableDataLength(_QueryBytesAvailable);
            if (_QueryBytesAvailable == 0) {
                SetEndOfFile();
            }
        } else {
            error = GetLastError();
        }
    }
    return error;
}

//
// GOPHER_FILE_HANDLE_OBJECT class implementation
//

GOPHER_FILE_HANDLE_OBJECT::GOPHER_FILE_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)
{
    _FileHandle = Child;
    _wCloseFunction = wCloseFunc;
    _IsHtml = FALSE;
    _lpszUrl = NULL;
    _lpszDirEntry = NULL;
    _Context = dwContext;
    SetObjectType(TypeGopherFileHandle);
}

GOPHER_FILE_HANDLE_OBJECT::~GOPHER_FILE_HANDLE_OBJECT(
    VOID
    )
{
    //
    // close local handle with appropriate function.
    //

    if (_FileHandle != NULL) {
        _Status = _wCloseFunction(_FileHandle);
    } else {
        _Status = ERROR_SUCCESS;
    }

    //
    // clear out any strings we allocated
    //

    if (_lpszUrl != NULL) {
        DEL_STRING(_lpszUrl);
    }
    if (_lpszDirEntry != NULL) {
        DEL_STRING(_lpszDirEntry);
    }
}

HINTERNET
GOPHER_FILE_HANDLE_OBJECT::GetHandle(
    VOID
    )
{
    return _FileHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\autoprox.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    autoprox.cxx

Abstract:

    Contains class implementation for auto-proxy DLLs which can extent WININET's
        abilities (logic) for deciding what proxies to use.

    How auto-proxy works:
        By offloading requests to a specialized Win32 Thread which picks
        up queued up message requests for Queries, Shutdown, and Initialization


    Contents:
        InternetInitializeAutoProxyDll
        AUTO_PROXY_DLLS::CheckForTimerConfigChanges
        AUTO_PROXY_DLLS::DoNestedProxyInfoDownload
        AUTO_PROXY_DLLS::SelectAutoProxyByMime
        AUTO_PROXY_DLLS::SelectAutoProxyByFileExtension
        AUTO_PROXY_DLLS::SelectAutoProxyByDefault
        AUTO_PROXY_DLLS::ReadAutoProxyRegistrySettings
        AUTO_PROXY_DLLS::IsAutoProxyEnabled
        AUTO_PROXY_DLLS::IsAutoProxyGetProxyInfoCallNeeded
        AUTO_PROXY_DLLS::QueueAsyncAutoProxyRequest
        AUTO_PROXY_DLLS::ProcessProxyQueryForInfo
        AUTO_PROXY_DLLS::SafeThreadShutdown
        AUTO_PROXY_DLLS::DoThreadProcessing
        AUTO_PROXY_DLLS::ProcessAsyncAutoProxyRequest
        AUTO_PROXY_DLLS::SignalAsyncRequestCompleted
        AUTO_PROXY_DLLS::FreeAutoProxyInfo

        AUTO_PROXY_LIST_ENTRY::LoadEntry
        AUTO_PROXY_LIST_ENTRY::GetProxyInfoEx
        AUTO_PROXY_LIST_ENTRY::ProxyInfoInvalid
        AUTO_PROXY_LIST_ENTRY::ProxyDllInit
        AUTO_PROXY_LIST_ENTRY::ProxyDllDeInit

        (MatchFileExtensionWithUrl)
        (AutoProxyThreadFunc)

Author:

    Arthur L Bierer (arthurbi) 17-Dec-1996

Revision History:

    17-Dec-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include "autodial.h"
#include "apdetect.h"

//
// definitions
//

#define DEFAULT_SCRIPT_BUFFER_SIZE 4000 // bytes.

//
// BUGBUG [arthurbi] This structures are shared between
//  wininet.dll && jsproxy.dll, shouldn't we move them 
//  into a central file???
//

#define AUTO_PROXY_REG_FLAG_ALLOW_STRUC  0x0001

typedef struct {

    //
    // Size of struct
    //

    DWORD dwStructSize;

    //
    // Buffer to Pass
    //

    LPSTR lpszScriptBuffer;

    //
    // Size of buffer above
    //

    DWORD dwScriptBufferSize;

}  AUTO_PROXY_EXTERN_STRUC, *LPAUTO_PROXY_EXTERN_STRUC;


//
// private templates
//

PRIVATE
BOOL
MatchFileExtensionWithUrl(
    IN LPCSTR lpszFileExtensionList,
    IN LPCSTR lpszUrl
    );


//
// private vars
//


//
// functions
//

INTERNETAPI_(BOOL)
InternetInitializeAutoProxyDll(
    DWORD dwReserved
    )
/*++

Routine Description:

    Stub to make INETCPL work.  Since they expect to call this function.

Arguments:

    none.

Return Value:

    BOOL
        TRUE    - success

--*/

{

    BOOL fSuccess;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "InternetInitializeAutoProxyDll",
                ""
                ));

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
    }
    if (error == ERROR_SUCCESS) {
        GlobalProxyInfo.ClearBadProxyList();
        FixProxySettingsForCurrentConnection(TRUE);
        GlobalProxyInfo.RefreshProxySettings(TRUE);        
    }

    fSuccess = (error == ERROR_SUCCESS ) ? TRUE : FALSE;

    DEBUG_LEAVE(fSuccess);

    return fSuccess;

}


DWORD
WINAPI
AutoProxyThreadFunc(
    LPVOID lpAutoProxyObject
    )
/*++

Routine Description:

    Initialization Win32 Proc called when the auto-proxy thread is started.

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    return GlobalProxyInfo.DoThreadProcessing(lpAutoProxyObject);
}


//
// methods
//

DWORD
AUTO_PROXY_DLLS::CheckForTimerConfigChanges(
    IN DWORD dwMinsToPoll
    )
/*++

Routine Description:

    Exames the registry to see if a timer has been turned so
      that we poll auto-proxy every so often to check for updates

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD error = ERROR_SUCCESS;
    DWORD dwReloadMins = dwMinsToPoll;
    BOOL fEnableTimer = FALSE;

    //
    // Now check to determine if we have to enable the auto-proxy e
    //   this is used to force a re-download every "X" minutes.
    //

    if ( dwReloadMins != 0 )
    {
        if ( dwReloadMins >  MAX_RELOAD_DELAY  )  // too big?...
        {
            dwReloadMins = MAX_RELOAD_DELAY;
        }

        dwReloadMins *= ( 1000 * 60 ); // convert mins to miliseconds
        fEnableTimer = TRUE;
    }

    //
    // enable/disable timer for auto-proxy refresh.
    //

    ResetTimerCounter(
        fEnableTimer, // TRUE/FALSE enable/disable
        dwReloadMins  // conv-ed already to msecs
        );

    error = ERROR_SUCCESS;

    return error;
}

DWORD
AUTO_PROXY_DLLS::StartDownloadOfProxyInfo(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Does the Overall download of proxy-information from an internally accessable Web Server.
        Handles the case where we may have to redownload a secondary script also takes
        care of launching detection for proxies.

Arguments:

    fForceRefresh - TRUE if we are to attempt to refresh the auto-proxy URLs, and force a redection

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD error = ERROR_SUCCESS;
    BOOL fLocked = FALSE;
    DWORD dwcbAutoConfigProxy = 0;
    LPCSTR lpszAutoProxyUrl = NULL;
    INTERNET_PROXY_INFO_EX  ProxySettings;
    BOOL fProxySettingsAlloced = FALSE;
    BOOL fNeedRegWrite = FALSE;
    BOOL fCachedDialupDetection = FALSE;
    BOOL fNeedHostIPChk = FALSE;


    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::StartDownloadOfProxyInfo",
                "%B",
                fForceRefresh
                ));


    if ( IsOffline() ) 
    {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    LockAutoProxy();
    fLocked = TRUE;    

    error = GetProxySettings(&ProxySettings);

    if (error != ERROR_SUCCESS ) {
        goto quit;
    }

    fProxySettingsAlloced = TRUE;

    //
    // Now read from the registry, closing any stale stuff that we may still have
    //   around.  Do we still really need this?  Lets only do this for Refresh cases.
    //

    if ( fForceRefresh )
    {
        DestroyAutoProxyDll(TRUE); // unloads DLLs and frees up reg vars.
        SelectAutoProxy(NULL);

        _Error = ReadAutoProxyRegistrySettings();
        error = _Error;

        if (error != ERROR_SUCCESS ||
           !IsConfigValidForAutoProxyThread() )
        {
            SetState(AUTO_PROXY_DISABLED);
            goto quit;
        }

        if ( GetState() == AUTO_PROXY_DISABLED )
        {
            INET_ASSERT(FALSE);  // do we need this code?
            goto quit;
        }
    }

    //INET_ASSERT(GetState() == AUTO_PROXY_BLOCKED ||
    //            GetState() == AUTO_PROXY_PENDING);

    fLocked = FALSE;
    UnlockAutoProxy();

    //
    // Now begin the work, we should no longer need to touch the Proxy_DLL object
    //   settings until we grab the AutoProxy Lock again.
    //

    do
    {
        if ( IsProxyAutoDetectEnabled(&ProxySettings) )
        {
            CHAR szUrl[1024];
            BOOL fRet;
            DWORD dwDetectFlags = PROXY_AUTO_DETECT_TYPE_DNS_A;


            if ( fForceRefresh ||
                 IsProxyAutoDetectNeeded(&ProxySettings) )
            {

                //
                // Release Old Auto-config URL
                //

                if ( ProxySettings.lpszLastKnownGoodAutoConfigUrl) {
                    FREE_MEMORY(ProxySettings.lpszLastKnownGoodAutoConfigUrl);
                    ProxySettings.lpszLastKnownGoodAutoConfigUrl = NULL;
                }

                // only do dhcp on net connections
                if ( ProxySettings.lpszConnectionName == NULL ) {
                    dwDetectFlags |= PROXY_AUTO_DETECT_TYPE_DHCP;
                }

                //
                // Save out the Host IP addresses, before we start the detection,
                //  after the detection is complete, we confirm that we're still
                //  on the same set of Host IPs, in case the user switched connections.
                //

                error = GetHostAddresses(&(ProxySettings.pdwDetectedInterfaceIp),
                                         &(ProxySettings.dwDetectedInterfaceIpCount));

                if ( error != ERROR_SUCCESS) {
                    goto quit;
                }

                fNeedHostIPChk = TRUE; // because we've saved our IPs

                //
                // Do the actual Detection work
                //

                fRet = DetectAutoProxyUrl(
                         szUrl,
                         ARRAY_ELEMENTS(szUrl),
                         dwDetectFlags
                         );

                GetCurrentGmtTime(&ProxySettings.ftLastKnownDetectTime); // mark when detection was run.

                //
                // Process the Results of detection.
                //

                if ( fRet )
                {
                    ProxySettings.dwAutoDiscoveryFlags |= AUTO_PROXY_FLAG_DETECTION_RUN;

                    ProxySettings.lpszLastKnownGoodAutoConfigUrl = NewString(szUrl);
                    if ( ProxySettings.lpszLastKnownGoodAutoConfigUrl == NULL )
                    {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }

                    SetExpiredUrl(szUrl);
                    fNeedRegWrite = TRUE;
                }
                else
                {
                    //
                    // Disable auto-detection, if we failed
                    //

                    if ( ! (ProxySettings.dwAutoDiscoveryFlags & (AUTO_PROXY_FLAG_DETECTION_RUN | AUTO_PROXY_FLAG_USER_SET)) )
                    {
                        ProxySettings.dwFlags &= ~(PROXY_TYPE_AUTO_DETECT);
                    }

                    ProxySettings.dwAutoDiscoveryFlags |= AUTO_PROXY_FLAG_DETECTION_RUN;
                    fNeedRegWrite = TRUE;
                }
            } 
            else if ( ProxySettings.lpszLastKnownGoodAutoConfigUrl != NULL &&
                      ProxySettings.lpszConnectionName             != NULL )
                      
            {   
                //
                // If we're not doing any detection, and we're on a dial-up adapter,
                //   then we should remember that fact, since we may be called upon
                //   to actually force a detect, in case the cached URL was stale/bad.
                //

                INET_ASSERT(! fForceRefresh );

                fCachedDialupDetection = TRUE;
            }

            lpszAutoProxyUrl = ProxySettings.lpszLastKnownGoodAutoConfigUrl;
        }

        //
        // Falback if we are unable to detect something
        //

        if ( lpszAutoProxyUrl == NULL &&
             IsProxyAutoConfigEnabled(&ProxySettings))
        {
            lpszAutoProxyUrl = ProxySettings.lpszAutoconfigUrl;
        }

        //
        // Do the actual download of the file
        //

        if (lpszAutoProxyUrl != NULL)
        {
            error = DoNestedProxyInfoDownload(lpszAutoProxyUrl, &ProxySettings, fForceRefresh);

            if ( error != ERROR_SUCCESS )
            {

                //
                // If we're cached + on a dialup, and we fail with the URL,
                //  then perhaps the URL/net is really expired.
                //

                if ( fCachedDialupDetection &&
                     ! fForceRefresh )
                {
                    fForceRefresh = TRUE;
                    continue;
                }

                //
                // Fallback to autoconfig if we failed and we were using
                //  auto-detect
                //

                if ( IsProxyAutoConfigEnabled(&ProxySettings) &&                 
                     lpszAutoProxyUrl != ProxySettings.lpszAutoconfigUrl &&
                     ProxySettings.lpszAutoconfigUrl != NULL )
                {
                    lpszAutoProxyUrl = ProxySettings.lpszAutoconfigUrl;
                    error = DoNestedProxyInfoDownload(lpszAutoProxyUrl, &ProxySettings, fForceRefresh);
                }
            }
        }
    } while (FALSE);

    LockAutoProxy();
    fLocked = TRUE;

    if (lpszAutoProxyUrl == NULL)
    {
        SetState(AUTO_PROXY_DISABLED);
        goto quit;
    }
    else
    {
        // stamp version so we know we just ran detection
        _dwUpdatedProxySettingsVersion = 
            ProxySettings.dwCurrentSettingsVersion;
        SetState(AUTO_PROXY_ENABLED);
    }

    CheckForTimerConfigChanges(ProxySettings.dwAutoconfigReloadDelayMins);

quit:

    if ( error != ERROR_SUCCESS )
    {
        if (!fLocked)
        {
            LockAutoProxy();
            fLocked = TRUE;
        }

        SetState(AUTO_PROXY_DISABLED);
    }

    //
    // Unlock the AutoProxy 
    //

    if ( fLocked ) {
        UnlockAutoProxy();
    }

    if ( fProxySettingsAlloced )
    {
        //
        // We need to save results to registry,
        //   then stamp the version in our global we now we detected for this,
        //   and then finally clean up any allocated stuff.
        //

        SaveDetectedProxySettings(&ProxySettings, fNeedHostIPChk);        

        WipeProxySettings(&ProxySettings);
    }

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::DoNestedProxyInfoDownload(
    IN LPCSTR lpszAutoProxy,
    IN LPINTERNET_PROXY_INFO_EX lpProxySettings,
    IN BOOL fForceRefresh
    )
/*++

Routine Description:

    Does the download of proxy-information from an internally accessable Web Server.
        Handles the case where we may have to redownload a secondary script and then
        calls on to DownloadProxyInfo to actually do the dirty work.

Arguments:

    lpszAutoProxy - URL to download

    lpProxySettings - active Proxy Settings Copy for auto-proxy thread.

    fForceRefresh - force refresh of downloaded file

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    LPCSTR lpszNestedAutoProxyUrl = NULL;
    DWORD error;
   
    _pTempProxySettings = lpProxySettings; // in case they reset proxy settings    

    if ( _fInAutoProxyThreadShutDown )
    {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;

    }

    //
    // IEAK flag, don't retry INS file unless either one of the following:
    //      1) INS URL is expired
    //      2) caching INS run is disabled
    //      3) we're not forcing a refresh
    //

    if ( !(lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_CACHE_INIT_RUN ) ||
         // !(ProxySettings.dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_RUN ) ||
         !fForceRefresh ||         
         IsExpiredUrl(lpszAutoProxy))
    {

        //
        // Now do the actual download of the proxy info.
        //

        error =
            DownloadProxyInfo(lpszAutoProxy, fForceRefresh);

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }

    //
    // Now check to determine if we have an overriding Auto-Proxy that
    //   supersides the one we just download.  If we do, we will
    //   need to redownload auto-proxy
    //
    lpszNestedAutoProxyUrl = lpProxySettings->lpszAutoconfigSecondaryUrl;

    if ( lpszNestedAutoProxyUrl ) 
    {
        //
        // Success - now restart the download process for this special Url
        //

        error = DownloadProxyInfo(
                    lpszNestedAutoProxyUrl,
                    fForceRefresh
                    );
    }

    // fall through even in error

    error = ERROR_SUCCESS;

quit:

    INET_ASSERT(_pTempProxySettings);
    _pTempProxySettings = NULL;

    return error;
}



DWORD
AUTO_PROXY_DLLS::DownloadProxyInfo(
    IN LPCSTR lpszAutoProxy,
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Does the download of proxy-information from an internally accessable Web Server.
        The data will be checked, written to a temp file, and then an associated
        DLL will be called to handle it.

Arguments:

    lpszUrl - The URL to download.

    fForceRefresh - force file to be reloaded from the wire

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    HINTERNET hInternet = NULL;
    HINTERNET hRequest = NULL;
    HANDLE hFile = NULL;
    CHAR szTemporyFile[MAX_PATH+1];
    DWORD dwTempFileSize;

    HANDLE hLockHandle = NULL;

    BOOL fSuccess;
    DWORD error = ERROR_SUCCESS;

    CHAR szBuffer[MAX_PATH+1];
    DWORD dwBytesRead;

    BOOL fCleanupFile = FALSE;
    BOOL fLocked = FALSE;
    BOOL fBuffering = FALSE; 

    LPSTR lpszScriptBuffer = NULL;
    DWORD dwScriptBufferSize;

    DWORD dwStatusCode = ERROR_SUCCESS;
    DWORD cbSize = sizeof(DWORD);
    int nRetries = 3; // Num auth attempts

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::DownloadProxyInfo",
                "%q",
                lpszAutoProxy
                ));

    INET_ASSERT(lpszAutoProxy);

    //
    // Fire up a mini InternetOpen/InternetOpenUrl to download a
    //  config file found on some internal server.
    //

    hInternet = InternetOpen(
                    (_lpszUserAgent) ? _lpszUserAgent : gszDefaultUserAgent,
                    INTERNET_OPEN_TYPE_DIRECT,
                    NULL,
                    NULL,
                    0
                    );


    if ( !hInternet )
    {
        error = GetLastError();
        INET_ASSERT(error != ERROR_SUCCESS);
            goto quit;
    }


    do 
    {
        hRequest = InternetOpenUrl(
                            hInternet,
                            lpszAutoProxy,
                            "Accept: */*\r\n",
                            (DWORD) -1,
                            (fForceRefresh ?
                                INTERNET_FLAG_RELOAD :
                                0) |
                            INTERNET_FLAG_NEED_FILE,
                            INTERNET_NO_CALLBACK
                            );


         if ( !hRequest )
         {
            //error = ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT;
            error = GetLastError();
            if(GlobalDisplayScriptDownloadFailureUI && !GlobalIsProcessNtService)
            {
                InternetErrorDlg(
                GetDesktopWindow(),
                hRequest,
                ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT,
                FLAGS_ERROR_UI_FILTER_FOR_ERRORS,
                NULL);
            }
            goto quit;
        }

        cbSize = sizeof(dwStatusCode);
        if (HttpQueryInfo(
            hRequest,
            HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
            (LPVOID) &dwStatusCode,
            &cbSize,
            NULL
            ) && HTTP_STATUS_DENIED == dwStatusCode)
        {
            if (GlobalIsProcessNtService)
            {
                error = ERROR_INTERNET_INTERNAL_ERROR;
                goto quit;
            }

            // Check the status code and throw an InternetErrorDlg
            // if auth is needed and try again.
            if (InternetErrorDlg(
                GetDesktopWindow(), 
                hRequest,
                ERROR_INTERNET_INCORRECT_PASSWORD,
                FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
                NULL
                ) != ERROR_INTERNET_FORCE_RETRY)
            {
                nRetries = 0;
            }
            else
            {
		cbSize = sizeof(szBuffer);
		HttpQueryInfo(
			hRequest,
			HTTP_QUERY_WWW_AUTHENTICATE,
			(LPVOID) szBuffer,
			&cbSize,
			NULL
			);
		szBuffer[5]='\0';
		if (!lstrcmpi(szBuffer, "Basic"))
		{
		    HttpSendRequest(
				    hRequest, 
				    "Accept: */*\r\n",
				    (DWORD)-1,
				    NULL,
				    0);
		    cbSize = sizeof(dwStatusCode);
		    if (HttpQueryInfo(
			    hRequest,
			    HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
			    (LPVOID) &dwStatusCode,
			    &cbSize,	
			    NULL
			    ) && HTTP_STATUS_DENIED == dwStatusCode)
		    {
                        InternetCloseHandle(hRequest);
		    }
		    else
		    {
                        GlobalAutoProxyNeedsInit = FALSE;
			break;
		    }
		}
		else
                    InternetCloseHandle(hRequest);
            }
        }
        else
        {
            // Call it good
            GlobalAutoProxyNeedsInit = FALSE;
            break;
        }
    } while ( --nRetries>0);

    if(nRetries <= 0)
    {
        // Still haven't initialized.
        GlobalAutoProxyNeedsInit = TRUE;
    }

    // Reset to success
    error = ERROR_SUCCESS;

    if(HTTP_STATUS_NOT_FOUND == dwStatusCode)
    {
        error = ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT;
        if(GlobalDisplayScriptDownloadFailureUI && !GlobalIsProcessNtService)
        {
            InternetErrorDlg(
                GetDesktopWindow(),
                hRequest,
                ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT,
                FLAGS_ERROR_UI_FILTER_FOR_ERRORS,
                NULL);
        }
        goto quit;
    }


    DWORD dwIndex;
    DWORD dwTempSize;

    dwIndex = 0;
    dwTempSize = sizeof(dwScriptBufferSize);

    dwScriptBufferSize = 0;
    
    if ( ! HttpQueryInfo(hRequest, 
                       (HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER),
                       (LPVOID) &dwScriptBufferSize,
                       &dwTempSize,
                       &dwIndex) )
    {
        // failure, just defaults 
        dwScriptBufferSize = DEFAULT_SCRIPT_BUFFER_SIZE;
        fBuffering = TRUE;
    }
    else if ( dwScriptBufferSize > DEFAULT_SCRIPT_BUFFER_SIZE )
    {
        // success, but too big.
        dwScriptBufferSize = DEFAULT_SCRIPT_BUFFER_SIZE;
        fBuffering = FALSE;
    }
    else
    {
        // success, and this one is just right.
        fBuffering = TRUE; 
    }
   
    lpszScriptBuffer = (LPSTR) 
                        ALLOCATE_MEMORY(LMEM_FIXED, ((dwScriptBufferSize+1)
                            * sizeof(CHAR)));

    if ( lpszScriptBuffer == NULL ) 
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull down bytes, and write to file
    //

    DWORD dwBytes;
    dwBytesRead = 0;

    do
    {
        DWORD dwBytesLeft;
        LPSTR lpszDest;

        dwBytes = 0;
        lpszDest = lpszScriptBuffer;
        dwBytesLeft = dwScriptBufferSize;

        fSuccess = InternetReadFile(
                        hRequest,
                        lpszDest,
                        dwBytesLeft,
                        &dwBytes
                        );

        if ( ! fSuccess )
        {
            error = GetLastError();
            goto quit;
        }

        if ( _fInAutoProxyThreadShutDown )
        {
            error = ERROR_INTERNET_SHUTDOWN;
            goto quit;
        }

        if ( dwBytes > 0 )
        {
            if ( dwBytesRead > 0 ) 
            {
                fBuffering = FALSE;
            }

            dwBytesRead += dwBytes;
        }
    } while ( dwBytes != 0 );

    //
    // Figure out what kind of file we're dealing with.
    //  ONLY allow files with the correct extension or the correct MIME type.
    //

    szBuffer[0] = '\0';
    dwBytes = ARRAY_ELEMENTS(szBuffer)-1;

    fSuccess = HttpQueryInfo( hRequest,
                                 HTTP_QUERY_CONTENT_TYPE,
                                 szBuffer,
                                 &dwBytes,
                                 NULL );

    fLocked = TRUE;
    LockAutoProxy();

    if ( !(fSuccess
            && SelectAutoProxyByMime(szBuffer)) )
    {
        if ( ! SelectAutoProxyByFileExtension(lpszAutoProxy) )
        {
            if ( ! SelectAutoProxyByDefault() )
            {
                //
                // Could not find a registered handler for this data.
                //

                error = ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT;
                goto quit;
            }
        }
    }

    //
    // Now, launch the handler to tell them about the file.
    //  we downloaded it first.
    //

    AUTO_PROXY_LIST_ENTRY * papleAutoProxy;
    AUTO_PROXY_EXTERN_STRUC apeStruct;
    LPAUTO_PROXY_EXTERN_STRUC pExtraStruct;
    

    papleAutoProxy = GetSelectedAutoProxyEntry();
    pExtraStruct = NULL;

    //
    // Get a temp file from cache if we need it.
    //

    if ( fBuffering &&
         (papleAutoProxy->_dwFlags & AUTO_PROXY_REG_FLAG_ALLOW_STRUC) &&
         dwBytesRead > 0 )
    {
        // slam a \0 terminator
        INET_ASSERT(dwBytesRead <= dwScriptBufferSize);
        lpszScriptBuffer[dwBytesRead] = '\0';

        pExtraStruct = &apeStruct;
        apeStruct.dwStructSize = sizeof(AUTO_PROXY_EXTERN_STRUC);
        apeStruct.lpszScriptBuffer = lpszScriptBuffer;
        apeStruct.dwScriptBufferSize = dwBytesRead + 1;
    }
    else 
    {
        fCleanupFile = TRUE;

        //Qfe 3430: When parsing ins file, with reference to pac file, wininet needs to 
        //know the connectoid name in order to set the pac file correctly. Currently there
        //is no way for wininet to pass the connectoid name to branding dll. To workaround
        //this, we use the AUTO_PROXY_EXTERN_STRUC to pass the connectoid name in lpszScriptBuffer
        //variable. 
        if(!(papleAutoProxy->_dwFlags & AUTO_PROXY_REG_FLAG_ALLOW_STRUC))
        {
            pExtraStruct = &apeStruct;
            apeStruct.dwStructSize = sizeof(AUTO_PROXY_EXTERN_STRUC);
            apeStruct.lpszScriptBuffer = GlobalProxyInfo.GetConnectionName();
        }

        if ( ! InternetLockRequestFile(hRequest, &hLockHandle) ) 
        {
            fCleanupFile = FALSE;
        }
        
        dwTempFileSize = MAX_PATH;

        if ( ! InternetQueryOption(hRequest, INTERNET_OPTION_DATAFILE_NAME, 
                    szTemporyFile, &dwTempFileSize ) ||
               dwTempFileSize == 0 )
        {
            error = ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT;
            goto quit;
        }
    }

    //
    // The loading and unloading of DLLs is owned/allowed
    //  only by the auto-proxy thread, ONCE THIS THREAD IS RUNNING
    //  so once we're here, we can be assured its safe to
    //  make the following calls without holding the crit sec.
    //

    INET_ASSERT(fLocked);
    UnlockAutoProxy();
    fLocked = FALSE;
    fSuccess = TRUE;

    //
    // If we're not configured, or cannot match the URL
    //  with a Handler to actually run the script,
    //  then we need to error out
    //

    if ( papleAutoProxy == NULL)
    {
        error = ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT;
        goto quit;
    }

    if ( ! papleAutoProxy->_hAutoConfigDLL )
    {
        if ( _fInAutoProxyThreadShutDown )
        {
            error = ERROR_INTERNET_SHUTDOWN;
            goto quit;
        }

        error = papleAutoProxy->LoadEntry();

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }
    else if ( papleAutoProxy->_fInitializedSuccessfully &&
              papleAutoProxy->_pProxyDllInit &&
              papleAutoProxy->_pProxyDllDeInit )
    {
        //
        // If this DLL has already been loaded,
        //   then unitialize it before re-initalizeing with
        //   new data, otherwise we risk leaking some its
        //   objects
        //

        papleAutoProxy->ProxyDllDeInit(
            szBuffer,
            0
            );
        INET_ASSERT(papleAutoProxy->_fUnInited);
    }

    //
    // Make the call into the external DLL,
    //  and let it run, possibly initilization and doing a bunch
    //  of stuff.
    //


    fSuccess = papleAutoProxy->ProxyDllInit (
                            AUTO_PROXY_VERSION,
                            szTemporyFile,  // temp file we down loaded
                            szBuffer,       // mime
                            &_aphAutoProxyAPIs,
                            (DWORD_PTR) pExtraStruct
                            );

    if ( _fInAutoProxyThreadShutDown )
    {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    if ( ! fSuccess )
    {
        error = ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT;
        goto quit;
    }


    if ( papleAutoProxy->IsGetProxyInfoEx() ||
         papleAutoProxy->IsGetProxyInfo()  )
    {
        SetState(AUTO_PROXY_ENABLED);
    }
    else
    {
        SetState(AUTO_PROXY_DISABLED);
    }

quit:

    if ( error != ERROR_SUCCESS )
    {
        if (!fLocked)
        {
            LockAutoProxy();
            fLocked = TRUE;
        }

        SetState(AUTO_PROXY_DISABLED);
    }

    if ( fLocked )
    {
        UnlockAutoProxy();
    }

    if ( fCleanupFile )
    {
        InternetUnlockRequestFile(hLockHandle);
    }

    if ( lpszScriptBuffer )
    {
        FREE_MEMORY(lpszScriptBuffer);
    }

    if ( hRequest )
    {
        InternetCloseHandle(hRequest);
    }

    if ( hInternet )
    {
        InternetCloseHandle(hInternet);
    }

    SetAbortHandle(NULL);

    DEBUG_LEAVE(error);

    return error;
}



BOOL
AUTO_PROXY_DLLS::IsAutoProxyEnabled(
    VOID
    )

/*++

Routine Description:

    Determines whether the auto-proxy thread is enabled and ready
        to accept async proxy requests.  This is needed to prevent
        senceless calls to the auto-proxy thread when the request
        could made more directly to the PROXY_INFO object.

Return Value:

    BOOL
        TRUE - the AutoProxy thread is accepting async requests

        FALSE - the AutoProxy thread is refusung async requests.

--*/

{
    BOOL fIsGetProxyCallProxyNeeded = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::IsAutoProxyEnabled",
                ""
                ));


    LockAutoProxy();

    //
    // If we're downloading new information, OR we have a async thread ready to process
    //   autoproxy queries, then go async and do the request.  The worst case will
    //   result in the async thread being created and then returning the request
    //   unprocessed ( the FSM will resubmit it to the general proxy code )
    //

    if ( GetState() == AUTO_PROXY_ENABLED ||
         GetState() == AUTO_PROXY_BLOCKED ||
         GetState() == AUTO_PROXY_PENDING )
    {
        fIsGetProxyCallProxyNeeded = TRUE;
    }
    else
    {
        fIsGetProxyCallProxyNeeded = FALSE;
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(fIsGetProxyCallProxyNeeded);

    return fIsGetProxyCallProxyNeeded;
}


BOOL
AUTO_PROXY_DLLS::IsAutoProxyGetProxyInfoCallNeeded(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForInfo
    )

/*++

Routine Description:

    Wrapper for IsAutoProxyEnabled, verifies that the message object (pQueryForInfo)
        in question is capible of going async.

Arguments:

    pQueryForInfo - Pointer to Message object that contains state information
                        used in the query.

Return Value:

    BOOL
        TRUE - the AutoProxy thread is accepting async requests

        FALSE - the AutoProxy thread is refusung async requests.

--*/

{

    INET_ASSERT(pQueryForInfo);

    //
    // The caller has explicitly banned auto-proxy calls.
    //

    if ( pQueryForInfo->IsAvoidAsyncCall() )
    {
        return FALSE;
    }

    //
    // We cannot process this request to auto-proxy unless we have an URL
    //

    if ( ! pQueryForInfo->IsUrl() )
    {
        return FALSE;
    }

    //
    // Now check to see if its really enabled.
    //

    return IsAutoProxyEnabled();

}

DWORD
AUTO_PROXY_DLLS::QueueAsyncAutoProxyRequest(
    IN OUT AUTO_PROXY_ASYNC_MSG **ppQueryForInfo
    )

/*++

Routine Description:

    Submits the *ppQueryForInfo Object on the async queue for processing
     by the async auto-proxy thread.

Arguments:

    ppQueryForInfo - Pointer to pointer to Message object that contains state information
                        used in the query.   If the object needs to be allocated on the heap
                        then the pointer will change to reflect the new object ptr.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/


{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL fLocked = FALSE;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::QueueAsyncAutoProxyRequest",
                "%x",
                ppQueryForInfo
                ));


    //
    // First allocate an object, if its not allocated,
    //  cause we can't pass local stack vars to another thread (duh..)
    //

    if ( ! (*ppQueryForInfo)->IsAlloced() )
    {
        *ppQueryForInfo = new AUTO_PROXY_ASYNC_MSG(*ppQueryForInfo);

        if ( *ppQueryForInfo == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    LockAutoProxy();  // lock object to prevent anyone messing with thread handles
    fLocked = TRUE;

    //
    // Busy wait for thread to be shutdown before restarting.
    //

    while ( _fInAutoProxyThreadShutDown )
    {
        UnlockAutoProxy();
        Sleep(100);
        LockAutoProxy();
    }

    if ( _hAutoProxyThread == NULL )
    {

        _hAutoProxyThreadEvent = CreateEvent(
                                    NULL,   // pointer to security attributes
                                    FALSE,  // flag for manual-reset event
                                    TRUE,  // flag for initial state
                                    NULL    // event-object name
                                    );


        if ( _hAutoProxyThreadEvent == NULL )
        {
            error = GetLastError();
            goto quit;
        }

        //
        // We block on this event until the thread is actually running,
        //   otherwise we may PROCESS_DETEACH while the auto-proxy
        //   thread is in this quasi-state of having been created, but not actually run.
        //

        _hAutoProxyStartEvent = CreateEvent(
                                    NULL,   // pointer to security attributes
                                    TRUE,  // flag for manual-reset event
                                    FALSE,  // flag for initial state
                                    NULL    // event-object name
                                    );


        if ( _hAutoProxyStartEvent == NULL )
        {
            error = GetLastError();
            goto quit;
        }

        ResetEvent(_hAutoProxyStartEvent);

        _hAutoProxyThread = CreateThread(
                                NULL, // pointer to thread security attributes
                                0,    // starting stack size
                                AutoProxyThreadFunc,
                                this,  // argument
                                0,     // flags
                                &_dwAutoProxyThreadId
                                );


        if ( _hAutoProxyThread == NULL )
        {
            error = GetLastError();
            CloseHandle(_hAutoProxyThreadEvent);
            CloseHandle(_hAutoProxyStartEvent);
            _hAutoProxyThreadEvent = NULL;
            _hAutoProxyStartEvent = NULL;
            goto quit;
        }

        const HANDLE aWaitHandles[2] = {_hAutoProxyStartEvent, _hAutoProxyThread};

        // wait on the thread handle too in case it terminates for some unknown reason
        error = WaitForMultipleObjects(ARRAYSIZE(aWaitHandles),
                                       aWaitHandles,
                                       FALSE,
                                       INFINITE);
        if ( error != WAIT_OBJECT_0 )
        {
            INET_ASSERT(FALSE);
            TerminateThread(_hAutoProxyThread, ERROR_SUCCESS);

            CloseHandle(_hAutoProxyThreadEvent);
            CloseHandle(_hAutoProxyStartEvent);
            CloseHandle(_hAutoProxyThread);
            _hAutoProxyStartEvent = NULL;
            _hAutoProxyThread = NULL;
            _hAutoProxyThreadEvent = NULL;
            _dwAutoProxyThreadId = NULL;

            error = ERROR_INTERNET_INTERNAL_ERROR;
            goto quit;
        }
        else
        {
            CloseHandle(_hAutoProxyStartEvent);
            _hAutoProxyStartEvent = NULL;
        }

    }

    //
    // Now Block the Thread we're on...
    //

    if ( (*ppQueryForInfo)->IsBlockUntilCompletetion() )
    {
        if ( lpThreadInfo &&
             lpThreadInfo->Fsm &&
             lpThreadInfo->IsAsyncWorkerThread &&
             !(lpThreadInfo->Fsm->IsBlocking()))
        {
            //
            // In a FSM, use FSM - thread pool handler to block this.
            //

            (*ppQueryForInfo)->SetBlockedOnFsm(TRUE);

            lpThreadInfo->Fsm->SetState(FSM_STATE_CONTINUE);
            lpThreadInfo->Fsm->SetNextState(FSM_STATE_CONTINUE);

            error = BlockWorkItem(
                lpThreadInfo->Fsm,
                (DWORD_PTR) *ppQueryForInfo,    // block the FSM on ourselves
                INFINITE                        // we block foreever
                );


            if ( error != ERROR_SUCCESS )
            {
                goto quit;
            }

            InsertAtTailOfSerializedList(&_AsyncQueueList, &(*ppQueryForInfo)->_List);
            SetEvent(_hAutoProxyThreadEvent);

            error = ERROR_IO_PENDING;
        }
        else
        {
            AcquireBlockedRequestQueue();

            InsertAtTailOfSerializedList(&_AsyncQueueList, &(*ppQueryForInfo)->_List);
            SetEvent(_hAutoProxyThreadEvent);

            UnlockAutoProxy();
            fLocked = FALSE;

            error = BlockThreadOnEvent(
                (DWORD_PTR) *ppQueryForInfo,
                INFINITE,   // we need to block forever !
                TRUE        // release BlockedRequestQueue
                );
        }
    }
    else
    {
        InsertAtTailOfSerializedList(&_AsyncQueueList, &(*ppQueryForInfo)->_List);
        SetEvent(_hAutoProxyThreadEvent);
    }

quit:

    if ( fLocked )
    {
        UnlockAutoProxy();
        fLocked = FALSE;
    }

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::ProcessProxyQueryForInfo(
    IN OUT AUTO_PROXY_ASYNC_MSG **ppQueryForInfo
    )

/*++

Routine Description:

    Performs a query for proxy information using an external DLL's entry points to
      anwser our query.  If we are not on the correct thread, we call QueueAsyncAutoProxyRequest
      to marshall our call across to it.

Arguments:

    ppQueryForInfo - Pointer to pointer to Message object that contains state information
                        used in the query.   If the object needs to be allocated on the heap
                        then the pointer will change to reflect the new object ptr.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    AUTO_PROXY_LIST_ENTRY * papleAutoProxy;
    DWORD error = ERROR_SUCCESS;
    BOOL fUnlocked = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::ProcessProxyQueryForInfo",
                "%x",
                ppQueryForInfo
                ));


    INET_ASSERT(ppQueryForInfo);
    INET_ASSERT(*ppQueryForInfo);
    INET_ASSERT((*ppQueryForInfo)->QueryForInfoMessage() == PROXY_MSG_GET_PROXY_INFO);
    INET_ASSERT(IsOnAsyncAutoProxyThread());

    LockAutoProxy();

    //
    // this function should only ever be executed on the auto-proxy thread
    //

    if ( GetState() == AUTO_PROXY_DISABLED )
    {
        //
        // Fall back to a normal proxy query.
        //

        (*ppQueryForInfo)->SetAvoidAsyncCall(TRUE);
        goto quit;
    }

    papleAutoProxy =
            GetSelectedAutoProxyEntry();

    //
    // We should be the only ones to create or destroy
    //  auto-proxy info, therefore we release the holly
    //  lock of auto-proxy.  If I'm wrong another thread
    //  could cause us trouble ...
    //

    UnlockAutoProxy();
    fUnlocked = TRUE;

    if ( papleAutoProxy )
    {
        //
        // If GetProxyInfoEx is supported, we defer to it to handle
        //  everything.
        //

        if ( papleAutoProxy->IsGetProxyInfoEx() )
        {
            error = papleAutoProxy->GetProxyInfoEx(
                *ppQueryForInfo
                );

            goto quit;
        }
        else if ( papleAutoProxy->IsGetProxyInfo() )
        {
            error = papleAutoProxy->GetProxyInfo(
                *ppQueryForInfo
                );

            goto quit;
        }
        else
        {
            //
            // Fall back to a normal proxy query.
            //

            (*ppQueryForInfo)->SetAvoidAsyncCall(TRUE);
        }
    }
    else
    {
        //
        // Fall back to a normal proxy query.
        //

        (*ppQueryForInfo)->SetAvoidAsyncCall(TRUE);
    }


quit:

    if ( !fUnlocked )
    {
        UnlockAutoProxy();
    }

    DEBUG_LEAVE(error);

    return error;
}

VOID
AUTO_PROXY_DLLS::SafeThreadShutdown(
    BOOL fItsTheFinalShutDown
    )
/*++

Routine Description:

    Performs a shutdown of the auto-proxy thread by the auto-proxy thread itself.

Arguments:

    fItsTheFinalShutDown - TRUE, if we are shutting down at the end of a process

Return Value:

    none.

--*/
{
    DEBUG_ENTER((DBG_PROXY,
                None,
                "AUTO_PROXY_DLLS::SafeThreadShutdown",
                "%B",
                fItsTheFinalShutDown
                ));


    //
    // Attempt to Shut down thread due to no-activity OR
    //  due to process shutdown.
    //

    LockAutoProxy();

    if ( IsSerializedListEmpty(&_AsyncQueueList) ||
         fItsTheFinalShutDown )
    {
        //HANDLE hAutoProxyThreadEvent = _hAutoProxyThreadEvent;
        //HANDLE hAutoProxyThread = _hAutoProxyThread;

        //_hAutoProxyThread = NULL;
        //_hAutoProxyThreadEvent = NULL;
        _dwAutoProxyThreadId = 0;

        //CloseHandle(hAutoProxyThreadEvent);
                //CloseHandle(hAutoProxyThread);

        UnlockAutoProxy();

        if ( fItsTheFinalShutDown )
        {
            //DestroyAutoProxyMsgQueue();
            DestroyAutoProxyDll(TRUE); // unloads DLLs and frees up reg vars
        }

        DEBUG_LEAVE(0);

        ExitThread(ERROR_SUCCESS);

        INET_ASSERT(FALSE);  //we will never get here...
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(0);

}

#define NLA_ERROR_RETRY_INTERVAL    (5*60*1000)

class NLA_NET_CHANGE {
private:
    HANDLE          _hLookup;
    WSAOVERLAPPED   _ovlp;
    DWORD           _lastInitAttempt;

    BOOLEAN
    Initialize ();

    BOOLEAN
    EnumerateNetChanges ();
    
public:
    NLA_NET_CHANGE () {
        _ovlp.hEvent = NULL;
        if (GlobalPlatformWhistler &&
                _I_WSALookupServiceBeginW!=NULL) {
            _hLookup = NULL;
            _lastInitAttempt = GetTickCount ()-NLA_ERROR_RETRY_INTERVAL-1;
        }
        else {
#if DBG
            dprintf ("NLA not available: whistler-%ld, lookup:-%#x\n",
                        GlobalPlatformWhistler, _I_WSALookupServiceBeginW);
#endif
            _hLookup = INVALID_HANDLE_VALUE;
        }
    };

    ~NLA_NET_CHANGE () {
        if (_hLookup!=NULL && _hLookup!=INVALID_HANDLE_VALUE) {
#if DBG
            dprintf ("NLA - cleaning up");
#endif
            _I_WSALookupServiceEnd (_hLookup);
            CloseHandle (_ovlp.hEvent);
        }
    };

    BOOLEAN
    IsNetChanged () {
        if (_hLookup!=INVALID_HANDLE_VALUE) {
            if ((_hLookup!=NULL) || 
                    ( ((GetTickCount ()-_lastInitAttempt)
                                        >NLA_ERROR_RETRY_INTERVAL) &&
                        Initialize () ) ) {
                if (HasOverlappedIoCompleted (&_ovlp)) {
#if DBG
                    dprintf ("NLA change detected, status:%lx\n",
                            _ovlp.Internal);
#endif
                    return EnumerateNetChanges ();
                }
            }
        }
        return FALSE;
    };

    HANDLE
    GetChangeEvent () {
        return _ovlp.hEvent;
    };

};



BOOLEAN
NLA_NET_CHANGE::Initialize (
    )
/*++

Routine Description:

    Initializes Network Location Awareness lookup query.

Arguments:


Return Value:

    TRUE    - succes
    FALSE   - failure

--*/
{
    WSAQUERYSETW    qset;
    GUID    nlaServiceClassId = NLA_SERVICE_CLASS_GUID;
    DWORD   qSize;
    INT     error;

    INET_ASSERT (_ovlp.hEvent==NULL);
    INET_ASSERT (_hLookup==NULL);

    //
    // Create event for async notifications.
    //
    _ovlp.hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (_ovlp.hEvent!=NULL) {

        ZeroMemory (&qset, sizeof (qset));
        qset.dwSize = sizeof (qset);
        qset.lpServiceClassId = &nlaServiceClassId;
        qset.dwNameSpace = NS_NLA;

        if (_I_WSALookupServiceBeginW (
                        &qset,
                        LUP_RETURN_NAME|LUP_RETURN_BLOB,
                        &_hLookup)!=SOCKET_ERROR) {
            DEBUG_PRINT (PROXY, INFO, ("Nla Lookup created\n"));
#if DBG
            dprintf ("NLA Lookup created, handle:%#x\n", _hLookup);
#endif

            //
            // Just walk through the net list and setup notification.
            //
            return EnumerateNetChanges ();

        }
        else {
            error = GetLastError ();
            DEBUG_PRINT (PROXY, ERROR,
                ("NLA Lookup creation failed, err: %ld\n",
                error));
#if DBG
            dprintf ("NLA Lookup creation failed, err: %ld\n",error);
#endif
        }
        _hLookup = NULL;
        CloseHandle (_ovlp.hEvent);
        _ovlp.hEvent = NULL;
    }
    else {
        error = GetLastError ();
        DEBUG_PRINT (PROXY, ERROR,
            ("NLA notification event creation failed, err: %ld\n",
            error));
#if DBG
        dprintf ("NLA notification event creation failed, err: %ld\n",
            error);
#endif
    }

    INET_ASSERT (error!=NO_ERROR);

    //
    // Remember when we failed, so we do not retry very often.
    //
    _lastInitAttempt = GetTickCountWrap ();

    return FALSE;
}


BOOLEAN
NLA_NET_CHANGE::EnumerateNetChanges (
    )
/*++

Routine Description:

    Enumerates Network entries returned by the NLA query.
    If this is called after change notification, only
    changes since last enumeration are returned.

Arguments:
    None.

Return Value:
    TRUE    - there were any relevant changes
    FALSE   - no relevant changes.

--*/
{
    DWORD   error = NO_ERROR;

    // Stack buffer which should be sufficient for most cases.
    struct {
        WSAQUERYSETW    set;
        WCHAR           name[128];
        NLA_BLOB        blob;
    } q;
    LPWSAQUERYSETW  pqSet = &q.set;
    DWORD   qSize = sizeof (q), retSize;
    BOOLEAN changed = FALSE;

    INET_ASSERT (_hLookup!=NULL && _hLookup!=INVALID_HANDLE_VALUE);
    INET_ASSERT (_ovlp.hEvent!=NULL);
    INET_ASSERT (HasOverlappedIoCompleted (&_ovlp));

    do {// Outer loop - keep calling while we are getting notifications.

        do {// Inner loop - keep calling while enumerating through networks.
            retSize = qSize;
            error = _I_WSALookupServiceNextW (
                            _hLookup,
                            0,
                            &retSize,
                            pqSet);
            if (error!=SOCKET_ERROR) {
                INET_ASSERT (error==NO_ERROR);
                //
                // Success, see if results in this query are relevant
                //
                DEBUG_PRINT (PROXY, INFO,
                             ("NLA change for %ws-%lx\n",
                                 pqSet->lpszServiceInstanceName,
                                 pqSet->dwOutputFlags));
#if DBG
                dprintf ("NLA change for %ws-%lx\n",
                                 pqSet->lpszServiceInstanceName,
                                 pqSet->dwOutputFlags);
#endif
                if ((pqSet->lpBlob!=NULL) &&
                        (pqSet->lpBlob->pBlobData!=NULL) &&
                        (((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->header.type==NLA_INTERFACE) ) {
#if DBG
                    dprintf ("    type:%ld, speed:%ld, name: %s\n",
                                ((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->data.interfaceData.dwType,
                                ((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->data.interfaceData.dwSpeed,
                                ((LPNLA_BLOB)pqSet->lpBlob->pBlobData)->data.interfaceData.adapterName);
#endif
                    changed = TRUE;
                }
            }
            else {
                error = GetLastError ();
                INET_ASSERT (error!=NO_ERROR);
                if (error==WSAEFAULT) {

                    INET_ASSERT (qSize<retSize);

                    //
                    // Not enough space for query results.
                    // Allocate whatever is requested.
                    // First free what we have know is necessary.
                    //
                    if (pqSet!=NULL && pqSet!=&q.set) {
                        FREE_MEMORY (pqSet);
                    }
                    pqSet = (LPWSAQUERYSETW)ALLOCATE_MEMORY (LMEM_FIXED, retSize);
                    if (pqSet!=NULL) {
                        qSize = retSize;
                        error = NO_ERROR;
                    }
                    else {
                        DEBUG_PRINT (PROXY, ERROR,
                            ("NLA - Failed to allocate %ld bytes for query\n",
                            retSize));
#if DBG
                        dprintf 
                            ("NLA - Failed to allocate %ld bytes for query\n",
                            retSize);
#endif
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
        while ( error==NO_ERROR );

        if (error == WSA_E_NO_MORE) {
            WSACOMPLETION   wsacmpl;
            DWORD           count;

            //
            // This is expected error indicating that we got all that
            // was available at the moment. Set up new notification.
            //
            wsacmpl.Type = NSP_NOTIFY_EVENT;
            wsacmpl.Parameters.Event.lpOverlapped = &_ovlp;
            error = _I_WSANSPIoctl (_hLookup, SIO_NSP_NOTIFY_CHANGE, NULL, 0, NULL, 0, &count, &wsacmpl);
            if (error!=SOCKET_ERROR) {
                //
                // Something has changed, we need to enumerate again.
                //
                INET_ASSERT (error==NO_ERROR);
#if DBG
                dprintf ("NLA notification signaled immediately");
#endif
            }
            else {
                //
                // Failure, get the error and get out.
                //
                error = GetLastError ();
                INET_ASSERT (error!=NO_ERROR);
            }
        }
    }
    while (error==NO_ERROR);

    if (pqSet!=NULL && pqSet!=&q.set) {
        FREE_MEMORY (pqSet);
    }
    else {
        INET_ASSERT (qSize==sizeof (q));
    }

    if (error!=WSA_IO_PENDING) {
        DEBUG_PRINT (PROXY, ERROR,
            ("NLA - Failed to setup notification, error: %ld\n",
            error));
#if DBG
        dprintf (
            "NLA - Failed to setup notification, error: %ld\n",
            error);
#endif
        //
        // Error other then pending means that we failed.
        // Cleanup everything - query will get recreated
        // next time someone asks for changes.
        //
        CloseHandle (_ovlp.hEvent);
        _ovlp.hEvent = NULL;
        _I_WSALookupServiceEnd (_hLookup);
        _hLookup = NULL;
        //
        // Remember when we failed, so we do not retry very often.
        //
        _lastInitAttempt = GetTickCountWrap ();
    }


    return changed;
}


DWORD
AUTO_PROXY_DLLS::DoThreadProcessing(
    VOID
    )
/*++

Routine Description:

    Main function for the auto-proxy thread, maintains a generic loop
      that dispatchs events/messages sent to our thread for processing

Arguments:

    none.

Return Value:

    none.

--*/
{
    DWORD error  = ERROR_SUCCESS;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HANDLE EventArray[2];
    NLA_NET_CHANGE  nlaChange;
    BOOLEAN         needRefresh;

    EventArray[0] = _hAutoProxyThreadEvent;

    INET_ASSERT(IsOnAsyncAutoProxyThread());
    INET_ASSERT(_hAutoProxyStartEvent);

    SetEvent(_hAutoProxyStartEvent);

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // Mark ourselves as the Auto-proxy thread...
    //

    _InternetSetAutoProxy(lpThreadInfo);

    while ( TRUE )
    {
        BOOLEAN networkChanged;
        //
        // 1. Check for shut down.
        //

        if ( _fInAutoProxyThreadShutDown )
        {
            SafeThreadShutdown(GlobalDynaUnload);
        }


        //
        // 2. Check for timer causing a refresh of registry settings
        //    and network location changes,
        //      thus causing a redownload of settings
        //    Be carefull to call both functions since they have side-effects.
        //

        needRefresh = nlaChange.IsNetChanged ();
        needRefresh = ChkForAndUpdateTimerCounter() || needRefresh;
        if (needRefresh)
        {

            //
            // Finally, start a download of the new stuff.
            //

            error = StartDownloadOfProxyInfo(FALSE /*full refresh*/);
        }

        //
        // 3. Wait for new messages to come in,
        //      for shutdown we should pass right past it
        //


        error = WaitForMultipleObjects(
                    (EventArray[1]=nlaChange.GetChangeEvent())==NULL ? 1 : 2,
                    EventArray, 
                    FALSE,
                    _dwWaitTimeOut
                    );
        if (error==WAIT_OBJECT_0+1) {
            //
            // NLA change identified, skip processing, just redownload.
            //
#if DBG
            dprintf ("NLA change event signalled\n");
#endif
            continue;
        }


        //
        // 4. Check to see if we're ready to shut down the thread,
        //    due to a process termination or whatnot.
        //

        if ( _fInAutoProxyThreadShutDown )
        {
            SafeThreadShutdown(TRUE);
        }

        GlobalProxyInfo.CheckForExpiredEntries();

        //
        // 5. If we've idled let us shut down until we're needed again
        //

        //
        // BUGBUG [arthurbi] Theoredically this should work,
        //   and the thread should shutdown on idle, too risky?
        //

        //if ( error == WAIT_FAILED && GetLastError() == WAIT_TIMEOUT)
        //{
            //SafeThreadShutdown(FALSE);
        //}

        //
        // 6. Walk and process the list the messages to our thread asking for
        //     information or reinitalization
        //

        error = ProcessAsyncAutoProxyRequest();

        INET_ASSERT( (error == ERROR_INTERNET_SHUTDOWN) ? _fInAutoProxyThreadShutDown : TRUE );
    }

quit:

    return error;
}

DWORD
AUTO_PROXY_DLLS::ProcessAsyncAutoProxyRequest(
    VOID
    )

/*++

Routine Description:

    Walks the list of queued messages and processes them one by one by
      either rerunning the download/initalization or executing a query for
      proxy information

Arguments:

    none.

Return Value:

    none.

--*/

{

    DWORD error = ERROR_SUCCESS;
    BOOL fForceRefresh;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::ProcessAsyncAutoProxyRequest",
                ""
                ));

    while (!IsSerializedListEmpty(&_AsyncQueueList)) {

        //
        // If we're shuting down, then quit right away
        //

        if ( _fInAutoProxyThreadShutDown )
        {
            error = ERROR_INTERNET_SHUTDOWN;
            goto quit;

        }

        LPVOID entry = SlDequeueHead(&_AsyncQueueList);
        AUTO_PROXY_ASYNC_MSG *pQueryForInfo =
            CONTAINING_RECORD(entry, AUTO_PROXY_ASYNC_MSG, _List);


        //
        // If the request has been unblocked, then destroy
        //   the request. ( this is typically due to cancel )
        //

        if ( pQueryForInfo->IsBlockUntilCompletetion() )
        {
            DWORD dwBlockCnt;

            if ( pQueryForInfo->IsBlockedOnFsm() )
            {

                dwBlockCnt = CheckForBlockedWorkItems(
                                1,
                                (DWORD_PTR) pQueryForInfo // blocked on message
                                );

                if ( dwBlockCnt == 0 )
                {
                    delete pQueryForInfo;
                    continue;
                }
            }
        }

        switch ( pQueryForInfo->QueryForInfoMessage() )
        {
            case PROXY_MSG_INIT:

                fForceRefresh = pQueryForInfo->IsForceRefresh();

                //
                // First peak ahead to make sure we're not asked to download
                //  the same darn thing over and over again.
                //

                while (!IsSerializedListEmpty(&_AsyncQueueList))
                {

                    LPVOID entry = SlDequeueHead(&_AsyncQueueList);
                    AUTO_PROXY_ASYNC_MSG *pQueryForInfo =
                        CONTAINING_RECORD(entry, AUTO_PROXY_ASYNC_MSG, _List);

                    if ( pQueryForInfo->QueryForInfoMessage() == PROXY_MSG_INIT )
                    {
                        INET_ASSERT(!pQueryForInfo->IsBlockUntilCompletetion());
                        if ( pQueryForInfo->IsForceRefresh() ) {
                            fForceRefresh = TRUE;
                        }
                        delete pQueryForInfo;
                    }
                    else
                    {
                        InsertAtHeadOfSerializedList(&_AsyncQueueList, &pQueryForInfo->_List);
                        break;
                    }
                }

                //
                // Finally, start a download of the new stuff.
                //

                if ( error == ERROR_SUCCESS )
                {
                    error = StartDownloadOfProxyInfo(fForceRefresh);
                }

                if ( error == ERROR_INTERNET_SHUTDOWN )
                {
                    goto quit;
                }

                break;

            case PROXY_MSG_SELF_DESTRUCT:

                //
                // Destroy ourselves and AUTO_PROXY_DLLS object.
                //
                //

                SafeThreadShutdown(TRUE);

                INET_ASSERT(FALSE); // never returns...

                break;


            case PROXY_MSG_GET_PROXY_INFO:

                //
                // If we've been updated then we need refresh settings from 
                //   the net.
                //

                if ( (_dwUpdatedProxySettingsVersion != _ProxySettings.dwCurrentSettingsVersion) ) 
                {
                    error = StartDownloadOfProxyInfo(FALSE /* no full refresh*/);
                }


                //
                // The strait call into GetProxyInfo
                //

                error = ProcessProxyQueryForInfo(
                    &pQueryForInfo
                    );

                if ( error == ERROR_INTERNET_SHUTDOWN )
                {
                    goto quit;
                }

                break;


            case PROXY_MSG_SET_BAD_PROXY:
            case PROXY_MSG_DEINIT:
            case PROXY_MSG_INVALID:
            default:

                INET_ASSERT(FALSE);
                break;
        }

        //
        // Wake up the caller if they are blocking on this completeion
        //

        if ( pQueryForInfo->IsBlockUntilCompletetion() )
        {
            SignalAsyncRequestCompleted(pQueryForInfo); // the thread that gets woken up now owns the object
        }
        else
        {
            delete pQueryForInfo;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::SignalAsyncRequestCompleted(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForInfo
    )
/*++

Routine Description:

    Notifies a blocked thread or FSM that we have completed its message based request and
      it now can continue.

Arguments:

    pQueryForInfo - the orginating request

Return Value:

    none.

--*/

{
    DWORD dwCntUnBlocked;

    INET_ASSERT ( pQueryForInfo );

    if ( pQueryForInfo->IsBlockedOnFsm() )
    {
        dwCntUnBlocked = UnblockWorkItems(
                            1,
                            (DWORD_PTR) pQueryForInfo, // blocked on message
                            ERROR_SUCCESS,
                            TP_NO_PRIORITY_CHANGE
                            );

        //
        // If we were unable to unblock it, then we need to free it.
        //

        if ( dwCntUnBlocked == 0 )
        {
            delete pQueryForInfo;
            pQueryForInfo = NULL;
        }

    }
    else
    {

        dwCntUnBlocked = SignalThreadOnEvent(
                            (DWORD_PTR) pQueryForInfo,  // blocked on message
                            1,                          // should only be one item thats blocked by us
                            ERROR_SUCCESS
                            );

        //if ( dwCntUnBlocked == 0 )
        //{
        //    delete pQueryForInfo;
        //    pQueryForInfo = NULL;
        //}

    }

    return ERROR_SUCCESS;
}

VOID
AUTO_PROXY_DLLS::WipeProxySettings(
    LPINTERNET_PROXY_INFO_EX lpProxySettings
    )

/*++

Routine Description:

    Frees proxy settings

Arguments:

    lpProxySettings - pointer to listing of proxy settings

Return Value:

    none.

--*/

{
    if ( lpProxySettings )
    {
        if ( lpProxySettings->lpszConnectionName ) {
            FREE_MEMORY(lpProxySettings->lpszConnectionName);
        }

        if ( lpProxySettings->lpszProxy ) {
            FREE_MEMORY(lpProxySettings->lpszProxy);
        }

        if ( lpProxySettings->lpszProxyBypass ) {
            FREE_MEMORY(lpProxySettings->lpszProxyBypass);
        }

        if ( lpProxySettings->lpszLastKnownGoodAutoConfigUrl ) {
            FREE_MEMORY(lpProxySettings->lpszLastKnownGoodAutoConfigUrl);
        }

        if (lpProxySettings->lpszAutoconfigUrl) {
            FREE_MEMORY(lpProxySettings->lpszAutoconfigUrl);
        }

        if (lpProxySettings->lpszAutoconfigSecondaryUrl) {
            FREE_MEMORY(lpProxySettings->lpszAutoconfigSecondaryUrl);
        }

        if (lpProxySettings->pdwDetectedInterfaceIp) {
            FREE_MEMORY(lpProxySettings->pdwDetectedInterfaceIp);
        }
    }
}


DWORD
AUTO_PROXY_DLLS::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess,
    IN BOOL fAllowOverwrite
    )

/*++

Routine Description:

    Write Auto-proxy Settings on the current auto-proxy object,
        this writes the settings into the object, but does not
        refresh it.

Arguments:

    lpProxySettings - List of new settings that we'd like to write

    fAllowOverwrite - Allow update of the settings in the object even if the version counter
                    hasn't changed

Return Value:

    DWORD
        ERROR_SUCCESS - if we have a valid proxy config

        other-errors - if we were not able to make the settings

--*/


{
    DWORD error = ERROR_SUCCESS;
    BOOL fGoPending = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::SetProxySettings",
                "%x %B, %B",
                lpProxySettings,
                fModifiedInProcess,
                fAllowOverwrite
                ));

    LockAutoProxy();

    if ( fAllowOverwrite ||
         lpProxySettings->dwCurrentSettingsVersion == _ProxySettings.dwCurrentSettingsVersion )
    {
        BOOL fConnectionNameChange = FALSE;

        _fModifiedInProcess = fModifiedInProcess;

        UPDATE_GLOBAL_PROXY_VERSION();

        //
        // Check to see if we're changing the connection name,
        //  if so than this means we should plan on resetting
        //  the version below, so that we can redetect the new 
        //  connection.
        //

        if ( ! IsConnectionMatch( 
                _ProxySettings.lpszConnectionName,
                lpProxySettings->lpszConnectionName))
        {
            fConnectionNameChange = TRUE;
        }

        WipeProxySettings();

        _ProxySettings = *lpProxySettings;

        if ( fModifiedInProcess ) {
            // update version, only if we don't plan to write out these settings
            _ProxySettings.dwCurrentSettingsVersion++;
        }

        //
        // minus -1 so that when we get to the auto-proxy thread,
        //  we can reload/detect or do what's needed to keep settings current
        //

        if ( _dwUpdatedProxySettingsVersion != _ProxySettings.dwCurrentSettingsVersion ||             
             _dwUpdatedProxySettingsVersion == 0 /* init state */ ||
             fConnectionNameChange /* connection switch */ ) 
        {
            _dwUpdatedProxySettingsVersion = (DWORD) (_ProxySettings.dwCurrentSettingsVersion - 1);
            fGoPending = TRUE;
        }

        //
        // we shouldn't care about these settings,
        //   but we need to copy them anyway in
        //   case we save the stuff to the registry store
        //

        _ProxySettings.lpszProxy =
            lpProxySettings->lpszProxy ?
            NewString(lpProxySettings->lpszProxy) :
            NULL;

        _ProxySettings.lpszProxyBypass =
            lpProxySettings->lpszProxyBypass ?
            NewString(lpProxySettings->lpszProxyBypass) :
            NULL;

        _ProxySettings.lpszConnectionName =
            lpProxySettings->lpszConnectionName ?
            NewString(lpProxySettings->lpszConnectionName) :
            NULL;


        //
        // Copy strings, cause we may be on another thread
        //

        _ProxySettings.lpszAutoconfigUrl =
            lpProxySettings->lpszAutoconfigUrl ?
            NewString(lpProxySettings->lpszAutoconfigUrl) :
            NULL;

        _ProxySettings.lpszAutoconfigSecondaryUrl = 
            lpProxySettings->lpszAutoconfigSecondaryUrl ?
            NewString(lpProxySettings->lpszAutoconfigSecondaryUrl) :
            NULL;

        _ProxySettings.lpszLastKnownGoodAutoConfigUrl =
            lpProxySettings->lpszLastKnownGoodAutoConfigUrl ?
            NewString(lpProxySettings->lpszLastKnownGoodAutoConfigUrl) :
            NULL;

        //
        // Copy of IP host addresses from last detection
        //

        if ( lpProxySettings->dwDetectedInterfaceIpCount > 0 &&
             lpProxySettings->pdwDetectedInterfaceIp != NULL )
        {
            _ProxySettings.pdwDetectedInterfaceIp = (LPDWORD)
                ALLOCATE_MEMORY(LMEM_FIXED, lpProxySettings->dwDetectedInterfaceIpCount
                                * sizeof(DWORD));

            if (_ProxySettings.pdwDetectedInterfaceIp == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            memcpy(_ProxySettings.pdwDetectedInterfaceIp, lpProxySettings->pdwDetectedInterfaceIp,
                        lpProxySettings->dwDetectedInterfaceIpCount * sizeof(DWORD));
        }


        if (fGoPending &&
            IsConfigValidForAutoProxyThread())            
        {
            //
            // Enable a forced refresh if the user orders it through the UI,
            //   for unknown new connections we don't block the user on auto-detect,
            //   since he didn't really order it
            //

            if ( IsStaticFallbackEnabled() ) {
                SetState(AUTO_PROXY_PENDING);
            } else {
                SetState(AUTO_PROXY_BLOCKED);
            }
        }
    }

quit:

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
AUTO_PROXY_DLLS::GetProxySettings(
    OUT LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion
    )

/*++

Routine Description:

    Reads Auto-proxy Settings off the current auto-proxy object,
        this allocates individual fields as needed to store the result

Arguments:

    lpProxySettings - Returns the result of the auto-proxy settings

Return Value:

    DWORD
        ERROR_SUCCESS - if we have a valid proxy config

        other-errors - if we were not able to make the settings

--*/

{
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::GetProxySettings",
                "%x %B",
                lpProxySettings
                ));

    LockAutoProxy();

    if ( fCheckVersion &&
         lpProxySettings->dwCurrentSettingsVersion == _ProxySettings.dwCurrentSettingsVersion )
    {
        goto quit; // no change
    }


    *lpProxySettings = _ProxySettings;

    //
    // Copy strings, cause we may be on another thread
    //

    lpProxySettings->lpszProxy =
        _ProxySettings.lpszProxy ?
        NewString(_ProxySettings.lpszProxy) :
        NULL;

    lpProxySettings->lpszProxyBypass =
        _ProxySettings.lpszProxyBypass ?
        NewString(_ProxySettings.lpszProxyBypass) :
        NULL;

    lpProxySettings->lpszConnectionName =
        _ProxySettings.lpszConnectionName ?
        NewString(_ProxySettings.lpszConnectionName) :
        NULL;

    lpProxySettings->lpszAutoconfigUrl =
        _ProxySettings.lpszAutoconfigUrl ?
        NewString(_ProxySettings.lpszAutoconfigUrl) :
        NULL;

    lpProxySettings->lpszAutoconfigSecondaryUrl = 
        _ProxySettings.lpszAutoconfigSecondaryUrl ?
        NewString(_ProxySettings.lpszAutoconfigSecondaryUrl) :
        NULL;

    lpProxySettings->lpszLastKnownGoodAutoConfigUrl =
        _ProxySettings.lpszLastKnownGoodAutoConfigUrl ?
        NewString(_ProxySettings.lpszLastKnownGoodAutoConfigUrl) :
        NULL;

    //
    // Copy of IP host addresses from last detection
    //

    if ( _ProxySettings.dwDetectedInterfaceIpCount > 0 &&
         _ProxySettings.pdwDetectedInterfaceIp != NULL )
    {
        lpProxySettings->pdwDetectedInterfaceIp = (LPDWORD)
            ALLOCATE_MEMORY(LMEM_FIXED, _ProxySettings.dwDetectedInterfaceIpCount
                            * sizeof(DWORD));

        if (lpProxySettings->pdwDetectedInterfaceIp == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        memcpy(lpProxySettings->pdwDetectedInterfaceIp, _ProxySettings.pdwDetectedInterfaceIp,
                    _ProxySettings.dwDetectedInterfaceIpCount * sizeof(DWORD));
    }

quit:

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
AUTO_PROXY_DLLS::RefreshProxySettings(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Syncronizes the Auto-Proxy engine with the state of the various settings,
      and updates the various state keepers of the results.

        - If there is no proxy settings, or auto-proxy is not needed or not detected,
          we disable the auto-proxy system.

        - If we have auto-proxy information or need to detect for some, then we fire up
            the auto-proxy thread and send it a message to initalize itself.

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/


{
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::RefreshProxySetting