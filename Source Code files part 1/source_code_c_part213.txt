;

    pNode = new ListNode<Type>(item);
    if (pNode) {
        _iCount++;
       pNode->SetNext(_pHead);
       pNode->SetPrev(NULL);
       if (_pHead == NULL) {
           _pTail = pNode;
       }
       else {
           _pHead->SetPrev(pNode);
       }
       _pHead = pNode;
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE List<Type>::AddSorted(const Type &item, 
                                                     LPVOID pfn)
{
    ListNode<Type>           *pNode = NULL;
    LISTNODE           pCurrNode = NULL;
    LISTNODE           pPrevNode = NULL;
    int                      i;
    Type                     curItem;

    LONG (*pFN) (const Type item1, const Type item2);

    pFN = (LONG (*) (const Type item1, const Type item2))pfn;

    if(_pHead == NULL) {
        return AddHead(item);
    }
    else {
        pCurrNode = GetHeadPosition();
        curItem = ((ListNode<Type> *) pCurrNode)->GetItem();
        for (i = 0; i < _iCount; i++) {
            if (pFN(item, curItem) < 1) {
                pNode = new(ListNode<Type>(item));
                pNode->SetPrev((ListNode<Type> *)pPrevNode);
                pNode->SetNext((ListNode<Type> *)pCurrNode);
                if(pPrevNode) {
                    ((ListNode<Type> *)pPrevNode)->SetNext(pNode);
                }
                else {
                    _pHead = pNode;
                }
                _iCount++;
                break;
            }
            pPrevNode = pCurrNode;
            curItem = GetNext(pCurrNode);
            if(i+1 == _iCount)
                return AddTail(item);
        }
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE List<Type>::AddTail(const Type &item)
{
    ListNode<Type>                   *pNode = NULL;
    
    pNode = new ListNode<Type>(item);
    if (pNode) {
        _iCount++;
        if (_pTail) {
            pNode->SetPrev(_pTail);
            _pTail->SetNext(pNode);
            _pTail = pNode;
        }
        else {
            _pHead = _pTail = pNode;
        }
    }

    return (LISTNODE)pNode;
}

template <class Type> int List<Type>::GetCount()
{
    return _iCount;
}

template <class Type> LISTNODE List<Type>::GetHeadPosition()
{
    return (LISTNODE)_pHead;
}

template <class Type> LISTNODE List<Type>::GetTailPosition()
{
    return (LISTNODE)_pTail;
}

template <class Type> Type List<Type>::GetNext(LISTNODE &pNode)
{
    Type                  item;
    ListNode<Type>       *pListNode = (ListNode<Type> *)pNode;

    // Faults if you pass NULL
    item = pListNode->GetItem();
    pNode = (LISTNODE)(pListNode->GetNext());

    return item;
}

template <class Type> void List<Type>::RemoveAll()
{
    int                        i;
    LISTNODE                   listNode = NULL;
    ListNode<Type>            *pDelNode = NULL;

    listNode = GetHeadPosition();

    for (i = 0; i < _iCount; i++) {
        pDelNode = (ListNode<Type> *)listNode;
        GetNext(listNode);
        delete pDelNode;
    }
    
    _iCount = 0;
    _pHead = NULL;
    _pTail = NULL;
}

template <class Type> void List<Type>::RemoveAt(LISTNODE pNode)
{
    ListNode<Type>           *pListNode = (ListNode<Type> *)pNode;
    ListNode<Type>           *pPrevNode = NULL;
    ListNode<Type>           *pNextNode = NULL;

    if (pNode) {
        pPrevNode = pListNode->GetPrev();
        pNextNode = pListNode->GetNext();

        if (pPrevNode) {
            pPrevNode->SetNext(pNextNode);
            if (pNextNode) {
                pNextNode->SetPrev(pPrevNode);
            }
            else {
                // We're removing the last node, so we have a new tail
                _pTail = pPrevNode;
            }
            delete pNode;
            pNode = NULL;
        }
        else {
            // No previous, so we are the head of the list
            _pHead = pNextNode;
            if (pNextNode) {
                pNextNode->SetPrev(NULL);
            }
            else {
                // No previous, or next. There was only one node.
                _pHead = NULL;
                _pTail = NULL;
            }
            delete pNode;
        }

        _iCount--;
    }
}
        

template <class Type> LISTNODE List<Type>::Find(const Type &item)
{
    int                      i;
    Type                     curItem;
    LISTNODE                 pNode = NULL;
    LISTNODE                 pMatchNode = NULL;
    ListNode<Type> *         pListNode = NULL;

    pNode = GetHeadPosition();
    for (i = 0; i < _iCount; i++) {
        pListNode = (ListNode<Type> *)pNode;
        curItem = GetNext(pNode);
        if (curItem == item) {
            pMatchNode = (LISTNODE)pListNode;
            break;
        }
    }

    return pMatchNode;
}

template <class Type> Type List<Type>::GetAt(LISTNODE pNode)
{
    ListNode<Type>                *pListNode = (ListNode<Type> *)pNode;

    // Faults if pListNode == NULL
    return pListNode->GetItem();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\adfassminfo.cs ===
using System.Reflection;

[assembly:AssemblyCultureAttribute("")]
[assembly:AssemblyVersionAttribute("1.0.1125.0")]
[assembly:AssemblyKeyFileAttribute("../ADFKey.snk")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\macros.h ===
#pragma once

#if DBG
#define ASSERT(x) if (!(x)) { EnsureDebuggerPresent(); DebugBreak(); }
#else
#define ASSERT(x)
#endif

// The only error we don't break on.
#define PREDICATE _hr == E_ABORT
#define HEAPCHK if (!DoHeapValidate()) ASSERT(FALSE);

#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; };
#define SAFEDELETEARRAY(p) if ((p) != NULL) { delete[] (p); (p) = NULL; };
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };


#define MAKE_ERROR_MACROS_STATIC(_x)  HRESULT &_hr = _x;
#define IF_FAILED_EXIT(_x) do {_hr = (_x);  if (FAILED(_hr)) { ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_NULL_EXIT(_x, _y) do {if ((_x) == NULL) {_hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_FALSE_EXIT(_x, _y) do { if ((_x) == FALSE) {_hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_ALLOC_FAILED_EXIT(_x) do { if ((_x) == NULL) {_hr = E_OUTOFMEMORY; ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_WIN32_FAILED_EXIT(_x) do { _hr = (HRESULT_FROM_WIN32(_x)); if (FAILED(_hr)) { ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_WIN32_FALSE_EXIT(_x) do { if (!_x) { DWORD dw=GetLastError(); _hr = (dw? HRESULT_FROM_WIN32(dw) : E_FAIL ); } else {_hr = S_OK;}  if (FAILED(_hr)) {ASSERT(PREDICATE); goto exit;} } while (0)
#define IF_TRUE_EXIT(_x, _y) do { if (_x) { _hr = _y; goto exit;} } while (0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\manifestdata.h ===
#pragma once

#include <comdef.h>
#include <thash.h>

class CManifestDataObject
{
public:
    CManifestDataObject();
    ~CManifestDataObject();

    STDMETHOD(Set)(
        /* in */ LPVOID pvProperty, 
        /* in */ DWORD cbProperty,
        /* in */ DWORD dwType);
    
    STDMETHOD(Get)(
        /* out */ LPVOID *ppvProperty,
        /* out */ DWORD *pcbProperty,
        /* out */ DWORD *pdwType);

    STDMETHOD(Assign)(
        /* in */ CManifestDataObject& dataObj);

private:
    DWORD _dwType;

    CString _sData;
    IUnknown* _pIUnknownData;
    DWORD _dwData;

    DWORD    _dwSig;
    HRESULT  _hr;
};


class CManifestData : public IManifestData
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(Set)(
        /* in */ LPCWSTR pwzPropertyId,
        /* in */ LPVOID pvProperty,
        /* in */ DWORD cbProperty,
        /* in */ DWORD dwType);
    
    STDMETHOD(Get)(
        /* in */ LPCWSTR pwzPropertyId,
        /* out */ LPVOID *ppvProperty,
        /* out */ DWORD *pcbProperty,
        /* out */ DWORD *pdwType);

    // indexed Set/Get
    STDMETHOD(Set)(
        /* in */ DWORD dwPropertyIndex,
        /* in */ LPVOID pvProperty,
        /* in */ DWORD cbProperty,
        /* in */ DWORD dwType);

    STDMETHOD(Get)(
        /* in */ DWORD dwPropertyIndex,
        /* out */ LPVOID *ppvProperty,
        /* out */ DWORD *pcbProperty,
        /* out */ DWORD *pdwType);

    STDMETHOD(GetType)(
        /* out */ LPWSTR *ppwzType);

    CManifestData();
    ~CManifestData();

private:

    HRESULT Init();

    THashTable<CString, CManifestDataObject> _DataTable;

    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

friend HRESULT CreateManifestData(LPCWSTR pwzDataType, LPMANIFEST_DATA* ppManifestData);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\manifestemit.h ===
#pragma once
#include <comdef.h>

class CAssemblyManifestEmit : public IAssemblyManifestEmit
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(ImportManifestInfo)(
        /* in */ LPASSEMBLY_MANIFEST_IMPORT pManImport);

    STDMETHOD(SetDependencySubscription)(
        /* in */ LPASSEMBLY_MANIFEST_IMPORT pManImport,
        /* in */ LPWSTR pwzManifestUrl);

    STDMETHOD(Commit)();

    ~CAssemblyManifestEmit();

    HRESULT static InitGlobalCritSect();
    void static DelGlobalCritSect();

private:

    // Instance specific data
    DWORD                    _dwSig;
    HRESULT                  _hr;
    LONG                     _cRef;
    IXMLDOMDocument2        *_pXMLDoc;
    IXMLDOMNode             *_pAssemblyNode;
    IXMLDOMNode             *_pDependencyNode;
    IXMLDOMNode             *_pApplicationNode;
    BSTR                     _bstrManifestFilePath;

    // Globals
    static CRITICAL_SECTION   g_cs;
    
    CAssemblyManifestEmit();

    HRESULT Init(LPCOLESTR wzManifestFilePath);

    HRESULT ImportAssemblyNode(LPASSEMBLY_MANIFEST_IMPORT pManImport);

friend HRESULT CreateAssemblyManifestEmit(LPASSEMBLY_MANIFEST_EMIT* ppEmit, 
    LPCOLESTR pwzManifestFilePath, MANIFEST_TYPE eType);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\cstrings.h ===
#pragma once


// Two flavors of allocator.
#define CRT_ALLOC 0
#define COM_ALLOC 1

// Buffer alloc chungks must be a power of 2.
#define BUFFER_ALLOCATION_SIZE 0x40
#define ROUNDUPTOPOWEROF2(bytesize, powerof2) (((bytesize) + (powerof2) - 1) & ~((powerof2) - 1))

// MAXCHARCOUNT is nice for simple overflow calculations; it allows rollover checks only on the character 
// counts themselves and not also again on the underlying byte counts passed to memcpy.
// Find the right include for this.
#define ULONG_MAX 0xffffffff
#define MAXCHARCOUNT (ULONG_MAX / sizeof(WCHAR))
#define BADMATH HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW)
#define OVERFLOW_CHECK1(_x) do { if (_x > MAXCHARCOUNT) { _hr = BADMATH; ASSERT(PREDICATE); goto exit; } } while (0)
#define OVERFLOW_CHECK2(_x, _y) do { if ((_y > MAXCHARCOUNT) || (_y < _x)) { _hr = BADMATH; ASSERT(PREDICATE); goto exit; } } while (0)

#define DEFAULT_STACK_SIZE 32


//////////////////////////////////////////////////////////////////////////////
//
// CBaseString
//
//////////////////////////////////////////////////////////////////////////////
template <ULONG T> class CBaseString
{
    public:

    enum AllocFlags
    {
        COM_Allocator = 0,
        CRT_Allocator
    };

    enum HashFlags
    {
        CaseInsensitive = 0,
        CaseSensitive 
    };


    DWORD     _dwSig;
    HRESULT    _hr;
    WCHAR      _wz[T];
    LPWSTR     _pwz;          // Str ptr.
    DWORD     _cc;           // String length
    DWORD     _ccBuf;        // Buffer length
    AllocFlags    _eAlloc;       // Allocator
    BOOL          _fLocked;  // Accessor lock    

    // ctor
    CBaseString();
    
    // ctor w/ allocator
    CBaseString(AllocFlags eAlloc);
    
    // dtor
    ~CBaseString();

    operator LPCWSTR ( ) const;

   // Used by accessor.
    HRESULT Lock();
    HRESULT UnLock();
    
    // Allocations
    HRESULT ResizeBuffer(DWORD ccNew);

    // Deallocations
    VOID FreeBuffer();

    // Assume control for a buffer.
    HRESULT TakeOwnership(WCHAR* pwz, DWORD cc = 0);
    
    // Release control.
    HRESULT ReleaseOwnership(LPWSTR *ppwz);
            
    // Direct copy assign from string.
    HRESULT Assign(LPCWSTR pwzSource, DWORD ccSource = 0);

    // Direct copy assign from CBaseString
    HRESULT Assign(CBaseString& sSource);

    // Append given wchar string.
    HRESULT Append(LPCWSTR pwzSource, DWORD ccSource = 0);

    // Append given CBaseString
    HRESULT Append(CBaseString& sSource);

    // Append given number (DWORD)
    HRESULT Append(DWORD dwValue);

    // Compare to string
    HRESULT CompareString(CBaseString& s);

    HRESULT CompareString(LPCWSTR pwz);

    HRESULT LastElement(CBaseString &sSource);

    HRESULT RemoveLastElement();

    HRESULT SplitLastElement(WCHAR wcSeparator, CBaseString &sSource);

    HRESULT StartsWith(LPCWSTR pwzPrefix);

    HRESULT EndsWith(LPCWSTR pwzSuffix);

    DWORD ByteCount();

    DWORD CharCount();
            
    // / -> \ in string
    HRESULT  PathNormalize();

    HRESULT GetHash(LPDWORD pdwhash, DWORD dwFlags);

    HRESULT Get65599Hash(LPDWORD pdwHash, DWORD dwFlags);

};





//-----------------------------------------------------------------------------
// ctor
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::CBaseString()
{
    _dwSig = 'NRTS';
    _wz[0] = 'L\0';
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;
    _eAlloc = CRT_Allocator;
    _hr = S_OK;
    _fLocked = FALSE;
}


//-----------------------------------------------------------------------------
// ctor w/ allocator
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::CBaseString(AllocFlags eAlloc)
{
    _dwSig = 'NRTS';
    _wz[0] = L'\0';
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;
    _eAlloc = eAlloc;
    _hr = S_OK;
    _fLocked = FALSE;
}


//-----------------------------------------------------------------------------
// dtor
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::~CBaseString()
{
    FreeBuffer();
}

//-----------------------------------------------------------------------------
// operator LPCWSTR
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::operator LPCWSTR () const
{
    return _pwz;
}

//-----------------------------------------------------------------------------
// Lock
//-----------------------------------------------------------------------------
template<ULONG T>HRESULT CBaseString<T>::Lock()
{
    IF_FALSE_EXIT(_fLocked != TRUE, E_UNEXPECTED);
    _fLocked = TRUE;

exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// Lock
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::UnLock()
{
    IF_FALSE_EXIT(_fLocked != FALSE, E_UNEXPECTED);
    _fLocked = FALSE;

exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// ResizeBuffer
// NOTICE: Does not decrease buffer size.
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::ResizeBuffer(DWORD ccNew)
{
    LPWSTR pwzNew = NULL;
    DWORD  ccOriginal = 0;
    DWORD  ccNewRoundUp = 0;
    
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_TRUE_EXIT((ccNew <= _ccBuf), S_OK);
    
    if (!_pwz && (ccNew <= T))
    {
         _pwz = _wz;
        _ccBuf = T;
        goto exit;
    }

    ccNewRoundUp = ROUNDUPTOPOWEROF2(ccNew, BUFFER_ALLOCATION_SIZE);
    OVERFLOW_CHECK2(ccNew, ccNewRoundUp);
    
    if (_eAlloc == CRT_Allocator)
        pwzNew = new WCHAR[ccNewRoundUp];
    else if (_eAlloc == COM_Allocator)        
        pwzNew = (LPWSTR) CoTaskMemAlloc(ccNewRoundUp * sizeof(WCHAR));

    IF_ALLOC_FAILED_EXIT(pwzNew);

    if (_pwz && _cc)
        memcpy(pwzNew, _pwz, _cc * sizeof(WCHAR));
    
    ccOriginal = _cc;
    
    FreeBuffer();
    
    _pwz = pwzNew;
    _cc  = ccOriginal;
    _ccBuf = ccNewRoundUp;

exit:    

    return _hr;
}


//-----------------------------------------------------------------------------
// FreeBuffer
//-----------------------------------------------------------------------------
template<ULONG T> VOID CBaseString<T>::FreeBuffer()
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    if (_pwz == _wz)
        goto exit;
        
    if (_eAlloc == CRT_Allocator)
    {    
        SAFEDELETEARRAY(_pwz);
    }
    else if (_eAlloc == COM_Allocator)
    {
        if (_pwz)
            CoTaskMemFree(_pwz);
    }

exit:

    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;

    return;
}


//-----------------------------------------------------------------------------
// TakeOwnership
//
// Working assumption here is that incoming buffer size if not
// specified is  equal to strlen + 1. If it's bigger, that's fine but
// we won't know about the extra.
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::TakeOwnership(WCHAR* pwz, DWORD cc)
{
    DWORD ccNew = 0, ccLen = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_NULL_EXIT(pwz, E_INVALIDARG);   
    OVERFLOW_CHECK1(cc);

    if (cc)
    {
        ccNew = cc;
    }
    else
    {
        ccLen = lstrlen(pwz);
        ccNew = ccLen+1;
        OVERFLOW_CHECK2(ccLen, ccNew);
    }        

    FreeBuffer();

    _pwz = pwz;
    _cc = _ccBuf = ccNew;

exit:
    return _hr;
}


//-----------------------------------------------------------------------------
// ReleaseOwnership
//-----------------------------------------------------------------------------
template<ULONG T>HRESULT CBaseString<T>::ReleaseOwnership(LPWSTR *ppwz)
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    if (_pwz == _wz)
    {
        IF_ALLOC_FAILED_EXIT(*ppwz = new WCHAR[_ccBuf]);
        memcpy(*ppwz, _wz, _ccBuf * sizeof(WCHAR));
    }
    else
        *ppwz = _pwz;
    
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;

    exit:

    return _hr;
}
        
//-----------------------------------------------------------------------------
// Assign
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Assign(LPCWSTR pwzSource, DWORD ccSource)
{    
    DWORD ccSourceLen = 0;    

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_NULL_EXIT(pwzSource, E_INVALIDARG);
    OVERFLOW_CHECK1(ccSource);
    
    if (!ccSource)
    {
        ccSourceLen = lstrlen(pwzSource);
        ccSource = ccSourceLen + 1;
        OVERFLOW_CHECK2(ccSourceLen, ccSource);
    }

    IF_FAILED_EXIT(ResizeBuffer(ccSource));
     
    _cc = ccSource;

    memcpy(_pwz, pwzSource, _cc * sizeof(WCHAR));

exit:

    return _hr;        
}

//-----------------------------------------------------------------------------
// Assign
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Assign(CBaseString& sSource)
{
    return Assign(sSource._pwz, sSource._cc);
}

//-----------------------------------------------------------------------------
// Append
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Append(LPCWSTR pwzSource, DWORD ccSource)
{
    DWORD ccRequired = 0, ccSourceLen = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_NULL_EXIT(pwzSource, E_INVALIDARG);
    OVERFLOW_CHECK1(ccSource);
    
    if (!ccSource)
    {
        ccSourceLen = lstrlen(pwzSource);
        ccSource = ccSourceLen + 1;
        OVERFLOW_CHECK2(ccSourceLen, ccSource);
    }

    if (_cc)
    {
        ccRequired = _cc -1 + ccSource;
        OVERFLOW_CHECK2(ccSource, ccRequired);
    }
    else
    {
        ccRequired = ccSource;
    }

    IF_FAILED_EXIT(ResizeBuffer(ccRequired));
    
    memcpy(_pwz + (_cc ? _cc-1 : 0), 
        pwzSource, ccSource * sizeof(WCHAR));

    _cc = ccRequired;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// Append
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Append(CBaseString& sSource)
{        
    IF_NULL_EXIT(sSource._pwz, E_INVALIDARG);
    IF_FAILED_EXIT(Append(sSource._pwz, sSource._cc));

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// Append
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Append(DWORD dwValue)
{
    LPWSTR pwzBuf = NULL;

    // ISSUE-05/31/02-felixybc  optimize by using internal buffer if not currently used

    // 2^32 has 10 digits(base 10) + sign + '\0' = 12 WCHAR
    IF_ALLOC_FAILED_EXIT(pwzBuf = new WCHAR[12]);
    pwzBuf[0] = L'\0';

    // ISSUE- check error?
    _ultow(dwValue, pwzBuf, 10);

    IF_FAILED_EXIT(Append(pwzBuf));

exit:
    SAFEDELETEARRAY(pwzBuf);
    return _hr;
}

//-----------------------------------------------------------------------------
// CompareString
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::CompareString(CBaseString& s)
{
    return CompareString(s._pwz);
}

//-----------------------------------------------------------------------------
// CompareString
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::CompareString(LPCWSTR pwz)
{
    DWORD iCompare = 0;
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    iCompare = ::CompareString(LOCALE_USER_DEFAULT, 0, 
        _pwz, -1, pwz, -1);

    IF_WIN32_FALSE_EXIT(iCompare);

    _hr = (iCompare == CSTR_EQUAL) ? S_OK : S_FALSE;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// LastElement
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::LastElement(CBaseString<T> &sSource)
{
    LPWSTR pwz = NULL;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    
    pwz = _pwz + _cc - 1;

    while (1)
    {
        pwz = CharPrev(_pwz, pwz);
        if (*pwz == L'\\' || *pwz == L'/')
            break;
        IF_FALSE_EXIT((pwz != _pwz), E_FAIL);
    }

    sSource.Assign(pwz+1);

exit:

    return _hr;
}


//-----------------------------------------------------------------------------
// RemoveLastElement
// remove last element, also the L'\\' or L'/'
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::RemoveLastElement()
{
    DWORD cc = 0;
    LPWSTR pwz = NULL;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);

    pwz = _pwz + _cc - 1;

    while (1)
    {
        pwz = CharPrev(_pwz, pwz);
        cc++;
        if (*pwz == L'\\' || *pwz == L'/' || (pwz == _pwz) )
            break;
        // IF_FALSE_EXIT((pwz != _pwz), E_FAIL);
    }

    *pwz = L'\0';
    _cc -= cc;

exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// SplitLastElement
// remove last element, also the separator
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::SplitLastElement(WCHAR wcSeparator, CBaseString &sSource)
{
    DWORD cc = 0;
    LPWSTR pwz = NULL;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    
    pwz = _pwz + _cc - 1;

    while (1)
    {
        pwz = CharPrev(_pwz, pwz);
        cc++;
        if (*pwz == wcSeparator)
            break;
        IF_FALSE_EXIT((pwz != _pwz), E_FAIL);
    }

    sSource.Assign(pwz+1);

    *pwz = L'\0';
    _cc -= cc;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// ByteCount
//-----------------------------------------------------------------------------
template<ULONG T> DWORD CBaseString<T>::ByteCount()
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    exit:

    return (_cc * sizeof(WCHAR));
}

//-----------------------------------------------------------------------------
// CharCount
//-----------------------------------------------------------------------------
template<ULONG T> DWORD CBaseString<T>::CharCount()
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    exit:

    return _cc;
}

//-----------------------------------------------------------------------------
// StartsWith
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::StartsWith(LPCWSTR pwzPrefix)
{
    DWORD ccPrefixLen = 0,  iCompare = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    IF_NULL_EXIT(pwzPrefix, E_INVALIDARG);
    
    ccPrefixLen = lstrlen(pwzPrefix);

    IF_FALSE_EXIT((ccPrefixLen < _cc-1), E_INVALIDARG);

    iCompare = ::CompareString(LOCALE_USER_DEFAULT, 0, 
        _pwz, ccPrefixLen, pwzPrefix, ccPrefixLen);

    IF_WIN32_FALSE_EXIT(iCompare);

    _hr = (iCompare == CSTR_EQUAL) ? S_OK : S_FALSE;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// EndsWith
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::EndsWith(LPCWSTR pwzSuffix)
{
    DWORD ccSuffixLen = 0,  iCompare = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    IF_NULL_EXIT(pwzSuffix, E_INVALIDARG);
    
    ccSuffixLen = lstrlen(pwzSuffix);

    IF_FALSE_EXIT((ccSuffixLen < _cc-1), E_INVALIDARG);

    iCompare = ::CompareString(LOCALE_USER_DEFAULT, 0, 
        _pwz+_cc-ccSuffixLen, ccSuffixLen, pwzSuffix, ccSuffixLen);

    IF_WIN32_FALSE_EXIT(iCompare);

    _hr = (iCompare == CSTR_EQUAL) ? S_OK : S_FALSE;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// PathNormalize
// / -> \ in string
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::PathNormalize()
{
    LPWSTR pwz = NULL;
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);

    pwz = _pwz;

    if (*pwz == L'/')
        *pwz = L'\\';
        
    while ((pwz = CharNext(pwz)) && *pwz)
    {
        if (*pwz == L'/')
            *pwz = L'\\';
    }

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// GetHash
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::GetHash(LPDWORD pdwHash, DWORD dwFlags)
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    _hr = Get65599Hash(pdwHash, dwFlags);
    exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// Get65599Hash
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::Get65599Hash(LPDWORD pdwHash, DWORD dwFlags)
{
    ULONG TmpHashValue = 0;
    DWORD cc = 0;
    LPWSTR pwz = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);

    if (pdwHash != NULL)
        *pdwHash = 0;

    cc = _cc;
    pwz = _pwz;
    
    if (dwFlags == CaseSensitive)
    {
        while (cc-- != 0)
        {
            WCHAR Char = *pwz++;
            TmpHashValue = (TmpHashValue * 65599) + (WCHAR) ::CharUpperW((PWSTR) Char);
        }
    }
    else
    {
        while (cc-- != 0)
            TmpHashValue = (TmpHashValue * 65599) + *pwz++;
    }

    *pdwHash = TmpHashValue;

exit:
    return _hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CString
//
//////////////////////////////////////////////////////////////////////////////
class CString : public CBaseString<DEFAULT_STACK_SIZE>
{
    public: 
        CString() : CBaseString<DEFAULT_STACK_SIZE> (){}
        CString(AllocFlags eAllocFlags) : CBaseString<DEFAULT_STACK_SIZE>(eAllocFlags) {}
};


//////////////////////////////////////////////////////////////////////////////
//
// CStringAccessor
//
//////////////////////////////////////////////////////////////////////////////
template<class T> class CStringAccessor
{
    
private:

    HRESULT _hr;
    T* _ps;

public:
    
    CStringAccessor();
    ~CStringAccessor();

    HRESULT Attach(T& s);
    HRESULT Detach(DWORD cc = 0);

    LPWSTR* operator &();
    LPWSTR  GetBuf();
};


//-----------------------------------------------------------------------------
// ctor
//-----------------------------------------------------------------------------
template<class T> CStringAccessor<T>::CStringAccessor()
    : _ps(NULL), _hr(S_OK)
{}

//-----------------------------------------------------------------------------
// dtor
//-----------------------------------------------------------------------------
template<class T> CStringAccessor<T>::~CStringAccessor()
{}

//-----------------------------------------------------------------------------
// Attach
//-----------------------------------------------------------------------------
template<class T> HRESULT CStringAccessor<T>::Attach(T &s)
{
    _ps = &s;
    IF_FAILED_EXIT(_ps->Lock());
exit:
    return _hr;
}    


//-----------------------------------------------------------------------------
// Detach
//-----------------------------------------------------------------------------
template<class T> HRESULT CStringAccessor<T>::Detach(DWORD cc)
{
    DWORD ccLen = 0;
    
    IF_NULL_EXIT(_ps, E_UNEXPECTED);
    IF_NULL_EXIT(_ps->_pwz, E_UNEXPECTED);
    
    if (!cc)
    {
        ccLen = lstrlen(_ps->_pwz);
        cc = ccLen+1;
        OVERFLOW_CHECK2(ccLen, cc);
    }
    else
    {
        IF_FALSE_EXIT((*(_ps->_pwz + cc - 1) == L'\0'), E_INVALIDARG);
    }

    _ps->_cc = _ps->_ccBuf = cc;

    IF_FAILED_EXIT(_ps->UnLock());

exit:

    return _hr;
}    

//-----------------------------------------------------------------------------
// operator &
//-----------------------------------------------------------------------------
template<class T> LPWSTR* CStringAccessor<T>::operator &()
{
    if (!_ps)
    {
        ASSERT(FALSE);
    }

    return (_ps ? &(_ps->_pwz) : NULL);
}    

//-----------------------------------------------------------------------------
// GetBuf
//-----------------------------------------------------------------------------
template<class T> LPWSTR CStringAccessor<T>::GetBuf()
{
    if (!_ps)
    {
        ASSERT(FALSE);
    }

    return (_ps ? (_ps->_pwz) : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\manifestimportclr.h ===
#pragma once
#include "cor.h"

#define ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE 32

class CAssemblyManifestImportCLR: public IAssemblyManifestImport
{
public:

    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    CAssemblyManifestImportCLR();
    ~CAssemblyManifestImportCLR();

    STDMETHOD(GetAssemblyIdentity)( 
        /* out */ IAssemblyIdentity **ppName);

    STDMETHOD(GetNextAssembly)(DWORD nIndex, IManifestInfo **ppName);

    STDMETHOD(GetNextFile)(DWORD nIndex, IManifestInfo **ppImport);

    STDMETHOD(ReportManifestType)(
        /*out*/  DWORD *pdwType);


    //Functions not implemented
    STDMETHOD(GetSubscriptionInfo)(
        /* out */ IManifestInfo **ppSubsInfo);

    STDMETHOD(GetNextPlatform)(
        /* in */ DWORD nIndex,
        /* out */ IManifestData **ppPlatformInfo);

    STDMETHOD(GetManifestApplicationInfo)(
        /* out */ IManifestInfo **ppAppInfo);

    STDMETHOD(QueryFile)(
        /* in  */ LPCOLESTR pwzFileName,
        /* out */ IManifestInfo **ppAssemblyFile);

    STDMETHOD(Init)(LPCWSTR szManifestFilePath);


    private:    
    
    DWORD                    _dwSig;
    DWORD                    _cRef;
    HRESULT                 _hr;
    
    WCHAR                    _szManifestFilePath[MAX_PATH];
    DWORD                    _ccManifestFilePath;
    IAssemblyIdentity     *_pName;
    IMetaDataAssemblyImport *_pMDImport;    
    PBYTE                    _pMap;
    mdAssembly              *_rAssemblyRefTokens;
    DWORD                    _cAssemblyRefTokens;
    mdFile                  *_rAssemblyModuleTokens;
    DWORD                    _cAssemblyModuleTokens;
};

STDAPI CreateAssemblyManifestImportCLR(LPCWSTR szManifestFilePath, IAssemblyManifestImport **ppImport);
STDAPI DeAllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd);
STDAPI AllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\manifestinfo.h ===
#pragma once

struct Property
{
    LPVOID pv;
    DWORD cb;
    DWORD flag;
};

class CPropertyArray
{
private:

    DWORD    _dwSig;
    DWORD   _dwType;
    Property *_rProp;
    
public:


   static DWORD max_params[MAN_INFO_MAX];

    CPropertyArray();
    ~CPropertyArray();
    HRESULT Init (DWORD dwType);
    HRESULT GetType(DWORD *pdwType);
    inline HRESULT Set(DWORD PropertyId, LPVOID pvProperty, DWORD  cbProperty, DWORD flag);
    inline HRESULT Get(DWORD PropertyId, LPVOID pvProperty, LPDWORD pcbProperty, DWORD *flag);
    inline Property operator [] (DWORD dwPropId);
};

class CManifestInfo : public IManifestInfo
{
    public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(Set)(
        /* in */ DWORD PropertyId, 
        /* in */ LPVOID pvProperty, 
        /* in */ DWORD cbProperty,
        /* in */ DWORD type);
    
    STDMETHOD(Get)(
        /* in */   DWORD PropertyId,
        /* out */ LPVOID  *ppvProperty,
        /* out */ DWORD  *pcbProperty,
        /* out */ DWORD *pType);

    STDMETHOD (IsEqual)(
        /* in */ IManifestInfo *pManifestInfo);

    STDMETHOD (GetType)(
        /* out */ DWORD *pdwType);

    CManifestInfo();
    ~CManifestInfo();

    HRESULT Init (DWORD dwType);
    private:
        
    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

    CPropertyArray *_properties;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\fusenet.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0359 */
/* Compiler settings for fusenet.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusenet_h__
#define __fusenet_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyIdentity_FWD_DEFINED__
#define __IAssemblyIdentity_FWD_DEFINED__
typedef interface IAssemblyIdentity IAssemblyIdentity;
#endif 	/* __IAssemblyIdentity_FWD_DEFINED__ */


#ifndef __IManifestInfo_FWD_DEFINED__
#define __IManifestInfo_FWD_DEFINED__
typedef interface IManifestInfo IManifestInfo;
#endif 	/* __IManifestInfo_FWD_DEFINED__ */


#ifndef __IManifestData_FWD_DEFINED__
#define __IManifestData_FWD_DEFINED__
typedef interface IManifestData IManifestData;
#endif 	/* __IManifestData_FWD_DEFINED__ */


#ifndef __IPatchingUtil_FWD_DEFINED__
#define __IPatchingUtil_FWD_DEFINED__
typedef interface IPatchingUtil IPatchingUtil;
#endif 	/* __IPatchingUtil_FWD_DEFINED__ */


#ifndef __IAssemblyManifestImport_FWD_DEFINED__
#define __IAssemblyManifestImport_FWD_DEFINED__
typedef interface IAssemblyManifestImport IAssemblyManifestImport;
#endif 	/* __IAssemblyManifestImport_FWD_DEFINED__ */


#ifndef __IAssemblyManifestEmit_FWD_DEFINED__
#define __IAssemblyManifestEmit_FWD_DEFINED__
typedef interface IAssemblyManifestEmit IAssemblyManifestEmit;
#endif 	/* __IAssemblyManifestEmit_FWD_DEFINED__ */


#ifndef __IAssemblyCacheImport_FWD_DEFINED__
#define __IAssemblyCacheImport_FWD_DEFINED__
typedef interface IAssemblyCacheImport IAssemblyCacheImport;
#endif 	/* __IAssemblyCacheImport_FWD_DEFINED__ */


#ifndef __IAssemblyCacheEmit_FWD_DEFINED__
#define __IAssemblyCacheEmit_FWD_DEFINED__
typedef interface IAssemblyCacheEmit IAssemblyCacheEmit;
#endif 	/* __IAssemblyCacheEmit_FWD_DEFINED__ */


#ifndef __IAssemblyCacheEnum_FWD_DEFINED__
#define __IAssemblyCacheEnum_FWD_DEFINED__
typedef interface IAssemblyCacheEnum IAssemblyCacheEnum;
#endif 	/* __IAssemblyCacheEnum_FWD_DEFINED__ */


#ifndef __IAssemblyBindSink_FWD_DEFINED__
#define __IAssemblyBindSink_FWD_DEFINED__
typedef interface IAssemblyBindSink IAssemblyBindSink;
#endif 	/* __IAssemblyBindSink_FWD_DEFINED__ */


#ifndef __IAssemblyDownload_FWD_DEFINED__
#define __IAssemblyDownload_FWD_DEFINED__
typedef interface IAssemblyDownload IAssemblyDownload;
#endif 	/* __IAssemblyDownload_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "bits.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusenet_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// fusenet.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-2001 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusenet Interfaces.

class CDebugLog;





#include <fusion.h>
EXTERN_C const IID IID_IAssemblyIdentity;
EXTERN_C const IID IID_IAssemblyManifestImport;
EXTERN_C const IID IID_IAssemblyManifestEmit;
EXTERN_C const IID IID_IAssemblyCacheImport;
EXTERN_C const IID IID_IAssemblyCacheEmit;
EXTERN_C const IID IID_IAssemblyCacheEnum;
EXTERN_C const IID IID_IAssemblyDownload;
EXTERN_C const IID IID_IManifestInfo;
EXTERN_C const IID IID_IManifestData;
EXTERN_C const IID IID_IPatchingInfo;


extern RPC_IF_HANDLE __MIDL_itf_fusenet_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusenet_0000_v0_0_s_ifspec;

#ifndef __IAssemblyIdentity_INTERFACE_DEFINED__
#define __IAssemblyIdentity_INTERFACE_DEFINED__

/* interface IAssemblyIdentity */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyIdentity *LPASSEMBLY_IDENTITY;

typedef /* [public] */ 
enum __MIDL_IAssemblyIdentity_0001
    {	ASMID_DISPLAYNAME_NOMANGLING	= 0,
	ASMID_DISPLAYNAME_WILDCARDED	= ASMID_DISPLAYNAME_NOMANGLING + 1,
	ASMID_DISPLAYNAME_MAX	= ASMID_DISPLAYNAME_WILDCARDED + 1
    } 	ASMID_DISPLAYNAME_FLAGS;


EXTERN_C const IID IID_IAssemblyIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aaa1257d-a56c-4383-9b4a-c868eda7ca42")
    IAssemblyIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ LPCOLESTR pwzName,
            /* [in] */ LPCOLESTR pwzValue,
            /* [in] */ DWORD ccValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ LPCOLESTR pwzName,
            /* [out] */ LPOLESTR *ppwzValue,
            /* [out] */ LPDWORD pccValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out] */ LPDWORD pccDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLRDisplayName( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out] */ LPDWORD pccDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyIdentity *pAssemblyId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IAssemblyIdentity * This,
            /* [in] */ LPCOLESTR pwzName,
            /* [in] */ LPCOLESTR pwzValue,
            /* [in] */ DWORD ccValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IAssemblyIdentity * This,
            /* [in] */ LPCOLESTR pwzName,
            /* [out] */ LPOLESTR *ppwzValue,
            /* [out] */ LPDWORD pccValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyIdentity * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out] */ LPDWORD pccDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLRDisplayName )( 
            IAssemblyIdentity * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out] */ LPDWORD pccDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyIdentity * This,
            /* [in] */ IAssemblyIdentity *pAssemblyId);
        
        END_INTERFACE
    } IAssemblyIdentityVtbl;

    interface IAssemblyIdentity
    {
        CONST_VTBL struct IAssemblyIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyIdentity_SetAttribute(This,pwzName,pwzValue,ccValue)	\
    (This)->lpVtbl -> SetAttribute(This,pwzName,pwzValue,ccValue)

#define IAssemblyIdentity_GetAttribute(This,pwzName,ppwzValue,pccValue)	\
    (This)->lpVtbl -> GetAttribute(This,pwzName,ppwzValue,pccValue)

#define IAssemblyIdentity_GetDisplayName(This,dwFlags,ppwzDisplayName,pccDisplayName)	\
    (This)->lpVtbl -> GetDisplayName(This,dwFlags,ppwzDisplayName,pccDisplayName)

#define IAssemblyIdentity_GetCLRDisplayName(This,dwFlags,ppwzDisplayName,pccDisplayName)	\
    (This)->lpVtbl -> GetCLRDisplayName(This,dwFlags,ppwzDisplayName,pccDisplayName)

#define IAssemblyIdentity_IsEqual(This,pAssemblyId)	\
    (This)->lpVtbl -> IsEqual(This,pAssemblyId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyIdentity_SetAttribute_Proxy( 
    IAssemblyIdentity * This,
    /* [in] */ LPCOLESTR pwzName,
    /* [in] */ LPCOLESTR pwzValue,
    /* [in] */ DWORD ccValue);


void __RPC_STUB IAssemblyIdentity_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyIdentity_GetAttribute_Proxy( 
    IAssemblyIdentity * This,
    /* [in] */ LPCOLESTR pwzName,
    /* [out] */ LPOLESTR *ppwzValue,
    /* [out] */ LPDWORD pccValue);


void __RPC_STUB IAssemblyIdentity_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyIdentity_GetDisplayName_Proxy( 
    IAssemblyIdentity * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LPOLESTR *ppwzDisplayName,
    /* [out] */ LPDWORD pccDisplayName);


void __RPC_STUB IAssemblyIdentity_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyIdentity_GetCLRDisplayName_Proxy( 
    IAssemblyIdentity * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LPOLESTR *ppwzDisplayName,
    /* [out] */ LPDWORD pccDisplayName);


void __RPC_STUB IAssemblyIdentity_GetCLRDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyIdentity_IsEqual_Proxy( 
    IAssemblyIdentity * This,
    /* [in] */ IAssemblyIdentity *pAssemblyId);


void __RPC_STUB IAssemblyIdentity_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyIdentity_INTERFACE_DEFINED__ */


#ifndef __IManifestInfo_INTERFACE_DEFINED__
#define __IManifestInfo_INTERFACE_DEFINED__

/* interface IManifestInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IManifestInfo *LPMANIFEST_INFO;


enum __MIDL_IManifestInfo_0001
    {	MAN_INFO_ASM_FILE_NAME	= 0,
	MAN_INFO_ASM_FILE_HASH	= MAN_INFO_ASM_FILE_NAME + 1,
	MAN_INFO_ASM_FILE_SIZE	= MAN_INFO_ASM_FILE_HASH + 1,
	MAN_INFO_ASM_FILE_MAX	= MAN_INFO_ASM_FILE_SIZE + 1
    } ;

enum __MIDL_IManifestInfo_0002
    {	MAN_INFO_APPLICATION_FRIENDLYNAME	= 0,
	MAN_INFO_APPLICATION_ENTRYPOINT	= MAN_INFO_APPLICATION_FRIENDLYNAME + 1,
	MAN_INFO_APPLICATION_ENTRYIMAGETYPE	= MAN_INFO_APPLICATION_ENTRYPOINT + 1,
	MAN_INFO_APPLICATION_ICONFILE	= MAN_INFO_APPLICATION_ENTRYIMAGETYPE + 1,
	MAN_INFO_APPLICATION_ICONINDEX	= MAN_INFO_APPLICATION_ICONFILE + 1,
	MAN_INFO_APPLICATION_SHOWCOMMAND	= MAN_INFO_APPLICATION_ICONINDEX + 1,
	MAN_INFO_APPLICATION_HOTKEY	= MAN_INFO_APPLICATION_SHOWCOMMAND + 1,
	MAN_INFO_APPLICATION_ASSEMBLYNAME	= MAN_INFO_APPLICATION_HOTKEY + 1,
	MAN_INFO_APPLICATION_ASSEMBLYCLASS	= MAN_INFO_APPLICATION_ASSEMBLYNAME + 1,
	MAN_INFO_APPLICATION_ASSEMBLYMETHOD	= MAN_INFO_APPLICATION_ASSEMBLYCLASS + 1,
	MAN_INFO_APPLICATION_ASSEMBLYARGS	= MAN_INFO_APPLICATION_ASSEMBLYMETHOD + 1,
	MAN_INFO_APPLICATION_MAX	= MAN_INFO_APPLICATION_ASSEMBLYARGS + 1
    } ;

enum __MIDL_IManifestInfo_0003
    {	MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_INTERVAL	= 0,
	MAN_INFO_SUBSCRIPTION_INTERVAL_UNIT	= MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_INTERVAL + 1,
	MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_EVENT	= MAN_INFO_SUBSCRIPTION_INTERVAL_UNIT + 1,
	MAN_INFO_SUBSCRIPTION_EVENT_DEMAND_CONNECTION	= MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_EVENT + 1,
	MAN_INFO_SUBSCRIPTION_MAX	= MAN_INFO_SUBSCRIPTION_EVENT_DEMAND_CONNECTION + 1
    } ;

enum __MIDL_IManifestInfo_0004
    {	MAN_INFO_DEPENDENT_ASM_CODEBASE	= 0,
	MAN_INFO_DEPENDENT_ASM_TYPE	= MAN_INFO_DEPENDENT_ASM_CODEBASE + 1,
	MAN_INFO_DEPENDENT_ASM_ID	= MAN_INFO_DEPENDENT_ASM_TYPE + 1,
	MAN_INFO_DEPENDANT_ASM_MAX	= MAN_INFO_DEPENDENT_ASM_ID + 1
    } ;

enum __MIDL_IManifestInfo_0005
    {	MAN_INFO_SOURCE_ASM_ID	= 0,
	MAN_INFO_SOURCE_ASM_PATCH_UTIL	= MAN_INFO_SOURCE_ASM_ID + 1,
	MAN_INFO_SOURCE_ASM_DIR	= MAN_INFO_SOURCE_ASM_PATCH_UTIL + 1,
	MAN_INFO_SOURCE_ASM_INSTALL_DIR	= MAN_INFO_SOURCE_ASM_DIR + 1,
	MAN_INFO_SOURCE_ASM_TEMP_DIR	= MAN_INFO_SOURCE_ASM_INSTALL_DIR + 1,
	MAN_INFO_SOURCE_ASM_MAX	= MAN_INFO_SOURCE_ASM_TEMP_DIR + 1
    } ;

enum __MIDL_IManifestInfo_0006
    {	MAN_INFO_PATCH_INFO_SOURCE	= 0,
	MAN_INFO_PATCH_INFO_TARGET	= MAN_INFO_PATCH_INFO_SOURCE + 1,
	MAN_INFO_PATCH_INFO_PATCH	= MAN_INFO_PATCH_INFO_TARGET + 1,
	MAN_INFO_PATCH_INFO_MAX	= MAN_INFO_PATCH_INFO_PATCH + 1
    } ;
typedef /* [public] */ 
enum __MIDL_IManifestInfo_0007
    {	MAN_INFO_FILE	= 0,
	MAN_INFO_APPLICATION	= MAN_INFO_FILE + 1,
	MAN_INFO_SUBSCRIPTION	= MAN_INFO_APPLICATION + 1,
	MAN_INFO_DEPENDTANT_ASM	= MAN_INFO_SUBSCRIPTION + 1,
	MAN_INFO_SOURCE_ASM	= MAN_INFO_DEPENDTANT_ASM + 1,
	MAN_INFO_PATCH_INFO	= MAN_INFO_SOURCE_ASM + 1,
	MAN_INFO_MAX	= MAN_INFO_PATCH_INFO + 1
    } 	MAN_INFO;

typedef /* [public] */ 
enum __MIDL_IManifestInfo_0008
    {	MAN_INFO_FLAG_UNDEF	= 0,
	MAN_INFO_FLAG_IUNKNOWN_PTR	= MAN_INFO_FLAG_UNDEF + 1,
	MAN_INFO_FLAG_LPWSTR	= MAN_INFO_FLAG_IUNKNOWN_PTR + 1,
	MAN_INFO_FLAG_DWORD	= MAN_INFO_FLAG_LPWSTR + 1,
	MAN_INFO_FLAG_ENUM	= MAN_INFO_FLAG_DWORD + 1,
	MAN_INFO_FLAG_BOOL	= MAN_INFO_FLAG_ENUM + 1,
	MAN_INFO_FLAG_MAX	= MAN_INFO_FLAG_BOOL + 1
    } 	MAN_INFO_FLAGS;


enum __MIDL_IManifestInfo_0009
    {	MAX_MAN_INFO_PROPERTIES	= MAN_INFO_APPLICATION_MAX
    } ;

EXTERN_C const IID IID_IManifestInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9309cc3-e522-4d58-b5c7-dee5b1763114")
    IManifestInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty,
            /* [in] */ DWORD type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ DWORD dwPropertyId,
            /* [out] */ LPVOID *pvProperty,
            /* [out] */ DWORD *pcbProperty,
            /* [out] */ DWORD *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IManifestInfo *pManifestInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ DWORD *pdwType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManifestInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManifestInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManifestInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManifestInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IManifestInfo * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty,
            /* [in] */ DWORD type);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IManifestInfo * This,
            /* [in] */ DWORD dwPropertyId,
            /* [out] */ LPVOID *pvProperty,
            /* [out] */ DWORD *pcbProperty,
            /* [out] */ DWORD *pType);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IManifestInfo * This,
            /* [in] */ IManifestInfo *pManifestInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IManifestInfo * This,
            /* [out] */ DWORD *pdwType);
        
        END_INTERFACE
    } IManifestInfoVtbl;

    interface IManifestInfo
    {
        CONST_VTBL struct IManifestInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManifestInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IManifestInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IManifestInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IManifestInfo_Set(This,PropertyId,pvProperty,cbProperty,type)	\
    (This)->lpVtbl -> Set(This,PropertyId,pvProperty,cbProperty,type)

#define IManifestInfo_Get(This,dwPropertyId,pvProperty,pcbProperty,pType)	\
    (This)->lpVtbl -> Get(This,dwPropertyId,pvProperty,pcbProperty,pType)

#define IManifestInfo_IsEqual(This,pManifestInfo)	\
    (This)->lpVtbl -> IsEqual(This,pManifestInfo)

#define IManifestInfo_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IManifestInfo_Set_Proxy( 
    IManifestInfo * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty,
    /* [in] */ DWORD type);


void __RPC_STUB IManifestInfo_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IManifestInfo_Get_Proxy( 
    IManifestInfo * This,
    /* [in] */ DWORD dwPropertyId,
    /* [out] */ LPVOID *pvProperty,
    /* [out] */ DWORD *pcbProperty,
    /* [out] */ DWORD *pType);


void __RPC_STUB IManifestInfo_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IManifestInfo_IsEqual_Proxy( 
    IManifestInfo * This,
    /* [in] */ IManifestInfo *pManifestInfo);


void __RPC_STUB IManifestInfo_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IManifestInfo_GetType_Proxy( 
    IManifestInfo * This,
    /* [out] */ DWORD *pdwType);


void __RPC_STUB IManifestInfo_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IManifestInfo_INTERFACE_DEFINED__ */


#ifndef __IManifestData_INTERFACE_DEFINED__
#define __IManifestData_INTERFACE_DEFINED__

/* interface IManifestData */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IManifestData *LPMANIFEST_DATA;

typedef /* [public] */ 
enum __MIDL_IManifestData_0001
    {	MAN_DATA_TYPE_UNDEF	= 0,
	MAN_DATA_TYPE_LPWSTR	= MAN_DATA_TYPE_UNDEF + 1,
	MAN_DATA_TYPE_DWORD	= MAN_DATA_TYPE_LPWSTR + 1,
	MAN_DATA_TYPE_ENUM	= MAN_DATA_TYPE_DWORD + 1,
	MAN_DATA_TYPE_BOOL	= MAN_DATA_TYPE_ENUM + 1,
	MAN_DATA_TYPE_IUNKNOWN_PTR	= MAN_DATA_TYPE_BOOL + 1,
	MAN_DATA_TYPE_MAX	= MAN_DATA_TYPE_IUNKNOWN_PTR + 1
    } 	MAN_DATA_TYPES;


EXTERN_C const IID IID_IManifestData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a423759-b438-4fdd-92cd-e09fed4830ef")
    IManifestData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCWSTR pwzPropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty,
            /* [in] */ DWORD dwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCWSTR pwzPropertyId,
            /* [out] */ LPVOID *ppvProperty,
            /* [out] */ DWORD *pcbProperty,
            /* [out] */ DWORD *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ LPWSTR *ppwzType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManifestDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManifestData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManifestData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManifestData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IManifestData * This,
            /* [in] */ LPCWSTR pwzPropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty,
            /* [in] */ DWORD dwType);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IManifestData * This,
            /* [in] */ LPCWSTR pwzPropertyId,
            /* [out] */ LPVOID *ppvProperty,
            /* [out] */ DWORD *pcbProperty,
            /* [out] */ DWORD *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IManifestData * This,
            /* [out] */ LPWSTR *ppwzType);
        
        END_INTERFACE
    } IManifestDataVtbl;

    interface IManifestData
    {
        CONST_VTBL struct IManifestDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManifestData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IManifestData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IManifestData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IManifestData_Set(This,pwzPropertyId,pvProperty,cbProperty,dwType)	\
    (This)->lpVtbl -> Set(This,pwzPropertyId,pvProperty,cbProperty,dwType)

#define IManifestData_Get(This,pwzPropertyId,ppvProperty,pcbProperty,pdwType)	\
    (This)->lpVtbl -> Get(This,pwzPropertyId,ppvProperty,pcbProperty,pdwType)

#define IManifestData_GetType(This,ppwzType)	\
    (This)->lpVtbl -> GetType(This,ppwzType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IManifestData_Set_Proxy( 
    IManifestData * This,
    /* [in] */ LPCWSTR pwzPropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty,
    /* [in] */ DWORD dwType);


void __RPC_STUB IManifestData_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IManifestData_Get_Proxy( 
    IManifestData * This,
    /* [in] */ LPCWSTR pwzPropertyId,
    /* [out] */ LPVOID *ppvProperty,
    /* [out] */ DWORD *pcbProperty,
    /* [out] */ DWORD *pdwType);


void __RPC_STUB IManifestData_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IManifestData_GetType_Proxy( 
    IManifestData * This,
    /* [out] */ LPWSTR *ppwzType);


void __RPC_STUB IManifestData_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IManifestData_INTERFACE_DEFINED__ */


#ifndef __IPatchingUtil_INTERFACE_DEFINED__
#define __IPatchingUtil_INTERFACE_DEFINED__

/* interface IPatchingUtil */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IPatchingUtil *LPPATCHING_INTERFACE;


EXTERN_C const IID IID_IPatchingUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e460c1ba-e601-48e4-a926-fea8033ab199")
    IPatchingUtil : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MatchTarget( 
            /* [in] */ LPWSTR pwzTarget,
            /* [out] */ IManifestInfo **ppPatchInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchPatch( 
            /* [in] */ LPWSTR pwzPatch,
            /* [out] */ IManifestInfo **ppPatchInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPatchingUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPatchingUtil * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPatchingUtil * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPatchingUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *MatchTarget )( 
            IPatchingUtil * This,
            /* [in] */ LPWSTR pwzTarget,
            /* [out] */ IManifestInfo **ppPatchInfo);
        
        HRESULT ( STDMETHODCALLTYPE *MatchPatch )( 
            IPatchingUtil * This,
            /* [in] */ LPWSTR pwzPatch,
            /* [out] */ IManifestInfo **ppPatchInfo);
        
        END_INTERFACE
    } IPatchingUtilVtbl;

    interface IPatchingUtil
    {
        CONST_VTBL struct IPatchingUtilVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPatchingUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPatchingUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPatchingUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPatchingUtil_MatchTarget(This,pwzTarget,ppPatchInfo)	\
    (This)->lpVtbl -> MatchTarget(This,pwzTarget,ppPatchInfo)

#define IPatchingUtil_MatchPatch(This,pwzPatch,ppPatchInfo)	\
    (This)->lpVtbl -> MatchPatch(This,pwzPatch,ppPatchInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPatchingUtil_MatchTarget_Proxy( 
    IPatchingUtil * This,
    /* [in] */ LPWSTR pwzTarget,
    /* [out] */ IManifestInfo **ppPatchInfo);


void __RPC_STUB IPatchingUtil_MatchTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPatchingUtil_MatchPatch_Proxy( 
    IPatchingUtil * This,
    /* [in] */ LPWSTR pwzPatch,
    /* [out] */ IManifestInfo **ppPatchInfo);


void __RPC_STUB IPatchingUtil_MatchPatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPatchingUtil_INTERFACE_DEFINED__ */


#ifndef __IAssemblyManifestImport_INTERFACE_DEFINED__
#define __IAssemblyManifestImport_INTERFACE_DEFINED__

/* interface IAssemblyManifestImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyManifestImport *LPASSEMBLY_MANIFEST_IMPORT;

typedef /* [public] */ 
enum __MIDL_IAssemblyManifestImport_0001
    {	MANIFEST_TYPE_UNKNOWN	= 0,
	MANIFEST_TYPE_DESKTOP	= MANIFEST_TYPE_UNKNOWN + 1,
	MANIFEST_TYPE_SUBSCRIPTION	= MANIFEST_TYPE_DESKTOP + 1,
	MANIFEST_TYPE_APPLICATION	= MANIFEST_TYPE_SUBSCRIPTION + 1,
	MANIFEST_TYPE_COMPONENT	= MANIFEST_TYPE_APPLICATION + 1,
	MANIFEST_TYPE_MAX	= MANIFEST_TYPE_COMPONENT + 1
    } 	MANIFEST_TYPE;

typedef /* [public] */ 
enum __MIDL_IAssemblyManifestImport_0002
    {	DEPENDENT_ASM_INSTALL_TYPE_NORMAL	= 0,
	DEPENDENT_ASM_INSTALL_TYPE_REQUIRED	= DEPENDENT_ASM_INSTALL_TYPE_NORMAL + 1,
	DEPENDENT_ASM_INSTALL_TYPE_MAX	= DEPENDENT_ASM_INSTALL_TYPE_REQUIRED + 1
    } 	DEPENDENT_ASM_INSTALL_TYPE;

typedef /* [public] */ 
enum __MIDL_IAssemblyManifestImport_0003
    {	SUBSCRIPTION_INTERVAL_UNIT_HOURS	= 0,
	SUBSCRIPTION_INTERVAL_UNIT_MINUTES	= SUBSCRIPTION_INTERVAL_UNIT_HOURS + 1,
	SUBSCRIPTION_INTERVAL_UNIT_DAYS	= SUBSCRIPTION_INTERVAL_UNIT_MINUTES + 1,
	SUBSCRIPTION_INTERVAL_UNIT_MAX	= SUBSCRIPTION_INTERVAL_UNIT_DAYS + 1
    } 	SUBSCRIPTION_INTERVAL_UNIT;

typedef /* [public] */ 
enum __MIDL_IAssemblyManifestImport_0004
    {	SUBSCRIPTION_SYNC_EVENT_NONE	= 0,
	SUBSCRIPTION_SYNC_EVENT_ON_APP_STARTUP	= SUBSCRIPTION_SYNC_EVENT_NONE + 1,
	SUBSCRIPTION_SYNC_EVENT_MAX	= SUBSCRIPTION_SYNC_EVENT_ON_APP_STARTUP + 1
    } 	SUBSCRIPTION_SYNC_EVENT;


EXTERN_C const IID IID_IAssemblyManifestImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("696fb37f-da64-4175-94e7-fdc8234539c4")
    IAssemblyManifestImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyIdentity( 
            /* [out] */ IAssemblyIdentity **ppAssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestApplicationInfo( 
            /* [out] */ IManifestInfo **ppAppInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubscriptionInfo( 
            /* [out] */ IManifestInfo **ppSubsInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextPlatform( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IManifestData **ppPlatformInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextFile( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IManifestInfo **ppAssemblyFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryFile( 
            /* [in] */ LPCOLESTR pwzFileName,
            /* [out] */ IManifestInfo **ppAssemblyFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IManifestInfo **ppDependAsm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportManifestType( 
            /* [out] */ DWORD *pdwType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyManifestImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyManifestImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyManifestImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyManifestImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyIdentity )( 
            IAssemblyManifestImport * This,
            /* [out] */ IAssemblyIdentity **ppAssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestApplicationInfo )( 
            IAssemblyManifestImport * This,
            /* [out] */ IManifestInfo **ppAppInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubscriptionInfo )( 
            IAssemblyManifestImport * This,
            /* [out] */ IManifestInfo **ppSubsInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextPlatform )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IManifestData **ppPlatformInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextFile )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IManifestInfo **ppAssemblyFile);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFile )( 
            IAssemblyManifestImport * This,
            /* [in] */ LPCOLESTR pwzFileName,
            /* [out] */ IManifestInfo **ppAssemblyFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IManifestInfo **ppDependAsm);
        
        HRESULT ( STDMETHODCALLTYPE *ReportManifestType )( 
            IAssemblyManifestImport * This,
            /* [out] */ DWORD *pdwType);
        
        END_INTERFACE
    } IAssemblyManifestImportVtbl;

    interface IAssemblyManifestImport
    {
        CONST_VTBL struct IAssemblyManifestImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyManifestImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyManifestImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyManifestImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyManifestImport_GetAssemblyIdentity(This,ppAssemblyId)	\
    (This)->lpVtbl -> GetAssemblyIdentity(This,ppAssemblyId)

#define IAssemblyManifestImport_GetManifestApplicationInfo(This,ppAppInfo)	\
    (This)->lpVtbl -> GetManifestApplicationInfo(This,ppAppInfo)

#define IAssemblyManifestImport_GetSubscriptionInfo(This,ppSubsInfo)	\
    (This)->lpVtbl -> GetSubscriptionInfo(This,ppSubsInfo)

#define IAssemblyManifestImport_GetNextPlatform(This,nIndex,ppPlatformInfo)	\
    (This)->lpVtbl -> GetNextPlatform(This,nIndex,ppPlatformInfo)

#define IAssemblyManifestImport_GetNextFile(This,nIndex,ppAssemblyFile)	\
    (This)->lpVtbl -> GetNextFile(This,nIndex,ppAssemblyFile)

#define IAssemblyManifestImport_QueryFile(This,pwzFileName,ppAssemblyFile)	\
    (This)->lpVtbl -> QueryFile(This,pwzFileName,ppAssemblyFile)

#define IAssemblyManifestImport_GetNextAssembly(This,nIndex,ppDependAsm)	\
    (This)->lpVtbl -> GetNextAssembly(This,nIndex,ppDependAsm)

#define IAssemblyManifestImport_ReportManifestType(This,pdwType)	\
    (This)->lpVtbl -> ReportManifestType(This,pdwType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetAssemblyIdentity_Proxy( 
    IAssemblyManifestImport * This,
    /* [out] */ IAssemblyIdentity **ppAssemblyId);


void __RPC_STUB IAssemblyManifestImport_GetAssemblyIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetManifestApplicationInfo_Proxy( 
    IAssemblyManifestImport * This,
    /* [out] */ IManifestInfo **ppAppInfo);


void __RPC_STUB IAssemblyManifestImport_GetManifestApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetSubscriptionInfo_Proxy( 
    IAssemblyManifestImport * This,
    /* [out] */ IManifestInfo **ppSubsInfo);


void __RPC_STUB IAssemblyManifestImport_GetSubscriptionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextPlatform_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IManifestData **ppPlatformInfo);


void __RPC_STUB IAssemblyManifestImport_GetNextPlatform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextFile_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IManifestInfo **ppAssemblyFile);


void __RPC_STUB IAssemblyManifestImport_GetNextFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_QueryFile_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ LPCOLESTR pwzFileName,
    /* [out] */ IManifestInfo **ppAssemblyFile);


void __RPC_STUB IAssemblyManifestImport_QueryFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextAssembly_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IManifestInfo **ppDependAsm);


void __RPC_STUB IAssemblyManifestImport_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_ReportManifestType_Proxy( 
    IAssemblyManifestImport * This,
    /* [out] */ DWORD *pdwType);


void __RPC_STUB IAssemblyManifestImport_ReportManifestType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyManifestImport_INTERFACE_DEFINED__ */


#ifndef __IAssemblyManifestEmit_INTERFACE_DEFINED__
#define __IAssemblyManifestEmit_INTERFACE_DEFINED__

/* interface IAssemblyManifestEmit */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyManifestEmit *LPASSEMBLY_MANIFEST_EMIT;


EXTERN_C const IID IID_IAssemblyManifestEmit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f022ef5f-61dc-489b-b321-4d6f2b910890")
    IAssemblyManifestEmit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ImportManifestInfo( 
            /* [in] */ LPASSEMBLY_MANIFEST_IMPORT pManImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDependencySubscription( 
            /* [in] */ LPASSEMBLY_MANIFEST_IMPORT pManImport,
            /* [in] */ LPWSTR pwzManifestUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyManifestEmitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyManifestEmit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyManifestEmit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyManifestEmit * This);
        
        HRESULT ( STDMETHODCALLTYPE *ImportManifestInfo )( 
            IAssemblyManifestEmit * This,
            /* [in] */ LPASSEMBLY_MANIFEST_IMPORT pManImport);
        
        HRESULT ( STDMETHODCALLTYPE *SetDependencySubscription )( 
            IAssemblyManifestEmit * This,
            /* [in] */ LPASSEMBLY_MANIFEST_IMPORT pManImport,
            /* [in] */ LPWSTR pwzManifestUrl);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyManifestEmit * This);
        
        END_INTERFACE
    } IAssemblyManifestEmitVtbl;

    interface IAssemblyManifestEmit
    {
        CONST_VTBL struct IAssemblyManifestEmitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyManifestEmit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyManifestEmit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyManifestEmit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyManifestEmit_ImportManifestInfo(This,pManImport)	\
    (This)->lpVtbl -> ImportManifestInfo(This,pManImport)

#define IAssemblyManifestEmit_SetDependencySubscription(This,pManImport,pwzManifestUrl)	\
    (This)->lpVtbl -> SetDependencySubscription(This,pManImport,pwzManifestUrl)

#define IAssemblyManifestEmit_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyManifestEmit_ImportManifestInfo_Proxy( 
    IAssemblyManifestEmit * This,
    /* [in] */ LPASSEMBLY_MANIFEST_IMPORT pManImport);


void __RPC_STUB IAssemblyManifestEmit_ImportManifestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestEmit_SetDependencySubscription_Proxy( 
    IAssemblyManifestEmit * This,
    /* [in] */ LPASSEMBLY_MANIFEST_IMPORT pManImport,
    /* [in] */ LPWSTR pwzManifestUrl);


void __RPC_STUB IAssemblyManifestEmit_SetDependencySubscription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestEmit_Commit_Proxy( 
    IAssemblyManifestEmit * This);


void __RPC_STUB IAssemblyManifestEmit_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyManifestEmit_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheImport_INTERFACE_DEFINED__
#define __IAssemblyCacheImport_INTERFACE_DEFINED__

/* interface IAssemblyCacheImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyCacheImport *LPASSEMBLY_CACHE_IMPORT;

typedef /* [public] */ 
enum __MIDL_IAssemblyCacheImport_0001
    {	CACHEIMP_CREATE_NULL	= 0,
	CACHEIMP_CREATE_RETRIEVE	= CACHEIMP_CREATE_NULL + 1,
	CACHEIMP_CREATE_RETRIEVE_MAX	= CACHEIMP_CREATE_RETRIEVE + 1,
	CACHEIMP_CREATE_RESOLVE_REF	= CACHEIMP_CREATE_RETRIEVE_MAX + 1,
	CACHEIMP_CREATE_RESOLVE_REF_EX	= CACHEIMP_CREATE_RESOLVE_REF + 1,
	CACHEIMP_CREATE_MAX	= CACHEIMP_CREATE_RESOLVE_REF_EX + 1
    } 	CACHEIMP_CREATE_FLAGS;


EXTERN_C const IID IID_IAssemblyCacheImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c920b164-33e0-4c61-b595-eca4cdb04f12")
    IAssemblyCacheImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetManifestImport( 
            /* [out] */ IAssemblyManifestImport **ppManifestImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestFilePath( 
            /* [out] */ LPOLESTR *ppwzFilePath,
            /* [out][in] */ LPDWORD pccFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestFileDir( 
            /* [out] */ LPOLESTR *ppwzFileDir,
            /* [out][in] */ LPDWORD pccFileDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyIdentity( 
            /* [out] */ IAssemblyIdentity **ppAssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindExistMatching( 
            /* [in] */ IManifestInfo *pAssemblyFileInfo,
            /* [out] */ LPOLESTR *ppwzPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestImport )( 
            IAssemblyCacheImport * This,
            /* [out] */ IAssemblyManifestImport **ppManifestImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestFilePath )( 
            IAssemblyCacheImport * This,
            /* [out] */ LPOLESTR *ppwzFilePath,
            /* [out][in] */ LPDWORD pccFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestFileDir )( 
            IAssemblyCacheImport * This,
            /* [out] */ LPOLESTR *ppwzFileDir,
            /* [out][in] */ LPDWORD pccFileDir);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyIdentity )( 
            IAssemblyCacheImport * This,
            /* [out] */ IAssemblyIdentity **ppAssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyCacheImport * This,
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *FindExistMatching )( 
            IAssemblyCacheImport * This,
            /* [in] */ IManifestInfo *pAssemblyFileInfo,
            /* [out] */ LPOLESTR *ppwzPath);
        
        END_INTERFACE
    } IAssemblyCacheImportVtbl;

    interface IAssemblyCacheImport
    {
        CONST_VTBL struct IAssemblyCacheImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheImport_GetManifestImport(This,ppManifestImport)	\
    (This)->lpVtbl -> GetManifestImport(This,ppManifestImport)

#define IAssemblyCacheImport_GetManifestFilePath(This,ppwzFilePath,pccFilePath)	\
    (This)->lpVtbl -> GetManifestFilePath(This,ppwzFilePath,pccFilePath)

#define IAssemblyCacheImport_GetManifestFileDir(This,ppwzFileDir,pccFileDir)	\
    (This)->lpVtbl -> GetManifestFileDir(This,ppwzFileDir,pccFileDir)

#define IAssemblyCacheImport_GetAssemblyIdentity(This,ppAssemblyId)	\
    (This)->lpVtbl -> GetAssemblyIdentity(This,ppAssemblyId)

#define IAssemblyCacheImport_GetDisplayName(This,ppwzDisplayName,pccDisplayName)	\
    (This)->lpVtbl -> GetDisplayName(This,ppwzDisplayName,pccDisplayName)

#define IAssemblyCacheImport_FindExistMatching(This,pAssemblyFileInfo,ppwzPath)	\
    (This)->lpVtbl -> FindExistMatching(This,pAssemblyFileInfo,ppwzPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheImport_GetManifestImport_Proxy( 
    IAssemblyCacheImport * This,
    /* [out] */ IAssemblyManifestImport **ppManifestImport);


void __RPC_STUB IAssemblyCacheImport_GetManifestImport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheImport_GetManifestFilePath_Proxy( 
    IAssemblyCacheImport * This,
    /* [out] */ LPOLESTR *ppwzFilePath,
    /* [out][in] */ LPDWORD pccFilePath);


void __RPC_STUB IAssemblyCacheImport_GetManifestFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheImport_GetManifestFileDir_Proxy( 
    IAssemblyCacheImport * This,
    /* [out] */ LPOLESTR *ppwzFileDir,
    /* [out][in] */ LPDWORD pccFileDir);


void __RPC_STUB IAssemblyCacheImport_GetManifestFileDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheImport_GetAssemblyIdentity_Proxy( 
    IAssemblyCacheImport * This,
    /* [out] */ IAssemblyIdentity **ppAssemblyId);


void __RPC_STUB IAssemblyCacheImport_GetAssemblyIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheImport_GetDisplayName_Proxy( 
    IAssemblyCacheImport * This,
    /* [out] */ LPOLESTR *ppwzDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName);


void __RPC_STUB IAssemblyCacheImport_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheImport_FindExistMatching_Proxy( 
    IAssemblyCacheImport * This,
    /* [in] */ IManifestInfo *pAssemblyFileInfo,
    /* [out] */ LPOLESTR *ppwzPath);


void __RPC_STUB IAssemblyCacheImport_FindExistMatching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheImport_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheEmit_INTERFACE_DEFINED__
#define __IAssemblyCacheEmit_INTERFACE_DEFINED__

/* interface IAssemblyCacheEmit */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyCacheEmit *LPASSEMBLY_CACHE_EMIT;


EXTERN_C const IID IID_IAssemblyCacheEmit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83d6b9ac-eff9-45a3-8361-7c41df1f9f85")
    IAssemblyCacheEmit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetManifestImport( 
            /* [out] */ IAssemblyManifestImport **ppManifestImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestFilePath( 
            /* [out] */ LPOLESTR *ppwzFilePath,
            /* [out][in] */ LPDWORD pccFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestFileDir( 
            /* [out] */ LPOLESTR *ppwzFilePath,
            /* [out][in] */ LPDWORD pccFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyIdentity( 
            /* [out] */ IAssemblyIdentity **ppAssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyFile( 
            /* [in] */ LPOLESTR pwzSourceFilePath,
            /* [in] */ LPOLESTR pwzFileName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheEmitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheEmit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheEmit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheEmit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestImport )( 
            IAssemblyCacheEmit * This,
            /* [out] */ IAssemblyManifestImport **ppManifestImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestFilePath )( 
            IAssemblyCacheEmit * This,
            /* [out] */ LPOLESTR *ppwzFilePath,
            /* [out][in] */ LPDWORD pccFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestFileDir )( 
            IAssemblyCacheEmit * This,
            /* [out] */ LPOLESTR *ppwzFilePath,
            /* [out][in] */ LPDWORD pccFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyCacheEmit * This,
            /* [out] */ LPOLESTR *ppwzDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyIdentity )( 
            IAssemblyCacheEmit * This,
            /* [out] */ IAssemblyIdentity **ppAssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *CopyFile )( 
            IAssemblyCacheEmit * This,
            /* [in] */ LPOLESTR pwzSourceFilePath,
            /* [in] */ LPOLESTR pwzFileName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheEmit * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAssemblyCacheEmitVtbl;

    interface IAssemblyCacheEmit
    {
        CONST_VTBL struct IAssemblyCacheEmitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheEmit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheEmit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheEmit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheEmit_GetManifestImport(This,ppManifestImport)	\
    (This)->lpVtbl -> GetManifestImport(This,ppManifestImport)

#define IAssemblyCacheEmit_GetManifestFilePath(This,ppwzFilePath,pccFilePath)	\
    (This)->lpVtbl -> GetManifestFilePath(This,ppwzFilePath,pccFilePath)

#define IAssemblyCacheEmit_GetManifestFileDir(This,ppwzFilePath,pccFilePath)	\
    (This)->lpVtbl -> GetManifestFileDir(This,ppwzFilePath,pccFilePath)

#define IAssemblyCacheEmit_GetDisplayName(This,ppwzDisplayName,pccDisplayName)	\
    (This)->lpVtbl -> GetDisplayName(This,ppwzDisplayName,pccDisplayName)

#define IAssemblyCacheEmit_GetAssemblyIdentity(This,ppAssemblyId)	\
    (This)->lpVtbl -> GetAssemblyIdentity(This,ppAssemblyId)

#define IAssemblyCacheEmit_CopyFile(This,pwzSourceFilePath,pwzFileName,dwFlags)	\
    (This)->lpVtbl -> CopyFile(This,pwzSourceFilePath,pwzFileName,dwFlags)

#define IAssemblyCacheEmit_Commit(This,dwFlags)	\
    (This)->lpVtbl -> Commit(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheEmit_GetManifestImport_Proxy( 
    IAssemblyCacheEmit * This,
    /* [out] */ IAssemblyManifestImport **ppManifestImport);


void __RPC_STUB IAssemblyCacheEmit_GetManifestImport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEmit_GetManifestFilePath_Proxy( 
    IAssemblyCacheEmit * This,
    /* [out] */ LPOLESTR *ppwzFilePath,
    /* [out][in] */ LPDWORD pccFilePath);


void __RPC_STUB IAssemblyCacheEmit_GetManifestFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEmit_GetManifestFileDir_Proxy( 
    IAssemblyCacheEmit * This,
    /* [out] */ LPOLESTR *ppwzFilePath,
    /* [out][in] */ LPDWORD pccFilePath);


void __RPC_STUB IAssemblyCacheEmit_GetManifestFileDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEmit_GetDisplayName_Proxy( 
    IAssemblyCacheEmit * This,
    /* [out] */ LPOLESTR *ppwzDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName);


void __RPC_STUB IAssemblyCacheEmit_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEmit_GetAssemblyIdentity_Proxy( 
    IAssemblyCacheEmit * This,
    /* [out] */ IAssemblyIdentity **ppAssemblyId);


void __RPC_STUB IAssemblyCacheEmit_GetAssemblyIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEmit_CopyFile_Proxy( 
    IAssemblyCacheEmit * This,
    /* [in] */ LPOLESTR pwzSourceFilePath,
    /* [in] */ LPOLESTR pwzFileName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyCacheEmit_CopyFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEmit_Commit_Proxy( 
    IAssemblyCacheEmit * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyCacheEmit_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheEmit_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheEnum_INTERFACE_DEFINED__
#define __IAssemblyCacheEnum_INTERFACE_DEFINED__

/* interface IAssemblyCacheEnum */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyCacheEnum *LPASSEMBLY_CACHE_ENUM;

typedef /* [public] */ 
enum __MIDL_IAssemblyCacheEnum_0001
    {	CACHEENUM_RETRIEVE_ALL	= 0,
	CACHEENUM_RETRIEVE_VISIBLE	= CACHEENUM_RETRIEVE_ALL + 1,
	CACHEENUM_RETRIEVE_MAX	= CACHEENUM_RETRIEVE_VISIBLE + 1
    } 	CACHEENUM_RETRIEVE_FLAGS;


EXTERN_C const IID IID_IAssemblyCacheEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48a5b677-f800-494f-b19b-795d30699385")
    IAssemblyCacheEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IAssemblyCacheImport **ppAsmCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ LPDWORD pdwCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            IAssemblyCacheEnum * This,
            /* [out] */ IAssemblyCacheImport **ppAsmCache);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyCacheEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IAssemblyCacheEnum * This,
            /* [out] */ LPDWORD pdwCount);
        
        END_INTERFACE
    } IAssemblyCacheEnumVtbl;

    interface IAssemblyCacheEnum
    {
        CONST_VTBL struct IAssemblyCacheEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheEnum_GetNext(This,ppAsmCache)	\
    (This)->lpVtbl -> GetNext(This,ppAsmCache)

#define IAssemblyCacheEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyCacheEnum_GetCount(This,pdwCount)	\
    (This)->lpVtbl -> GetCount(This,pdwCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheEnum_GetNext_Proxy( 
    IAssemblyCacheEnum * This,
    /* [out] */ IAssemblyCacheImport **ppAsmCache);


void __RPC_STUB IAssemblyCacheEnum_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEnum_Reset_Proxy( 
    IAssemblyCacheEnum * This);


void __RPC_STUB IAssemblyCacheEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheEnum_GetCount_Proxy( 
    IAssemblyCacheEnum * This,
    /* [out] */ LPDWORD pdwCount);


void __RPC_STUB IAssemblyCacheEnum_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheEnum_INTERFACE_DEFINED__ */


#ifndef __IAssemblyBindSink_INTERFACE_DEFINED__
#define __IAssemblyBindSink_INTERFACE_DEFINED__

/* interface IAssemblyBindSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyBindSink *LPASSEMBLY_BIND_SINK;

typedef /* [public] */ 
enum __MIDL_IAssemblyBindSink_0001
    {	ASM_NOTIFICATION_START	= 0,
	ASM_NOTIFICATION_PROGRESS	= ASM_NOTIFICATION_START + 1,
	ASM_NOTIFICATION_ABORT	= ASM_NOTIFICATION_PROGRESS + 1,
	ASM_NOTIFICATION_ERROR	= ASM_NOTIFICATION_ABORT + 1,
	ASM_NOTIFICATION_SUBSCRIPTION_MANIFEST	= ASM_NOTIFICATION_ERROR + 1,
	ASM_NOTIFICATION_APPLICATION_MANIFEST	= ASM_NOTIFICATION_SUBSCRIPTION_MANIFEST + 1,
	ASM_NOTIFICATION_DONE	= ASM_NOTIFICATION_APPLICATION_MANIFEST + 1
    } 	ASM_NOTIFICATION;


EXTERN_C const IID IID_IAssemblyBindSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("af0bc960-0b9a-11d3-95ca-00a024a85b51")
    IAssemblyBindSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyBindSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyBindSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyBindSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyBindSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IAssemblyBindSink * This,
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } IAssemblyBindSinkVtbl;

    interface IAssemblyBindSink
    {
        CONST_VTBL struct IAssemblyBindSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyBindSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyBindSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyBindSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyBindSink_OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)	\
    (This)->lpVtbl -> OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyBindSink_OnProgress_Proxy( 
    IAssemblyBindSink * This,
    /* [in] */ DWORD dwNotification,
    /* [in] */ HRESULT hrNotification,
    /* [in] */ LPCWSTR szNotification,
    /* [in] */ DWORD dwProgress,
    /* [in] */ DWORD dwProgressMax,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IAssemblyBindSink_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyBindSink_INTERFACE_DEFINED__ */


#ifndef __IAssemblyDownload_INTERFACE_DEFINED__
#define __IAssemblyDownload_INTERFACE_DEFINED__

/* interface IAssemblyDownload */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyDownload *LPASSEMBLY_DOWNLOAD;

typedef /* [public] */ 
enum __MIDL_IAssemblyDownload_0001
    {	DOWNLOAD_FLAGS_NO_NOTIFICATION	= 0,
	DOWNLOAD_FLAGS_PROGRESS_UI	= 0x1,
	DOWNLOAD_FLAGS_NOTIFY_BINDSINK	= 0x2
    } 	ASM_DOWNLOAD;


EXTERN_C const IID IID_IAssemblyDownload;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a249b36-6132-4238-8871-a267029382a8")
    IAssemblyDownload : public IBackgroundCopyCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DownloadManifestAndDependencies( 
            /* [in] */ LPWSTR pwzApplicationManifestUrl,
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelDownload( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyDownloadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyDownload * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyDownload * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyDownload * This);
        
        HRESULT ( STDMETHODCALLTYPE *JobTransferred )( 
            IAssemblyDownload * This,
            /* [in] */ IBackgroundCopyJob *pJob);
        
        HRESULT ( STDMETHODCALLTYPE *JobError )( 
            IAssemblyDownload * This,
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ IBackgroundCopyError *pError);
        
        HRESULT ( STDMETHODCALLTYPE *JobModification )( 
            IAssemblyDownload * This,
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *DownloadManifestAndDependencies )( 
            IAssemblyDownload * This,
            /* [in] */ LPWSTR pwzApplicationManifestUrl,
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDownload )( 
            IAssemblyDownload * This);
        
        END_INTERFACE
    } IAssemblyDownloadVtbl;

    interface IAssemblyDownload
    {
        CONST_VTBL struct IAssemblyDownloadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyDownload_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyDownload_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyDownload_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyDownload_JobTransferred(This,pJob)	\
    (This)->lpVtbl -> JobTransferred(This,pJob)

#define IAssemblyDownload_JobError(This,pJob,pError)	\
    (This)->lpVtbl -> JobError(This,pJob,pError)

#define IAssemblyDownload_JobModification(This,pJob,dwReserved)	\
    (This)->lpVtbl -> JobModification(This,pJob,dwReserved)


#define IAssemblyDownload_DownloadManifestAndDependencies(This,pwzApplicationManifestUrl,pBindSink,dwFlags)	\
    (This)->lpVtbl -> DownloadManifestAndDependencies(This,pwzApplicationManifestUrl,pBindSink,dwFlags)

#define IAssemblyDownload_CancelDownload(This)	\
    (This)->lpVtbl -> CancelDownload(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyDownload_DownloadManifestAndDependencies_Proxy( 
    IAssemblyDownload * This,
    /* [in] */ LPWSTR pwzApplicationManifestUrl,
    /* [in] */ IAssemblyBindSink *pBindSink,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyDownload_DownloadManifestAndDependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyDownload_CancelDownload_Proxy( 
    IAssemblyDownload * This);


void __RPC_STUB IAssemblyDownload_CancelDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyDownload_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusenet_0156 */
/* [local] */ 

typedef /* [public][public] */ struct __MIDL___MIDL_itf_fusenet_0156_0001
    {
    LPWSTR pwzName;
    LPWSTR pwzURL;
    } 	TPLATFORM_INFO;

typedef TPLATFORM_INFO *LPTPLATFORM_INFO;

STDAPI CheckPlatformRequirements(LPASSEMBLY_MANIFEST_IMPORT pManifestImport, LPDWORD pdwNumMissingPlatforms, LPTPLATFORM_INFO* pptPlatform);
STDAPI CheckPlatformRequirementsEx(LPASSEMBLY_MANIFEST_IMPORT pManifestImport, CDebugLog* pDbgLog, LPDWORD pdwNumMissingPlatforms, LPTPLATFORM_INFO* pptPlatform);
STDAPI CreateFusionAssemblyCacheEx (IAssemblyCache **ppFusionAsmCache);
STDAPI CreateAssemblyIdentity(LPASSEMBLY_IDENTITY *ppAssemblyId, DWORD dwFlags);
STDAPI CreateAssemblyIdentityEx(LPASSEMBLY_IDENTITY *ppAssemblyId, DWORD dwFlags, LPWSTR wzDisplayName);
STDAPI CloneAssemblyIdentity(LPASSEMBLY_IDENTITY pSrcAssemblyId, LPASSEMBLY_IDENTITY *ppDestAssemblyId);
STDAPI CreateAssemblyManifestImport(LPASSEMBLY_MANIFEST_IMPORT *ppAssemblyManifestImport, LPCOLESTR szPath, CDebugLog *pDbgLog, DWORD dwFlags);
STDAPI CreateAssemblyManifestEmit(LPASSEMBLY_MANIFEST_EMIT* ppEmit, LPCOLESTR pwzManifestFilePath, MANIFEST_TYPE eType);
STDAPI CreateAssemblyCacheImport(LPASSEMBLY_CACHE_IMPORT *ppAssemblyCacheImport, LPASSEMBLY_IDENTITY pAssemblyIdentity, DWORD dwFlags);
STDAPI CreateAssemblyCacheEmit(LPASSEMBLY_CACHE_EMIT *ppAssemblyCacheEmit, LPASSEMBLY_CACHE_EMIT pAssemblyCacheEmit, DWORD dwFlags);
STDAPI CreateAssemblyDownload(IAssemblyDownload** ppDownload, CDebugLog *pDbgLog, DWORD dwFlags); 
STDAPI CreateManifestInfo(DWORD dwId, LPMANIFEST_INFO* ppManifestInfo);
STDAPI CreateManifestData(LPCWSTR pwzDataType, LPMANIFEST_DATA* ppManifestData);
STDAPI CreateAssemblyCacheEnum(  LPASSEMBLY_CACHE_ENUM   *ppAssemblyCacheEnum, LPASSEMBLY_IDENTITY pAssemblyIdentity, DWORD dwFlags);


extern RPC_IF_HANDLE __MIDL_itf_fusenet_0156_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusenet_0156_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\assemblydownload.h ===
#pragma once

#include "List.h"
#include "assemblycache.h"
#include "dbglog.h"

class CGlobalCacheInstallEntry;
class CDownloadDlg;


class CAssemblyDownload : public IAssemblyDownload
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBackgroundCopyCallback methods
    STDMETHOD(JobTransferred)(
        /* in */ IBackgroundCopyJob *pJob);

    STDMETHOD(JobError)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ IBackgroundCopyError* pError);

    STDMETHOD(JobModification)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ DWORD dwReserved);


    // IAssemblyDownload methods

    STDMETHOD(DownloadManifestAndDependencies)(
        /* in */ LPWSTR wzApplicationManifestUrl, IAssemblyBindSink *pBindSink, DWORD dwFlags);
    
    STDMETHOD(CancelDownload)();

    CAssemblyDownload();
    ~CAssemblyDownload();
    HRESULT Init( CDebugLog * pDbgLog);


static HRESULT InitBITS();
    CDebugLog *_pDbgLog;
    BOOL _bLocalLog;

private:
    
    HRESULT DoCacheUpdate(IBackgroundCopyJob *pJob);

    HRESULT HandleManifest(IBackgroundCopyFile *pFile, 
        IBackgroundCopyJob **ppJob);

    HRESULT HandleSubscriptionManifest(
        IAssemblyManifestImport *pManifestImport, 
        CString &sLocalName, CString &sRemoteName, 
        IBackgroundCopyJob **ppJob);

    HRESULT HandleApplicationManifest(
        IAssemblyManifestImport *pManifestImport, 
        CString &sLocalName, CString &sRemoteName,
        IBackgroundCopyJob **ppJob);

    HRESULT HandleComponentManifest(
        IAssemblyManifestImport *pManifestImport, 
        CString &sLocalName, CString &sRemoteName,
        IBackgroundCopyJob **ppJob);

    HRESULT HandleFile(IBackgroundCopyFile *pFile);

    HRESULT EnqueueDependencies(IUnknown* pUnk,
        CString &sRemoteName, IBackgroundCopyJob **ppJob);

    HRESULT EnqueueSubscriptionDependencies(
        IAssemblyManifestImport *pManifestImport, CString &sCodebase, 
        CString& sDisplayName, IBackgroundCopyJob **ppJob);

    HRESULT EnqueueApplicationDependencies(IAssemblyCacheImport *pCacheImport,
        CString &sCodebase, CString& sDisplayName, IBackgroundCopyJob **ppJob);

    HRESULT EnqueueComponentDependencies(IAssemblyCacheImport *pCacheImport,
        CString &sCodebase, CString& sDisplayName, BOOL fRecurse, IBackgroundCopyJob **ppJob);

    HRESULT LookupPatchInfo(IAssemblyCacheImport *pCacheImport);

    HRESULT ApplyPatchFile (LPWSTR pwzFilePath);
    HRESULT ResolveFile(CString &sFileName, CString &sLocalFilePath);
    HRESULT CleanUpPatchDir();

    static HRESULT GetBITSErrorMsg(IBackgroundCopyError *pError, CString &sMessage);

    HRESULT CreateNewBITSJob(IBackgroundCopyJob **ppJob, 
        CString &sDisplayName);

    HRESULT MakeTempManifestLocation(CString &sAssemblyName, 
        CString& sManifestFilePath);
    
    HRESULT CleanUpTempFilesOnError(IBackgroundCopyJob *pJob);

    HRESULT IsManifestFile(IBackgroundCopyFile *pFile, BOOL *pbIsManifestFile);

    HRESULT InstallGlobalAssemblies();

    VOID SetJobObject(IBackgroundCopyJob *pJob);
    HRESULT SetErrorCode(HRESULT dwHr);

    HRESULT FinishDownload();

    HRESULT SignalAbort();
    HRESULT HandleError(IBackgroundCopyError *pError, IBackgroundCopyJob *pJob);

    HRESULT DoEvilAvalonRegistrationHack();
    HRESULT IsAvalonAssembly(IAssemblyIdentity *pId, BOOL *pbIsAvalon);

    DWORD                          _dwSig;
    LONG                           _cRef;
    HRESULT                        _hr;
    HRESULT                        _hrError;
    CString                        _sAppBase;
    CString                        _sAppDisplayName;
    IAssemblyCacheEmit            *_pRootEmit;
    IAssemblyBindSink               *_pBindSink;
    IBackgroundCopyJob            *_pJob;
    CDownloadDlg                  *_pDlg;    

    IManifestInfo               *_pPatchingInfo;
    List <CGlobalCacheInstallEntry*> _ListGlobalCacheInstall;
    BOOL                          _bAbort;
    BOOL                          _bAbortFromBindSink;
    BOOL                          _bErrorHandled;
    CRITICAL_SECTION    _cs;
    friend CDownloadDlg;    
    friend HRESULT CreateAssemblyDownload(IAssemblyDownload **ppAssemblyDownload, CDebugLog *pDbgLog, DWORD dwFlags);
};

///////////////////////////////////////////////////////////////////////////////

class CBitsCallback : public IBackgroundCopyCallback
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBackgroundCopyCallback methods
    STDMETHOD(JobTransferred)(
        /* in */ IBackgroundCopyJob *pJob);

    STDMETHOD(JobError)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ IBackgroundCopyError* pError);

    STDMETHOD(JobModification)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ DWORD dwReserved);


    CBitsCallback(IAssemblyDownload *pDownload);
    ~CBitsCallback();

    
    DWORD                          _dwSig;
    LONG                           _cRef;
    HRESULT                        _hr;
    IAssemblyDownload              *_pDownload;
};

///////////////////////////////////////////////////////////////////////////////

class CGlobalCacheInstallEntry
{
public:
    CGlobalCacheInstallEntry();
    ~CGlobalCacheInstallEntry();

    IAssemblyCacheImport* _pICacheImport;
    CString              _sCurrentAssemblyPath;

private:
    DWORD                _dwSig;
};


extern IBackgroundCopyManager* g_pBITSManager;

HRESULT InitBITS();
HRESULT DeleteAssemblyAndModules(LPWSTR pszManifestFilePath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\fusion.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* at Tue Jul 31 11:25:26 2001
 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusion_h__
#define __fusion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IAssemblyEnum_FWD_DEFINED__
#define __IAssemblyEnum_FWD_DEFINED__
typedef interface IAssemblyEnum IAssemblyEnum;
#endif 	/* __IAssemblyEnum_FWD_DEFINED__ */


#ifndef __IInstallReferenceItem_FWD_DEFINED__
#define __IInstallReferenceItem_FWD_DEFINED__
typedef interface IInstallReferenceItem IInstallReferenceItem;
#endif 	/* __IInstallReferenceItem_FWD_DEFINED__ */


#ifndef __IInstallReferenceEnum_FWD_DEFINED__
#define __IInstallReferenceEnum_FWD_DEFINED__
typedef interface IInstallReferenceEnum IInstallReferenceEnum;
#endif 	/* __IInstallReferenceEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusion_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// fusion.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#pragma once




EXTERN_C const IID IID_IAssemblyCache;      
EXTERN_C const IID IID_IAssemblyCacheItem;  
EXTERN_C const IID IID_IAssemblyName;       
EXTERN_C const IID IID_IAssemblyEnum;       
typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0000_0001
    {	ASM_CACHE_ZAP	= 0x1,
	ASM_CACHE_GAC	= 0x2,
	ASM_CACHE_DOWNLOAD	= 0x4
    } 	ASM_CACHE_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_s_ifspec;

#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 

// {8cedc215-ac4b-488b-93c0-a50a49cb2fb8}
DEFINE_GUID(FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID, 0x8cedc215, 0xac4b, 0x488b, 0x93, 0xc0, 0xa5, 0x0a, 0x49, 0xcb, 0x2f, 0xb8);

// {b02f9d65-fb77-4f7a-afa5-b391309f11c9}
DEFINE_GUID(FUSION_REFCOUNT_FILEPATH_GUID, 0xb02f9d65, 0xfb77, 0x4f7a, 0xaf, 0xa5, 0xb3, 0x91, 0x30, 0x9f, 0x11, 0xc9);

// {2ec93463-b0c3-45e1-8364-327e96aea856}
DEFINE_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);
 // {25df0fc1-7f97-4070-add7-4b13bbfd7cb8} // this GUID cannot be used for installing into GAC.
DEFINE_GUID(FUSION_REFCOUNT_MSI_GUID,  0x25df0fc1, 0x7f97, 0x4070, 0xad, 0xd7, 0x4b, 0x13, 0xbb, 0xfd, 0x7c, 0xb8); 
typedef struct _FUSION_INSTALL_REFERENCE_
    {
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    LPCWSTR szIdentifier;
    LPCWSTR szNonCannonicalData;
    } 	FUSION_INSTALL_REFERENCE;

typedef struct _FUSION_INSTALL_REFERENCE_ *LPFUSION_INSTALL_REFERENCE;

typedef const FUSION_INSTALL_REFERENCE *LPCFUSION_INSTALL_REFERENCE;

typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_INSTALL_FLAG_REFRESH (0x00000001)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES (5)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND (6)
#define QUERYASMINFO_FLAG_VALIDATE        (0x00000001)
#define QUERYASMINFO_FLAG_GETSIZE         (0x00000002)
#define ASSEMBLYINFO_FLAG_INSTALLED       (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)

EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyScavenger( 
            /* [out] */ IUnknown **ppUnkReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyScavenger )( 
            IAssemblyCache * This,
            /* [out] */ IUnknown **ppUnkReserved);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)	\
    (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)

#define IAssemblyCache_CreateAssemblyScavenger(This,ppUnkReserved)	\
    (This)->lpVtbl -> CreateAssemblyScavenger(This,ppUnkReserved)

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)	\
    (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCache_UninstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCache_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_QueryAssemblyInfo_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);


void __RPC_STUB IAssemblyCache_QueryAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyCacheItem_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved,
    /* [out] */ IAssemblyCacheItem **ppAsmItem,
    /* [optional][in] */ LPCWSTR pszAssemblyName);


void __RPC_STUB IAssemblyCache_CreateAssemblyCacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyScavenger_Proxy( 
    IAssemblyCache * This,
    /* [out] */ IUnknown **ppUnkReserved);


void __RPC_STUB IAssemblyCache_CreateAssemblyScavenger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_InstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszManifestFilePath,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);


void __RPC_STUB IAssemblyCache_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH (0x00000001)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)

EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition)

#define IAssemblyCacheItem_AbortItem(This)	\
    (This)->lpVtbl -> AbortItem(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_CreateStream_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszStreamName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream **ppIStream,
    /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);


void __RPC_STUB IAssemblyCacheItem_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_Commit_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCacheItem_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_AbortItem_Proxy( 
    IAssemblyCacheItem * This);


void __RPC_STUB IAssemblyCacheItem_AbortItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ASM_NAME_PUBLIC_KEY + 1,
	ASM_NAME_HASH_VALUE	= ASM_NAME_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NAME	= ASM_NAME_HASH_VALUE + 1,
	ASM_NAME_MAJOR_VERSION	= ASM_NAME_NAME + 1,
	ASM_NAME_MINOR_VERSION	= ASM_NAME_MAJOR_VERSION + 1,
	ASM_NAME_BUILD_NUMBER	= ASM_NAME_MINOR_VERSION + 1,
	ASM_NAME_REVISION_NUMBER	= ASM_NAME_BUILD_NUMBER + 1,
	ASM_NAME_CULTURE	= ASM_NAME_REVISION_NUMBER + 1,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ASM_NAME_CULTURE + 1,
	ASM_NAME_OSINFO_ARRAY	= ASM_NAME_PROCESSOR_ID_ARRAY + 1,
	ASM_NAME_HASH_ALGID	= ASM_NAME_OSINFO_ARRAY + 1,
	ASM_NAME_ALIAS	= ASM_NAME_HASH_ALGID + 1,
	ASM_NAME_CODEBASE_URL	= ASM_NAME_ALIAS + 1,
	ASM_NAME_CODEBASE_LASTMOD	= ASM_NAME_CODEBASE_URL + 1,
	ASM_NAME_NULL_PUBLIC_KEY	= ASM_NAME_CODEBASE_LASTMOD + 1,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ASM_NAME_NULL_PUBLIC_KEY + 1,
	ASM_NAME_CUSTOM	= ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NULL_CUSTOM	= ASM_NAME_CUSTOM + 1,
	ASM_NAME_MVID	= ASM_NAME_NULL_CUSTOM + 1,
	ASM_NAME_MAX_PARAMS	= ASM_NAME_MVID + 1
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_ALL	= ASM_CMPF_NAME | ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_REVISION_NUMBER | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE | ASM_CMPF_CUSTOM,
	ASM_CMPF_DEFAULT	= 0x100
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkSink,
            /* [in] */ IUnknown *pUnkContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkSink,
            /* [in] */ IUnknown *pUnkContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty)

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty)

#define IAssemblyName_Finalize(This)	\
    (This)->lpVtbl -> Finalize(This)

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)

#define IAssemblyName_BindToObject(This,refIID,pUnkSink,pUnkContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)	\
    (This)->lpVtbl -> BindToObject(This,refIID,pUnkSink,pUnkContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName)

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow)

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags)

#define IAssemblyName_Clone(This,pName)	\
    (This)->lpVtbl -> Clone(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyName_SetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty);


void __RPC_STUB IAssemblyName_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [out] */ LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty);


void __RPC_STUB IAssemblyName_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Finalize_Proxy( 
    IAssemblyName * This);


void __RPC_STUB IAssemblyName_Finalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetDisplayName_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPOLESTR szDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName,
    /* [in] */ DWORD dwDisplayFlags);


void __RPC_STUB IAssemblyName_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_BindToObject_Proxy( 
    IAssemblyName * This,
    /* [in] */ REFIID refIID,
    /* [in] */ IUnknown *pUnkSink,
    /* [in] */ IUnknown *pUnkContext,
    /* [in] */ LPCOLESTR szCodeBase,
    /* [in] */ LONGLONG llFlags,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD cbReserved,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyName_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetName_Proxy( 
    IAssemblyName * This,
    /* [out][in] */ LPDWORD lpcwBuffer,
    /* [out] */ WCHAR *pwzName);


void __RPC_STUB IAssemblyName_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetVersion_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPDWORD pdwVersionHi,
    /* [out] */ LPDWORD pdwVersionLow);


void __RPC_STUB IAssemblyName_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_IsEqual_Proxy( 
    IAssemblyName * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ DWORD dwCmpFlags);


void __RPC_STUB IAssemblyName_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Clone_Proxy( 
    IAssemblyName * This,
    /* [out] */ IAssemblyName **pName);


void __RPC_STUB IAssemblyName_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IAssemblyEnum_INTERFACE_DEFINED__
#define __IAssemblyEnum_INTERFACE_DEFINED__

/* interface IAssemblyEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00c04f8ef448")
    IAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyEnum * This,
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyEnum * This,
            /* [out] */ IAssemblyEnum **ppEnum);
        
        END_INTERFACE
    } IAssemblyEnumVtbl;

    interface IAssemblyEnum
    {
        CONST_VTBL struct IAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyEnum_GetNextAssembly(This,pvReserved,ppName,dwFlags)	\
    (This)->lpVtbl -> GetNextAssembly(This,pvReserved,ppName,dwFlags)

#define IAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyEnum_GetNextAssembly_Proxy( 
    IAssemblyEnum * This,
    /* [in] */ LPVOID pvReserved,
    /* [out] */ IAssemblyName **ppName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyEnum_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Reset_Proxy( 
    IAssemblyEnum * This);


void __RPC_STUB IAssemblyEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Clone_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IAssemblyEnum **ppEnum);


void __RPC_STUB IAssemblyEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceItem_INTERFACE_DEFINED__
#define __IInstallReferenceItem_INTERFACE_DEFINED__

/* interface IInstallReferenceItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("582dac66-e678-449f-aba6-6faaec8a9394")
    IInstallReferenceItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReference( 
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReference )( 
            IInstallReferenceItem * This,
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceItemVtbl;

    interface IInstallReferenceItem
    {
        CONST_VTBL struct IInstallReferenceItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceItem_GetReference(This,ppRefData,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetReference(This,ppRefData,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceItem_GetReference_Proxy( 
    IInstallReferenceItem * This,
    /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceItem_GetReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceItem_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceEnum_INTERFACE_DEFINED__
#define __IInstallReferenceEnum_INTERFACE_DEFINED__

/* interface IInstallReferenceEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56b1a988-7c0c-4aa2-8639-c3eb5a90226f")
    IInstallReferenceEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextInstallReferenceItem( 
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextInstallReferenceItem )( 
            IInstallReferenceEnum * This,
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceEnumVtbl;

    interface IInstallReferenceEnum
    {
        CONST_VTBL struct IInstallReferenceEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceEnum_GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceEnum_GetNextInstallReferenceItem_Proxy( 
    IInstallReferenceEnum * This,
    /* [out] */ IInstallReferenceItem **ppRefItem,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceEnum_GetNextInstallReferenceItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusion_0116 */
/* [local] */ 

STDAPI CreateInstallReferenceEnum(IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyEnum(IAssemblyEnum **pEnum, IUnknown *pUnkReserved, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
STDAPI GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath); 


extern RPC_IF_HANDLE __MIDL_itf_fusion_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0116_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\patchingutil.h ===
#pragma once

STDAPI CreatePatchingUtil(IXMLDOMNode *pPatchNode, IPatchingUtil **ppPatchingInfo);

class CPatchingUtil : public IPatchingUtil
{
    public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD (Init)(
        /* in */ IXMLDOMNode *pPatchNode);

    // Pre-download
    STDMETHOD (MatchTarget)(
        /* in */ LPWSTR pwzTarget, 
        /* out */ IManifestInfo **ppPatchInfo);

    // Post-download
    STDMETHOD (MatchPatch)(
        /* in */ LPWSTR pwzPatch,
        /* out */ IManifestInfo **ppPatchInfo);
    
    static HRESULT CreatePatchingInfo(IXMLDOMDocument2 *pXMLDOMDocument, IAssemblyCacheImport *pCacheImport, IManifestInfo **ppPatchingInfo);


    CPatchingUtil();
    ~CPatchingUtil();

    private:
            
    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

    IXMLDOMNode *_pXMLPatchNode;    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\regclass.h ===
#pragma once

// ---------------------------------------------------------------------------
// CRegEmit
// ---------------------------------------------------------------------------
class CRegEmit
{
    private:

    HRESULT _hr;
    HKEY     _hBaseKey;
    
   CRegEmit();

    public:
    
    ~CRegEmit();

    HRESULT WriteDword(LPCWSTR pwzValue, DWORD dwData);
    HRESULT WriteString(LPCWSTR pwzValue, CString &sData );
    HRESULT WriteString(LPCWSTR pwzValue, LPCWSTR pwzData, DWORD ccData = 0);
    HRESULT DeleteKey(LPCWSTR pwzSubKey);

    static HRESULT Create(CRegEmit **ppEmit, LPCWSTR pwzRelKeyPath, CRegEmit *pParentEmit = NULL);

};



// ---------------------------------------------------------------------------
// CRegImport
// ---------------------------------------------------------------------------
class CRegImport
{
    private:

    HRESULT _hr;
    HKEY     _hBaseKey;

    CRegImport();

    public:

    ~CRegImport();

    HRESULT Check(LPCWSTR pwzValue, BOOL &bExist);
    HRESULT ReadDword(LPCWSTR pwzValue, LPDWORD pdwData);
    HRESULT ReadString(LPCWSTR pwzValue, CString &sData);
    HRESULT EnumKeys(DWORD n, CString &sKey);
    HRESULT EnumKeys(DWORD n, CRegImport **ppImport);

    static HRESULT Create(CRegImport **ppImport, LPCWSTR pwzRelKeyPath, CRegImport *pParentImport = NULL);
    static HRESULT Create(CRegImport **ppImport, LPCWSTR pwzRelKeyPath, HKEY hkeyRoot);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\legacy\asmexec.cs ===
/*=============================================================================
**
** Class: AsmExecute
**
** Purpose: Used to setup the correct hosting environment before executing an assembly
**
** Date: 10/20/2000
**        5/10/2001  Rev for CLR Beta2
**
** Copyright (c) Microsoft, 1999-2001
**
=============================================================================*/

using System.Reflection;
using System.Configuration.Assemblies;

[assembly:AssemblyCultureAttribute("")]
[assembly:AssemblyVersionAttribute("1.0.704.0")]
[assembly:AssemblyKeyFileAttribute(/*"..\..\*/"asmexecKey.snk")]

[assembly:AssemblyTitleAttribute("Microsoft Fusion .Net Assembly Execute Host")]
[assembly:AssemblyDescriptionAttribute("Microsoft Fusion Network Services CLR Host for executing .Net assemblies")]
[assembly:AssemblyProductAttribute("Microsoft Fusion Network Services")]
[assembly:AssemblyInformationalVersionAttribute("1.0.0.0")]
[assembly:AssemblyTrademarkAttribute("Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation")]
[assembly:AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:AssemblyCopyrightAttribute("Copyright  Microsoft Corp. 1999-2001. All rights reserved.")]


//BUGBUG??
[assembly:System.CLSCompliant(true)]


//namespace Microsoft {
namespace FusionCLRHost {

    using System;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Globalization;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Collections;
    using System.Runtime.InteropServices;

    using System.IO;
    using System.Net;

//    [GuidAttribute("E612D54D-B42A-32B5-B1D7-8490CE09705C")]
    public interface IAsmExecute
    {
        int Execute(string codebase, Int32 flags, Int32 evidenceZone, string evidenceSrcUrl, string stringArg);
    }

    [GuidAttribute("7EB9A84D-646E-3764-BBCA-3789CDB3447B")]
    public class AsmExecute : MarshalByRefObject, IAsmExecute
    {
        // this must be the same as defined in the caller...
        private static readonly int SECURITY_NONE = 0x00;
        private static readonly int SECURITY_ZONE = 0x01;
        private static readonly int SECURITY_SITE = 0x02;

        private static readonly int TYPE_AVALON = 0x1000;

        public AsmExecute()
        {
            appbasePath = null;
            appbaseURL = null;
            loadingAssembly = false;
        }
        
        // Arguments: Codebase, flags, zone, srcurl
        // If the flags indicate zone then a zone must be provided. 
        // If the flags indicate a site then a srcurl must be provided, codebase must be a filepath
        public int Execute(string codebase, Int32 flags, Int32 evidenceZone, string evidenceSrcUrl, string stringArg)
        {
            string file = codebase;
            if((file.Length == 0) || (file[0] == '\0'))
                throw new ArgumentException("Invalid codebase");

            Console.WriteLine("Codebase- {0}", file);

            // Find the appbase of the executable. For now we assume the 
            // form to be http://blah/... with forward slashes. This
            // need to be update.
            // Note: aso works with '\' as in file paths
            string appbase = null;
            string ConfigurationFile = null;
            int k = file.LastIndexOf('/');
            if(k <= 0)
            {
                k = file.LastIndexOf('\\');
                if(k == 0) 
                {
                    appbase = file;
                    ConfigurationFile = file;
                }
            }

            if(k != 0)
            {
                // if k is still < 0 at this point, appbase should be an empty string
                appbase = file.Substring(0,k+1);
                if(k+1 < file.Length) 
                    ConfigurationFile = file.Substring(k+1);
            }

            // Check 1: disallow non-fully qualified path/codebase
            if ((appbase.Length == 0) || (appbase[0] == '.'))
                throw new ArgumentException("Codebase must be fully qualified");
            
            // BUGBUG: should appbase be the source of the code, not local?
            Console.WriteLine("AppBase- {0}", appbase);

            // Build up the configuration File name
            if(ConfigurationFile != null)
            {
                StringBuilder bld = new StringBuilder();
                bld.Append(ConfigurationFile);
                bld.Append(".config");
                ConfigurationFile = bld.ToString();
            }

            Console.WriteLine("Config- {0}", ConfigurationFile);

            // Get the flags 
            // 0x1 we have Zone
            // 0x2 we have a unique id.
            int dwFlag = flags;

            Evidence securityEvidence = null;

            // Check 2: disallow called with no evidence
            if (dwFlag == SECURITY_NONE)
            {
                // BUGBUG?: disallow executing with no evidence
                throw new ArgumentException("Flag set at no evidence");
            }

            if((dwFlag & SECURITY_SITE) != 0 ||
               (dwFlag & SECURITY_ZONE) != 0) 
                securityEvidence = new Evidence();

            // BUGBUG: check other invalid cases for dwFlag

            string appURLbase = null;

            if((dwFlag & SECURITY_ZONE) != 0)
            {
                int zone = evidenceZone;
                securityEvidence.AddHost( new Zone((System.Security.SecurityZone)zone) );

                Console.WriteLine("Evidence Zone- {0}", zone);
            }
            if((dwFlag & SECURITY_SITE) != 0)
            {
                if (file.Length<7||String.Compare(file.Substring(0,7),"file://",true)!=0)
                {
                    securityEvidence.AddHost( System.Security.Policy.Site.CreateFromUrl(evidenceSrcUrl) );

                    Console.WriteLine("Evidence SiteFromUrl- {0}", evidenceSrcUrl);
                
                    // BUGBUG: possible security hole? - if this intersects with Url/Zone _may_ resolve to a less restrictive policy...
                    // if srcUrl is given, assume file/appbase is a local file path
                    StringBuilder bld = new StringBuilder();
                    bld.Append("file://");
                    bld.Append(appbase);
                    securityEvidence.AddHost( new ApplicationDirectory(bld.ToString()) );

                    Console.WriteLine("Evidence AppDir- {0}", bld);
                }

                // URLs may be matched exactly or by a wildcard in the final position,
                // for example: http://www.fourthcoffee.com/process/*
                StringBuilder bld2 = new StringBuilder();
                if (evidenceSrcUrl[evidenceSrcUrl.Length-1] == '/')
                    bld2.Append(evidenceSrcUrl);
                else
                {
                    int j = evidenceSrcUrl.LastIndexOf('/');
                    if(j > 0)
                    {
                        if (j > 7)  // evidenceSrcUrl == "http://a/file.exe"
                            bld2.Append(evidenceSrcUrl.Substring(0,j+1));
                        else
                        {
                            // evidenceSrcUrl == "http://foo.com" -> but why?
                            bld2.Append(evidenceSrcUrl);
                            bld2.Append('/');
                        }
                    }
                    else
                        throw new ArgumentException("Invalid Url format");
                }

                appURLbase = bld2.ToString();

                bld2.Append('*');

                securityEvidence.AddHost( new Url(bld2.ToString()) );

                Console.WriteLine("Evidence Url- {0}", bld2);
            }

            // other evidence: Hash, Publisher, StrongName

            // NOTENOTE: not effective if not both url and zone in evidence

            // Populate the PolicyLevel with code groups that will do the following:
            // 1) For all assemblies that come from this app's cache directory, 
            //    give permissions from retrieved permission set from SecurityManager.
            // 2) For all other assemblies, give FullTrust permission set.  Remember,
            //    since the permissions will be intersected with other policy levels,
            //    just because we grant full trust to all other assemblies does not mean
            //    those assemblies will end up with full trust.

            // Create a new System.Security.Policy.PolicyStatement that does not contain any permissions.
            PolicyStatement Nada = new PolicyStatement(new PermissionSet(PermissionState.None));//PermissionSet());

            // Create a System.Security.Policy.FirstMatchCodeGroup as the root that matches all
            // assemblies by supplying an AllMembershipCondition:
            FirstMatchCodeGroup RootCG = new FirstMatchCodeGroup(new AllMembershipCondition(), Nada);

            // ResolvePolicy will return a System.Security.PermissionSet
            PermissionSet AppPerms = SecurityManager.ResolvePolicy(securityEvidence);

            // Create another PolicyStatement for the permissions that we want to grant to code from the app directory:
            PolicyStatement AppStatement = new PolicyStatement(AppPerms);

            // Create a child UnionCodeGroup to handle the assemblies from the app cache.  We do this
            // by using a UrlMembershipCondition set to the app cache directory:
            UnionCodeGroup AppCG = new UnionCodeGroup(new UrlMembershipCondition("file://"+appbase+"*"), AppStatement);

            // Add AppCG to RootCG as first child.  This is important because we need it to be evaluated first
//	     if ((dwFlag & TYPE_AVALON) == 0)
            	RootCG.AddChild(AppCG);

            // Create another PolicyStatement so all other code gets full trust, by passing in an _unrestricted_ PermissionSet
            PolicyStatement FullTrustStatement = new PolicyStatement(new PermissionSet(PermissionState.Unrestricted));

            // Create a second child UnionCodeGroup to handle all other code, by using the AllMembershipCondition again
            UnionCodeGroup AllCG = new UnionCodeGroup(new AllMembershipCondition(), FullTrustStatement);

            // Add AllCG to RootCG after AppCG.  If AppCG doesnt apply to the assembly, AllCG will.
            RootCG.AddChild(AllCG);

            // This will be the PolicyLevel that we will associate with the new AppDomain.
            PolicyLevel AppPolicy = PolicyLevel.CreateAppDomainLevel();

            // Set the RootCG as the root code group on the new policy level
            AppPolicy.RootCodeGroup = RootCG;

            // NOTENOTE
            // Code from the site that lives on the local machine will get the reduced permissions as expected.
            // Dependencies of this app (not under app dir or maybe dependencies that live in the GAC) would still get full trust.  
            // If the full trust dependencies need to do something trusted, they carry the burden of asserting to overcome the stack walk.

            // Set domain name to site name if possible
            string friendlyName = null;
            if((dwFlag & SECURITY_SITE) != 0)
                friendlyName = GetSiteName(evidenceSrcUrl);
            else
                friendlyName = GetSiteName(file);
            Console.WriteLine("AppDomain friendlyName- {0}", friendlyName);

            // set up arguments
            // only allow 1 for now
            string[] args;
            if (stringArg != null)
            {
                args = new string[1];
                args[0] = stringArg;
            }
            else
                args = new string[0];

            AppDomainSetup properties = new AppDomainSetup();
//            properties.DisallowPublisherPolicy=true;  // not allowed to set safe mode
            properties.ApplicationBase = appbase;   // BUGBUG: security? see note on ApplicationDirectory above
            properties.PrivateBinPath = "bin";
            if(ConfigurationFile != null)
                properties.ConfigurationFile = ConfigurationFile;   // should not set config file if it doesnot exist?

            AppDomain proxy = AppDomain.CreateDomain(friendlyName, null, properties);
            if(proxy != null) 
            {
                // set the AppPolicy policy level as the policy level for the AppDomain
                proxy.SetAppDomainPolicy(AppPolicy);

                AssemblyName asmname = Assembly.GetExecutingAssembly().GetName();
                Console.WriteLine("AsmExecute name- {0}", asmname);

                try
                {
                    // Use remoting. Otherwise asm will be loaded both in current and the new AppDomain
                    // ... as explained by URT dev
                    // asmexec.dll must be found on path (CorPath?) or in the GAC for this to work.
                    ObjectHandle handle = proxy.CreateInstance(asmname.FullName, "FusionCLRHost.AsmExecute");
                    if (handle != null)
                    {
                        AsmExecute execproxy = (AsmExecute)handle.Unwrap();
                        int retVal = -1;

                        if (execproxy != null)
                        {
                            // prepare for on-demand/asm resolution
                            execproxy.InitOnDemand(appbase, appURLbase);
                        }

                        Console.WriteLine("\n========");
                        
                        if (execproxy != null)
                        {
                            if((dwFlag & TYPE_AVALON) != 0)
                                retVal = execproxy.ExecuteAsAvalon(file, securityEvidence, args);
                            else
                                retVal = execproxy.ExecuteAsAssembly(file, securityEvidence, args);
                        }

                        Console.WriteLine("\n========");

                        return retVal;
                    }

                }
                catch(Exception e)
                {
                    Console.WriteLine("AsmExecute CreateInstance(AsmExecute) / execute assembly failed:\n{0}: {1}", e.GetType(), e.Message);
                    throw e;
                }
            } 
            else
                Console.WriteLine("AsmExecute CreateDomain failed");

            // BUGBUG: throw Exception?
            return -1;           
        }

        // This method must be internal, since it asserts the ControlEvidence permission.
        // private --> require ReflectionPermission not known how
        // solution: public but LinkDemand StrongNameIdentity of ours
        [ComVisible(false)]
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010013F3CD6C291DF1566D3C6E7269800C35D9212A622FA934492AD0833DAEA2574D12A9AA2A9392FF30A892ECD3F7F9B57211A541CC4712A184450992E143C1BDBC864E31826598B0D90BB2F04C5C50F004771370F9C76444696E8DC18999A3D8448D26EBF3A9E68796CA3A7D2ACC47B491455E462F4E6DDD9DF338171D911D88B2" )]
        public int ExecuteAsAssembly(string file, Evidence evidence, string[] args)
        {
            new PermissionSet(PermissionState.Unrestricted).Assert();
            return AppDomain.CurrentDomain.ExecuteAssembly(file, evidence, args);
        }

        // This method must be internal, since it asserts the ControlEvidence permission.
        [ComVisible(false)]
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010013F3CD6C291DF1566D3C6E7269800C35D9212A622FA934492AD0833DAEA2574D12A9AA2A9392FF30A892ECD3F7F9B57211A541CC4712A184450992E143C1BDBC864E31826598B0D90BB2F04C5C50F004771370F9C76444696E8DC18999A3D8448D26EBF3A9E68796CA3A7D2ACC47B491455E462F4E6DDD9DF338171D911D88B2" )]
        public int ExecuteAsAvalon(string file, Evidence evidence,  string[] args)
        {
            new PermissionSet(PermissionState.Unrestricted).Assert();

            // evidence not used....??

            // do not catch exceptions
            Assembly assembly = Assembly.Load("Avalon.Application");

            Console.WriteLine("Avalon.Application name- {0}", assembly.GetName());

            Object obj = assembly.CreateInstance("Avalon.Application.AvalonContext", false);
            if (obj == null)
                throw new TypeLoadException("A failure has occurred while loading Avalon.Application.AvalonContext");

            Object [] argObjects = new Object [] {new String[] {file}};//args}; avalon arg hack

            // instance method, void ExecuteApp(string[] args) 
            // BUGBUG: ensure matching sig/arg list?
            MethodInfo method = obj.GetType().GetMethod("ExecuteApp",
                                            BindingFlags.Instance|BindingFlags.Public|BindingFlags.DeclaredOnly);

            if (method == null)
                throw new MissingMethodException("Avalon.Application.AvalonContext", "ExecuteApp");

            try
            {
                // note: use BindingFlags.InvokeMethod|BindingFlags.ExactBinding|BindingFlags.SuppressChangeType?
                Object pRet=method.Invoke(obj, argObjects);

                Console.WriteLine("Avalon.Application.AvalonContext.ExecuteApp() method invoke succeeded");
            }
            catch (Exception e)
            {
                // unwrap the real exception, usually == e.InnerException
                throw e.GetBaseException();
            }
            
            return 0;
        }

        private static string GetSiteName(string pURL) 
        {
            // BUGBUG: this does not work w/ UNC or file:// (?)
            string siteName = null;
            if(pURL != null) {
                int j = pURL.IndexOf(':');  
                
                // If there is a protocal remove it. In a URL of the form
                // yyyy://xxxx/zzzz   where yyyy is the protocal, xxxx is
                // the site and zzzz is extra we want to get xxxx.
                if(j != -1 && 
                   j+3 < pURL.Length &&
                   pURL[j+1] == '/' &&
                   pURL[j+2] == '/') 
                    {
                        j+=3;
                        
                        // Remove characters after the
                        // next /.  
                        int i = pURL.IndexOf('/',j);
                        if(i > -1) 
                            siteName = pURL.Substring(j,i-j);
                        else 
                            siteName = pURL.Substring(j);
                    }
            
                if(siteName == null)
                    siteName = pURL;
            }
            return siteName;
        }


        //**************************************************************
        // InitOnDemand()
        //**************************************************************
        [ComVisible(false)]
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010013F3CD6C291DF1566D3C6E7269800C35D9212A622FA934492AD0833DAEA2574D12A9AA2A9392FF30A892ECD3F7F9B57211A541CC4712A184450992E143C1BDBC864E31826598B0D90BB2F04C5C50F004771370F9C76444696E8DC18999A3D8448D26EBF3A9E68796CA3A7D2ACC47B491455E462F4E6DDD9DF338171D911D88B2" )]
        public void InitOnDemand(string path, string url)
        {
            // initialize on-demand assmebly download and resolution

            // add assembly resolve event handler
            AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(OnAssemblyResolve);

            // set paths
            appbasePath = path;
            appbaseURL = url;
        }

        protected string appbasePath;
        protected string appbaseURL;
        protected bool loadingAssembly;

        //**************************************************************
        // OnAssemblyResolve()
        //**************************************************************
        private Assembly OnAssemblyResolve(Object sender, ResolveEventArgs args)
        {
            // Check to see if the AssemblyLoad in this event is what caused the
            // event to fire again.  If so, the load failed.
            // If no URL is given, on-demand download cannot be done

            if (loadingAssembly==true || appbaseURL==null)
                return null;

            loadingAssembly=true;

            string[] AssemblyNameParts = args.Name.Split(new Char[] {','}, 2);
            string AssemblyName = AssemblyNameParts[0] + ".dll";

            // permission needed for file IO etc
            new PermissionSet(PermissionState.Unrestricted).Assert();

            try
            {
                GetFile(AssemblyName);
            }
            catch
            {
                // GetFile fails - next time may succeed

                // BUGBUG: offline or background download scenarios? set background download?
                loadingAssembly=false;
                return null;
            }

            Assembly assembly;
            try 
            {
                assembly = Assembly.Load(args.Name);
            } 
            catch 
            {
                // should throw a custom exception or event here.

                assembly = null;
                // return null;
            }
            finally
            {
                loadingAssembly=false;
            }

            return assembly;
        }

        //**************************************************************
        // GetFile()
        //**************************************************************
        private void GetFile(string name)
        {
            HttpWebResponse Response;

            //Retrieve the File
            HttpWebRequest Request = (HttpWebRequest)HttpWebRequest.Create(appbaseURL + name);

            try 
            {
                Response = (HttpWebResponse)Request.GetResponse();
            }
            catch(WebException e) 
            {
                throw e;

                // BUGBUG: apply probing rules?
            }

            Stream responseStream = Response.GetResponseStream();

            // setup UI
            // BUGBUG: allow no UI case?

            // BUGBUG: test with file > 4GB
            Int64 totalLength = 0;
            int factor = (int) (Response.ContentLength / int.MaxValue);
            int max = int.MaxValue;
            if (factor <= 1)
            {
                factor = 1;
                max = (int) Response.ContentLength;
            }
            if (max <= -1)
            {
                // no content length returned from the server (-1),
                //  or error (what does < -1 mean?)

                // no progress, set max to 0
                max = 0;
            }

            DownloadStatus statusForm = new DownloadStatus(0, max);
            statusForm.SetStatus(0);
            statusForm.Show();

            // write from stream to disk
            byte[] buffer = new byte[4096];
            int length;

            try{
                FileStream AFile = File.Open(appbasePath+name, FileMode.Create, FileAccess.ReadWrite);

                length = responseStream.Read(buffer, 0, 4096);
                while ( length != 0 )
                {
                    AFile.Write(buffer, 0, length);

                    if (max != 0)
                    {
                        totalLength += length;
                        statusForm.SetStatus((int) (totalLength/factor));
                    }

                    length = responseStream.Read(buffer, 0, 4096);

                    // dispatch messages
                    System.Windows.Forms.Application.DoEvents();
                }
                AFile.Close();

                statusForm.SetMessage("Download complete");
            }
            catch(Exception e)
            {
                statusForm.SetMessage(e.Message);
                // BUGBUG: AFile may not be closed
            }

            responseStream.Close();

            //Pause for a moment to show the status dialog in
            //case the app downloaded extremely quickly (small file?).
            statusForm.Refresh();
            System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1));
            statusForm.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\regdb.h ===
#ifndef _REG_DB_H_

#define _REG_DB_H_


HRESULT AddJobToRegistry(LPWSTR pwzURL,
                         LPWSTR pwzTempFile, 
                         IBackgroundCopyJob *pJob, 
                         DWORD dwFlags);

#define RJFR_DELETE_FILES (0x1)

HRESULT RemoveJobFromRegistry(IBackgroundCopyJob *pJob, 
                              GUID *pGUID, SHREGDEL_FLAGS dwDelRegFlags, 
                              DWORD dwFlags);

void FusionFormatGUID(GUID guid, CString& sGUID);

HRESULT FusionParseGUID(
    LPWSTR String,
    SIZE_T Cch,
    GUID &rGuid
    );

HRESULT ProcessOrphanedJobs();

/*
HRESULT StringToGUID(LPCWSTR pSrc, UINT cSrc, GUID *pGUID);

HRESULT GUIDToString(GUID *pGUID, CString& sGUID);

*/

#endif // _REG_DB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bits_ie.rc
//
#define IDS_LONGPROGRESS                1
#define IDS_ERROR                       2
#define IDS_SHORTPROGRESS               3
#define IDS_QUEUED                      4
#define IDS_CONNECTING                  5
#define IDS_TRANSFERRING                6
#define IDS_SUSPENDED                   7
#define IDS_FATALERROR                  8
#define IDS_TRANSIENTERROR              9
#define IDS_TRANSFERRED                 10
#define IDS_ACKNOWLEDGED                11
#define IDS_CANCELLED                   12
#define IDS_UNKNOWN                     13
#define IDS_DAYSFORMAT                  14
#define IDS_HOURSFORMAT                 15
#define IDS_MINUTESFORMAT               16
#define IDS_SECONDSFORMAT               17
#define IDS_FOREGROUND                  18
#define IDS_HIGH                        19
#define IDS_NORMAL                      20
#define IDS_LOW                         21
#define IDS_ERRORBOXTITLE               22
#define IDS_FILEDLGTITLE                23
#define IDS_CANCELCAPTION               24
#define IDS_CANCELTEXT                  25
#define IDS_NOHTTPORHTTPS               26
#define IDS_ALLFILES                    27
#define IDS_STARTUPLINK                 28
#define IDS_CLOSECAPTION                29
#define IDS_CLOSETEXT                   30
#define IDS_ALREADYFINISHED             31
#define IDS_ALREADYFINISHEDCAPTION      32
#define IDS_GIGAFORMAT                  33
#define IDS_MEGAFORMAT                  34
#define IDS_KILOFORMAT                  35
#define IDS_BYTEFORMAT                  36
#define IDS_MAX                          IDS_BYTEFORMAT
#define IDD_DIALOG                      101
#define IDI_ICON                        105
#define IDA_DOWNLOADING               106
#define IDC_ANIMATE_DOWNLOAD          1003
#define IDC_COMPLETE2                   1004
#define IDC_FINISH                      1004
#define IDC_CANCEL2                     1005
#define IDC_CANCEL                      1005
#define IDC_SUSPEND2                    1006
#define IDC_SUSPEND                     1006
#define IDC_PROGRESS                    1007
#define IDC_PROGRESSBAR                 1007
#define IDC_STATUSTXT                   1008
#define IDC_CREATIONTIMETXT             1009
#define IDC_MODIFICATONTIMETXT          1010
#define IDC_COMPLETIONTIMETXT           1011
#define IDC_ESTIMATEDTIMETXT            1012
#define IDC_TRANSFERRATETXT             1013
#define IDC_PRIORITY                    1014
#define IDC_RESUME2                     1015
#define IDC_RESUME                      1015
#define IDC_PRIORITYTXT                 1016
#define IDC_ERRORMSGTXT                 1017
#define IDC_STATUS                      1021
#define IDC_STARTTIME                   1022
#define IDC_MODIFICATIONTIME            1023
#define IDC_COMPLETIONTIME              1024
#define IDC_ESTIMATEDTIME               1025
#define IDC_TRANSFERRATE                1026
#define IDC_ERRORMSG                    1027
#define IDC_PROGRESSINFOTXT             1045
#define IDC_PROGRESSINFO                1046
#define IDC_DISPLAYNAME                 1047

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\thash.h ===
#pragma once

#include <tlist.h>

//////////////////////////////////////////////////////////////////////////////
// Hash table entry.
//////////////////////////////////////////////////////////////////////////////
template<class T, class V> class THashTableEntry
{
public:

    DWORD _dwSig;
    HRESULT _hr;

    T            _tKey;
    V            _vItem;
    DWORD   _dwHash;

    THashTableEntry(T& tKey, V& vItem);
    ~THashTableEntry();
};


//-----------------------------------------------------------------------------
// THashTableEntry ctor
//-----------------------------------------------------------------------------
template<class T, class V> THashTableEntry<T, V>::THashTableEntry(T& tKey, V& vItem)
    : _hr(S_OK), _dwSig('RTNE')
{    
    IF_FAILED_EXIT(_tKey.Assign(tKey));

    IF_FAILED_EXIT(_vItem.Assign(vItem));

    IF_FAILED_EXIT(_tKey.GetHash(&_dwHash, T::CaseSensitive));

    exit:

    return;
}

//-----------------------------------------------------------------------------
// THashTableEntry dtor
//-----------------------------------------------------------------------------
template<class T, class V> THashTableEntry<T, V>::~THashTableEntry() 
{ }


//////////////////////////////////////////////////////////////////////////////
// Hash table class
//////////////////////////////////////////////////////////////////////////////
template<class T, class V> class THashTable
{
public:

    THashTable();
    THashTable(DWORD nSlots);
    ~THashTable();

    HRESULT Init(DWORD nSlots);
    HRESULT Destruct();
    HRESULT Insert(T& tKey, V& vItem);
    HRESULT Retrieve(T& tKey, V** ppvItem);

private:

    HRESULT _hr;
    DWORD   _dwSig;
    DWORD   _nSlots;
    TList<THashTableEntry<T, V> *> *_pListArray;
};

//-----------------------------------------------------------------------------
// THashTable ctor
//-----------------------------------------------------------------------------
template<class T, class V> THashTable<T, V>::THashTable()
    : _hr(S_OK), _dwSig('HSAH'), _nSlots(0), _pListArray(NULL)
{}

//-----------------------------------------------------------------------------
// THashTable ctor
//-----------------------------------------------------------------------------
template<class T, class V> THashTable<T, V>::THashTable(DWORD nSlots)
    : THashTable()
{
    Init(nSlots);
}


//-----------------------------------------------------------------------------
// THashTable dtor
//-----------------------------------------------------------------------------
template<class T, class V> THashTable<T, V>::~THashTable(void)
{
    Destruct();
    SAFEDELETEARRAY(_pListArray);
}

//-----------------------------------------------------------------------------
// THashTable::Init
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Init(DWORD nSlots)
{
    _nSlots = nSlots;

    _pListArray = new TList<THashTableEntry<T, V> * > [_nSlots];

    IF_ALLOC_FAILED_EXIT((_pListArray));

exit:

    return _hr;
}


//-----------------------------------------------------------------------------
// THashTable::Insert
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Insert(T& tKey, V& vItem)
{    
    _hr = S_OK;
    
    THashTableEntry<T, V> *pEntry = new THashTableEntry<T, V>(tKey, vItem);

    IF_ALLOC_FAILED_EXIT(pEntry);

    IF_FALSE_EXIT((pEntry->_hr == S_OK), pEntry->_hr);

    IF_FAILED_EXIT(_pListArray[(pEntry->_dwHash) % _nSlots].Insert(pEntry));

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// THashTable::Retrieve
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Retrieve(T& tKey, V** ppvItem)
{
    _hr = S_OK;

    DWORD dwHash = 0;
    BOOL     bFound = FALSE;

    THashTableEntry<T, V> **ppEntry = 0;

    tKey.GetHash(&dwHash, T::CaseSensitive);

    TList_Iter<THashTableEntry<T, V> * > Iterator(_pListArray[dwHash % _nSlots]);

    while (ppEntry = Iterator.Next())
    {
        if (dwHash != ((*ppEntry)->_dwHash))
            continue;

        IF_FAILED_EXIT(tKey.CompareString((*ppEntry)->_tKey));

        if (_hr == S_OK)
        {
            bFound = TRUE;
            break;
        }
    }

exit:

    *ppvItem = bFound ? &((*ppEntry)->_vItem) : NULL;
    _hr = bFound ? S_OK : S_FALSE;

    return _hr;

}

//-----------------------------------------------------------------------------
// THashTable::Destruct
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Destruct()
{        
    for (DWORD i = 0; i < _nSlots; i++)
        _pListArray[i].Destruct();            

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

#include <macros.h>
#include <cstrings.h>
#include <regclass.h>
#include <fusenetincludes.h>

#undef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; };

#undef SAFEDELETEARRAY
#define SAFEDELETEARRAY(p) if ((p) != NULL) { delete[] (p); (p) = NULL; };

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };

#define KNOWN_SYSTEM_ASSEMBLY 0
#define KNOWN_TRUSTED_ASSEMBLY 1


inline
WCHAR*
WSTRDupDynamic(LPCWSTR pwszSrc)
{
    LPWSTR pwszDest = NULL;
    if (pwszSrc != NULL)
    {
        const DWORD dwLen = lstrlenW(pwszSrc) + 1;
        pwszDest = new WCHAR[dwLen];
        if( pwszDest )
            memcpy(pwszDest, pwszSrc, dwLen * sizeof(WCHAR));
    }
    return pwszDest;
}



HRESULT ConvertVersionStrToULL(LPCWSTR pwzVerStr, ULONGLONG *pullVersion);

HRESULT
RemoveDirectoryAndChildren(LPWSTR szDir);
            
HRESULT FusionpHresultFromLastError();

VOID MakeRandomString(LPWSTR wzRandom, DWORD cc);
HRESULT CreateRandomDir(LPWSTR pwzRootPath, LPWSTR pwzRandomDir, DWORD cchDirLen);

HRESULT CreateDirectoryHierarchy(LPWSTR pwzRootDir, LPWSTR pwzFilePath);

HRESULT IsKnownAssembly(IAssemblyIdentity *pId, DWORD dwFlags);

BOOL EnsureDebuggerPresent();

BOOL DoHeapValidate();

HRESULT DoPathCombine(CString& sDest, LPWSTR pwzSource);

HRESULT CheckFileExistence(LPCWSTR pwzFile, BOOL *pbExists);

HRESULT FusionCompareString(LPCWSTR pwz1, LPWSTR pwz2, DWORD dwFlags);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\tlist.h ===
#pragma once

#include <macros.h>

//////////////////////////////////////////////////////////////////////////////
// slink
//////////////////////////////////////////////////////////////////////////////
struct slink
{
    DWORD _dwSig;
    slink* next;
    slink() { _dwSig = 'KNLS'; next = NULL; }
    slink(slink* p) { next = p; }
};


//////////////////////////////////////////////////////////////////////////////
// tlink
//////////////////////////////////////////////////////////////////////////////
template<class T> struct tlink : public slink
{
    T info;
    tlink( T& t) : info(t) { }
};



//////////////////////////////////////////////////////////////////////////////
// slist
// slist of slinks
//////////////////////////////////////////////////////////////////////////////
class slist
{
    DWORD _dwSig;
    slink *last;

public:

    void insert(slink* p);
    void append(slink* p);
    slink* get();

    slist() { _dwSig = 'TSLS'; last = NULL; }
    slist(slink* p) { last = p->next = p; }

    friend class slist_iter;
};



//////////////////////////////////////////////////////////////////////////////
// slist iterator
//////////////////////////////////////////////////////////////////////////////
class slist_iter
{
    slink* ce;
    slist* cs;

public:
    inline slist_iter(slist& s);
    inline slink* next();
};

//-----------------------------------------------------------------------------
// slist_iter ctor
//-----------------------------------------------------------------------------
slist_iter::slist_iter(slist& s)
{
    cs = &s;
    ce = cs->last;
}

//-----------------------------------------------------------------------------
// slist_iter::next
//-----------------------------------------------------------------------------
slink* slist_iter::next()
{
    slink* p = ce ? (ce=ce->next) : 0;

    if (ce == cs->last) 
        ce = 0;

    return p;
}

template<class T> class TList_Iter;

//////////////////////////////////////////////////////////////////////////////
// TList
// list of tlinks
//////////////////////////////////////////////////////////////////////////////
template<class T> class TList : private slist
{
public:

    HRESULT Insert( T& t);
    HRESULT Append( T& t);
    void Destruct();

    friend class TList_Iter<T>;
};

//-----------------------------------------------------------------------------
// TList::Insert
//-----------------------------------------------------------------------------
template<class T> HRESULT TList<T>::Insert( T& t)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    tlink<T> *pt = new tlink<T>(t);
        
    IF_ALLOC_FAILED_EXIT(pt);

    slist::insert(pt);

exit:

    return hr;
}

//-----------------------------------------------------------------------------
// TList::Append
//-----------------------------------------------------------------------------
template<class T> HRESULT TList<T>::Append( T& t)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    tlink<T> *pt = new tlink<T>(t);

    IF_ALLOC_FAILED_EXIT(pt);

    slist::append(pt);

exit:

    return hr;
}


//-----------------------------------------------------------------------------
// TList::Destruct
//-----------------------------------------------------------------------------
template<class T> void TList<T>::Destruct()
{
    tlink<T>* lnk;
    
    while (lnk = (tlink<T>*) slist::get())
    {
        delete lnk->info;
        delete lnk;
    }
}


//////////////////////////////////////////////////////////////////////////////
// TList iterator.
//////////////////////////////////////////////////////////////////////////////
template<class T> class TList_Iter : private slist_iter
{
public:

    TList_Iter(TList<T>& s) : slist_iter(s) { }

    inline T* Next ();
};

//-----------------------------------------------------------------------------
// TList_Iter::next
//-----------------------------------------------------------------------------
template<class T> T* TList_Iter<T>::Next ()
{
    slink* p = slist_iter::next();
    return p ? &(((tlink<T>*) p)->info) : NULL; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\manifestimport.h ===
#pragma once
#include <comdef.h>
#include "dbglog.h"


// manifest data types:
#define WZ_DATA_PLATFORM_MANAGED L"platform_managed"
#define WZ_DATA_PLATFORM_OS             L"platform_os"
#define WZ_DATA_PLATFORM_DOTNET     L"platform_dotnet"
#define WZ_DATA_OSVERSIONINFO           L"osversioninfo"

class CAssemblyManifestImport : public IAssemblyManifestImport
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();



    STDMETHOD(GetAssemblyIdentity)( 
        /* out */ LPASSEMBLY_IDENTITY *ppAssemblyId);

    STDMETHOD(GetManifestApplicationInfo)(
        /* out */ IManifestInfo **ppAppInfo);

    STDMETHOD(GetSubscriptionInfo)(
        /* out */ IManifestInfo **ppSubsInfo);

    STDMETHOD(GetNextPlatform)(
        /* in */ DWORD nIndex,
        /* out */ IManifestData **ppPlatformInfo);

    STDMETHOD(GetNextFile)( 
        /* in  */ DWORD    nIndex,
        /* out */ IManifestInfo **ppAssemblyFile);
 
    STDMETHOD(QueryFile)(
        /* in  */ LPCOLESTR pwzFileName,
        /* out */ IManifestInfo **ppAssemblyFile);
    
    STDMETHOD(GetNextAssembly)( 
        /* in */ DWORD nIndex,
        /* out */ IManifestInfo **ppDependAsm);

    STDMETHOD(ReportManifestType)(
        /*out*/  DWORD *pdwType);

    STDMETHOD (GetXMLDoc)(
        /* out */ IXMLDOMDocument2 **pXMLDoc);

    static HRESULT XMLtoAssemblyIdentity(IXMLDOMNode *pIDOMNode,
        LPASSEMBLY_IDENTITY *ppAssemblyFile);

    static HRESULT ParseAttribute(IXMLDOMNode *pIXMLDOMNode, BSTR bstrAttributeName, 
        LPWSTR *ppwzAttributeValue, LPDWORD pccAttributeValueOut);

    
    ~CAssemblyManifestImport();

    HRESULT static InitGlobalCritSect();
    void static DelGlobalCritSect();

private:
    HRESULT XMLtoOSVersionInfo(IXMLDOMNode *pIDOMNode, LPMANIFEST_DATA pPlatformInfo);
    HRESULT XMLtoDotNetVersionInfo(IXMLDOMNode *pIDOMNode, LPMANIFEST_DATA pPlatformInfo);

    // Instance specific data
    DWORD                    _dwSig;
    HRESULT                  _hr;
    LONG                     _cRef;
    LPASSEMBLY_IDENTITY      _pAssemblyId;
    IXMLDOMDocument2        *_pXMLDoc;
    IXMLDOMNodeList         *_pXMLFileNodeList;            
    LONG                     _nFileNodes;
    IXMLDOMNodeList         *_pXMLAssemblyNodeList;
    LONG                     _nAssemblyNodes;
    IXMLDOMNodeList         *_pXMLPlatformNodeList;
    LONG                     _nPlatformNodes;
    BSTR                     _bstrManifestFilePath;
    CDebugLog               *_pDbgLog;
    // Globals
    static CRITICAL_SECTION   g_cs;
    
public:
    enum eStringTableId
    {
        Name = 0,
        Version,
        Language,
        PublicKey,
        PublicKeyToken,
        ProcessorArchitecture,
        Type,

        SelNameSpaces,
        NameSpace,
        SelLanguage,
        XPath,
        FileNode,
        FileName,
        FileHash,
        AssemblyId,
        DependentAssemblyNode,
        DependentAssemblyCodebase,
        Codebase,
        
        ShellState,
        FriendlyName,        // note: this must be in sync with MAN_APPLICATION in fusenet.idl
        EntryPoint,
        EntryImageType,
        IconFile,
        IconIndex,
        ShowCommand,
        HotKey,
        Activation,
        AssemblyName,
        AssemblyClass,
        AssemblyMethod,
        AssemblyArgs,
        Patch,
        PatchInfo,
        Source,
        Target,
        PatchFile,
        AssemblyIdTag,
        Compressed,
        Subscription,
        SynchronizeInterval,
        IntervalUnit,
        SynchronizeEvent,
        EventDemandConnection,
        File,
        Cab,

        AssemblyNode,
        ApplicationNode,
        VersionWildcard,
        Desktop,
        Dependency,
        DependentAssembly,
        Install,
        InstallType,

        Platform,
        PlatformInfo,
        OSVersionInfo,
        DotNetVersionInfo,
        Href,
        OS,
        MajorVersion,       // note: the following must be in order
        MinorVersion,
        BuildNumber,
        ServicePackMajor,
        ServicePackMinor,
        Suite,
        ProductType,
        SupportedRuntime,

        MAX_STRINGS
    };

    struct StringTableEntry
    {
        const WCHAR *pwz;
        BSTR         bstr;
        SIZE_T       Cch;
    };

    static StringTableEntry g_StringTable[MAX_STRINGS];

    static HRESULT InitGlobalStringTable();
    static HRESULT FreeGlobalStringTable();

private:
    
    CAssemblyManifestImport(CDebugLog *);

    HRESULT Init(LPCOLESTR wzManifestFilePath);

    static HRESULT IsCLRManifest(LPCOLESTR pwzManifestFilePath);

    HRESULT LoadDocumentSync();
    
    HRESULT CreateAssemblyFileEx(IManifestInfo **ppAssemblyFile, IXMLDOMNode * pIDOMNode);
    
    friend HRESULT CreateAssemblyManifestImport(IAssemblyManifestImport** ppImport, 
        LPCOLESTR pwzManifestFilePath, CDebugLog *pDbgLog, DWORD dwFlags);

friend class CAssemblyManifestEmit; // for sharing BSTR and access to _pXMLDoc

};


inline CAssemblyManifestImport::eStringTableId operator++(CAssemblyManifestImport::eStringTableId &rs, int)
{
    return rs = (CAssemblyManifestImport::eStringTableId) (rs+1);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\sxsapi.h ===
#pragma once

#include <sxstypes.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Opaque ASSEMBLY_IDENTITY structure
//

typedef struct _ASSEMBLY_IDENTITY *PASSEMBLY_IDENTITY;
typedef const struct _ASSEMBLY_IDENTITY *PCASSEMBLY_IDENTITY;

//
//  The types of assembly identities.
//
//  Definitions may not include wildcard attributes; definitions
//  match only if they are exactly equal.  A wildcard matches
//  a definition if for all the non-wildcarded attributes,
//  there is an exact match.  References may not contain
//  wildcarded attributes but may contain a different set of
//  attributes than a definition that they match.  (Example:
//  definitions carry the full public key of the publisher, but
//  references usually carry just the "strong name" which is
//  the first 8 bytes of the SHA-1 hash of the public key.)
//

#define ASSEMBLY_IDENTITY_TYPE_DEFINITION (1)
#define ASSEMBLY_IDENTITY_TYPE_REFERENCE (2)
#define ASSEMBLY_IDENTITY_TYPE_WILDCARD (3)

#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE L"urn:schemas-microsoft-com:asm.v1"
#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH (32)

#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY                     L"assembly"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_CCH                 (8)
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY            L"assemblyIdentity"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY_CCH        (16)

#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION L"configuration"
#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH (13)

#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION           L"manifestVersion"
#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION_CCH       (15)

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME                       L"name"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME_CCH                   (4)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION                    L"version"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION_CCH                (7)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE                   L"language"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE_CCH               (8)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY                 L"publicKey"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_CCH             (9)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN           L"publicKeyToken"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN_CCH       (14)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE     L"processorArchitecture"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE_CCH (21)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE                       L"type"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE_CCH                   (4)

// Pseudo-value used in some places when the language= attribute is missing from the identity.
// An identity that does not have language is implicitly "worldwide".

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE          L"x-ww"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE_CCH      (4)

//
//  All win32 assemblies must have "win32" as their type.
//

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32                L"win32"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32_CCH            (5)

#define SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING      (0x00000001)

//
//  SXS_ASSEMBLY_IDENTITY_FLAG_FROZEN means that the assembly
//  identity's contents are frozen and are not subject to additional
//  change.
//

#define ASSEMBLY_IDENTITY_FLAG_FROZEN           (0x80000000)

//
//  ASSEMBLY_IDENTITY_ATTRIBUTE structure
//

typedef struct _ASSEMBLY_IDENTITY_ATTRIBUTE {
    ULONG   Flags;
    SIZE_T  NamespaceCch;
    SIZE_T  NameCch;
    SIZE_T  ValueCch;
    const WCHAR *Namespace;
    const WCHAR *Name;
    const WCHAR *Value;
} ASSEMBLY_IDENTITY_ATTRIBUTE, *PASSEMBLY_IDENTITY_ATTRIBUTE;

typedef const struct _ASSEMBLY_IDENTITY_ATTRIBUTE *PCASSEMBLY_IDENTITY_ATTRIBUTE;

typedef enum _ASSEMBLY_IDENTITY_INFORMATION_CLASS {
    AssemblyIdentityBasicInformation = 1,
} ASSEMBLY_IDENTITY_INFORMATION_CLASS;

typedef struct _ASSEMBLY_IDENTITY_BASIC_INFORMATION {
    ULONG Flags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
} ASSEMBLY_IDENTITY_BASIC_INFORMATION, *PASSEMBLY_IDENTITY_BASIC_INFORMATION;

#define SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE    (0x00000001)

#define SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF (0x00000001)

#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE    (0x00000001)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME         (0x00000002)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE        (0x00000004)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED   (0x00000008)

#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE    (0x00000001)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME         (0x00000002)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE        (0x00000004)

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID          (0)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN        (1)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL            (2)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN     (3)

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE     (0x00000001)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME          (0x00000002)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE         (0x00000004)

#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE       (0x00000001)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME            (0x00000002)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE           (0x00000004)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS    (0x00000008)


//
//  Rather than making "n" heap allocations, the pattern for SxsGetAssemblyIdentityAttributeByOrdinal()
//  is to call once with BufferSize = 0 or some reasonable fixed number to get the size of the
//  buffer required, allocate the buffer if the buffer passed in was too small and call again.
//
//  The strings returned in the ASSEMBLY_IDENTITY_ATTRIBUTE are *not*
//  dynamically allocated, but are instead expected to fit in the buffer passed in.
//

#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE         (0x00000001)
#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL     (0x00000002)

#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE (0x00000001)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME      (0x00000002)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE     (0x00000004)

//
//  Assembly Identity encoding:
//
//  Assembly identities may be encoded in various forms.  The two usual ones
//  are either a binary stream, suitable for embedding in other data structures
//  or for persisting or a textual format that looks like:
//
//      name;[ns1,]n1="v1";[ns2,]n2="v2"[;...]
//

#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY (1)
#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL (2)

#define SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE        (0x00000001)

typedef VOID (* PRTLSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE)(
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PVOID Context
    );


#define STATUS_SXS_UNKNOWN_ENCODING_GROUP                   (0xc0100010)
#define STATUS_SXS_UNKNOWN_ENCODING                         (0xc0100011)
#define STATUS_SXS_INVALID_XML_NAMESPACE_URI                (0xc0100012)
#define STATUS_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME (0xc0100013)
#define STATUS_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE      (0xc0100014)

#ifdef __cplusplus
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\version.h ===
/**
 * Version strings for the project binaries
 * 
 * Copyright (c) 2001 Microsoft Corporation
 */

// Standard version includes

#pragma once

#include <winver.h>
#include <ntverp.h>

//
// Version
//
// Version numbers can be assigned in newbuild.cmd
//

#ifndef FUS_VER_MAJORVERSION
#define FUS_VER_MAJORVERSION 1
#endif

#ifndef FUS_VER_MINORVERSION
#define FUS_VER_MINORVERSION 0
#endif

#ifndef FUS_VER_PRODUCTBUILD
#define FUS_VER_PRODUCTBUILD 1016
#endif

#ifndef FUS_VER_PRODUCTBUILD_QFE
#define FUS_VER_PRODUCTBUILD_QFE 0
#endif

//
// Allow a component to override values in individual rc files
// by checking if these are already defined
//
#ifndef FUS_VER_PRODUCTNAME_STR
#define FUS_VER_PRODUCTNAME_STR      "Microsoft Application Deployment Framework"
#endif

#ifndef FUS_VER_INTERNALNAME_STR
#define FUS_VER_INTERNALNAME_STR     "CLICKONCE"
#endif

// the followings are defined in individual RC files:
//      FUS_VER_ORIGINALFILENAME_STR
//      FUS_VER_FILEDESCRIPTION_STR

//
// Don't edit the remainder of this file to change version values.
// Edit above instead.
//

//#if FUSBLDTYPE_FREE
//#define FUS_BLDTYPE_STR     "Free"
//#elif FUSBLDTYPE_ICECAP
//#define FUS_BLDTYPE_STR     "Icecap"
//#elif FUSBLDTYPE_RETAIL
//#define FUS_BLDTYPE_STR     "Retail"
//#else //FUSBLDTYPE_DEBUG
//#define FUS_BLDTYPE_STR     "Debug"
//#endif

#if DBG
#define FUS_BLDTYPE_STR     "Debug"
#else
#define FUS_BLDTYPE_STR     "Retail"
#endif

//
// undefine these values as some are defined in sdk\inc\ntverp.h
//

#ifdef VER_MAJORVERSION
#undef VER_MAJORVERSION
#endif

#ifdef VER_MINORVERSION
#undef VER_MINORVERSION
#endif

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifdef VER_INTERNALNAME_STR
#undef VER_INTERNALNAME_STR
#endif

#ifdef VER_ORIGINALFILENAME_STR
#undef VER_ORIGINALFILENAME_STR
#endif

#ifdef VER_FILEDESCRIPTION_STR
#undef VER_FILEDESCRIPTION_STR
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_FILETYPE
#undef VER_FILETYPE
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#define VER_MAJORVERSION         FUS_VER_MAJORVERSION
#define VER_MINORVERSION         FUS_VER_MINORVERSION
#define VER_PRODUCTBUILD         FUS_VER_PRODUCTBUILD
#define VER_PRODUCTBUILD_QFE     FUS_VER_PRODUCTBUILD_QFE

#define VER_PRODUCTNAME_STR      FUS_VER_PRODUCTNAME_STR
#define VER_INTERNALNAME_STR     FUS_VER_INTERNALNAME_STR
#define VER_ORIGINALFILENAME_STR FUS_VER_ORIGINALFILENAME_STR
#define VER_FILEDESCRIPTION_STR  FUS_VER_FILEDESCRIPTION_STR

#define CONCAT5HELPER(a, b, c, d, e)      #a "." #b "." #c "." #d " " e
#define CONCAT5(a, b, c, d, e)            CONCAT5HELPER(a, b, c, d, e)

#define CONCAT5HELPER_L(a, b, c, d, e)    L ## #a L"." L ## #b L"." L ## #c L"." L ## #d L" " L ## e
#define CONCAT5_L(a, b, c, d, e)          CONCAT5HELPER_L(a, b, c, d, e)

#define VER_PRODUCTVERSION_STR   CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)
#define VER_PRODUCTVERSION_STR_L CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)

#define VER_PRODUCTVERSION       VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILEVERSION_STR      CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)
#define VER_FILEVERSION_STR_L    CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)

#define VER_FILEVERSION          VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          VFT2_UNKNOWN
//#define VER_FILESUBTYPE             VFT_UNKNOWN


// Standard NT build defines

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR



#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP */
#ifndef _CRTIMP
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#define WCHAR_MIN       0
#define WCHAR_MAX       ((wchar_t)-1)

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

#ifndef _CTYPE_DISABLE_MACROS
inline int __cdecl isleadbyte(int _C)
        {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif

#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);
_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);
_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#ifndef __cplusplus
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __cdecl getwchar()
        {return (fgetwc(&_iob[0])); }   /* stdin */
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, &_iob[1])); }       /* stdout */
#endif  /* __cplusplus */

#define getwc(_stm)     fgetwc(_stm)
#define putwc(_c,_stm)  fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

#ifdef  __cplusplus
        #define _WConst_return  const
#else
        #define _WConst_return
#endif

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP _WConst_return wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#ifdef  __cplusplus
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
}

extern "C" {
#endif  /* __cplusplus */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */

_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif



typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP wint_t __cdecl btowc(int);
_CRTIMP size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

_CRTIMP size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
_CRTIMP size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
_CRTIMP int __cdecl wctob(wint_t);

#ifdef  __cplusplus

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#if     defined(_M_IA64)
void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif
void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\shlwapi.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/


#ifndef _INC_SHLWAPI
#define _INC_SHLWAPI

#ifndef NOSHLWAPI

#include <objbase.h>
#include <shtypes.h>


#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif


#ifdef UNIX
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
typedef interface IInternetSecurityManager IInternetSecurityManager;
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHLWAPI
#if !defined(_SHLWAPI_)
#define LWSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define LWSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#define LWSTDAPIV         EXTERN_C DECLSPEC_IMPORT HRESULT STDAPIVCALLTYPE
#define LWSTDAPIV_(type)  EXTERN_C DECLSPEC_IMPORT type STDAPIVCALLTYPE
#else
#define LWSTDAPI          STDAPI
#define LWSTDAPI_(type)   STDAPI_(type)
#define LWSTDAPIV         STDAPIV
#define LWSTDAPIV_(type)  STDAPIV_(type)
#endif
#endif // WINSHLWAPI

#ifdef _WIN32
#include <pshpack8.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions
//    NO_SHLWAPI_PATH       Path functions
//    NO_SHLWAPI_REG        Registry functions
//    NO_SHLWAPI_STREAM     Stream functions
//    NO_SHLWAPI_GDI        GDI helper functions

#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

LWSTDAPI_(LPSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(int)      StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCSpnA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(int)      StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(LPSTR)    StrDupA(LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrDupW(LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrFormatByteSizeA(DWORD dw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPSTR)    StrFormatByteSize64A(LONGLONG qdw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPWSTR)   StrFormatByteSizeW(LONGLONG qdw, LPWSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPWSTR)   StrFormatKBSizeW(LONGLONG qdw, LPWSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPSTR)    StrFormatKBSizeA(LONGLONG qdw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(int)      StrFromTimeIntervalA(LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(int)      StrFromTimeIntervalW(LPWSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(BOOL)     StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     StrIsIntlEqualW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar);
LWSTDAPI_(LPSTR)    StrNCatA(LPSTR psz1, LPCSTR psz2, int cchMax);
LWSTDAPI_(LPWSTR)   StrNCatW(LPWSTR psz1, LPCWSTR psz2, int cchMax);
LWSTDAPI_(LPSTR)    StrPBrkA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(LPWSTR)   StrPBrkW(LPCWSTR psz, LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrSpnA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(int)      StrSpnW(LPCWSTR psz, LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrStrA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrToIntA(LPCSTR lpSrc);
LWSTDAPI_(int)      StrToIntW(LPCWSTR lpSrc);
LWSTDAPI_(BOOL)     StrToIntExA(LPCSTR pszString, DWORD dwFlags, int * piRet);
LWSTDAPI_(BOOL)     StrToIntExW(LPCWSTR pszString, DWORD dwFlags, int * piRet);
#if (_WIN32_IE >= 0x0600)
LWSTDAPI_(BOOL)     StrToInt64ExA(LPCSTR pszString, DWORD dwFlags, LONGLONG * pllRet);
LWSTDAPI_(BOOL)     StrToInt64ExW(LPCWSTR pszString, DWORD dwFlags, LONGLONG * pllRet);
#endif
LWSTDAPI_(BOOL)     StrTrimA(LPSTR psz, LPCSTR pszTrimChars);
LWSTDAPI_(BOOL)     StrTrimW(LPWSTR psz, LPCWSTR pszTrimChars);

LWSTDAPI_(LPWSTR)   StrCatW(LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpIW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyW(LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax);

LWSTDAPI_(LPWSTR)   StrCatBuffW(LPWSTR pszDest, LPCWSTR pszSrc, int cchDestBuffSize);
LWSTDAPI_(LPSTR)    StrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize);

LWSTDAPI_(BOOL)     ChrCmpIA(WORD w1, WORD w2);
LWSTDAPI_(BOOL)     ChrCmpIW(WCHAR w1, WCHAR w2);

LWSTDAPI_(int)      wvnsprintfA(LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, va_list arglist);
LWSTDAPI_(int)      wvnsprintfW(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, va_list arglist);
LWSTDAPIV_(int)     wnsprintfA(LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, ...);
LWSTDAPIV_(int)     wnsprintfW(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ...);

#define StrIntlEqNA( s1, s2, nChar) StrIsIntlEqualA( TRUE, s1, s2, nChar)
#define StrIntlEqNW( s1, s2, nChar) StrIsIntlEqualW( TRUE, s1, s2, nChar)
#define StrIntlEqNIA(s1, s2, nChar) StrIsIntlEqualA(FALSE, s1, s2, nChar)
#define StrIntlEqNIW(s1, s2, nChar) StrIsIntlEqualW(FALSE, s1, s2, nChar)

LWSTDAPI StrRetToStrA(STRRET *pstr, LPCITEMIDLIST pidl, LPSTR *ppsz);
LWSTDAPI StrRetToStrW(STRRET *pstr, LPCITEMIDLIST pidl, LPWSTR *ppsz);
#ifdef UNICODE
#define StrRetToStr  StrRetToStrW
#else
#define StrRetToStr  StrRetToStrA
#endif // !UNICODE
LWSTDAPI StrRetToBufA(STRRET *pstr, LPCITEMIDLIST pidl, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI StrRetToBufW(STRRET *pstr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define StrRetToBuf  StrRetToBufW
#else
#define StrRetToBuf  StrRetToBufA
#endif // !UNICODE
LWSTDAPI StrRetToBSTR(STRRET *pstr, LPCITEMIDLIST pidl, BSTR *pbstr);

// helper to duplicate a string using the task allocator

LWSTDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz);
LWSTDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz);
#ifdef UNICODE
#define SHStrDup  SHStrDupW
#else
#define SHStrDup  SHStrDupA
#endif // !UNICODE

LWSTDAPI_(int) StrCmpLogicalW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(DWORD) StrCatChainW(LPWSTR pszDst, DWORD cchDst, DWORD ichAt, LPCWSTR pszSrc);

LWSTDAPI SHLoadIndirectString(LPCWSTR pszSource, LPWSTR pszOutBuf, UINT cchOutBuf, void **ppvReserved);


#ifdef UNICODE
#define StrChr                  StrChrW
#define StrRChr                 StrRChrW
#define StrChrI                 StrChrIW
#define StrRChrI                StrRChrIW
#define StrCmpN                 StrCmpNW
#define StrCmpNI                StrCmpNIW
#define StrStr                  StrStrW
#define StrStrI                 StrStrIW
#define StrDup                  StrDupW
#define StrRStrI                StrRStrIW
#define StrCSpn                 StrCSpnW
#define StrCSpnI                StrCSpnIW
#define StrSpn                  StrSpnW
#define StrToInt                StrToIntW
#define StrPBrk                 StrPBrkW
#define StrToIntEx              StrToIntExW
#if (_WIN32_IE >= 0x0600)
#define StrToInt64Ex            StrToInt64ExW
#endif
#define StrFromTimeInterval     StrFromTimeIntervalW
#define StrIntlEqN              StrIntlEqNW
#define StrIntlEqNI             StrIntlEqNIW
#define StrFormatByteSize       StrFormatByteSizeW
#define StrFormatByteSize64     StrFormatByteSizeW
#define StrFormatKBSize         StrFormatKBSizeW
#define StrNCat                 StrNCatW
#define StrTrim                 StrTrimW
#define StrCatBuff              StrCatBuffW
#define ChrCmpI                 ChrCmpIW
#define wvnsprintf              wvnsprintfW
#define wnsprintf               wnsprintfW
#define StrIsIntlEqual          StrIsIntlEqualW


#else
#define StrChr                  StrChrA
#define StrRChr                 StrRChrA
#define StrChrI                 StrChrIA
#define StrRChrI                StrRChrIA
#define StrCmpN                 StrCmpNA
#define StrCmpNI                StrCmpNIA
#define StrStr                  StrStrA
#define StrStrI                 StrStrIA
#define StrDup                  StrDupA
#define StrRStrI                StrRStrIA
#define StrCSpn                 StrCSpnA
#define StrCSpnI                StrCSpnIA
#define StrSpn                  StrSpnA
#define StrToInt                StrToIntA
#define StrPBrk                 StrPBrkA
#define StrToIntEx              StrToIntExA
#if (_WIN32_IE >= 0x0600)
#define StrToInt64Ex            StrToInt64ExA
#endif
#define StrFromTimeInterval     StrFromTimeIntervalA
#define StrIntlEqN              StrIntlEqNA
#define StrIntlEqNI             StrIntlEqNIA
#define StrFormatByteSize       StrFormatByteSizeA
#define StrFormatByteSize64     StrFormatByteSize64A
#define StrFormatKBSize         StrFormatKBSizeA
#define StrNCat                 StrNCatA
#define StrTrim                 StrTrimA
#define StrCatBuff              StrCatBuffA
#define ChrCmpI                 ChrCmpIA
#define wvnsprintf              wvnsprintfA
#define wnsprintf               wnsprintfA
#define StrIsIntlEqual          StrIsIntlEqualA
#endif


// Backward compatible to NT's non-standard naming (strictly
// for comctl32)
//
LWSTDAPI_(BOOL)     IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar);

#define IntlStrEqNA( s1, s2, nChar) IntlStrEqWorkerA( TRUE, s1, s2, nChar)
#define IntlStrEqNW( s1, s2, nChar) IntlStrEqWorkerW( TRUE, s1, s2, nChar)
#define IntlStrEqNIA(s1, s2, nChar) IntlStrEqWorkerA(FALSE, s1, s2, nChar)
#define IntlStrEqNIW(s1, s2, nChar) IntlStrEqWorkerW(FALSE, s1, s2, nChar)

#ifdef UNICODE
#define IntlStrEqN              IntlStrEqNW
#define IntlStrEqNI             IntlStrEqNIW
#else
#define IntlStrEqN              IntlStrEqNA
#define IntlStrEqNI             IntlStrEqNIA
#endif

#define SZ_CONTENTTYPE_HTMLA       "text/html"
#define SZ_CONTENTTYPE_HTMLW       L"text/html"
#define SZ_CONTENTTYPE_CDFA        "application/x-cdf"
#define SZ_CONTENTTYPE_CDFW        L"application/x-cdf"

#ifdef UNICODE
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLW
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFW
#else
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLA
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFA
#endif

#define PathIsHTMLFileA(pszPath)     PathIsContentTypeA(pszPath, SZ_CONTENTTYPE_HTMLA)
#define PathIsHTMLFileW(pszPath)     PathIsContentTypeW(pszPath, SZ_CONTENTTYPE_HTMLW)

// Flags for StrToIntEx
#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L


#define StrCatA                 lstrcatA
#define StrCmpA                 lstrcmpA
#define StrCmpIA                lstrcmpiA
#define StrCpyA                 lstrcpyA
#define StrCpyNA                lstrcpynA


#define StrToLong               StrToInt
#define StrNCmp                 StrCmpN
#define StrNCmpI                StrCmpNI
#define StrNCpy                 StrCpyN
#define StrCatN                 StrNCat

#ifdef UNICODE
#define StrCat                  StrCatW
#define StrCmp                  StrCmpW
#define StrCmpI                 StrCmpIW
#define StrCpy                  StrCpyW
#define StrCpyN                 StrCpyNW
#define StrCatBuff              StrCatBuffW
#else
#define StrCat                  lstrcatA
#define StrCmp                  lstrcmpA
#define StrCmpI                 lstrcmpiA
#define StrCpy                  lstrcpyA
#define StrCpyN                 lstrcpynA
#define StrCatBuff              StrCatBuffA
#endif


#endif //  NO_SHLWAPI_STRFCNS


#ifndef NO_SHLWAPI_PATH

//
//=============== Path Routines ===================================
//

LWSTDAPI_(LPSTR)  PathAddBackslashA(LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathAddBackslashW(LPWSTR pszPath);
#ifdef UNICODE
#define PathAddBackslash  PathAddBackslashW
#else
#define PathAddBackslash  PathAddBackslashA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAddExtensionA(LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathAddExtensionW(LPWSTR pszPath, LPCWSTR pszExt);
#ifdef UNICODE
#define PathAddExtension  PathAddExtensionW
#else
#define PathAddExtension  PathAddExtensionA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAppendA(LPSTR pszPath, LPCSTR pMore);
LWSTDAPI_(BOOL)     PathAppendW(LPWSTR pszPath, LPCWSTR pMore);
LWSTDAPI_(LPSTR)  PathBuildRootA(LPSTR pszRoot, int iDrive);
LWSTDAPI_(LPWSTR)  PathBuildRootW(LPWSTR pszRoot, int iDrive);
#ifdef UNICODE
#define PathBuildRoot  PathBuildRootW
#else
#define PathBuildRoot  PathBuildRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCanonicalizeA(LPSTR pszBuf, LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathCanonicalizeW(LPWSTR pszBuf, LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathCombineA(LPSTR pszDest, LPCSTR pszDir, LPCSTR pszFile);
LWSTDAPI_(LPWSTR)  PathCombineW(LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
#ifdef UNICODE
#define PathCombine  PathCombineW
#else
#define PathCombine  PathCombineA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCompactPathA(HDC hDC, LPSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathW(HDC hDC, LPWSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathExA(LPSTR pszOut, LPCSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(BOOL)     PathCompactPathExW(LPWSTR pszOut, LPCWSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(int)      PathCommonPrefixA(LPCSTR pszFile1, LPCSTR pszFile2, LPSTR achPath);
LWSTDAPI_(int)      PathCommonPrefixW(LPCWSTR pszFile1, LPCWSTR pszFile2, LPWSTR achPath);
LWSTDAPI_(BOOL)     PathFileExistsA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathFileExistsW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFileExists  PathFileExistsW
#else
#define PathFileExists  PathFileExistsA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindExtensionA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindExtensionW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindExtension  PathFindExtensionW
#else
#define PathFindExtension  PathFindExtensionA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindFileNameA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindFileNameW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindFileName  PathFindFileNameW
#else
#define PathFindFileName  PathFindFileNameA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindNextComponentA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindNextComponentW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindNextComponent  PathFindNextComponentW
#else
#define PathFindNextComponent  PathFindNextComponentA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathFindOnPathA(LPSTR pszPath, LPCSTR * ppszOtherDirs);
LWSTDAPI_(BOOL)     PathFindOnPathW(LPWSTR pszPath, LPCWSTR * ppszOtherDirs);
LWSTDAPI_(LPSTR)  PathGetArgsA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathGetArgsW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetArgs  PathGetArgsW
#else
#define PathGetArgs  PathGetArgsA
#endif // !UNICODE
LWSTDAPI_(LPCSTR) PathFindSuffixArrayA(LPCSTR pszPath, const LPCSTR *apszSuffix, int iArraySize);
LWSTDAPI_(LPCWSTR) PathFindSuffixArrayW(LPCWSTR pszPath, const LPCWSTR *apszSuffix, int iArraySize);
#ifdef UNICODE
#define PathFindSuffixArray  PathFindSuffixArrayW
#else
#define PathFindSuffixArray  PathFindSuffixArrayA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsLFNFileSpecA(LPCSTR lpName);
LWSTDAPI_(BOOL)     PathIsLFNFileSpecW(LPCWSTR lpName);
#ifdef UNICODE
#define PathIsLFNFileSpec  PathIsLFNFileSpecW
#else
#define PathIsLFNFileSpec  PathIsLFNFileSpecA
#endif // !UNICODE

LWSTDAPI_(UINT)     PathGetCharTypeA(UCHAR ch);
LWSTDAPI_(UINT)     PathGetCharTypeW(WCHAR ch);

// Return flags for PathGetCharType
#define GCT_INVALID             0x0000
#define GCT_LFNCHAR             0x0001
#define GCT_SHORTCHAR           0x0002
#define GCT_WILD                0x0004
#define GCT_SEPARATOR           0x0008

LWSTDAPI_(int)      PathGetDriveNumberA(LPCSTR pszPath);
LWSTDAPI_(int)      PathGetDriveNumberW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetDriveNumber  PathGetDriveNumberW
#else
#define PathGetDriveNumber  PathGetDriveNumberA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectory  PathIsDirectoryW
#else
#define PathIsDirectory  PathIsDirectoryA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyW
#else
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsFileSpecA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsFileSpecW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsFileSpec  PathIsFileSpecW
#else
#define PathIsFileSpec  PathIsFileSpecA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsPrefixA(LPCSTR pszPrefix, LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsPrefixW(LPCWSTR pszPrefix, LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsPrefix  PathIsPrefixW
#else
#define PathIsPrefix  PathIsPrefixA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRelativeA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRelativeW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRelative  PathIsRelativeW
#else
#define PathIsRelative  PathIsRelativeA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRootA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRoot  PathIsRootW
#else
#define PathIsRoot  PathIsRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSameRootA(LPCSTR pszPath1, LPCSTR pszPath2);
LWSTDAPI_(BOOL)     PathIsSameRootW(LPCWSTR pszPath1, LPCWSTR pszPath2);
#ifdef UNICODE
#define PathIsSameRoot  PathIsSameRootW
#else
#define PathIsSameRoot  PathIsSameRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNC  PathIsUNCW
#else
#define PathIsUNC  PathIsUNCA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsNetworkPathA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsNetworkPathW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsNetworkPath  PathIsNetworkPathW
#else
#define PathIsNetworkPath  PathIsNetworkPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServer  PathIsUNCServerW
#else
#define PathIsUNCServer  PathIsUNCServerA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerShareA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerShareW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServerShare  PathIsUNCServerShareW
#else
#define PathIsUNCServerShare  PathIsUNCServerShareA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsContentTypeA(LPCSTR pszPath, LPCSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsContentTypeW(LPCWSTR pszPath, LPCWSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsURLA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsURLW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsURL  PathIsURLW
#else
#define PathIsURL  PathIsURLA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathMakePrettyA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathMakePrettyW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathMatchSpecA(LPCSTR pszFile, LPCSTR pszSpec);
LWSTDAPI_(BOOL)     PathMatchSpecW(LPCWSTR pszFile, LPCWSTR pszSpec);
LWSTDAPI_(int)      PathParseIconLocationA(LPSTR pszIconFile);
LWSTDAPI_(int)      PathParseIconLocationW(LPWSTR pszIconFile);
LWSTDAPI_(void)     PathQuoteSpacesA(LPSTR lpsz);
LWSTDAPI_(void)     PathQuoteSpacesW(LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathRelativePathToA(LPSTR pszPath, LPCSTR pszFrom, DWORD dwAttrFrom, LPCSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(BOOL)     PathRelativePathToW(LPWSTR pszPath, LPCWSTR pszFrom, DWORD dwAttrFrom, LPCWSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(void)     PathRemoveArgsA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveArgsW(LPWSTR pszPath);
LWSTDAPI_(LPSTR)  PathRemoveBackslashA(LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathRemoveBackslashW(LPWSTR pszPath);
#ifdef UNICODE
#define PathRemoveBackslash  PathRemoveBackslashW
#else
#define PathRemoveBackslash  PathRemoveBackslashA
#endif // !UNICODE
LWSTDAPI_(void)     PathRemoveBlanksA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveBlanksW(LPWSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRenameExtensionA(LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathRenameExtensionW(LPWSTR pszPath, LPCWSTR pszExt);
LWSTDAPI_(BOOL)     PathSearchAndQualifyA(LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathSearchAndQualifyW(LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(void)     PathSetDlgItemPathA(HWND hDlg, int id, LPCSTR pszPath);
LWSTDAPI_(void)     PathSetDlgItemPathW(HWND hDlg, int id, LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathSkipRootA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathSkipRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathSkipRoot  PathSkipRootW
#else
#define PathSkipRoot  PathSkipRootA
#endif // !UNICODE
LWSTDAPI_(void)     PathStripPathA(LPSTR pszPath);
LWSTDAPI_(void)     PathStripPathW(LPWSTR pszPath);
#ifdef UNICODE
#define PathStripPath  PathStripPathW
#else
#define PathStripPath  PathStripPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathStripToRootA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathStripToRootW(LPWSTR pszPath);
#ifdef UNICODE
#define PathStripToRoot  PathStripToRootW
#else
#define PathStripToRoot  PathStripToRootA
#endif // !UNICODE
LWSTDAPI_(void)     PathUnquoteSpacesA(LPSTR lpsz);
LWSTDAPI_(void)     PathUnquoteSpacesW(LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathMakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathMakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathMakeSystemFolder  PathMakeSystemFolderW
#else
#define PathMakeSystemFolder  PathMakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderW
#else
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSystemFolderA(LPCSTR pszPath, DWORD dwAttrb);
LWSTDAPI_(BOOL)     PathIsSystemFolderW(LPCWSTR pszPath, DWORD dwAttrb);
#ifdef UNICODE
#define PathIsSystemFolder  PathIsSystemFolderW
#else
#define PathIsSystemFolder  PathIsSystemFolderA
#endif // !UNICODE
LWSTDAPI_(void)     PathUndecorateA(LPSTR pszPath);
LWSTDAPI_(void)     PathUndecorateW(LPWSTR pszPath);
#ifdef UNICODE
#define PathUndecorate  PathUndecorateW
#else
#define PathUndecorate  PathUndecorateA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsA(LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsW(LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsW
#else
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsA
#endif // !UNICODE



#ifdef UNICODE
#define PathAppend              PathAppendW
#define PathCanonicalize        PathCanonicalizeW
#define PathCompactPath         PathCompactPathW
#define PathCompactPathEx       PathCompactPathExW
#define PathCommonPrefix        PathCommonPrefixW
#define PathFindOnPath          PathFindOnPathW
#define PathGetCharType         PathGetCharTypeW
#define PathIsContentType       PathIsContentTypeW
#define PathIsHTMLFile          PathIsHTMLFileW
#define PathMakePretty          PathMakePrettyW
#define PathMatchSpec           PathMatchSpecW
#define PathParseIconLocation   PathParseIconLocationW
#define PathQuoteSpaces         PathQuoteSpacesW
#define PathRelativePathTo      PathRelativePathToW
#define PathRemoveArgs          PathRemoveArgsW
#define PathRemoveBlanks        PathRemoveBlanksW
#define PathRemoveExtension     PathRemoveExtensionW
#define PathRemoveFileSpec      PathRemoveFileSpecW
#define PathRenameExtension     PathRenameExtensionW
#define PathSearchAndQualify    PathSearchAndQualifyW
#define PathSetDlgItemPath      PathSetDlgItemPathW
#define PathUnquoteSpaces       PathUnquoteSpacesW
#else
#define PathAppend              PathAppendA
#define PathCanonicalize        PathCanonicalizeA
#define PathCompactPath         PathCompactPathA
#define PathCompactPathEx       PathCompactPathExA
#define PathCommonPrefix        PathCommonPrefixA
#define PathFindOnPath          PathFindOnPathA
#define PathGetCharType         PathGetCharTypeA
#define PathIsContentType       PathIsContentTypeA
#define PathIsHTMLFile          PathIsHTMLFileA
#define PathMakePretty          PathMakePrettyA
#define PathMatchSpec           PathMatchSpecA
#define PathParseIconLocation   PathParseIconLocationA
#define PathQuoteSpaces         PathQuoteSpacesA
#define PathRelativePathTo      PathRelativePathToA
#define PathRemoveArgs          PathRemoveArgsA
#define PathRemoveBlanks        PathRemoveBlanksA
#define PathRemoveExtension     PathRemoveExtensionA
#define PathRemoveFileSpec      PathRemoveFileSpecA
#define PathRenameExtension     PathRenameExtensionA
#define PathSearchAndQualify    PathSearchAndQualifyA
#define PathSetDlgItemPath      PathSetDlgItemPathA
#define PathUnquoteSpaces       PathUnquoteSpacesA
#endif

typedef enum {
    URL_SCHEME_INVALID     = -1,
    URL_SCHEME_UNKNOWN     =  0,
    URL_SCHEME_FTP,
    URL_SCHEME_HTTP,
    URL_SCHEME_GOPHER,
    URL_SCHEME_MAILTO,
    URL_SCHEME_NEWS,
    URL_SCHEME_NNTP,
    URL_SCHEME_TELNET,
    URL_SCHEME_WAIS,
    URL_SCHEME_FILE,
    URL_SCHEME_MK,
    URL_SCHEME_HTTPS,
    URL_SCHEME_SHELL,
    URL_SCHEME_SNEWS,
    URL_SCHEME_LOCAL,
    URL_SCHEME_JAVASCRIPT,
    URL_SCHEME_VBSCRIPT,
    URL_SCHEME_ABOUT,
    URL_SCHEME_RES,
    URL_SCHEME_MSSHELLROOTED,
    URL_SCHEME_MSSHELLIDLIST,
    URL_SCHEME_MSHELP,
    URL_SCHEME_MAXVALUE
} URL_SCHEME;

typedef enum {
    URL_PART_NONE       = 0,
    URL_PART_SCHEME     = 1,
    URL_PART_HOSTNAME,
    URL_PART_USERNAME,
    URL_PART_PASSWORD,
    URL_PART_PORT,
    URL_PART_QUERY,
} URL_PART;

typedef enum {
    URLIS_URL,
    URLIS_OPAQUE,
    URLIS_NOHISTORY,
    URLIS_FILEURL,
    URLIS_APPLIABLE,
    URLIS_DIRECTORY,
    URLIS_HASQUERY,
} URLIS;

#define URL_UNESCAPE                    0x10000000
#define URL_ESCAPE_UNSAFE               0x20000000
#define URL_PLUGGABLE_PROTOCOL          0x40000000
#define URL_WININET_COMPATIBILITY       0x80000000
#define URL_DONT_ESCAPE_EXTRA_INFO      0x02000000
#define URL_DONT_UNESCAPE_EXTRA_INFO    URL_DONT_ESCAPE_EXTRA_INFO
#define URL_BROWSER_MODE                URL_DONT_ESCAPE_EXTRA_INFO
#define URL_ESCAPE_SPACES_ONLY          0x04000000
#define URL_DONT_SIMPLIFY               0x08000000
#define URL_NO_META                     URL_DONT_SIMPLIFY
#define URL_UNESCAPE_INPLACE            0x00100000
#define URL_CONVERT_IF_DOSPATH          0x00200000
#define URL_UNESCAPE_HIGH_ANSI_ONLY     0x00400000
#define URL_INTERNAL_PATH               0x00800000  // Will escape #'s in paths
#define URL_FILE_USE_PATHURL            0x00010000
#define URL_ESCAPE_PERCENT              0x00001000
#define URL_ESCAPE_SEGMENT_ONLY         0x00002000  // Treat the entire URL param as one URL segment.

#define URL_PARTFLAG_KEEPSCHEME         0x00000001

#define URL_APPLY_DEFAULT               0x00000001
#define URL_APPLY_GUESSSCHEME           0x00000002
#define URL_APPLY_GUESSFILE             0x00000004
#define URL_APPLY_FORCEAPPLY            0x00000008


LWSTDAPI_(int)          UrlCompareA(LPCSTR psz1, LPCSTR psz2, BOOL fIgnoreSlash);
LWSTDAPI_(int)          UrlCompareW(LPCWSTR psz1, LPCWSTR psz2, BOOL fIgnoreSlash);
LWSTDAPI                UrlCombineA(LPCSTR pszBase, LPCSTR pszRelative, LPSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCombineW(LPCWSTR pszBase, LPCWSTR pszRelative, LPWSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeA(LPCSTR pszUrl, LPSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeW(LPCWSTR pszUrl, LPWSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI_(BOOL)         UrlIsOpaqueA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsOpaqueW(LPCWSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryW(LPCWSTR pszURL);
#define                 UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define                 UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)
LWSTDAPI_(BOOL)         UrlIsA(LPCSTR pszUrl, URLIS UrlIs);
LWSTDAPI_(BOOL)         UrlIsW(LPCWSTR pszUrl, URLIS UrlIs);
LWSTDAPI_(LPCSTR)       UrlGetLocationA(LPCSTR psz1);
LWSTDAPI_(LPCWSTR)      UrlGetLocationW(LPCWSTR psz1);
LWSTDAPI                UrlUnescapeA(LPSTR pszUrl, LPSTR pszUnescaped, LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlUnescapeW(LPWSTR pszUrl, LPWSTR pszUnescaped, LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeA(LPCSTR pszUrl, LPSTR pszEscaped, LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeW(LPCWSTR pszUrl, LPWSTR pszEscaped, LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathA(LPCSTR pszPath, LPSTR pszUrl, LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathW(LPCWSTR pszPath, LPWSTR pszUrl, LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlA(LPCSTR pszUrl, LPSTR pszPath, LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlW(LPCWSTR pszUrl, LPWSTR pszPath, LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                UrlHashA(LPCSTR pszUrl, LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlHashW(LPCWSTR pszUrl, LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlGetPartW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlGetPartA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash);



#ifdef UNICODE
#define UrlCompare              UrlCompareW
#define UrlCombine              UrlCombineW
#define UrlCanonicalize         UrlCanonicalizeW
#define UrlIsOpaque             UrlIsOpaqueW
#define UrlIsFileUrl            UrlIsFileUrlW
#define UrlGetLocation          UrlGetLocationW
#define UrlUnescape             UrlUnescapeW
#define UrlEscape               UrlEscapeW
#define UrlCreateFromPath       UrlCreateFromPathW
#define PathCreateFromUrl       PathCreateFromUrlW
#define UrlHash                 UrlHashW
#define UrlGetPart              UrlGetPartW
#define UrlApplyScheme          UrlApplySchemeW
#define UrlIs                   UrlIsW


#else //!UNICODE
#define UrlCompare              UrlCompareA
#define UrlCombine              UrlCombineA
#define UrlCanonicalize         UrlCanonicalizeA
#define UrlIsOpaque             UrlIsOpaqueA
#define UrlIsFileUrl            UrlIsFileUrlA
#define UrlGetLocation          UrlGetLocationA
#define UrlUnescape             UrlUnescapeA
#define UrlEscape               UrlEscapeA
#define UrlCreateFromPath       UrlCreateFromPathA
#define PathCreateFromUrl       PathCreateFromUrlA
#define UrlHash                 UrlHashA
#define UrlGetPart              UrlGetPartA
#define UrlApplyScheme          UrlApplySchemeA
#define UrlIs                   UrlIsA


#endif //UNICODE

#define UrlEscapeSpaces(pszUrl, pszEscaped, pcchEscaped)        UrlCanonicalize(pszUrl, pszEscaped, pcchEscaped, URL_ESCAPE_SPACES_ONLY |URL_DONT_ESCAPE_EXTRA_INFO )
#define UrlUnescapeInPlace(pszUrl, dwFlags)                     UrlUnescape(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)



#endif //  NO_SHLWAPI_PATH



#ifndef NO_SHLWAPI_REG
//
//=============== Registry Routines ===================================
//


// SHDeleteEmptyKey mimics RegDeleteKey as it behaves on NT.
// SHDeleteKey mimics RegDeleteKey as it behaves on Win95.

LWSTDAPI_(DWORD)    SHDeleteEmptyKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteEmptyKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteEmptyKey  SHDeleteEmptyKeyW
#else
#define SHDeleteEmptyKey  SHDeleteEmptyKeyA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHDeleteKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteKey  SHDeleteKeyW
#else
#define SHDeleteKey  SHDeleteKeyA
#endif // !UNICODE
LWSTDAPI_(HKEY)     SHRegDuplicateHKey(HKEY hkey);


// These functions open the key, get/set/delete the value, then close
// the key.

LWSTDAPI_(DWORD)    SHDeleteValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue);
LWSTDAPI_(DWORD)    SHDeleteValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue);
#ifdef UNICODE
#define SHDeleteValue  SHDeleteValueW
#else
#define SHDeleteValue  SHDeleteValueA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHGetValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI_(DWORD)    SHGetValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SHGetValue  SHGetValueW
#else
#define SHGetValue  SHGetValueA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHSetValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
LWSTDAPI_(DWORD)    SHSetValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
#ifdef UNICODE
#define SHSetValue  SHSetValueW
#else
#define SHSetValue  SHSetValueA
#endif // !UNICODE


//
// SRRF - Shell Registry Routine Flags (for SHRegGetValue)
//

typedef DWORD SRRF;

#define SRRF_RT_REG_NONE        0x00000001  // restrict type to REG_NONE      (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_SZ          0x00000002  // restrict type to REG_SZ        (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_EXPAND_SZ   0x00000004  // restrict type to REG_EXPAND_SZ (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_BINARY      0x00000008  // restrict type to REG_BINARY    (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_DWORD       0x00000010  // restrict type to REG_DWORD     (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_MULTI_SZ    0x00000020  // restrict type to REG_MULTI_SZ  (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_REG_QWORD       0x00000040  // restrict type to REG_QWORD     (other data types will not return ERROR_SUCCESS)

#define SRRF_RT_DWORD           (SRRF_RT_REG_BINARY | SRRF_RT_REG_DWORD) // restrict type to *32-bit* SRRF_RT_REG_BINARY or SRRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_QWORD           (SRRF_RT_REG_BINARY | SRRF_RT_REG_QWORD) // restrict type to *64-bit* SRRF_RT_REG_BINARY or SRRF_RT_REG_DWORD (other data types will not return ERROR_SUCCESS)
#define SRRF_RT_ANY             0x0000ffff                               // no type restriction

#define SRRF_RM_ANY             0x00000000  // no mode restriction (default is to allow any mode)
#define SRRF_RM_NORMAL          0x00010000  // restrict system startup mode to "normal boot"               (other startup modes will not return ERROR_SUCCESS)
#define SRRF_RM_SAFE            0x00020000  // restrict system startup mode to "safe mode"                 (other startup modes will not return ERROR_SUCCESS)
#define SRRF_RM_SAFENETWORK     0x00040000  // restrict system startup mode to "safe mode with networking" (other startup modes will not return ERROR_SUCCESS)

#define SRRF_NOEXPAND           0x10000000  // do not automatically expand environment strings if value is of type REG_EXPAND_SZ
#define SRRF_ZEROONFAILURE      0x20000000  // if pvData is not NULL, set content to all zeros on failure


// Function:
//
//  SHRegGetValue()
//
// Purpose:
//
//  Gets a registry value.  SHRegGetValue() provides the following benefits:
//
//  - data type checking
//  - boot mode checking
//  - auto-expansion of REG_EXPAND_SZ data
//  - guaranteed NULL termination of REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ data
//
// Parameters:
//
//  hkey        - handle to a currently open key.
//
//  pszSubKey   - pointer to a null-terminated string specifying the relative
//                path from hkey to one of its subkeys from which the data is
//                to be retrieved.  this will be opened with KEY_READ sam.
//
//                Note1: pszSubKey can be NULL or "".  In either of these two
//                       cases, the data is retrieved from the hkey itself.
//                Note2: *** PERF ***
//                       If pszSubKey is not NULL or "", the subkey will be
//                       automatically be opened and closed by this routine
//                       in order to obtain the data.  If you are retrieving
//                       multiple values from the same subkey, it is better
//                       for perf to open the subkey via RegOpenKeyEx() prior
//                       to calling this method, and using this opened key as
//                       hkey with pszSubKey set to NULL.
//
//  pszValue    - pointer to a null-terminated string specifying the name of
//                the value to query for data
//
//                Note1: pszValue can be NULL or "".  In either of these two
//                       cases, the data is retrieved from the unnamed or
//                       default value.
//
//  dwFlags     - bitwise or of SRRF_ flags, which cannot be 0:  at least one
//                type restriction must be specified (SRRF_RT_...), or if any
//                type is desired then SRRF_RT_ANY can be specified
//
//                Note1: SRRF_RT_ANY will allow any data type to be returned.
//                Note2: The following two type restrictions have special
//                       handling semantics:
//
//                         SRRF_RT_DWORD == SRRF_RT_REG_BINARY | SRRF_RT_REG_DWORD
//                         SRRF_RT_QWORD == SRRF_RT_REG_BINARY | SRRF_RT_REG_QWORD
//
//                       If either of these are specified, with no other type
//                       restrictions, then in the prior case the restriction
//                       will limit "valid" returned data to either REG_DWORD
//                       or 32-bit REG_BINARY data, and in the latter case
//                       the restriction will limit "valid" returned data to
//                       either REG_QWORD or 64-bit REG_BINARY.
//
//  pdwType     - pointer to a dword which receives a code indicating the
//                type of data stored in the specified value
//
//                Note1: pdwType can be NULL if no type information is wanted
//                Note2: If pdwType is not NULL, and the SRRF_NOEXPAND flag
//                       has not been set, data types of REG_EXPAND_SZ will
//                       be returned as REG_SZ since they are automatically
//                       expanded in this method.
//
//  pvData      - pointer to a buffer that receives the value's data
//
//                Note1: pvData can be NULL if the data is not required.
//                       pvData is usually NULL if doing either a simple
//                       existence test, or if interested in the size only.
//                Note2: *** PERF ***
//                       Reference 'perf' note for pcbData.
//
//  pcbData     - when pvData is NULL:
//                  optional pointer to a dword that receives a size in bytes
//                  which would be sufficient to hold the registry data (note
//                  this size is not guaranteed to be exact, merely sufficient)
//                when pvData is not NULL:
//                  required pointer to a dword that specifies the size in
//                  bytes of the buffer pointed to by the pvData parameter
//                  and receives a size in bytes of:
//                  a) the number of bytes read into pvData on ERROR_SUCCESS
//                     (note this size is guaranteed to be exact)
//                  b) the number of bytes which would be sufficient to hold
//                     the registry data on ERROR_MORE_DATA -- pvData was of
//                     insufficient size (note this size is not guaranteed to
//                     be exact, merely sufficient)
//
//                Note1: pcbData can be NULL only if pvData is NULL.
//                Note2: *** PERF ***
//                       The potential for an 'extra' call to the registry to
//                       read (or re-read) in the data exists when the data
//                       type is REG_EXPAND_SZ and the SRRF_NOEXPAND flag has
//                       not been set.  The following conditions will result
//                       in this 'extra' read operation:
//                       i)  when pvData is NULL and pcbData is not NULL
//                           we must read in the data from the registry
//                           anyway in order to obtain the string and perform
//                           an expand on it to obtain and return the total
//                           required size in pcbData
//                       ii) when pvData is not NULL but is of insufficient
//                           size we must re-read in the data from the
//                           registry in order to obtain the entire string
//                           and perform an expand on it to obtain and return
//                           the total required size in pcbData
//
// Remarks:
//
//  The key identified by hkey must have been opened with KEY_QUERY_VALUE
//  access.  If pszSubKey is not NULL or "", it must be able to be opened
//  with KEY_QUERY_VALUE access in the current calling context.
//
//  If the data type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then any
//  returned data is guaranteed to take into account proper null termination.
//  For example:  if pcbData is not NULL, its returned size will include the
//  bytes for a null terminator  if pvData is not NULL, its returned data
//  will be properly null terminated.
//
//  If the data type is REG_EXPAND_SZ, then unless the SRRF_NOEXPAND flag
//  is set the data will be automatically expanded prior to being returned.
//  For example:  if pdwType is not NULL, its returned type will be changed
//  to REG_SZ,  if pcbData is not NULL, its returned size will include the
//  bytes for a properly expanded string.  if pvData is not NULL, its
//  returned data will be the expanded version of the string.
//
//  Reference MSDN documentation for RegQueryValueEx() for more information
//  of the behaviour when pdwType, pvData, and/or pcbData are equal to NULL.
//
// Return Values:
//
//  If the function succeeds, the return value is ERROR_SUCCESS and all out
//  parameters requested (pdwType, pvData, pcbData) are valid.
//
//  If the function fails due to insufficient space in a provided non-NULL
//  pvData, the return value is ERROR_MORE_DATA and only pdwType and pcbData
//  can contain valid data.  The content of pvData in this case is undefined.
//
// Examples:
//
//  1) read REG_SZ (or REG_EXPAND_SZ as REG_SZ) "string" data from the (default) value of an open hkey
//
//      TCHAR szData[128]
//      DWORD cbData = sizeof(pszData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, NULL, SRRF_RT_REG_SZ, NULL, szData, &cbData))
//      {
//          // use sz (successful read)
//      }
//
//  2) read REG_SZ (or REG_EXPAND_SZ as REG_SZ) "string" data of unknown size from the "MyValue" value of an open hkey
//
//      DWORD cbData
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_REG_SZ, NULL, NULL, &cbData))
//      {
//          TCHAR *pszData = new TCHAR[cbData/sizeof(TCHAR)]
//          if (pszData)
//          {
//              if (ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_REG_SZ, NULL, pszData, &cbData))
//              {
//                  // use pszData (successful read)
//              }
//              delete[] pszData
//          }
//      }
//
//  3) read "dword" data from the "MyValue" value of the "MySubKey" subkey of an open hkey
//
//      DWORD dwData
//      DWORD cbData = sizeof(dwData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, TEXT("MySubKey"), TEXT("MyValue"), SRRF_RT_REG_DWORD, NULL, &dwData, &cbData))
//      {
//          // use dwData (successful read)
//      }
//
//  4) read "dword" data from the "MyValue" value of the "MySubKey" subkey of an open hkey (32-bit binary data also ok)
//
//      DWORD dwData
//      DWORD cbData = sizeof(dwData)
//      if (ERROR_SUCCESS == SHRegGetValue(hkey, TEXT("MySubKey"), TEXT("MyValue"), SRRF_RT_DWORD, NULL, &dwData, &cbData))
//      {
//          // use dwData (successful read)
//      }
//
//  5) determine existence of "MyValue" value of an open hkey
//
//      BOOL bExists = ERROR_SUCCESS == SHRegGetValue(hkey, NULL, TEXT("MyValue"), SRRF_RT_ANY, NULL, NULL, NULL)

LWSTDAPI_(LONG)     SHRegGetValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue, SRRF dwFlags, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI_(LONG)     SHRegGetValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue, SRRF dwFlags, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SHRegGetValue  SHRegGetValueW
#else
#define SHRegGetValue  SHRegGetValueA
#endif // !UNICODE

// These functions behave just like RegQueryValueEx(), except if the data
// type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ then the string is
// guaranteed to be properly null terminated.
//
// Additionally, if the data type is REG_EXPAND_SZ these functions will
// go ahead and expand out the string, and "massage" the returned *pdwType
// to be REG_SZ.

LWSTDAPI_(DWORD)    SHQueryValueExA(HKEY hkey, LPCSTR pszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI_(DWORD)    SHQueryValueExW(HKEY hkey, LPCWSTR pszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SHQueryValueEx  SHQueryValueExW
#else
#define SHQueryValueEx  SHQueryValueExA
#endif // !UNICODE

// Enumeration functions support.

LWSTDAPI_(LONG)     SHEnumKeyExA(HKEY hkey, DWORD dwIndex, LPSTR pszName, LPDWORD pcchName);
LWSTDAPI_(LONG)     SHEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR pszName, LPDWORD pcchName);
LWSTDAPI_(LONG)     SHEnumValueA(HKEY hkey, DWORD dwIndex, LPSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData);
LWSTDAPI_(LONG)     SHEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData);
LWSTDAPI_(LONG)     SHQueryInfoKeyA(HKEY hkey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen);
LWSTDAPI_(LONG)     SHQueryInfoKeyW(HKEY hkey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen);

// recursive key copy
LWSTDAPI_(DWORD)     SHCopyKeyA(HKEY hkeySrc, LPCSTR   szSrcSubKey, HKEY hkeyDest, DWORD fReserved);
LWSTDAPI_(DWORD)     SHCopyKeyW(HKEY hkeySrc, LPCWSTR wszSrcSubKey, HKEY hkeyDest, DWORD fReserved);

// Getting and setting file system paths with environment variables

LWSTDAPI_(DWORD)    SHRegGetPathA(HKEY hKey, LPCSTR pcszSubKey, LPCSTR pcszValue, LPSTR pszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegGetPathW(HKEY hKey, LPCWSTR pcszSubKey, LPCWSTR pcszValue, LPWSTR pszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegSetPathA(HKEY hKey, LPCSTR pcszSubKey, LPCSTR pcszValue, LPCSTR pcszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegSetPathW(HKEY hKey, LPCWSTR pcszSubKey, LPCWSTR pcszValue, LPCWSTR pcszPath, DWORD dwFlags);

#ifdef UNICODE
#define SHEnumKeyEx           SHEnumKeyExW
#define SHEnumValue           SHEnumValueW
#define SHQueryInfoKey        SHQueryInfoKeyW
#define SHCopyKey             SHCopyKeyW
#define SHRegGetPath          SHRegGetPathW
#define SHRegSetPath          SHRegSetPathW
#else
#define SHEnumKeyEx           SHEnumKeyExA
#define SHEnumValue           SHEnumValueA
#define SHQueryInfoKey        SHQueryInfoKeyA
#define SHCopyKey             SHCopyKeyA
#define SHRegGetPath          SHRegGetPathA
#define SHRegSetPath          SHRegSetPathA
#endif


//////////////////////////////////////////////
// User Specific Registry Access Functions
//////////////////////////////////////////////

//
// Type definitions.
//

typedef enum
{
    SHREGDEL_DEFAULT = 0x00000000,       // Delete's HKCU, or HKLM if HKCU is not found.
    SHREGDEL_HKCU    = 0x00000001,       // Delete HKCU only
    SHREGDEL_HKLM    = 0x00000010,       // Delete HKLM only.
    SHREGDEL_BOTH    = 0x00000011,       // Delete both HKCU and HKLM.
} SHREGDEL_FLAGS;

typedef enum
{
    SHREGENUM_DEFAULT = 0x00000000,       // Enumerates HKCU or HKLM if not found.
    SHREGENUM_HKCU    = 0x00000001,       // Enumerates HKCU only
    SHREGENUM_HKLM    = 0x00000010,       // Enumerates HKLM only.
    SHREGENUM_BOTH    = 0x00000011,       // Enumerates both HKCU and HKLM without duplicates.
                                          // This option is NYI.
} SHREGENUM_FLAGS;

#define     SHREGSET_HKCU           0x00000001       // Write to HKCU if empty.
#define     SHREGSET_FORCE_HKCU     0x00000002       // Write to HKCU.
#define     SHREGSET_HKLM           0x00000004       // Write to HKLM if empty.
#define     SHREGSET_FORCE_HKLM     0x00000008       // Write to HKLM.
#define     SHREGSET_DEFAULT        (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)          // Default is SHREGSET_FORCE_HKCU | SHREGSET_HKLM.

typedef HANDLE HUSKEY;  // HUSKEY is a Handle to a User Specific KEY.
typedef HUSKEY *PHUSKEY;

LWSTDAPI_(LONG)        SHRegCreateUSKeyA(LPCSTR pszPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegCreateUSKeyW(LPCWSTR pwzPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegOpenUSKeyA(LPCSTR pszPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, BOOL fIgnoreHKCU);
LWSTDAPI_(LONG)        SHRegOpenUSKeyW(LPCWSTR pwzPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, BOOL fIgnoreHKCU);
LWSTDAPI_(LONG)        SHRegQueryUSValueA(HUSKEY hUSKey, LPCSTR pszValue, LPDWORD pdwType, void *pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegQueryUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, LPDWORD pdwType, void *pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegWriteUSValueA(HUSKEY hUSKey, LPCSTR pszValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegWriteUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegDeleteUSValueA(HUSKEY hUSKey, LPCSTR pszValue, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteEmptyUSKeyW(HUSKEY hUSKey, LPCWSTR pwzSubKey, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteEmptyUSKeyA(HUSKEY hUSKey, LPCSTR pszSubKey, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSKeyA(HUSKEY hUSKey, DWORD dwIndex, LPSTR pszName, LPDWORD pcchName, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSKeyW(HUSKEY hUSKey, DWORD dwIndex, LPWSTR pwzName, LPDWORD pcchName, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSValueA(HUSKEY hUSkey, DWORD dwIndex, LPSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSValueW(HUSKEY hUSkey, DWORD dwIndex, LPWSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegQueryInfoUSKeyA(HUSKEY hUSKey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegQueryInfoUSKeyW(HUSKEY hUSKey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegCloseUSKey(HUSKEY hUSKey);


// These calls are equal to an SHRegOpenUSKey, SHRegQueryUSValue, and then a SHRegCloseUSKey.
LWSTDAPI_(LONG)        SHRegGetUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, LPDWORD pdwType, void * pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegGetUSValueW(LPCWSTR pwzSubKey, LPCWSTR pwzValue, LPDWORD pdwType, void * pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegSetUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegSetUSValueW(LPCWSTR pwzSubKey, LPCWSTR pwzValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(int)         SHRegGetIntW(HKEY hk, LPCWSTR pwzKey, int iDefault);

#ifdef UNICODE
#define SHRegCreateUSKey        SHRegCreateUSKeyW
#define SHRegOpenUSKey          SHRegOpenUSKeyW
#define SHRegQueryUSValue       SHRegQueryUSValueW
#define SHRegWriteUSValue       SHRegWriteUSValueW
#define SHRegDeleteUSValue      SHRegDeleteUSValueW
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyW
#define SHRegEnumUSKey          SHRegEnumUSKeyW
#define SHRegEnumUSValue        SHRegEnumUSValueW
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyW
#define SHRegGetUSValue         SHRegGetUSValueW
#define SHRegSetUSValue         SHRegSetUSValueW
#define SHRegGetInt             SHRegGetIntW
#else
#define SHRegCreateUSKey        SHRegCreateUSKeyA
#define SHRegOpenUSKey          SHRegOpenUSKeyA
#define SHRegQueryUSValue       SHRegQueryUSValueA
#define SHRegWriteUSValue       SHRegWriteUSValueA
#define SHRegDeleteUSValue      SHRegDeleteUSValueA
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyA
#define SHRegEnumUSKey          SHRegEnumUSKeyA
#define SHRegEnumUSValue        SHRegEnumUSValueA
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyA
#define SHRegGetUSValue         SHRegGetUSValueA
#define SHRegSetUSValue         SHRegSetUSValueA
#endif

LWSTDAPI_(BOOL) SHRegGetBoolUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, BOOL fIgnoreHKCU, BOOL fDefault);
LWSTDAPI_(BOOL) SHRegGetBoolUSValueW(LPCWSTR pszSubKey, LPCWSTR pszValue, BOOL fIgnoreHKCU, BOOL fDefault);

#ifdef UNICODE
#define SHRegGetBoolUSValue SHRegGetBoolUSValueW
#else
#define SHRegGetBoolUSValue SHRegGetBoolUSValueA
#endif

//
//  Association APIs
//
//  these APIs are to assist in accessing the data in HKCR
//  getting the Command strings and exe paths
//  for different verbs and extensions are simplified this way
//

enum {
    ASSOCF_INIT_NOREMAPCLSID           = 0x00000001,  //  do not remap clsids to progids
    ASSOCF_INIT_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_OPEN_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_INIT_DEFAULTTOSTAR          = 0x00000004,  //  treat "*" as the BaseClass
    ASSOCF_INIT_DEFAULTTOFOLDER        = 0x00000008,  //  treat "Folder" as the BaseClass
    ASSOCF_NOUSERSETTINGS              = 0x00000010,  //  dont use HKCU
    ASSOCF_NOTRUNCATE                  = 0x00000020,  //  dont truncate the return string
    ASSOCF_VERIFY                      = 0x00000040,  //  verify data is accurate (DISK HITS)
    ASSOCF_REMAPRUNDLL                 = 0x00000080,  //  actually gets info about rundlls target if applicable
    ASSOCF_NOFIXUPS                    = 0x00000100,  //  attempt to fix errors if found
    ASSOCF_IGNOREBASECLASS             = 0x00000200,  //  dont recurse into the baseclass
};

typedef DWORD ASSOCF;


typedef enum {
    ASSOCSTR_COMMAND      = 1,  //  shell\verb\command string
    ASSOCSTR_EXECUTABLE,        //  the executable part of command string
    ASSOCSTR_FRIENDLYDOCNAME,   //  friendly name of the document type
    ASSOCSTR_FRIENDLYAPPNAME,   //  friendly name of executable
    ASSOCSTR_NOOPEN,            //  noopen value
    ASSOCSTR_SHELLNEWVALUE,     //  query values under the shellnew key
    ASSOCSTR_DDECOMMAND,        //  template for DDE commands
    ASSOCSTR_DDEIFEXEC,         //  DDECOMMAND to use if just create a process
    ASSOCSTR_DDEAPPLICATION,    //  Application name in DDE broadcast
    ASSOCSTR_DDETOPIC,          //  Topic Name in DDE broadcast
    ASSOCSTR_INFOTIP,           //  info tip for an item, or list of properties to create info tip from
    ASSOCSTR_QUICKTIP,          //  same as ASSOCSTR_INFOTIP, except, this list contains only quickly retrievable properties
    ASSOCSTR_TILEINFO,          //  similar to ASSOCSTR_INFOTIP - lists important properties for tileview
    ASSOCSTR_CONTENTTYPE,       //  MIME Content type
    ASSOCSTR_DEFAULTICON,       //  Default icon source
    ASSOCSTR_SHELLEXTENSION,    //  Guid string pointing to the Shellex\Shellextensionhandler value.
    ASSOCSTR_MAX                //  last item in enum...
} ASSOCSTR;

typedef enum {
    ASSOCKEY_SHELLEXECCLASS = 1,  //  the key that should be passed to ShellExec(hkeyClass)
    ASSOCKEY_APP,                 //  the "Application" key for the association
    ASSOCKEY_CLASS,               //  the progid or class key
    ASSOCKEY_BASECLASS,           //  the BaseClass key
    ASSOCKEY_MAX                  //  last item in enum...
} ASSOCKEY;

typedef enum {
    ASSOCDATA_MSIDESCRIPTOR = 1,  //  Component Descriptor to pass to MSI APIs
    ASSOCDATA_NOACTIVATEHANDLER,  //  restrict attempts to activate window
    ASSOCDATA_QUERYCLASSSTORE,    //  should check with the NT Class Store
    ASSOCDATA_HASPERUSERASSOC,    //  defaults to user specified association
    ASSOCDATA_EDITFLAGS,          //  Edit flags.
    ASSOCDATA_VALUE,              //  use pszExtra as the Value name
    ASSOCDATA_MAX
} ASSOCDATA;

typedef enum {
    ASSOCENUM_NONE
} ASSOCENUM;

#undef INTERFACE
#define INTERFACE IQueryAssociations

DECLARE_INTERFACE_( IQueryAssociations, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IQueryAssociations methods
    STDMETHOD (Init)(THIS_ ASSOCF flags, LPCWSTR pszAssoc, HKEY hkProgid, HWND hwnd) PURE;
    STDMETHOD (GetString)(THIS_ ASSOCF flags, ASSOCSTR str, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut) PURE;
    STDMETHOD (GetKey)(THIS_ ASSOCF flags, ASSOCKEY key, LPCWSTR pszExtra, HKEY *phkeyOut) PURE;
    STDMETHOD (GetData)(THIS_ ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, LPVOID pvOut, DWORD *pcbOut) PURE;
    STDMETHOD (GetEnum)(THIS_ ASSOCF flags, ASSOCENUM assocenum, LPCWSTR pszExtra, REFIID riid, LPVOID *ppvOut) PURE;
};


LWSTDAPI AssocCreate(CLSID clsid, REFIID riid, LPVOID *ppv);

//  wrappers for the interface
LWSTDAPI AssocQueryStringA(ASSOCF flags, ASSOCSTR str, LPCSTR pszAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut);
//  wrappers for the interface
LWSTDAPI AssocQueryStringW(ASSOCF flags, ASSOCSTR str, LPCWSTR pszAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryString  AssocQueryStringW
#else
#define AssocQueryString  AssocQueryStringA
#endif // !UNICODE
LWSTDAPI AssocQueryStringByKeyA(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut);
LWSTDAPI AssocQueryStringByKeyW(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryStringByKey  AssocQueryStringByKeyW
#else
#define AssocQueryStringByKey  AssocQueryStringByKeyA
#endif // !UNICODE
LWSTDAPI AssocQueryKeyA(ASSOCF flags, ASSOCKEY key, LPCSTR pszAssoc, LPCSTR pszExtra, HKEY *phkeyOut);
LWSTDAPI AssocQueryKeyW(ASSOCF flags, ASSOCKEY key, LPCWSTR pszAssoc, LPCWSTR pszExtra, HKEY *phkeyOut);
#ifdef UNICODE
#define AssocQueryKey  AssocQueryKeyW
#else
#define AssocQueryKey  AssocQueryKeyA
#endif // !UNICODE

//  AssocIsDangerous() checks a file type to determine whether it is "Dangerous"
//      this maps to the IE download dialog's forcing a prompt to open or save.
//      dangerous file types should be handled more carefully than other file types.
//
//  Parameter:  pszAssoc - type to check.  may be an extension or progid.  (".exe" or "exefile" would both be valid)
//
//  Returns: TRUE if the file type is dangerous.
//
//  NOTES:
//
//      this API first checks a hardcoded list of known dangerous types.
//      then it checks the editflags for the file type looking for the FTA_AlwaysUnsafe bit.
//      then it checks Safer policies.
//      
LWSTDAPI_(BOOL) AssocIsDangerous(LPCWSTR pszAssoc);



#endif //  NO_SHLWAPI_REG



#ifndef NO_SHLWAPI_STREAM
//
//=============== Stream Routines ===================================
//

LWSTDAPI_(struct IStream *) SHOpenRegStreamA(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStreamW(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream  SHOpenRegStreamW
#else
#define SHOpenRegStream  SHOpenRegStreamA
#endif // !UNICODE
LWSTDAPI_(struct IStream *) SHOpenRegStream2A(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStream2W(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream2  SHOpenRegStream2W
#else
#define SHOpenRegStream2  SHOpenRegStream2A
#endif // !UNICODE
// New code always wants new implementation...
#undef SHOpenRegStream
#define SHOpenRegStream SHOpenRegStream2

LWSTDAPI SHCreateStreamOnFileA(LPCSTR pszFile, DWORD grfMode, struct IStream **ppstm);
LWSTDAPI SHCreateStreamOnFileW(LPCWSTR pszFile, DWORD grfMode, struct IStream **ppstm);
#ifdef UNICODE
#define SHCreateStreamOnFile  SHCreateStreamOnFileW
#else
#define SHCreateStreamOnFile  SHCreateStreamOnFileA
#endif // !UNICODE

#if (_WIN32_IE >= 0x0600)

LWSTDAPI SHCreateStreamOnFileEx(LPCWSTR pszFile, DWORD grfMode, DWORD dwAttributes, BOOL fCreate, struct IStream * pstmTemplate, struct IStream **ppstm);

#endif // (_WIN32_IE >= 0x0600)



#endif // NO_SHLWAPI_STREAM



#if (_WIN32_IE >= 0x0500)

// SHAutoComplete
//      hwndEdit - HWND of editbox, ComboBox or ComboBoxEx.
//      dwFlags - Flags to indicate what to AutoAppend or AutoSuggest for the editbox.
//
// WARNING:
//    Caller needs to have called CoInitialize() or OleInitialize()
//    and cannot call CoUninit/OleUninit until after
//    WM_DESTROY on hwndEdit.
//
//  dwFlags values:
#define SHACF_DEFAULT                   0x00000000  // Currently (SHACF_FILESYSTEM | SHACF_URLALL)
#define SHACF_FILESYSTEM                0x00000001  // This includes the File System as well as the rest of the shell (Desktop\My Computer\Control Panel\)
#define SHACF_URLALL                    (SHACF_URLHISTORY | SHACF_URLMRU)
#define SHACF_URLHISTORY                0x00000002  // URLs in the User's History
#define SHACF_URLMRU                    0x00000004  // URLs in the User's Recently Used list.
#define SHACF_USETAB                    0x00000008  // Use the tab to move thru the autocomplete possibilities instead of to the next dialog/window control.
#define SHACF_FILESYS_ONLY              0x00000010  // This includes the File System

#if (_WIN32_IE >= 0x0600)
#define SHACF_FILESYS_DIRS              0x00000020  // Same as SHACF_FILESYS_ONLY except it only includes directories, UNC servers, and UNC server shares.
#endif // (_WIN32_IE >= 0x0600)

#define SHACF_AUTOSUGGEST_FORCE_ON      0x10000000  // Ignore the registry default and force the feature on.
#define SHACF_AUTOSUGGEST_FORCE_OFF     0x20000000  // Ignore the registry default and force the feature off.
#define SHACF_AUTOAPPEND_FORCE_ON       0x40000000  // Ignore the registry default and force the feature on. (Also know as AutoComplete)
#define SHACF_AUTOAPPEND_FORCE_OFF      0x80000000  // Ignore the registry default and force the feature off. (Also know as AutoComplete)

LWSTDAPI SHAutoComplete(HWND hwndEdit, DWORD dwFlags);

LWSTDAPI SHSetThreadRef(IUnknown *punk);
LWSTDAPI SHGetThreadRef(IUnknown **ppunk);

LWSTDAPI_(BOOL) SHSkipJunction(struct IBindCtx* pbc, const CLSID *pclsid);
#endif // (_WIN32_IE >= 0x0500)

#define CTF_INSIST          0x00000001      // SHCreateThread() dwFlags - call pfnThreadProc synchronously if CreateThread() fails
#define CTF_THREAD_REF      0x00000002      // hold a reference to the creating thread
#define CTF_PROCESS_REF     0x00000004      // hold a reference to the creating process
#define CTF_COINIT          0x00000008      // init COM for the created thread
#define CTF_FREELIBANDEXIT  0x00000010      // hold a ref to the DLL and call FreeLibraryAndExitThread() when done
#define CTF_REF_COUNTED     0x00000020      // thread supports ref counting via SHGetThreadRef() or CTF_THREAD_REF so that child threads can keep this thread alive
#define CTF_WAIT_ALLOWCOM   0x00000040      // while waiting for pfnCallback, allow COM marshaling to the blocked calling thread

LWSTDAPI_(BOOL) SHCreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void *pData, DWORD dwFlags, LPTHREAD_START_ROUTINE pfnCallback);

LWSTDAPI SHReleaseThreadRef(); // release a CTF_THREAD_REF reference earlier than the return of pfnThreadProc

#ifndef NO_SHLWAPI_GDI
//
//====== GDI helper functions  ================================================
//

LWSTDAPI_(HPALETTE) SHCreateShellPalette(HDC hdc);

#if (_WIN32_IE >= 0x0500)

LWSTDAPI_(void)     ColorRGBToHLS(COLORREF clrRGB, WORD* pwHue, WORD* pwLuminance, WORD* pwSaturation);
LWSTDAPI_(COLORREF) ColorHLSToRGB(WORD wHue, WORD wLuminance, WORD wSaturation);
LWSTDAPI_(COLORREF) ColorAdjustLuma(COLORREF clrRGB, int n, BOOL fScale);


#endif  // _WIN32_IE >= 0x0500

#endif // NO_SHLWAPI_GDI


//
//====== DllGetVersion  =======================================================
//

typedef struct _DLLVERSIONINFO
{
    DWORD cbSize;
    DWORD dwMajorVersion;                   // Major version
    DWORD dwMinorVersion;                   // Minor version
    DWORD dwBuildNumber;                    // Build number
    DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

#if (_WIN32_IE >= 0x0501)

typedef struct _DLLVERSIONINFO2
{
    DLLVERSIONINFO info1;
    DWORD dwFlags;                          // No flags currently defined
    ULONGLONG ullVersion;                   // Encoded as:
                                            // Major 0xFFFF 0000 0000 0000
                                            // Minor 0x0000 FFFF 0000 0000
                                            // Build 0x0000 0000 FFFF 0000
                                            // QFE   0x0000 0000 0000 FFFF
} DLLVERSIONINFO2;

#define DLLVER_MAJOR_MASK                    0xFFFF000000000000
#define DLLVER_MINOR_MASK                    0x0000FFFF00000000
#define DLLVER_BUILD_MASK                    0x00000000FFFF0000
#define DLLVER_QFE_MASK                      0x000000000000FFFF

#endif

#define MAKEDLLVERULL(major, minor, build, qfe) \
        (((ULONGLONG)(major) << 48) |        \
         ((ULONGLONG)(minor) << 32) |        \
         ((ULONGLONG)(build) << 16) |        \
         ((ULONGLONG)(  qfe) <<  0))

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);

// DllInstall (to be implemented by self-installing DLLs)
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine);



#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif


#endif  // _INC_SHLWAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\sxstypes.h ===
/*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sxstypes.h

Abstract:

    Include file with definitions for data structures used for side-by-side
    binding.

Author:

    Michael Grier (MGrier) 28-Mar-2000

Environment:


Revision History:

--*/

#ifndef _SXSTYPES_
#define _SXSTYPES_

#if (_MSC_VER > 1020)
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif

typedef struct _ACTIVATION_CONTEXT_DATA ACTIVATION_CONTEXT_DATA;
typedef const ACTIVATION_CONTEXT_DATA *PCACTIVATION_CONTEXT_DATA;

//
// These data structures have to line up in a number of different run-time
// environments, so we explicitly set the alignment.
//
#include "pshpack4.h"
//
// These data structures may be generated by 64bit code and consumed
// in 32bit code, as in the case of 32bit processes on Win64.
// Therefore they have no pointers and no SIZE_Ts.
//
// Besides that, they are created in a different process than they
// are consumed. They are position independent.
//

//
//  ASSEMBLY_VERSION represents a traditional four-part version
//  as in Major.Minor.Revision.Build.
//
//  They are laid out so that you can perform a simple ULONGLONG-
//  based comparison on them.
//
//  They are interpreted as:
//
//      Major.Minor.Build.Revision
//
//  So for example you might have "5.1.2505.2" (where 5.1 is the major
//  minor, 2505 represents the daily build number and 2 is the number
//  of updates to the build since its initial build).
//
//  Overloaded comparison operators are provided for C++ clients.
//

#include "pshpack1.h"

typedef union _ASSEMBLY_VERSION {
    struct {
        USHORT Build;
        USHORT Revision;
        USHORT Minor;
        USHORT Major;
    };
    ULONGLONG QuadPart;
} ASSEMBLY_VERSION, *PASSEMBLY_VERSION;

#include "poppack.h"

typedef const ASSEMBLY_VERSION *PCASSEMBLY_VERSION;

#if defined(__cplusplus)
extern "C++" {
inline bool operator ==(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart == av2.QuadPart; }
inline bool operator !=(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart != av2.QuadPart; }
inline bool operator <(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart < av2.QuadPart; }
inline bool operator >(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart > av2.QuadPart; }
inline bool operator <=(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart <= av2.QuadPart; }
inline bool operator >=(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart >= av2.QuadPart; }
} /* extern "C++" */
#endif /* __cplusplus */

//
//  Standard Activation Context section IDs:
//

// begin_winnt
#define ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION         (1)
#define ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION              (2)
#define ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION     (3)
#define ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION       (4)
#define ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION    (5)
#define ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION (6)
#define ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION       (7)
#define ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE   (8)
#define ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES               (9)
// end_winnt

//
//  Activation Context section format identifiers:
//

#define ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN               (0)
#define ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE          (1)
#define ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE            (2)

typedef struct _ACTIVATION_CONTEXT_DATA {
    ULONG Magic;
    ULONG HeaderSize;
    ULONG FormatVersion;
    ULONG TotalSize;
    ULONG DefaultTocOffset;
    ULONG ExtendedTocOffset;
    ULONG AssemblyRosterOffset;
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA, *PACTIVATION_CONTEXT_DATA;
typedef const ACTIVATION_CONTEXT_DATA *PCACTIVATION_CONTEXT_DATA;

#define ACTIVATION_CONTEXT_DATA_MAGIC ((ULONG) 'xtcA')
#define ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER (1)

// Internally this is associated with the data, but externally
// the data is usually opaque and it is associated with the activation context.
#define ACTIVATION_CONTEXT_FLAG_NO_INHERIT (0x00000001)

typedef struct _ACTIVATION_CONTEXT_DATA_TOC_HEADER {
    ULONG HeaderSize;
    ULONG EntryCount;
    ULONG FirstEntryOffset;
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA_TOC_HEADER, *PACTIVATION_CONTEXT_DATA_TOC_HEADER;
typedef const struct _ACTIVATION_CONTEXT_DATA_TOC_HEADER *PCACTIVATION_CONTEXT_DATA_TOC_HEADER;

#define ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE (0x00000001)
#define ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER (0x00000002)

typedef struct _ACTIVATION_CONTEXT_DATA_TOC_ENTRY {
    ULONG Id;
    ULONG Offset;            // from ACTIVATION_CONTEXT_DATA base
    ULONG Length;           // in bytes
    ULONG Format;           // ACTIVATION_CONTEXT_SECTION_FORMAT_*
} ACTIVATION_CONTEXT_DATA_TOC_ENTRY, *PACTIVATION_CONTEXT_DATA_TOC_ENTRY;
typedef const struct _ACTIVATION_CONTEXT_DATA_TOC_ENTRY *PCACTIVATION_CONTEXT_DATA_TOC_ENTRY;

typedef struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER {
    ULONG HeaderSize;
    ULONG EntryCount;
    ULONG FirstEntryOffset;     // from ACTIVATION_CONTEXT_DATA base
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER, *PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;
typedef const struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER *PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;

typedef struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY {
    GUID ExtensionGuid;
    ULONG TocOffset;            // from ACTIVATION_CONTEXT_DATA base
    ULONG Length;
} ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY, *PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;
typedef const struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY *PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER {
    ULONG HeaderSize;
    ULONG HashAlgorithm;
    ULONG EntryCount;               // Entry 0 is reserved; this is the number of assemblies plus 1.
    ULONG FirstEntryOffset;         // From ACTIVATION_CONTEXT_DATA base
    ULONG AssemblyInformationSectionOffset; // Offset from the ACTIVATION_CONTEXT_DATA base to the
                                    // header of the assembly information string section.  Needed because
                                    // the roster entries contain the offsets from the ACTIVATION_CONTEXT_DATA
                                    // to the assembly information structs, but those structs contain offsets
                                    // from their section base to the strings etc.
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;
typedef const struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;

#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID (0x00000001)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT    (0x00000002)

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY {
    ULONG Flags;
    ULONG PseudoKey;                // case-insentively-hashed assembly name
    ULONG AssemblyNameOffset;       // from ACTIVATION_CONTEXT_DATA base
    ULONG AssemblyNameLength;       // length in bytes
    ULONG AssemblyInformationOffset; // from ACTIVATION_CONTEXT_DATA base to ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION
    ULONG AssemblyInformationLength; // length in bytes
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;
typedef const struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;

//
//  ActivationContext string sections are organized as follows:
//
//  Header
//  Hash structure (optional)
//  List of subelements
//  Variable length data
//
//
//  If you don't recognize the FormatVersion, you should still
//  be able to navigate to the list of subelements; once there
//  you can still do a very fast linear search avoiding many
//  string comparisons if the hash algorithms align.
//
//  If you can't even use the hash algorithm, you can still do
//  string comparisons.
//

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_HEADER {
    ULONG Magic;
    ULONG HeaderSize;               // in bytes
    ULONG FormatVersion;
    ULONG DataFormatVersion;
    ULONG Flags;
    ULONG ElementCount;
    ULONG ElementListOffset;        // offset from section header
    ULONG HashAlgorithm;
    ULONG SearchStructureOffset;    // offset from section header
    ULONG UserDataOffset;           // offset from section header
    ULONG UserDataSize;             // in bytes
} ACTIVATION_CONTEXT_STRING_SECTION_HEADER, *PACTIVATION_CONTEXT_STRING_SECTION_HEADER;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_HEADER *PCACTIVATION_CONTEXT_STRING_SECTION_HEADER;

#define ACTIVATION_CONTEXT_STRING_SECTION_MAGIC ((ULONG) 'dHsS')

#define ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE              (0x00000001)
#define ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER    (0x00000002)

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE {
    ULONG BucketTableEntryCount;
    ULONG BucketTableOffset;        // offset from section header
} ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE, *PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE *PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET {
    ULONG ChainCount;
    ULONG ChainOffset;              // offset from section header
} ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET, *PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET *PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;

// The hash table bucket chain is then a list of offsets from the section header to
// the section entries for the chain.

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY {
    ULONG PseudoKey;
    ULONG KeyOffset;            // offset from the section header
    ULONG KeyLength;            // in bytes
    ULONG Offset;               // offset from the section header
    ULONG Length;               // in bytes
    ULONG AssemblyRosterIndex;  // 1-based index into the assembly roster for the assembly that
                                // provided this entry.  If the entry is not associated with
                                // an assembly, zero.
} ACTIVATION_CONTEXT_STRING_SECTION_ENTRY, *PACTIVATION_CONTEXT_STRING_SECTION_ENTRY;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY *PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY;

//
//  ActivationContext GUID sections are organized as follows:
//
//  Header
//  Hash structure (optional)
//  List of subelements
//  Variable length data
//
//  If you don't recognize the FormatVersion, you should still
//  be able to navigate to the list of subelements; once there
//  you can still do a very fast linear search avoiding many
//  GUID comparisons.
//

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_HEADER {
    ULONG Magic;
    ULONG HeaderSize;
    ULONG FormatVersion;
    ULONG DataFormatVersion;
    ULONG Flags;
    ULONG ElementCount;
    ULONG ElementListOffset;        // offset from section header
    ULONG SearchStructureOffset;    // offset from section header
    ULONG UserDataOffset;           // offset from section header
    ULONG UserDataSize;             // in bytes
} ACTIVATION_CONTEXT_GUID_SECTION_HEADER, *PACTIVATION_CONTEXT_GUID_SECTION_HEADER;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_HEADER *PCACTIVATION_CONTEXT_GUID_SECTION_HEADER;

#define ACTIVATION_CONTEXT_GUID_SECTION_MAGIC ((ULONG) 'dHsG')

#define ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER    (0x00000001)

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE {
    ULONG BucketTableEntryCount;
    ULONG BucketTableOffset;        // offset from section header
} ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE, *PACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE *PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET {
    ULONG ChainCount;
    ULONG ChainOffset;              // offset from section header
} ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET, *PACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET *PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;

// The hash table bucket chain is then a list of offsets from the section header to
// the section entries for the chain.

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY {
    GUID Guid;
    ULONG Offset;               // offset from the section header
    ULONG Length;               // in bytes
    ULONG AssemblyRosterIndex;  // 1-based index into the assembly roster for the assembly that
                                // provided this entry.  If the entry is not associated with
                                // an assembly, zero.
} ACTIVATION_CONTEXT_GUID_SECTION_ENTRY, *PACTIVATION_CONTEXT_GUID_SECTION_ENTRY;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY *PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY;

//
//  Data structures for the assembly information section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION)
//

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION {
    ULONG Size;
    ULONG Flags;
    GUID PolicyCoherencyGuid;
    GUID PolicyOverrideGuid;
    ULONG ApplicationDirectoryPathType;
    ULONG ApplicationDirectoryLength;
    ULONG ApplicationDirectoryOffset; // Offset from base of ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;
typedef const ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;

//
//  Leaf node structure for the assembly information section
//

#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_FORMAT_WHISTLER (1)

//
//  Bitflags for the Flags member of an assembly information section element.
//

#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY              (0x00000001)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED             (0x00000002)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED    (0x00000004)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED        (0x00000008)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY           (0x00000010)

// ACTIVATION_CONTEXT_PATH_TYPE_NONE is used when
// a manifest has no stored location or identity, such as when a manifest is found
// in the app compat database.  The client is free to specify a manifest path
// string which should assist in diagnosing where the manifest came from, but
// cannot be assumed to have any particular format or syntax.

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION {
    ULONG Size;                                 // size of this structure, in bytes
    ULONG Flags;
    ULONG EncodedAssemblyIdentityLength;        // in bytes
    ULONG EncodedAssemblyIdentityOffset;        // offset from section header base

    ULONG ManifestPathType;
    ULONG ManifestPathLength;                   // in bytes
    ULONG ManifestPathOffset;                   // offset from section header base
    LARGE_INTEGER ManifestLastWriteTime;
    ULONG PolicyPathType;
    ULONG PolicyPathLength;                     // in bytes
    ULONG PolicyPathOffset;                     // offset from section header base
    LARGE_INTEGER PolicyLastWriteTime;
    ULONG MetadataSatelliteRosterIndex;
    ULONG Unused2;
    ULONG ManifestVersionMajor;
    ULONG ManifestVersionMinor;
    ULONG PolicyVersionMajor;
    ULONG PolicyVersionMinor;
    ULONG AssemblyDirectoryNameLength; // in bytes
    ULONG AssemblyDirectoryNameOffset; // from section header base
    ULONG NumOfFilesInAssembly;
// 2600 stopped here
    ULONG LanguageLength; // in bytes
    ULONG LanguageOffset; // from section header base
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;

typedef const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;

//
//  Leaf node structure for the dll redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER (1)

//
//  ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Flags:
//
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME
//
//          Provides for a redirection that remaps not just the path but the actual
//          base name of the file to access.
//
//          Not used in any current Whistler scenarios.
//
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT
//
//          Provides for a redirection where the actual storage path of the file
//          must be determined at runtime by via the assembly roster.  This allows
//          for a cached activation context to remain valid across when an assembly
//          is relocated across storage volumes.
//
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND
//
//          The path must be constructed by appending all the segments and then
//          the resultant string must be passed through either the
//          RtlExpandEnvironmentStrings() or the Win32 ExpandEnvironmentStrings() APIs.
//
//          Used generally only for app compat where a manifest for the executable
//          may call out a file which the application may erroneously carry with it
//          (possibly on read-only media) to be redirected to, for example,
//          "%windir%\system32\"
//
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SYSTEM_DEFAULT_REDIRECTED_SYSTEM32_DLL
//
//          Provides for dll which exist under system32 as well as system default
//          for example, comctl32.dll. There are two entries for this dll in string section
//          (1) LoadLibrary("comctl32.dll"), redirected to 5.82 comctl32 under winsxs
//          (2) LoadLibrary("c:\windows\system32\comctl32.dll"), is also redirected to 5.82 
//              comctl32 under winsxs
//
//  Note!
//
//      You may not have a single entry with both the
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT and
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND flags set.
//

#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME                     (0x00000001)
#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT                    (0x00000002)
#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND                                 (0x00000004)
#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SYSTEM_DEFAULT_REDIRECTED_SYSTEM32_DLL (0x00000008)

typedef struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG TotalPathLength; // bytewise length of concatenated segments only
    ULONG PathSegmentCount;
    ULONG PathSegmentOffset; // offset from section base header so that entries can share
} ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION, *PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION *PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;

typedef struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT {
    ULONG Length; // in bytes
    ULONG Offset; // from section header so that individual entries can share
} ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT, *PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;

typedef const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT *PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;

//
//  Leaf node structures for window class redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER (1)

typedef struct _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG VersionSpecificClassNameLength; // in bytes
    ULONG VersionSpecificClassNameOffset; // Offset from ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION base
    ULONG DllNameLength; // in bytes
    ULONG DllNameOffset; // Offset from section base because this can be shared across multiple entries
} ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION, *PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION *PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;

//
//  Leaf node structures for COM activation redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_INVALID (0)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT (1)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE (2)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE (3)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH (4)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL (5)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG ThreadingModel;
    GUID ReferenceClsid;
    GUID ConfiguredClsid;
    GUID ImplementedClsid;
    GUID TypeLibraryId;
    ULONG ModuleLength; // in bytes
    ULONG ModuleOffset; // offset from section base because this can be shared across multiple entries
    ULONG ProgIdLength; // in bytes
    ULONG ProgIdOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION because this is never shared
    ULONG ShimDataLength; // in bytes
    ULONG ShimDataOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION because this is not shared
} ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;

//
//  ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM is a struct optionally hung
//  off an ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION that describes shimming. 
//  The common use of a shim is a file that is not a PE that implements
//  DllGetClassObject(); instead some other DLL will use the path
//  to the file in question plus metadata (typename for managed code and Java)
//  to provide a COM object that implements the CLSID.  Note that the file may not
//  even be a PE for things like scriptlets.  Most shims will reference the
//  system registry for this metadata; Fusion-aware shims can use the information
//  here in the activation context.
//
//  The format version of the ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION should
//  account for any format changes in the _SHIM struct here.
//

#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER (1)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS (2)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM {
    ULONG Size;
    ULONG Flags;
    ULONG Type;
    ULONG ModuleLength; // in bytes
    ULONG ModuleOffset; // offset from section base
    ULONG TypeLength; // in bytes
    ULONG TypeOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM
    ULONG ShimVersionLength; // in bytes
    ULONG ShimVersionOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM
    ULONG DataLength; // in bytes
    ULONG DataOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM
} ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM, *PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;

typedef const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM *PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;

//
//  Leaf node structures for COM interface marshalling redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID    (0x00000001)
#define ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID (0x00000002)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    GUID ProxyStubClsid32;
    ULONG NumMethods;
    GUID TypeLibraryId;
    GUID BaseInterface;
    ULONG NameLength; // in bytes
    ULONG NameOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION because this is not shared
} ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;

//
//  Leaf node structures for COM type library redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION)
//

//
// CLR interop goop
//
#define ACTIVATION_CONTEXT_DATA_CLR_SURROGATE_FORMAT_WHISTLER   (1)

typedef struct _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE {
    ULONG   Size;
    ULONG   Flags;
    GUID    SurrogateIdent;
    ULONG   VersionOffset;              // The version of runtime corresponding to this type
    ULONG   VersionLength;
    ULONG   TypeNameOffset;             // Name of the type that implements this surrogate
    ULONG   TypeNameLength;             
} ACTIVATION_CONTEXT_DATA_CLR_SURROGATE, *PACTIVATION_CONTEXT_DATA_CLR_SURROGATE;

typedef const struct _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE *PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE;




//
//OLD
//OLD  The type library redirection section is keyed off a string composed of the type library GUID,
//OLD  the hexidecimal representation of the LCID for the tlb and the version number of the
//OLD type library.
//OLD
//OLD  e.g.
//OLD
//OLD      "{0ECD9B60-23AA-11D0-B351-00A0C9055D8E}_en-us_6.0"
//OLD
//
// The type library redirection section is keyed off of the type library guid.
//

#define ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER (1)

typedef struct _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION
{
    USHORT Major;
    USHORT Minor;
} ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION, *PACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION;
typedef const ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION* PCACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION;

typedef struct _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_2600 {
    ULONG   Size;
    ULONG   Flags;
    ULONG   NameLength; // in bytes
    ULONG   NameOffset; // offset from section header
    USHORT  ResourceId; // Resource ID of type library resource in PE
    USHORT  LibraryFlags; // flags, as defined by the LIBFLAGS enumeration in oaidl.h
    ULONG   HelpDirLength; // in bytes
    ULONG   HelpDirOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION
} ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_2600, *PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_2600;

typedef const ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_2600 *PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_2600;

typedef struct _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION {
    ULONG   Size;
    ULONG   Flags;
    ULONG   NameLength; // in bytes
    ULONG   NameOffset; // offset from section header
    USHORT  ResourceId; // Resource ID of type library resource in PE
    USHORT  LibraryFlags; // flags, as defined by the LIBFLAGS enumeration in oaidl.h
    ULONG   HelpDirLength; // in bytes
    ULONG   HelpDirOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION
// 2600 stopped here.
    ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION Version;
} ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;

//
//  Leaf node structures for COM ProgId redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER (1)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG ConfiguredClsidOffset; // offset from section header
} ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;

#include "poppack.h"

#if defined(__cplusplus)
} /* extern "C" */
#endif

#endif /* _SXSTYPES_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\assemblyidentity.cs ===
using System;
using System.Text;
using System.Collections;

namespace Microsoft.Fusion.ADF
{
	// A class for storing values associated with assembly's identity.
	// Standard information, such as name, version, public key token,
	// processor architecture, and culture are explicitly stored as
	// properties, while any other custom attributes can be set using
	// this class as a hashtable.
	public class AssemblyIdentity
	{
		private string name;
		private Version vers;
		private string pktString;
		private string procArch;
		private string lang;
		private Hashtable properties;

		public AssemblyIdentity(string name, Version vers, string pktString, string procArch, string lang)
		{
			this.name = "";
			if(name != null) this.name = name;
			this.vers = new Version(0, 0, 0, 0);
			if(vers != null) this.vers = vers;
			this.pktString = "";
			if(pktString != null) this.pktString = pktString;
			this.procArch = "";
			if(procArch != null) this.procArch = procArch;
			this.lang = "";
			if(lang != null) this.lang = lang;
			properties = new Hashtable();
			properties[AssemblyIdentityStandardProps.Name] = this.name;
			properties[AssemblyIdentityStandardProps.Version] = this.vers.ToString();
			properties[AssemblyIdentityStandardProps.PubKeyTok] = this.pktString;
			properties[AssemblyIdentityStandardProps.ProcArch] = this.procArch;
			properties[AssemblyIdentityStandardProps.Lang] = this.lang;
		}

		public string Name
		{
			get
			{
				return name;
			}
		}

		public Version Vers
		{
			get
			{
				return vers;
			}
		}

		public string PublicKeyTokenString
		{
			get
			{
				return pktString;
			}
		}

		public string ProcessorArchitecture
		{
			get
			{
				return procArch;
			}
		}

		public string Language
		{
			get
			{
				return lang;
			}
		}

		public string FullName
		{
			get
			{
				StringBuilder sb = new StringBuilder();
				sb.Append("name=" + this.name);
				sb.Append(", version=" + this.vers.ToString());
				sb.Append(", pubKeyTok=" + this.pktString);
				sb.Append(", procArch=" + this.procArch);
				sb.Append(", lang=" + this.lang);
				return sb.ToString();
			}
		}

		public string this[string index]
		{
			get { return (string) properties[index]; }
			set 
			{
				if(properties[index] == null) properties[index] = (object) value;
				//else throw new Exception("Property " + index  + " of this AssemblyIdentity is already set");
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\assemblyidentitystandardprops.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	// This is a class containing strings representing default properties of an AssemblyIdentity, used to access by indexing.
	public class AssemblyIdentityStandardProps
	{
		public static string
			Name = "name",
			Version = "version",
			PubKeyTok = "publickeytoken",
			ProcArch = "processorarchitecture",
			Lang = "language";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\assemblymanifestparser.cpp ===
#using <mscorlib.dll>
#using "assm.netmodule"
#include <stdio.h>
#include <windows.h>
#include <fusenet.h>
#include <util.h>
#include <shlwapi.h>
#include <sxsapi.h>
#include <wchar.h>
#include "cor.h"

using namespace System;
using namespace Microsoft::Fusion::ADF;
using System::Runtime::InteropServices::Marshal;

#define ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE 32
#define MAX_PKT_LEN 33

typedef	HRESULT	(*pfnGetAssemblyMDImport)(LPCWSTR szFileName, REFIID riid, LPVOID *ppv);
typedef	BOOL (*pfnStrongNameTokenFromPublicKey)(LPBYTE,	DWORD, LPBYTE*,	LPDWORD);
typedef	HRESULT	(*pfnStrongNameErrorInfo)();
typedef	VOID (*pfnStrongNameFreeBuffer)(LPBYTE);

//#pragma unmanaged

pfnGetAssemblyMDImport g_pfnGetAssemblyMDImport = NULL;
pfnStrongNameTokenFromPublicKey	g_pfnStrongNameTokenFromPublicKey  = NULL;
pfnStrongNameErrorInfo g_pfnStrongNameErrorInfo = NULL;
pfnStrongNameFreeBuffer	g_pfnStrongNameFreeBuffer = NULL;

//--------------------------------------------------------------------
// BinToUnicodeHex
//--------------------------------------------------------------------
HRESULT BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst)
{
	UINT x;
	UINT y;

#define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))   

	for ( x = 0, y = 0 ; x < cSrc ; ++x )
	{
		UINT v;
		v = pSrc[x]>>4;
		pDst[y++] = TOHEX( v );  
		v = pSrc[x] & 0x0f;                 
		pDst[y++] = TOHEX( v ); 
	}                                    
	pDst[y] = '\0';

	return S_OK;
}

// ---------------------------------------------------------------------------
// DeAllocateAssemblyMetaData
//-------------------------------------------------------------------
STDAPI DeAllocateAssemblyMetaData(ASSEMBLYMETADATA	*pamd)
{
	// NOTE	- do not 0 out counts
	// since struct	may	be reused.

	pamd->cbLocale = 0;
	SAFEDELETEARRAY(pamd->szLocale);

	SAFEDELETEARRAY(pamd->rProcessor);
	SAFEDELETEARRAY(pamd->rOS);

	return S_OK;
}

// ---------------------------------------------------------------------------
// InitializeEEShim
//-------------------------------------------------------------------
HRESULT	InitializeEEShim()
{
	HRESULT	hr = S_OK;
	MAKE_ERROR_MACROS_STATIC(hr);
	HMODULE	hMod;

	// BUGBUG -	mscoree.dll	never gets unloaded	with increasing	ref	count.
	// what	does URT do?
	hMod = LoadLibrary(TEXT("mscoree.dll"));

	IF_WIN32_FALSE_EXIT(hMod);

	g_pfnGetAssemblyMDImport = (pfnGetAssemblyMDImport)GetProcAddress(hMod,	"GetAssemblyMDImport");
	g_pfnStrongNameTokenFromPublicKey =	(pfnStrongNameTokenFromPublicKey)GetProcAddress(hMod, "StrongNameTokenFromPublicKey");
	g_pfnStrongNameErrorInfo = (pfnStrongNameErrorInfo)GetProcAddress(hMod,	"StrongNameErrorInfo");			  
	g_pfnStrongNameFreeBuffer =	(pfnStrongNameFreeBuffer)GetProcAddress(hMod, "StrongNameFreeBuffer");


	if (!g_pfnGetAssemblyMDImport || !g_pfnStrongNameTokenFromPublicKey	|| !g_pfnStrongNameErrorInfo
		|| !g_pfnStrongNameFreeBuffer) 
	{
		hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
		goto exit;
	}
exit:
	return hr;
}

// ---------------------------------------------------------------------------
// CreateMetaDataImport
//-------------------------------------------------------------------
HRESULT	CreateMetaDataImport(LPCOLESTR pszFilename,	IMetaDataAssemblyImport	**ppImport)
{
	HRESULT	hr=	S_OK;
	MAKE_ERROR_MACROS_STATIC(hr);

	IF_FAILED_EXIT(InitializeEEShim());

	hr =  (*g_pfnGetAssemblyMDImport)(pszFilename, IID_IMetaDataAssemblyImport,	(void **)ppImport);

	IF_TRUE_EXIT(hr	== HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), hr);	// do not assert
	IF_FAILED_EXIT(hr);

exit:

	return hr;
}

// ---------------------------------------------------------------------------
// AllocateAssemblyMetaData
//-------------------------------------------------------------------
STDAPI AllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd)
{
	HRESULT	hr = S_OK;
	MAKE_ERROR_MACROS_STATIC(hr);

	// Re/Allocate Locale array
	SAFEDELETEARRAY(pamd->szLocale);		

	if (pamd->cbLocale)	{
		IF_ALLOC_FAILED_EXIT(pamd->szLocale	= new(WCHAR[pamd->cbLocale]));
	}

	// Re/Allocate Processor array
	SAFEDELETEARRAY(pamd->rProcessor);
	IF_ALLOC_FAILED_EXIT(pamd->rProcessor =	new(DWORD[pamd->ulProcessor]));

	// Re/Allocate OS array
	SAFEDELETEARRAY(pamd->rOS);
	IF_ALLOC_FAILED_EXIT(pamd->rOS = new(OSINFO[pamd->ulOS]));

exit:
	if (FAILED(hr) && pamd)
		DeAllocateAssemblyMetaData(pamd);

	return hr;
}

// ---------------------------------------------------------------------------
// ByteArrayMaker
// ---------------------------------------------------------------------------
HRESULT ByteArrayMaker(LPVOID pvOriginator, DWORD dwOriginator, LPBYTE *ppbPublicKeyToken, DWORD *pcbPublicKeyToken)
{
	//LPBYTE pbPublicKeyToken;
	//DWORD cbPublicKeyToken;

	if (!(g_pfnStrongNameTokenFromPublicKey((LPBYTE)pvOriginator, dwOriginator, ppbPublicKeyToken, pcbPublicKeyToken)))
	{
		return g_pfnStrongNameErrorInfo();
	}
	//*ppbPublicKeyToken = pbPublicKeyToken;
	//*pcbPublicKeyToken = cbPublicKeyToken;
	return S_OK;
}

// ---------------------------------------------------------------------------
// ByteArrayFreer
// ---------------------------------------------------------------------------
void ByteArrayFreer(LPBYTE pbPublicKeyToken)
{
	g_pfnStrongNameFreeBuffer(pbPublicKeyToken);
}

//#pragma managed

namespace FusionADF
{
	__gc public class AssemblyManifestParser
	{

	public:

		// ---------------------------------------------------------------------------
		// AssemblyManifestParser constructor
		// ---------------------------------------------------------------------------
		AssemblyManifestParser()
		{
			_dwSig					= 'INAM';
			_pMDImport				= NULL;
			_rAssemblyRefTokens		= NULL;
			_cAssemblyRefTokens		= 0;
			_rAssemblyModuleTokens	= NULL;
			_cAssemblyModuleTokens	= 0;
			*_szManifestFilePath	= TEXT('\0');
			_ccManifestFilePath		= 0;
			*_szAssemblyName		= TEXT('\0');
			_pvOriginator			= NULL;
			_dwOriginator			= 0;
			_name					= NULL;
			_version				= NULL;
			*_szPubKeyTokStr		= TEXT('\0');
			_pktString				= NULL;
			_procArch				= NULL;
			_language				= NULL;
			_hr						= S_OK;

			instanceValid			= false;
			initCalledOnce			= false;
		}

		// ---------------------------------------------------------------------------
		// AssemblyManifestParser destructor
		// ---------------------------------------------------------------------------
		~AssemblyManifestParser()
		{
			SAFERELEASE(_pMDImport);
			SAFEDELETEARRAY(_rAssemblyRefTokens);
			SAFEDELETEARRAY(_rAssemblyModuleTokens);
		}

		bool InitFromFile(String* filePath)
		{
			LPCOLESTR lstr = 0;
			HRESULT hr;

			if(initCalledOnce) return false;
			initCalledOnce = true;

			try
			{
				lstr = static_cast<LPCOLESTR>(const_cast<void*>(static_cast<const void*>(Marshal::StringToHGlobalAuto(filePath))));
			}
			catch(ArgumentException *e)
			{
				// handle the exception
				return false;
			}
			catch (OutOfMemoryException *e)
			{
				// handle the exception
				return false;
			}
			hr = Init(lstr);
			if(hr != S_OK) return false;
			instanceValid = true;
			return true;
		}

		bool IsInstanceValid()
		{
			return instanceValid;
		}

		bool HasInitBeenCalled()
		{
			return initCalledOnce;
		}

		// ---------------------------------------------------------------------------
		// GetAssemblyIdentity
		// ---------------------------------------------------------------------------
		AssemblyIdentity* GetAssemblyIdentity()
		{
			return new AssemblyIdentity(_name, _version, _pktString, _procArch, _language);
		}

		// ---------------------------------------------------------------------------
		// GetNumDependentAssemblies
		// ---------------------------------------------------------------------------
		int GetNumDependentAssemblies()
		{
			return _cAssemblyRefTokens;
		}

		// ---------------------------------------------------------------------------
		// GetDependentAssemblyInfo
		// ---------------------------------------------------------------------------
		DependentAssemblyInfo* GetDependentAssemblyInfo(int nIndex)
		{
			WCHAR  szAssemblyName[MAX_PATH];

			const VOID*				pvOriginator = 0;
			const VOID*				pvHashValue	   = NULL;

			DWORD ccAssemblyName = MAX_PATH,
				cbOriginator   = 0,
				ccLocation	   = MAX_PATH,
				cbHashValue	   = 0,
				dwRefFlags	   = 0;

			INT	i;

			LPWSTR pwz=NULL;

			mdAssemblyRef	 mdmar;
			ASSEMBLYMETADATA amd = {0};

			String *name = NULL, *pktString = NULL, *procArch = NULL, *language = NULL;
			Version *version = NULL;

			// Verify the index	passed in. 
			if (nIndex >= _cAssemblyRefTokens)
			{
				_hr	= HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
				goto exit;
			}

			// Reference indexed dep assembly ref token.
			mdmar =	_rAssemblyRefTokens[nIndex];

			// Default allocation sizes.
			amd.ulProcessor	= amd.ulOS = 32;
			amd.cbLocale = MAX_PATH;

			// Loop	max	2 (try/retry)
			for	(i = 0;	i <	2; i++)
			{
				// Allocate	ASSEMBLYMETADATA instance.
				IF_FAILED_EXIT(AllocateAssemblyMetaData(&amd));

				// Get the properties for the refrenced	assembly.
				IF_FAILED_EXIT(_pMDImport->GetAssemblyRefProps(
					mdmar,				// [IN]	The	AssemblyRef	for	which to get the properties.
					&pvOriginator,		// [OUT] Pointer to	the	PublicKeyToken blob.
					&cbOriginator,		// [OUT] Count of bytes	in the PublicKeyToken Blob.
					szAssemblyName,		// [OUT] Buffer	to fill	with name.
					MAX_PATH,	  // [IN] Size of buffer in	wide chars.
					&ccAssemblyName,	// [OUT] Actual	# of wide chars	in name.
					&amd,				// [OUT] Assembly MetaData.
					&pvHashValue,		// [OUT] Hash blob.
					&cbHashValue,		// [OUT] Count of bytes	in the hash	blob.
					&dwRefFlags			// [OUT] Flags.
					));

				// Check if	retry necessary.
				if (!i)
				{	
					if (amd.ulProcessor	<= 32 
						&& amd.ulOS	<= 32)
					{
						break;
					}			 
					else
						DeAllocateAssemblyMetaData(&amd);
				}

				// Retry with updated sizes
			}

			// Allow for funky null	locale convention
			// in metadata - cbLocale == 0 means szLocale ==L'\0'
			if (!amd.cbLocale)
			{
				amd.cbLocale = 1;
			}
			else if	(amd.szLocale)
			{
				WCHAR *ptr;
				ptr	= StrChrW(amd.szLocale,	L';');
				if (ptr)
				{
					(*ptr) = L'\0';
					amd.cbLocale = ((DWORD)	(ptr - amd.szLocale) + sizeof(WCHAR));
				}			 
			}
			else
			{
				_hr	= HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
				goto exit;
			}

			//Name
			name = new String(szAssemblyName);

			//Version
			version = new Version(amd.usMajorVersion, amd.usMinorVersion, amd.usBuildNumber, amd.usRevisionNumber);

			//Public Key Token
			if (cbOriginator)
			{
				IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[cbOriginator*2	+1]);
				IF_FAILED_EXIT(BinToUnicodeHex((LPBYTE)pvOriginator, cbOriginator, pwz));
				pktString = new String(pwz);
				SAFEDELETEARRAY(pwz);
			}

			//Architecture
			procArch = S"x86";

			//Language
			if (!(*amd.szLocale)) language = S"*";
			else language = new String(amd.szLocale);

			_hr = S_OK;

exit:
			DeAllocateAssemblyMetaData(&amd);
			SAFEDELETEARRAY(pwz);

			if(_hr != S_OK) return NULL;
			else return new DependentAssemblyInfo(new AssemblyIdentity(name, version, pktString, procArch, language), NULL);
		}

		// ---------------------------------------------------------------------------
		// GetNumDependentFiles
		// ---------------------------------------------------------------------------
		int GetNumDependentFiles()
		{
			return _cAssemblyModuleTokens;
		}

		// ---------------------------------------------------------------------------
		// GetDependentFileInfo
		// ---------------------------------------------------------------------------
		DependentFileInfo* GetDependentFileInfo(int nIndex)
		{
			LPWSTR pszName = NULL;
			DWORD ccPath   = 0;
			WCHAR szModulePath[MAX_PATH];

			mdFile					mdf;
			WCHAR					szModuleName[MAX_PATH];
			DWORD					ccModuleName   = MAX_PATH;
			const VOID*				pvHashValue	   = NULL;	  
			DWORD					cbHashValue	   = 0;
			DWORD					dwFlags		   = 0;

			LPWSTR pwz=NULL;

			String *name = NULL, *hash = NULL;

			// Verify the index. 
			if (nIndex >= _cAssemblyModuleTokens)
			{
				_hr	= HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
				goto exit;
			}

			// Reference indexed dep assembly ref token.
			mdf	= _rAssemblyModuleTokens[nIndex];

			// Get the properties for the refrenced	assembly.
			IF_FAILED_EXIT(_pMDImport->GetFileProps(
				mdf,			// [IN]	The	File for which to get the properties.
				szModuleName,	// [OUT] Buffer	to fill	with name.
				MAX_CLASS_NAME,	// [IN]	Size of	buffer in wide chars.
				&ccModuleName,	// [OUT] Actual	# of wide chars	in name.
				&pvHashValue,	// [OUT] Pointer to	the	Hash Value Blob.
				&cbHashValue,	// [OUT] Count of bytes	in the Hash	Value Blob.
				&dwFlags));		// [OUT] Flags.

			//name
			name = new String(szModuleName);

			//hash
			if (cbHashValue)
			{
				IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[cbHashValue*2 +1]);
				IF_FAILED_EXIT(_hr = BinToUnicodeHex((LPBYTE)pvHashValue, cbHashValue, pwz));
				hash = new String(pwz);
				SAFEDELETEARRAY(pwz);
			}

			_hr = S_OK;

exit:
			SAFEDELETEARRAY(pwz);

			if(_hr != S_OK) return NULL;
			else return new DependentFileInfo(name, hash);
		}

	private:
		DWORD                    _dwSig;
		HRESULT                  _hr;

		WCHAR                    _szManifestFilePath  __nogc[MAX_PATH];
		DWORD                    _ccManifestFilePath;
		WCHAR					 _szAssemblyName __nogc[MAX_CLASS_NAME];
		IMetaDataAssemblyImport *_pMDImport;
		PBYTE                    _pMap;
		mdAssembly              *_rAssemblyRefTokens;
		DWORD                    _cAssemblyRefTokens;
		mdFile                  *_rAssemblyModuleTokens;
		DWORD                    _cAssemblyModuleTokens;
		LPVOID					 _pvOriginator;
		DWORD					 _dwOriginator;
		String*					 _name;
		Version*				 _version;
		WCHAR					 _szPubKeyTokStr __nogc[MAX_PKT_LEN];
		String*					 _pktString;
		String*					 _procArch;
		String*					 _language;

		bool					instanceValid;
		bool					initCalledOnce;

		// ---------------------------------------------------------------------------
		// Init
		// ---------------------------------------------------------------------------
		HRESULT	Init(LPCOLESTR szManifestFilePath)
		{
			WCHAR __pin *tempFP = _szManifestFilePath;
			WCHAR __pin *temp_szAssemblyName = _szAssemblyName;
			WCHAR __pin *temp_szPubKeyTokStr = _szPubKeyTokStr;

			LPBYTE pbPublicKeyToken = NULL;
			DWORD cbPublicKeyToken = 0;
			DWORD dwFlags = 0, dwSize = 0, dwHashAlgId = 0;
			INT	i;

			ASSEMBLYMETADATA amd = {0};

			const cElems = ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE;

			// ********** First, work on getting metadata from file.
			// ********** ------------------------------------------

			IF_NULL_EXIT(szManifestFilePath, E_INVALIDARG);

			_ccManifestFilePath	= lstrlenW(szManifestFilePath) + 1;
			memcpy(tempFP, szManifestFilePath, _ccManifestFilePath * sizeof(WCHAR));

			IF_ALLOC_FAILED_EXIT(_rAssemblyRefTokens = new(mdAssemblyRef[cElems]));
			IF_ALLOC_FAILED_EXIT(_rAssemblyModuleTokens	= new(mdFile[cElems]));

			// Create meta data	importer if	necessary.
			if (!_pMDImport)
			{
				IMetaDataAssemblyImport *temp_pMDImport;
				// Create meta data	importer
				_hr	= CreateMetaDataImport((LPCOLESTR)tempFP, &temp_pMDImport);

				IF_TRUE_EXIT(_hr ==	HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), _hr);
				IF_FAILED_EXIT(_hr);

				_pMDImport = temp_pMDImport;

			}

			// ********** Next, get the assembly identity fields.
			// ********** ---------------------------------------

			mdAssembly mda;
			// Get the assembly	token.
			if(FAILED(_hr =	_pMDImport->GetAssemblyFromScope(&mda)))
			{
				// This	fails when called with managed module and not manifest.	mg does	such things.
				_hr	= S_FALSE; // this will	convert	CLDB_E_RECORD_NOTFOUND (0x80131130)	to S_FALSE;
				goto exit;
			}

			// Default allocation sizes.
			amd.ulProcessor	= amd.ulOS = 32;
			amd.cbLocale = MAX_PATH;

			// Loop	max	2 (try/retry)
			for	(i = 0;	i <	2; i++)
			{
				// Create an ASSEMBLYMETADATA instance.
				IF_FAILED_EXIT(AllocateAssemblyMetaData(&amd));

				LPVOID temp_pvOriginator;
				DWORD temp_dwOriginator;
				// Get name	and	metadata
				IF_FAILED_EXIT(_pMDImport->GetAssemblyProps(			 
					mda,								// [IN]	The	Assembly for which to get the properties.
					(const void	**)&temp_pvOriginator,  // [OUT]	Pointer	to the Originator blob.
					&temp_dwOriginator,						// [OUT] Count of bytes	in the Originator Blob.
					&dwHashAlgId,						// [OUT] Hash Algorithm.
					temp_szAssemblyName,					// [OUT] Buffer	to fill	with name.
					MAX_CLASS_NAME,						// [IN]	 Size of buffer	in wide	chars.
					&dwSize,							// [OUT] Actual	# of wide chars	in name.
					&amd,								// [OUT] Assembly MetaData.
					&dwFlags							// [OUT] Flags.																   
					));
				_pvOriginator = temp_pvOriginator;
				_dwOriginator = temp_dwOriginator;

				// Check if	retry necessary.
				if (!i)
				{
					if (amd.ulProcessor	<= 32 && amd.ulOS <= 32)
						break;
					else
						DeAllocateAssemblyMetaData(&amd);
				}
			}

			// Allow for funky null	locale convention
			// in metadata - cbLocale == 0 means szLocale ==L'\0'
			if (!amd.cbLocale)
			{			
				amd.cbLocale = 1;
			}
			else if	(amd.szLocale)
			{
				WCHAR *ptr;
				ptr	= StrChrW(amd.szLocale,	L';');
				if (ptr)
				{
					(*ptr) = L'\0';
					amd.cbLocale = ((DWORD)	(ptr - amd.szLocale) + sizeof(WCHAR));
				}		   
			}
			else
			{
				_hr	= E_FAIL;
				goto exit;
			}

			// NAME is _szAssemblyName, pinned in temp_szAssemblyName, set to _name using the following code:
			_name = new String(temp_szAssemblyName);

			// VERSION is _version, set using the following code:
			_version = new Version(amd.usMajorVersion, amd.usMinorVersion, amd.usBuildNumber, amd.usRevisionNumber);

			// PUBLICKEYTOKEN is being figured out
			if (_dwOriginator)
			{
				if(FAILED(_hr = ByteArrayMaker(_pvOriginator, _dwOriginator, &pbPublicKeyToken, &cbPublicKeyToken)))
				{
					goto exit;
				}
				if(FAILED(_hr = BinToUnicodeHex(pbPublicKeyToken, cbPublicKeyToken, temp_szPubKeyTokStr)))
				{
					goto exit;
				}
				ByteArrayFreer(pbPublicKeyToken);
				_pktString = new String(temp_szPubKeyTokStr);
			}

			// LANGUAGE is _language, set using the following code:
			if (!(*amd.szLocale)) _language = S"*";
			else _language = new String(amd.szLocale);

			// PROCESSOR ARCHITECTURE is _procArch, set using the following code:
			_procArch = S"x86";

			// ********** Next, get the dependent assemblies.
			// ********** -----------------------------------

			if (!_cAssemblyRefTokens)
			{
				DWORD cTokensMax = 0;
				HCORENUM hEnum = 0;
				// Attempt to get token	array. If we have insufficient space
				// in the default array	we will	re-allocate	it.
				if (FAILED(_hr = _pMDImport->EnumAssemblyRefs(
					&hEnum,	
					_rAssemblyRefTokens, 
					ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE,	
					&cTokensMax)))
				{
					goto exit;
				}

				// Number of tokens	known. close enum.
				_pMDImport->CloseEnum(hEnum);
				hEnum =	0;

				// Insufficient	array size.	Grow array.
				if (cTokensMax > ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE)
				{
					// Re-allocate space for tokens.
					SAFEDELETEARRAY(_rAssemblyRefTokens);
					_cAssemblyRefTokens	= cTokensMax;
					_rAssemblyRefTokens	= new(mdAssemblyRef[_cAssemblyRefTokens]);
					if (!_rAssemblyRefTokens)
					{
						_hr	= E_OUTOFMEMORY;
						goto exit;
					}

					DWORD temp_cART;
					// Re-get tokens.		 
					if (FAILED(_hr = _pMDImport->EnumAssemblyRefs(
						&hEnum,	
						_rAssemblyRefTokens, 
						cTokensMax,	
						&temp_cART)))
					{
						goto exit;
					}
					_cAssemblyRefTokens = temp_cART;

					// Close enum.
					_pMDImport->CloseEnum(hEnum);			 
					hEnum =	0;
				}
				// Otherwise, the default array	size was sufficient.
				else
				{
					_cAssemblyRefTokens	= cTokensMax;
				}
			}

			// ********** Next, get the dependent files / modules.
			// ********** ----------------------------------------

			if (!_cAssemblyModuleTokens)
			{
				DWORD cTokensMax = 0;
				HCORENUM hEnum = 0;
				// Attempt to get token	array. If we have insufficient space
				// in the default array	we will	re-allocate	it.
				if (FAILED(_hr = _pMDImport->EnumFiles(&hEnum, _rAssemblyModuleTokens, 
					ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE,	&cTokensMax)))
				{
					goto exit;
				}

				// Number of tokens	known. close enum.
				_pMDImport->CloseEnum(hEnum);
				hEnum =	0;

				if (cTokensMax > ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE)
				{
					// Insufficient	array size.	Grow array.
					_cAssemblyModuleTokens = cTokensMax;
					SAFEDELETEARRAY(_rAssemblyModuleTokens);
					_rAssemblyModuleTokens = new(mdFile[_cAssemblyModuleTokens]);
					if(_hr == S_OK) Console::WriteLine(S"Still OK 3");
					if (!_rAssemblyModuleTokens)
					{
						_hr	= E_OUTOFMEMORY;
						//Console::WriteLine(S"2 HR set, failure, going to exit");
						goto exit;
					}

					DWORD temp_cAMT;
					// Re-get tokens.		 
					if (FAILED(_hr = _pMDImport->EnumFiles(
						&hEnum,	
						_rAssemblyModuleTokens,	
						cTokensMax,	
						&temp_cAMT)))
					{
						//Console::WriteLine(S"3 HR set, failure, going to exit");
						goto exit;
					}
					_cAssemblyModuleTokens = temp_cAMT;

					// Close enum.
					_pMDImport->CloseEnum(hEnum);			 
					hEnum =	0;
				}		 
				// Otherwise, the default array	size was sufficient.
				else _cAssemblyModuleTokens = cTokensMax;
			}
			_hr = S_OK;

exit:
			// ********** If everything worked, _hr will be S_OK. That is for caller to determine.
			// ********** ------------------------------------------------------------------------
			DeAllocateAssemblyMetaData(&amd);
			return _hr;
		}

		//Functions	not	implemented
		HRESULT	GetSubscriptionInfo(IManifestInfo **ppSubsInfo)
		{
			return E_NOTIMPL;
		}

		HRESULT	GetNextPlatform(DWORD nIndex, IManifestData	**ppPlatformInfo)
		{
			return E_NOTIMPL;
		}

		HRESULT	GetManifestApplicationInfo(IManifestInfo **ppAppInfo)
		{
			return E_NOTIMPL;
		}

		HRESULT	CQueryFile(LPCOLESTR	pwzFileName,IManifestInfo **ppAssemblyFile)
		{
			return E_NOTIMPL;
		}
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\defaultassemblymanifestimport.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	public class DefaultAssemblyManifestImport : IAssemblyManifestImport
	{
		private AssemblyIdentity assmID;
		private DependentFileInfo[] depFileInfoArr;
		private DependentAssemblyInfo[] depAssmInfoArr;

		public DefaultAssemblyManifestImport(AssemblyIdentity assmID, DependentAssemblyInfo[] depAssmInfoArr, DependentFileInfo[] depFileInfoArr)
		{
			this.assmID = assmID;
			this.depFileInfoArr = depFileInfoArr;
			this.depAssmInfoArr = depAssmInfoArr;
		}

		AssemblyIdentity IAssemblyManifestImport.GetAssemblyIdentity()
		{
			return assmID;
		}

		DependentFileInfo[] IAssemblyManifestImport.GetDependentFileInfo()
		{
			return depFileInfoArr;
		}

		DependentAssemblyInfo[] IAssemblyManifestImport.GetDependentAssemblyInfo()
		{
			return depAssmInfoArr;
		}

		ManifestType IAssemblyManifestImport.GetManifestType()
		{
			return ManifestType.Component;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\defaultassemblymanifestimporter.cs ===
using System;
using System.IO;
using FusionADF;

namespace Microsoft.Fusion.ADF
{
	public class DefaultAssemblyManifestImporter
	{
		
		public static IAssemblyManifestImport GetAssemblyManifestImport(string fileName)
		{
			DefaultAssemblyManifestImport retVal = null;
			AssemblyManifestParser amp = new AssemblyManifestParser();

			string fullPath = Path.GetFullPath(fileName);
			if(!File.Exists(fileName)) throw new FileNotFoundException("The path " + fullPath + " does not refer to a file.");
			else
			{
				bool checkInit = amp.InitFromFile(fileName);
				if(checkInit)
				{
					AssemblyIdentity impAssmID = amp.GetAssemblyIdentity();
					int numDepAssms = amp.GetNumDependentAssemblies();
					DependentAssemblyInfo[] impDepAssmInfoArr = new DependentAssemblyInfo[numDepAssms];
					for(int i = 0; i < numDepAssms; i++)
					{
						impDepAssmInfoArr[i] = amp.GetDependentAssemblyInfo(i);
						if(impDepAssmInfoArr[i] == null) throw new BadImageFormatException("Cannot access dependent assembly information from " + fullPath);
					}
					int numDepFiles = amp.GetNumDependentFiles();
					DependentFileInfo[] impDepFileInfoArr = new DependentFileInfo[numDepFiles];
					for(int i = 0; i < numDepFiles; i++)
					{
						impDepFileInfoArr[i] = amp.GetDependentFileInfo(i);
						if(impDepFileInfoArr[i] == null) throw new BadImageFormatException("Cannot access dependent file information from " + fullPath);
					}
					retVal = new DefaultAssemblyManifestImport(impAssmID, impDepAssmInfoArr, impDepFileInfoArr);
				}
				else throw new BadImageFormatException("The file " + fullPath + " is not an assembly.");
			}
			return retVal;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\dependentfileinfo.cs ===
using System;
using System.Text;

namespace Microsoft.Fusion.ADF
{
	public class DependentFileInfo
	{ 
		private string fileName;
		private byte[] fileHash;
		private string fileHashString;

		public DependentFileInfo(string fileName, string fileHashString)
		{
			this.fileName = "";
			if(fileName != null) this.fileName = fileName;
			this.fileHash = null;
			//if(fileHash != null) {this.fileHash = new byte[fileHash.Length]; Array.Copy(fileHash, this.fileHash, fileHash.Length);}
			this.fileHashString = "";
			if(fileHashString != null) this.fileHashString = fileHashString;
		}

		public string Name
		{
			get
			{
				return fileName;
			}
		}

		public byte[] Hash
		{
			get
			{
				return fileHash;
			}
		}

		public string HashString
		{
			get
			{
				return fileHashString;
			}
		}

		public string FullName
		{
			get
			{
				StringBuilder sb = new StringBuilder();
				sb.Append("name=" + this.fileName);
				sb.Append(", hash=" + this.fileHashString);
				return sb.ToString();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\iassemblymanifestimport.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	// This interface describes classes that are able to open IL assemblies
	// and parse their metadata, extracting information such as the components
	// of the assembly's strong name, the strong names of dependent assemblies,
	// and the relative paths and hashcodes of files referenced.
	public interface IAssemblyManifestImport
	{
		// Gets the components of the strong name of the assembly.
		AssemblyIdentity GetAssemblyIdentity();

		// Gets an array contaning the information on the files of this assembly, in order.
		DependentFileInfo[] GetDependentFileInfo();

		// Gets an array containing the information on the dependent assemblies of this assembly, in order.
		DependentAssemblyInfo[] GetDependentAssemblyInfo();

		// Returns the type of manifest.
		ManifestType GetManifestType();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\dependentassemblyinfo.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	public class DependentAssemblyInfo
	{
		private AssemblyIdentity assmID;
		private string codeBase;

		public DependentAssemblyInfo(AssemblyIdentity assmID, string codeBase) 
		{
			this.assmID = assmID;
			this.codeBase = codeBase;
		}

		public AssemblyIdentity AssmID
		{
			get
			{
				return assmID;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\ifileoperator.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	// This interface describes classes that perform some operation
	// on files, usually by reading them and deriving some information
	// from them in a search through a directory tree.
	public interface IFileOperator
	{
		void ProcessDirectory(string startDir, string relPathDir);

		// A function that processes a file in a directory in some way. The
		// information it has available to it is the start of the directory
		// scan, the relative path from the start, and the filename. The abs
		// path can be constructed by concatenating the three args in order.
		void ProcessFile(string startDir, string relPathDir, string fileName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\dirscanner.cs ===
using System;
using System.IO;

namespace Microsoft.Fusion.ADF
{
	public class DirScanner
	{

		public static void BeginScan(IFileOperator ifo, string rootPath)
		{
			if((ifo != null) && (rootPath != null))
			{
				string fullPath = Path.GetFullPath(rootPath);      
				if(Directory.Exists(fullPath)) ScanDirectory(ifo, fullPath, ""); // This path is a directory
				else Console.WriteLine(fullPath + " is not a valid directory.");
			}
		}

		public static void ScanDirectory(IFileOperator ifo, string rootPath, string relPathDir)
		{
			string currDir = Path.Combine(rootPath, relPathDir);
			//string currDir = String.Concat(rootPath, relPathDir);

			// Process the list of files found in the directory
			string [] fileEntries = Directory.GetFiles(currDir);
			foreach(string fileName in fileEntries) ifo.ProcessFile(rootPath, relPathDir, Path.GetFileName(fileName));

			// Recurse into subdirectories of this directory
			string [] subdirEntries = Directory.GetDirectories(currDir);
			foreach(string subdir in subdirEntries) 
			{
				// Get the end directory and tag it onto relPathDir
				string tempRelPathDir = Path.Combine(relPathDir, subdir.Substring(currDir.Length+1));

				ifo.ProcessDirectory(rootPath, tempRelPathDir);
				ScanDirectory(ifo, rootPath, tempRelPathDir);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\manifestgeneratorassminfo.cs ===
using System.Reflection;

[assembly:AssemblyTitleAttribute("Microsoft Application Deployment Framework Manifest Generator Tools")]
[assembly:AssemblyDescriptionAttribute("Microsoft Application Deployment Framework -  Programmatic Access to Manifest Generation for .Net Applications")]
[assembly:AssemblyProductAttribute("Microsoft Application Deployment Framework")]
[assembly:AssemblyInformationalVersionAttribute("1.0.0.0")]
[assembly:AssemblyTrademarkAttribute("Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation")]
[assembly:AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:AssemblyCopyrightAttribute("Copyright  Microsoft Corp. 1999-2002. All rights reserved.")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mainapp.cs ===
using System;
using System.IO;
using System.Xml;

namespace Microsoft.Fusion.ADF
{
	class MainApp
	{
		public static void Main(string[] args)
		{
			string sourceDir, targetDir, paramFile, extraXmlFile;
			ManifestGenerator mg = null;
			MGParamParser mgPP = null;
			Stream paramFileStream = null, extraXmlStream = null;

			if(args.Length < 2 || args.Length > 3)
			{
				Console.WriteLine("usage: mg <source_dir> <param_file> [extra_xml]");
				Console.WriteLine("<> indicates a parameter that is required.");
				Console.WriteLine("[] indicates a parameter that is optional.");
				return;
			}
			if(args.Length == 2)
			{
				sourceDir = args[0];
				paramFile = args[1];
				targetDir = args[0];
				extraXmlFile = null;
			}
			else
			{
				sourceDir = args[0];
				paramFile = args[1];
				targetDir = args[0];
				extraXmlFile = args[2];
			}
		
			try
			{
				paramFileStream = File.Open(paramFile, FileMode.Open);
			}
			catch(FileNotFoundException fnfe)
			{
				Console.WriteLine(fnfe.ToString());
			}

			try
			{
				if(extraXmlFile != null) extraXmlStream = File.Open(extraXmlFile, FileMode.Open);
			}
			catch(FileNotFoundException fnfe)
			{
				Console.WriteLine(fnfe.ToString());
			}

			try
			{
				mgPP = new MGParamParser(paramFileStream);
			}
			catch(MGParseErrorException mgpee)
			{
				Console.WriteLine(mgpee.ToString());
			}

			string appManFilePath = "";
			string subManFilePath = "";

			if(mgPP != null)
			{
				appManFilePath = Path.Combine(targetDir, String.Concat(mgPP.AppName, ".manifest"));
				subManFilePath = Path.Combine(targetDir, String.Concat(mgPP.AppName, ".subscription.manifest"));

				// DEAL WITH THIS MORE ELEGANTLY ... EITHER SAVE THESE FILES IN MEMORY OR MOVE TO TEMP DIRECTORY?
				if(File.Exists(appManFilePath)) File.Delete(appManFilePath);
				if(File.Exists(subManFilePath)) File.Delete(subManFilePath);

				try
				{
					mg = new ManifestGenerator(sourceDir, mgPP, extraXmlStream);
				}
				catch(ArgumentNullException ane)
				{
					Console.WriteLine(ane.ToString());
				}
				catch(ArgumentException ae)
				{
					Console.WriteLine(ae.ToString());
				}
				catch(MGParseErrorException mgpee)
				{
					Console.WriteLine(mgpee.ToString());
				}
				catch(MGDependencyException mgde)
				{
					Console.WriteLine(mgde.ToString());
				}
				catch(XmlException xmle)
				{
					Console.WriteLine(xmle.ToString());
				}
			}

			if(mg != null)
			{
				// Take the streams and make files out of them

				FileStream appManFile = File.Create(appManFilePath);
				FileStream subManFile = File.Create(subManFilePath);

				// Set up copy buffer

				int copyBufferSize = 32768;
				byte[] copyBuffer = new byte[copyBufferSize];
				int bytesRead;

				// Write the streams out

				Stream appManContents = mg.AppManStream;
				Stream subManContents = mg.SubManStream;

				while((bytesRead = appManContents.Read(copyBuffer, 0, copyBufferSize)) > 0) appManFile.Write(copyBuffer, 0, bytesRead);
				while((bytesRead = subManContents.Read(copyBuffer, 0, copyBufferSize)) > 0) subManFile.Write(copyBuffer, 0, bytesRead);

				// Close streams

				appManFile.Flush();
				appManFile.Close();
				Console.WriteLine("Created " + appManFilePath + " successfully");

				subManFile.Flush();
				subManFile.Close();
				Console.WriteLine("Created " + subManFilePath + " successfully");

				mg.CloseStreams();

				// Convert sourceDir and targetDir to absolute paths so that we can check if they are the same
				// Then check and store value

				bool dirsEqual = false;

				if(targetDir != null)
				{
					string absSourceDir = Path.GetFullPath(sourceDir).ToLower();
					string absTargetDir = Path.GetFullPath(targetDir).ToLower();
					dirsEqual = absSourceDir.Equals(absTargetDir);
				}

				// Now do the file copying if necessary

				if(!dirsEqual && targetDir != null)
				{
					if(!Directory.Exists(targetDir))
					{
						try
						{
							Directory.CreateDirectory(targetDir);
						}
						catch(IOException ioe)
						{
							throw new ArgumentException("Target directory " + targetDir + " could not be created.", ioe);
						}
						catch(ArgumentException ae)
						{
							throw new ArgumentException("Target directory " + targetDir + " could not be created.", ae);
						}
					}

					MGFileCopier mgFC = new MGFileCopier(targetDir);
					DirScanner.BeginScan((IFileOperator) mgFC, sourceDir);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgassminfo.cs ===
using System.Reflection;

[assembly:AssemblyTitleAttribute("Microsoft Application Deployment Framework Manifest Generator")]
[assembly:AssemblyDescriptionAttribute("Microsoft Application Deployment Framework -  Manifest Generation for .Net Applications")]
[assembly:AssemblyProductAttribute("Microsoft Application Deployment Framework")]
[assembly:AssemblyInformationalVersionAttribute("1.0.0.0")]
[assembly:AssemblyTrademarkAttribute("Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation")]
[assembly:AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:AssemblyCopyrightAttribute("Copyright  Microsoft Corp. 1999-2002. All rights reserved.")]

[assembly:System.CLSCompliant(true)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\manifesttype.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	// This is an enumeration describing possible types of manifests.
	public enum ManifestType : long
	{
		Unknown = 0L,
		Application = 1L,
		Component = 2L
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgdependencyexception.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	public class MGDependencyException : ApplicationException
	{

		public MGDependencyException() : base()
		{
		}

		public MGDependencyException(string errorMsg) : base(errorMsg)
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\legacy\mfilter.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "mfilter.h"
#include <stdio.h> // for _snwprintf

// note: a bit hacky to use something that's implemented under shell\shortcut
#include "project.hpp"  // for extern HRESULT GetLastWin32Error(); only


// {2B3C580C-9BE6-44c5-9BB5-558F7EEF58E2}
static const GUID CLSID_FusionMimeFilter = 
{ 0x2b3c580c, 0x9be6, 0x44c5, { 0x9b, 0xb5, 0x55, 0x8f, 0x7e, 0xef, 0x58, 0xe2 } };

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);


#ifdef SHOW_CLICKONCE_AD
//WCHAR g_wzAdString[] = { L"<html><head><title>Downloading Fusion ClickOnce App...</title></head><body><form><script Language=\"JScript\">\ndocument.write('<font face=\"Arial, Helvetica, Geneva, sans-serif\">Brought to you by <b>Microsoft</b>,<br><b>Fusion ClickOnce</b><br><br><a target=\"_blank\" href=\"http://www.microsoft.com\"><img src=\"http://www.microsoft.com/library/homepage/images/ms-banner.gif\" border=0 width=250 height=60></a></font>\\n');\nresizeTo(350, 300);\nwindow.status=\"download started\";\n</script><noscript>Brought to you by Microsoft,<br>Fusion ClickOnce<br><br><a target=\"_blank\" href=\"http://www.microsoft.com\"><img src=\"http://www.microsoft.com/library/homepage/images/ms-banner.gif\" border=0 width=250 height=60></a></noscript><br></form></body></html>" };
WCHAR g_wzAdString[] = { L"<html><head><title>Downloading Fusion ClickOnce App...</title></head><body><form><script Language=\"JScript\">\ndocument.write('<font face=\"Arial, Helvetica, Geneva, sans-serif\">Brought to you by <b>Microsoft</b>,<br><b>Fusion ClickOnce</b><br><br><a target=\"_blank\" href=\"http://www.microsoft.com\"><img src=\"http://www.microsoft.com/library/homepage/images/ms-banner.gif\" border=0 width=250 height=60></a></font>\\n');\nwindow.status=\"download started\";\n</script><noscript>Brought to you by Microsoft,<br>Fusion ClickOnce<br><br><a target=\"_blank\" href=\"http://www.microsoft.com\"><img src=\"http://www.microsoft.com/library/homepage/images/ms-banner.gif\" border=0 width=250 height=60></a></noscript><br></form></body></html>" };
ULONG g_cbAdLen = sizeof(g_wzAdString)-sizeof(WCHAR);    //strlen - ending L'\0'
#endif


// BUGBUG: look for the Open verb and its command string in the registry and execute that instead
// rundll32.exe should be in c:\windows\system32
// BUGBUG: security hole with CreateProcess- consider using full path with ""
#define WZ_EXEC_STRING      L"rundll32.exe fnsshell.dll,Start \"%s\" \"%s\""


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CFusionMimeFilterClassFactory::CFusionMimeFilterClassFactory()
{
    _cRef = 1;
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilterClassFactory::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return hr;
}

// ----------------------------------------------------------------------------

ULONG
CFusionMimeFilterClassFactory::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CFusionMimeFilterClassFactory::Release()
{
    LONG ulCount = InterlockedDecrement(&_cRef);

    if (ulCount <= 0)
    {
        delete this;
    }

    return (ULONG) ulCount;
}

HRESULT
CFusionMimeFilterClassFactory::LockServer(BOOL lock)
{
    return (lock ? 
            DllAddRef() :
            DllRelease());
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilterClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;
    CFusionMimeFilter *pMimeFilter = NULL;

    *ppv = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
    {
        hr = CLASS_E_NOAGGREGATION;
        goto exit;
    }

    pMimeFilter = new CFusionMimeFilter();
    if (pMimeFilter == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = (IInternetProtocol *)pMimeFilter;
        pMimeFilter->AddRef();
    }
    else
    {
        hr = pMimeFilter->QueryInterface(iid, ppv);
        if (FAILED(hr))
            goto exit;
    }

exit:
    if (pMimeFilter)
        pMimeFilter->Release();

    return hr;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

#define BUFFER_READ_SIZE 4096
static BYTE g_buffer[BUFFER_READ_SIZE + sizeof(WCHAR)]; // BUGBUG?: why '+sizeof(WCHAR)?'

// ----------------------------------------------------------------------------
// CFusionMimeFilter

CFusionMimeFilter::CFusionMimeFilter()
{
    _cRef = 1;
    _fFirstRead = TRUE;
    _fReadDone = FALSE;
    _pOutgoingProtSink = NULL;
    _pIncomingProt = NULL;
    _grfSTI = 0;

    _pwzUrl = NULL;

    _wzTempFile[0] = L'\0';
    _hFile = 0; //INVALID_HANDLE_VALUE;

    _cbAdRead = 0;

    InitializeCriticalSection(&_cs);
    _csLock = new CCriticalSection(&_cs);
    // AV if _csLock == NULL       
}

CFusionMimeFilter::~CFusionMimeFilter()
{
    if (_pwzUrl)
        delete [] _pwzUrl;

    if (_pIncomingProt)
    {
        _pIncomingProt->Release();
        _pIncomingProt = NULL;
    }

    if (_pOutgoingProtSink)
    {
        _pOutgoingProtSink->Release();
        _pOutgoingProtSink = NULL;
    }

    CloseTempFile();    // ignore return value

    delete _csLock;
    DeleteCriticalSection(&_cs);
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilter::QueryInterface(REFIID iid,  void** ppv)
{
    HRESULT hr = S_OK;
    *ppv = NULL;

    if (iid == IID_IInternetProtocol ||
        iid == IID_IInternetProtocolRoot ||
        iid == IID_IUnknown)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (iid == IID_IInternetProtocolSink)
    {
        *ppv = (IInternetProtocolSink *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return hr;
}

// ----------------------------------------------------------------------------

ULONG
CFusionMimeFilter::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CFusionMimeFilter::Release()
{
    LONG ulCount = InterlockedDecrement(&_cRef);

    if (ulCount <= 0)
    {
        delete this;
    }

    return (ULONG) ulCount;
}

// ----------------------------------------------------------------------------
// IInternetProtocol interface

HRESULT
CFusionMimeFilter::Start(
        LPCWSTR wzUrl,
        IInternetProtocolSink *pIProtSink,
        IInternetBindInfo *pIBindInfo,
        DWORD grfSTI,
        HANDLE_PTR dwReserved)
{
    HRESULT hr = E_FAIL;
    WCHAR* string[1];

    _csLock->Lock();    // check return value

    string[0] = NULL;

    _grfSTI = grfSTI;

    if (!(grfSTI & PI_FILTER_MODE))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ULONG ulCount = 0;
        DWORD grfBINDF = 0;
        BINDINFO bindinfo;

        ZeroMemory(&bindinfo, sizeof(bindinfo));

        // get bindinfo
        bindinfo.cbSize = sizeof(BINDINFO);
        hr=pIBindInfo->GetBindInfo(&grfBINDF, &bindinfo);
        if (bindinfo.cbSize)
        {
            ReleaseBindInfo(&bindinfo);
            ZeroMemory(&bindinfo, sizeof(bindinfo));
        }

        // hr from GetBindInfo() above...
        if (hr == S_OK)
        {
            // check bind flag...
            if ((grfBINDF & BINDF_NO_UI) != 0 || (grfBINDF & BINDF_SILENTOPERATION ) != 0)
            {
                // possibly under Explorer folder view generating previews of .url Internet Shortcut files...
                // in any case, this should fail -  we should always do UI
                // note: also tried hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER, didn't help
                hr = E_FAIL;
                goto exit;
            }
        }

        // copy the URL
        // param wzUrl is the mime Content Type for plug mime filter
        // so have to get the real url this way
        if (FAILED(hr=pIBindInfo->GetBindString(BINDSTRING_URL, string, 1, &ulCount)))
            goto exit;

        if (_pwzUrl)
            delete [] _pwzUrl;

        _pwzUrl = new WCHAR[wcslen(string[0])+1];
        if (!_pwzUrl)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        wcscpy(_pwzUrl, string[0]);

        // get the protocol pointer from reserved pointer
        PROTOCOLFILTERDATA* ProtFiltData = (PROTOCOLFILTERDATA*) dwReserved;
        if (NULL != _pIncomingProt)
        {
            hr = E_UNEXPECTED;
            goto exit;
        }

        if (NULL == ProtFiltData->pProtocol)
        {
            // !! We can't do anything without an interface to read from
            hr = E_INVALIDARG;
            goto exit;
        }

        _pIncomingProt = ProtFiltData->pProtocol;
        _pIncomingProt->AddRef();

        // hold onto the sink as well
        if (NULL != _pOutgoingProtSink)
        {
            hr = E_UNEXPECTED;
            goto exit;
        }

        _pOutgoingProtSink = pIProtSink;
        _pOutgoingProtSink->AddRef();

        _fFirstRead = TRUE;

        hr = S_OK;
    }

exit:
    if (string[0] != NULL)
    {
        CoTaskMemFree(string[0]);
    }

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::Continue(PROTOCOLDATA *pProtData)
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
    else
        hr = _pIncomingProt->Continue(pProtData);

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::Abort(HRESULT hrReason,DWORD dwOptions)
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
    else
        hr = _pIncomingProt->Abort(hrReason, dwOptions);

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::Terminate(DWORD dwOptions)
{
    HRESULT hr = S_OK;
    _csLock->Lock();    // check return value

    // Release the sink
    if (_pOutgoingProtSink)
    {
        _pOutgoingProtSink->Release();
        _pOutgoingProtSink = NULL;
    }

    if (NULL == _pIncomingProt)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    hr = _pIncomingProt->Terminate(dwOptions);

exit:

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::Suspend()
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
    else
        hr = _pIncomingProt->Suspend();

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::Resume()
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
    else
        hr = _pIncomingProt->Resume();

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = S_OK;
    HRESULT hrFromProt=S_FALSE;

    BYTE* pbuff = g_buffer;
    ULONG cbReadFromProt;
    DWORD cbWritten = 0;

    _csLock->Lock();    // check return value

    // assumes _pOutgoingProtSink != NULL

    // Read() can be called multiple times after it is done (and Prot Handler will return S_FALSE)
    // this ensure the followings are called once only
    if (!_fReadDone)
    {
        // retrieve requested amount of data from protocol handler
        hrFromProt = _pIncomingProt->Read((void*)pbuff, BUFFER_READ_SIZE, &cbReadFromProt);
        if (E_PENDING != hrFromProt) // may have some extra data in our buffer, so continue
        {
            if (FAILED(hrFromProt))
            {
                hr = hrFromProt;
                goto exit;
            }
            else 
            {
                // write data to a temp file
                if (cbReadFromProt > 0)
                {
                    if (_fFirstRead)
                    {
                        if (FAILED(hr=OpenTempFile()))
                            goto exit;

                        _fFirstRead = FALSE;
#ifndef SHOW_CLICKONCE_AD  

                        // must do this (once) to avoid getting a Open/Save dialog from IE
                        // note: reporting same mime type (_not_ "text/html") so that the IE window stays on same page or goes away (if Start Run)
                        _pOutgoingProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, CONTENT_TYPE);
#endif
                    }
                    if ( !WriteFile(_hFile, pbuff, cbReadFromProt, &cbWritten, NULL) || 
                        cbWritten != cbReadFromProt )
                    {
                        hr = GetLastWin32Error();
                        goto exit;
                    }
                }

                // prot handler will let us know when there is no more data left
                if (S_FALSE == hrFromProt)
                {
                    STARTUPINFO si;
                    PROCESS_INFORMATION pi;
                    WCHAR wzCmdLine[MAX_PATH];  // BUGBUG: string length limitation...

                    if (FAILED(hr=CloseTempFile()))
                        goto exit;

                    if (_snwprintf(wzCmdLine, sizeof(wzCmdLine)/sizeof(wzCmdLine[0]),
                        WZ_EXEC_STRING, _wzTempFile, _pwzUrl) < 0)
                    {
                        hr = CO_E_PATHTOOLONG;
                        goto exit;
                    }

                    _fReadDone = TRUE;

                    ZeroMemory(&si, sizeof(si));
                    ZeroMemory(&pi, sizeof(pi));
                    si.cb = sizeof(si);

                    // this child process must delete the temp file....
                    if(!CreateProcess(NULL, wzCmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
                    {
                        hr = GetLastWin32Error();
                    }

                    if(pi.hThread) CloseHandle(pi.hThread);
                    if(pi.hProcess) CloseHandle(pi.hProcess);

                    // note: this few lines must follow the CreateProcess
                    if (FAILED(hr))
                        goto exit;
                }
            }
        }
    }

#ifndef SHOW_CLICKONCE_AD  
    hr = hrFromProt;
    *pcbRead = 0;
#else
    // switch the MIME type here
    // IE window stays if this is done with CONTENT_TYPE == L"text/html"!
    _pOutgoingProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, CONTENT_TYPE);

    // return customer's ad in the browser - this can be taken from a file on disk or inside the file this is read above
    // right now it's just a simple implementation
    if (_cbAdRead >= g_cbAdLen)
    {
        if (_fReadDone)
            hr = S_FALSE;
        else
            // hold till _pIncomingProt is done
            hr = S_OK;//E_PENDING;
    }
    else
    {
        ULONG cbDataAvail = g_cbAdLen-_cbAdRead;
        
        if (cb < cbDataAvail)
            cbDataAvail = cb;

        // note BYTE pointer increment not LPWSTR pointer style
        memcpy(pv, ((BYTE*)g_wzAdString)+_cbAdRead, cbDataAvail);
        _cbAdRead += cbDataAvail;
        *pcbRead = cbDataAvail;

        hr = S_OK;
    }
#endif

exit:
    _csLock->Unlock();

    return hr;
}

HRESULT
CFusionMimeFilter::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

HRESULT
CFusionMimeFilter::LockRequest(DWORD dwOptions)
{
    return S_OK;
}

HRESULT
CFusionMimeFilter::UnlockRequest()
{
    return S_OK;
}

// ----------------------------------------------------------------------------
// IInternetProtocolSink interface
HRESULT
CFusionMimeFilter::Switch(PROTOCOLDATA __RPC_FAR *pProtocolData)
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
        hr = _pOutgoingProtSink->Switch(pProtocolData);

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText)
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
        hr = _pOutgoingProtSink->ReportProgress(ulStatusCode, szStatusText);

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
        hr = _pOutgoingProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);

    _csLock->Unlock();
    return hr;
}

HRESULT
CFusionMimeFilter::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR szResult)
{
    HRESULT hr;
    _csLock->Lock();    // check return value

    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
        hr = _pOutgoingProtSink->ReportResult(hrResult, dwError, szResult);

    _csLock->Unlock();
    return hr;
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilter::OpenTempFile()
{
    HRESULT hr = S_OK;
    HANDLE hTempFile;

    static WCHAR wzTempPath[MAX_PATH+32] = {0};

    if (!wzTempPath[0])
    {
        // BUGBUG: GetTempPath can overrun the buffer?
        if (GetTempPath(MAX_PATH, wzTempPath) == 0)
        {
            hr = GetLastWin32Error();
            goto exit;
        }
    }

    if (_wzTempFile[0] == L'\0')
    {
        if (GetTempFileName(wzTempPath, L"FMA", 0, _wzTempFile))	// fusion manifest file
        {
            // the file should be deleted afterwards
            DWORD dwFileAtr = FILE_ATTRIBUTE_TEMPORARY;

            // the handling child process must delete the temp file....
            hTempFile = CreateFile(_wzTempFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, dwFileAtr, NULL);
            if (hTempFile == INVALID_HANDLE_VALUE)
            {
                _hFile = 0;
                hr = GetLastWin32Error();
                goto exit;
            }
            else
            {
                _pOutgoingProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, _wzTempFile);
                _hFile = hTempFile;
            }
        }
    }

exit:
    return hr;
}

HRESULT
CFusionMimeFilter::CloseTempFile()
{
    HRESULT hr = E_FAIL;

    if (_hFile)
    {
        CloseHandle(_hFile);
        _hFile = 0;
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\manifestgenerator.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Reflection;

namespace Microsoft.Fusion.ADF
{
	public class ManifestGenerator
	{
		private Stream appManStream, subManStream, extraXmlStream;
		private Stream appManSchema, subManSchema;

		private XmlDocument extraXmlDoc;

		private MGParamParser mgPP;

		private string sourceDir;

		public void CloseStreams()
		{
			appManStream.Close();
			subManStream.Close();
		}

		public Stream AppManStream
		{
			get
			{
				return appManStream;
			}
		}

		public Stream SubManStream
		{
			get
			{
				return subManStream;
			}
		}

		private void GenerateManifests()
		{
			// Read in extra xml; make sure it's valid
			if(this.extraXmlStream == null) this.extraXmlDoc = null;
			else
			{
				try
				{
					this.extraXmlDoc = new XmlDocument();
					this.extraXmlDoc.Load(this.extraXmlStream);
				}
				catch(XmlException xmle)
				{
					throw new XmlException("Problem with extra input XML", xmle);
				}
			}

			// Start doing work
			XmlTextReader manReader = null;
			XmlValidatingReader manValidatingReader = null;
			XmlSchemaCollection appXmlSchemaCollection = null, subXmlSchemaCollection = null;

			// Now scan manifest dependencies
			MGDepTracker mgDT = new MGDepTracker();
			DirScanner.BeginScan((IFileOperator) mgDT, sourceDir);

			try
			{
				mgDT.VerifyDependencies();
			}
			catch(MGDependencyException mgde)
			{
				throw mgde;
			}

			mgDT.CalculateSizes();

			// Write application manifest

			XmlTextWriter appGen = new XmlTextWriter(appManStream, null);
			//XmlTextWriter appGen = new XmlTextWriter(Console.Out);
			appGen.Formatting = Formatting.Indented;

			appGen.WriteStartDocument();
			appGen.WriteComment("Generated by mg v0.1 (managed)");

			appGen.WriteStartElement("assembly");
			appGen.WriteAttributeString("xmlns", "asm_namespace_v1", null, "urn:schemas-microsoft-com:asm.v1");
			appGen.WriteAttributeString("manifestVersion", "1.0");

			//MGTemplateWriter.XmlOutput(appGen, mgPR.AppKeyValPairs, mgPR.DescriptionStr);
			mgPP.WriteAppParams(appGen);

			mgDT.FileXmlOutput(appGen);

			appGen.WriteStartElement("dependency");
			mgDT.AssmXmlOutput(appGen);

			//MGPlatformWriter.XmlOutput(appGen);
			mgPP.WritePlatParams(appGen);

			appGen.WriteEndElement(); // dependency

			appGen.WriteEndElement(); // assembly

			appGen.WriteEndDocument();
			appGen.Flush();
			appManStream.Position = 0;

			// Verify application manifest

			appXmlSchemaCollection = new XmlSchemaCollection();
			appXmlSchemaCollection.Add(null , new XmlTextReader(appManSchema));

			manReader = new XmlTextReader(appManStream);
			manValidatingReader = new XmlValidatingReader(manReader);
			manValidatingReader.Schemas.Add(appXmlSchemaCollection);
			manValidatingReader.ValidationType = ValidationType.Schema;
			XmlDocument appManifest = new XmlDocument();

			try
			{
				appManifest.Load(manValidatingReader);
			}
			catch (XmlSchemaException xmlse)
			{
				// Validation error
				throw new XmlException("Error validating final application manifest; check parameters", xmlse);
			}

			appManStream.Close();

			if(extraXmlDoc != null)
			{
				XmlNode extraCopy = appManifest.ImportNode(extraXmlDoc.DocumentElement, true);
				appManifest.DocumentElement.AppendChild(extraCopy);
			}

			appManStream = new BufferedStream(new MemoryStream());
			appManifest.Save(appManStream);

			appManStream.Position = 0;

			// Write subscription manifest

			XmlTextWriter subGen = new XmlTextWriter(subManStream, null);
			subGen.Formatting = Formatting.Indented;

			subGen.WriteStartDocument();
			subGen.WriteComment("Generated by mg v0.1 (managed)");
			subGen.WriteStartElement("assembly");
			subGen.WriteAttributeString("xmlns", "asm_namespace_v1", null, "urn:schemas-microsoft-com:asm.v1");
			subGen.WriteAttributeString("manifestVersion", "1.0");

			//MGSubManifestWriter.XmlOutput(subGen, mgPR.AppKeyValPairs, mgPR.SubKeyValPairs, mgPR.DescriptionStr);
			mgPP.WriteSubParams(subGen);

			subGen.WriteEndElement();
			subGen.WriteEndDocument();
			subGen.Flush();
			subManStream.Position = 0;

			// Verify subscription manifest

			subXmlSchemaCollection = new XmlSchemaCollection();
			subXmlSchemaCollection.Add(null , new XmlTextReader(subManSchema));

			manReader = new XmlTextReader(subManStream);
			manValidatingReader = new XmlValidatingReader(manReader);
			manValidatingReader.Schemas.Add(subXmlSchemaCollection);
			manValidatingReader.ValidationType = ValidationType.Schema;

			try
			{
				while(manValidatingReader.Read());
			}
			catch (XmlSchemaException xmlse)
			{
				// Validation error
				throw new XmlException("Error validating final subscription manifest; check parameters", xmlse);
			}
			subManStream.Position = 0;
		}

		public ManifestGenerator(string sourceDir, Stream paramStream, Stream extraXmlStream)
		{
			MGParamParser tempMGPP;

			// Check for null arguments
			if(sourceDir == null) throw new ArgumentNullException("Source directory (arg 1) is null.");
			if(paramStream == null) throw new ArgumentNullException("Parameter stream (arg 2) is null.");

			// Check that paths and files are valid
			if(!Directory.Exists(sourceDir)) throw new ArgumentException("Source directory " + sourceDir + " does not exist.");
 
			this.appManStream = new BufferedStream(new MemoryStream());
			this.subManStream = new BufferedStream(new MemoryStream());

			// Get the schemas from the assembly as resource streams
			Assembly thisAssm = Assembly.GetExecutingAssembly();
			this.appManSchema = thisAssm.GetManifestResourceStream("appManSchema");
			this.subManSchema = thisAssm.GetManifestResourceStream("subManSchema");

			this.sourceDir = sourceDir;
			this.extraXmlStream = extraXmlStream;

			// Read param stream
			try
			{
				this.mgPP = new MGParamParser(paramStream);
			}
			catch(MGParseErrorException mgpee)
			{
				throw mgpee;
			}

			GenerateManifests();
		}
		
		public ManifestGenerator(string sourceDir, MGParamParser mgPP, Stream extraXmlStream)
		{
			// Check for null arguments
			if(sourceDir == null) throw new ArgumentNullException("Source directory (arg 1) is null.");
			if(mgPP == null) throw new ArgumentNullException("Parameter object (arg 2) is null.");

			// Check that paths and files are valid
			if(!Directory.Exists(sourceDir)) throw new ArgumentException("Source directory " + sourceDir + " does not exist.");

			this.appManStream = new BufferedStream(new MemoryStream());
			this.subManStream = new BufferedStream(new MemoryStream());

			// Get the schemas from the assembly as resource streams
			Assembly thisAssm = Assembly.GetExecutingAssembly();
			this.appManSchema = thisAssm.GetManifestResourceStream("appManSchema");
			this.subManSchema = thisAssm.GetManifestResourceStream("subManSchema");

			this.sourceDir = sourceDir;
			this.extraXmlStream = extraXmlStream;

			this.mgPP = mgPP;

			GenerateManifests();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgparseerrorexception.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	public class MGParseErrorException : ApplicationException
	{

		public MGParseErrorException() : base()
		{
		}

		public MGParseErrorException(string errorMsg) : base(errorMsg)
		{
		}

		public MGParseErrorException(string errorMsg, Exception e) : base(errorMsg, e)
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgfilecopier.cs ===
using System;
using System.IO;

namespace Microsoft.Fusion.ADF
{

	public class MGFileCopier : IFileOperator
	{
		private string targetDir;

		public MGFileCopier(string targetDir)
		{
			this.targetDir = Path.GetFullPath(targetDir);
		}

		void IFileOperator.ProcessDirectory(string startDir, string relPathDir)
		{
			// create the directory
			string currAbsPath = Path.Combine(targetDir, relPathDir);
			if(!Directory.Exists(currAbsPath)) Directory.CreateDirectory(currAbsPath);
		}

		void IFileOperator.ProcessFile(string startDir, string relPathDir, string fileName)
		{
			// copy the file
			string relPath = Path.Combine(relPathDir, fileName);
			string sourceAbsPath = Path.Combine(startDir, relPath);
			string targetAbsPath = Path.Combine(targetDir, relPath);

			try
			{
				if(!File.Exists(targetAbsPath)) File.Copy(sourceAbsPath, targetAbsPath);
			}
			catch(Exception e)
			{
				Console.WriteLine("Exception " + e.ToString());
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgdeptracker.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Security.Cryptography;
using System.Xml;

namespace Microsoft.Fusion.ADF 
{

	public class MGDepTracker : IFileOperator
	{
		static string MSKEY1 = "b77a5c561934e089";
		static string MSKEY2 = "b03f5f7f11d50a3a";
		static string AVALONKEY = "a29c01bbd4e39ac5";
		Hashtable fileTable;
		ArrayList appAssms, appModules;

		public MGDepTracker()
		{
			fileTable = new Hashtable();
			appAssms = new ArrayList();
			appModules = new ArrayList();
		}

		/*
		public static byte[] ComputePublicKeyHash(byte[] data)
		{
			SHA1 sha = new SHA1Managed();
			byte[] result = sha.ComputeHash(data);
			return result;
		}
		*/

		public static string ComputeFileHash(FileInfo fInf)
		{
			SHA1 sha = new SHA1Managed();
			byte[] byteHash = sha.ComputeHash(fInf.OpenRead());
			return Util.ByteArrToString(byteHash, null);
		}

		public static bool IsPlatform(string key)
		{
			bool retVal = false;

			if(key == null) return false;
			if(key.ToLower().Equals(MSKEY1) || key.ToLower().Equals(MSKEY2) || key.ToLower().Equals(AVALONKEY)) retVal = true;
			return retVal;
		}

		public void DumpData() 
		{
			foreach(Object obj in appAssms)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				Console.WriteLine("Assembly " + tempNode.assmName + "; version " + tempNode.nVers);
				if(!tempNode.isConfNode) Console.WriteLine("\tThis assembly is referenced by " + tempNode.depAssmName + " but isn't there");
				Console.WriteLine("Size: " + tempNode.size + "; Total Size: " + tempNode.totalSize);
			}
			Console.WriteLine();
			foreach(Object obj in appModules)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				Console.WriteLine("File " + tempNode.installPath + "; depends on " + tempNode.depAssmName);
				Console.WriteLine("Size: " + tempNode.size);
			}
		}

		public void VerifyDependencies()
		{
			foreach(Object obj in appAssms)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				if(!tempNode.isConfNode)
					throw new MGDependencyException(tempNode.assmName + ", dependency of " + tempNode.depAssmName + ", is missing.");
			}
			foreach(Object obj in appModules)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				if(!tempNode.isConfNode)
					throw new MGDependencyException(tempNode.installPath + ", dependency of " + tempNode.depAssmName + ", is missing.");
			}
		}

		public void CalculateSizes()
		{
			foreach(Object obj in appAssms)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				tempNode.totalSize = tempNode.size;
			}
			foreach(Object obj in appModules)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				if(!tempNode.depAssmKey.Equals(""))
				{
					MGTrackerNode tempNode2 = (MGTrackerNode) fileTable[tempNode.depAssmKey];
					tempNode2.totalSize += tempNode.size;
				}
			}
		}

		public void FileXmlOutput(XmlTextWriter xtw)
		{
			foreach(Object obj in appModules)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				if(tempNode.depAssmKey.Equals("")) 
				{
					xtw.WriteStartElement("file");
					xtw.WriteAttributeString("name", tempNode.installPath);
					xtw.WriteAttributeString("hash", tempNode.calcHashCode);
					xtw.WriteAttributeString("size", tempNode.size.ToString());
					xtw.WriteEndElement();
				}
			}
		}

		public void AssmXmlOutput(XmlTextWriter xtw) // this is always inside a dependency block
		{
			foreach(Object obj in appAssms)
			{
				MGTrackerNode tempNode = (MGTrackerNode) obj;
				xtw.WriteStartElement("dependentAssembly");
				xtw.WriteStartElement("assemblyIdentity");
				xtw.WriteAttributeString("name", tempNode.assmName);
				xtw.WriteAttributeString("version", tempNode.nVers.ToString());
				xtw.WriteAttributeString("publicKeyToken", tempNode.publicKeyToken);
				xtw.WriteAttributeString("processorArchitecture", tempNode.procArch);
				xtw.WriteAttributeString("language", tempNode.lang);
				xtw.WriteEndElement();
				xtw.WriteStartElement("install");
				xtw.WriteAttributeString("codebase", tempNode.installPath);
				xtw.WriteAttributeString("size", tempNode.totalSize.ToString());
				xtw.WriteEndElement();
				xtw.WriteEndElement();
			}
		}


		void IFileOperator.ProcessDirectory(string startDir, string relPathDir)
		{
			// doesn't do anything here
		}

		void IFileOperator.ProcessFile(string startDir, string relPathDir, string fileName)
		{
			IAssemblyManifestImport currAssm = null;
			AssemblyIdentity assmID = null;
			DependentAssemblyInfo[] depAssmInfoArr = null;
			DependentFileInfo[] depFileInfoArr = null;
			MGTrackerNode tempNode;

			string relPath = Path.Combine(relPathDir, fileName);
			string absPath = Path.Combine(startDir, relPath);
			FileInfo fInf = new FileInfo(absPath);
			//Console.Write("Processing " + absPath + "... ");

			try 
			{
				currAssm = DefaultAssemblyManifestImporter.GetAssemblyManifestImport(absPath);
				assmID = currAssm.GetAssemblyIdentity();
				depAssmInfoArr = currAssm.GetDependentAssemblyInfo();
				depFileInfoArr = currAssm.GetDependentFileInfo();
			}
			catch (BadImageFormatException bife)
			{
				// This file is a module; update hash table
				tempNode = (MGTrackerNode) fileTable[relPath];
				if(tempNode == null)
				{
					tempNode = new MGTrackerNode();
					fileTable[relPath] = tempNode;
					tempNode.hashKey = relPath;
					tempNode.installPath = relPath;
					appModules.Add(tempNode);
				}
				tempNode.isConfNode = true;
				tempNode.calcHashCode = ComputeFileHash(fInf);
				tempNode.size = fInf.Length;
				// Finished updating module entry
			}

			if(currAssm != null)
			{
				// This file is an assembly; update hash table
				if(!IsPlatform(assmID.PublicKeyTokenString)) // completely ignore if it's part of a platform
				{
					tempNode = (MGTrackerNode) fileTable[assmID.FullName];
					if(tempNode == null) 
					{
						tempNode = new MGTrackerNode();
						fileTable[assmID.FullName] = tempNode;
						tempNode.hashKey = assmID.FullName;
						tempNode.assmName = assmID.Name;
						tempNode.isAssm = true;
						tempNode.nVers = assmID.Vers;
						tempNode.publicKeyToken = assmID.PublicKeyTokenString;
						appAssms.Add(tempNode);
					}
					tempNode.isConfNode = true;
					tempNode.installPath = relPath;
					tempNode.size = fInf.Length;
					// Finished updating assembly entry

					// Now we process assembly dependencies
					//depAssmInfoArr = currAssm.GetDependentAssemblyInfo();
					foreach(DependentAssemblyInfo depAssmInfo in depAssmInfoArr)
					{
						AssemblyIdentity depAssmID = depAssmInfo.AssmID;
						if(!IsPlatform(depAssmID.PublicKeyTokenString)) // maybe call this "IsPlatform", "CheckPlatform"
						{
							tempNode = (MGTrackerNode) fileTable[depAssmID.FullName];
							if(tempNode == null)
							{
								tempNode = new MGTrackerNode();
								fileTable[depAssmID.FullName] = tempNode;
								tempNode.hashKey = depAssmID.FullName;
								tempNode.assmName = depAssmID.Name;
								tempNode.isAssm = true;
								tempNode.nVers = depAssmID.Vers;
								tempNode.publicKeyToken = depAssmID.PublicKeyTokenString;
								appAssms.Add(tempNode);
							}
							tempNode.depAssmKey = assmID.FullName;
							tempNode.depAssmName = assmID.Name;
						}
					}
					// Done with assembly dependencies

					// Now we process file dependencies
					//depFileInfoArr = currAssm.GetDependentFileInfo();
					foreach(DependentFileInfo depFileInfo in depFileInfoArr)
					{
						// For the hashtable, we actually need the relative path from the application root to the file,
						// because we want this file entry's hash key to match the file entry that is obtained by discovering
						// the actual location of the file
						string fileHashKey = Path.Combine(relPathDir, depFileInfo.Name);
						tempNode = (MGTrackerNode) fileTable[fileHashKey];
						if(tempNode == null)
						{
							tempNode = new MGTrackerNode();
							fileTable[fileHashKey] = tempNode;
							tempNode.hashKey = fileHashKey;
							tempNode.installPath = fileHashKey;
							appModules.Add(tempNode);
						}
						tempNode.depAssmKey = assmID.FullName;
						tempNode.depAssmName = assmID.Name;
					}
					// Done with file dependencies
				}
			}
			//Console.WriteLine("done");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgtrackernode.cs ===
using System;

namespace Microsoft.Fusion.ADF
{
	public class MGTrackerNode
	{

		public string hashKey;
		public string assmName;
		public string depAssmKey;
		public string depAssmName;
		public bool isAssm;
		public bool isConfNode;
		public string installPath;
		public Version nVers;
		public string publicKeyToken;
		public string procArch;
		public string lang;
		public string hashCode;
		public string calcHashCode;
		public long size;
		public long totalSize;

		public MGTrackerNode() 
		{
			hashKey = "";
			assmName = "";
			depAssmKey = "";
			depAssmName = "";
			isAssm = false;
			isConfNode = false;
			installPath = "";
			nVers = null;
			publicKeyToken = "";
			procArch = "x86";
			lang = "x-ww";
			hashCode = "";
			calcHashCode = "";
			size = 0;
			totalSize = 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgplatformwriter.cs ===
using System;
using System.Xml;
using System.Collections;
using System.IO;

namespace Microsoft.Fusion.ADF
{
	public class MGPlatformWriter
	{
		public static void XmlOutput(XmlTextWriter xtw) // this is always insisde a dependency block
		{
			xtw.WriteStartElement("platform");

			xtw.WriteStartElement("osVersionInfo");

			xtw.WriteStartElement("os");
			xtw.WriteAttributeString("majorVersion", "5");
			xtw.WriteAttributeString("minorVersion", "1");
			xtw.WriteAttributeString("buildNumber", "2600");
			xtw.WriteAttributeString("servicePackMajor", "0");
			xtw.WriteAttributeString("servicePackMinor", "0");
			xtw.WriteEndElement(); // os

			xtw.WriteEndElement(); // osVersionInfo

			xtw.WriteStartElement("platformInfo");
			xtw.WriteAttributeString("friendlyName", "Microsoft Windows XP");
			xtw.WriteAttributeString("href", "http://windows.microsoft.com");
			xtw.WriteEndElement(); // platformInfo

			xtw.WriteEndElement(); // platform

			xtw.WriteStartElement("platform");

			xtw.WriteStartElement("dotNetVersionInfo");

			xtw.WriteStartElement("supportedRuntime");
			xtw.WriteAttributeString("version", "v1.0.3705");
			xtw.WriteEndElement(); // supportedRuntime

			xtw.WriteEndElement(); // dotNetVersionInfo

			xtw.WriteStartElement("platformInfo");
			xtw.WriteAttributeString("friendlyName", "Microsoft .Net Frameworks redist");
			xtw.WriteAttributeString("href", "http://www.microsoft.com/net");
			xtw.WriteEndElement(); // platformInfo

			xtw.WriteEndElement(); // platform
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\mgparamparser.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Reflection;

namespace Microsoft.Fusion.ADF
{
	// 07/18/02: DON'T DO THE EXTRA WORK THAT INPUT SCHEMA ALREADY DOES FOR YOU

	public class MGParamParser
	{
		private Stream xmlInput;
		private XmlDocument paramInput;
		private string appName;
		private XmlNode assmIDNode = null, descNode = null, appNode = null, subNode = null, platNode = null;
		private XmlNode appAssmIDNode, subAssmIDNode;

		public MGParamParser(Stream xmlInput)
		{
			this.xmlInput = xmlInput;
			try
			{
				XmlNodeList temp;
				IEnumerator nodeEnum;

				// Make document out of stream

				// Begin by adding schema
				Assembly thisAssm = Assembly.GetExecutingAssembly();
				Stream xmlInputSchema = thisAssm.GetManifestResourceStream("inputSchema");
				XmlSchemaCollection myXmlSchemaCollection = new XmlSchemaCollection();
				myXmlSchemaCollection.Add(null , new XmlTextReader(xmlInputSchema));

				// Then validate file (validation fills in defaults)
				XmlTextReader myXmlTextReader = new XmlTextReader(xmlInput);
				XmlValidatingReader myXmlValidatingReader = new XmlValidatingReader(myXmlTextReader);
				myXmlValidatingReader.Schemas.Add(myXmlSchemaCollection);
				myXmlValidatingReader.ValidationType = ValidationType.Schema;

				this.paramInput = new XmlDocument();
				paramInput.Load(myXmlValidatingReader);

				// Extract nodes we care about
				temp = paramInput.GetElementsByTagName("assemblyIdentity");
				if(temp.Count != 1) throw new MGParseErrorException("XML parameters should only have 1 assemblyIdentity element");
				else
				{
					nodeEnum = temp.GetEnumerator();
					nodeEnum.MoveNext();
					assmIDNode = (XmlNode) nodeEnum.Current;
				}

				temp = paramInput.GetElementsByTagName("description");
				if(temp.Count != 1) throw new MGParseErrorException("XML parameters should only have 1 description element");
				else
				{
					nodeEnum = temp.GetEnumerator();
					nodeEnum.MoveNext();
					descNode = (XmlNode) nodeEnum.Current;
				}

				temp = paramInput.GetElementsByTagName("applicationParams");
				if(temp.Count != 1) throw new MGParseErrorException("XML parameters should only have 1 applicationParams element");
				else
				{
					nodeEnum = temp.GetEnumerator();
					nodeEnum.MoveNext();
					appNode = (XmlNode) nodeEnum.Current;
				}

				temp = paramInput.GetElementsByTagName("subscriptionParams");
				if(temp.Count != 1) throw new MGParseErrorException("XML parameters should only have 1 subscriptionParams element");
				else
				{
					nodeEnum = temp.GetEnumerator();
					nodeEnum.MoveNext();
					subNode = (XmlNode) nodeEnum.Current;
				}

				temp = paramInput.GetElementsByTagName("platformParams");
				if(temp.Count > 1) throw new MGParseErrorException("XML parameters should have at most 1 platformParams element");
				else if(temp.Count == 1)
				{
					nodeEnum = temp.GetEnumerator();
					nodeEnum.MoveNext();
					platNode = (XmlNode) nodeEnum.Current;
				}

				// Extract application name
				appName = assmIDNode.Attributes["name"].Value;

				// Set up specialized assembly ID nodes
				appAssmIDNode = assmIDNode.Clone();
				subAssmIDNode = assmIDNode.Clone();

				XmlAttribute typeAttr1 = paramInput.CreateAttribute("type");
				XmlAttribute typeAttr2 = (XmlAttribute) typeAttr1.CloneNode(true);
				typeAttr1.Value = "application";
				appAssmIDNode.Attributes.Prepend(typeAttr1);
				typeAttr2.Value = "subscription";
				subAssmIDNode.Attributes.Prepend(typeAttr2);
			}
			catch (XmlException xmle)
			{
				throw new MGParseErrorException("XML parameter parsing failed", xmle);
			}
			catch (XmlSchemaException xmlse)
			{
				throw new MGParseErrorException("XML parameter validation failed", xmlse);
			}
		}

		public string AppName
		{
			get
			{
				return appName;
			}
		}

		// USE WRITE, WRITETO, OUTERXML, OTHER STUFF FROM .NET APIS INSTEAD OF INJECTNODE UTILITY

		public void WriteAppParams(XmlTextWriter xtw)
		{
			try
			{
				Util.InjectNode(appAssmIDNode, xtw, true, true);
				Util.InjectNode(descNode, xtw, true, true);
				Util.InjectNode(appNode, xtw, false, false);
			}
			catch (XmlException xmle)
			{
				throw new MGParseErrorException("XML parameter parsing failed", xmle);
			}
		}

		public void WriteSubParams(XmlTextWriter xtw)
		{
			try
			{
				Util.InjectNode(subAssmIDNode, xtw, true, true);
				Util.InjectNode(descNode, xtw, true, true);
				xtw.WriteStartElement("dependency");
				xtw.WriteStartElement("dependentAssembly");
				Util.InjectNode(appAssmIDNode, xtw, true, true);

				// The following is to ensure that filenames match everywhere; I may take it out
				XmlNodeList temp = subNode.SelectNodes("//install");
				IEnumerator tempEnum = temp.GetEnumerator();
				tempEnum.MoveNext();
				string tempCodebase = ((XmlNode) tempEnum.Current).Attributes["codebase"].Value;
				tempCodebase = tempCodebase.Substring(0, tempCodebase.LastIndexOf('/') + 1);
				if(!tempCodebase.Equals("")) ((XmlNode) tempEnum.Current).Attributes["codebase"].Value = String.Concat(tempCodebase, appName + ".manifest");
				Util.InjectNode(subNode, xtw, false, false);
				xtw.WriteEndElement();
				xtw.WriteEndElement();
			}
			catch (XmlException xmle)
			{
				throw new MGParseErrorException("XML parameter parsing failed", xmle);
			}
		}

		public void WritePlatParams(XmlTextWriter xtw)
		{
			try
			{
				if(platNode != null) Util.InjectNode(platNode, xtw, false, false);
				else MGPlatformWriter.XmlOutput(xtw); // write defaults
			}
			catch (XmlException xmle)
			{
				throw new MGParseErrorException("XML parameter parsing failed", xmle);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\manifest\manifestdata.cpp ===
#include <fusenetincludes.h>
#include <manifestdata.h>

// special key for data type
LPCWSTR pcwzManifestDataType = L"_t";

#define DATA_TABLE_ARRAY_SIZE 0x08

// ---------------------------------------------------------------------------
// CManifestDataObject ctor
// ---------------------------------------------------------------------------
CManifestDataObject::CManifestDataObject()
    :  _dwSig('JBOD'), _hr(S_OK),  _dwType(MAN_DATA_TYPE_UNDEF),
    _pIUnknownData(NULL), _dwData(0)
{
}

// ---------------------------------------------------------------------------
// CManifestDataObject dtor
// ---------------------------------------------------------------------------
CManifestDataObject::~CManifestDataObject()
{
    if (_dwType == MAN_DATA_TYPE_IUNKNOWN_PTR)
        SAFERELEASE(_pIUnknownData);
}

// ISSUE not support remove property
// no this Property CPropertyArray::operator [] (DWORD PropertyId)
// probably not the best for iunknown* or DWORD properties
// no need to SAFEDELETEARRAY for bool/dword types
// work slightly differently if setting IUnknown* (pass (LPVOID) pUnkwn)

// ---------------------------------------------------------------------------
// CManifestDataObject::Set
// ---------------------------------------------------------------------------
HRESULT CManifestDataObject::Set(LPVOID pvProperty, DWORD cbProperty, DWORD dwType)
{
    _dwType = MAN_DATA_TYPE_UNDEF;
    SAFERELEASE(_pIUnknownData);

    if (dwType == MAN_DATA_TYPE_LPWSTR)
    {
        DWORD dwLen = cbProperty/sizeof(WCHAR);
        IF_FALSE_EXIT(dwLen >= 1, E_INVALIDARG);
        IF_FALSE_EXIT(((LPCWSTR)pvProperty)[dwLen-1] == L'\0', E_INVALIDARG);
        IF_FAILED_EXIT(_sData.Assign(((LPCWSTR)pvProperty), dwLen));
    }
    else if (dwType == MAN_DATA_TYPE_IUNKNOWN_PTR)
    {
        IF_FALSE_EXIT(cbProperty == sizeof(LPVOID), E_INVALIDARG);
        _pIUnknownData = (IUnknown*) pvProperty;
        _pIUnknownData->AddRef();
    }
    else if (dwType == MAN_DATA_TYPE_DWORD 
        || dwType == MAN_DATA_TYPE_ENUM)
    {
        _dwData = *((LPDWORD)pvProperty);
    }
    else if (dwType == MAN_DATA_TYPE_BOOL)
    {
        _dwData = *((LPBOOL)pvProperty);
    }
    else
    {
        IF_FAILED_EXIT(E_INVALIDARG);
    }

    _dwType = dwType;
    _hr = S_OK;

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// CManifestDataObject::Get
// ---------------------------------------------------------------------------
HRESULT CManifestDataObject::Get(LPVOID *ppvProperty, DWORD *pcbProperty, DWORD *pdwType)
{
    if (_dwType == MAN_DATA_TYPE_LPWSTR)
    {
        CString sValue;
        IF_FAILED_EXIT(sValue.Assign(_sData));
        IF_FAILED_EXIT(sValue.ReleaseOwnership((LPWSTR*)ppvProperty));
        *pcbProperty = sValue.ByteCount();
    }
    else if (_dwType == MAN_DATA_TYPE_IUNKNOWN_PTR)
    {
        *ppvProperty = _pIUnknownData;
        *pcbProperty = sizeof(IUnknown*);
        _pIUnknownData->AddRef();
    }
    else if (_dwType == MAN_DATA_TYPE_BOOL)
    {
        BOOL *pbData = NULL;
        IF_ALLOC_FAILED_EXIT(pbData = new BOOL);
        *pbData = _dwData;
        *ppvProperty = pbData;
        *pcbProperty = sizeof(BOOL);
    }
    else if (_dwType == MAN_DATA_TYPE_DWORD || _dwType == MAN_DATA_TYPE_ENUM)
    {
        DWORD *pdwData = NULL;
        IF_ALLOC_FAILED_EXIT(pdwData = new DWORD);
        *pdwData = _dwData;
        *ppvProperty = pdwData;
        *pcbProperty = sizeof(DWORD);
    }
    else
    {
        IF_FAILED_EXIT(E_FAIL);
    }

    *pdwType = _dwType;
    _hr = S_OK;

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// CManifestDataObject::Assign
// ---------------------------------------------------------------------------
HRESULT CManifestDataObject::Assign(CManifestDataObject& dataObj)
{
    if (_dwType == MAN_DATA_TYPE_IUNKNOWN_PTR)
        SAFERELEASE(_pIUnknownData);

    _sData.FreeBuffer();
    if (dataObj._sData.CharCount() != 0)
        IF_FAILED_EXIT(_sData.Assign(dataObj._sData));

    _pIUnknownData = dataObj._pIUnknownData;
    if (_pIUnknownData)
        _pIUnknownData->AddRef();

    _dwData = dataObj._dwData;

    _dwType = dataObj._dwType;
    _hr = S_OK;

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// CreateManifestData
// ---------------------------------------------------------------------------
STDAPI CreateManifestData(LPCWSTR pwzDataType, LPMANIFEST_DATA* ppManifestData)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD dwLen = 0;

    CManifestData *pManifestData = NULL;

    IF_ALLOC_FAILED_EXIT(pManifestData = new(CManifestData));

    IF_FAILED_EXIT(pManifestData->Init());

    dwLen = lstrlen(pwzDataType);
    IF_FALSE_EXIT(dwLen < dwLen+1, HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));
    dwLen++;

    IF_FAILED_EXIT(pManifestData->Set(pcwzManifestDataType, (LPVOID)pwzDataType, dwLen*sizeof(WCHAR), MAN_DATA_TYPE_LPWSTR));

    *ppManifestData = static_cast<IManifestData*> (pManifestData);
    pManifestData = NULL;

exit:

    SAFERELEASE(pManifestData);
    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CManifestData::CManifestData()
    : _dwSig('DNAM'), _cRef(1), _hr(S_OK)
{    
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CManifestData::~CManifestData()
{
}

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CManifestData::Init()
{
    _hr = _DataTable.Init(DATA_TABLE_ARRAY_SIZE);
    return _hr;
}


// ---------------------------------------------------------------------------
// Set
// ---------------------------------------------------------------------------
HRESULT CManifestData::Set(LPCWSTR pwzPropertyId, LPVOID pvProperty, DWORD cbProperty, DWORD dwType)
{
    CString sId;
    CManifestDataObject DataObj;

    IF_NULL_EXIT(pvProperty, E_INVALIDARG);
    IF_FALSE_EXIT(cbProperty>0, E_INVALIDARG);
    IF_FALSE_EXIT(dwType<MAN_DATA_TYPE_MAX, E_INVALIDARG);

    IF_NULL_EXIT(pwzPropertyId, E_INVALIDARG);
    IF_FAILED_EXIT(sId.Assign((LPWSTR)pwzPropertyId));

    IF_FAILED_EXIT(DataObj.Set(pvProperty, cbProperty, dwType));

    IF_FAILED_EXIT(_DataTable.Insert(sId, DataObj));

exit:
    return _hr;
}

// ---------------------------------------------------------------------------
// Get
// ---------------------------------------------------------------------------
HRESULT CManifestData::Get(LPCWSTR pwzPropertyId, LPVOID *ppvProperty, DWORD *pcbProperty, DWORD *pdwType)
{
    CString sId;
    CManifestDataObject* pDataObj = NULL;

    IF_NULL_EXIT(ppvProperty, E_INVALIDARG);
    *ppvProperty = NULL;
    IF_NULL_EXIT(pcbProperty, E_INVALIDARG);
    *pcbProperty = 0;
    IF_NULL_EXIT(pdwType, E_INVALIDARG);
    *pdwType = MAN_DATA_TYPE_UNDEF;

    IF_NULL_EXIT(pwzPropertyId, E_INVALIDARG);
    IF_FAILED_EXIT(sId.Assign((LPWSTR) pwzPropertyId));

    IF_FAILED_EXIT(_DataTable.Retrieve(sId, &pDataObj));

    if (_hr == S_OK)
    {
        IF_FAILED_EXIT(pDataObj->Get(ppvProperty, pcbProperty, pdwType));
    }
    else
        _hr = S_OK; // if not found, return *ppvProperty == NULL

exit:

    return _hr;
}

// ---------------------------------------------------------------------------
// Set
// ---------------------------------------------------------------------------
HRESULT CManifestData::Set(DWORD dwPropertyIndex, LPVOID pvProperty, DWORD cbProperty, DWORD dwType)
{
    // indexed insert - note: this is not as optimizied as a normal array would, due to the use of CStrings as keys
    CString sId;
    WCHAR wzId[3] = {L'\0', L'\0', L'\0'};
    CManifestDataObject DataObj;

    IF_NULL_EXIT(pvProperty, E_INVALIDARG);
    IF_FALSE_EXIT(cbProperty>0, E_INVALIDARG);
    IF_FALSE_EXIT(dwType<MAN_DATA_TYPE_MAX, E_INVALIDARG);

    wzId[0] = LOWORD(dwPropertyIndex);
    wzId[1] = HIWORD(dwPropertyIndex);
    IF_FAILED_EXIT(sId.Assign(wzId));

    IF_FAILED_EXIT(DataObj.Set(pvProperty, cbProperty, dwType));

    IF_FAILED_EXIT(_DataTable.Insert(sId, DataObj));

exit:
    return _hr;
}

// ---------------------------------------------------------------------------
// Get
// ---------------------------------------------------------------------------
HRESULT CManifestData::Get(DWORD dwPropertyIndex, LPVOID *ppvProperty, DWORD *pcbProperty, DWORD *pdwType)
{
    // indexed retrieve
    CString sId;
    WCHAR wzId[3] = {L'\0', L'\0', L'\0'};
    CManifestDataObject* pDataObj = NULL;

    IF_NULL_EXIT(ppvProperty, E_INVALIDARG);
    *ppvProperty = NULL;
    IF_NULL_EXIT(pcbProperty, E_INVALIDARG);
    *pcbProperty = 0;
    IF_NULL_EXIT(pdwType, E_INVALIDARG);
    *pdwType = MAN_DATA_TYPE_UNDEF;

    wzId[0] = LOWORD(dwPropertyIndex);
    wzId[1] = HIWORD(dwPropertyIndex);
    IF_FAILED_EXIT(sId.Assign(wzId));

    IF_FAILED_EXIT(_DataTable.Retrieve(sId, &pDataObj));

    if (_hr == S_OK)
    {
        IF_FAILED_EXIT(pDataObj->Get(ppvProperty, pcbProperty, pdwType));
    }
    else
        _hr = S_OK; // if not found, return *ppvProperty == NULL

exit:

    return _hr;
}

// ---------------------------------------------------------------------------
// GetType
// ---------------------------------------------------------------------------
HRESULT CManifestData::GetType(LPWSTR *ppwzType)
{
    DWORD cbProperty = 0;
    DWORD dwType = 0;
    IF_FAILED_EXIT(Get(pcwzManifestDataType, (LPVOID*) ppwzType, &cbProperty, &dwType));
    IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_LPWSTR, E_FAIL);

exit:
    return _hr;
}


// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CManifestData::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CManifestData::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IManifestData)
       )
    {
        *ppvObj = static_cast<IManifestData*> (this);
        AddRef();
        _hr =  S_OK;
    }
    else
    {
        *ppvObj = NULL;
        _hr = E_NOINTERFACE;
    }
    return _hr;
}

// ---------------------------------------------------------------------------
// CManifestData::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CManifestData::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CManifestData::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CManifestData::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\manifest\manifestimport.cpp ===
#include <fusenetincludes.h>
#include <manifestimport.h>
#include <manifestimportclr.h>
#ifdef CONTAINER
#include <manifestimportcontainer.h>
#endif
#include <sxsapi.h>
#include <manifestdata.h>
#include "dbglog.h"

#define WZ_NAMESPACES              L"xmlns:asm_namespace_v1='urn:schemas-microsoft-com:asm.v1'"
#define WZ_SELECTION_NAMESPACES    L"SelectionNamespaces"
#define WZ_SELECTION_LANGUAGE      L"SelectionLanguage"
#define WZ_XPATH                    L"XPath"
#define WZ_FILE_NODE                L"/assembly/file"
#define WZ_FILE_QUERYSTRING_PREFIX  L"/assembly/file[@name = \""
#define WZ_QUERYSTRING_SUFFIX  L"\"]"
#define WZ_ASSEMBLY_ID              L"/assembly/assemblyIdentity"
#define WZ_DEPENDENT_ASSEMBLY_NODE       L"/assembly/dependency/dependentAssembly/assemblyIdentity"
#define WZ_DEPENDENT_ASSEMBLY_CODEBASE  L"../install[@codebase]"
#define WZ_CODEBASE                L"codebase"
#define WZ_SHELLSTATE             L"/assembly/application/shellState"
#define WZ_ACTIVATION             L"/assembly/application/activation"
#define WZ_FILE_NAME                L"name"
#define WZ_FILE_HASH                L"hash"
#define WZ_FRIENDLYNAME             L"friendlyName"
#define WZ_ENTRYPOINT               L"entryPoint"
#define WZ_ENTRYIMAGETYPE           L"entryImageType"
#define WZ_ICONFILE                 L"iconFile"
#define WZ_ICONINDEX               L"iconIndex"
#define WZ_SHOWCOMMAND           L"showCommand"
#define WZ_HOTKEY                   L"hotKey"
#define WZ_ASSEMBLYNAME             L"assemblyName"
#define WZ_ASSEMBLYCLASS            L"assemblyClass"
#define WZ_ASSEMBLYMETHOD           L"assemblyMethod"
#define WZ_ASSEMBLYARGS             L"assemblyMethodArgs"

#define WZ_PATCH                    L"/assembly/Patch/SourceAssembly"
#define WZ_PATCHINFO                L"/PatchInfo/"
#define WZ_SOURCE                   L"source"
#define WZ_TARGET                   L"target"
#define WZ_PATCHFILE                L"patchfile"
#define WZ_ASSEMBLY_ID_TAG  L"assemblyIdentity"
#define WZ_COMPRESSED           L"compressed"
#define WZ_SUBSCRIPTION        L"/assembly/dependency/dependentAssembly/subscription"
#define WZ_SYNC_INTERVAL        L"synchronizeInterval"
#define WZ_INTERVAL_UNIT        L"intervalUnit"
#define WZ_SYNC_EVENT           L"synchronizeEvent"
#define WZ_DEMAND_CONNECTION    L"eventDemandConnection"
#define WZ_FILE L"file"
#define WZ_CAB L"cab"
#define WZ_ASSEMBLY_NODE        L"/assembly"    //BUGBUG: match assembly with xmlns and/or manifestVersion attributes for versioning
#define WZ_APPLICATION_NODE     L"/assembly/application"
#define WZ_VERSIONWILDCARD      L"*"
#define WZ_DESKTOP              L"desktop"
#define WZ_DEPENDENCY           L"dependency"
#define WZ_DEPENDENTASSEMBLY L"dependentAssembly"
#define WZ_INSTALL              L"install"
#define WZ_INSTALL_TYPE         L"type"

#define WZ_PLATFORM             L"/assembly/dependency/platform"
#define WZ_PLATFORMINFO     L"platformInfo"
#define WZ_OSVERSIONINFO    L"osVersionInfo"
#define WZ_DOTNETVERSIONINFO   L"dotNetVersionInfo"
#define WZ_HREF                         L"href"
#define WZ_OS                             L"os"
#define WZ_MAJORVERSION         L"majorVersion"
#define WZ_MINORVERSION         L"minorVersion"
#define WZ_BUILDNUMBER          L"buildNumber"
#define WZ_SERVICEPACKMAJOR L"servicePackMajor"
#define WZ_SERVICEPACKMINOR L"servicePackMinor"
#define WZ_SUITE                        L"suite"
#define WZ_PRODUCTTYPE           L"productType"
#define WZ_SUPPORTEDRUNTIME L"supportedRuntime"

#define WZ_REQUIRED             L"required"
#define WZ_MINUTES              L"minutes"
//#define WZ_HOURS                L"hours"
#define WZ_DAYS                 L"days"
#define WZ_ONAPPLICATIONSTARTUP L"onApplicationStartup"
#define WZ_YES                  L"yes"
//#define WZ_NO                   L"no"

#ifdef DEVMODE
#define WZ_DEVSYNC L"devSync"
#endif

//BUGBUG: default sync interval==6hrs; should be documented
#define DW_DEFAULT_SYNC_INTERVAL 6

#undef NUMBER_OF
#define NUMBER_OF(x) ( (sizeof(x) / sizeof(*x) ) )

#undef ENTRY
#define ENTRY(x) { x, NULL, NUMBER_OF(x) - 1 },
    
CAssemblyManifestImport::StringTableEntry CAssemblyManifestImport::g_StringTable[] = 
{    
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
    ENTRY(WZ_SELECTION_NAMESPACES)
    ENTRY(WZ_NAMESPACES)
    ENTRY(WZ_SELECTION_LANGUAGE)
    ENTRY(WZ_XPATH)
    ENTRY(WZ_FILE_NODE)
    ENTRY(WZ_FILE_NAME)
    ENTRY(WZ_FILE_HASH)
    ENTRY(WZ_ASSEMBLY_ID)
    ENTRY(WZ_DEPENDENT_ASSEMBLY_NODE)
    ENTRY(WZ_DEPENDENT_ASSEMBLY_CODEBASE)
    ENTRY(WZ_CODEBASE)
    ENTRY(WZ_SHELLSTATE)
    ENTRY(WZ_FRIENDLYNAME)
    ENTRY(WZ_ENTRYPOINT)
    ENTRY(WZ_ENTRYIMAGETYPE)
    ENTRY(WZ_ICONFILE)
    ENTRY(WZ_ICONINDEX)
    ENTRY(WZ_SHOWCOMMAND)
    ENTRY(WZ_HOTKEY)
    ENTRY(WZ_ACTIVATION)
    ENTRY(WZ_ASSEMBLYNAME)
    ENTRY(WZ_ASSEMBLYCLASS)
    ENTRY(WZ_ASSEMBLYMETHOD)
    ENTRY(WZ_ASSEMBLYARGS)
    ENTRY(WZ_PATCH)
    ENTRY(WZ_PATCHINFO)
    ENTRY(WZ_SOURCE)
    ENTRY(WZ_TARGET)
    ENTRY(WZ_PATCHFILE)
    ENTRY(WZ_ASSEMBLY_ID_TAG)
    ENTRY(WZ_COMPRESSED)
    ENTRY(WZ_SUBSCRIPTION)
    ENTRY(WZ_SYNC_INTERVAL)
    ENTRY(WZ_INTERVAL_UNIT)
    ENTRY(WZ_SYNC_EVENT)
    ENTRY(WZ_DEMAND_CONNECTION)
    ENTRY(WZ_FILE)
    ENTRY(WZ_CAB)
    ENTRY(WZ_ASSEMBLY_NODE)
    ENTRY(WZ_APPLICATION_NODE)
    ENTRY(WZ_VERSIONWILDCARD)
    ENTRY(WZ_DESKTOP)
    ENTRY(WZ_DEPENDENCY)
    ENTRY(WZ_DEPENDENTASSEMBLY)
    ENTRY(WZ_INSTALL)
    ENTRY(WZ_INSTALL_TYPE)
    ENTRY(WZ_PLATFORM)
    ENTRY(WZ_PLATFORMINFO)
    ENTRY(WZ_OSVERSIONINFO)
    ENTRY(WZ_DOTNETVERSIONINFO)
    ENTRY(WZ_HREF)
    ENTRY(WZ_OS)
    ENTRY(WZ_MAJORVERSION)
    ENTRY(WZ_MINORVERSION)
    ENTRY(WZ_BUILDNUMBER)
    ENTRY(WZ_SERVICEPACKMAJOR)
    ENTRY(WZ_SERVICEPACKMINOR)
    ENTRY(WZ_SUITE)
    ENTRY(WZ_PRODUCTTYPE)
    ENTRY(WZ_SUPPORTEDRUNTIME)

  };


CRITICAL_SECTION CAssemblyManifestImport::g_cs;
    
// CLSID_XML DOM Document 3.0
class __declspec(uuid("f6d90f11-9c73-11d3-b32e-00c04f990bb4")) private_MSXML_DOMDocument30;


// Publics

// ---------------------------------------------------------------------------
// InitGlobalStringTable
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::InitGlobalStringTable()
{    
    for (eStringTableId i = Name; i < MAX_STRINGS; i++)
        if (!(g_StringTable[i].bstr = ::SysAllocString(g_StringTable[i].pwz)))
            return E_OUTOFMEMORY;

    return S_OK;
}

    
// ---------------------------------------------------------------------------
// FreeGlobalStringTable
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::FreeGlobalStringTable()
{
    for (eStringTableId i = Name;  i <= MAX_STRINGS; i++)
        ::SysFreeString(g_StringTable[i].bstr);

    return S_OK;
}


// ---------------------------------------------------------------------------
// CreateAssemblyManifestImport
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyManifestImport(IAssemblyManifestImport** ppImport, 
    LPCOLESTR pwzManifestFilePath, CDebugLog *pDbgLog, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CAssemblyManifestImportCLR * pImportCLR = NULL;
    CAssemblyManifestImport * pImportXML = NULL;
    IAssemblyManifestImport* pImport = NULL;
    IAssemblyIdentity * pAsmId=NULL;

    *ppImport = NULL;

    // BUGBUG - currently we sniff for "MZ" and assume it's a complib manifest.
    // This won't work when we start looking at Win32 PEs with embedded manifests.

    hr = CAssemblyManifestImport::IsCLRManifest(pwzManifestFilePath);
    IF_TRUE_EXIT(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), hr);
    IF_FAILED_EXIT(hr);

    if(hr  == S_OK)
    {
        IF_ALLOC_FAILED_EXIT(pImportCLR = new(CAssemblyManifestImportCLR));

        hr = pImportCLR->Init(pwzManifestFilePath);

        IF_TRUE_EXIT(hr == HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), hr); // do not assert
        IF_FAILED_EXIT(hr);

        pImport = (IAssemblyManifestImport*)pImportCLR;
        pImportCLR = NULL;
    }
    else //if (hr == S_FALSE)
    {
#ifdef CONTAINER
        IF_FAILED_EXIT(CAssemblyManifestImport::IsContainer(pwzManifestFilePath));
        if (hr == S_OK)
        {
            IF_ALLOC_FAILED_EXIT(pImportXML = new (CAssemblyManifestImportContainer) (pDbgLog) );
        }
        else //if (hr == S_FALSE)
        {
#endif
            IF_ALLOC_FAILED_EXIT(pImportXML = new (CAssemblyManifestImport) (pDbgLog) );
#ifdef CONTAINER
        }
#endif

        hr = pImportXML->Init(pwzManifestFilePath);
        IF_TRUE_EXIT(hr == HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), hr); // do not assert
        IF_FAILED_EXIT(hr);

        pImport = (IAssemblyManifestImport*)pImportXML;
        pImportXML = NULL;
    }

    IF_FAILED_EXIT(pImport->GetAssemblyIdentity(&pAsmId));

    IF_TRUE_EXIT(hr != S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));

    *ppImport = pImport;
    pImport = NULL;

exit:
    SAFERELEASE(pImport);
    SAFERELEASE(pAsmId);
    SAFERELEASE(pImportXML);
    SAFERELEASE(pImportCLR);

    return hr;
}


// ---------------------------------------------------------------------------
// CreateAssemblyManifestImportFromXMLStream
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyManifestImportFromXMLStream(IAssemblyManifestImport * * ppImport,
        IStream* piStream, CDebugLog * pDbgLog, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CAssemblyManifestImport* pImport = NULL;
    IAssemblyIdentity * pAsmId=NULL;

    IF_NULL_EXIT(ppImport, E_INVALIDARG);
    IF_NULL_EXIT(piStream, E_INVALIDARG);
    *ppImport = NULL;

    IF_ALLOC_FAILED_EXIT(pImport = new (CAssemblyManifestImport) (pDbgLog) );

    // load XML from IStream
    // call loaddocument directly, for now
    hr = pImport->LoadDocumentSync(piStream);
    IF_TRUE_EXIT(hr == HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), hr); // do not assert
    IF_FAILED_EXIT(hr);

    IF_FAILED_EXIT(pImport->GetAssemblyIdentity(&pAsmId));
    IF_TRUE_EXIT(hr != S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));

    *ppImport = pImport;
    pImport = NULL;

exit:
    SAFERELEASE(pImport);
    SAFERELEASE(pAsmId);

    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyManifestImport::CAssemblyManifestImport(CDebugLog * pDbgLog)
    : _dwSig('TRPM'), _cRef(1), _hr(S_OK), _pAssemblyId(NULL), _pXMLDoc(NULL), 
      _pXMLFileNodeList(NULL), _pXMLAssemblyNodeList(NULL), _pXMLPlatformNodeList(NULL),
      _nFileNodes(0), _nAssemblyNodes(0), _nPlatformNodes(0), _bstrManifestFilePath(NULL)
{
    _pDbgLog = pDbgLog;

    if(pDbgLog)
    {
        pDbgLog->AddRef();
    }
}


// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyManifestImport::~CAssemblyManifestImport()
{
    SAFERELEASE(_pDbgLog);
    SAFERELEASE(_pAssemblyId);
    SAFERELEASE(_pXMLFileNodeList);
    SAFERELEASE(_pXMLAssemblyNodeList);
    SAFERELEASE(_pXMLPlatformNodeList);
    SAFERELEASE(_pXMLDoc);

    if (_bstrManifestFilePath)
        ::SysFreeString(_bstrManifestFilePath);

}

// ---------------------------------------------------------------------------
// GetNextPlatform
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetNextPlatform(DWORD nIndex, IManifestData **ppPlatformInfo)
{
    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNode *pIDOMIdNode = NULL;
    IXMLDOMNode *pIDOMInfoNode = NULL;
    IXMLDOMNodeList *pXMLIdNodeList = NULL;
    IXMLDOMNodeList *pXMLInfoNodeList = NULL;
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    LPMANIFEST_DATA pPlatformInfo = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf;
    LONG nMatchingNodes = 0;
    BOOL bFoundManagedPlatform = FALSE;

    IF_NULL_EXIT(ppPlatformInfo, E_INVALIDARG);

    *ppPlatformInfo = NULL;

    // Initialize the platform node list if necessary.    
    if (!_pXMLPlatformNodeList)
    {
        if ((_hr = _pXMLDoc->selectNodes(g_StringTable[Platform].bstr, 
            &_pXMLPlatformNodeList)) != S_OK)
            goto exit;

        IF_FAILED_EXIT(_pXMLPlatformNodeList->get_length(&_nPlatformNodes));
        IF_FAILED_EXIT(_pXMLPlatformNodeList->reset());
    }

    if (nIndex >= (DWORD) _nPlatformNodes)
    {
        if(_nPlatformNodes <= 0)
            DEBUGOUT(_pDbgLog, 1, L" LOG: No platform dependency found");

        // no more
        _hr = S_FALSE;
        goto exit;
    }

    IF_FAILED_EXIT(_pXMLPlatformNodeList->get_item(nIndex, &pIDOMNode));

    // first try assemblyIdentity
    IF_FAILED_EXIT(pIDOMNode->selectNodes(g_StringTable[AssemblyIdTag].bstr, &pXMLIdNodeList));

    IF_FAILED_EXIT(pXMLIdNodeList->get_length(&nMatchingNodes));
    IF_FALSE_EXIT_LOG1(nMatchingNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                       _pDbgLog, 0, L" ERR: %d assemblyIdentity nodes in a dependent platform node found. only 1 expected", nMatchingNodes);

    if (nMatchingNodes > 0)
    {
        bFoundManagedPlatform = TRUE;

        IF_FAILED_EXIT(pXMLIdNodeList->reset());
        IF_FAILED_EXIT(pXMLIdNodeList->get_item(0, &pIDOMIdNode));

        IF_FAILED_EXIT(XMLtoAssemblyIdentity(pIDOMIdNode, &pAssemblyId));

        IF_FAILED_EXIT(CreateManifestData(WZ_DATA_PLATFORM_MANAGED, &pPlatformInfo));
        IF_FAILED_EXIT(pPlatformInfo->Set(g_StringTable[AssemblyIdTag].pwz,
                pAssemblyId,
                sizeof(LPVOID),
                MAN_DATA_TYPE_IUNKNOWN_PTR));
    }

    SAFERELEASE(pXMLIdNodeList);
    // then try osVersionInfo
    IF_FAILED_EXIT(pIDOMNode->selectNodes(g_StringTable[OSVersionInfo].bstr, &pXMLIdNodeList));

    IF_FAILED_EXIT(pXMLIdNodeList->get_length(&nMatchingNodes));
    IF_FALSE_EXIT_LOG1(nMatchingNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                       _pDbgLog, 0, L" ERR: %d osVersionInfo nodes in a dependent platform node found. only 1 expected", nMatchingNodes);
    if (nMatchingNodes > 0)
    {
        IF_FALSE_EXIT_LOG(pPlatformInfo == NULL, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                        _pDbgLog, 0, L" ERR: More than 1 of assemblyIdentity and osVersionInfo specified. only 1 expected");

        IF_FAILED_EXIT(pXMLIdNodeList->reset());
        IF_FAILED_EXIT(pXMLIdNodeList->get_item(0, &pIDOMIdNode));

        IF_FAILED_EXIT(CreateManifestData(WZ_DATA_PLATFORM_OS, &pPlatformInfo));
        IF_FAILED_EXIT(XMLtoOSVersionInfo(pIDOMIdNode, pPlatformInfo));
    }

    SAFERELEASE(pXMLIdNodeList);
    // then try .NetVersionInfo
    IF_FAILED_EXIT(pIDOMNode->selectNodes(g_StringTable[DotNetVersionInfo].bstr, &pXMLIdNodeList));

    IF_FAILED_EXIT(pXMLIdNodeList->get_length(&nMatchingNodes));
    IF_FALSE_EXIT_LOG1(nMatchingNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                       _pDbgLog, 0, L" ERR: %d .NetVersionInfo nodes in a dependent platform node found. only 1 expected", nMatchingNodes);
    if (nMatchingNodes > 0)
    {
        IF_FALSE_EXIT_LOG(pPlatformInfo == NULL, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                        _pDbgLog, 0, L" ERR: More than 1 of assemblyIdentity, osVersionInfo, and .NetVersionInfo specified. only 1 expected");

        IF_FAILED_EXIT(pXMLIdNodeList->reset());
        IF_FAILED_EXIT(pXMLIdNodeList->get_item(0, &pIDOMIdNode));

        IF_FAILED_EXIT(CreateManifestData(WZ_DATA_PLATFORM_DOTNET, &pPlatformInfo));
        IF_FAILED_EXIT(XMLtoDotNetVersionInfo(pIDOMIdNode, pPlatformInfo));
    }

    IF_FALSE_EXIT_LOG(pPlatformInfo != NULL, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                _pDbgLog, 0, L" ERR: No assemblyIdentity, osVersionInfo, or .NetVersionInfo specified. 1 expected");

    IF_FAILED_EXIT(pIDOMNode->selectNodes(g_StringTable[PlatformInfo].bstr, &pXMLInfoNodeList));

    IF_FAILED_EXIT(pXMLInfoNodeList->get_length(&nMatchingNodes));
    IF_FALSE_EXIT_LOG1(nMatchingNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                       _pDbgLog, 0, L" ERR: %d platformInfo nodes in a dependent platform node found. only 1 expected", nMatchingNodes);
    IF_FALSE_EXIT_LOG(nMatchingNodes > 0, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                       _pDbgLog, 0, L" ERR: No platformInfo nodes in a dependent platform node found");

    IF_FAILED_EXIT(pXMLInfoNodeList->reset());
    IF_FAILED_EXIT(pXMLInfoNodeList->get_item(0, &pIDOMInfoNode));

    // ISSUE? is friendlyName optional? ....
    IF_FAILED_EXIT(ParseAttribute(pIDOMInfoNode, g_StringTable[FriendlyName].bstr, 
                              &pwzBuf, &ccBuf));
    IF_FALSE_EXIT_LOG1(_hr == S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                   _pDbgLog, 0, L" ERR: %s attribute missing in a dependent platform node", g_StringTable[FriendlyName].pwz);
    IF_FAILED_EXIT(pPlatformInfo->Set(g_StringTable[FriendlyName].pwz,
            (LPVOID) pwzBuf, 
            ccBuf*sizeof(WCHAR),
            MAN_DATA_TYPE_LPWSTR));
    SAFEDELETEARRAY(pwzBuf);

    // ISSUE? href could be optional...
    IF_FAILED_EXIT(ParseAttribute(pIDOMInfoNode, g_StringTable[Href].bstr, &pwzBuf, &ccBuf));
    IF_FALSE_EXIT_LOG1(_hr == S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
             _pDbgLog, 0, L" ERR: %s attribute missing in a dependent platform node", g_StringTable[Href].pwz);
    IF_FAILED_EXIT(pPlatformInfo->Set(g_StringTable[Href].pwz,
            (LPVOID) pwzBuf, 
            ccBuf*sizeof(WCHAR),
            MAN_DATA_TYPE_LPWSTR));
    SAFEDELETEARRAY(pwzBuf);

    SAFERELEASE(pXMLInfoNodeList);
    SAFERELEASE(pIDOMInfoNode);
    IF_FAILED_EXIT(pIDOMNode->selectNodes(g_StringTable[Install].bstr, &pXMLInfoNodeList));

    IF_FAILED_EXIT(pXMLInfoNodeList->get_length(&nMatchingNodes));
    IF_FALSE_EXIT_LOG1(nMatchingNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
             _pDbgLog, 0, L" ERR: %d install nodes in a dependent platform node found. only 1 expected", nMatchingNodes);

    IF_FALSE_EXIT_LOG((bFoundManagedPlatform || nMatchingNodes <= 0), HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
             _pDbgLog, 0, L" ERR: The install node can only be specified for a managed dependent platform node");

    // install codebase is optional
    if (nMatchingNodes > 0)
   {
        IF_FAILED_EXIT(pXMLInfoNodeList->reset());
        IF_FAILED_EXIT(pXMLInfoNodeList->get_item(0, &pIDOMInfoNode));

        IF_FAILED_EXIT(ParseAttribute(pIDOMInfoNode, g_StringTable[Codebase].bstr, &pwzBuf, &ccBuf));
        IF_FALSE_EXIT_LOG1(_hr == S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                 _pDbgLog, 0, L" ERR: %s attribute missing in a dependent platform node", g_StringTable[Codebase].pwz);
        IF_FAILED_EXIT(pPlatformInfo->Set(g_StringTable[Codebase].pwz,
                (LPVOID) pwzBuf, 
                ccBuf*sizeof(WCHAR),
                MAN_DATA_TYPE_LPWSTR));
        SAFEDELETEARRAY(pwzBuf);
    }

    // Handout refcounted manifest data.
    *ppPlatformInfo = pPlatformInfo;
    pPlatformInfo = NULL;

    _hr = S_OK;

exit:
    SAFEDELETEARRAY(pwzBuf);
    SAFERELEASE(pAssemblyId);
    SAFERELEASE(pIDOMInfoNode);
    SAFERELEASE(pIDOMIdNode);
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pXMLInfoNodeList);
    SAFERELEASE(pXMLIdNodeList);
    SAFERELEASE(pPlatformInfo);

    return _hr;
}

// ---------------------------------------------------------------------------
// XMLtoOSVersionInfo
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::XMLtoOSVersionInfo(IXMLDOMNode *pIDOMNode, LPMANIFEST_DATA pPlatformInfo)
{
    IXMLDOMNode *pIDOMVersionNode = NULL;
    IXMLDOMNodeList *pXMLVersionNodeList = NULL;
    LPMANIFEST_DATA pOSInfo = NULL;
    LONG nNodes = 0;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;
    BOOL bFoundAtLeastOneAttribute = FALSE;

    IF_FAILED_EXIT(pIDOMNode->selectNodes(g_StringTable[OS].bstr, &pXMLVersionNodeList));

    IF_FAILED_EXIT(pXMLVersionNodeList->get_length(&nNodes));
    IF_FALSE_EXIT_LOG(nNodes > 0, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
            _pDbgLog, 0, L" ERR: No os nodes in a dependent platform OSVersionInfo node found. At least 1 expected");

    IF_FAILED_EXIT(pXMLVersionNodeList->reset());

    for (LONG lIndex = 0; lIndex < nNodes; lIndex++)
    {
        IF_FAILED_EXIT(pXMLVersionNodeList->get_item(lIndex, &pIDOMVersionNode));

        IF_FAILED_EXIT(CreateManifestData(WZ_DATA_OSVERSIONINFO, &pOSInfo));

        bFoundAtLeastOneAttribute = FALSE;

        for (eStringTableId i = MajorVersion; i <= ProductType; i++)
        {
            IF_FAILED_EXIT(ParseAttribute(pIDOMVersionNode, g_StringTable[i].bstr, 
                                          &pwzBuf, &ccBuf));
            if (_hr != S_FALSE)
            {
                bFoundAtLeastOneAttribute = TRUE;
                if (i >= MajorVersion && i <= ServicePackMinor)
                {
                    LPWSTR pwzStopString = NULL;
                    int num = wcstol(pwzBuf, &pwzStopString, 10);

                    IF_FALSE_EXIT_LOG1(num >= 0, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                             _pDbgLog, 0, L" ERR: Invalid %s attribute value less than zero", g_StringTable[i].pwz);

                    DWORD dwValue = num;

                    if (i >= ServicePackMajor && i <= ServicePackMinor)
                    {
                        // WORD
#define WORD_MAX 0xffff
                        IF_FALSE_EXIT_LOG1(dwValue <= WORD_MAX, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                                 _pDbgLog, 0, L" ERR: Invalid %s attribute value greater than WORD size", g_StringTable[i].pwz);
                    }
                    //else
                        // DWORD

                    IF_FAILED_EXIT(pOSInfo->Set(g_StringTable[i].pwz,
                            (LPVOID) &dwValue,
                            sizeof(dwValue),
                            MAN_DATA_TYPE_DWORD));
                }
                else
                {
                    IF_FAILED_EXIT(pOSInfo->Set(g_StringTable[i].pwz,
                            (LPVOID) pwzBuf, 
                            ccBuf*sizeof(WCHAR),
                            MAN_DATA_TYPE_LPWSTR));
                }
            SAFEDELETEARRAY(pwzBuf);
            }
        }

        IF_FALSE_EXIT_LOG(bFoundAtLeastOneAttribute, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                _pDbgLog, 0, L" ERR: No known os attribute in a dependent platform OSVersionInfo node found. At least 1 expected");

        IF_FAILED_EXIT((static_cast<CManifestData*>(pPlatformInfo))->Set(lIndex,
                pOSInfo,
                sizeof(LPVOID),
                MAN_DATA_TYPE_IUNKNOWN_PTR));

        SAFERELEASE(pOSInfo);
        SAFERELEASE(pIDOMVersionNode);
    }

exit:
    SAFEDELETEARRAY(pwzBuf);
    SAFERELEASE(pOSInfo);
    SAFERELEASE(pIDOMVersionNode);
    SAFERELEASE(pXMLVersionNodeList);
    return _hr;
}

// ---------------------------------------------------------------------------
// XMLtoDotNetVersionInfo
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::XMLtoDotNetVersionInfo(IXMLDOMNode *pIDOMNode, LPMANIFEST_DATA pPlatformInfo)
{
    IXMLDOMNode *pIDOMVersionNode = NULL;
    IXMLDOMNodeList *pXMLVersionNodeList = NULL;
    LONG nNodes = 0;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    IF_FAILED_EXIT(pIDOMNode->selectNodes(g_StringTable[SupportedRuntime].bstr, &pXMLVersionNodeList));

    IF_FAILED_EXIT(pXMLVersionNodeList->get_length(&nNodes));
    IF_FALSE_EXIT_LOG(nNodes > 0, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
            _pDbgLog, 0, L" ERR: No supportedRuntime nodes in a dependent platform .NetVersionInfo node found. At least 1 expected");

    IF_FAILED_EXIT(pXMLVersionNodeList->reset());

    for (LONG lIndex = 0; lIndex < nNodes; lIndex++)
    {
        IF_FAILED_EXIT(pXMLVersionNodeList->get_item(lIndex, &pIDOMVersionNode));

        IF_FAILED_EXIT(ParseAttribute(pIDOMVersionNode, g_StringTable[Version].bstr, 
                &pwzBuf, &ccBuf));

        IF_FALSE_EXIT_LOG1(_hr != S_FALSE, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                _pDbgLog, 0, L" ERR: No %s attribute in a dependent platform .NetVersionInfo node found", g_StringTable[Version].pwz);

        IF_FAILED_EXIT((static_cast<CManifestData*>(pPlatformInfo))->Set(lIndex,
                (LPVOID) pwzBuf, 
                ccBuf*sizeof(WCHAR),
                MAN_DATA_TYPE_LPWSTR));
        SAFEDELETEARRAY(pwzBuf);
        SAFERELEASE(pIDOMVersionNode);
    }

exit:
    SAFEDELETEARRAY(pwzBuf);
    SAFERELEASE(pIDOMVersionNode);
    SAFERELEASE(pXMLVersionNodeList);
    return _hr;
}

// ---------------------------------------------------------------------------
// GetSubscriptionInfo
// returns defaults if not specified in the manifest
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetSubscriptionInfo(IManifestInfo **ppSubsInfo)
{
    DWORD dwInterval = DW_DEFAULT_SYNC_INTERVAL;
    DWORD dwUnit = SUBSCRIPTION_INTERVAL_UNIT_HOURS;
    DWORD dwSyncEvent = SUBSCRIPTION_SYNC_EVENT_NONE;
    BOOL bEventDemandNet = FALSE;  //no (default)

    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNodeList *pXMLMatchingNodeList = NULL;
    IManifestInfo *pSubsInfo = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf;
    LONG nMatchingNodes = 0;

    IF_NULL_EXIT(ppSubsInfo, E_INVALIDARG);

    *ppSubsInfo = NULL;

    IF_FAILED_EXIT(_pXMLDoc->selectNodes(g_StringTable[Subscription].bstr, 
                                           &pXMLMatchingNodeList));

    IF_FAILED_EXIT(pXMLMatchingNodeList->get_length(&nMatchingNodes));

    IF_FALSE_EXIT_LOG1(nMatchingNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT),
                       _pDbgLog, 0, L" ERR: %d subscription nodes found. only 1 expected", nMatchingNodes);


    if (nMatchingNodes)
    {
        IF_FAILED_EXIT(pXMLMatchingNodeList->reset());

        IF_FAILED_EXIT(pXMLMatchingNodeList->get_item(0, &pIDOMNode));

        IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[SynchronizeInterval].bstr, 
                                      &pwzBuf, &ccBuf));

        if (_hr == S_OK)
        {
            LPWSTR pwzStopString = NULL;
            int num = wcstol(pwzBuf, &pwzStopString, 10);
            SAFEDELETEARRAY(pwzBuf);

            if (num > 0)
            {
                dwInterval = (DWORD) num;   // ignore <= 0 intervals

                // only check interval unit if valid interval is specified
                IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[IntervalUnit].bstr, 
                    &pwzBuf, &ccBuf));

                if (_hr == S_OK)
                {
                    // note: case sensitive comparison
                    IF_FAILED_EXIT(FusionCompareString(pwzBuf, WZ_MINUTES, 0));

                    if(_hr == S_OK)
                    {
                        dwUnit = SUBSCRIPTION_INTERVAL_UNIT_MINUTES;
                    }
                    else 
                    {
                        IF_FAILED_EXIT(FusionCompareString(pwzBuf, WZ_DAYS, 0));
                        if(_hr == S_OK)
                            dwUnit = SUBSCRIPTION_INTERVAL_UNIT_DAYS;
                    }
                    //else default
                }
            }
        }
        else
            DEBUGOUT(_pDbgLog, 1, L" LOG: No synchronizeInterval specified in the subscription node found. Default interval is assumed");

        SAFEDELETEARRAY(pwzBuf);

        IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[SynchronizeEvent].bstr, 
                                      &pwzBuf, &ccBuf));

        if (_hr == S_OK)
        {
            // note: case sensitive comparison
            IF_FAILED_EXIT(FusionCompareString(pwzBuf, WZ_ONAPPLICATIONSTARTUP, 0));
            if(_hr == S_OK)
                dwSyncEvent = SUBSCRIPTION_SYNC_EVENT_ON_APP_STARTUP;
            //else default
        }
        SAFEDELETEARRAY(pwzBuf);

        if (dwSyncEvent != SUBSCRIPTION_SYNC_EVENT_NONE)
        {
            // only check demand connection if an event is specified
            IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[EventDemandConnection].bstr,
                                          &pwzBuf, &ccBuf));

            if (_hr == S_OK)
            {
                // note: case sensitive comparison
                IF_FAILED_EXIT(FusionCompareString(pwzBuf, WZ_YES, 0));
                if(_hr == S_OK)
                    bEventDemandNet = TRUE;
                //else default
            }
            SAFEDELETEARRAY(pwzBuf);
        }
    }

    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_SUBSCRIPTION, &pSubsInfo));

    IF_FAILED_EXIT(pSubsInfo->Set(MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_INTERVAL,
            (LPVOID) &dwInterval, 
            sizeof(dwInterval),
            MAN_INFO_FLAG_DWORD));

    IF_FAILED_EXIT(pSubsInfo->Set(MAN_INFO_SUBSCRIPTION_INTERVAL_UNIT,
            (LPVOID) &dwUnit,
            sizeof(dwUnit),
            MAN_INFO_FLAG_ENUM));

    IF_FAILED_EXIT(pSubsInfo->Set(MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_EVENT,
            (LPVOID) &dwSyncEvent,
            sizeof(dwSyncEvent),
            MAN_INFO_FLAG_ENUM));

    IF_FAILED_EXIT(pSubsInfo->Set(MAN_INFO_SUBSCRIPTION_EVENT_DEMAND_CONNECTION,
            (LPVOID) &bEventDemandNet,
            sizeof(bEventDemandNet),
            MAN_INFO_FLAG_BOOL));

    // Handout refcounted manifest info.
    *ppSubsInfo = pSubsInfo;
    pSubsInfo = NULL;

    _hr = S_OK;

exit:

    SAFEDELETEARRAY(pwzBuf);
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pXMLMatchingNodeList);
    SAFERELEASE(pSubsInfo);

    return _hr;
}

// ---------------------------------------------------------------------------
// GetNextFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetNextFile(DWORD nIndex, IManifestInfo **ppAssemblyFile)
{
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    CString sFileName;
    CString sFileHash;

    IXMLDOMNode *pIDOMNode = NULL;
    IManifestInfo *pAssemblyFile = NULL;
    
    // Initialize the file node list if necessary.    
    if (!_pXMLFileNodeList)
    {
        if ((_hr = _pXMLDoc->selectNodes(g_StringTable[FileNode].bstr, 
            &_pXMLFileNodeList)) != S_OK)
            goto exit;

        IF_FAILED_EXIT(_pXMLFileNodeList->get_length(&_nFileNodes));
        IF_FAILED_EXIT(_pXMLFileNodeList->reset());
    }

    if (nIndex >= (DWORD) _nFileNodes)
    {
        _hr = S_FALSE;
        goto exit;
    }

    if ((_hr = _pXMLFileNodeList->get_item(nIndex, &pIDOMNode)) != S_OK)
        goto exit;

    IF_FAILED_EXIT(CreateAssemblyFileEx (&pAssemblyFile, pIDOMNode));
 
    *ppAssemblyFile = pAssemblyFile;
    pAssemblyFile = NULL;
    _hr = S_OK;

exit:

    SAFERELEASE(pAssemblyFile);
    SAFERELEASE(pIDOMNode);

    return _hr;

}


// ---------------------------------------------------------------------------
// QueryFile
// return:
//    S_OK
//    S_FALSE -not exist or not match or missing attribute
//    E_*
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::QueryFile(LPCOLESTR pcwzFileName, IManifestInfo **ppAssemblyFile)
{
    CString sQueryString;
    BSTR bstrtQueryString = NULL;

    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNodeList *pXMLMatchingFileNodeList = NULL;
    IManifestInfo *pAssemblyFile = NULL;
    LONG nMatchingFileNodes = 0;

    IF_NULL_EXIT(pcwzFileName, E_INVALIDARG);
    IF_NULL_EXIT(ppAssemblyFile, E_INVALIDARG);

    *ppAssemblyFile = NULL;

    // XPath query string: "file[@name = "path\filename"]"
    IF_FAILED_EXIT(sQueryString.Assign(WZ_FILE_QUERYSTRING_PREFIX));
    IF_FAILED_EXIT(sQueryString.Append((LPWSTR)pcwzFileName));
    IF_FAILED_EXIT(sQueryString.Append(WZ_QUERYSTRING_SUFFIX));

    IF_ALLOC_FAILED_EXIT(bstrtQueryString = ::SysAllocString(sQueryString._pwz));

    if ((_hr = _pXMLDoc->selectNodes(bstrtQueryString, &pXMLMatchingFileNodeList)) != S_OK)
        goto exit;

    IF_FAILED_EXIT( pXMLMatchingFileNodeList->get_length(&nMatchingFileNodes));

    IF_FALSE_EXIT(nMatchingFileNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT)); // multiple file callouts having the exact same file name/path within a single manifest...

    IF_TRUE_EXIT(nMatchingFileNodes <= 0, S_FALSE);

    IF_FAILED_EXIT(pXMLMatchingFileNodeList->reset());

    IF_FALSE_EXIT( pXMLMatchingFileNodeList->get_item(0, &pIDOMNode) == S_OK, E_FAIL);

    IF_FAILED_EXIT(CreateAssemblyFileEx (&pAssemblyFile, pIDOMNode));

    *ppAssemblyFile = pAssemblyFile;
    pAssemblyFile = NULL;
    _hr = S_OK;

exit:

    if (bstrtQueryString)
        ::SysFreeString(bstrtQueryString);
    
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pXMLMatchingFileNodeList);
    SAFERELEASE(pAssemblyFile);

    return _hr;

}


// ---------------------------------------------------------------------------
// CreateAssemblyFileEx
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::CreateAssemblyFileEx(IManifestInfo **ppAssemblyFile, IXMLDOMNode *pIDOMNode)
{
    LPWSTR pwzBuf;
    DWORD ccBuf;
    BOOL compressed;
    CString sFileName, sFileHash;

    IManifestInfo *pAssemblyFile=NULL;

    //Create new ManifestInfo
    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_FILE, &pAssemblyFile));

    // Parse out relevent information from IDOMNode       
    IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[FileName].bstr,  &pwzBuf, &ccBuf));

    // BUGBUG:: IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    sFileName.TakeOwnership(pwzBuf, ccBuf);

    IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[FileHash].bstr, 
                                  &pwzBuf, &ccBuf));

    // BUGBUG:: IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    sFileHash.TakeOwnership(pwzBuf, ccBuf);

    // Set all aboved pased info into the AssemblyFIle    
    IF_FAILED_EXIT(pAssemblyFile->Set(MAN_INFO_ASM_FILE_NAME, sFileName._pwz, 
                                  sFileName.ByteCount(), MAN_INFO_FLAG_LPWSTR));
    
    IF_FAILED_EXIT(pAssemblyFile->Set(MAN_INFO_ASM_FILE_HASH, sFileHash._pwz, 
                                  sFileHash.ByteCount(), MAN_INFO_FLAG_LPWSTR));
        
    *ppAssemblyFile = pAssemblyFile;
    pAssemblyFile = NULL;

exit:
    SAFERELEASE (pAssemblyFile);

    return _hr;
}

// ---------------------------------------------------------------------------
// XMLtoAssemblyIdentiy IXMLDOMDocument2 *pXMLDoc
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::XMLtoAssemblyIdentity(IXMLDOMNode *pIDOMNode, LPASSEMBLY_IDENTITY *ppAssemblyId)
{
    HRESULT hr;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    IF_FAILED_EXIT(CreateAssemblyIdentity(&pAssemblyId, 0));

    for (eStringTableId i = Name; i <= Type; i++)
    {
        CString sBuf;
        IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[i].bstr, 
                                      &pwzBuf, &ccBuf));

        if (hr != S_FALSE)
        {
            sBuf.TakeOwnership(pwzBuf, ccBuf);
            IF_FAILED_EXIT(pAssemblyId->SetAttribute(g_StringTable[i].pwz, 
                sBuf._pwz, sBuf._cc));    
        }
    }

    *ppAssemblyId = pAssemblyId;
    pAssemblyId = NULL;

    hr = S_OK;

  exit:
    SAFERELEASE (pAssemblyId);
    return hr;

}

// ---------------------------------------------------------------------------
// GetNextAssembly
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetNextAssembly(DWORD nIndex, IManifestInfo **ppDependAsm)
{
    CString sCodebase;
    DWORD dwType = DEPENDENT_ASM_INSTALL_TYPE_NORMAL;

    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNode *pIDOMCodebaseNode = NULL;
    IXMLDOMNodeList *pXMLCodebaseNodeList = NULL;
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    IManifestInfo *pDependAsm = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = NULL;
    LONG nCodebaseNodes = 0;

    IF_NULL_EXIT(ppDependAsm, E_INVALIDARG);

    *ppDependAsm = NULL;
    
    // Initialize the assembly node list if necessary.    
    if (!_pXMLAssemblyNodeList)
    {
        if ((_hr = _pXMLDoc->selectNodes(g_StringTable[DependentAssemblyNode].bstr, 
            &_pXMLAssemblyNodeList)) != S_OK)
            goto exit;

        IF_FAILED_EXIT(_pXMLAssemblyNodeList->get_length(&_nAssemblyNodes));
        IF_FAILED_EXIT(_pXMLAssemblyNodeList->reset());
    }

    if (nIndex >= (DWORD) _nAssemblyNodes)
    {
        _hr = S_FALSE;
        goto exit;
    }

    IF_FAILED_EXIT(_pXMLAssemblyNodeList->get_item(nIndex, &pIDOMNode));

    IF_FAILED_EXIT(XMLtoAssemblyIdentity(pIDOMNode, &pAssemblyId));
    
    // note: check for multiple qualified nodes. As the use of "../install" XPath expression
    //      can result in either preceding _or_ following siblings with node name "install",
    //      this is to ensure codebase is not defined > 1 for this particular dependent
    // BUGBUG: should just take the 1st codebase and ignore all others?
    if ((_hr = pIDOMNode->selectNodes(g_StringTable[DependentAssemblyCodebase].bstr, &pXMLCodebaseNodeList)) != S_OK)
        goto exit;

    IF_FAILED_EXIT(pXMLCodebaseNodeList->get_length(&nCodebaseNodes));

    IF_FALSE_EXIT(nCodebaseNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT)); // multiple codebases for a single dependent assembly identity...

    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_DEPENDTANT_ASM,&pDependAsm));

    if (nCodebaseNodes)
    {
        IF_FAILED_EXIT(pXMLCodebaseNodeList->reset());

        IF_FALSE_EXIT(pXMLCodebaseNodeList->get_item(0, &pIDOMCodebaseNode) == S_OK, E_FAIL);

        IF_FAILED_EXIT(ParseAttribute(pIDOMCodebaseNode, g_StringTable[Codebase].bstr, 
            &pwzBuf, &ccBuf));

        if(_hr == S_OK) // BUGBUG: do we want to exit if S_FALSE ??
        {
            sCodebase.TakeOwnership(pwzBuf, ccBuf);

            IF_FAILED_EXIT(pDependAsm->Set(MAN_INFO_DEPENDENT_ASM_CODEBASE, sCodebase._pwz, 
                                 sCodebase.ByteCount(), MAN_INFO_FLAG_LPWSTR));
        }

        IF_FAILED_EXIT(ParseAttribute(pIDOMCodebaseNode, g_StringTable[InstallType].bstr, 
            &pwzBuf, &ccBuf));

        if (_hr == S_OK)
        {
            // note: case sensitive comparison
            IF_FAILED_EXIT(FusionCompareString(pwzBuf, WZ_REQUIRED, 0));
            if(_hr == S_OK)
                dwType = DEPENDENT_ASM_INSTALL_TYPE_REQUIRED;
#ifdef DEVMODE
            else
            {
                IF_FAILED_EXIT(FusionCompareString(pwzBuf, WZ_DEVSYNC, 0));
                if(_hr == S_OK)
                    dwType = DEPENDENT_ASM_INSTALL_TYPE_DEVSYNC;
            }
#endif
        }

        SAFEDELETEARRAY(pwzBuf);

        IF_FAILED_EXIT(pDependAsm->Set(MAN_INFO_DEPENDENT_ASM_TYPE, (LPVOID)&dwType, sizeof(dwType), MAN_INFO_FLAG_ENUM));
    }

    // Handout refcounted assemblyid.
    IF_FAILED_EXIT(pDependAsm->Set(MAN_INFO_DEPENDENT_ASM_ID, &pAssemblyId, sizeof(LPVOID), MAN_INFO_FLAG_IUNKNOWN_PTR));

    *ppDependAsm = pDependAsm;
    pDependAsm  = NULL;
    _hr = S_OK;

exit:

    SAFERELEASE(pIDOMCodebaseNode);
    SAFERELEASE(pXMLCodebaseNodeList);
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pAssemblyId);
    SAFERELEASE(pDependAsm);
    return _hr;

}


// ---------------------------------------------------------------------------
// GetAssemblyIdentity
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetAssemblyIdentity(LPASSEMBLY_IDENTITY *ppAssemblyId)
{
    IXMLDOMNode *pIDOMNode = NULL;
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    if (_pAssemblyId)
    {
        *ppAssemblyId = _pAssemblyId;
        (*ppAssemblyId)->AddRef();
        _hr = S_OK;
        goto exit;
    }
    
    if ((_hr = _pXMLDoc->selectSingleNode(g_StringTable[AssemblyId].bstr, 
        &pIDOMNode)) != S_OK)
        goto exit;

    IF_FAILED_EXIT(XMLtoAssemblyIdentity(pIDOMNode, &pAssemblyId));

    *ppAssemblyId = pAssemblyId;
    (*ppAssemblyId)->AddRef();

    // do not release AsmId, cache it
    _pAssemblyId = pAssemblyId;
    
exit:
    SAFERELEASE(pIDOMNode);

    return _hr;
}

// ---------------------------------------------------------------------------
// GetManifestApplicationInfo
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetManifestApplicationInfo(IManifestInfo ** ppAppInfo)
{
    IXMLDOMNode *pIDOMNode = NULL;
    IManifestInfo *pAppInfo = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    IF_NULL_EXIT(ppAppInfo, E_INVALIDARG);

    *ppAppInfo = NULL;

    IF_FAILED_EXIT(_pXMLDoc->selectSingleNode(g_StringTable[ShellState].bstr, &pIDOMNode));

    IF_TRUE_EXIT(_hr != S_OK, _hr);

    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_APPLICATION, &pAppInfo));

    for (eStringTableId i = FriendlyName; i <= HotKey; i++)
    {
        CString sBuf;
        IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[i].bstr, &pwzBuf, &ccBuf));

        if (_hr != S_FALSE)
        {
            IF_FAILED_EXIT(sBuf.TakeOwnership(pwzBuf, ccBuf));
            IF_FAILED_EXIT(pAppInfo->Set(MAN_INFO_APPLICATION_FRIENDLYNAME+i-FriendlyName,
                    sBuf._pwz, sBuf.ByteCount(), MAN_INFO_FLAG_LPWSTR));
        }
    }

    IF_FAILED_EXIT(_pXMLDoc->selectSingleNode(g_StringTable[Activation].bstr, &pIDOMNode));

    if(_hr == S_OK)
    {
        for (eStringTableId i = AssemblyName; i <= AssemblyArgs; i++)
        {
            CString sBuf;
            IF_FAILED_EXIT(ParseAttribute(pIDOMNode, g_StringTable[i].bstr, 
                                           &pwzBuf, &ccBuf));

            if (_hr != S_FALSE)
            {
                sBuf.TakeOwnership(pwzBuf, ccBuf);
                IF_FAILED_EXIT(pAppInfo->Set(MAN_INFO_APPLICATION_FRIENDLYNAME+i-FriendlyName-1, // MAN_INFO_APPLICATION_ASSEMBLYNAME+i-AssemblyName,
                        sBuf._pwz, sBuf.ByteCount(), MAN_INFO_FLAG_LPWSTR));
            }
        }
    }
    // reset so that S_FALSE is returned only if Subscription node is not found but not its attributes
    _hr = S_OK;

    *ppAppInfo = pAppInfo;
    pAppInfo = NULL;

exit:
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pAppInfo);

    return _hr;
}

// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestImport::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyManifestImport)
       )
    {
        *ppvObj = static_cast<IAssemblyManifestImport*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImport::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImport::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

// Privates


// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::Init(LPCOLESTR pwzManifestFilePath)
{    

    IF_NULL_EXIT(pwzManifestFilePath, E_INVALIDARG);

    // Alloc manifest file path.
    IF_ALLOC_FAILED_EXIT(_bstrManifestFilePath    = ::SysAllocString((LPWSTR) pwzManifestFilePath));

    // Load the DOM document.
    _hr = LoadDocumentSync(NULL);


exit:

    return _hr;
}
    

// ---------------------------------------------------------------------------
// LoadDocumentSync
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::LoadDocumentSync(IUnknown* punk)
{
    VARIANT             varDoc;
    VARIANT             varNameSpaces;
    VARIANT             varXPath;
    VARIANT_BOOL        varb;

    IXMLDOMDocument2   *pXMLDoc   = NULL;

    IF_FALSE_EXIT(((_bstrManifestFilePath != NULL || punk != NULL)
        && (_bstrManifestFilePath == NULL || punk == NULL)), E_INVALIDARG);

    // Create the DOM Doc interface
    IF_FAILED_EXIT(CoCreateInstance(__uuidof(private_MSXML_DOMDocument30), 
            NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, (void**)&_pXMLDoc));

    // Load synchronously
    IF_FAILED_EXIT(_pXMLDoc->put_async(VARIANT_FALSE));
    
    VariantInit(&varDoc);
    if (_bstrManifestFilePath != NULL)
    {
        // Load xml document from the given URL or file path
        varDoc.vt = VT_BSTR;
        V_BSTR(&varDoc) = _bstrManifestFilePath;
    }
    else
    {
        // punk != NULL
        varDoc.vt = VT_UNKNOWN;
        V_UNKNOWN(&varDoc) = punk;
    }

    IF_FAILED_EXIT(_pXMLDoc->load(varDoc, &varb));

    // ISSUE-2002/04/16-felixybc  Hack for mg. Not clear returning ERROR_BAD_FORMAT is correct in all cases
    //    however, load() returns S_FALSE when loading fails, and the error is unknown.
    IF_TRUE_EXIT(_hr != S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT)); // S_FALSE returned if the load fails

    // Setup namespace filter
    VariantInit(&varNameSpaces);
    varNameSpaces.vt = VT_BSTR;
    V_BSTR(&varNameSpaces) = g_StringTable[NameSpace].bstr;

    IF_FAILED_EXIT(_pXMLDoc->setProperty(g_StringTable[SelNameSpaces].bstr, varNameSpaces));

    // Setup query type
    VariantInit(&varXPath);
    varXPath.vt = VT_BSTR;
    V_BSTR(&varXPath) = g_StringTable[XPath].bstr;

    IF_FAILED_EXIT(_pXMLDoc->setProperty(g_StringTable[SelLanguage].bstr, varXPath));

    _hr = S_OK;

exit:

    if (FAILED(_hr))
        SAFERELEASE(_pXMLDoc);

    return _hr;
}


// ---------------------------------------------------------------------------
// ParseAttribute
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::ParseAttribute(IXMLDOMNode *pIXMLDOMNode, 
    BSTR bstrAttributeName, LPWSTR *ppwzAttributeValue, LPDWORD pccAttributeValue)
{
    HRESULT hr;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD ccAttributeValue = 0;
    LPWSTR pwzAttributeValue = NULL;        

    VARIANT varValue;
    IXMLDOMElement *pIXMLDOMElement = NULL;

    *ppwzAttributeValue = NULL;
    *pccAttributeValue = 0;

    VariantInit(&varValue);

    IF_FAILED_EXIT(pIXMLDOMNode->QueryInterface(IID_IXMLDOMElement, (void**) &pIXMLDOMElement));

    if ((hr = pIXMLDOMElement->getAttribute(bstrAttributeName, 
        &varValue)) != S_OK)
        goto exit;
        
    // BUGBUG - what is meaning of NULL value here?
    if(varValue.vt != VT_NULL)
    {
        
        ccAttributeValue = ::SysStringLen(varValue.bstrVal) + 1;
        IF_ALLOC_FAILED_EXIT(pwzAttributeValue = new WCHAR[ccAttributeValue]);
        memcpy(pwzAttributeValue, varValue.bstrVal, ccAttributeValue * sizeof(WCHAR));
        *ppwzAttributeValue = pwzAttributeValue;
        *pccAttributeValue = ccAttributeValue;
    }
    else
        hr = S_FALSE;
exit:

    SAFERELEASE(pIXMLDOMElement);

    if (varValue.bstrVal)
        ::SysFreeString(varValue.bstrVal);

    return hr;
}


// ---------------------------------------------------------------------------
// InitGlobalCritSect
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::InitGlobalCritSect()
{
    HRESULT hr = S_OK;

    __try {
        InitializeCriticalSection(&g_cs);
    }
    __except (GetExceptionCode() == STATUS_NO_MEMORY ? 
            EXCEPTION_EXECUTE_HANDLER : 
            EXCEPTION_CONTINUE_SEARCH ) 
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


// ---------------------------------------------------------------------------
// DelGlobalCritSect
// ---------------------------------------------------------------------------
void CAssemblyManifestImport::DelGlobalCritSect()
{
    DeleteCriticalSection(&g_cs);
}


// ---------------------------------------------------------------------------
// ReportManifestType
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::ReportManifestType(DWORD *pdwType)
{
    LPWSTR pwzType = NULL;
    DWORD dwCC = 0;

    IF_NULL_EXIT(pdwType, E_INVALIDARG);

    *pdwType = MANIFEST_TYPE_UNKNOWN;

    // ensure _pAssemblyId is initialized/cached
    if (!_pAssemblyId)
    {
        LPASSEMBLY_IDENTITY pAssemblyId = NULL;
        if ((_hr = GetAssemblyIdentity(&pAssemblyId)) != S_OK)
            goto exit;

        SAFERELEASE(pAssemblyId);
    }

    if ((_hr = _pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE, &pwzType, &dwCC)) == S_OK)
    {
        // note: case sensitive comparison
        IF_FAILED_EXIT(FusionCompareString(pwzType, L"desktop", 0));
        if(_hr == S_OK)
            *pdwType = MANIFEST_TYPE_DESKTOP;
        else
        {
            IF_FAILED_EXIT(FusionCompareString(pwzType, L"subscription", 0));
            if(_hr == S_OK)
            {
                *pdwType = MANIFEST_TYPE_SUBSCRIPTION;
            }
            else
            {
                IF_FAILED_EXIT(FusionCompareString(pwzType, L"application", 0));
                if(_hr == S_OK)
                    *pdwType = MANIFEST_TYPE_APPLICATION;
            }
        // else MANIFEST_TYPE_UNKNOWN
        }

        SAFEDELETEARRAY(pwzType);
    }

exit:
    SAFEDELETEARRAY(pwzType);
    return _hr;
}


// ---------------------------------------------------------------------------
// GetXMLDoc
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetXMLDoc(IXMLDOMDocument2 **pXMLDoc)
{
    _hr = S_OK;

    *pXMLDoc = NULL;

    if (!_pXMLDoc)
    {        
        _hr = S_FALSE;
        goto exit;
    }
   
    *pXMLDoc = _pXMLDoc;
    (*pXMLDoc)->AddRef();

exit:
    return _hr;
}

// ---------------------------------------------------------------------------
// IsCLRManifest
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::IsCLRManifest(LPCOLESTR pwzManifestFilePath)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwLength=0;
    unsigned char buffer[2];

    ZeroMemory(buffer, sizeof(buffer));

    hFile = CreateFile(pwzManifestFilePath, 
                       GENERIC_READ, 
                       FILE_SHARE_READ, 
                       NULL, 
                       OPEN_EXISTING, 
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = FusionpHresultFromLastError();
        // ISSUE-2002/04/12-felixybc  File could be deleted when called by shell in the shell ext context
        //   do not assert in that case
        ASSERT(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)); 
        goto exit;
    }

    IF_WIN32_FALSE_EXIT(ReadFile(hFile, buffer, sizeof(buffer), &dwLength, NULL));

    if (dwLength && !strncmp((const char *)buffer, "MZ", 2))
        hr = S_OK;
    else
        hr = S_FALSE;

exit:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    return hr;
}

#ifdef CONTAINER
// ---------------------------------------------------------------------------
// IsContainer
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::IsContainer(LPCOLESTR pwzManifestFilePath)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CString sPath;

    IF_FAILED_EXIT(sPath.Assign(pwzManifestFilePath));

    // ISSUE-2002/07/03-felixybc  only checks extension for now
    IF_FAILED_EXIT(sPath.EndsWith(L".container"));
    
exit:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\manifest\manifestemit.cpp ===
#include <fusenetincludes.h>
#include <msxml2.h>
#include <manifestemit.h>
#include <manifestimport.h>
#include "macros.h"

CRITICAL_SECTION CAssemblyManifestEmit::g_cs;
    
// CLSID_XML DOM Document 3.0
class __declspec(uuid("f6d90f11-9c73-11d3-b32e-00c04f990bb4")) private_MSXML_DOMDocument30;


// Publics


// ---------------------------------------------------------------------------
// CreateAssemblyManifestEmit
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyManifestEmit(LPASSEMBLY_MANIFEST_EMIT* ppEmit, 
    LPCOLESTR pwzManifestFilePath, MANIFEST_TYPE eType)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CAssemblyManifestEmit* pEmit = NULL;

    IF_NULL_EXIT(ppEmit, E_INVALIDARG);

    *ppEmit = NULL;

    // only support emitting desktop manifest now
    IF_FALSE_EXIT(eType == MANIFEST_TYPE_DESKTOP, HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED));

    pEmit = new(CAssemblyManifestEmit);
    IF_ALLOC_FAILED_EXIT(pEmit);

    IF_FAILED_EXIT(pEmit->Init(pwzManifestFilePath));

    *ppEmit = (IAssemblyManifestEmit*) pEmit;
    pEmit->AddRef();

exit:

    SAFERELEASE(pEmit);

    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyManifestEmit::CAssemblyManifestEmit()
    : _dwSig('TMEM'), _cRef(1), _hr(S_OK), _pXMLDoc(NULL), 
     _pAssemblyNode(NULL), _pDependencyNode(NULL),
     _pApplicationNode(NULL),_bstrManifestFilePath(NULL)
{
}


// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyManifestEmit::~CAssemblyManifestEmit()
{
    SAFERELEASE(_pAssemblyNode);
    SAFERELEASE(_pDependencyNode);
    SAFERELEASE(_pApplicationNode);
    SAFERELEASE(_pXMLDoc);

    if (_bstrManifestFilePath)
        ::SysFreeString(_bstrManifestFilePath);
}

// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CAssemblyManifestEmit::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestEmit::QueryInterface(REFIID riid, void** ppvObj)
{
    if ( IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyManifestEmit))
    {
        *ppvObj = static_cast<IAssemblyManifestEmit*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyManifestEmit::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestEmit::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyManifestEmit::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestEmit::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

// Privates


// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestEmit::Init(LPCOLESTR pwzManifestFilePath)
{
    IF_NULL_EXIT(pwzManifestFilePath, E_INVALIDARG);

    // Alloc manifest file path.
    _bstrManifestFilePath = ::SysAllocString((LPWSTR) pwzManifestFilePath);
    IF_ALLOC_FAILED_EXIT(_bstrManifestFilePath);

    // note: DOM Doc is delayed initialized in ImportAssemblyNode() to enable sharing of BSTRs
    _hr = S_OK;

exit:
    return _hr;
}
    

// ---------------------------------------------------------------------------
// InitGlobalCritSect
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestEmit::InitGlobalCritSect()
{
    HRESULT hr = S_OK;

    __try {
        InitializeCriticalSection(&g_cs);
    }
    __except (GetExceptionCode() == STATUS_NO_MEMORY ? 
            EXCEPTION_EXECUTE_HANDLER : 
            EXCEPTION_CONTINUE_SEARCH ) 
    {
        hr = E_OUTOFMEMORY;
    }

return hr;
}


// ---------------------------------------------------------------------------
// DelGlobalCritSect
// ---------------------------------------------------------------------------
void CAssemblyManifestEmit::DelGlobalCritSect()
{
    DeleteCriticalSection(&g_cs);
}


// ---------------------------------------------------------------------------
// ImportManifestInfo
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestEmit::ImportManifestInfo(LPASSEMBLY_MANIFEST_IMPORT pManImport)
{
    DWORD dwType = MANIFEST_TYPE_UNKNOWN;
    IXMLDOMDocument2 *pXMLDocSrc = NULL;
    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNode *pIDOMNodeClone = NULL;
    IXMLDOMElement *pIXMLDOMElement = NULL;

    VARIANT varVersionWildcard;
    VARIANT varTypeDesktop;
    VARIANT varRefNode;

    IF_NULL_EXIT(pManImport, E_INVALIDARG);

    IF_FAILED_EXIT(pManImport->ReportManifestType(&dwType));

    IF_FALSE_EXIT(dwType == MANIFEST_TYPE_APPLICATION, HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED));

    IF_TRUE_EXIT(_pApplicationNode != NULL, S_FALSE);

    if (_pAssemblyNode == NULL)
        IF_FAILED_EXIT(ImportAssemblyNode(pManImport));

    // application manifest: clone and insert 'assemblyIdentity' node (change 'version', 'type' attribute)
    // and 'application' node

    pXMLDocSrc = ((CAssemblyManifestImport*)pManImport)->_pXMLDoc;

    // BUGBUG: this only pick the 1st instance of 'application'
    IF_FAILED_EXIT(pXMLDocSrc->selectSingleNode(
        CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::ApplicationNode].bstr, &pIDOMNode));
    IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    // clone all children
    IF_FAILED_EXIT(pIDOMNode->cloneNode(VARIANT_TRUE, &pIDOMNodeClone));

    VariantInit(&varRefNode);
    varRefNode.vt = VT_UNKNOWN;
    V_UNKNOWN(&varRefNode) = _pDependencyNode;
    // insert before 'dependency', if present
    IF_FAILED_EXIT(_pAssemblyNode->insertBefore(pIDOMNodeClone, varRefNode, &_pApplicationNode));

    SAFERELEASE(pIDOMNodeClone);
    SAFERELEASE(pIDOMNode);

    // BUGBUG: this only pick the 1st instance of 'assemblyIdentity'
    IF_FAILED_EXIT(pXMLDocSrc->selectSingleNode(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::AssemblyId].bstr, &pIDOMNode));
    IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    // clone all children
    IF_FAILED_EXIT(pIDOMNode->cloneNode(VARIANT_TRUE, &pIDOMNodeClone));

    SAFERELEASE(pIDOMNode);

    VariantInit(&varRefNode);
    varRefNode.vt = VT_UNKNOWN;
    V_UNKNOWN(&varRefNode) = _pApplicationNode;
    // insert before 'application'
    IF_FAILED_EXIT(_pAssemblyNode->insertBefore(pIDOMNodeClone, varRefNode, &pIDOMNode));

    // change 'version' = '*', 'type' = 'desktop'
    IF_FAILED_EXIT(pIDOMNode->QueryInterface(IID_IXMLDOMElement, (void**) &pIXMLDOMElement));

    VariantInit(&varVersionWildcard);
    varVersionWildcard.vt = VT_BSTR;
    V_BSTR(&varVersionWildcard) = CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::VersionWildcard].bstr;
    IF_FAILED_EXIT(pIXMLDOMElement->setAttribute(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Version].bstr, varVersionWildcard));

    VariantInit(&varTypeDesktop);
    varTypeDesktop.vt = VT_BSTR;
    V_BSTR(&varTypeDesktop) = CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Desktop].bstr;
    _hr = pIXMLDOMElement->setAttribute(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Type].bstr, varTypeDesktop);

exit:
    SAFERELEASE(pIXMLDOMElement);
    SAFERELEASE(pIDOMNodeClone);
    SAFERELEASE(pIDOMNode);

    if (FAILED(_hr))
        SAFERELEASE(_pApplicationNode);

    return _hr;
}


// ---------------------------------------------------------------------------
// SetDependencySubscription
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestEmit::SetDependencySubscription(LPASSEMBLY_MANIFEST_IMPORT pManImport, LPWSTR pwzManifestUrl)
{
    DWORD dwType = MANIFEST_TYPE_UNKNOWN;
    IXMLDOMDocument2 *pXMLDocSrc = NULL;
    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNode *pIDOMNodeClone = NULL;
    IXMLDOMElement *pIDOMElement = NULL;
    IXMLDOMNode *pDependentAssemblyNode = NULL;

    VARIANT varVersionWildcard;
    VARIANT varCodebase;
    BSTR bstrManifestUrl = NULL;

    VariantInit(&varCodebase);

    IF_FALSE_EXIT(pManImport && pwzManifestUrl, E_INVALIDARG);

    IF_FAILED_EXIT(pManImport->ReportManifestType(&dwType));

    IF_FALSE_EXIT(dwType == MANIFEST_TYPE_SUBSCRIPTION || dwType == MANIFEST_TYPE_APPLICATION, HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED));

    IF_TRUE_EXIT(_pDependencyNode != NULL, S_FALSE);

    if (_pAssemblyNode == NULL)
        IF_FAILED_EXIT(ImportAssemblyNode(pManImport));

    // setup manifest subscription data: create dependency/dependentAssembly
    // then add a clone of the asm Id node from pManImport and an 'install' node with the given URL
    IF_FAILED_EXIT(_pXMLDoc->createElement(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Dependency].bstr, &pIDOMElement));

    // insert at the end
    IF_FAILED_EXIT(_pAssemblyNode->appendChild(pIDOMElement, &_pDependencyNode));

    SAFERELEASE(pIDOMElement);

    IF_FAILED_EXIT(_pXMLDoc->createElement(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::DependentAssembly].bstr, &pIDOMElement));

    IF_FAILED_EXIT(_pDependencyNode->appendChild(pIDOMElement, &pDependentAssemblyNode));

    SAFERELEASE(pIDOMElement);

    pXMLDocSrc = ((CAssemblyManifestImport*)pManImport)->_pXMLDoc;

    // BUGBUG: this only pick the 1st instance of 'assemblyIdentity'
    IF_FAILED_EXIT(pXMLDocSrc->selectSingleNode(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::AssemblyId].bstr, &pIDOMNode));
    IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    // clone all children
    IF_FAILED_EXIT(pIDOMNode->cloneNode(VARIANT_TRUE, &pIDOMNodeClone));

    // change 'version' = '*'
    IF_FAILED_EXIT(pIDOMNodeClone->QueryInterface(IID_IXMLDOMElement, (void**) &pIDOMElement));

    VariantInit(&varVersionWildcard);
    varVersionWildcard.vt = VT_BSTR;
    V_BSTR(&varVersionWildcard) = CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::VersionWildcard].bstr;
    IF_FAILED_EXIT(pIDOMElement->setAttribute(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Version].bstr, varVersionWildcard));

    SAFERELEASE(pIDOMElement);

    IF_FAILED_EXIT(pDependentAssemblyNode->appendChild(pIDOMNodeClone, NULL));

    IF_FAILED_EXIT(_pXMLDoc->createElement(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Install].bstr, &pIDOMElement));

    bstrManifestUrl = ::SysAllocString(pwzManifestUrl);
    IF_ALLOC_FAILED_EXIT(bstrManifestUrl);

    // bstrManifestUrl to be freed by VariantClear()
    varCodebase.vt = VT_BSTR;
    V_BSTR(&varCodebase) = bstrManifestUrl;
    IF_FAILED_EXIT(pIDOMElement->setAttribute(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Codebase].bstr, varCodebase));

    IF_FAILED_EXIT(pDependentAssemblyNode->appendChild(pIDOMElement, NULL));

exit:
    VariantClear(&varCodebase);

    SAFERELEASE(pDependentAssemblyNode);
    SAFERELEASE(pIDOMElement);
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pIDOMNodeClone);

    if (FAILED(_hr))
        SAFERELEASE(_pDependencyNode);

    return _hr;
}


// ---------------------------------------------------------------------------
// ImportAssemblyNode
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestEmit::ImportAssemblyNode(LPASSEMBLY_MANIFEST_IMPORT pManImport)
{
    VARIANT varNameSpaces;
    VARIANT varXPath;

    IXMLDOMDocument2 *pXMLDocSrc = NULL;
    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNode *pIDOMNodeClone = NULL;

    // note: _pXMLDoc, _pAssemblyNode must be NULL
    //     and this must be called _only and exactly once_


    // Create the DOM Doc interface
    IF_FAILED_EXIT(CoCreateInstance(__uuidof(private_MSXML_DOMDocument30), 
            NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, (void**)&_pXMLDoc));

    // Load synchronously
    IF_FAILED_EXIT(_pXMLDoc->put_async(VARIANT_FALSE));

    // Setup namespace filter
    VariantInit(&varNameSpaces);
    varNameSpaces.vt = VT_BSTR;
    V_BSTR(&varNameSpaces) = CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::NameSpace].bstr;
    IF_FAILED_EXIT(_pXMLDoc->setProperty(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::SelNameSpaces].bstr, varNameSpaces));

    // Setup query type
    VariantInit(&varXPath);
    varXPath.vt = VT_BSTR;
    V_BSTR(&varXPath) = CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::XPath].bstr;
    IF_FAILED_EXIT(_pXMLDoc->setProperty(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::SelLanguage].bstr, varXPath));

    // initialize manifest file: clone and insert 'assembly' node
    // by doing this, manifestVersion and other attributes are maintained

    pXMLDocSrc = ((CAssemblyManifestImport*)pManImport)->_pXMLDoc;

    // BUGBUG: this only pick the 1st instance of 'assembly'
    IF_FAILED_EXIT(pXMLDocSrc->selectSingleNode(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::AssemblyNode].bstr, &pIDOMNode));
    IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    // clone no child
    IF_FAILED_EXIT(pIDOMNode->cloneNode(VARIANT_FALSE, &pIDOMNodeClone));

    _hr = _pXMLDoc->appendChild(pIDOMNodeClone, &_pAssemblyNode);

exit:
    if (FAILED(_hr))
        SAFERELEASE(_pXMLDoc);

    SAFERELEASE(pIDOMNodeClone);
    SAFERELEASE(pIDOMNode);

    return _hr;
}


// ---------------------------------------------------------------------------
// Commit
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestEmit::Commit()
{
    // considered safe to be called multiple times
    VARIANT varFileName;

    if (_pXMLDoc)
    {
        // ignore any error occured before, do save anyway
        // it's caller's responsibility to track a incomplete xml manifest file/XMLDoc state
        VariantInit(&varFileName);
        varFileName.vt = VT_BSTR;
        V_BSTR(&varFileName) = _bstrManifestFilePath;

        _hr = _pXMLDoc->save(varFileName);
    }
    else
    {
        // not initialized
        _hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
    }

    return _hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\manifest\patchingutil.cpp ===
#include <fusenetincludes.h>
#include <msxml2.h>
#include <patchingutil.h>
#include <manifestinfo.h>
#include <manifestimport.h>


#define PATCH_DIRECTORY L"__patch__\\"

// ---------------------------------------------------------------------------
// CreatePatchingUtil
// ---------------------------------------------------------------------------
STDAPI CreatePatchingUtil(IXMLDOMNode *pPatchNode, LPPATCHING_INTERFACE* ppPatchingInfo)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CPatchingUtil *pPatchingInfo = NULL;
    
    IF_ALLOC_FAILED_EXIT(pPatchingInfo = new(CPatchingUtil));

    IF_FAILED_EXIT(pPatchingInfo->Init(pPatchNode));
        
    *ppPatchingInfo = static_cast<IPatchingUtil*> (pPatchingInfo);
    pPatchingInfo = NULL;

exit:

    SAFERELEASE(pPatchingInfo);
    return hr;

}

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CPatchingUtil::CPatchingUtil()
    : _dwSig('UATP'), _cRef(1), _hr(S_OK), _pXMLPatchNode(NULL)
{    

}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CPatchingUtil::~CPatchingUtil()
{
    SAFERELEASE(_pXMLPatchNode);
}

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CPatchingUtil::Init(IXMLDOMNode *pPatchNode)
{
    _hr = S_OK;
    _pXMLPatchNode = pPatchNode;
    _pXMLPatchNode->AddRef();
    return _hr;
}

// ---------------------------------------------------------------------------
// MatchTarget
// ---------------------------------------------------------------------------
HRESULT CPatchingUtil::MatchTarget(LPWSTR pwzTarget, IManifestInfo **ppPatchInfo)
{
    LPWSTR pwzBuf;
    DWORD ccBuf;
    CString sQueryString;    
    BSTR bstrtQueryString;

    IXMLDOMNode *pNode=NULL;
    IXMLDOMNodeList *pNodeList = NULL;
    LONG nNodes; 
    IManifestInfo *pPatchInfo = NULL;

    CString sSourceName, sPatchName, sTargetName;

    IF_FAILED_EXIT(sTargetName.Assign(pwzTarget));
   
    // set up serach string
    IF_FAILED_EXIT(sQueryString.Assign(L"PatchInfo[@file=\""));
    IF_FAILED_EXIT(sQueryString.Append(pwzTarget));
    IF_FAILED_EXIT(sQueryString.Append(L"\"] | PatchInfo[@target=\""));
    IF_FAILED_EXIT(sQueryString.Append(pwzTarget));
    IF_FAILED_EXIT(sQueryString.Append(L"\"]"));

    IF_ALLOC_FAILED_EXIT(bstrtQueryString = ::SysAllocString(sQueryString._pwz));

    IF_FAILED_EXIT(_pXMLPatchNode->selectNodes(bstrtQueryString, &pNodeList));

    IF_FAILED_EXIT(_hr = pNodeList->get_length(&nNodes));

    IF_FALSE_EXIT(nNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));

    IF_TRUE_EXIT(nNodes == 0, S_FALSE);

    IF_FALSE_EXIT(pNodeList->get_item(0, &pNode) == S_OK, E_FAIL);

    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_PATCH_INFO, &pPatchInfo));

    IF_FAILED_EXIT(pPatchInfo->Set(MAN_INFO_PATCH_INFO_TARGET, sTargetName._pwz, sTargetName.ByteCount(), MAN_INFO_FLAG_LPWSTR));

    IF_FAILED_EXIT(CAssemblyManifestImport::ParseAttribute(pNode, CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::File].bstr, &pwzBuf, &ccBuf));

    if(_hr == S_OK)
    {
        IF_FAILED_EXIT(sSourceName.TakeOwnership(pwzBuf, ccBuf));
    }
    else if (_hr == S_FALSE)
    {
        IF_FAILED_EXIT(CAssemblyManifestImport::ParseAttribute(pNode, CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Source].bstr,  &pwzBuf, &ccBuf));

        IF_FALSE_EXIT(_hr == S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));
        IF_FAILED_EXIT(sSourceName.TakeOwnership(pwzBuf, ccBuf));
    }

    IF_FAILED_EXIT(pPatchInfo->Set(MAN_INFO_PATCH_INFO_SOURCE, sSourceName._pwz, sSourceName.ByteCount(), MAN_INFO_FLAG_LPWSTR));
    
    IF_FAILED_EXIT(CAssemblyManifestImport::ParseAttribute(pNode, CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::PatchFile].bstr,  &pwzBuf, &ccBuf));

    IF_TRUE_EXIT(_hr == S_FALSE, S_OK);
    IF_FAILED_EXIT(sPatchName.TakeOwnership(pwzBuf, ccBuf));
    
    IF_FAILED_EXIT(pPatchInfo->Set(MAN_INFO_PATCH_INFO_PATCH, sPatchName._pwz, sPatchName.ByteCount(), MAN_INFO_FLAG_LPWSTR));

    *ppPatchInfo = pPatchInfo;
    pPatchInfo = NULL;
    
exit:
    if (bstrtQueryString)
        ::SysFreeString(bstrtQueryString);

    SAFERELEASE(pNode);
    SAFERELEASE(pNodeList);
    SAFERELEASE(pPatchInfo);
    
    return _hr;
}

// ---------------------------------------------------------------------------
// MatchPatch
// ---------------------------------------------------------------------------
HRESULT CPatchingUtil::MatchPatch(LPWSTR pwzPatch, IManifestInfo **ppPatchInfo)
{
    LPWSTR pwzBuf;
    DWORD ccBuf;
    CString sQueryString;    
    BSTR bstrtQueryString;

    IXMLDOMNode *pNode=NULL;
    IXMLDOMNodeList *pNodeList = NULL;
    LONG nNodes;
    
    IManifestInfo *pPatchInfo = NULL;

    CString sSourceName, sTargetName, sFileName, sPatchName;

    IF_FAILED_EXIT(sPatchName.Assign (pwzPatch));

    // set up serach string
    IF_FAILED_EXIT(sQueryString.Assign(L"PatchInfo[@patchfile=\""));
    IF_FAILED_EXIT(sQueryString.Append(pwzPatch));
    IF_FAILED_EXIT(sQueryString.Append(L"\"]"));

    IF_ALLOC_FAILED_EXIT(bstrtQueryString = ::SysAllocString(sQueryString._pwz));

    if ((_hr = _pXMLPatchNode->selectNodes(bstrtQueryString, &pNodeList)) != S_OK)
        goto exit;

    _hr = pNodeList->get_length(&nNodes);
    IF_FALSE_EXIT(nNodes <= 1, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));

    IF_FALSE_EXIT(pNodeList->get_item(0, &pNode) == S_OK, E_FAIL);

    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_PATCH_INFO, &pPatchInfo));

    IF_FAILED_EXIT(pPatchInfo->Set(MAN_INFO_PATCH_INFO_PATCH, sPatchName._pwz, sPatchName.ByteCount(), MAN_INFO_FLAG_LPWSTR));

    IF_FAILED_EXIT(CAssemblyManifestImport::ParseAttribute(pNode, CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::File].bstr, &pwzBuf, &ccBuf));

    if(_hr == S_OK)
    {
        IF_FAILED_EXIT(sSourceName.TakeOwnership(pwzBuf, ccBuf));
        IF_FAILED_EXIT(sTargetName.Assign(pwzBuf));
    }
    else if (_hr == S_FALSE)
    {
        IF_FALSE_EXIT(CAssemblyManifestImport::ParseAttribute(pNode, CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Source].bstr,  &pwzBuf, &ccBuf) == S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));

        IF_FAILED_EXIT(sSourceName.TakeOwnership(pwzBuf, ccBuf));

        IF_FALSE_EXIT(CAssemblyManifestImport::ParseAttribute(pNode, CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Target].bstr,  &pwzBuf, &ccBuf) == S_OK, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));

        IF_FAILED_EXIT(sTargetName.TakeOwnership(pwzBuf, ccBuf));

    }

    IF_FAILED_EXIT(pPatchInfo->Set(MAN_INFO_PATCH_INFO_SOURCE, sSourceName._pwz, sSourceName.ByteCount(), MAN_INFO_FLAG_LPWSTR));

    IF_FAILED_EXIT(pPatchInfo->Set(MAN_INFO_PATCH_INFO_TARGET, sTargetName._pwz, sTargetName.ByteCount(), MAN_INFO_FLAG_LPWSTR));

    *ppPatchInfo = pPatchInfo;
    pPatchInfo = NULL;
    _hr = S_OK;
    
exit:

    if (bstrtQueryString)
        ::SysFreeString(bstrtQueryString);

    SAFERELEASE(pNode);
    SAFERELEASE(pNodeList);
    SAFERELEASE(pPatchInfo);
    
    return _hr;
}


// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CPatchingUtil::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CPatchingUtil::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IPatchingUtil)
       )
    {
        *ppvObj = static_cast<IPatchingUtil*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CPatchingUtil::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CPatchingUtil::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CPatchingUtil::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CPatchingUtil::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

// ---------------------------------------------------------------------------
// CreatePatchingInfo
// ---------------------------------------------------------------------------
HRESULT CPatchingUtil::CreatePatchingInfo(IXMLDOMDocument2 *pXMLDOMDocument, IAssemblyCacheImport *pCacheImport, IManifestInfo **ppPatchingInfo)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwzBuf;
    DWORD cbBuf, ccBuf;
    CString sManifestDirectory, sSourceManifestDirectory, sTempDirectoryPath;
    CString sSourceAssemblyDisplayName;
    CString sQueryString;
    BSTR bstrtQueryString = NULL;
    IXMLDOMNodeList *pXMLMatchingNodeList = NULL;
    IXMLDOMNode *pXMLNode = NULL;
    IXMLDOMNode *pXMLASMNode = NULL;
    IAssemblyCacheImport  *pSourceASMImport = NULL;
    IAssemblyIdentity *pAssemblyId = NULL, *pSourceASMId =NULL;
    IAssemblyManifestImport *pManifestImport = NULL;
    IManifestInfo *pPatchingInfo = NULL;
    IPatchingUtil *pPatchingUtil = NULL;

    *ppPatchingInfo = NULL;


    //Get the manifest import from the pCacheImport so we can grab the AssemblyId
    IF_FAILED_EXIT(pCacheImport->GetManifestImport(&pManifestImport));

    //Get the assemblyID
    IF_FAILED_EXIT(pManifestImport->GetAssemblyIdentity(&pAssemblyId));

    SAFERELEASE(pManifestImport);

    IF_FAILED_EXIT(sQueryString.Assign(L"/assembly/Patch/SourceAssembly"));
    IF_ALLOC_FAILED_EXIT(bstrtQueryString = ::SysAllocString(sQueryString._pwz));

    if ((hr = pXMLDOMDocument->selectNodes(bstrtQueryString, &pXMLMatchingNodeList)) != S_OK)
        goto exit;

    pXMLMatchingNodeList->reset();

    //enumerate through the Source Assemblies
    while ((hr = pXMLMatchingNodeList->nextNode(&pXMLNode)) == S_OK)
    {
            //Get the first child under the SourceAssemly (this is the ASM Id)
           if ((hr = pXMLNode->get_firstChild (&pXMLASMNode)) != S_OK)
                goto exit;

            //Convert the XML node to an actuall ASM Id
            if ((hr = CAssemblyManifestImport::XMLtoAssemblyIdentity(pXMLASMNode, &pSourceASMId)) != S_OK)
                goto exit;

            //Check to see if the SourceAssembly exists in cache 
            // or if is the same as the Assembly we are currently downloading
            IF_FAILED_EXIT(CreateAssemblyCacheImport(&pSourceASMImport, pSourceASMId, CACHEIMP_CREATE_RETRIEVE));

            if (hr == S_FALSE)
            {
                IF_FAILED_EXIT(pSourceASMId->IsEqual(pAssemblyId));

                if (hr == S_OK)
                {
                    pSourceASMImport = pCacheImport;
                    pSourceASMImport->AddRef();
                }    
            }

            //Found a suitable SourceAssembly
            if (hr == S_OK) 
            {
                //Create a manifestInfo property bag
                IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_SOURCE_ASM, &pPatchingInfo));

                //Set the source ASMId in the property bag
                IF_FAILED_EXIT(pPatchingInfo->Set(MAN_INFO_SOURCE_ASM_ID, &pSourceASMId, 
                        sizeof(LPVOID), MAN_INFO_FLAG_IUNKNOWN_PTR));
           
                // grab the manifest directory
                IF_FAILED_EXIT(pCacheImport->GetManifestFileDir(&pwzBuf, &ccBuf));
                IF_FAILED_EXIT(sManifestDirectory.TakeOwnership(pwzBuf, ccBuf));

                //Set manifest Directory in patchingInfo property bag
                IF_FAILED_EXIT(pPatchingInfo->Set(MAN_INFO_SOURCE_ASM_INSTALL_DIR, sManifestDirectory._pwz, 
                        sManifestDirectory.ByteCount(), MAN_INFO_FLAG_LPWSTR));

                
                //grab directory of SourceAssembly
                IF_FAILED_EXIT(pSourceASMImport->GetManifestFileDir(&pwzBuf, &ccBuf));
                IF_FAILED_EXIT(sSourceManifestDirectory.TakeOwnership(pwzBuf, ccBuf));

                //Set SourceAssembly Directory in patchingInfo property bag
                IF_FAILED_EXIT(pPatchingInfo->Set(MAN_INFO_SOURCE_ASM_DIR, sSourceManifestDirectory._pwz, 
                        sSourceManifestDirectory.ByteCount(), MAN_INFO_FLAG_LPWSTR));


                //get display name of patch assembly identity
                IF_FAILED_EXIT(pSourceASMId->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &ccBuf));
                IF_FAILED_EXIT(sSourceAssemblyDisplayName.TakeOwnership (pwzBuf, ccBuf));

                //setup the path of the temporary directory
                IF_FAILED_EXIT(sTempDirectoryPath.Assign(sManifestDirectory));
                IF_FAILED_EXIT(DoPathCombine(sTempDirectoryPath, PATCH_DIRECTORY));
                IF_FAILED_EXIT(DoPathCombine(sTempDirectoryPath, sSourceAssemblyDisplayName._pwz));
                IF_FAILED_EXIT(sTempDirectoryPath.Append(L"\\"));

                //Set Temporary Directory in patchingInfo property bag
                IF_FAILED_EXIT(pPatchingInfo->Set(MAN_INFO_SOURCE_ASM_TEMP_DIR, sTempDirectoryPath._pwz, 
                        sTempDirectoryPath.ByteCount(), MAN_INFO_FLAG_LPWSTR));

                // Create patching info interface and insert into manifestInfo propertybag
                IF_FAILED_EXIT(CreatePatchingUtil(pXMLNode, &pPatchingUtil));
            
                IF_FAILED_EXIT(pPatchingInfo->Set(MAN_INFO_SOURCE_ASM_PATCH_UTIL, &pPatchingUtil, 
                            sizeof(LPVOID), MAN_INFO_FLAG_IUNKNOWN_PTR));
            }

        SAFERELEASE(pXMLNode);
        SAFERELEASE(pXMLASMNode);
        SAFERELEASE(pSourceASMId);
        SAFERELEASE(pSourceASMImport);

        if (pPatchingInfo)
        {
            *ppPatchingInfo = pPatchingInfo;
            pPatchingInfo = NULL;
            hr = S_OK;  // this is the successful case. 
            goto exit;
        }
    }

    IF_FAILED_EXIT(hr);

    // BUGBUG: what the hell is this?
    hr = S_FALSE;

exit:
    if (bstrtQueryString)
        ::SysFreeString(bstrtQueryString);

    SAFERELEASE(pManifestImport);
    SAFERELEASE(pXMLNode);
    SAFERELEASE(pXMLASMNode);
    SAFERELEASE(pSourceASMId);
    SAFERELEASE(pSourceASMImport);

    SAFERELEASE(pXMLMatchingNodeList);
    SAFERELEASE(pPatchingUtil);
    SAFERELEASE(pPatchingInfo);
    SAFERELEASE(pAssemblyId);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\manifest\manifestimportclr.cpp ===
#include <fusenetincludes.h>
#include <sxsapi.h>
#include <wchar.h>
#include <manifestimportCLR.h>

typedef HRESULT (*pfnGetAssemblyMDImport)(LPCWSTR szFileName, REFIID riid, LPVOID *ppv);
typedef BOOL (*pfnStrongNameTokenFromPublicKey)(LPBYTE, DWORD, LPBYTE*, LPDWORD);
typedef HRESULT (*pfnStrongNameErrorInfo)();
typedef VOID (*pfnStrongNameFreeBuffer)(LPBYTE);

pfnGetAssemblyMDImport g_pfnGetAssemblyMDImport = NULL;
pfnStrongNameTokenFromPublicKey g_pfnStrongNameTokenFromPublicKey = NULL;
pfnStrongNameErrorInfo g_pfnStrongNameErrorInfo = NULL;
pfnStrongNameFreeBuffer g_pfnStrongNameFreeBuffer = NULL;

HRESULT InitializeEEShim()
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HMODULE hMod;

    // BUGBUG - mscoree.dll never gets unloaded with increasing ref count.
    // what does URT do?
    hMod = LoadLibrary(TEXT("mscoree.dll"));

    IF_WIN32_FALSE_EXIT(hMod);

    g_pfnGetAssemblyMDImport = (pfnGetAssemblyMDImport)GetProcAddress(hMod, "GetAssemblyMDImport");
    g_pfnStrongNameTokenFromPublicKey = (pfnStrongNameTokenFromPublicKey)GetProcAddress(hMod, "StrongNameTokenFromPublicKey");
    g_pfnStrongNameErrorInfo = (pfnStrongNameErrorInfo)GetProcAddress(hMod, "StrongNameErrorInfo");           
    g_pfnStrongNameFreeBuffer = (pfnStrongNameFreeBuffer)GetProcAddress(hMod, "StrongNameFreeBuffer");


    if (!g_pfnGetAssemblyMDImport || !g_pfnStrongNameTokenFromPublicKey || !g_pfnStrongNameErrorInfo
        || !g_pfnStrongNameFreeBuffer) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        goto exit;
    }


exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CreateMetaDataImport
//-------------------------------------------------------------------
HRESULT CreateMetaDataImport(LPCOLESTR pszFilename, IMetaDataAssemblyImport **ppImport)
{
    HRESULT hr= S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    IF_FAILED_EXIT(InitializeEEShim());

    hr =  (*g_pfnGetAssemblyMDImport)(pszFilename, IID_IMetaDataAssemblyImport, (void **)ppImport);

    IF_TRUE_EXIT(hr == HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), hr);   // do not assert
    IF_FAILED_EXIT(hr);

exit:
    
    return hr;
}

//--------------------------------------------------------------------
// BinToUnicodeHex
//--------------------------------------------------------------------
HRESULT BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst)
{
    UINT x;
    UINT y;

    #define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))   
        
    for ( x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );  
        v = pSrc[x] & 0x0f;                 
        pDst[y++] = TOHEX( v ); 
    }                                    
    pDst[y] = '\0';

    return S_OK;
}

// ---------------------------------------------------------------------------
// CreateAssemblyManifestImportURT
// This is not used!
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyManifestImportCLR(LPCWSTR szManifestFilePath, IAssemblyManifestImport **ppImport)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CAssemblyManifestImportCLR *pImport = NULL;

    IF_ALLOC_FAILED_EXIT(pImport = new(CAssemblyManifestImportCLR));

    IF_FAILED_EXIT(pImport->Init(szManifestFilePath));

    *ppImport = (IAssemblyManifestImport*) pImport;
    pImport = NULL;

exit:

    SAFERELEASE(pImport);
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImportCLR constructor
// ---------------------------------------------------------------------------
CAssemblyManifestImportCLR::CAssemblyManifestImportCLR()
{
    _dwSig                  = 'INAM';
    _pName                  = NULL;
    _pMDImport              = NULL;
    _rAssemblyRefTokens     = NULL;
    _cAssemblyRefTokens     = 0;
    _rAssemblyModuleTokens  = NULL;
    _cAssemblyModuleTokens  = 0;
    *_szManifestFilePath    = TEXT('\0');
    _ccManifestFilePath     = 0;
    _hr                      = S_OK;
    _cRef                   = 1;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImportCLR destructor
// ---------------------------------------------------------------------------
CAssemblyManifestImportCLR::~CAssemblyManifestImportCLR()
{
     SAFERELEASE(_pName);
     SAFERELEASE(_pMDImport);
   
        
    SAFEDELETEARRAY(_rAssemblyRefTokens);
    SAFEDELETEARRAY(_rAssemblyModuleTokens);
}


// ---------------------------------------------------------------------------
// CAssembly::Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImportCLR::Init(LPCOLESTR szManifestFilePath)
{
    const cElems = ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE;

    IF_NULL_EXIT(szManifestFilePath, E_INVALIDARG);

    _ccManifestFilePath = lstrlenW(szManifestFilePath) + 1;
    memcpy(_szManifestFilePath, szManifestFilePath, _ccManifestFilePath * sizeof(WCHAR));

    IF_ALLOC_FAILED_EXIT(_rAssemblyRefTokens = new(mdAssemblyRef[cElems]));
    IF_ALLOC_FAILED_EXIT(_rAssemblyModuleTokens = new(mdFile[cElems]));

    // Create meta data importer if necessary.
    if (!_pMDImport)
    {
        // Create meta data importer
        _hr = CreateMetaDataImport((LPCOLESTR)_szManifestFilePath, &_pMDImport);

        IF_TRUE_EXIT(_hr == HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), _hr);
        IF_FAILED_EXIT(_hr);
    }


exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// GetAssemblyIdentity
// ---------------------------------------------------------------------------
HRESULT
CAssemblyManifestImportCLR::GetAssemblyIdentity(IAssemblyIdentity **ppName)
{
    WCHAR   szAssemblyName[MAX_CLASS_NAME];
    WCHAR   szDefaultAlias[MAX_CLASS_NAME];

    LPVOID    pvOriginator = NULL;
    DWORD   dwOriginator = 0;

    DWORD   dwFlags = 0, 
                  dwSize  = 0,
                  dwHashAlgId = 0,
                  ccDefaultAlias = MAX_CLASS_NAME;                  
    int           i;

    LPWSTR pwz = NULL;    
    ASSEMBLYMETADATA amd = {0};
    
    // If name doesn't exist, create one.
    if (!_pName)
    {        
        // Get the assembly token.
        mdAssembly mda;
        if(FAILED(_hr = _pMDImport->GetAssemblyFromScope(&mda)))
        {
            // This fails when called with managed module and not manifest. mg does such things.
            _hr = S_FALSE; // this will convert CLDB_E_RECORD_NOTFOUND (0x80131130) to S_FALSE;
            goto exit;
        }

        // Default allocation sizes.
        amd.ulProcessor = amd.ulOS = 32;
        amd.cbLocale = MAX_PATH;
        
        // Loop max 2 (try/retry)
        for (i = 0; i < 2; i++)
        {
            // Create an ASSEMBLYMETADATA instance.
            IF_FAILED_EXIT(AllocateAssemblyMetaData(&amd));

            // Get name and metadata
            IF_FAILED_EXIT(_pMDImport->GetAssemblyProps(             
                mda,            // [IN] The Assembly for which to get the properties.
                (const void **)&pvOriginator,  // [OUT] Pointer to the Originator blob.
                &dwOriginator,  // [OUT] Count of bytes in the Originator Blob.
                &dwHashAlgId,   // [OUT] Hash Algorithm.
                szAssemblyName, // [OUT] Buffer to fill with name.
                MAX_CLASS_NAME, // [IN]  Size of buffer in wide chars.
                &dwSize,        // [OUT] Actual # of wide chars in name.
                &amd,           // [OUT] Assembly MetaData.
                &dwFlags        // [OUT] Flags.                                                                
              ));

            // Check if retry necessary.
            if (!i)
            {
                if (amd.ulProcessor <= 32 && amd.ulOS <= 32)
                    break;
                else
                    DeAllocateAssemblyMetaData(&amd);
            }
        }
        
        // Allow for funky null locale convention
        // in metadata - cbLocale == 0 means szLocale ==L'\0'
        if (!amd.cbLocale)
        {           
            amd.cbLocale = 1;
        }
        else if (amd.szLocale)
        {
            WCHAR *ptr;
            ptr = StrChrW(amd.szLocale, L';');
            if (ptr)
            {
                (*ptr) = L'\0';
                amd.cbLocale = ((DWORD) (ptr - amd.szLocale) + sizeof(WCHAR));
            }          
        }
        else
        {
            _hr = E_FAIL;
            goto exit;
        }

        IF_FAILED_EXIT(CreateAssemblyIdentity(&_pName, NULL));

        //NAME
        IF_FAILED_EXIT(_pName->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, 
            (LPCOLESTR)szAssemblyName, lstrlenW(szAssemblyName) + 1));

        //Public Key Token
        if (dwOriginator)
        {
            LPBYTE pbPublicKeyToken = NULL;
            DWORD cbPublicKeyToken = 0;
            if (!(g_pfnStrongNameTokenFromPublicKey((LPBYTE)pvOriginator, dwOriginator, &pbPublicKeyToken, &cbPublicKeyToken)))
            {
                _hr = g_pfnStrongNameErrorInfo();
                goto exit;
            }

            IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[cbPublicKeyToken*2 +1]);
            IF_FAILED_EXIT( BinToUnicodeHex(pbPublicKeyToken, cbPublicKeyToken, pwz));
            IF_FAILED_EXIT(_pName->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, 
                    (LPCOLESTR)pwz, lstrlenW(pwz) + 1));
            SAFEDELETEARRAY(pwz);
            g_pfnStrongNameFreeBuffer(pbPublicKeyToken);
        }

        //Language
        if (!(*amd.szLocale))
            IF_FAILED_EXIT(_pName->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, 
                L"x-ww\0", lstrlenW(L"x-ww") + 1));
        else
            IF_FAILED_EXIT(_pName->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, 
                (LPCOLESTR)amd.szLocale, lstrlenW(amd.szLocale) + 1));


        //Version
        IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[MAX_PATH+1]);
        int j = 0;

        j = wnsprintf(pwz, MAX_PATH, L"%hu.%hu.%hu.%hu\0", amd.usMajorVersion,
                amd.usMinorVersion, amd.usBuildNumber, amd.usRevisionNumber);

        if(j <0)
        {
            _hr = E_FAIL;
            goto exit;
        }

        IF_FAILED_EXIT(_pName->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, 
            (LPCOLESTR)pwz, lstrlenW(pwz) + 1));

        //Architecture
        IF_FAILED_EXIT(_pName->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
            (LPCOLESTR)L"x86", lstrlenW(L"x86") + 1));
        
    }

    // Point to the name, addref it and hand it out.
    *ppName = _pName;
    (*ppName)->AddRef();
    _hr = S_OK;

exit:

    SAFEDELETEARRAY(pwz);
    DeAllocateAssemblyMetaData(&amd);
    return _hr;
}


// ---------------------------------------------------------------------------
// CAssemblyManifestImportCLR::GetNextAssembly
// ---------------------------------------------------------------------------
HRESULT
CAssemblyManifestImportCLR::GetNextAssembly(DWORD nIndex, IManifestInfo **ppDependAsm)
{
    HCORENUM    hEnum           = 0;  
    DWORD       cTokensMax      = 0;

    WCHAR  szAssemblyName[MAX_PATH];


    const VOID*             pvOriginator = 0;
    const VOID*             pvHashValue    = NULL;

    DWORD ccAssemblyName = MAX_PATH,
          cbOriginator   = 0,
          ccLocation     = MAX_PATH,
          cbHashValue    = 0,
          dwRefFlags     = 0;

    INT i;

    LPWSTR pwz=NULL;

    IManifestInfo *pDependAsm=NULL;
    IAssemblyIdentity *pAsmId=NULL;
    
    mdAssemblyRef    mdmar;
    ASSEMBLYMETADATA amd = {0};
    
    // Check to see if this import object
    // already has a dep assembly ref token array.
    if (!_cAssemblyRefTokens)
    {    
        // Attempt to get token array. If we have insufficient space
        // in the default array we will re-allocate it.
        if (FAILED(_hr = _pMDImport->EnumAssemblyRefs(
            &hEnum, 
            _rAssemblyRefTokens, 
            ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE, 
            &cTokensMax)))
        {
            goto done;
        }
        
        // Number of tokens known. close enum.
        _pMDImport->CloseEnum(hEnum);
        hEnum = 0;

        // No dependent assemblies.
        if (!cTokensMax)
        {
            _hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }

        // Insufficient array size. Grow array.
        if (cTokensMax > ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE)
        {
            // Re-allocate space for tokens.
            SAFEDELETEARRAY(_rAssemblyRefTokens);
            _cAssemblyRefTokens = cTokensMax;
            _rAssemblyRefTokens = new(mdAssemblyRef[_cAssemblyRefTokens]);
            if (!_rAssemblyRefTokens)
            {
                _hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Re-get tokens.        
            if (FAILED(_hr = _pMDImport->EnumAssemblyRefs(
                &hEnum, 
                _rAssemblyRefTokens, 
                cTokensMax, 
                &_cAssemblyRefTokens)))
            {
                goto exit;
            }

            // Close enum.
            _pMDImport->CloseEnum(hEnum);            
            hEnum = 0;
        }
        // Otherwise, the default array size was sufficient.
        else
        {
            _cAssemblyRefTokens = cTokensMax;
        }
    }        

done:


    // Verify the index passed in. 
    if (nIndex >= _cAssemblyRefTokens)
    {
        _hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto exit;
    }

    // Reference indexed dep assembly ref token.
    mdmar = _rAssemblyRefTokens[nIndex];

    // Default allocation sizes.
    amd.ulProcessor = amd.ulOS = 32;
    amd.cbLocale = MAX_PATH;
    
    // Loop max 2 (try/retry)
    for (i = 0; i < 2; i++)
    {
        // Allocate ASSEMBLYMETADATA instance.
        IF_FAILED_EXIT(AllocateAssemblyMetaData(&amd));
   
        // Get the properties for the refrenced assembly.
        IF_FAILED_EXIT(_pMDImport->GetAssemblyRefProps(
            mdmar,              // [IN] The AssemblyRef for which to get the properties.
            &pvOriginator,      // [OUT] Pointer to the PublicKeyToken blob.
            &cbOriginator,      // [OUT] Count of bytes in the PublicKeyToken Blob.
            szAssemblyName,     // [OUT] Buffer to fill with name.
            MAX_PATH,     // [IN] Size of buffer in wide chars.
            &ccAssemblyName,    // [OUT] Actual # of wide chars in name.
            &amd,               // [OUT] Assembly MetaData.
            &pvHashValue,       // [OUT] Hash blob.
            &cbHashValue,       // [OUT] Count of bytes in the hash blob.
            &dwRefFlags         // [OUT] Flags.
            ));

        // Check if retry necessary.
        if (!i)
        {   
            if (amd.ulProcessor <= 32 
                && amd.ulOS <= 32)
            {
                break;
            }            
            else
                DeAllocateAssemblyMetaData(&amd);
        }

    // Retry with updated sizes
    }

    // Allow for funky null locale convention
    // in metadata - cbLocale == 0 means szLocale ==L'\0'
    if (!amd.cbLocale)
    {
        amd.cbLocale = 1;
    }
    else if (amd.szLocale)
    {
        WCHAR *ptr;
        ptr = StrChrW(amd.szLocale, L';');
        if (ptr)
        {
            (*ptr) = L'\0';
            amd.cbLocale = ((DWORD) (ptr - amd.szLocale) + sizeof(WCHAR));
        }            
    }
    else
    {
        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }

    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_DEPENDTANT_ASM, &pDependAsm));

    IF_FAILED_EXIT(CreateAssemblyIdentity(&pAsmId, NULL));

    //Name
    IF_FAILED_EXIT(pAsmId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, 
        (LPCOLESTR)szAssemblyName, lstrlenW(szAssemblyName) + 1));

    //Public Key Token
    if (cbOriginator)
    {
        IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[cbOriginator*2 +1]);
        IF_FAILED_EXIT(BinToUnicodeHex((LPBYTE)pvOriginator, cbOriginator, pwz));
        IF_FAILED_EXIT(pAsmId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, 
            (LPCOLESTR)pwz, lstrlenW(pwz) + 1));
        SAFEDELETEARRAY(pwz);

    }

    //Language
    if (!(*amd.szLocale))
        IF_FAILED_EXIT(pAsmId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, 
            L"x-ww\0", lstrlenW(L"x-ww") + 1));
    else
        IF_FAILED_EXIT(pAsmId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, 
            (LPCOLESTR)amd.szLocale, lstrlenW(amd.szLocale) + 1));

    //Version
    IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[MAX_PATH+1]);
    int j = 0;

    j = wnsprintf(pwz, MAX_PATH, L"%hu.%hu.%hu.%hu\0", amd.usMajorVersion,
            amd.usMinorVersion, amd.usBuildNumber, amd.usRevisionNumber);

    if(j <0)
    {
        _hr = E_FAIL;
        goto exit;
    }

    IF_FAILED_EXIT(pAsmId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, 
        (LPCOLESTR)pwz, lstrlenW(pwz) + 1));
    SAFEDELETEARRAY(pwz);
    
    //Architecture
    IF_FAILED_EXIT(pAsmId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
        (LPCOLESTR)L"x86", lstrlenW(L"x86") + 1));

    // Handout refcounted assemblyid.
    IF_FAILED_EXIT(pDependAsm->Set(MAN_INFO_DEPENDENT_ASM_ID, &pAsmId, 
                                     sizeof(LPVOID), MAN_INFO_FLAG_IUNKNOWN_PTR));

    *ppDependAsm = pDependAsm;
    pDependAsm = NULL;
    // _hr = S_OK;
exit:        
    DeAllocateAssemblyMetaData(&amd);

    SAFERELEASE(pAsmId);
    SAFERELEASE(pDependAsm);
    SAFEDELETEARRAY(pwz);

    return _hr;
}


// ---------------------------------------------------------------------------
// CAssemblyManifestImportCLR::GetNextAssemblyFile
// ---------------------------------------------------------------------------
HRESULT
CAssemblyManifestImportCLR::GetNextFile(DWORD nIndex, IManifestInfo **ppFileInfo)
{
    HCORENUM    hEnum           = 0;  
    DWORD       cTokensMax      = 0;

    LPWSTR pszName = NULL;
    DWORD ccPath   = 0;
    WCHAR szModulePath[MAX_PATH];

    mdFile                  mdf;
    WCHAR                   szModuleName[MAX_PATH];
    DWORD                   ccModuleName   = MAX_PATH;
    const VOID*             pvHashValue    = NULL;    
    DWORD                   cbHashValue    = 0;
    DWORD                   dwFlags        = 0;

    LPWSTR pwz=NULL;
    IManifestInfo *pFileInfo=NULL;

    // Check to see if this import object
    // already has a module token array.
    if (!_cAssemblyModuleTokens)
    {    
        // Attempt to get token array. If we have insufficient space
        // in the default array we will re-allocate it.
        if (FAILED(_hr = _pMDImport->EnumFiles(&hEnum, _rAssemblyModuleTokens, 
            ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE, &cTokensMax)))
        {
            goto done;
        }
        
        // Number of tokens known. close enum.
        _pMDImport->CloseEnum(hEnum);
        hEnum = 0;
        
        // No modules
        if (!cTokensMax)
        {
            _hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }

        if (cTokensMax > ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE)
        {
            // Insufficient array size. Grow array.
            _cAssemblyModuleTokens = cTokensMax;
            SAFEDELETEARRAY(_rAssemblyModuleTokens);
            _rAssemblyModuleTokens = new(mdFile[_cAssemblyModuleTokens]);
            if (!_rAssemblyModuleTokens)
            {
                _hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Re-get tokens.        
            if (FAILED(_hr = _pMDImport->EnumFiles(
                &hEnum, 
                _rAssemblyModuleTokens, 
                cTokensMax, 
                &_cAssemblyModuleTokens)))
            {
                goto exit;
            }

            // Close enum.
            _pMDImport->CloseEnum(hEnum);            
            hEnum = 0;
        }        
        // Otherwise, the default array size was sufficient.
        else
            _cAssemblyModuleTokens = cTokensMax;
    }

done:

    // Verify the index. 
    if (nIndex >= _cAssemblyModuleTokens)
    {
        _hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto exit;
    }

    // Reference indexed dep assembly ref token.
    mdf = _rAssemblyModuleTokens[nIndex];

    // Get the properties for the refrenced assembly.
    IF_FAILED_EXIT(_pMDImport->GetFileProps(
        mdf,            // [IN] The File for which to get the properties.
        szModuleName,   // [OUT] Buffer to fill with name.
        MAX_CLASS_NAME, // [IN] Size of buffer in wide chars.
        &ccModuleName,  // [OUT] Actual # of wide chars in name.
        &pvHashValue,   // [OUT] Pointer to the Hash Value Blob.
        &cbHashValue,   // [OUT] Count of bytes in the Hash Value Blob.
        &dwFlags));     // [OUT] Flags.

    IF_FAILED_EXIT(CreateManifestInfo(MAN_INFO_FILE, &pFileInfo));

    //NAME
    IF_FAILED_EXIT(pFileInfo->Set(MAN_INFO_ASM_FILE_NAME, szModuleName, (ccModuleName+1)*(sizeof(WCHAR)), MAN_INFO_FLAG_LPWSTR));

    //HASH
    if (cbHashValue)
    {
        IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[cbHashValue*2 +1]);
        IF_FAILED_EXIT(_hr = BinToUnicodeHex((LPBYTE)pvHashValue, cbHashValue, pwz));
        IF_FAILED_EXIT(pFileInfo->Set(MAN_INFO_ASM_FILE_HASH, pwz, (sizeof(pwz)+1)*(sizeof(WCHAR)), MAN_INFO_FLAG_LPWSTR));
        SAFEDELETEARRAY(pwz);
    }

    *ppFileInfo = pFileInfo;
    pFileInfo = NULL;
    // _hr = S_OK;

exit:
    SAFERELEASE(pFileInfo);
    SAFEDELETEARRAY(pwz);

    return _hr;
}


HRESULT CAssemblyManifestImportCLR::ReportManifestType(DWORD *pdwType)
{
    *pdwType = MANIFEST_TYPE_COMPONENT;
    return S_OK;
}


//Functions not implemented
HRESULT CAssemblyManifestImportCLR::GetSubscriptionInfo(IManifestInfo **ppSubsInfo)
{
    return E_NOTIMPL;
}

HRESULT CAssemblyManifestImportCLR::GetNextPlatform(DWORD nIndex, IManifestData **ppPlatformInfo)
{
    return E_NOTIMPL;
}

HRESULT CAssemblyManifestImportCLR::GetManifestApplicationInfo(IManifestInfo **ppAppInfo)
{
    return E_NOTIMPL;
}

HRESULT CAssemblyManifestImportCLR::QueryFile(LPCOLESTR pwzFileName,IManifestInfo **ppAssemblyFile)
{
    return E_NOTIMPL;
}


// ---------------------------------------------------------------------------
// CAssemblyManifestImport::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestImportCLR::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyManifestImport)
       )
    {
        *ppvObj = static_cast<IAssemblyManifestImport*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImportCLR::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImportCLR::AddRef()
{
    return _cRef++;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImportCLR::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImportCLR::Release()
{
    if (--_cRef == 0) {
        delete this;
        return 0;
    }

    return _cRef;
}

// Creates an ASSEMBLYMETADATA struct for write.
STDAPI
AllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    // Re/Allocate Locale array
    SAFEDELETEARRAY(pamd->szLocale);        

    if (pamd->cbLocale) {
        IF_ALLOC_FAILED_EXIT(pamd->szLocale = new(WCHAR[pamd->cbLocale]));
    }

    // Re/Allocate Processor array
    SAFEDELETEARRAY(pamd->rProcessor);
    IF_ALLOC_FAILED_EXIT(pamd->rProcessor = new(DWORD[pamd->ulProcessor]));

    // Re/Allocate OS array
    SAFEDELETEARRAY(pamd->rOS);
    IF_ALLOC_FAILED_EXIT(pamd->rOS = new(OSINFO[pamd->ulOS]));

exit:
    if (FAILED(hr) && pamd)
        DeAllocateAssemblyMetaData(pamd);

    return hr;
}


STDAPI
DeAllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd)
{
    // NOTE - do not 0 out counts
    // since struct may be reused.

    pamd->cbLocale = 0;
    SAFEDELETEARRAY(pamd->szLocale);

    SAFEDELETEARRAY(pamd->rProcessor);
    SAFEDELETEARRAY(pamd->rOS);

    return S_OK;
}

STDAPI
DeleteAssemblyMetaData(ASSEMBLYMETADATA *pamd)
{
    DeAllocateAssemblyMetaData(pamd);
    delete pamd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\mg\util.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Globalization;
using System.Xml;

namespace Microsoft.Fusion.ADF
{
	// A utility class with various useful functions.
	public class Util
	{
		public static string ByteArrToString(Byte[] bArr, string format) 
		{
			if(bArr == null) return "";
			StringBuilder sb = new StringBuilder();
			if(format == null) format = "x02";
			foreach(Byte b in bArr)
			{
				sb.Append(b.ToString(format));
			}
			return sb.ToString();
		}

		public static void CSharpXmlCodeGenerator(XmlNode node, StreamWriter sw, string xmlWriterName)
		{
			try
			{
				switch (node.NodeType)
				{
					case XmlNodeType.Text:
						sw.WriteLine(xmlWriterName + ".WriteString(\"" + node.Value + "\");");
						break;

					case XmlNodeType.Element:
						sw.WriteLine(xmlWriterName + ".WriteStartElement(\"" + node.LocalName + "\");");
						XmlAttributeCollection attrColl = node.Attributes;
						if(attrColl != null)
						{
							IEnumerator attrEnum = attrColl.GetEnumerator();
							while (attrEnum.MoveNext())
							{
								XmlAttribute attr = (XmlAttribute) attrEnum.Current;
								sw.WriteLine(xmlWriterName + ".WriteAttributeString(\"" +
									attr.Prefix + "\", \"" +
									attr.LocalName + "\", " +
									"null" + ", \"" +
									attr.Value + "\");");
							}
						}
						if(node.HasChildNodes)
						{
							XmlNodeList nodeList = node.ChildNodes;
							IEnumerator nodeEnum = nodeList.GetEnumerator();
							while (nodeEnum.MoveNext())
							{
								XmlNode currNode = (XmlNode) nodeEnum.Current;
								CSharpXmlCodeGenerator(currNode, sw, xmlWriterName);
							}
						}
						sw.WriteLine(xmlWriterName + ".WriteEndElement();");
						break;
				}
			}
			catch (XmlException e)
			{
				throw new XmlException("Error in Util", e);
			}
		}

		public static void InjectNode(XmlNode node, XmlTextWriter xtw, bool writeEnclosingNode, bool writeAttributes)
		{
			try
			{
				switch (node.NodeType)
				{
					case XmlNodeType.Text:
						xtw.WriteString(node.Value);
						break;

					case XmlNodeType.Element:
						if(writeEnclosingNode) xtw.WriteStartElement(node.LocalName);
						if(writeAttributes)
						{
							XmlAttributeCollection attrColl = node.Attributes;
							if(attrColl != null)
							{
								IEnumerator attrEnum = attrColl.GetEnumerator();
								while (attrEnum.MoveNext())
								{
									XmlAttribute attr = (XmlAttribute) attrEnum.Current;
									xtw.WriteAttributeString(attr.Prefix, attr.LocalName, null, attr.Value);
								}
							}
						}

						if(node.HasChildNodes)
						{
							XmlNodeList nodeList = node.ChildNodes;
							IEnumerator nodeEnum = nodeList.GetEnumerator();
							while (nodeEnum.MoveNext())
							{   
								XmlNode currNode = (XmlNode) nodeEnum.Current;
								InjectNode(currNode, xtw, true, true);
							}
						}
						if(writeEnclosingNode) xtw.WriteEndElement();
						break;

					default:
						break;
				}
			}
			catch (XmlException e)
			{
				throw new XmlException("Error in Util", e);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\manifest\platform.cpp ===
#include <fusenetincludes.h>
#include <assemblycache.h>
#include <msxml2.h>
#include <manifestimport.h>
#include <manifestdata.h>
#include <dbglog.h>


// fwd declaration
HRESULT CheckPlatform(LPMANIFEST_DATA pPlatformData);


// return: 0 for all satisfied
HRESULT CheckPlatformRequirementsEx(LPASSEMBLY_MANIFEST_IMPORT pManifestImport,
        CDebugLog* pDbgLog, LPDWORD pdwNumMissingPlatforms, LPTPLATFORM_INFO* pptPlatform)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD dwCount = 0;
    DWORD dwMissingCount = 0;
    LPMANIFEST_DATA pPlatformList = NULL;
    LPMANIFEST_DATA pPlatformData = NULL;
    DWORD cbProperty = 0, dwType = 0;
    LPASSEMBLY_IDENTITY pAsmId = NULL;
    LPTPLATFORM_INFO ptPlatform = NULL;
    LPWSTR pwzId = NULL;
    DWORD dwCC = 0;

    IF_NULL_EXIT(pManifestImport, E_INVALIDARG);
    IF_NULL_EXIT(pdwNumMissingPlatforms, E_INVALIDARG);
    IF_NULL_EXIT(pptPlatform, E_INVALIDARG);

    *pdwNumMissingPlatforms = 0;
    *pptPlatform = NULL;

    IF_FAILED_EXIT(CreateManifestData(L"platform list", &pPlatformList));

    IF_FAILED_EXIT(pManifestImport->GetNextPlatform(dwCount, &pPlatformData));
    while (hr == S_OK)
    {
        if (pDbgLog)
        {
            SAFEDELETEARRAY(pwzId);
            IF_FAILED_EXIT(pPlatformData->GetType(&pwzId));
            IF_NULL_EXIT(pwzId, E_FAIL);

            IF_FAILED_EXIT(FusionCompareString(pwzId, WZ_DATA_PLATFORM_MANAGED, 0));
            if (hr == S_OK)
            {
                SAFEDELETEARRAY(pwzId);
                IF_FAILED_EXIT(pPlatformData->Get(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::AssemblyIdTag].pwz,
                        (LPVOID*) &pAsmId, &cbProperty, &dwType));
                IF_NULL_EXIT(pAsmId, E_FAIL);
                IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_IUNKNOWN_PTR, E_FAIL);

                IF_FAILED_EXIT(pAsmId->GetDisplayName(0, &pwzId, &dwCC));
                SAFERELEASE(pAsmId);
            }
        }

        IF_FAILED_EXIT(CheckPlatform(pPlatformData));
        if (hr == S_FALSE)
        {
            IF_FALSE_EXIT(dwMissingCount < dwMissingCount+1, HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));
            dwMissingCount++;

            // ISSUE-06/07/02-felixybc  use linked-list instead?
            IF_FAILED_EXIT((static_cast<CManifestData*>(pPlatformList))->Set(dwMissingCount, (LPVOID) pPlatformData, sizeof(LPVOID), MAN_DATA_TYPE_IUNKNOWN_PTR));

            if (pDbgLog)
            {
                DEBUGOUT1(pDbgLog, 1, L" LOG: Missing dependent platform, id: %s", pwzId);
            }
        }
        else if (pDbgLog)
        {
            DEBUGOUT1(pDbgLog, 1, L" LOG: Found dependent platform, id: %s", pwzId);
        }

        SAFERELEASE(pPlatformData);

        IF_FALSE_EXIT(dwCount < dwCount+1, HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));
        dwCount++;
        // platform data is returned in order
        IF_FAILED_EXIT(pManifestImport->GetNextPlatform(dwCount, &pPlatformData));
    }

    // assemble platform struct
    if (dwMissingCount > 0)
    {
        IF_ALLOC_FAILED_EXIT(ptPlatform = new TPLATFORM_INFO[dwMissingCount]);
        // ISSUE - zero out memory pointed by ptPlatform
        for (DWORD dw = 0; dw < dwMissingCount; dw++)
        {
            IF_FAILED_EXIT((static_cast<CManifestData*>(pPlatformList))->Get(dw+1, (LPVOID *)&pPlatformData, &cbProperty, &dwType));
            IF_NULL_EXIT(pPlatformData, E_FAIL);
            IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_IUNKNOWN_PTR, E_FAIL);

            // allow missing friendly name??
            IF_FAILED_EXIT(pPlatformData->Get(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::FriendlyName].pwz,
                    (LPVOID *)&((ptPlatform[dw]).pwzName), &cbProperty, &dwType));
            IF_NULL_EXIT(((ptPlatform[dw]).pwzName), E_FAIL);
            IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_LPWSTR, E_FAIL);

            IF_FAILED_EXIT(pPlatformData->Get(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::Href].pwz,
                    (LPVOID *)&((ptPlatform[dw]).pwzURL), &cbProperty, &dwType));
            // allow missing URL
            if ((ptPlatform[dw]).pwzURL != NULL)
            {
                IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_LPWSTR, E_FAIL);
            }

            // ISSUE-06/07/02-felixybc  for internal use, need a different way to return Codebase

            SAFERELEASE(pPlatformData);

            if (pDbgLog)
            {
                DEBUGOUT2(pDbgLog, 1, L" LOG: Missing dependent platform data, friendlyName: %s; codebase/URL: %s",
                    (ptPlatform[dw]).pwzName, (ptPlatform[dw]).pwzURL);
            }
        }
    }

    *pdwNumMissingPlatforms = dwMissingCount;
    *pptPlatform = ptPlatform;
     ptPlatform = NULL;

exit:
    if (FAILED(hr) && ptPlatform)
    {
        for (DWORD dw = 0; dw < dwMissingCount; dw++)
        {
            SAFEDELETEARRAY((ptPlatform[dw]).pwzName);
            SAFEDELETEARRAY((ptPlatform[dw]).pwzURL);
        }
        SAFEDELETEARRAY(ptPlatform);
    }

    SAFEDELETEARRAY(pwzId);

    SAFERELEASE(pAsmId);
    SAFERELEASE(pPlatformData);
    SAFERELEASE(pPlatformList);
    return hr;
}


// return: 0 for all satisfied
HRESULT CheckPlatformRequirements(LPASSEMBLY_MANIFEST_IMPORT pManifestImport,
        LPDWORD pdwNumMissingPlatforms, LPTPLATFORM_INFO* pptPlatform)
{
    return CheckPlatformRequirementsEx(pManifestImport, NULL, pdwNumMissingPlatforms, pptPlatform);
}


#define WZ_PLATFORM_OS_TYPE_WORKSTATION L"workstation"
#define WZ_PLATFORM_OS_TYPE_DOMAIN_CONTROLLER L"domainController"
#define WZ_PLATFORM_OS_TYPE_SERVER L"server"
#define WZ_PLATFORM_OS_SUITE_BACKOFFICE L"backoffice"
#define WZ_PLATFORM_OS_SUITE_BLADE L"blade"
#define WZ_PLATFORM_OS_SUITE_DATACENTER L"datacenter"
#define WZ_PLATFORM_OS_SUITE_ENTERPRISE L"enterprise"
#define WZ_PLATFORM_OS_SUITE_PERSONAL L"home"  // note: different text
#define WZ_PLATFORM_OS_SUITE_SMALLBUSINESS L"smallbusiness"
#define WZ_PLATFORM_OS_SUITE_SMALLBUSINESS_RESTRICTED L"smallbusinessRestricted"
#define WZ_PLATFORM_OS_SUITE_TERMINAL L"terminal"
// our addition/definition:
#define WZ_PLATFORM_OS_SUITE_PROFESSIONAL L"professional"
// return: S_OK
//          S_FALSE
//          E_*
HRESULT CheckOSHelper(LPMANIFEST_DATA pOSData)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwzBuf = NULL;
    LPDWORD pdwVal = NULL;
    DWORD cbProperty = 0;
    DWORD dwType = 0;
    OSVERSIONINFOEX osvi;
    DWORDLONG dwlConditionMask = 0;
    DWORD dwTypeMask = 0;
    BOOL bCheckProfessionalSuite = FALSE;
#define WORD_MAX 0xffff

    // verify type
    IF_FAILED_EXIT(pOSData->GetType(&pwzBuf));
    IF_FAILED_EXIT(FusionCompareString(WZ_DATA_OSVERSIONINFO, pwzBuf, 0));
    IF_FALSE_EXIT(hr == S_OK, E_INVALIDARG);
    SAFEDELETEARRAY(pwzBuf);

   // Initialize the OSVERSIONINFOEX structure.

   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

   for (CAssemblyManifestImport::eStringTableId i = CAssemblyManifestImport::MajorVersion; i <= CAssemblyManifestImport::ProductType; i++)
    {
        if (i >= CAssemblyManifestImport::MajorVersion && i <= CAssemblyManifestImport::ServicePackMinor)
        {
            IF_FAILED_EXIT(pOSData->Get(CAssemblyManifestImport::g_StringTable[i].pwz,
                    (LPVOID*) &pdwVal, &cbProperty, &dwType));
            if (pdwVal != NULL)
            {
                IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_DWORD, E_FAIL);

                switch (i)
                {
                    case CAssemblyManifestImport::MajorVersion:
                                                                                osvi.dwMajorVersion = *pdwVal;

                                                                                // Initialize the condition mask.
                                                                                VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION,
                                                                                    VER_GREATER_EQUAL );

                                                                                dwTypeMask |= VER_MAJORVERSION;
                                                                                break;
                    case CAssemblyManifestImport::MinorVersion:
                                                                                osvi.dwMinorVersion = *pdwVal;
                                                                                VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION,
                                                                                   VER_GREATER_EQUAL );
                                                                                dwTypeMask |= VER_MINORVERSION;
                                                                                break;
                    case CAssemblyManifestImport::BuildNumber:
                                                                                osvi.dwBuildNumber = *pdwVal;
                                                                                VER_SET_CONDITION( dwlConditionMask, VER_BUILDNUMBER,
                                                                                    VER_GREATER_EQUAL );
                                                                                dwTypeMask |= VER_BUILDNUMBER;
                                                                                break;
                    case CAssemblyManifestImport::ServicePackMajor:
                                                                                // WORD
                                                                                osvi.wServicePackMajor = (WORD) ((*pdwVal) & WORD_MAX);
                                                                                VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR,
                                                                                    VER_GREATER_EQUAL );
                                                                                dwTypeMask |= VER_SERVICEPACKMAJOR;
                                                                                break;
                    case CAssemblyManifestImport::ServicePackMinor:
                                                                                // WORD
                                                                                osvi.wServicePackMinor = (WORD) ((*pdwVal) & WORD_MAX);
                                                                                VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMINOR,
                                                                                    VER_GREATER_EQUAL );
                                                                                dwTypeMask |= VER_SERVICEPACKMINOR;
                                                                                break;
                    //default: should not happen
                }
                SAFEDELETEARRAY(pdwVal);
            }
        }
        else
        {
            IF_FAILED_EXIT(pOSData->Get(CAssemblyManifestImport::g_StringTable[i].pwz,
                    (LPVOID*) &pwzBuf, &cbProperty, &dwType));
            if (pwzBuf != NULL)
            {
                IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_LPWSTR, E_FAIL);
                if (i == CAssemblyManifestImport::ProductType)
                {
                    IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_TYPE_WORKSTATION, pwzBuf, 0));
                    if (hr == S_OK)
                        //VER_NT_WORKSTATION The system is running Windows NT 4.0 Workstation,
                        //    Windows 2000 Professional, Windows XP Home Edition, or Windows XP Professional.
                        osvi.wProductType = VER_NT_WORKSTATION;
                    else
                    {
                        IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_TYPE_DOMAIN_CONTROLLER, pwzBuf, 0));
                        if (hr == S_OK)
                            //VER_NT_DOMAIN_CONTROLLER The system is a domain controller. 
                            osvi.wProductType = VER_NT_DOMAIN_CONTROLLER;
                        else
                        {
                            IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_TYPE_SERVER, pwzBuf, 0));
                            if (hr == S_OK)
                                //VER_NT_SERVER The system is a server. 
                                osvi.wProductType = VER_NT_SERVER;
                            else
                            {
                                IF_FAILED_EXIT(E_FAIL);
                            }
                        }
                    }

                    VER_SET_CONDITION( dwlConditionMask, VER_PRODUCT_TYPE,
                        VER_EQUAL );
                    dwTypeMask |= VER_PRODUCT_TYPE;
                }
                else if (i == CAssemblyManifestImport::Suite)
                {
                    // ISSUE-06/07/02-felixybc  suite mask should allow specifying multiple with AND OR conditions
                    // use goto done to avoid indenting.
                    IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_BACKOFFICE, pwzBuf, 0));
                    if (hr == S_OK)
                        //VER_SUITE_BACKOFFICE Microsoft BackOffice components are installed.
                        osvi.wSuiteMask |= VER_SUITE_BACKOFFICE;
                    else
                    {
                        IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_BLADE, pwzBuf, 0));
                        if (hr == S_OK)
                            //VER_SUITE_BLADE Windows Web Server is installed.
                            osvi.wSuiteMask |= VER_SUITE_BLADE;
                        else
                        {
                            IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_DATACENTER, pwzBuf, 0));
                            if (hr == S_OK)
                                //VER_SUITE_DATACENTER Windows 2000 or Windows Datacenter Server is installed.
                                osvi.wSuiteMask |= VER_SUITE_DATACENTER;
                            else
                            {
                                IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_ENTERPRISE, pwzBuf, 0));
                                if (hr == S_OK)
                                    //VER_SUITE_ENTERPRISE Windows 2000 Advanced Server or Windows Enterprise Server is installed.
                                    osvi.wSuiteMask |= VER_SUITE_ENTERPRISE;
                                else
                                {
                                    IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_PERSONAL, pwzBuf, 0));
                                    if (hr == S_OK)
                                        //VER_SUITE_PERSONAL  Windows XP Home Edition is installed.
                                        osvi.wSuiteMask |= VER_SUITE_PERSONAL;
                                    else
                                    {
                                        IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_SMALLBUSINESS, pwzBuf, 0));
                                        if (hr == S_OK)
                                            //VER_SUITE_SMALLBUSINESS Microsoft Small Business Server is installed. 
                                            osvi.wSuiteMask |= VER_SUITE_SMALLBUSINESS;
                                        else
                                        {
                                            IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_SMALLBUSINESS_RESTRICTED, pwzBuf, 0));
                                            if (hr == S_OK)
                                                 //VER_SUITE_SMALLBUSINESS_RESTRICTED Microsoft Small Business Server is installed with the restrictive client license in force. 
                                                osvi.wSuiteMask |= VER_SUITE_SMALLBUSINESS_RESTRICTED;
                                            else
                                            {
                                                IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_TERMINAL, pwzBuf, 0));
                                                if (hr == S_OK)
                                                    //VER_SUITE_TERMINAL Terminal Services is installed.
                                                    osvi.wSuiteMask |= VER_SUITE_TERMINAL;
                                                else
                                                {
                                                    IF_FAILED_EXIT(FusionCompareString(WZ_PLATFORM_OS_SUITE_PROFESSIONAL, pwzBuf, 0));
                                                    if (hr == S_OK)
                                                        bCheckProfessionalSuite = TRUE;
                                                    else
                                                    {
                                                        IF_FAILED_EXIT(E_FAIL);
                                                    }
                                                }
                                                // more from winnt.h..
                                                //#define VER_SUITE_COMMUNICATIONS
                                                //#define VER_SUITE_EMBEDDEDNT
                                                //#define VER_SUITE_SINGLEUSERTS
                                                //#define VER_SUITE_EMBEDDED_RESTRICTED
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // ISSUE-06/07/02-felixybc  assume AND condition
                    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME,
                        VER_AND );
                    dwTypeMask |= VER_SUITENAME;
                }
                //else should not happen
                    //hr = E_FAIL;

                SAFEDELETEARRAY(pwzBuf);
            }
        }
    }

   // ISSUE-06/07/02-felixybc  assume nt only
   osvi.dwPlatformId = VER_PLATFORM_WIN32_NT;
   VER_SET_CONDITION( dwlConditionMask, VER_PLATFORMID, 
      VER_EQUAL );
   dwTypeMask |= VER_PLATFORMID;

   // Perform the test

   BOOL bResult = VerifyVersionInfo(
      &osvi, 
      dwTypeMask,
      dwlConditionMask);

    if (!bResult)
    {
        DWORD dw = GetLastError();
        if (dw != ERROR_OLD_WIN_VERSION)
            hr = HRESULT_FROM_WIN32(dw);
        else
            hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
        if (bCheckProfessionalSuite)
        {
            // do "professional" - do a GetVersionEx after to check suite

            // ISSUE-06/14/02-felixybc  check 'professional'. API has no notion of professional
            //   assume "not home" == "professional"
            //   note: type==workstation for Home/Pro but suite==Home for Home

            OSVERSIONINFOEX osvx;
            ZeroMemory(&osvx, sizeof(OSVERSIONINFOEX));
            osvx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
            IF_WIN32_FALSE_EXIT(GetVersionEx((OSVERSIONINFO*) &osvx));
            if ((osvx.wSuiteMask & VER_SUITE_PERSONAL) || (osvx.wProductType != VER_NT_WORKSTATION))
            {
                hr = S_FALSE;
            }
        }
    }

exit:
    SAFEDELETEARRAY(pwzBuf);
    SAFEDELETEARRAY(pdwVal);
    return hr;
}


HRESULT CheckOS(LPMANIFEST_DATA pPlatformData)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD dwCount = 0;
    LPMANIFEST_DATA pOSData = NULL;
    DWORD cbProperty = 0;
    DWORD dwType = 0;
    BOOL bFound = FALSE;

    while (TRUE)
    {
        // test a list of versions - as soon as 1 is satisfied, this check succeeds

        IF_FAILED_EXIT((static_cast<CManifestData*>(pPlatformData))->Get(dwCount,
            (LPVOID*) &pOSData, &cbProperty, &dwType));
        if (pOSData == NULL)
            break;

        IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_IUNKNOWN_PTR, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));
        IF_FAILED_EXIT(CheckOSHelper(pOSData));
        if (hr == S_OK)
        {
            bFound = TRUE;
            break;
        }
        SAFERELEASE(pOSData);
        dwCount++;
    }

    if (bFound)
        hr = S_OK;
    else
        hr = S_FALSE;

exit:
    SAFERELEASE(pOSData);
    return hr;
}


HRESULT CheckDotNet(LPMANIFEST_DATA pPlatformData)
{
#define WZ_DOTNETREGPATH L"Software\\Microsoft\\.NetFramework\\Policy\\"
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD dwCount = 0;
    LPWSTR pwzVersion = NULL;
    DWORD cbProperty = 0;
    DWORD dwType = 0;
    CString sRegPath;
    CString sVersion;
    CString sBuildNum;
    CRegImport *pRegImport = NULL;
    BOOL bFound = FALSE;

    while (TRUE)
    {
        // test a list of versions - as soon as 1 is found, this check succeeds

        IF_FAILED_EXIT((static_cast<CManifestData*>(pPlatformData))->Get(dwCount,
            (LPVOID*) &pwzVersion, &cbProperty, &dwType));
        if (pwzVersion == NULL)
            break;

        IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_LPWSTR, HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));
        IF_FAILED_EXIT(sVersion.TakeOwnership(pwzVersion, cbProperty/sizeof(WCHAR)));
        pwzVersion = NULL;

        // xml format: <supportedRuntime version="v1.0.4122" />
        // registry layout: HKLM\software\microsoft\.netframework\policy\v1.0, value name=4122
        IF_FAILED_EXIT(sVersion.SplitLastElement(L'.', sBuildNum));

        IF_FAILED_EXIT(sRegPath.Assign(WZ_DOTNETREGPATH));
        IF_FAILED_EXIT(sRegPath.Append(sVersion));

        // note: require access to HKLM
        IF_FAILED_EXIT(CRegImport::Create(&pRegImport, sRegPath._pwz, HKEY_LOCAL_MACHINE));
        if (hr == S_OK)
        {
            IF_FAILED_EXIT(pRegImport->Check(sBuildNum._pwz, bFound));
            if (bFound)
                break;
            SAFEDELETE(pRegImport);
        }
        dwCount++;
    }

    if (bFound)
        hr = S_OK;
    else
        hr = S_FALSE;

exit:
    SAFEDELETEARRAY(pwzVersion);
    SAFEDELETE(pRegImport);
    return hr;
}


HRESULT CheckManagedPlatform(LPMANIFEST_DATA pPlatformData)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPASSEMBLY_IDENTITY pAsmId = NULL;
    DWORD cbProperty = 0;
    DWORD dwType = 0;
    CString sAsmPath;

    // ISSUE-06/07/02-felixybc  apply policy also; use Fusion's PreBind

    IF_FAILED_EXIT(pPlatformData->Get(CAssemblyManifestImport::g_StringTable[CAssemblyManifestImport::AssemblyIdTag].pwz,
        (LPVOID*) &pAsmId, &cbProperty, &dwType));
    IF_NULL_EXIT(pAsmId, E_FAIL);
    IF_FALSE_EXIT(dwType == MAN_DATA_TYPE_IUNKNOWN_PTR, E_FAIL);

    IF_FAILED_EXIT(CAssemblyCache::GlobalCacheLookup(pAsmId, sAsmPath));

exit:
    SAFERELEASE(pAsmId);
    return hr;
}


HRESULT CheckPlatform(LPMANIFEST_DATA pPlatformData)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CString    sPlatformType;
    LPWSTR    pwzBuf = NULL;

    // get the platform type
    IF_FAILED_EXIT(pPlatformData->GetType(&pwzBuf));
    IF_NULL_EXIT(pwzBuf, E_FAIL);
    // use accessor.
    IF_FAILED_EXIT(sPlatformType.TakeOwnership(pwzBuf));
    pwzBuf = NULL;

    IF_FAILED_EXIT(sPlatformType.CompareString(WZ_DATA_PLATFORM_OS));
    if (hr == S_OK)
    {
        IF_FAILED_EXIT(CheckOS(pPlatformData));
    }
    else
    {
        IF_FAILED_EXIT(sPlatformType.CompareString(WZ_DATA_PLATFORM_DOTNET));
        if (hr == S_OK)
        {
            IF_FAILED_EXIT(CheckDotNet(pPlatformData));
        }
        else
        {
            /*IF_FAILED_EXIT(sName.CompareString(DX));
            if (hr == S_OK)
            {
                IF_FAILED_EXIT(CheckDirectX(pPlatformData));
            }
            else
            {*/
                IF_FAILED_EXIT(sPlatformType.CompareString(WZ_DATA_PLATFORM_MANAGED));
                if (hr == S_OK)
                {
                    IF_FAILED_EXIT(CheckManagedPlatform(pPlatformData));
                }
                else
                    hr = E_FAIL;
            //}
        }
    }

exit:
    SAFEDELETEARRAY(pwzBuf);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\manifest\manifestinfo.cpp ===
#include <fusenetincludes.h>
#include <manifestinfo.h>

// Must be in the same order as the MAN_INFO enumeration in fusenet.idl
DWORD CPropertyArray::max_params[MAN_INFO_MAX] = {
        MAN_INFO_ASM_FILE_MAX,
        MAN_INFO_APPLICATION_MAX,
        MAN_INFO_SUBSCRIPTION_MAX,
        MAN_INFO_DEPENDANT_ASM_MAX,
        MAN_INFO_SOURCE_ASM_MAX,
        MAN_INFO_PATCH_INFO_MAX,
    };


// ---------------------------------------------------------------------------
// CreatePropertyArray
// ---------------------------------------------------------------------------
STDAPI CreatePropertyArray(DWORD dwType, CPropertyArray** ppPropertyArray)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CPropertyArray *pPropArray = NULL;

    *ppPropertyArray = NULL;

    IF_ALLOC_FAILED_EXIT(pPropArray = new (CPropertyArray));

    IF_FAILED_EXIT(pPropArray->Init(dwType));

    *ppPropertyArray = pPropArray;
    pPropArray = NULL;

exit:

    SAFEDELETE(pPropArray);
    return hr;
}

// ---------------------------------------------------------------------------
// CPropertyArray ctor
// ---------------------------------------------------------------------------
CPropertyArray::CPropertyArray()
    :  _dwType(0),  _rProp(NULL)
{
    _dwSig = 'PORP';
}

// ---------------------------------------------------------------------------
// CPropertyArray dtor
// ---------------------------------------------------------------------------
CPropertyArray::~CPropertyArray()
{
    for (DWORD i = 0; i < max_params[_dwType]; i++)
    {
        if (_rProp[i].flag ==  MAN_INFO_FLAG_IUNKNOWN_PTR)
        {
                IUnknown *pUnk =  ((IUnknown*) _rProp[i].pv);
                SAFERELEASE(pUnk);
        }

        if (_rProp[i].cb > sizeof(DWORD))
            SAFEDELETEARRAY(_rProp[i].pv);
    }
    SAFEDELETEARRAY(_rProp);
}


// ---------------------------------------------------------------------------
// CPropertyArray::Init
// ---------------------------------------------------------------------------
HRESULT CPropertyArray::Init(DWORD dwType)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    _dwType = dwType;
    IF_ALLOC_FAILED_EXIT(_rProp = new Property[max_params[dwType]]);

    memset(_rProp, 0, max_params[dwType]* sizeof(Property));

exit:
    return hr;
}
    
// ---------------------------------------------------------------------------
// CPropertyArray::Set
// ---------------------------------------------------------------------------
HRESULT CPropertyArray::Set(DWORD PropertyId, 
    LPVOID pvProperty, DWORD cbProperty, DWORD flag)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    Property *pItem ;

    if (PropertyId > max_params[_dwType])
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pItem = &(_rProp[PropertyId]);

    if (!cbProperty && !pvProperty)
    {
        if (pItem->cb > sizeof(DWORD))
            SAFEDELETEARRAY(pItem->pv);

        pItem->pv = NULL;
    }
    else if (cbProperty > sizeof(DWORD))
    {
        LPBYTE ptr = NULL;

        IF_ALLOC_FAILED_EXIT(ptr = new (BYTE[cbProperty]));

        if (pItem->cb > sizeof(DWORD))
            SAFEDELETEARRAY(pItem->pv);

        memcpy(ptr, pvProperty, cbProperty);        
        pItem->pv = ptr;
    }
    else
    {
        if (pItem->cb > sizeof(DWORD))
            SAFEDELETEARRAY(pItem->pv);

        memcpy(&(pItem->pv), pvProperty, cbProperty);
    }
    pItem->cb = cbProperty;
    pItem->flag = flag;

exit:
    return hr;
}     


// ---------------------------------------------------------------------------
// CPropertyArray::Get
// ---------------------------------------------------------------------------
HRESULT CPropertyArray::Get(DWORD PropertyId, 
    LPVOID pvProperty, LPDWORD pcbProperty, DWORD *flag)
{
    HRESULT hr = S_OK;
    Property *pItem;    

    if ((!pvProperty && *pcbProperty) || (PropertyId > max_params[_dwType]))
    {
        hr = E_INVALIDARG;
        goto exit;
    }        

    pItem = &(_rProp[PropertyId]);

    if (pItem->cb > *pcbProperty)
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    else if (pItem->cb)
    {
        memcpy(pvProperty, (pItem->cb > sizeof(DWORD) ? 
            pItem->pv : (LPBYTE) &(pItem->pv)), pItem->cb);
    }

    *pcbProperty = pItem->cb;
    *flag = pItem->flag;
        
exit:
    return hr;
}     


// ---------------------------------------------------------------------------
// GetType
// ---------------------------------------------------------------------------
HRESULT CPropertyArray::GetType(DWORD *pdwType)
{
    *pdwType = _dwType;
    return S_OK;
}

// ---------------------------------------------------------------------------
// CPropertyArray::operator []
// Wraps DWORD optimization test.
// ---------------------------------------------------------------------------
Property CPropertyArray::operator [] (DWORD PropertyId)
{
    Property Prop;

    Prop.pv = _rProp[PropertyId].cb > sizeof(DWORD) ?
        _rProp[PropertyId].pv : &(_rProp[PropertyId].pv);

    Prop.cb = _rProp[PropertyId].cb;

    return Prop;
}


// ---------------------------------------------------------------------------
// CreateManifestInfo
// ---------------------------------------------------------------------------
STDAPI CreateManifestInfo(DWORD dwType, LPMANIFEST_INFO* ppManifestInfo)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CManifestInfo *pManifestInfo = NULL;

    IF_ALLOC_FAILED_EXIT(pManifestInfo = new(CManifestInfo));

    IF_FAILED_EXIT(pManifestInfo->Init(dwType));

    *ppManifestInfo = static_cast<IManifestInfo*> (pManifestInfo);
    pManifestInfo = NULL;

exit:

    SAFERELEASE(pManifestInfo);
    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CManifestInfo::CManifestInfo()
    : _dwSig('INAM'), _cRef(1), _hr(S_OK)
{    
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CManifestInfo::~CManifestInfo()
{
    SAFEDELETE(_properties);
}

// ---------------------------------------------------------------------------
// Set
// ---------------------------------------------------------------------------
HRESULT CManifestInfo::Set(DWORD PropertyId, LPVOID pvProperty, DWORD cbProperty, DWORD flag)
{
    IF_FAILED_EXIT( (*_properties).Set(PropertyId, pvProperty, cbProperty, flag));

    if (flag == MAN_INFO_FLAG_IUNKNOWN_PTR)
        (*(IUnknown**) pvProperty)->AddRef();
        
exit:
    return _hr;
}

// ---------------------------------------------------------------------------
// Get
// ---------------------------------------------------------------------------
HRESULT CManifestInfo::Get(DWORD PropertyId, LPVOID *ppvProperty, DWORD *pcbProperty, DWORD *pflag)
{
    DWORD flag;
    LPBYTE pbAlloc;
    DWORD cbAlloc;

    *ppvProperty = NULL;
    *pcbProperty = 0;

    // Get property size
    _hr = (*_properties).Get(PropertyId, NULL, &(cbAlloc = 0), &flag);
    if (_hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        // Property is set; alloc buf
        IF_ALLOC_FAILED_EXIT(pbAlloc = new(BYTE[cbAlloc]));

        // Get the property
        IF_FAILED_EXIT( (*_properties).Get(PropertyId, pbAlloc, &cbAlloc, &flag));

        if (flag == MAN_INFO_FLAG_IUNKNOWN_PTR)
        {
            memcpy(ppvProperty, pbAlloc, cbAlloc);
            ((IUnknown *)(*ppvProperty))-> AddRef();
            SAFEDELETEARRAY(pbAlloc);
        }
        else
            *ppvProperty = pbAlloc;
        
        *pcbProperty = cbAlloc;
        *pflag = flag;
    }
    else
    {
        // If property unset, hr should be S_OK
        if (_hr != S_OK)
            goto exit;
 
        // Success, returning 0 bytes, ensure buf is null.    
        *pflag = MAN_INFO_FLAG_UNDEF;
    }
exit:
    return _hr;

}

// ---------------------------------------------------------------------------
// IsEqual
// As of now, only valid to check equality of MAN_INFO_FILE property bags
// ---------------------------------------------------------------------------
HRESULT CManifestInfo::IsEqual(IManifestInfo  *pManifestInfo)
 {
    _hr = S_OK;
    DWORD dwType1, dwType2, cbBuf, dwFlag;
    LPWSTR pwzBuf1=NULL, pwzBuf2=NULL;

    GetType(&dwType1);
    pManifestInfo->GetType(&dwType2);

    if (dwType1 != MAN_INFO_FILE && dwType2 != MAN_INFO_FILE)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    for (DWORD i = MAN_INFO_ASM_FILE_NAME; i < MAN_INFO_ASM_FILE_MAX; i++)
    {
        // BUGBUG?: case sensitivity and issues?
        // BUGBUG?: locale?
        Get(i, (LPVOID *)&pwzBuf1, &cbBuf, &dwFlag);
        pManifestInfo->Get(i, (LPVOID *)&pwzBuf2, &cbBuf, &dwFlag);

        if ((pwzBuf1 && !pwzBuf2) || (!pwzBuf1 && pwzBuf2))
            _hr= S_FALSE;

        if(pwzBuf1 && pwzBuf2)
            IF_FAILED_EXIT(FusionCompareString(pwzBuf1, pwzBuf2, 0));
            
        SAFEDELETEARRAY(pwzBuf1);
        SAFEDELETEARRAY(pwzBuf2);

        // if one entry is false, no need to check the rest
        if (_hr == S_FALSE)
            break;
    }

    goto exit;

exit:    
    return _hr;
}


// ---------------------------------------------------------------------------
// GetType
// ---------------------------------------------------------------------------
HRESULT CManifestInfo::GetType(DWORD *pdwType)
{
    DWORD dwType;
    _hr = _properties->GetType(&dwType);
    *pdwType = dwType;
    return _hr;
}



// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CManifestInfo::Init(DWORD dwType)
{
    _hr = S_OK;
    if (dwType >= MAN_INFO_MAX)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

     _hr = CreatePropertyArray(dwType, &_properties);

exit:
    return _hr;
}

// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CManifestInfo::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CManifestInfo::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IManifestInfo)
       )
    {
        *ppvObj = static_cast<IManifestInfo*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CManifestInfo::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CManifestInfo::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CManifestInfo::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CManifestInfo::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\mime\activexmime.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "activexmime.h"

#include <wininet.h>

#define GOBACKHACK
#ifdef GOBACKHACK
#include <exdisp.h>   // for IWebBrowser2
#endif

#include "macros.h"

static const GUID CLSID_ActiveXMimePlayer = 
{ 0xFDCDCCE0, 0xCBC4, 0x49FB, { 0x85, 0x8D, 0x92, 0x53, 0xA6, 0xB8, 0x16, 0x1F} };

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CActiveXMimeClassFactory::CActiveXMimeClassFactory()
{
    _cRef = 1;
    _hr = S_OK;
}

// ----------------------------------------------------------------------------

HRESULT
CActiveXMimeClassFactory::QueryInterface(REFIID iid, void **ppv)
{
    _hr = S_OK;

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        _hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return _hr;
}

// ----------------------------------------------------------------------------

ULONG
CActiveXMimeClassFactory::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CActiveXMimeClassFactory::Release()
{
    LONG ulCount = InterlockedDecrement(&_cRef);

    if (ulCount <= 0)
    {
        delete this;
    }

    return (ULONG) ulCount;
}

HRESULT
CActiveXMimeClassFactory::LockServer(BOOL lock)
{
    if (lock)
        DllAddRef();
    else
        DllRelease();

    return (_hr = S_OK);
}

// ----------------------------------------------------------------------------

HRESULT
CActiveXMimeClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppv)
{
    _hr = S_OK;
    CActiveXMimePlayer *pMimePlayer = NULL;

    *ppv = NULL;

    IF_FALSE_EXIT(!pUnkOuter || iid == IID_IUnknown, CLASS_E_NOAGGREGATION);

    pMimePlayer = new CActiveXMimePlayer();
    IF_ALLOC_FAILED_EXIT(pMimePlayer);

    if (iid == IID_IUnknown)
    {
        *ppv = (IOleObject *)pMimePlayer;
        pMimePlayer->AddRef();
    }
    else
    {
        IF_FAILED_EXIT(pMimePlayer->QueryInterface(iid, ppv));
    }

exit:
    SAFERELEASE(pMimePlayer);

    return _hr;
}


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// CActiveXMimePlayer

CActiveXMimePlayer::CActiveXMimePlayer()
{
    _cRef = 1;
    _hr = S_OK;
}

CActiveXMimePlayer::~CActiveXMimePlayer()
{
}

// ----------------------------------------------------------------------------

HRESULT
CActiveXMimePlayer::QueryInterface(REFIID iid,  void** ppv)
{
    _hr = S_OK;
    *ppv = NULL;

    if (iid == IID_IOleObject ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleObject *)this;
    }
    else if (iid == IID_IObjectSafety)
    {
        *ppv = (IObjectSafety *)this;
    }
    else
    {
        _hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return _hr;
}

// ----------------------------------------------------------------------------

ULONG
CActiveXMimePlayer::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CActiveXMimePlayer::Release()
{
    LONG ulCount = InterlockedDecrement(&_cRef);

    if (ulCount <= 0)
    {
        delete this;
    }

    return (ULONG) ulCount;
}

// ----------------------------------------------------------------------------

//////////////////////////////////////////////
// IOleObject interface


HRESULT
CActiveXMimePlayer::SetClientSite(IOleClientSite *pClientSite)
{
    _hr = S_OK;

    if (pClientSite != NULL)
    {
        // Obtain URL from container moniker.
        IMoniker* pmk = NULL;

        if (SUCCEEDED(_hr = pClientSite->GetMoniker(
                                    OLEGETMONIKER_TEMPFORUSER,
                                    OLEWHICHMK_CONTAINER,
                                    &pmk)))
        {
            LPOLESTR pwzDisplayName = NULL;

            if (SUCCEEDED(_hr = pmk->GetDisplayName(NULL, NULL, &pwzDisplayName)))
            {
                _hr = _sURL.Assign(pwzDisplayName);
                CoTaskMemFree((LPVOID)pwzDisplayName);

                // _hr from _sURL.Assign() above
                if (SUCCEEDED(_hr) && FAILED(StartManifestHandler(_sURL)))
                    MessageBox(NULL, L"Error downloading manifest or starting manifest handler. Cannot continue.", L"ClickOnce", MB_OK | MB_ICONEXCLAMATION);
            }
        }

        SAFERELEASE(pmk);

        if (FAILED(_hr))
            MessageBox(NULL, L"Error accessing manifest URL.", L"ClickOnce", MB_OK | MB_ICONEXCLAMATION);

#ifdef GOBACKHACK
        // ask IE to go back instead of staying in the blank page
        IServiceProvider* pISP = NULL;
        if (SUCCEEDED(_hr = pClientSite->QueryInterface(IID_IServiceProvider, (void **)&pISP)))
        {
            IWebBrowser2* pIWebBrowser2 = NULL;
            if (SUCCEEDED(_hr = pISP->QueryService(IID_IWebBrowserApp, IID_IWebBrowser2, (void **)&pIWebBrowser2)))
            {
//                if (FAILED(
                    _hr = pIWebBrowser2->GoBack();//))
// NOTICE-2002/03/12-felixybc  Go back can fail if new IE window with no viewed page, Start Run url, or Internet Shortcut
//     should close IE window instead?
            }
            SAFERELEASE(pIWebBrowser2);
        }

        SAFERELEASE(pISP);
#endif
    }

   return S_OK;
}


HRESULT
CActiveXMimePlayer::GetClientSite(IOleClientSite **ppClientSite)
{
    _hr = S_OK;
    if (ppClientSite == NULL)
        _hr = E_INVALIDARG;
    else
        *ppClientSite = NULL;   // return clientsite?
    return _hr;
}


HRESULT
CActiveXMimePlayer::SetHostNames(LPCOLESTR szContainerApp,
            /* [in] */ 
        LPCOLESTR szContainerObj)
            /* [unique][in] */ 
{
    // note: can check the name of container app here

    return (_hr = S_OK);
}


HRESULT
CActiveXMimePlayer::Close(DWORD dwSaveOption)
            /* [in] */ 
{
    return (_hr = S_OK);
}


HRESULT
CActiveXMimePlayer::SetMoniker(DWORD dwWhichMoniker,
            /* [in] */
        IMoniker *pmk)
            /* [unique][in] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::GetMoniker(DWORD dwAssign,
            /* [in] */
        DWORD dwWhichMoniker,
            /* [in] */
        IMoniker **ppmk)
            /* [out] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::InitFromData(IDataObject *pDataObject,
            /* [unique][in] */
        BOOL fCreation,
            /* [in] */
        DWORD dwReserved)
            /* [in] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::GetClipboardData(DWORD dwReserved,
            /* [in] */
        IDataObject **ppDataObject)
            /* [out] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::DoVerb(LONG iVerb,
            /* [in] */
        LPMSG lpmsg,
            /* [unique][in] */
        IOleClientSite *pActiveSite,
            /* [unique][in] */
        LONG lindex,
            /* [in] */
        HWND hwndParent,
            /* [in] */
        LPCRECT lprcPosRect)
            /* [unique][in] */
{
    return (_hr = OLEOBJ_E_NOVERBS); //E_NOTIMPL;
}


HRESULT
CActiveXMimePlayer::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
            /* [out] */
{
    return (_hr = OLEOBJ_E_NOVERBS); //E_NOTIMPL;
}


HRESULT
CActiveXMimePlayer::Update( void)
{
    return (_hr = S_OK);
}


HRESULT
CActiveXMimePlayer::IsUpToDate( void)
{
    return (_hr = S_OK); //OLE_E_UNAVAILABLE;
}


HRESULT
CActiveXMimePlayer::GetUserClassID(CLSID *pClsid)
{
    if (pClsid != NULL)
    {
        *pClsid = CLSID_ActiveXMimePlayer;
         _hr = S_OK;
    }
    else
        _hr = E_INVALIDARG;

    return _hr;
}


HRESULT
CActiveXMimePlayer::GetUserType(DWORD dwFormOfType,
            /* [in] */
        LPOLESTR *pszUserType)
            /* [out] */
{
    return (_hr = OLE_S_USEREG); //E_NOTIMPL;
}


HRESULT
CActiveXMimePlayer::SetExtent(DWORD dwDrawAspect,
            /* [in] */
        SIZEL *psizel)
            /* [in] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::GetExtent(DWORD dwDrawAspect,
            /* [in] */
        SIZEL *psizel)
            /* [out] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::Advise(IAdviseSink *pAdvSink,
            /* [unique][in] */
        DWORD *pdwConnection)
            /* [out] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::Unadvise(DWORD dwConnection)
            /* [in] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
            /* [out] */
{
    return (_hr = E_NOTIMPL);
}


HRESULT
CActiveXMimePlayer::GetMiscStatus(DWORD dwAspect,
        DWORD *pdwStatus)
{
    _hr = S_OK;

    // ignore dwAspect
    if (pdwStatus == NULL)
        _hr = E_INVALIDARG;
    else
        *pdwStatus = OLEMISC_SETCLIENTSITEFIRST | OLEMISC_NOUIACTIVATE; //OLEMISC_INVISIBLEATRUNTIME
    return _hr;
}


HRESULT
CActiveXMimePlayer::SetColorScheme(LOGPALETTE *pLogpal)
{
    return (_hr = E_NOTIMPL);
}


//////////////////////////////////////////////
// IOjbectSafety interface

HRESULT
CActiveXMimePlayer::GetInterfaceSafetyOptions(REFIID riid,
        DWORD* pdwSupportedOptions,
        DWORD* pdwEnabledOptions)
{
    _hr = S_OK;

    // regardless riid

    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        _hr = E_INVALIDARG;
    else
    {
        // do _not_ support safe for scripting - INTERFACESAFE_FOR_UNTRUSTED_CALLER
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return _hr;
}


HRESULT
CActiveXMimePlayer::SetInterfaceSafetyOptions(REFIID riid,
        DWORD dwOptionSetMask,
        DWORD dwEnabledOptions)
{
    _hr = E_FAIL;

    if (riid == IID_IDispatch)
    {
        // do _not_ support IDispatch interface
        // The dwOptionSetMask parameter specifies an option that is not supported by the object.
        _hr = E_FAIL;
    }
    else //if (riid == IID_IPersist)   // IID_IPersist*? what about IID_IUnknown?
    {
        // regardless riid

        // only acknowledge if only INTERFACESAFE_FOR_UNTRUSTED_DATA is passed in
        if (dwOptionSetMask == INTERFACESAFE_FOR_UNTRUSTED_DATA)
            _hr = S_OK;    // The object is safe for loading.
        else
            _hr = E_FAIL;
    }

    return _hr;
}


// ----------------------------------------------------------------------------

#define DEFAULT_PATH_LEN MAX_PATH
#define TEMP_FILE_NAME_LEN sizeof("preuuuu.TMP")    // from msdn
HRESULT
CActiveXMimePlayer::StartManifestHandler(CString& sURL) 
{
    HKEY hkey = NULL;
    DWORD dwcbData = 0;
    DWORD dwType = 0;
    LONG lReturn = 0;
    CString sOpenCommand;
    CString sCmdLine;
    LPWSTR pwzOpenCommand = NULL;

    CString sTempPath;

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);

    // check if sURL empty (including ending L'\0')
    // note: could do better check here, eg. check for http://
    IF_FALSE_EXIT(sURL._cc > 1, E_INVALIDARG);

    // assemble temp file path

    IF_FAILED_EXIT(sTempPath.ResizeBuffer(DEFAULT_PATH_LEN));

    {
        // ISSUE-2002/03/12-felixybc  GetTempPath can overrun the buffer?
        DWORD dwLen = GetTempPath(DEFAULT_PATH_LEN, sTempPath._pwz);

        IF_WIN32_FALSE_EXIT(dwLen);

        if (dwLen >= DEFAULT_PATH_LEN)
        {
            // resize, add 1 for terminating null
            IF_FAILED_EXIT(sTempPath.ResizeBuffer(dwLen+1));

            DWORD dwLenNew = GetTempPath(dwLen+1, sTempPath._pwz);

            IF_WIN32_FALSE_EXIT(dwLenNew);

            IF_FALSE_EXIT(dwLenNew < dwLen+1, E_FAIL);  // why is it still not enough?
        }
    }

    // why is the temp file created already?
    ASSERT(_sTempFile._pwz == NULL);

    {
        DWORD dwBufLen = lstrlen(sTempPath._pwz)+1;
        // note: can do a better check here
        IF_FALSE_EXIT(dwBufLen > 1, E_FAIL);

        // allocate buffer large enough for temp path and temp file name
        DWORD dwLenNew = (dwBufLen > DEFAULT_PATH_LEN)? dwBufLen : DEFAULT_PATH_LEN;
        dwLenNew += TEMP_FILE_NAME_LEN;

        // check for overflow
        IF_FALSE_EXIT(dwLenNew > dwBufLen, E_FAIL);

        IF_FAILED_EXIT(_sTempFile.ResizeBuffer(dwLenNew));

        *(_sTempFile._pwz) = L'\0';

        // note: temp file to be deleted by the child handler process created below
        IF_WIN32_FALSE_EXIT(GetTempFileName(sTempPath._pwz, L"FMA", 0, _sTempFile._pwz));    // fusion manifest file
    }

    IF_FAILED_EXIT(DownloadInternetFile(sURL, _sTempFile._pwz));

    // get the execution string (esp. path) from reg key


    // ISSUE-2002/03/21-adriaanc 
    // This code should live in regclass.cpp and CRegImport/CRegEmit should accept
    // a root hive handle and fall back to HKCU if not provided.

    // HKEY_CLASSES_ROOT\manifestfile\shell\Open\command
    lReturn = RegOpenKeyEx(HKEY_CLASSES_ROOT, L"manifestfile\\shell\\Open\\command", 0,
        KEY_EXECUTE | KEY_QUERY_VALUE, &hkey);
    IF_WIN32_FAILED_EXIT(lReturn);    

    lReturn = RegQueryValueEx(hkey, NULL, NULL, &dwType, NULL, &dwcbData);
    IF_WIN32_FAILED_EXIT(lReturn);
    IF_FALSE_EXIT(dwcbData, E_FAIL);

    // validate reg value type
    IF_FALSE_EXIT(dwType == REG_SZ || dwType == REG_EXPAND_SZ, E_UNEXPECTED);

    {
        // Allocate for call to RQEX, with one extra char in case
        // returned buffer is not null terminated.
        LPWSTR pwz = NULL;
        DWORD dwStrLen = dwcbData / sizeof(WCHAR);
        DWORD dwBufLen = dwStrLen+1;
        CStringAccessor<CString> acc;
        
        // Allocate and call RQVEX
        IF_ALLOC_FAILED_EXIT(pwzOpenCommand = new WCHAR[dwBufLen]);
        lReturn = RegQueryValueEx(hkey, NULL, NULL,
            &dwType, (LPBYTE) pwzOpenCommand, &dwcbData);

        IF_WIN32_FAILED_EXIT(lReturn);
        
        // Null terminate returned buffer.
        *(pwzOpenCommand + dwStrLen) = L'\0';

        // rundll32.exe fnsshell.dll,Start "%1" --> L"rundll32.exe fnsshell.dll,Start \"%s\" \"%s\""
        pwz = wcsrchr(pwzOpenCommand, L'%');
        IF_NULL_EXIT(pwz, E_FAIL);
        *pwz = L'\0';

        // Attach accessor, set buffer, detach with corrected length.
        IF_FAILED_EXIT(acc.Attach(sOpenCommand));
        *(&acc) = pwzOpenCommand;
        
        // Could avoid the strlen if we bothered to track the strlen.
        IF_FAILED_EXIT(acc.Detach());        
        // If Detach succeeds, reset pointer so that it is freed once.
        pwzOpenCommand = NULL;
    }
    
    // NTRAID#NTBUG9-574001-2002/03/12-felixybc  check format of the returned string value

    // assemble the command line

    
    IF_FAILED_EXIT(sCmdLine.Assign(sOpenCommand));
    IF_FAILED_EXIT(sCmdLine.Append(_sTempFile._pwz));
    IF_FAILED_EXIT(sCmdLine.Append(L"\" \""));
    IF_FAILED_EXIT(sCmdLine.Append(sURL));
    IF_FAILED_EXIT(sCmdLine.Append(L"\""));

    // start the process

    // NTRAID#NTBUG9-574001-2002/03/12-felixybc  string value needs proper format
    //   need quotes if executable path contains spaces, or instead pass lpApplicationName for better security
    //   rundll32.exe should be in c:\windows\system32
    IF_WIN32_FALSE_EXIT(CreateProcess(NULL, sCmdLine._pwz, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi));

exit:
    if(pi.hThread) CloseHandle(pi.hThread);
    if(pi.hProcess) CloseHandle(pi.hProcess);

    if (hkey)
        RegCloseKey(hkey);

    if (FAILED(_hr) && _sTempFile._pwz != NULL)
    {
        if (*(_sTempFile._pwz) != L'\0')
        {
            // ignore if error deleting the file
            DeleteFile(_sTempFile._pwz);
        }
        _sTempFile.FreeBuffer();
    }
    SAFEDELETEARRAY(pwzOpenCommand);
    return _hr;
}


// ----------------------------------------------------------------------------
// download file from url into path
HRESULT
CActiveXMimePlayer::DownloadInternetFile(CString& sUrl, 
        LPCWSTR pwzPath)
{
    HINTERNET    hInternet       = NULL;
    HINTERNET    hTransfer       = NULL;
    HANDLE        hFile           = INVALID_HANDLE_VALUE;
    DWORD        bytesRead       = 0;
    DWORD        bytesWritten    = 0;
    BYTE           *buffer = NULL;
    const DWORD dwBufferSize = 4096;
    BOOL            bReadOk = FALSE;

    _hr = S_OK;

    // check offline mode
/*    DWORD            dwState             = 0;
    DWORD            dwSize              = sizeof(DWORD);

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            // error!
    }*/

    // Step 1: Create the file
    // overwrites the file, if exists. file not shared
    hFile = CreateFile(pwzPath, GENERIC_WRITE, 0, NULL, 
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NOT_CONTENT_INDEXED|FILE_ATTRIBUTE_TEMPORARY,
                       NULL);

    IF_WIN32_FALSE_EXIT((hFile != INVALID_HANDLE_VALUE));

    // Step 2: Copy the files over the internet
    hInternet = InternetOpen(L"ManifestHandler", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    IF_WIN32_FALSE_EXIT((hInternet != NULL));

    // do not keep file in wininet cache
    hTransfer = InternetOpenUrl(hInternet, sUrl._pwz, NULL, 0, INTERNET_FLAG_NO_CACHE_WRITE, 0);
    IF_WIN32_FALSE_EXIT((hTransfer != NULL));

    // need to check if there's any error, eg. not found (404)...

    buffer = new BYTE[dwBufferSize];
    IF_ALLOC_FAILED_EXIT(buffer);
    
    // synchronous download
    while((bReadOk = InternetReadFile(hTransfer, buffer, dwBufferSize, &bytesRead)) && bytesRead != 0)
    {
        IF_WIN32_FALSE_EXIT(!( !WriteFile(hFile, buffer, bytesRead, &bytesWritten, NULL) || 
             bytesWritten != bytesRead  ));
    }

    IF_WIN32_FALSE_EXIT(bReadOk);
    
exit:
    SAFEDELETEARRAY(buffer);

    // ensure file/internet handles are closed 

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hTransfer != NULL)
        InternetCloseHandle(hTransfer);
    if (hInternet != NULL)
        InternetCloseHandle(hInternet);
    hInternet   = NULL;
    hTransfer   = NULL;
    hFile       = INVALID_HANDLE_VALUE;

    // note: caller's responsibility to delete the file

    return _hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\mime\mimedll.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "activexmime.h"

HINSTANCE g_DllInstance = NULL;
LONG      g_cRef=0;

//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{
    BOOL    ret = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // remember the instance
        g_DllInstance = hInst;
        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return ret;
}

//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
    // BUGBUG: should implement the registerserver
    return S_OK;
}


STDAPI DllUnregisterServer(void)
{
    // BUGBUG: should implement the unregisterserver
    return S_OK;
}


// ----------------------------------------------------------------------------
// DllAddRef
// ----------------------------------------------------------------------------

ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// DllRelease
// ----------------------------------------------------------------------------

ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// ----------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    return g_cRef > 0 ? S_FALSE : S_OK;
}

// ----------------------------------------------------------------------------

HRESULT 
GetActiveXMimeClassObject(REFIID iid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CActiveXMimeClassFactory *pActiveXMimeClassFactory = new CActiveXMimeClassFactory();
    if (pActiveXMimeClassFactory != NULL)
    {
        hr = pActiveXMimeClassFactory->QueryInterface(iid, ppv); 
        pActiveXMimeClassFactory->Release(); 
    }

    return hr;
}

// ----------------------------------------------------------------------------
  
STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (clsid == CLSID_ActiveXMimePlayer)
    {
        hr = GetActiveXMimeClassObject(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\mime\activexmime.h ===
#pragma once
#ifndef _MIME_DLL_H
#define _MIME_DLL_H

#include <objbase.h>
#include <windows.h>

#include <oleidl.h>
#include <objsafe.h>

#include <fusenetincludes.h>

// Clases and interfaces

class CActiveXMimeClassFactory: public IClassFactory
{
public:
    CActiveXMimeClassFactory	();

    // IUnknown Methods
    STDMETHOD_    (ULONG, AddRef)   ();
    STDMETHOD_    (ULONG, Release)  ();
    STDMETHOD     (QueryInterface)  (REFIID, void **);

    // IClassFactory Moethods
    STDMETHOD     (LockServer)      (BOOL);
    STDMETHOD     (CreateInstance)  (IUnknown*,REFIID,void**);

protected:
    long            _cRef;
    HRESULT    _hr;
};

class CActiveXMimePlayer : public IOleObject, public IObjectSafety
{
public:
    CActiveXMimePlayer     ();
    ~CActiveXMimePlayer    ();

    // IUnknown methods
    STDMETHOD_        (ULONG, AddRef)           ();
    STDMETHOD_        (ULONG, Release)          ();
    STDMETHOD         (QueryInterface)          (REFIID, void **);

    // IOleObject methods
    STDMETHOD (SetClientSite) (
        IOleClientSite *pClientSite);

    STDMETHOD (GetClientSite) (
        IOleClientSite **ppClientSite);

    STDMETHOD (SetHostNames) (
        LPCOLESTR szContainerApp,
        LPCOLESTR szContainerObj);

    STDMETHOD (Close) (
        DWORD dwSaveOption);

    STDMETHOD (SetMoniker) (
        DWORD dwWhichMoniker,
        IMoniker *pmk);

    STDMETHOD (GetMoniker) (
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        IMoniker **ppmk);

    STDMETHOD (InitFromData) (
        IDataObject *pDataObject,
        BOOL fCreation,
        DWORD dwReserved);

    STDMETHOD (GetClipboardData) (
        DWORD dwReserved,
        IDataObject **ppDataObject);

    STDMETHOD (DoVerb) (
        LONG iVerb,
        LPMSG lpmsg,
        IOleClientSite *pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect);

    STDMETHOD (EnumVerbs) (
        IEnumOLEVERB **ppEnumOleVerb);

    STDMETHOD (Update) ( void);

    STDMETHOD (IsUpToDate) ( void);

    STDMETHOD (GetUserClassID) (
        CLSID *pClsid);

    STDMETHOD (GetUserType) (
        DWORD dwFormOfType,
        LPOLESTR *pszUserType);

    STDMETHOD (SetExtent) (
        DWORD dwDrawAspect,
        SIZEL *psizel);

    STDMETHOD (GetExtent) (
        DWORD dwDrawAspect,
        SIZEL *psizel);

    STDMETHOD (Advise) (
        IAdviseSink *pAdvSink,
        DWORD *pdwConnection);
        
    STDMETHOD (Unadvise) (
        DWORD dwConnection);

    STDMETHOD (EnumAdvise) (
        IEnumSTATDATA **ppenumAdvise);

    STDMETHOD (GetMiscStatus) (
        DWORD dwAspect,
        DWORD *pdwStatus);

    STDMETHOD (SetColorScheme) (
        LOGPALETTE *pLogpal);

    // IOjbectSafety methods
    STDMETHOD (GetInterfaceSafetyOptions) (
        REFIID riid,
        DWORD* pdwSupportedOptions,
        DWORD* pdwEnabledOptions);

    STDMETHOD (SetInterfaceSafetyOptions) (
        REFIID riid,
        DWORD dwOptionSetMask,
        DWORD dwEnabledOptions);

protected:
    HRESULT            StartManifestHandler(CString& sURL);
    HRESULT            DownloadInternetFile(CString& sUrl, LPCWSTR pwzPath);

    long                _cRef;
    HRESULT         _hr;

    CString             _sURL;
    CString             _sTempFile;
};

extern const GUID CLSID_ActiveXMimePlayer;

#endif // _MIME_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\ndphost\manifestimport.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

namespace Microsoft.Fusion.ADF
{
	public enum FileType : int
	{
		Unknown = 0,
		RawFile = 1,
		ApplicationManifest = 2,
		ComponentManifest = 3
	}

	public interface IAssemblyManifestImport
	{
		AssemblyIdentity GetAssemblyIdentity();
		DependentFileInfo GetNextDependentFileInfo();
		DependentAssemblyInfo GetNextDependentAssemblyInfo();
		void ResetIterators();
		FileType GetFileType();
	}
	
	//----------------------------------------------------------
	// ApplicationManifestImport
	//----------------------------------------------------------
	public class ApplicationManifestImport : IAssemblyManifestImport
	{
		XmlDocument _xmlDocument;
		XPathNodeIterator _xPathFileIterator;
		XPathNodeIterator _xPathAssemblyIterator;
		
		AssemblyIdentity _assemblyIdentity;
		Uri _manifestUri;

		//----------------------------------------------------------
		// ctor
		//----------------------------------------------------------
		public ApplicationManifestImport(Uri manifestUri)
		{
			_manifestUri = manifestUri;
			_xmlDocument = new XmlDocument();
			_xmlDocument.Load(_manifestUri.ToString());
			_assemblyIdentity = GetAssemblyIdentity();

			_xPathFileIterator = null;
			_xPathAssemblyIterator = null;
		}

		//----------------------------------------------------------
		// GetActivationInfo	
		//----------------------------------------------------------
		public ActivationInfo GetActivationInfo()
		{
			XPathNavigator xPathNavigator = _xmlDocument.CreateNavigator();			
			XPathNodeIterator xPathNodeIterator =  xPathNavigator.Select ("/assembly/application/activation");
			if (xPathNodeIterator.MoveNext() == false)
				return null;
			ActivationInfo ai = new ActivationInfo();
			string assemblyName = xPathNodeIterator.Current.GetAttribute("assemblyName", "");
			string assemblyClass = xPathNodeIterator.Current.GetAttribute("assemblyClass", "");
			string assemblyMethod = xPathNodeIterator.Current.GetAttribute("assemblyMethod", "");
			string assemblyMethodArgs = xPathNodeIterator.Current.GetAttribute("assemblyMethodArgs", "");
			ai["assemblyName"] = assemblyName;
			ai["assemblyClass"] = assemblyClass;
			ai["assemblyMethod"] = assemblyMethod;
			ai["assemblyMethodArgs"] = assemblyMethodArgs;
			return ai;
		}

		//----------------------------------------------------------
		// GetAssemblyIdentity
		//----------------------------------------------------------
		public AssemblyIdentity GetAssemblyIdentity()
		{
			if (_assemblyIdentity != null)
				goto exit;

			XPathNavigator myXPathNavigator = _xmlDocument.CreateNavigator();			
			XPathNodeIterator myXPathNodeIterator =  myXPathNavigator.Select ("/assembly/assemblyIdentity");
			myXPathNodeIterator.MoveNext();
			_assemblyIdentity = XMLToAssemblyId(myXPathNodeIterator);

			exit:
				return _assemblyIdentity;
		}
	
		//----------------------------------------------------------
		// GetNextDependentFileInfo
		//----------------------------------------------------------
		public DependentFileInfo GetNextDependentFileInfo()
		{		
			if (_xPathFileIterator == null)
			{
				XPathNavigator myXPathNavigator = _xmlDocument.CreateNavigator();			
				_xPathFileIterator =  myXPathNavigator.Select ("/assembly/file");
			}
			
			if (_xPathFileIterator.MoveNext() == false)
				return null;

			DependentFileInfo dfi = new DependentFileInfo();
			dfi["name"] = _xPathFileIterator.Current.GetAttribute("name", "");
			dfi["hash"] = _xPathFileIterator.Current.GetAttribute("hash", "");
			return dfi;
		}
	
		//----------------------------------------------------------
		// GetNextDependentAssemblyInfo
		//----------------------------------------------------------
		public DependentAssemblyInfo GetNextDependentAssemblyInfo()
		{		
			if (_xPathAssemblyIterator == null)
			{
				XPathNavigator myXPathNavigator = _xmlDocument.CreateNavigator();			
				_xPathAssemblyIterator =  myXPathNavigator.Select ("/assembly/dependency/dependentAssembly");
			}
			
			if (_xPathAssemblyIterator.MoveNext() == false)
				return null;

			XPathNodeIterator asmIter = _xPathAssemblyIterator.Current.Select("assemblyIdentity");

			asmIter.MoveNext();
			DependentAssemblyInfo dai = new DependentAssemblyInfo();
			dai.assemblyIdentity = XMLToAssemblyId(asmIter);
			XPathNodeIterator installIter = _xPathAssemblyIterator.Current.Select("install");
			installIter.MoveNext();
			dai["codeBase"] = installIter.Current.GetAttribute("codebase", "");
			return dai;
		}

		//----------------------------------------------------------
		// XMLToAssemblyId
		//----------------------------------------------------------
		private AssemblyIdentity XMLToAssemblyId(XPathNodeIterator xPathNodeIterator)
		{
			AssemblyIdentity assemblyIdentity = new AssemblyIdentity();
			assemblyIdentity["name"] =xPathNodeIterator.Current.GetAttribute("name", "");
			assemblyIdentity["version"] =xPathNodeIterator.Current.GetAttribute("version", "");
			assemblyIdentity["processorArchitecture"] =xPathNodeIterator.Current.GetAttribute("processorArchitecture", "");
			assemblyIdentity["publicKeyToken"] =xPathNodeIterator.Current.GetAttribute("publicKeyToken", "");
			assemblyIdentity["language"] =xPathNodeIterator.Current.GetAttribute("language", "");
			return assemblyIdentity;
		}

		
		//----------------------------------------------------------
		// ResetIterators
		//----------------------------------------------------------
		public void ResetIterators()
		{
			_xPathAssemblyIterator = null;
			_xPathFileIterator = null;
		}

		//----------------------------------------------------------
		// GetFileType()
		//----------------------------------------------------------
		public FileType GetFileType()
		{
			return FileType.ApplicationManifest;
		}

		//----------------------------------------------------------
		// GetSecurityInfo
		//----------------------------------------------------------
		public SecurityInfo GetSecurityInfo()
		{
			XPathNavigator xPathNavigator = _xmlDocument.CreateNavigator();			
			XPathNodeIterator xPathNodeIterator =  xPathNavigator.Select ("/assembly/Security");

			if (xPathNodeIterator.MoveNext() == false)	
				return null;
			SecurityInfo si = new SecurityInfo();

			XPathNavigator xp = xPathNodeIterator.Current;
			//			XmlNode xmlNode = ((IHasXmlNode) xp).GetNode();
			XmlNode xmlNode = ((IHasXmlNode) xp).GetNode();
			si["Security"] = xmlNode.OuterXml;
			return si;
		}

	}

	
	//----------------------------------------------------------
	// AssemblyIdentity
	//----------------------------------------------------------
	public class AssemblyIdentity : Hashtable
	{ 
		public string GetDirectoryName()
		{
			string pa = (string) this["processorArchitecture"];
			string name = (string) this["name"];
			string version = (string) this["version"];
			string pkt = (string) this["publicKeyToken"];
			string lan = (string) this["language"];
			string appDirName =  pa + '_' + name + '_' + version + '_' + pkt + '_' + lan;
			return appDirName;
		}
	}

	//----------------------------------------------------------
	// StringTable
	//----------------------------------------------------------
	public class StringTable : Hashtable
	{
		public string this [string index]
		{
			get 	{ return (string) this[(object) index]; }
			set   { this[(object) index] = value; }
		}
	}
	
	//----------------------------------------------------------
	// DependentFileInfo
	//----------------------------------------------------------
	public class DependentFileInfo : StringTable
	{ }

	//----------------------------------------------------------
	// DependentAssemblyInfo
	//----------------------------------------------------------
	public class DependentAssemblyInfo : StringTable
	{ 
		public AssemblyIdentity assemblyIdentity;
	}

	//----------------------------------------------------------
	// ActivationInfo
	//----------------------------------------------------------
	public class ActivationInfo : StringTable
	{}
	public class SecurityInfo : StringTable
	{}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\proxy\stub_dlldata.c ===
#include <dlldata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\proxy\stub_server_p.c ===
#include <server_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\ndphost\downloadstatus.cs ===
/*=============================================================================
**
** Class: DownloadStatus
**
** Purpose: WinForm dialog for download status or info
**
** Date: 7/11/2001
**
** Copyright (c) Microsoft, 2001
**
=============================================================================*/

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace Microsoft.Fusion.ADF
{
    /// <summary>
    /// Summary description for DownloadStatus.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(false)]
    public class DownloadStatus : System.Windows.Forms.Form
    {
    private System.Windows.Forms.ProgressBar progressBar1;
    private System.Windows.Forms.Label label1;
    /// <summary>
    /// Required designer variable.
    /// </summary>
    private System.ComponentModel.Container components = null;

    public DownloadStatus(int minStatus, int maxStatus)
    {
        //
        // Required for Windows Form Designer support
        //
        InitializeComponent();

        progressBar1.Minimum = minStatus;
        progressBar1.Maximum = maxStatus;

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    /// Clean up any resources being used.
    /// </summary>

    protected override void Dispose(bool disposing)
    {
        if( disposing )
        {
            if(components != null)
            {
                components.Dispose();
            }
        }
        base.Dispose(disposing);
    }

#region Windows Form Designer generated code
    /// <summary>
    /// Required method for Designer support - do not modify
    /// the contents of this method with the code editor.
    /// </summary>
    private void InitializeComponent()
    {
        this.label1 = new System.Windows.Forms.Label();
        this.progressBar1 = new System.Windows.Forms.ProgressBar();
        this.SuspendLayout();
        // 
        // label1
        // 
        this.label1.Font = new System.Drawing.Font("Arial", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
        this.label1.Location = new System.Drawing.Point(48, 32);
        this.label1.Name = "label1";
        this.label1.Size = new System.Drawing.Size(248, 20);
        this.label1.TabIndex = 1;
        this.label1.Text = "On-demand download in progress...";
        // 
        // progressBar1
        // 
        this.progressBar1.Location = new System.Drawing.Point(40, 72);
        this.progressBar1.Name = "progressBar1";
        this.progressBar1.Size = new System.Drawing.Size(248, 20);
        this.progressBar1.TabIndex = 0;
        // 
        // DownloadStatus
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
        this.ClientSize = new System.Drawing.Size(322, 127);
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.label1, this.progressBar1});
        this.Name = "ClickOnceDownloadStatus";
        this.Text = "ClickOnce Download";
        this.ShowInTaskbar = false;
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.MinimizeBox = false;
        this.MaximizeBox = false;
//        this.Load += new System.EventHandler(this.DownloadStatus_Load);
        this.ResumeLayout(false);
    }
#endregion

//    private void DownloadStatus_Load(object sender, System.EventArgs e)
//    {
//    }

    public void SetStatus(int status)
    {
        progressBar1.Value = status;
    }

    public void SetMessage(string text)
    {
        label1.Text = text;
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\proxy\stub_server_i.c ===
#include <server_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\cfactory.cpp ===
///////////////////////////////////////////////////////////
//
// CFactory
//   - Base class for reusing a single class factory for
//     all components in a DLL
//
#include <objbase.h>
#include <fusenetincludes.h>
#include "CFactory.h"

LONG CFactory::s_cServerLocks = 0 ;    // Count of locks
HMODULE CFactory::s_hModule = NULL ;   // DLL module handle

#ifdef _OUTPROC_SERVER_
DWORD CFactory::s_dwThreadID = 0 ;
#endif

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
    m_pFactoryData = pFactoryData ;
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CFactory::~CFactory()
{}


// IUnknown implementation

// ---------------------------------------------------------------------------
// QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CFactory::QueryInterface(REFIID iid, void** ppv)
{ 
    IUnknown* pI ;
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        pI = this ; 
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    pI->AddRef() ;
    *ppv = pI ;
    return S_OK;
}

// ---------------------------------------------------------------------------
// AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFactory::AddRef() 
{ 
    return ::InterlockedIncrement((LONG*) &m_cRef) ; 
}

// ---------------------------------------------------------------------------
// Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFactory::Release() 
{
    if (::InterlockedDecrement((LONG*) &m_cRef) == 0) 
    {
        delete this; 
        return 0 ;
    }   
    return m_cRef;
}


// ---------------------------------------------------------------------------
// IClassFactory implementation
// ---------------------------------------------------------------------------
STDMETHODIMP CFactory::CreateInstance(IUnknown* pUnknownOuter,
                const IID& iid, void** ppv) 
{

    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CUnknown* pNewComponent = NULL;
    
    // Aggregate only if the requested IID is IID_IUnknown.
    if ((pUnknownOuter != NULL) && (iid != IID_IUnknown))
    {
        hr = CLASS_E_NOAGGREGATION ;
        goto exit;
    }

    // Create the component.
    IF_FAILED_EXIT(m_pFactoryData->CreateInstance(pUnknownOuter, &pNewComponent));

    // Initialize the component.
    IF_FAILED_EXIT(pNewComponent->Init());
    
    // Get the requested interface.
    IF_FAILED_EXIT(pNewComponent->QueryInterface(iid, ppv));

exit:

    // Release the reference held by the class factory.
    SAFERELEASE(pNewComponent);

    return hr ;   

}

// ---------------------------------------------------------------------------
// LockServer
// ---------------------------------------------------------------------------
STDMETHODIMP CFactory::LockServer(BOOL bLock) 
{
    if (bLock) 
    {
        ::InterlockedIncrement(&s_cServerLocks) ; 
    }
    else
    {
        ::InterlockedDecrement(&s_cServerLocks) ;
    }

    // If this is an out-of-proc server, check to see
    // whether we should shut down.
    CloseExe() ;  //@local

    return S_OK ;
}


// -------------------Support Common to Inproc/OutProc--------------------------


// ---------------------------------------------------------------------------
// Determine if the component can be unloaded.
// ---------------------------------------------------------------------------
HRESULT CFactory::CanUnloadNow()
{
    if (CUnknown::ActiveComponents() || IsLocked())
    {
        return S_FALSE ;
    }
    else
    {
        return S_OK ;
    }
}


// --------------------------InProc Server support-------------------------------


#ifndef _OUTPROC_SERVER_


// ---------------------------------------------------------------------------
// GetClassObject
// ---------------------------------------------------------------------------
HRESULT CFactory::GetClassObject(const CLSID& clsid, 
                                 const IID& iid, 
                                 void** ppv)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);    
    BOOL fFound = FALSE;

    IF_FALSE_EXIT(((iid == IID_IUnknown) || (iid == IID_IClassFactory)), E_NOINTERFACE);

    // Traverse the array of data looking for this class ID.
    for (int i = 0; i < g_cFactoryDataEntries; i++)
    {
        const CFactoryData* pData = &g_FactoryDataArray[i] ;
        if (pData->IsClassID(clsid))
        {
            // Found the ClassID in the array of components we can
            // create. So create a class factory for this component.
            // Pass the CFactoryData structure to the class factory
            // so that it knows what kind of components to create.
            *ppv = (IUnknown*) new CFactory(pData) ;
            IF_ALLOC_FAILED_EXIT(*ppv);
            fFound = TRUE;
        }
    }

    hr = fFound ? NOERROR : CLASS_E_CLASSNOTAVAILABLE;

exit:
    return hr;

}


// ---------------------------------------------------------------------------
// DllCanUnloadNow
// ---------------------------------------------------------------------------
STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow() ; 
}

// ---------------------------------------------------------------------------
// DllGetClassObject
// ---------------------------------------------------------------------------
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv) 
{
    return CFactory::GetClassObject(clsid, iid, ppv) ;
}

// ---------------------------------------------------------------------------
// DllRegisterServer
// ---------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    return CFactory::RegisterAll() ;
}


// ---------------------------------------------------------------------------
// DllUnregisterServer
// ---------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    return CFactory::UnregisterAll() ;
}


// ---------------------------------------------------------------------------
// DllMain
// ---------------------------------------------------------------------------
BOOL APIENTRY DllMain(HANDLE hModule, 
    DWORD dwReason, void* lpReserved )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CFactory::s_hModule = (HMODULE) hModule ;
    }
    return TRUE ;
}


// -------------------------OutProc server support-----------------------------

#else


// ---------------------------------------------------------------------------
// Start factories
// ---------------------------------------------------------------------------
HRESULT CFactory::StartFactories()
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    CFactoryData* pStart = &g_FactoryDataArray[0] ;
    const CFactoryData* pEnd =
        &g_FactoryDataArray[g_cFactoryDataEntries - 1] ;

    IClassFactory* pIFactory = NULL;

    for(CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
    {
        // Initialize the class factory pointer and cookie.
        pData->m_pIClassFactory = NULL ;
        pData->m_dwRegister = NULL ;

        // Create the class factory for this component.
        pIFactory = new CFactory(pData) ;
        IF_ALLOC_FAILED_EXIT(pIFactory);
        
        // Register the class factory.
        DWORD dwRegister ;
        hr = ::CoRegisterClassObject(
                  *pData->m_pCLSID,
                  static_cast<IUnknown*>(pIFactory),
                  CLSCTX_LOCAL_SERVER,
                  REGCLS_MULTIPLEUSE,
                  // REGCLS_MULTI_SEPARATE, //@Multi
                  &dwRegister) ;

        IF_FAILED_EXIT(hr);
        
        // Set the data.
        pData->m_pIClassFactory = pIFactory ;
        pData->m_dwRegister = dwRegister ;

    }

exit:

    if (FAILED(hr))
        SAFERELEASE(pIFactory);

    return hr;
}

// ---------------------------------------------------------------------------
// Stop factories
// ---------------------------------------------------------------------------
void CFactory::StopFactories()
{
    CFactoryData* pStart = &g_FactoryDataArray[0] ;
    const CFactoryData* pEnd =
        &g_FactoryDataArray[g_cFactoryDataEntries - 1] ;

    for (CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
    {
        // Get the magic cookie and stop the factory from running.
        DWORD dwRegister = pData->m_dwRegister ;
        if (dwRegister != 0) 
        {
            ::CoRevokeClassObject(dwRegister) ;
        }

        // Release the class factory.
        IClassFactory* pIFactory  = pData->m_pIClassFactory ;
        SAFERELEASE(pIFactory);
    }
}

#endif //_OUTPROC_SERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\cunknown.cpp ===
#include "CUnknown.h"
#include "CFactory.h"

long CUnknown::s_cActiveComponents = 0 ;

CUnknown::CUnknown()
: m_cRef(1)
{
    ::InterlockedIncrement(&s_cActiveComponents) ;
}

CUnknown::~CUnknown()
{
    ::InterlockedDecrement(&s_cActiveComponents) ;

    // If this is an EXE server, shut it down.
    CFactory::CloseExe() ;
}

// ---------------------------------------------------------------------------
// AddRef
// ---------------------------------------------------------------------------
DWORD CUnknown::AddRef()
{
    return InterlockedIncrement ((LONG*) &m_cRef);
}

// ---------------------------------------------------------------------------
// Release
// ---------------------------------------------------------------------------
DWORD CUnknown::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &m_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

// ---------------------------------------------------------------------------
// Release
// ---------------------------------------------------------------------------
DWORD CUnknown::ActiveComponents()
{
    return s_cActiveComponents;
}

// ---------------------------------------------------------------------------
// FinishQI 
// ---------------------------------------------------------------------------
HRESULT CUnknown::FinishQI(IUnknown* pI, void** ppv) 
{
    *ppv = pI ;
    pI->AddRef() ;
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\guids.cpp ===
#define INITGUID
#include <guiddef.h>


DEFINE_GUID(IID_IAssemblyUpdate,
0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(LIBID_ServerLib,
0xd3011ee0,0xb997,0x11cf,0xa6,0xbb,0x00,0x80,0xc7,0xb2,0xd6,0x82);

DEFINE_GUID(CLSID_CAssemblyUpdate,
0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);

DEFINE_GUID( IID_IAssemblyBindSink,
0xaf0bc960,0x0b9a,0x11d3,0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\cunknown.h ===
#pragma once

#include <objbase.h>

// ---------------------------------------------------------------------------
// CUnknown
// Base class for class instances provided by component server.
// ---------------------------------------------------------------------------
class CUnknown 
{
public:

    // ctor
    CUnknown();

    // dtor
    virtual ~CUnknown() ;

    virtual HRESULT __stdcall QueryInterface(REFIID riid, void ** ppv) = 0;

    DWORD AddRef();

    DWORD Release();

    virtual HRESULT Init() = 0;

    static DWORD ActiveComponents();
    
    // Helper function
    HRESULT FinishQI(IUnknown* pI, void** ppv) ;


private:
    // Reference count for this object
    DWORD m_cRef ;
    
    // Count of all active instances
    static long s_cActiveComponents ; 

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\resource.h ===
#define IDI_ICON                        101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\outproc.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <fusenetincludes.h>
#include "CUnknown.h"
#include "CFactory.h"
#include "Resource.h"
#include <update.h>
#include "regdb.h"

HWND g_hwndUpdateServer = NULL ;
CRITICAL_SECTION g_csServer;

// Signal that an update is available.
extern BOOL g_fSignalUpdate;

BOOL InitWindow(int nCmdShow) ;
extern "C" LRESULT APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) ;


//-----------------------------------------------------------------------------
// WinMain
// The main entry point via CoCreate or CreateProcess.
//-----------------------------------------------------------------------------
extern "C" int WINAPI WinMain(HINSTANCE hInstance, 
                              HINSTANCE hPrevInstance,
                              LPSTR lpCmdLine, 
                              int nCmdShow)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    // Initialize the COM Library.
    IF_FAILED_EXIT(CoInitializeEx(NULL, COINIT_MULTITHREADED));
   
    __try 
    {
        ::InitializeCriticalSection(&g_csServer);
    }
    __except (GetExceptionCode() == STATUS_NO_MEMORY ? 
            EXCEPTION_EXECUTE_HANDLER : 
            EXCEPTION_CONTINUE_SEARCH ) 
    {
        hr = E_OUTOFMEMORY;
    }

    IF_FAILED_EXIT(hr);
            
    // Get Thread ID.
    CFactory::s_dwThreadID = ::GetCurrentThreadId() ;
    CFactory::s_hModule = hInstance ;

    IF_WIN32_FALSE_EXIT(InitWindow(SW_HIDE));
    
    // Increment artificial server lock.
    ::InterlockedIncrement(&CFactory::s_cServerLocks) ;

    // clean-up the jobs left out from previous login.
    IF_FAILED_EXIT(ProcessOrphanedJobs());

    // Initialize the subscription list and timers from registry.
    IF_FAILED_EXIT(CAssemblyUpdate::InitializeSubscriptions());
        
    // Register all of the class factories.
    IF_FAILED_EXIT(CFactory::StartFactories());

    // Wait for shutdown.
    MSG msg ;
    while (::GetMessage(&msg, 0, 0, 0))
    {
        ::DispatchMessage(&msg) ;
    }

    // Unregister the class factories.
    // BUGBUG - use the critsect instead
    // for race condition.
    // The check here is because StopFactories
    // will have already been called if an update
    // is signalled.
    if (!g_fSignalUpdate)
        CFactory::StopFactories() ;
    ::DeleteCriticalSection(&g_csServer);

exit:

    return SUCCEEDED(hr) ? TRUE : FALSE;

    // Uninitialize the COM Library.
    CoUninitialize() ;
    return 0 ;
}


//-----------------------------------------------------------------------------
// InitWindow
// Initializes hidden window used by main service process thread.
//-----------------------------------------------------------------------------
BOOL InitWindow(int nCmdShow) 
{
    // Fill in window class structure with parameters
    // that describe the main window.
    WNDCLASS wcUpdateServer ;
    wcUpdateServer.style = 0 ;
    wcUpdateServer.lpfnWndProc = MainWndProc ;
    wcUpdateServer.cbClsExtra = 0 ;
    wcUpdateServer.cbWndExtra = 0 ;
    wcUpdateServer.hInstance = CFactory::s_hModule ;
    wcUpdateServer.hIcon = ::LoadIcon(CFactory::s_hModule,
                                  MAKEINTRESOURCE(IDC_ICON)) ;
    wcUpdateServer.hCursor = ::LoadCursor(NULL, IDC_ARROW) ;
    wcUpdateServer.hbrBackground = (HBRUSH) ::GetStockObject(GRAY_BRUSH) ;
    wcUpdateServer.lpszMenuName = NULL ;
    wcUpdateServer.lpszClassName = L"UpdateServiceServerInternalWindow" ;

    // returns GetLastError on fail.
    BOOL bResult = ::RegisterClass(&wcUpdateServer) ;
    if (!bResult)
    {
        return bResult ;
    }

    HWND hWndMain ;

    // returns getlasterror
    hWndMain = ::CreateWindow(
        L"UpdateServiceServerInternalWindow",
        L"Application Update Service", 
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT,
        NULL,               
        NULL,               
        CFactory::s_hModule,          
        NULL) ;

    // If window could not be created, return "failure".
    if (!hWndMain)
    {
        return FALSE ;
    }

    // Make the window visible; update its client area;
    // and return "success".
    ::ShowWindow(hWndMain, nCmdShow) ;
    ::UpdateWindow(hWndMain) ;
    return TRUE ;
}

//-----------------------------------------------------------------------------
// MainWndProc
// Window procedure for service process thread (hidden).
//-----------------------------------------------------------------------------
extern "C" LRESULT APIENTRY MainWndProc(
    HWND hWnd,                // window handle
    UINT message,             // type of message
    WPARAM wParam,            // additional information
    LPARAM lParam)            // additional information
{
    DWORD dwStyle ;

    switch (message) 
    {
    case WM_CREATE:
        {
            // Get size of main window
            CREATESTRUCT* pcs = (CREATESTRUCT*) lParam ;

            // Create a window. LISTBOX for no particular reason.
            g_hwndUpdateServer = ::CreateWindow(
                L"LISTBOX",
                NULL, 
                WS_CHILD | WS_VISIBLE | LBS_USETABSTOPS
                    | WS_VSCROLL | LBS_NOINTEGRALHEIGHT,
                    0, 0, pcs->cx, pcs->cy,
                hWnd,               
                NULL,               
                CFactory::s_hModule,          
                NULL) ;

            if (g_hwndUpdateServer  == NULL)
            {
                ASSERT(FALSE);
                return -1 ;
            }
        }
        break ;

    case WM_SIZE:
        ::MoveWindow(g_hwndUpdateServer, 0, 0,
            LOWORD(lParam), HIWORD(lParam), TRUE) ;
        break;

    case WM_DESTROY:          // message: window being destroyed
        if (CFactory::CanUnloadNow() == S_OK)
        {
            // Only post the quit message, if there is
            // no one using the program.
            ::PostQuitMessage(0) ;
        }
        break ;

    case WM_CLOSE:
        // Decrement the lock count.
        ::InterlockedDecrement(&CFactory::s_cServerLocks) ;

        // The service is going away.
        g_hwndUpdateServer = NULL ;

        //Fall through 
    default:
        return (DefWindowProc(hWnd, message, wParam, lParam)) ;
    }
    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\ndphost\ndphost.cs ===
//-----------------------------------------------------------------------------
//
// Class: NDPHost
//
// Fusion ClickOnce NDP Application host
//
// Date: 12/7/2001
//
// Copyright (c) Microsoft, 2001
//
//-----------------------------------------------------------------------------

using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using Avalon.Security;

[assembly:AssemblyCultureAttribute("")]
[assembly:AssemblyVersionAttribute("1.0.1218.0")]
[assembly:AssemblyKeyFileAttribute(/*"..\..\*/"NDPHostKey.snk")]

[assembly:AssemblyTitleAttribute("Microsoft Application Deployment Framework .Net Assembly Execute Host")]
[assembly:AssemblyDescriptionAttribute("Microsoft Application Deployment Framework -  NDP Hosting for .Net assemblies")]
[assembly:AssemblyProductAttribute("Microsoft Application Deployment Framework")]
[assembly:AssemblyInformationalVersionAttribute("1.0.0.0")]
[assembly:AssemblyTrademarkAttribute("Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation")]
[assembly:AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:AssemblyCopyrightAttribute("Copyright  Microsoft Corp. 1999-2002. All rights reserved.")]

[assembly:System.CLSCompliant(true)]

namespace Microsoft.Fusion.ADF
{

//----------------------------------------------------------------------------
// class NDPHost
//----------------------------------------------------------------------------
public class NDPHost : MarshalByRefObject
{ 	

	// cmd arg ordinals.
	enum eCmd : int
	{
		AppBase,
		AsmName,
		AsmClass,
		AsmMethod,
		AsmArgs,
		Url,
		Zone,
		ManifestPath,
		SecurityStatement,
		Max
	}

	// internal strings.
	string _sAppBase = null;
	string _sAsmName = null;
	string _sAsmClass = null;
	string _sAsmMethod = null;
	string _sAsmArgs = null;
	string _sUrl = null;
	string _sZone = null;
	string _sManifestPath = null;
	string _sSecurityStatement = null;
	Zone  _zZone = null;

	static bool g_fLoadingAssembly = false;
	static string[] g_sZones = {"MyComputer", "Intranet", "Trusted", "Internet", "Untrusted"};


	//----------------------------------------------------------------------------
	// ctor
	//----------------------------------------------------------------------------
	public NDPHost()
	{
	}
		
	//----------------------------------------------------------------------------
	// ctor
	// Not used currently, but possibly useful for CreateInstanceFrom w/args to ctor.
	//----------------------------------------------------------------------------
	public NDPHost(string[] args)
	{
		LoadFromStrings(args);
	}
	
	//----------------------------------------------------------------------------
	// Main
	//----------------------------------------------------------------------------
	public static void Main(string[] sCmdLine) 
	{
		NDPHost ndpHost= new NDPHost();
		try
		{
			ndpHost.ParseCmdLine(sCmdLine);
			ndpHost.ParseManifest();
			ndpHost.LaunchApp();
		}
		catch(ArgumentException e)
		{
			if ((e.Message == "Invalid Command Line"))
				Usage();
			else
				throw(e);
			
		}
	}
	
	//----------------------------------------------------------------------------
	// LaunchApp
	//----------------------------------------------------------------------------
	public void LaunchApp() 
	{
		Evidence securityEvidence = null;
		PolicyLevel appPolicy = null;

		try 
		{
			if (GetTMEvidenceAndPolicy(ref securityEvidence, ref appPolicy) != true)
			{
				System.Windows.Forms.MessageBox.Show("Application Failed to Run Due to Insufficient Permissions");
				Console.WriteLine("Application Failed to Run Due to Insufficient Permissions");
				return;
			}

		}
		catch(System.IO.FileNotFoundException fnfe)
		{
			Console.WriteLine("==\nBinding to Avalon throws: " + fnfe + "==\n");

			// Construct the Evidence object from url, zone.
			securityEvidence = ConstructEvidence();

			// Construct PolicyLevel object from entry file path, Evidence object.
			appPolicy = ConstructAppPolicy(securityEvidence);

			securityEvidence = null; // do not set evidence on appdomain
		}

		// Run app given entry path, type and PolicyLevel object.
		ExecuteApplication(appPolicy, securityEvidence);
	}
		
	
	//----------------------------------------------------------------------------
	// ParseCmdLine
	//----------------------------------------------------------------------------
	public void ParseCmdLine(string[] sCmdLine)
	{
		Console.WriteLine("\nParsing Comand Line...");
		
		if ((sCmdLine.Length != 2))
			throw new ArgumentException("Invalid Command Line");

		_sManifestPath = sCmdLine[0];
		_sUrl = sCmdLine[1];

		Uri appBaseUri = new Uri(_sManifestPath);
		string localPath = appBaseUri.LocalPath;//AbsolutePath;

		_sAppBase = System.IO.Path.GetDirectoryName(localPath) + "\\";
		_zZone = System.Security.Policy.Zone.CreateFromUrl(_sUrl);
		_sZone = ZoneToString(_zZone.SecurityZone);
		
		Console.WriteLine("\n");
		Console.WriteLine("ManifestPath=\t" + _sManifestPath);
		Console.WriteLine("AppBase=\t" + _sAppBase);
		Console.WriteLine("Url=\t\t" + _sUrl);
		Console.WriteLine("Zone=\t\t" + _sZone);
	}

	//----------------------------------------------------------------------------
	// ParseManifest
	//----------------------------------------------------------------------------
	public void ParseManifest()
	{
		Uri sManifestUri = new Uri(_sManifestPath);
		ApplicationManifestImport ami = new ApplicationManifestImport(sManifestUri);
		ActivationInfo ai = ami.GetActivationInfo();
		SecurityInfo si = ami.GetSecurityInfo();

		_sAsmName = ai["assemblyName"];
		_sAsmClass = ai["assemblyClass"];
		_sAsmMethod = ai["assemblyMethod"];
		_sAsmArgs = ai["assemblyMethodArgs"];
		if (si != null)
			_sSecurityStatement = si["Security"];

		Console.WriteLine("AsmName=\t" + _sAsmName);
		Console.WriteLine("Class=\t\t" + _sAsmClass);
		Console.WriteLine("Method=\t\t" + _sAsmMethod);
		Console.WriteLine("Args=\t\t" + _sAsmArgs);
		Console.WriteLine("\n");
		Console.WriteLine("Security=\t\t" + _sSecurityStatement);

	}	


	//----------------------------------------------------------------------------
	// GetTMEvidenceAndPolicy
	//----------------------------------------------------------------------------
	public bool GetTMEvidenceAndPolicy(ref Evidence securityEvidence, ref PolicyLevel appPolicy)
	{
		SecurityManifest sm = null;

		if (_sSecurityStatement != null)
			sm = new SecurityManifest(_sSecurityStatement);
		else
			sm = new SecurityManifest();

		// setup object for domain specifically to get trust.
		// for demo hack, securityEvidence = null at first, then set to additional evidence returned.
		TrustDecision trustDecision = TrustManager.EvaluateTrustRequest(sm, securityEvidence, "file://"+_sAppBase);

		if (trustDecision.Action == BasicTrustAction.Deny)
			return false;
		
		appPolicy = TrustManager.CreatePolicyLevel(trustDecision);
		securityEvidence = trustDecision.DomainEvidence;

		return true;
	}
	
	
	//----------------------------------------------------------------------------
	// ConstructEvidence
	//----------------------------------------------------------------------------
	public Evidence ConstructEvidence()
	{
		Console.WriteLine("Constructing Evidence...");
		Evidence securityEvidence = new Evidence();
		securityEvidence.AddHost(_zZone);
		if ((new Uri(_sUrl)).IsFile)
			Console.WriteLine(" Skipping Site evidence for file://");
		else
			securityEvidence.AddHost( System.Security.Policy.Site.CreateFromUrl(_sUrl) );
		// bugbug - add the actual url.
		return securityEvidence;
	}
	
	//----------------------------------------------------------------------------
	// ConstructAppPolicy
	//----------------------------------------------------------------------------
	public PolicyLevel ConstructAppPolicy(Evidence securityEvidence)
	{
		Console.WriteLine("Constructing App Policy Level...");
		
		// NOTENOTE: not effective if not both url and zone in evidence

		// Populate the PolicyLevel with code groups that will do the following:
		// 1) For all assemblies that come from this app's cache directory, 
		//    give permissions from retrieved permission set from SecurityManager.
		// 2) For all other assemblies, give FullTrust permission set.  Remember,
		//    since the permissions will be intersected with other policy levels,
		//    just because we grant full trust to all other assemblies does not mean
		//    those assemblies will end up with full trust.
	
		PolicyLevel AppPolicy = null;

		// ResolvePolicy will return a System.Security.PermissionSet
		PermissionSet AppPerms = SecurityManager.ResolvePolicy(securityEvidence);

		// Create a new System.Security.Policy.PolicyStatement that does not contain any permissions.
		PolicyStatement Nada = new PolicyStatement(new PermissionSet(PermissionState.None));//PermissionSet());

		// Create a PolicyStatement for the permissions that we want to grant to code from the app directory:
		PolicyStatement AppStatement = new PolicyStatement(AppPerms);

		// Create Full trust PolicyStatement so all other code gets full trust, by passing in an _unrestricted_ PermissionSet
		PolicyStatement FullTrustStatement = new PolicyStatement(new PermissionSet(PermissionState.Unrestricted));
	
		// Create a System.Security.Policy.FirstMatchCodeGroup as the root that matches all
		// assemblies by supplying an AllMembershipCondition:
		FirstMatchCodeGroup RootCG = new FirstMatchCodeGroup(new AllMembershipCondition(), Nada);

		// Create a child UnionCodeGroup to handle the assemblies from the app cache.  We do this
		// by using a UrlMembershipCondition set to the app cache directory:
		UnionCodeGroup AppCG = new UnionCodeGroup(new UrlMembershipCondition("file://"+_sAppBase+"*"), AppStatement);

		// Add AppCG to RootCG as first child.  This is important because we need it to be evaluated first
		RootCG.AddChild(AppCG);

		// Create a second child UnionCodeGroup to handle all other code, by using the AllMembershipCondition again
		UnionCodeGroup AllCG = new UnionCodeGroup(new AllMembershipCondition(), FullTrustStatement);

		// Add AllCG to RootCG after AppCG.  If AppCG doesnt apply to the assembly, AllCG will.
		RootCG.AddChild(AllCG);

		// This will be the PolicyLevel that we will associate with the new AppDomain.
		AppPolicy = PolicyLevel.CreateAppDomainLevel();

		// Set the RootCG as the root code group on the new policy level
		AppPolicy.RootCodeGroup = RootCG;

		// NOTENOTE
		// Code from the site that lives on the local machine will get the reduced permissions as expected.
		// Dependencies of this app (not under app dir or maybe dependencies that live in the GAC) would still get full trust.  
		// If the full trust dependencies need to do something trusted, they carry the burden of asserting to overcome the stack walk.

		return AppPolicy;
	}


	//----------------------------------------------------------------------------
	// ExecuteApplication
	//----------------------------------------------------------------------------
	public void ExecuteApplication(PolicyLevel AppPolicy, Evidence securityEvidence)
	{	
		Console.WriteLine("Executing Application...");

		// setup object for new domain
		AppDomainSetup appDomainSetup = new AppDomainSetup();

		// app base, config file name and friendly name = host name.
		appDomainSetup.ApplicationBase = _sAppBase;
		appDomainSetup.ConfigurationFile = GetConfigFileName();
		AppDomain dom = AppDomain.CreateDomain(GetHostName(), securityEvidence, appDomainSetup);

		// Set the policy level on the domain.
		dom.SetAppDomainPolicy(AppPolicy);

		// Normal exe case.
		if (_sAsmMethod == "")
		{
			Console.WriteLine("\nRunning ExecuteAssembly in: " + GetExeFilePath());
			// bugbug - question security guys on whether or not useful to have evidence passed in.
			dom.ExecuteAssembly(GetExeFilePath());
		}
		// Library entry case.
		else
		{
			Console.WriteLine("\nRunning "+_sAsmMethod+" in Assembly: "+_sAsmName);

			// Hosted code metadata must be present in both default app domain
			// and remote app domain.  Load NDPHost assembly into remote domain.
			AssemblyName asmName = Assembly.GetExecutingAssembly().GetName();

			// Instance the NDPHost class with default constructor.
			ObjectHandle objhNDP = dom.CreateInstanceFrom(asmName.CodeBase, "Microsoft.Fusion.ADF.NDPHost");
			
			// Unwrap the handle. 
			NDPHost objNDP = (NDPHost) objhNDP.Unwrap();

			// Get a string array representation of this object in the current app domain.
			string[] s = this.LoadToStrings();

			// Do the real construction in the remote domain.
			objNDP.LoadFromStrings(s);

			// Load the assembly resolve handler in the remote domain.
			objNDP.LoadResolveEventHandler();

			// Run the method.
			objNDP.ExecMethod();		
	
			// NOTE: why doesn't the following construction work?
			// ObjectHandle objhNDP = dom.CreateInstanceFrom(asmName.CodeBase, "NDPHost", true, 
			//	BindingFlags.Instance|BindingFlags.Public|BindingFlags.DeclaredOnly,
			//  null, (object[]) s, null, null, null);

		}		
	}

	//----------------------------------------------------------------------------
	// ExecMethod
	//----------------------------------------------------------------------------
	public void ExecMethod()
	{
	       new PermissionSet(PermissionState.Unrestricted).Assert();

		// Load the assembly.
		Assembly assembly = Assembly.Load(_sAsmName);

		// Instance the class.
		Object objInstance = assembly.CreateInstance(_sAsmClass, false);

		// Pass args as 0th element of object array. Slight hack
		// because we canonicalize against app base. Likely should
		// make first arg equal to appbase, + subsequent args.
		string sAppEntryPoint = _sAppBase + _sAsmArgs;
		Object [] objArgs = new Object [] {new String[] {sAppEntryPoint}};
		
		// Retrieve method from class instance.
		MethodInfo method = objInstance.GetType().GetMethod(_sAsmMethod,
			BindingFlags.Instance|BindingFlags.Public|BindingFlags.DeclaredOnly);

		// Invoke the method.
		try
		{
			Object pRet=method.Invoke(objInstance, objArgs);
		}
		catch(Exception e)
		{
			// bugbug - show base exception text instead.
			Console.WriteLine(e.ToString());
			throw e.GetBaseException();
		}
	}

	//----------------------------------------------------------------------------
	// LoadResolveEventHandler
	//----------------------------------------------------------------------------
	public void LoadResolveEventHandler()
	{
		// ISSUE - onDemand download disabled for M2
		//AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(OnAssemblyResolve);
	}

	//----------------------------------------------------------------------------
	// OnAssemblyResolve
	//----------------------------------------------------------------------------
	private Assembly OnAssemblyResolve(Object sender, ResolveEventArgs args)
	{
        new PermissionSet(PermissionState.Unrestricted).Assert();

		Assembly assembly = null;

		if (g_fLoadingAssembly)
			goto done;
		g_fLoadingAssembly=true;

		string[] sAssemblyNameParts = args.Name.Split(new Char[] {','}, 2);
		string sAssemblyName = sAssemblyNameParts[0] + ".dll";

		try
		{
			GetFile(sAssemblyName);
		}
		catch
		{
			g_fLoadingAssembly=false;
			goto done;
		}

		try 
		{
			assembly = Assembly.Load(args.Name);
		} 
		catch 
		{
			assembly = null;
		}
		finally
		{
			g_fLoadingAssembly=false;
		}

done:
		return assembly;
	}

	//----------------------------------------------------------------------------
	// GetFile
	//----------------------------------------------------------------------------
	private void GetFile(string name)
	{
		HttpWebResponse Response;

		//Retrieve the File
		HttpWebRequest Request = (HttpWebRequest)HttpWebRequest.Create(_sUrl + name);

		try 
		{
			Response = (HttpWebResponse)Request.GetResponse();
		}
		catch(WebException e) 
		{
			Console.WriteLine(e.ToString());
			throw e;

			// BUGBUG: apply probing rules?
		}

		Stream responseStream = Response.GetResponseStream();

		// setup UI
		// BUGBUG: allow no UI case?

		// BUGBUG: test with file > 4GB
		Int64 totalLength = 0;
		int factor = (int) (Response.ContentLength / int.MaxValue);
		int max = int.MaxValue;
		if (factor <= 1)
		{
			factor = 1;
			max = (int) Response.ContentLength;
		}
		if (max <= -1)
		{
			// no content length returned from the server (-1),
			//  or error (what does < -1 mean?)

			// no progress, set max to 0
			max = 0;
		}

		DownloadStatus statusForm = new DownloadStatus(0, max);
		statusForm.SetStatus(0);
		statusForm.Show();

		// write from stream to disk
		byte[] buffer = new byte[4096];
		int length;

		try
		{
			FileStream AFile = File.Open(_sAppBase+name, FileMode.Create, FileAccess.ReadWrite);

			length = responseStream.Read(buffer, 0, 4096);
			while ( length != 0 )
			{
				AFile.Write(buffer, 0, length);

				if (max != 0)
				{
					totalLength += length;
					statusForm.SetStatus((int) (totalLength/factor));
				}

				length = responseStream.Read(buffer, 0, 4096);

				// dispatch messages
				System.Windows.Forms.Application.DoEvents();
			}
			AFile.Close();

			statusForm.SetMessage("Download complete");
		}
		catch(Exception e)
		{
			statusForm.SetMessage(e.Message);
			// BUGBUG: AFile may not be closed
		}

		responseStream.Close();

		//Pause for a moment to show the status dialog in
		//case the app downloaded extremely quickly (small file?).
		statusForm.Refresh();
		System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1));
		statusForm.Close();
	}
	
	//----------------------------------------------------------------------------
	// ValidateParams
	//----------------------------------------------------------------------------
	public void ValidateParams(string[] s)
	{	
		// appbase, asmname, url required. 
		if (((s[(int) eCmd.AppBase] == "") 
			|| (s[(int) eCmd.AsmName] == "") 
			|| (s[(int) eCmd.Url] == "")))
			throw new ArgumentException("Invalid Parameters");

		// if class or method specified, must specify both.
		if (((s[(int)eCmd.AsmMethod] != "") && (s[(int)eCmd.AsmClass] == ""))
			|| ((s[(int)eCmd.AsmMethod] == "") && (s[(int)eCmd.AsmClass] != "")))
			throw new ArgumentException("Invalid Parameters");
	}
	
	//----------------------------------------------------------------------------
	// LoadFromStrings
	//----------------------------------------------------------------------------
	public void LoadFromStrings(string[] s)
	{
		ValidateParams(s);

		_sAppBase = s[(int) eCmd.AppBase];
		_sAsmName=s[(int) eCmd.AsmName];
		_sAsmClass=s[(int) eCmd.AsmClass];
		_sAsmMethod=s[(int) eCmd.AsmMethod];
		_sAsmArgs=s[(int) eCmd.AsmArgs];
		_sUrl = s[(int) eCmd.Url];
		_sZone=s[(int) eCmd.Zone];
		_zZone = new Zone((System.Security.SecurityZone)StringToZone(_sZone));
		_sManifestPath = s[(int) eCmd.ManifestPath];
		_sSecurityStatement = s[(int) eCmd.SecurityStatement];

	}

	//----------------------------------------------------------------------------
	// LoadToStrings
	//----------------------------------------------------------------------------
	public string[] LoadToStrings()
	{
		string[] s = new string[(int) eCmd.Max];

		s[(int) eCmd.AppBase] = _sAppBase;
		s[(int) eCmd.AsmName]=_sAsmName;
		s[(int) eCmd.AsmClass]=_sAsmClass;
		s[(int) eCmd.AsmMethod]=_sAsmMethod;
		s[(int) eCmd.AsmArgs]=_sAsmArgs;
		s[(int) eCmd.Url]=_sUrl; 
		s[(int) eCmd.Zone]=_sZone;
		s[(int) eCmd.ManifestPath] = _sManifestPath;
		s[(int) eCmd.SecurityStatement] = _sSecurityStatement;
		return s;
	}

		
	//----------------------------------------------------------------------------
	// GetConfigFileName
	//----------------------------------------------------------------------------
	public string GetConfigFileName()
	{
		StringBuilder sb = new StringBuilder();
		if (_sAsmMethod == "")
			sb.Append(GetExeFilePath());
		else
			sb.Append(_sAsmArgs);

		sb.Append(".config");

		return sb.ToString();
	}
		
	//----------------------------------------------------------------------------
	// GetExeFilePath
	//----------------------------------------------------------------------------
	public string GetExeFilePath()
	{
		StringBuilder sb = new StringBuilder();
		string sExe = @"exe$";
		Match m = Regex.Match(_sAsmName, sExe, RegexOptions.IgnoreCase);

		sb.Append(_sAppBase);
		sb.Append(_sAsmName);

		if (!m.Success)
			sb.Append(".exe");
		return sb.ToString();
	}

	//----------------------------------------------------------------------------
	// GetHostName
	//----------------------------------------------------------------------------
	public string GetHostName()
	{
		System.Uri uri = new System.Uri(_sUrl);
		return uri.Host;
	}
		
	//----------------------------------------------------------------------------
	// ZoneToString
	//----------------------------------------------------------------------------
	string ZoneToString(SecurityZone z)
	{ 
		return g_sZones[(int) z];
	}

	//----------------------------------------------------------------------------
	// StringToZone
	//----------------------------------------------------------------------------
	SecurityZone StringToZone(string s)
	{ 
		for (int i = 0; i < g_sZones.Length; i++)
		{
			if (g_sZones[i] == s)
				return (SecurityZone) i;
		}
		return (SecurityZone) (-1);
	}


	//----------------------------------------------------------------------------
	// Usage
	//----------------------------------------------------------------------------
	public static void Usage()
	{
		Console.WriteLine("--NDPHost Application Launcher--");
		Console.WriteLine("NDP Build Version = v1.0.3705\n");
		Console.WriteLine("Usage: NDPHost ManifestFileUri, ApplicationBaseUri\n");
		Console.WriteLine("Example:\n");		
		Console.WriteLine("1) To launch application at c:\\foo\\bar\\bar.manifest with permissions based");
		Console.WriteLine("on url http://foo/bar/:\n");
		Console.WriteLine("NDPHost file://c:/foo/bar/bar.manifest http://foo/bar/");
	}
}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\server.cpp ===
#include <fusenetincludes.h>
#include "CFactory.h"
#include "server.h"
#include "update.h"

///////////////////////////////////////////////////////////
//
// Server.cpp
//
// This file contains the component server code.
// The FactoryDataArray contains the components that 
// can be served.
//

// Each component derived from CUnknown defines a static function
// for creating the component with the following prototype. 
// HRESULT CreateInstance(IUnknown* pUnknownOuter, 
//                        CUnknown** ppNewComponent) ;
// This function is used to create the component.
//

//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, the pointer to the creation function, and the name
// of the component to place in the Registry.
//
CFactoryData g_FactoryDataArray[] =
{
    {&CLSID_CAssemblyUpdate, CAssemblyUpdate::CreateInstance, NULL, 0}
} ;

int g_cFactoryDataEntries
    = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\cfactory.h ===
#pragma once

#include "CUnknown.h"
 
// Forward reference
class CFactoryData ;
class CUnknown ;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**) ;

///////////////////////////////////////////////////////////
//
// CFactoryData
//   - Information CFactory needs to create a component

class CFactoryData
{
public:
    // The class ID for the component
    const CLSID* m_pCLSID ;

    // Pointer to the function that creates it
    FPCREATEINSTANCE CreateInstance;
    
    // Pointer to running class factory for this component
    IClassFactory* m_pIClassFactory;

    // Magic cookie to identify running object
    DWORD m_dwRegister ;

    // Helper function for finding the class ID
    BOOL IsClassID(const CLSID& clsid) const
        { return (*m_pCLSID == clsid) ;}


} ;


///////////////////////////////////////////////////////////
//
// Class Factory
//
class CFactory : public IClassFactory
{
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IClassFactory
    STDMETHOD(CreateInstance)(IUnknown* pUnknownOuter,
                /*in*/    const IID& iid,
                /*out*/  void** ppv) ;

    STDMETHOD(LockServer)(BOOL bLock) ; 

    // ctor
    CFactory(/* in */ const CFactoryData* pFactoryData) ;

    // dtor
    ~CFactory();

    // Static FactoryData support functions

    // --------------Support Common to Inproc/OutProc--------------------------

    // Helper function for DllCanUnloadNow 
    static BOOL IsLocked()
    { return (s_cServerLocks > 0) ;}


    // Function to determine if component can be unloaded
    static HRESULT CanUnloadNow() ;


#ifdef _OUTPROC_SERVER_

    // ---------------------OutProc server support-----------------------------

    static HRESULT StartFactories() ;
    static void StopFactories() ;

    static DWORD s_dwThreadID ;

    // Shut down the application.
    static void CloseExe()
    {
        if (CanUnloadNow() == S_OK)
        {
            ::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0) ;
        }
    }

#else 

    // ---------------------InProc server support-----------------------------

    // DllGetClassObject support
    static HRESULT GetClassObject(const CLSID& clsid, 
                /*in*/ const IID& iid, 
                /*out*/ void** ppv) ;



    // CloseExe doesn't do anything if we are in process.
    static void CloseExe() { /*Empty*/ } 

#endif // _OUTPROC_SERVER



public:
    // Reference Count
   DWORD m_cRef ;

    // Pointer to information about class this factory creates
    const CFactoryData* m_pFactoryData ;

    // Count of locks
    static LONG s_cServerLocks ;   

    // Module handle
    static HMODULE s_hModule ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\dll\shelldll.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "shcut.h"

HINSTANCE g_DllInstance = NULL;
LONG      g_cRef=0;

//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{
    BOOL    ret = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // remember the instance
        g_DllInstance = hInst;
        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return ret;
}

//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
	// BUGBUG: should implement the registerserver
	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	// BUGBUG: should implement the unregisterserver
	return S_OK;
}


// ----------------------------------------------------------------------------
// DllAddRef
// ----------------------------------------------------------------------------

ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// DllRelease
// ----------------------------------------------------------------------------

ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// ----------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    return g_cRef > 0 ? S_FALSE : S_OK;
}

// ----------------------------------------------------------------------------

HRESULT 
GetShortcutClassObject(REFIID iid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

	CFusionShortcutClassFactory *pFusionShortcutClassFactory = new CFusionShortcutClassFactory();
	if (pFusionShortcutClassFactory != NULL)
	{
	    hr = pFusionShortcutClassFactory->QueryInterface(iid, ppv); 
	    pFusionShortcutClassFactory->Release(); 
	}

    return hr;
}

// ----------------------------------------------------------------------------
/*
HRESULT 
GetMimeFilterClassObject(REFIID iid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

	CFusionMimeFilterClassFactory *pFusionMimeFilterClassFactory = new CFusionMimeFilterClassFactory();
	if (pFusionMimeFilterClassFactory != NULL)
	{
	    hr = pFusionMimeFilterClassFactory->QueryInterface(iid, ppv); 
	    pFusionMimeFilterClassFactory->Release(); 
	}

    return hr;
}
*/
// ----------------------------------------------------------------------------
  
STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (clsid == CLSID_FusionShortcut)
    {
        hr = GetShortcutClassObject(iid, ppv);
    }
/*
    else if (clsid == CLSID_FusionMimeFilter)
    {
        hr = GetMimeFilterClassObject(iid, ppv);
    }
*/
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\update.h ===
//
// update.cpp - assembly update
//
#include "server.h"
#include "fusenet.h"
#include "CUnknown.h" // Base class for IUnknown

///////////////////////////////////////////////////////////
//
// Component AssemblyUpdate
//
class CAssemblyUpdate : public CUnknown,
       public IAssemblyUpdate
{

public:

    // Interface IUnknown
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Interface IAssemblyUpdate
    STDMETHOD(RegisterAssemblySubscription)(LPWSTR pwzDisplayName,
        LPWSTR pwzUrl, DWORD dwInterval);

    STDMETHOD(RegisterAssemblySubscriptionEx)(LPWSTR pwzDisplayName, 
        LPWSTR pwzUrl, DWORD dwInterval, DWORD dwIntervalUnit,
        DWORD dwEvent, BOOL bEventDemandConnection) ;


    STDMETHOD(UnRegisterAssemblySubscription)(LPWSTR pwzDisplayName);

    // Public non-interface methods.

    // Creation

    CAssemblyUpdate() ;

    ~CAssemblyUpdate() ;

    static HRESULT CreateInstance(IUnknown* pUnknownOuter,
        CUnknown** ppNewComponent) ;

    // Initialization
    HRESULT Init();

    // Registration
    HRESULT RegisterAssemblySubscriptionFromInfo(LPWSTR pwzDisplayName, 
        LPWSTR pwzUrl, IManifestInfo *pSubscriptionInfo) ;

    // Kick off polling on startup.
    static HRESULT InitializeSubscriptions();

    // Helpers
    static HRESULT GetCurrentVersion(ULONGLONG *pullCurrentVersion);
    static HRESULT RemoveUpdateRegistryEntry();
    static HRESULT ReadUpdateRegistryEntry(ULONGLONG *pullUpdateVersion, CString &sUpdatePath);
    static HRESULT IsDuplicate(LPWSTR pwzURL, BOOL *pbIsDuplicate);
    static HRESULT CheckForUpdate();

    // Private non-interface methods.


    HRESULT _hr;

} ;


///////////////////////////////////////////////////////////
//
// Component AssemblyBindSink
//
class CAssemblyBindSink : public IAssemblyBindSink
{
public:

    LONG _cRef;
    IAssemblyDownload *_pAssemblyDownload;

    CAssemblyBindSink(IAssemblyDownload *pAssemblyDownload);
    ~CAssemblyBindSink();
    
    STDMETHOD(OnProgress)(
        DWORD          dwNotification,
        HRESULT        hrNotification,
        LPCWSTR        szNotification,
        DWORD          dwProgress,
        DWORD          dwProgressMax,
        IUnknown       *pUnk);

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
};

///////////////////////////////////////////////////////////
//
// DownloadInstance
//
struct CDownloadInstance
{
    IAssemblyDownload * _pAssemblyDownload;
    CString _sUrl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\host\activator.cpp ===
#include <windows.h>
#include <objbase.h>
#include <shlobj.h>
#include <fusenetincludes.h>
#include <activator.h>
#include <versionmanagement.h>
#include <shellapi.h> // for shellexecuteex

#include <shellres.h>

#define INITGUID
#include <guiddef.h>

// used in OnProgress(), copied from guids.c
DEFINE_GUID( IID_IAssemblyManifestImport,
0x696fb37f,0xda64,0x4175,0x94,0xe7,0xfd,0xc8,0x23,0x45,0x39,0xc4);

// Update services
#include "server.h"
DEFINE_GUID(IID_IAssemblyUpdate,
    0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(CLSID_CAssemblyUpdate,
    0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);

extern HRESULT GetLastWin32Error();

#define WZ_TYPE_DOTNET  L".NetAssembly"
#define WZ_TYPE_WIN32   L"win32Executable"
#define WZ_TYPE_AVALON  L"avalon"
#define WZ_TYPE_CONSOLE   L"win32Console"
#define TYPE_DOTNET     1
#define TYPE_WIN32      2
#define TYPE_AVALON     3
#define TYPE_CONSOLE    4

#if 1
#include "ndphostthunk.cpp"
#else   // old code
// CLR Hosting
#import "..\..\clrhost\asmexec.tlb" raw_interfaces_only
using namespace asmexec;
#endif


// debug msg stuff
void Msg(LPCWSTR pwz);

void ShowError(LPCWSTR pwz);

void ShowError(HRESULT hr, LPCWSTR pwz=NULL);

// ----------------------------------------------------------------------------

typedef struct
{
    LPCWSTR pwzTitle;
    LPCWSTR pwzText;
} SHOWDIALOG_MSG;

#define DIALOG_OK 1
#define DIALOG_CANCEL 2
#define DIALOG_CLOSE 3
//IDC_TEXT
INT_PTR CALLBACK DialogBoxProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
  )
{
    //
    // Dialog proc for dialog window
    //
    switch( uMsg )
    {
    case WM_INITDIALOG:
        {
            SHOWDIALOG_MSG* pMsg = (SHOWDIALOG_MSG*) lParam;
            if (pMsg->pwzTitle)
                SetWindowText( hwndDlg, (LPWSTR) pMsg->pwzTitle);
            if (pMsg->pwzText)
            {
                HWND hwndText = GetDlgItem( hwndDlg, IDC_TEXT );
                if (hwndText)
                    SetWindowText( hwndText, (LPWSTR) pMsg->pwzText);
            }
        }
        return TRUE;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
#ifdef IDC_OK
            case IDC_OK:
                EndDialog( hwndDlg, DIALOG_OK );
                return TRUE;
#endif

#ifdef IDC_CANCEL
            case IDC_CANCEL:
                EndDialog( hwndDlg, DIALOG_CANCEL );
                return TRUE;
#endif

            default:
                return FALSE;
              }

    case WM_NOTIFY:
        if ((IDC_TEXT == LOWORD(wParam) ) &&
        ((NM_CLICK == ((LPNMHDR)lParam)->code) ||
        (NM_RETURN == ((LPNMHDR)lParam)->code)))
        {
            PNMLINK pNMLink = (PNMLINK) lParam;

            // check szURL empty
            if (pNMLink->item.szUrl[0] == L'\0')
                return FALSE;
    
            SHELLEXECUTEINFO sei = { 0 };
            sei.cbSize = sizeof(SHELLEXECUTEINFO);
            sei.fMask = SEE_MASK_DOENVSUBST | SEE_MASK_NO_CONSOLE; //SEE_MASK_FLAG_NO_UI |
            sei.nShow = SW_SHOWNORMAL;
            // ISSUE-06/14/02-felixybc  shellexecute should work as such
            //    for some unknown reason it is failing with module not found
            //sei.lpFile = pNMLink->item.szUrl;
            sei.lpParameters=pNMLink->item.szUrl;
            sei.lpFile=L"iexplore.exe";
            //
            sei.lpVerb = L"open";

            // ISSUE: check return with IF_WIN32_FALSE_EXIT(), check hInstApp for detail error
            ShellExecuteEx(&sei);
            return TRUE;
        }
        else
            // WM_NOTIFY not handled.
            return FALSE;

    default:
        return FALSE;
      }
}

extern HINSTANCE g_DllInstance;

HRESULT ShowDialog(HWND hWndParent, WORD wDlgId, LPCWSTR pwzText, LPCWSTR pwzTitle, DWORD& dwReturnValue)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    INT_PTR iptrReturn = 0;
    SHOWDIALOG_MSG msg = {0};

/*    INITCOMMONCONTROLSEX iccex;
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC  = ICC_LINK_CLASS | ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES;
    IF_FALSE_EXIT(InitCommonControlsEx(&iccex), E_FAIL);*/

    msg.pwzTitle = pwzTitle;
    msg.pwzText = pwzText;

    IF_WIN32_FALSE_EXIT((iptrReturn = DialogBoxParam(g_DllInstance, MAKEINTRESOURCE(wDlgId), hWndParent, DialogBoxProc, (LPARAM) &msg) > 0));
    dwReturnValue = PtrToLong((VOID *)iptrReturn);

exit:
    return hr;
}

// ----------------------------------------------------------------------------

HRESULT
RunCommand(LPCWSTR wzAppFileName, LPWSTR pwzCommandline, LPCWSTR wzCurrentDir, BOOL fWait)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    si.cb = sizeof(si);

    // wzCurrentDir: The string must be a full path and file name that includes a drive letter; or NULL
    // note: pwzCommandline is LPWSTR, NOT LPCWSTR
    IF_WIN32_FALSE_EXIT(CreateProcess(wzAppFileName, pwzCommandline, NULL, NULL, FALSE, 0, NULL, wzCurrentDir, &si, &pi));

    if (fWait)
    {
        IF_FALSE_EXIT(!(WaitForSingleObject(pi.hProcess, 180000L) == WAIT_TIMEOUT), HRESULT_FROM_WIN32(ERROR_TIMEOUT));
    }

exit:
    if(pi.hProcess)
    {
        BOOL bReturn = CloseHandle(pi.hProcess);
        if (SUCCEEDED(hr) && !bReturn)
            hr = GetLastWin32Error();
    }
    if(pi.hThread)
    {
        BOOL bReturn = CloseHandle(pi.hThread);
        if (SUCCEEDED(hr) && !bReturn)
            hr = GetLastWin32Error();
    }

    return hr;
}

HRESULT
RunCommandConsole(LPCWSTR wzAppFileName, LPCWSTR wzCurrentDir, BOOL fWait)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwzPath = NULL;
    LPWSTR pwzBuffer = NULL;
    DWORD ccPath = 0;

    CString sAppdir;
    CString sSystemDir;
    CString sCurrentDir;
    CString sCmdExe;    
    CString sCommandLine;
    CString sPath;

    // App dir
    IF_FAILED_EXIT(sAppdir.Assign(wzCurrentDir));

    // System directory.
    // bugbug - platforms; use GetRealWindowsDirectory instead?
    IF_WIN32_FALSE_EXIT((ccPath = GetSystemDirectory(NULL, 0)));
    IF_FALSE_EXIT(ccPath+1 > ccPath, HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));    // check overflow
    ccPath+=1;
    IF_ALLOC_FAILED_EXIT(pwzBuffer = new WCHAR[ccPath]);
    IF_WIN32_FALSE_EXIT(GetSystemDirectory(pwzBuffer, ccPath));
    IF_FAILED_EXIT(sSystemDir.Assign(pwzBuffer));

    // Current dir = root dir
    *(pwzBuffer+ sizeof("c:\\")-1) = L'\0';
    IF_FAILED_EXIT(sCurrentDir.Assign(pwzBuffer));

    // Path to cmd.exe
    IF_FAILED_EXIT(sCmdExe.Assign(sSystemDir));
    IF_FAILED_EXIT(sCmdExe.Append(L"\\cmd.exe"));

    // command line
    IF_FAILED_EXIT(sCommandLine.Assign(L"/k \""));
    IF_FAILED_EXIT(sCommandLine.Append(wzAppFileName));
    IF_FAILED_EXIT(sCommandLine.Append(L"\""));

    // Get current path.
    IF_WIN32_FALSE_EXIT((ccPath = GetEnvironmentVariable(L"PATH", NULL, 0)));
    IF_ALLOC_FAILED_EXIT(pwzPath = new WCHAR[ccPath]);
    IF_WIN32_FALSE_EXIT(GetEnvironmentVariable(L"PATH", pwzPath, ccPath));
    IF_FAILED_EXIT(sPath.TakeOwnership(pwzPath, ccPath));
    pwzPath = NULL;

    // Append app path to current path.
    IF_FAILED_EXIT(sPath.Append(sAppdir));
 
    // set new path env variable.
    IF_WIN32_FALSE_EXIT(SetEnvironmentVariable(L"PATH", sPath._pwz));
    
    IF_FAILED_EXIT(RunCommand(sCmdExe._pwz, sCommandLine._pwz, sCurrentDir._pwz,fWait));

exit:
    SAFEDELETEARRAY(pwzPath);
    SAFEDELETEARRAY(pwzBuffer);

    return hr;
}

// ----------------------------------------------------------------------------

// note: this append a '.manifest' file extension to the given pwzRealName
HRESULT
CopyToUSStartMenu(LPCWSTR pwzFilePath, LPCWSTR pwzRealName, BOOL bOverwrite, LPWSTR* ppwzResultFilePath)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwz = NULL;
    CString sPath;

    IF_ALLOC_FAILED_EXIT(pwz = new WCHAR[MAX_PATH]);
    pwz[0] = L'\0';

    // should it create the folder?  C:\Documents and Settings\username\Start Menu\Programs
    // "Start Menu\Programs" is localized in non-english windows
    IF_FAILED_EXIT(SHGetFolderPath(NULL, CSIDL_PROGRAMS | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, pwz));

    IF_FAILED_EXIT(sPath.TakeOwnership(pwz, 0));
    pwz = NULL;

    // ISSUE-2002/03/27-felixybc  Check returned path from SHGetFolderPath has no trailing '\'
    IF_FAILED_EXIT(sPath.Append(L"\\"));
    IF_FAILED_EXIT(sPath.Append(pwzRealName));
    IF_FAILED_EXIT(sPath.Append(L".manifest"));

    if (!CopyFile(pwzFilePath, sPath._pwz, !bOverwrite))
    {
        hr = GetLastWin32Error();
        ASSERT(hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS));    // do not assert if file already exists
        goto exit;
    }

    // return the file path
    IF_FAILED_EXIT(sPath.ReleaseOwnership(ppwzResultFilePath));

exit:
    SAFEDELETEARRAY(pwz);
    return hr;
}

// ----------------------------------------------------------------------------

// ISSUE-2002/03/30-felixybc  Temp wrapper code
// wrapper for CAssemblyUpdate::RegisterAssemblySubscriptionEx
HRESULT
RegisterAssemblySubscriptionEx(IAssemblyUpdate *pAssemblyUpdate,
    LPWSTR pwzDisplayName,  LPWSTR pwzUrl, IManifestInfo *pSubscriptionInfo)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD *pdw = NULL;
    BOOL *pb = NULL;
    DWORD dwInterval = 0, dwUnit = 0, dwEvent = 0;
    BOOL bDemandConnection = FALSE;
    DWORD dwCB = 0, dwFlag = 0;

    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_INTERVAL, (LPVOID *)&pdw, &dwCB, &dwFlag));
    IF_FALSE_EXIT(pdw != NULL, E_UNEXPECTED);
    dwInterval = *pdw;
    SAFEDELETEARRAY(pdw);

    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_INTERVAL_UNIT, (LPVOID *)&pdw, &dwCB, &dwFlag));
    IF_FALSE_EXIT(pdw != NULL, E_UNEXPECTED);
    dwUnit = *pdw;
    SAFEDELETEARRAY(pdw);
    
    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_EVENT, (LPVOID *)&pdw, &dwCB, &dwFlag));
    IF_FALSE_EXIT(pdw != NULL, E_UNEXPECTED);
    dwEvent = *pdw;
    SAFEDELETEARRAY(pdw);

    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_EVENT_DEMAND_CONNECTION, (LPVOID *)&pb, &dwCB, &dwFlag));
    IF_FALSE_EXIT(pb != NULL, E_UNEXPECTED);
    bDemandConnection = *pb;
    SAFEDELETEARRAY(pb);

    IF_FAILED_EXIT(pAssemblyUpdate->RegisterAssemblySubscriptionEx(pwzDisplayName, 
            pwzUrl, dwInterval, dwUnit, dwEvent, bDemandConnection));

exit:
    return hr;
}

// ----------------------------------------------------------------------------


// BUGBUG hacky should move this from extricon.cpp to util.cpp and declare in project.hpp
extern LONG GetRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                   PCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen);

// ISSUE-2002/03/30-felixybc  Temp read subscription info code
// note: replace this with generic subscription info stored -> IManifestInfo type == MAN_INFO_SUBSCRIPTION
// return: S_OK - success
//      error - error or missing reg key or reg value type not DWORD
HRESULT
CheckSubscribedWithEventSync(LPASSEMBLY_IDENTITY pAsmId, DWORD* pdwEvent)
{
    // copied from service\server\update.cpp
#define WZ_SYNC_EVENT       L"SyncEvent"
#define REG_KEY_FUSION_SUBS       L"Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Subscription"

    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD dwType = 0;
    DWORD dwValue = -1;
    DWORD dwSize = 0;

    CString sSubsKey;
    LPWSTR pwzName = NULL;

    IF_FAILED_EXIT(pAsmId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzName, &dwSize));
    IF_FALSE_EXIT(hr == S_OK, E_FAIL);

    IF_FAILED_EXIT(sSubsKey.Assign(REG_KEY_FUSION_SUBS));
    IF_FAILED_EXIT(sSubsKey.Append(L"\\"));
    IF_FAILED_EXIT(sSubsKey.Append(pwzName));

    dwSize = sizeof(dwValue);

    if (GetRegKeyValue(HKEY_CURRENT_USER, 
        sSubsKey._pwz, WZ_SYNC_EVENT,
        &dwType, (PBYTE) &dwValue, &dwSize)
        == ERROR_SUCCESS)
    {
        *pdwEvent = dwValue;
        hr = S_OK;
    }
    else
    {
        hr = GetLastWin32Error();
    }

exit:
    SAFEDELETEARRAY(pwzName);
    return hr;
}

// ----------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// CreateActivator
// ---------------------------------------------------------------------------
STDAPI
CreateActivator(
    LPACTIVATOR     *ppActivator,
    CDebugLog * pDbgLog,
    DWORD           dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CActivator *pAct = NULL;

    pAct = new(CActivator) (pDbgLog);
    IF_ALLOC_FAILED_EXIT(pAct);
    
exit:

    *ppActivator = pAct;//static_cast<IActivator*> (pAct);

    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CActivator::CActivator(CDebugLog * pDbgLog)
    : _dwSig('vtca'), _cRef(1), _hr(S_OK),
    _pManImport(NULL), _pAsmId(NULL), _pAppInfo(NULL),
    _pManEmit(NULL), _pwzAppRootDir(NULL), _pwzAppManifestPath(NULL),
    _pwzCodebase(NULL), _dwManifestType(MANIFEST_TYPE_UNKNOWN),
    _bIs1stTimeInstall(FALSE), _bIsCheckingRequiredUpdate(FALSE),
#ifdef DEVMODE
    _bIsDevMode(FALSE),
#endif
    _pSecurityMgr(NULL), _hrManEmit(S_OK), _ptPlatform(NULL),
    _dwMissingPlatform(0)
{

    _pDbgLog = pDbgLog;

    if(_pDbgLog)
        _pDbgLog->AddRef();
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CActivator::~CActivator()
{
    if (_ptPlatform)
    {
        for (DWORD dw = 0; dw < _dwMissingPlatform; dw++)
        {
            SAFEDELETEARRAY((_ptPlatform[dw]).pwzName);
            SAFEDELETEARRAY((_ptPlatform[dw]).pwzURL);
        }
        SAFEDELETEARRAY(_ptPlatform);
    }

    SAFERELEASE(_pSecurityMgr);
    SAFERELEASE(_pManEmit);
    SAFERELEASE(_pAsmId);
    SAFERELEASE(_pAppInfo);
    SAFERELEASE(_pManImport);
    SAFERELEASE(_pDbgLog);

    SAFEDELETEARRAY(_pwzAppManifestPath);
    SAFEDELETEARRAY(_pwzAppRootDir);
    SAFEDELETEARRAY(_pwzCodebase);
}


// ---------------------------------------------------------------------------
// CActivator::Initialize
//
//  pwzFileURL can be NULL
// ---------------------------------------------------------------------------
HRESULT CActivator::Initialize(LPCWSTR pwzFilePath, LPCWSTR pwzFileURL)
{
    IManifestInfo *pDependAsmInfo = NULL;
    DWORD dwCount, dwFlag = 0;

    IF_NULL_EXIT(pwzFilePath, E_INVALIDARG);

    if (pwzFileURL != NULL)
        IF_FAILED_EXIT(_sWebManifestURL.Assign((LPWSTR)pwzFileURL));

    // valid start conditions to invoke this function, passing
    // 1. path to desktop manifest (install redirect to subscription manifest on server)
    // 2. path to desktop manifest (install redirect to applicaion manifest on server)
    // 3. path to application manifest (no install, run from source)
    // 4. URL to subscription manifest on server
    // 5. URL to application manifest on server

    if (FAILED(_hr=CreateAssemblyManifestImport(&_pManImport, pwzFilePath, _pDbgLog, 0)))
    {
        Msg(L"Error in loading and parsing the manifest file.");
        goto exit;
    }

    IF_FAILED_EXIT(_pManImport->ReportManifestType(&_dwManifestType));
    if (_dwManifestType == MANIFEST_TYPE_UNKNOWN)
    {
        Msg(L"This manifest does not have a known format type.");
        _hr = E_ABORT;
        goto exit;
    }

    // allow only valid start conditions

    if (_sWebManifestURL._cc != 0 &&
        _dwManifestType != MANIFEST_TYPE_SUBSCRIPTION &&
        _dwManifestType != MANIFEST_TYPE_APPLICATION)
    {
        Msg(L"Not supported: URL pointing to a desktop manifest.");
        _hr = E_ABORT;
        goto exit;
    }

    if (_sWebManifestURL._cc == 0 &&
        _dwManifestType != MANIFEST_TYPE_DESKTOP &&
        _dwManifestType != MANIFEST_TYPE_APPLICATION)
    {
        Msg(L"This manifest does not have the proper format and cannot be used to start an application.");
        _hr = E_ABORT;
        goto exit;
    }

    // get data from the manifest file

    if (_dwManifestType != MANIFEST_TYPE_SUBSCRIPTION)
    {
        if (FAILED(_hr=_pManImport->GetAssemblyIdentity(&_pAsmId)))
        {
            Msg(L"This manifest does not have the proper format and contains no assembly identity.");
            goto exit;
        }
    }

    if (_dwManifestType != MANIFEST_TYPE_APPLICATION)
    {
        // BUGBUG: hardcoded index '0'
        IF_FAILED_EXIT(_pManImport->GetNextAssembly(0, &pDependAsmInfo));
        if (pDependAsmInfo)
        {
            if (_dwManifestType == MANIFEST_TYPE_SUBSCRIPTION)
#ifdef DEVMODE
            {
#endif
                pDependAsmInfo->Get(MAN_INFO_DEPENDENT_ASM_ID, (LPVOID *)&_pAsmId, &dwCount, &dwFlag);
#ifdef DEVMODE

                DWORD *pdw = NULL;

                // is it devMode?
                IF_FAILED_EXIT(pDependAsmInfo->Get(MAN_INFO_DEPENDENT_ASM_TYPE, (LPVOID *)&pdw, &dwCount, &dwFlag));
                IF_FALSE_EXIT(pdw != NULL, E_UNEXPECTED);

                if (*pdw == DEPENDENT_ASM_INSTALL_TYPE_DEVSYNC)
                    _bIsDevMode = TRUE;
                SAFEDELETEARRAY(pdw);
            }
#endif
            
            pDependAsmInfo->Get(MAN_INFO_DEPENDENT_ASM_CODEBASE, (LPVOID *)&_pwzCodebase, &dwCount, &dwFlag);
        }

        if (!_pAsmId || !_pwzCodebase)
        {
            Msg(L"This subscription manifest contains no dependent assembly identity or a subscription codebase.");
            _hr = E_FAIL;
            goto exit;
        }
    }
    else
    {
        if (_sWebManifestURL._cc != 0)
        {
            // if URL->app manifest (case 5), codebase is that URL
            // note: if path->app manifest (case 3), this does NOT apply

            // BUGBUG: HACK: this implies re-download of the app manifest. pref?

            size_t ccCodebase = wcslen(pwzFileURL)+1;
            _pwzCodebase = new WCHAR[ccCodebase];
            IF_ALLOC_FAILED_EXIT(_pwzCodebase);

            memcpy(_pwzCodebase, pwzFileURL, ccCodebase * sizeof(WCHAR));
        }
    }

    if (_sWebManifestURL._cc == 0 &&
        _dwManifestType == MANIFEST_TYPE_APPLICATION)
    {
        // run from source
        // set _pwzAppRootDir, _pwzAppManifestPath
        CString sManifestFilePath;
        CString sManifestFileDir;

        IF_FAILED_EXIT(sManifestFilePath.Assign(pwzFilePath));

        IF_FAILED_EXIT(sManifestFileDir.Assign(sManifestFilePath));
        IF_FAILED_EXIT(sManifestFileDir.RemoveLastElement());
        IF_FAILED_EXIT(sManifestFileDir.Append(L"\\"));
        IF_FAILED_EXIT(sManifestFileDir.ReleaseOwnership(&_pwzAppRootDir));

        IF_FAILED_EXIT(sManifestFilePath.ReleaseOwnership(&_pwzAppManifestPath));
    }

exit:
    SAFERELEASE(pDependAsmInfo)
    return _hr;
}


// ---------------------------------------------------------------------------
// CActivator::Process
// ---------------------------------------------------------------------------
HRESULT CActivator::Process()
{
    LPWSTR pwzDesktopManifestTempPath = NULL;
    DWORD dwCount = 0, dwFlag = 0;

    IF_NULL_EXIT(_pAsmId, E_UNEXPECTED); // not initialized

    if (_sWebManifestURL._cc == 0 &&
        _dwManifestType == MANIFEST_TYPE_APPLICATION)
    {
        // run from source

        if (FAILED(_hr=_pManImport->GetManifestApplicationInfo(&_pAppInfo)) || _hr==S_FALSE)
        {
            // can't continue without this...
            _hr = E_ABORT;
            Msg(L"The application manifest does not have the shell information and cannot be used to start an application.");
            goto exit;
        }

        // bypass other processing
        // _pwzAppRootDir, _pwzAppManifestPath are already set in Initialize
        _hr = S_FALSE;
        goto exit;
    }

    // search cache, download/install if necessary

    // BUGBUG: UGLY - pManImport & pwzFileURL are needed only for desktop manifest stuff.
    //    This and below subscription registration should be cleaned up once assemblydownload is restructured.
    ///   (see checks for "_sWebManifestURL._cc != 0 && dwManifestType == MANIFEST_TYPE_SUBSCRIPTION")

    IF_FAILED_EXIT(ResolveAndInstall(&pwzDesktopManifestTempPath));

    // register for updates

    if (_bIs1stTimeInstall && _sWebManifestURL._cc != 0 && _dwManifestType == MANIFEST_TYPE_SUBSCRIPTION)
    {
        // note: this code must be identical to what assemblydownload.cpp DoCacheUpdate() does!
        LPWSTR pwzName = NULL;

        if ((_hr = _pAsmId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzName, &dwCount)) != S_OK)
        {
            ShowError(_hr, L"Error in retrieving assembly name. Cannot register subscription for updates.");
            // note: This- no asm name- should not be allowed!
        }
        else
        {
            IAssemblyUpdate *pAssemblyUpdate = NULL;

            // register for updates
            _hr = CoCreateInstance(CLSID_CAssemblyUpdate, NULL, CLSCTX_LOCAL_SERVER, 
                                    IID_IAssemblyUpdate, (void**)&pAssemblyUpdate);
            if (SUCCEEDED(_hr))
            {
                IManifestInfo* pSubsInfo = NULL;
                if (SUCCEEDED(_hr = _pManImport->GetSubscriptionInfo(&pSubsInfo)))
                {
                    _hr = RegisterAssemblySubscriptionEx(pAssemblyUpdate, pwzName, 
                            _sWebManifestURL._pwz, pSubsInfo);
                    pSubsInfo->Release();
                }

                pAssemblyUpdate->Release();
            }

            if (FAILED(_hr))
            {
                ShowError(_hr, L"Error in update services. Cannot register subscription for updates.");
                //goto exit; do not terminate!fail gracefully
            }

            // BUGBUG: need a way to recover from this and register later

            delete[] pwzName;
        }
    }

    // CVersionManagement's RegisterInstall() below requires a manifest import to an application manifest
    if (_sWebManifestURL._cc != 0 || pwzDesktopManifestTempPath)
    {
        // if URL, crack the app manifest to get shell state info

        // BUGBUG: if URL->app manifest (case 5), pwzFilePath is a copy and is already cracked-so no need in that case?

        _pManImport->Release();
        if (FAILED(_hr=CreateAssemblyManifestImport(&_pManImport, _pwzAppManifestPath, _pDbgLog, 0)))
        {
            Msg(L"Error in loading and parsing the application manifest file.");
            goto exit;
        }
    }

    if (FAILED(_hr=_pManImport->GetManifestApplicationInfo(&_pAppInfo)) || _hr==S_FALSE)
    {
        // can't continue without this...
        _hr = E_ABORT;
        Msg(L"This manifest does not have the shell information and cannot be used to start an application.");
        goto exit;
    }

    // copy desktop manifest, if present
    // even if the app deployment can possibly be broken and will not execute
    if (pwzDesktopManifestTempPath)
    {
        LPWSTR pwzFriendlyName = NULL;

        // BUGBUG: should get status on the desktop manifest generated, not copy in some cases, eg. file size == 0 or XMLDOM errors
        // use _hrManEmit to check

        if (FAILED(_hr = _pAppInfo->Get(MAN_INFO_APPLICATION_FRIENDLYNAME, (LPVOID *)&pwzFriendlyName, &dwCount, &dwFlag)))
        {
            Msg(L"This application does not have a friendly name specified, no desktop manifest is generated and the installation is not registered.");
        }
        else
        {
            // BUGBUG: should somehow continue even w/o a friendly name? name conflict?

            IF_FALSE_EXIT(pwzFriendlyName != NULL, E_UNEXPECTED);

            LPWSTR pwzDesktopManifestPath = NULL;

            _hr = CopyToUSStartMenu(pwzDesktopManifestTempPath, pwzFriendlyName, FALSE, &pwzDesktopManifestPath);

            delete[] pwzFriendlyName;

            // note: if a file with the same name already exists, the desktop manifest is not copied over
            //  and so, this existing file will not be deleted when this app is uninstalled.

            // ISSUE-2002/03/27-felixybc  finalize on what to do if file already exists - this could be a name squatting attack

            IF_FALSE_EXIT(!(FAILED(_hr) && _hr != HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)), _hr);     // _hr from CopyToUSStartMenu() above...

            LPVERSION_MANAGEMENT pVerMan = NULL;

            if (SUCCEEDED(_hr = CreateVersionManagement(&pVerMan, 0)))
            {
                HRESULT hrVerMan = S_OK;
                if (FAILED(hrVerMan = pVerMan->RegisterInstall(_pManImport, pwzDesktopManifestPath)))
                {
                    ShowError(hrVerMan, L"Error registering installation. Uninstall of this application cannot be done in Add/Remove Programs.");
                    //goto exit; did not change _hr
                }
            }

            delete [] pwzDesktopManifestPath;
            if (pVerMan)
                pVerMan->Release();

            // _hr from CreateVersionManagement() above...
            IF_FAILED_EXIT(_hr);
        }
    }


exit:
    if (pwzDesktopManifestTempPath)
    {
        // delete the temp file for desktop manifest
        BOOL bReturn = DeleteFile(pwzDesktopManifestTempPath);
        if (SUCCEEDED(_hr) && !bReturn)
            _hr = GetLastWin32Error();  // else ignore return value

        delete[] pwzDesktopManifestTempPath;
    }

    return _hr;
}


// ---------------------------------------------------------------------------
// CActivator::Execute
// ---------------------------------------------------------------------------
HRESULT CActivator::Execute()
{
    LPWSTR pwzEntrypoint = NULL;
    LPWSTR pwzType = NULL;
    LPWSTR pwzAssemblyName = NULL;
    LPWSTR pwzAssemblyClass = NULL;
    LPWSTR pwzAssemblyMethod = NULL;
    LPWSTR pwzAssemblyArgs = NULL;

    LPWSTR pwzCmdLine = NULL;
    int iAppType = 0;
    DWORD dwCount, dwFlag = 0;

    IF_NULL_EXIT(_pAppInfo, E_UNEXPECTED); // not processed

    // execute the app

    IF_FAILED_EXIT(_pAppInfo->Get(MAN_INFO_APPLICATION_ENTRYPOINT, (LPVOID *)&pwzEntrypoint, &dwCount, &dwFlag));
    if(pwzEntrypoint && *pwzEntrypoint == L'\0')
        SAFEDELETEARRAY(pwzEntrypoint);

    if (FAILED(_hr = _pAppInfo->Get(MAN_INFO_APPLICATION_ENTRYIMAGETYPE, (LPVOID *)&pwzType, &dwCount, &dwFlag)))
    {
        Msg(L"Error in retrieving application type. Cannot continue.");
        goto exit;
    }
    IF_FALSE_EXIT(pwzType != NULL, E_UNEXPECTED);

    IF_FAILED_EXIT(FusionCompareString(pwzType, WZ_TYPE_DOTNET, 0));
    if (_hr == S_OK)
        iAppType = TYPE_DOTNET;
    else
    {
        IF_FAILED_EXIT(FusionCompareString(pwzType, WZ_TYPE_WIN32, 0));        
        if (_hr == S_OK)
            iAppType = TYPE_WIN32;
        else
        {
            IF_FAILED_EXIT(FusionCompareString(pwzType, WZ_TYPE_AVALON, 0));        
            if (_hr == S_OK)
                iAppType = TYPE_AVALON;
            else
            {
                IF_FAILED_EXIT(FusionCompareString(pwzType, WZ_TYPE_CONSOLE, 0));        
                if (_hr == S_OK)
                    iAppType = TYPE_CONSOLE;
                else
                {
                    // unknown type
                    Msg(L"Unsupported application type. Cannot continue.");
                    _hr = E_ABORT;
                    goto exit;
                }
            }
        }
    }

    if( (iAppType == TYPE_CONSOLE) || (iAppType == TYPE_WIN32) ) 
    {
        if(!pwzEntrypoint)
        {
            Msg(L"Entry point not specified. Could not run this application.");
            goto exit;
        }

        size_t ccWorkingDir = wcslen(_pwzAppRootDir);
        size_t ccEntryPoint = wcslen(pwzEntrypoint)+1;
        pwzCmdLine = new WCHAR[ccWorkingDir+ccEntryPoint];  // 2 strings + '\0'
        IF_ALLOC_FAILED_EXIT(pwzCmdLine);

        memcpy(pwzCmdLine, _pwzAppRootDir, ccWorkingDir * sizeof(WCHAR));
        memcpy(pwzCmdLine+ccWorkingDir, pwzEntrypoint, ccEntryPoint * sizeof(WCHAR));

        // check if the entry point is in cache or not
        BOOL bExists = FALSE;
        IF_FAILED_EXIT(CheckFileExistence(pwzCmdLine, &bExists));
        if (!bExists)
        {
            Msg(L"Entry point does not exist. Cannot continue.");
            _hr = E_ABORT;
            goto exit;
        }
    }


    if (iAppType == TYPE_DOTNET || iAppType == TYPE_AVALON)
    {
#if 0
        DWORD dwZone;
#endif

        // ISSUE - note: ndphost should do the checking below instead
        IF_FAILED_EXIT(_pAppInfo->Get(MAN_INFO_APPLICATION_ASSEMBLYNAME, 
                              (LPVOID *)&pwzAssemblyName, &dwCount, &dwFlag));
        if(pwzAssemblyName && *pwzAssemblyName == L'\0')
            SAFEDELETEARRAY(pwzAssemblyName);

        IF_FAILED_EXIT(_pAppInfo->Get(MAN_INFO_APPLICATION_ASSEMBLYCLASS, 
                              (LPVOID *)&pwzAssemblyClass, &dwCount, &dwFlag));
        if(pwzAssemblyClass && *pwzAssemblyClass == L'\0')
            SAFEDELETEARRAY(pwzAssemblyClass);

        IF_FAILED_EXIT(_pAppInfo->Get(MAN_INFO_APPLICATION_ASSEMBLYMETHOD, 
                              (LPVOID *)&pwzAssemblyMethod, &dwCount, &dwFlag));
        if(pwzAssemblyMethod && *pwzAssemblyMethod == L'\0')
            SAFEDELETEARRAY(pwzAssemblyMethod);

        IF_FAILED_EXIT(_pAppInfo->Get(MAN_INFO_APPLICATION_ASSEMBLYARGS, 
                              (LPVOID *)&pwzAssemblyArgs, &dwCount, &dwFlag));
        if(pwzAssemblyArgs && *pwzAssemblyArgs == L'\0')
            SAFEDELETEARRAY(pwzAssemblyArgs);

        if(!pwzAssemblyName)
        {
            Msg(L"The application manifest does not have an activation assembly.");
            _hr = E_ABORT;
            goto exit;
        }

        if(pwzEntrypoint)
        {
            Msg(L"Entrypoint cannot be specified for managed code application types.");
            _hr = E_ABORT;
            goto exit;
        }

        if((pwzAssemblyClass && !pwzAssemblyMethod)
            || (!pwzAssemblyClass && pwzAssemblyMethod)
            || (pwzAssemblyArgs && !pwzAssemblyClass))
        {
            Msg(L"Both AssemblyClass and AssemblyMethod must be specified.");
            _hr = E_ABORT;
            goto exit;
        }

        // note: at this point the codebase can be: URL to app manifest _or_ URL to subscription manifest
        //    (depends on how 1st time install is started with)
        if ((_sWebManifestURL._cc != 0 ||
            _dwManifestType != MANIFEST_TYPE_APPLICATION) &&        // run from source
            _pwzCodebase == NULL)
        {
            Msg(L"This application does not have a codebase specified. Cannot continue to execute .NetAssembly.");
            _hr = E_ABORT;
            goto exit;
        }

#if 0
        if (_pSecurityMgr == NULL)
        {
            // lazy init.
            _hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                IID_IInternetSecurityManager, (void**)&_pSecurityMgr);
            if (FAILED(_hr))
                _pSecurityMgr = NULL;
            IF_FAILED_EXIT(_hr);
        }

        // BUGBUG?: shouldn't use codebase from ref manifest to set zone?
        IF_FAILED_EXIT(_pSecurityMgr->MapUrlToZone(_pwzCodebase, &dwZone, 0));
#endif

#if 0   // old code
        // BUGBUG: hack for avalon (bug # 875)
        SetCurrentDirectory(_pwzAppRootDir);

        try
        {
            IAsmExecutePtr pIAsmExecute(__uuidof(AsmExecute));
            long lRetVal = -1;
            long lFlag = 0x3;
            LPWSTR pwzArg = NULL;

            // BUGBUG: change AsmExec if it's no longer needed to send commandline argument
            //          clean up interface

            if (iAppType == TYPE_AVALON)
            {
                // call with manifest file path as a parameter
                //pwzArg = pwzAppManifestPath;  avalon arg hack

                // pass Avalon flag
                lFlag = 0x1003;

// BUGBUG: a hack to show debug msg
AllocConsole();
            }

            //parameters: Codebase/filepath Flag Zone Url Arg
            // BUGBUG: DWORD is unsigned and long is signed

            _hr = pIAsmExecute->Execute(_bstr_t(pwzCmdLine), lFlag, dwZone, _bstr_t(_pwzCodebase), _bstr_t(pwzArg), &lRetVal);

            // BUGBUG: do something about lRetVal
        }
        catch (_com_error &e)
        {
            _hr = e.Error();
            Msg((LPWSTR)e.ErrorMessage());
        }

        // BUGBUG: get/display the actual error message
        // _hr from Execute() or inside catch(){} above
        if (FAILED(_hr))
            goto exit;
#else
        CString sHostPath;
        CString sCommandLine;
//        IF_FAILED_EXIT(MakeCommandLine(_pwzAppRootDir, pwzAssemblyName, pwzAssemblyClass, pwzAssemblyMethod, pwzAssemblyArgs, _pwzCodebase, dwZone, sHostPath, sCommandLine));
        IF_FAILED_EXIT(MakeCommandLine(_pwzAppManifestPath, _pwzCodebase, sHostPath, sCommandLine));
        IF_FAILED_EXIT(RunCommand(sHostPath._pwz, sCommandLine._pwz, _pwzAppRootDir, FALSE));
#endif
    }
    else if (iAppType == TYPE_WIN32)
    {
        // BUGBUG: Win32 app has no sandboxing... use SAFER?

        // BUGBUG: start directory: what if the exe is in a subdir of pwzAppRootDir?

        // CreateProcess dislike having the filename in the path for the start directory
        if (FAILED(_hr=RunCommand(pwzCmdLine, NULL, _pwzAppRootDir, FALSE)))
        {
            ShowError(_hr, L"Win32Executable: Create process error.");
            _hr = E_ABORT;
            goto exit;
        }
    }
    else if (iAppType == TYPE_CONSOLE)
    {
        // BUGBUG: Win32 app has no sandboxing... use SAFER?

        // BUGBUG: start directory: what if the exe is in a subdir of pwzAppRootDir?

        // CreateProcess dislike having the filename in the path for the start directory
        if (FAILED(_hr=RunCommandConsole(pwzCmdLine, _pwzAppRootDir, FALSE)))
        {
            ShowError(_hr, L"Win32Console: Create process error.");
            _hr = E_ABORT;
            goto exit;
        }
    }
    //else
        // unknown type....

exit:
    SAFEDELETEARRAY(pwzEntrypoint);
    SAFEDELETEARRAY(pwzType);
    SAFEDELETEARRAY(pwzCmdLine);

    SAFEDELETEARRAY(pwzAssemblyName);
    SAFEDELETEARRAY(pwzAssemblyClass);
    SAFEDELETEARRAY(pwzAssemblyMethod);
    SAFEDELETEARRAY(pwzAssemblyArgs);

    return _hr;
}


// ---------------------------------------------------------------------------
// CActivator::OnProgress
// ---------------------------------------------------------------------------
HRESULT CActivator::OnProgress(DWORD   dwNotification, HRESULT hrNotification,
                                    LPCWSTR szNotification, DWORD  dwProgress,
                                    DWORD  dwProgressMax, IUnknown *pUnk)
{
    LPASSEMBLY_MANIFEST_IMPORT pManifestImport = NULL;
    LPASSEMBLY_IDENTITY pAsmId = NULL;
    IManifestInfo *pDependAsmInfo = NULL;

    // only handles notification it cares
    if (dwNotification == ASM_NOTIFICATION_SUBSCRIPTION_MANIFEST ||
        dwNotification == ASM_NOTIFICATION_APPLICATION_MANIFEST)
    {
        // szNotification == URL to manifest
        IF_NULL_EXIT(szNotification, E_INVALIDARG);

        // pUnk == manifest import of manifest
        IF_FAILED_EXIT(pUnk->QueryInterface(IID_IAssemblyManifestImport, (LPVOID*) &pManifestImport));

        if (dwNotification == ASM_NOTIFICATION_SUBSCRIPTION_MANIFEST)
        {
            LPWSTR pwzName = NULL;
            DWORD dwCount = 0;

            IF_FAILED_EXIT(_pAsmId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzName, &dwCount));

            {
                IAssemblyUpdate *pAssemblyUpdate = NULL;

                // register for updates
                _hr = CoCreateInstance(CLSID_CAssemblyUpdate, NULL, CLSCTX_LOCAL_SERVER, 
                                        IID_IAssemblyUpdate, (void**)&pAssemblyUpdate);
                if (SUCCEEDED(_hr))
                {
                    IManifestInfo* pSubsInfo = NULL;
                    if (SUCCEEDED(_hr = pManifestImport->GetSubscriptionInfo(&pSubsInfo)))
                    {
                        _hr = RegisterAssemblySubscriptionEx(pAssemblyUpdate, pwzName, 
                                (LPWSTR) szNotification, pSubsInfo);
                        pSubsInfo->Release();
                    }

                    pAssemblyUpdate->Release();
                }

                delete[] pwzName;

                // do not fail... should show UI?
                if (FAILED(_hr))
                    _hr = S_OK;
                   // goto exit;

                // BUGBUG: need a way to recover from this and register later
            }

            // export dependency/dependentassembly/assemblyIdentity & subscription
            if (_pManEmit)
                _hrManEmit = _pManEmit->SetDependencySubscription(pManifestImport, (LPWSTR)szNotification);
            else if (_bIsCheckingRequiredUpdate)
            {
                // if _bIsCheckingRequiredUpdate, _pManEmit == NULL,
                // and must be downloading subscription manifest

                // check if required update

                BOOL bIsToDownload = FALSE;   // default is normal

                // BUGBUG: hardcoded index '0'
                IF_FAILED_EXIT(pManifestImport->GetNextAssembly(0, &pDependAsmInfo));
                IF_FALSE_EXIT(_hr == S_OK, E_FAIL);
                if (pDependAsmInfo)
                {
                    LPASSEMBLY_CACHE_IMPORT pCacheImport = NULL;
                    DWORD dwFlag= 0;

                    //already has it?
                    IF_FAILED_EXIT(pDependAsmInfo->Get(MAN_INFO_DEPENDENT_ASM_ID, (LPVOID *)&pAsmId, &dwCount, &dwFlag));
                    IF_FALSE_EXIT(pAsmId != NULL, E_UNEXPECTED);

                    IF_FAILED_EXIT(CreateAssemblyCacheImport(&pCacheImport, pAsmId, CACHEIMP_CREATE_RETRIEVE));
                    if (_hr == S_FALSE)
                    {
                        // no, does not have it

                        DWORD *pdw = NULL;

                        // is it required?
                        IF_FAILED_EXIT(pDependAsmInfo->Get(MAN_INFO_DEPENDENT_ASM_TYPE, (LPVOID *)&pdw, &dwCount, &dwFlag));
                        IF_FALSE_EXIT(pdw != NULL, E_UNEXPECTED);

                        if (*pdw == DEPENDENT_ASM_INSTALL_TYPE_REQUIRED)
                            bIsToDownload = TRUE;   // yes, it is required
#ifdef DEVMODE
                        else if (*pdw == DEPENDENT_ASM_INSTALL_TYPE_DEVSYNC)
                            bIsToDownload = TRUE;   // yes, it is devsync, assume required
#endif
                        SAFEDELETEARRAY(pdw);
                    }

                    SAFERELEASE(pCacheImport);
                }

                if (!bIsToDownload)
                    _hr = E_ABORT;  // signal abort the download
            }
        }
        else if (dwNotification == ASM_NOTIFICATION_APPLICATION_MANIFEST)
        {
            // check for dependent platforms
            IF_FAILED_EXIT(CheckPlatformRequirementsEx(pManifestImport, _pDbgLog, &_dwMissingPlatform, &_ptPlatform));
            IF_TRUE_EXIT((_dwMissingPlatform > 0), E_ABORT);

            if (_pManEmit)
            {
                // export assemblyIdentity & application

                // ignore failure
                _hrManEmit = _pManEmit->ImportManifestInfo(pManifestImport);

                // export dependency/dependentassembly/assemblyIdentity & subscription
                // ignore failure, if already called once this is ignored
                _hrManEmit = _pManEmit->SetDependencySubscription(pManifestImport, (LPWSTR)szNotification);
            }
        }
    }
    else
        _hr = S_OK;

exit:
    SAFERELEASE(pAsmId);
    SAFERELEASE(pDependAsmInfo);

    SAFERELEASE(pManifestImport);
    return _hr;
}

// IUnknown methods

// ---------------------------------------------------------------------------
// CActivator::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CActivator::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
//        || IsEqualIID(riid, IID_IActivator)
       )
    {
        *ppvObj = this; //static_cast<IActivator*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CActivator::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CActivator::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CActivator::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CActivator::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

// ----------------------------------------------------------------------------

HRESULT CreateTempFile(LPCWSTR pcwzPrefix, LPWSTR *ppwzFilePath)
{
    #define DEFAULT_PATH_LEN MAX_PATH
    #define TEMP_FILE_NAME_LEN sizeof("preuuuu.TMP")    // from msdn
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwzTempPath = NULL;
    LPWSTR pwzTempFilePath = NULL;

    IF_NULL_EXIT(pcwzPrefix, E_INVALIDARG);
    IF_NULL_EXIT(ppwzFilePath, E_INVALIDARG);
    *ppwzFilePath = NULL;

    IF_FALSE_EXIT(lstrlen(pcwzPrefix) == 3, E_INVALIDARG);

    // assemble temp file path
    IF_ALLOC_FAILED_EXIT(pwzTempPath = new WCHAR[DEFAULT_PATH_LEN]);

    // ISSUE-2002/03/31-felixybc  GetTempPath can overrun the buffer?
    DWORD dwLen = GetTempPath(DEFAULT_PATH_LEN, pwzTempPath);
    IF_WIN32_FALSE_EXIT(dwLen);

    if (dwLen >= DEFAULT_PATH_LEN)
    {
        // resize, add 1 for terminating null
        IF_FALSE_EXIT(dwLen+1 > dwLen, HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));    // check overflow
        SAFEDELETEARRAY(pwzTempPath);
        IF_ALLOC_FAILED_EXIT(pwzTempPath = new WCHAR[dwLen+1]);

        DWORD dwLenNew = GetTempPath(dwLen+1, pwzTempPath);
        IF_WIN32_FALSE_EXIT(dwLenNew);

        IF_FALSE_EXIT(dwLenNew < dwLen+1, E_FAIL);  // why is it still not enough?
    }

    DWORD dwBufLen = lstrlen(pwzTempPath)+1;
    // note: can do a better check here
    IF_FALSE_EXIT(dwBufLen > 1, E_FAIL);

    // allocate buffer large enough for temp path and temp file name
    DWORD dwLenNew = (dwBufLen > DEFAULT_PATH_LEN)? dwBufLen : DEFAULT_PATH_LEN;
    dwLenNew += TEMP_FILE_NAME_LEN;

    // check for overflow
    IF_FALSE_EXIT(dwLenNew > dwBufLen, E_FAIL);

    IF_ALLOC_FAILED_EXIT(pwzTempFilePath = new WCHAR[dwLenNew]);
//    *pwzTempFilePath = L'\0';

    // note: temp file to be deleted by the caller
    IF_WIN32_FALSE_EXIT(GetTempFileName(pwzTempPath, pcwzPrefix, 0, pwzTempFilePath));

    *ppwzFilePath = pwzTempFilePath;
    pwzTempFilePath = NULL;

exit:
/*    if (FAILED(hr) && pwzTempFilePath != NULL)
    {
        if (*pwzTempFilePath != L'\0')
        {
            // ignore if error deleting the file
            DeleteFile(pwzTempFilePath);
        }
    }*/

    SAFEDELETEARRAY(pwzTempFilePath);
    SAFEDELETEARRAY(pwzTempPath);

    return hr;
}
// ---------------------------------------------------------------------------
// CActivator::ResolveAndInstall
// note: parameter _pwzCodebase can be NULL
//     must delete if *ppwzDesktopManifestPathName != NULL
// ---------------------------------------------------------------------------
HRESULT CActivator::ResolveAndInstall(LPWSTR *ppwzDesktopManifestPathName)
{
    LPASSEMBLY_CACHE_IMPORT pCacheImport = NULL;
    DWORD dwCC = 0;

    _bIs1stTimeInstall = FALSE;

    // look into the cache

    IF_FAILED_EXIT(CreateAssemblyCacheImport(&pCacheImport, _pAsmId, CACHEIMP_CREATE_RESOLVE_REF));

    // hr from CreateAssemblyCacheImport() above
    
    // Case 1, cached copy exist
    // _hr == S_OK

    if (_hr == S_OK && _dwManifestType == MANIFEST_TYPE_DESKTOP)
    {
        // BUGBUG: broken if subscribed then run with a desktop manifest generated with URL to app manifest
        // should check and ignore if desktop manifest redirect to applicaion manifest on server
        // as there is no way to check for update/changes in subscription manifest, even if subscribed so
        // correct fix is to use subscription manifest's URL stored

        // check if subscribed with event sync

        DWORD dwSyncEvent = MAN_INFO_SUBSCRIPTION_MAX;
        _hr = CheckSubscribedWithEventSync(_pAsmId, &dwSyncEvent);
        // ISSUE-2002/04/12-felixybc  If the value is absent, ERROR_NO_MORE_FILES is returned.
        //     Note that dwSyncEvent is unmodified.
        if (_hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            IF_FAILED_EXIT(_hr);

        if (dwSyncEvent == SUBSCRIPTION_SYNC_EVENT_ON_APP_STARTUP)
        {
            LPASSEMBLY_DOWNLOAD pAsmDownload = NULL;

            // event sync onApplicationStartup == required update

            // _pwzCodebase != NULL

            // check policy before download
            IF_FAILED_EXIT(CheckZonePolicy(_pwzCodebase));

            IF_FAILED_EXIT(CreateAssemblyDownload(&pAsmDownload, _pDbgLog, 0));

            _bIsCheckingRequiredUpdate = TRUE;

            // (synchronous & ui & bindsink) download from codebase
            _hr=pAsmDownload->DownloadManifestAndDependencies(_pwzCodebase, this, DOWNLOAD_FLAGS_PROGRESS_UI | DOWNLOAD_FLAGS_NOTIFY_BINDSINK);
            pAsmDownload->Release();
            _bIsCheckingRequiredUpdate = FALSE;

            // hr from DownloadManifestAndDependencies() above
            if (FAILED(_hr))
            {
                if (_hr != E_ABORT)
                {
                    HRESULT hrTemp;
                    CString sErrMsg;
                    if(SUCCEEDED(hrTemp = _pDbgLog->GetLoggedMsgs(0, sErrMsg)))
                    {
                        hrTemp = sErrMsg.Append(L"Error in file download while checking for required update. Cannot continue.");
                        if(SUCCEEDED(hrTemp))
                        {
                            ShowError(sErrMsg._pwz);
                            _hr = E_ABORT;
                        }
                    }
                }
                goto exit;
            }

            IF_FAILED_EXIT(HandlePlatformCheckResult());

            SAFERELEASE(pCacheImport);
            // either no required update needed, or another version have been completely downloaded at this time...
            // BUGBUG: Determine if abort done by our bindsink when no required update - thus no need to re-create cache import.
            // get cache dir again to ensure running the highest version
            IF_FAILED_EXIT(CreateAssemblyCacheImport(&pCacheImport, _pAsmId, CACHEIMP_CREATE_RESOLVE_REF));

            if (_hr == S_FALSE)
            {
                // should never happen, at least 1 was found before
                Msg(L"No completed cached version found. Possible cache corruption. Cannot continue.");
                _hr = E_ABORT;
                goto exit;
            }
        }
        else
            // if _hr == error, ignore
            _hr = S_OK;
    }

    // Case 2, cached copy (of the referenced version) not exist
    else if (_hr == S_FALSE)
    {
        LPASSEMBLY_DOWNLOAD pAsmDownload = NULL;

        // BUGBUG?: what if it is not a partial ref but there's actually another version installed?

        if (_pwzCodebase == NULL)
        {
            Msg(L"No completed cached version of this application found and this manifest cannot be used to initiate an install. Cannot continue.");
            _hr = E_FAIL;
            goto exit;
        }

        // create temp file name
        IF_FAILED_EXIT(CreateTempFile(L"DMA", ppwzDesktopManifestPathName));        // desktop manifest file

        _bIs1stTimeInstall = TRUE;

        // check policy before download
        IF_FAILED_EXIT(CheckZonePolicy(_pwzCodebase));

#ifdef DEVMODE
        IF_FAILED_EXIT(CreateAssemblyDownload(&pAsmDownload, _pDbgLog, (_bIsDevMode ? DOWNLOAD_DEVMODE : 0)));
#else
        IF_FAILED_EXIT(CreateAssemblyDownload(&pAsmDownload, _pDbgLog, 0));
#endif

        // should generate the desktop manifest file if 1st time install (from mimehandler or not)
        // or even if it subsequently fails
        // ignore error
        _hrManEmit=CreateAssemblyManifestEmit(&_pManEmit, *ppwzDesktopManifestPathName, MANIFEST_TYPE_DESKTOP);

        // BUGBUG: UGLY - _pManImport & _sWebManifestURL._pwz are needed only for desktop manifest stuff.
        // ???
        //  This should be cleaned up once assemblydownload is restructured.
        //  (see checks for "_sWebManifestURL._cc != 0 && dwManifestType == MANIFEST_TYPE_SUBSCRIPTION")
        if (_sWebManifestURL._cc != 0 && _dwManifestType == MANIFEST_TYPE_SUBSCRIPTION && _pManEmit)
        {
            // export dependency/dependentassembly/assemblyIdentity & subscription

            // ignore failure
            _hrManEmit = _pManEmit->SetDependencySubscription(_pManImport, _sWebManifestURL._pwz);
        }

        //BUGBUG: need ref def matching checks for desktop->subscription->app manifests' ids

        // (synchronous & ui & bindsink) download from codebase
        _hr=pAsmDownload->DownloadManifestAndDependencies(_pwzCodebase, this, DOWNLOAD_FLAGS_PROGRESS_UI | DOWNLOAD_FLAGS_NOTIFY_BINDSINK);
        pAsmDownload->Release();
        if (_pManEmit)
        {
            // write out desktop manifest
            _hrManEmit = _pManEmit->Commit();
            SAFERELEASE(_pManEmit);
        }

        // hr from DownloadManifestAndDependencies() above
        if (FAILED(_hr))
        {
            if (_hr == E_ABORT)
            {
            //                Msg(L"File download canceled.");                
            }
            else
            {
                HRESULT hrTemp;
                CString sErrMsg;
                if(SUCCEEDED(hrTemp = _pDbgLog->GetLoggedMsgs(0, sErrMsg)))
                {
                    hrTemp = sErrMsg.Append(L"Error in file download. Cannot continue.");
                    if(SUCCEEDED(hrTemp))
                    {
                        ShowError(sErrMsg._pwz);
                        _hr = E_ABORT;
                    }
                }
            }
            goto exit;
        }

        IF_FAILED_EXIT(HandlePlatformCheckResult());

        // another version might have been completed at this time...
        // get cache dir again to ensure running the highest version
        IF_FAILED_EXIT(CreateAssemblyCacheImport(&pCacheImport, _pAsmId, CACHEIMP_CREATE_RESOLVE_REF));

        if (_hr == S_FALSE)
        {
            Msg(L"No completed cached version found. Possible error in download cache commit. Cannot continue.");
            _hr = E_ABORT;
            goto exit;
        }
    }

    IF_FAILED_EXIT(pCacheImport->GetManifestFileDir(&_pwzAppRootDir, &dwCC));
    IF_FALSE_EXIT(dwCC >= sizeof("c:\\"), E_FAIL);   // this should never happen

    IF_FAILED_EXIT(pCacheImport->GetManifestFilePath(&_pwzAppManifestPath, &dwCC));

exit:
    SAFERELEASE(pCacheImport);

    if (FAILED(_hr))
    {
        SAFEDELETEARRAY(_pwzAppRootDir);
        SAFEDELETEARRAY(_pwzAppManifestPath);
    }

    return _hr;
}

// ----------------------------------------------------------------------------

HRESULT CActivator::HandlePlatformCheckResult()
{
    if (_dwMissingPlatform > 0)
    {
        //    L"Single link: <a href=\"http://foo\" id=\"id1\">link</a>"
        DWORD dwReturn = 0;
        CString sText;

        IF_FAILED_EXIT(sText.Assign(L"The required version of "));
        IF_FAILED_EXIT(sText.Append((_ptPlatform[0]).pwzName));
        IF_FAILED_EXIT(sText.Append(L" is not available on this system.\n\nMore information about this platform can be found at \n<a href=\""));
        IF_FAILED_EXIT(sText.Append((_ptPlatform[0]).pwzURL));
        IF_FAILED_EXIT(sText.Append(L"\">"));
        IF_FAILED_EXIT(sText.Append((_ptPlatform[0]).pwzURL));
        IF_FAILED_EXIT(sText.Append(L"</a>"));

        IF_FAILED_EXIT(ShowDialog(NULL, IDD_LINKDIALOG, sText._pwz, L"Platform Update Required", dwReturn));
        _hr = E_ABORT;
        goto exit;
    }
    else
        _hr =  S_OK;
exit:
    return _hr;
}

// ----------------------------------------------------------------------------

// BUGBUG: this should be in-sync with what server does to register update
#define REG_KEY_FUSION_SETTINGS       L"Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Policy"

#define REG_VAL_INTRANET_DISALLOW     L"Download from Intranet Disallowed"
#define REG_VAL_TRUSTED_DISALLOW     L"Download from Trusted Zone Disallowed"
#define REG_VAL_INTERNET_DISALLOW     L"Download from Internet Disallowed"
#define REG_VAL_UNTRUSTED_DISALLOW   L"Download from Untrusted Zone Disallowed"

// ---------------------------------------------------------------------------
// CActivator::CheckZonePolicy
// return: S_OK for yes/ok, E_ABORT for no/abort
// default is allow all
// ---------------------------------------------------------------------------
HRESULT CActivator::CheckZonePolicy(LPWSTR pwzURL)
{
    DWORD dwZone = 0;
    DWORD dwType = 0;
    DWORD dwValue = -1;
    DWORD dwSize = sizeof(dwValue);

    if (_pSecurityMgr == NULL)
    {
        // lazy init.
        _hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                            IID_IInternetSecurityManager, (void**)&_pSecurityMgr);
        if (FAILED(_hr))
            _pSecurityMgr = NULL;
        IF_FAILED_EXIT(_hr);
    }

    IF_FAILED_EXIT(_pSecurityMgr->MapUrlToZone(pwzURL, &dwZone, 0));

    // BUGBUG: hack up code here... not much error checking...
    switch(dwZone)
    {
        case 1: // Intranet Zone
                // Get registry entry
                if (GetRegKeyValue(HKEY_CURRENT_USER, 
                    REG_KEY_FUSION_SETTINGS, REG_VAL_INTRANET_DISALLOW,
                    &dwType, (PBYTE) &dwValue, &dwSize)
                    == ERROR_SUCCESS)
                {
                    if (dwValue == 1)
                    {
                        _hr = E_ABORT;
                        Msg(L"Zone policy: Download from Intranet is disallowed. Aborting...");
                    }
                }
                break;
        case 2: // Trusted Zone
                // Get registry entry
                if (GetRegKeyValue(HKEY_CURRENT_USER, 
                    REG_KEY_FUSION_SETTINGS, REG_VAL_TRUSTED_DISALLOW,
                    &dwType, (PBYTE) &dwValue, &dwSize)
                    == ERROR_SUCCESS)
                {
                    if (dwValue == 1)
                    {
                        _hr = E_ABORT;
                        Msg(L"Zone policy: Download from Trusted Zone is disallowed. Aborting...");
                    }
                }
                break;
        case 3: // Internet Zone
                // Get registry entry
                if (GetRegKeyValue(HKEY_CURRENT_USER, 
                    REG_KEY_FUSION_SETTINGS, REG_VAL_INTERNET_DISALLOW,
                    &dwType, (PBYTE) &dwValue, &dwSize)
                    == ERROR_SUCCESS)
                {
                    if (dwValue == 1)
                    {
                        _hr = E_ABORT;
                        Msg(L"Zone policy: Download from Internet is disallowed. Aborting...");
                    }
                }
                break;
        default:
        case 4: // Untrusted Zone
                // Get registry entry
                if (GetRegKeyValue(HKEY_CURRENT_USER, 
                    REG_KEY_FUSION_SETTINGS, REG_VAL_UNTRUSTED_DISALLOW,
                    &dwType, (PBYTE) &dwValue, &dwSize)
                    == ERROR_SUCCESS)
                {
                    if (dwValue == 1)
                    {
                        _hr = E_ABORT;
                        Msg(L"Zone policy: Download from Untrusted Zone is disallowed. Aborting...");
                    }
                }
                break;
        case 0: //Local machine
                break;
    }
    
exit:
    return _hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\mfilter.h ===
#pragma once
#ifndef _FILTER_DLL_H
#define _FILTER_DLL_H

#include <objbase.h>
#include <windows.h>

#include <wininet.h>

#include "..\..\includes\lock.h"

#define SHOW_CLICKONCE_AD     // uncomment this to display the clickonce ad
#ifdef SHOW_CLICKONCE_AD
#define CONTENT_TYPE L"text/html"
#else
#define CONTENT_TYPE L"application/manifest"    // the context type this mime filter is handling
#endif

// Clases and interfaces

class CFusionMimeFilterClassFactory : public IClassFactory
{
public:
    CFusionMimeFilterClassFactory	();

    // IUnknown Methods
    STDMETHOD_    (ULONG, AddRef)   ();
    STDMETHOD_    (ULONG, Release)  ();
    STDMETHOD     (QueryInterface)  (REFIID, void **);

    // IClassFactory Moethods
    STDMETHOD     (LockServer)      (BOOL);
    STDMETHOD     (CreateInstance)  (IUnknown*,REFIID,void**);

protected:
    long            _cRef;
};

class CFusionMimeFilter : public IInternetProtocol, public IInternetProtocolSink
{
public:
    CFusionMimeFilter     ();
    ~CFusionMimeFilter    ();

    // IUnknown methods
    STDMETHOD_        (ULONG, AddRef)           ();
    STDMETHOD_        (ULONG, Release)          ();
    STDMETHOD         (QueryInterface)          (REFIID, void **);

    // InternetProtocol methods
    STDMETHOD         (Start)                   (LPCWSTR, IInternetProtocolSink *, IInternetBindInfo *, DWORD, HANDLE_PTR);
    STDMETHOD         (Continue)                (PROTOCOLDATA *pProtData);
    STDMETHOD         (Abort)                   (HRESULT hrReason,DWORD );
    STDMETHOD         (Terminate)               (DWORD );
    STDMETHOD         (Suspend)                 ();
    STDMETHOD         (Resume)                  ();
    STDMETHOD         (Read)                    (void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD         (Seek)                    (LARGE_INTEGER , DWORD , ULARGE_INTEGER *) ;
    STDMETHOD         (LockRequest)             (DWORD );
    STDMETHOD         (UnlockRequest)           ();

    // IInternetProtocolSink methods
    STDMETHOD         (ReportData)              (DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);
    STDMETHOD         (ReportProgress)          (ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHOD         (ReportResult)            (HRESULT hrResult, DWORD dwError, LPCWSTR szResult);
    STDMETHOD         (Switch)                  (PROTOCOLDATA *pProtocolData);

protected:
    HRESULT             OpenTempFile();
    HRESULT             CloseTempFile();

    long                _cRef;
    BOOL                _fFirstRead;
    BOOL                _fReadDone;

    IInternetProtocolSink* _pOutgoingProtSink;
    IInternetProtocol*  _pIncomingProt;

    DWORD               _grfSTI;                            // STI flags handed to us 

    LPWSTR              _pwzUrl;                             // The URL

    WCHAR               _wzTempFile[MAX_PATH];
    HANDLE              _hFile;

    ULONG              _cbAdRead;

    CRITICAL_SECTION    _cs;
    CCriticalSection    *_csLock;
};

extern const GUID CLSID_FusionMimeFilter;

#endif // _FILTER_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\activator.h ===
#pragma once
#ifndef _ACTIVATOR_H
#define _ACTIVATOR_H

#include <objbase.h>
#include <windows.h>
#include "cstrings.h"
#include "dbglog.h"

// ----------------------------------------------------------------------

class CActivator;
typedef CActivator *LPACTIVATOR;

STDAPI CreateActivator(
    LPACTIVATOR     *ppActivator,
    CDebugLog * pDbgLog,
    DWORD           dwFlags);

// ----------------------------------------------------------------------

class CActivator : public IAssemblyBindSink//: public IActivator
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IActivator methods

    STDMETHOD(Initialize)(
        /* in */ LPCWSTR pwzFilePath,
        /* in */ LPCWSTR pwzFileURL);

    STDMETHOD(Process)();

    STDMETHOD(Execute)();

    // IAssemblyBindSink methods

    STDMETHOD(OnProgress)(
        /* in */ DWORD          dwNotification,
        /* in */ HRESULT        hrNotification,
        /* in */ LPCWSTR        szNotification,
        /* in */ DWORD          dwProgress,
        /* in */ DWORD          dwProgressMax,
        /* in */ IUnknown       *pUnk);


    CActivator(CDebugLog * pDbgLog);
    ~CActivator();

private:
    HRESULT     CheckZonePolicy(LPWSTR pwzURL);
    HRESULT     ResolveAndInstall(LPWSTR *ppwzDesktopManifestPathName);
    HRESULT     HandlePlatformCheckResult();

    DWORD                       _dwSig;
    DWORD                       _cRef;
    DWORD                       _hr;

    LPASSEMBLY_MANIFEST_IMPORT _pManImport;
    LPASSEMBLY_IDENTITY         _pAsmId;
    IManifestInfo              *_pAppInfo;
    LPASSEMBLY_MANIFEST_EMIT    _pManEmit;

    HRESULT                     _hrManEmit;

    LPWSTR                      _pwzAppRootDir;
    LPWSTR                      _pwzAppManifestPath;

    LPWSTR                      _pwzCodebase;
    DWORD                       _dwManifestType;

    BOOL                        _bIs1stTimeInstall;
    BOOL                        _bIsCheckingRequiredUpdate;

    CString                     _sWebManifestURL;

    IInternetSecurityManager*   _pSecurityMgr;
    CDebugLog                   *_pDbgLog;

    LPTPLATFORM_INFO    _ptPlatform;
    DWORD                      _dwMissingPlatform;

#ifdef DEVMODE
    BOOL                         _bIsDevMode;
#endif

friend HRESULT CreateActivator(
    LPACTIVATOR     *ppActivator,
    CDebugLog * pDbgLog,
    DWORD           dwFlags);
};   

#endif // _ACTIVATOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\host\host.cpp ===
#include <fusenetincludes.h>
#include <activator.h>
#include <versionmanagement.h>
#include "dbglog.h"


// debug msg stuff
void
Msg(LPCWSTR pwz)
{
    MessageBox(NULL, pwz, L"ClickOnce", 0);
}

// ----------------------------------------------------------------------------

void
ShowError(LPCWSTR pwz)
{
    MessageBox(NULL, pwz, L"ClickOnce Error", MB_ICONERROR);
}

// ----------------------------------------------------------------------------

void
ShowError(HRESULT hr, LPCWSTR pwz=NULL)
{
    DWORD dwErrorCode = HRESULT_CODE(hr);
    LPWSTR MessageBuffer = NULL;
    DWORD dwBufferLength;

    // ISSUE-2002/03/27-felixybc  note: check for E_OUTOFMEMORY?

    // Call FormatMessage() to allow for message 
    //  text to be acquired from the system
    if(dwBufferLength = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, // module to get message from (NULL == system)
        dwErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
        (LPWSTR) &MessageBuffer,
        0,
        NULL))
    {
        // BUGBUG: Process any inserts in MessageBuffer

        LPWSTR pwzMsg = MessageBuffer;
        CString sMsg;

        if (pwz != NULL)
        {
            if (SUCCEEDED(sMsg.Assign((LPWSTR)pwz)))
                if (SUCCEEDED(sMsg.Append(L"\n\n")))
                    if (SUCCEEDED(sMsg.Append(MessageBuffer)))
                        pwzMsg = sMsg._pwz;
        }

        // Display the string
        ShowError(pwzMsg);

        // Free the buffer allocated by the system
        LocalFree(MessageBuffer);
    }
    else
    {
        // ISSUE-2002/03/27-felixybc  Error in this error handling code. Should print error code from format msg and orginal hr
        // should at least print error code?
        if (pwz != NULL)
            ShowError((LPWSTR)pwz);
        else
            ShowError(L"Error occurred. Unable to retrieve associated error message from the system.");
    }
}


/*void _stdcall 
  EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow); 

   hwnd - window handle that should be used as the owner window for
          any windows your DLL creates
   hinst - your DLL's instance handle
   lpszCmdLine - ASCIIZ command line your DLL should parse
   nCmdShow - describes how your DLL's windows should be displayed 
*/

// ---------------------------------------------------------------------------
// DisableCurrentVersionW
// The rundll32 entry point for rollback to previous version
// The function should be named as 'DisableCurrentVersion' on rundll32's command line
// ---------------------------------------------------------------------------
void CALLBACK
DisableCurrentVersionW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPVERSION_MANAGEMENT pVerMan = NULL;
    LPWSTR pwzDisplayNameMask = NULL;

    IF_FAILED_EXIT(CoInitialize(NULL));

    // parse commandline
    // accepted formats: "displayNameMask"
    if (*lpszCmdLine == L'\"')
    {
        LPWSTR pwz = NULL;
        
        pwz = wcschr(lpszCmdLine+1, L'\"');
        if (pwz != NULL)
        {
            *pwz = L'\0';

            pwzDisplayNameMask = lpszCmdLine+1;
        }
    }

    // exit if invalid arguments
    IF_NULL_EXIT(pwzDisplayNameMask, E_INVALIDARG);

    IF_FAILED_EXIT(CreateVersionManagement(&pVerMan, 0));
    IF_FAILED_EXIT(pVerMan->Rollback(pwzDisplayNameMask));

    if (hr == S_FALSE)
        Msg(L"Application files cannot be found. Operation is aborted.");

exit:
    SAFERELEASE(pVerMan);

    if (FAILED(hr))
    {
        if (hr != E_ABORT)
            ShowError(hr);
    }

    CoUninitialize();

    return;
}


// ---------------------------------------------------------------------------
// UninstallW
// The rundll32 entry point for Control Panel's Add/Remove Program
// The function should be named as 'Uninstall' on rundll32's command line
// ---------------------------------------------------------------------------
void CALLBACK
UninstallW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPVERSION_MANAGEMENT pVerMan = NULL;
    LPWSTR pwzDisplayNameMask = NULL;
    LPWSTR pwzDesktopManifestPath = NULL;
    HKEY hkey = NULL;
    LONG lReturn = 0;

    IF_FAILED_EXIT(CoInitialize(NULL));

    // parse commandline
    // accepted formats: "displayNameMask" "pathToDesktopManifest"
    if (*lpszCmdLine == L'\"')
    {
        LPWSTR pwz = NULL;
        
        pwz = wcschr(lpszCmdLine+1, L'\"');
        if (pwz != NULL)
        {
            *pwz = L'\0';

            pwzDisplayNameMask = lpszCmdLine+1;
            
            pwz = wcschr(pwz+1, L'\"');
            if (pwz != NULL)
            {
                pwzDesktopManifestPath = pwz+1;

                pwz = wcschr(pwzDesktopManifestPath, L'\"');
                if (pwz != NULL)
                    *pwz = L'\0';
                else
                    pwzDesktopManifestPath = NULL;
            }
        }
    }

    // exit if invalid arguments
    IF_FALSE_EXIT(pwzDisplayNameMask != NULL && pwzDesktopManifestPath != NULL, E_INVALIDARG);

    IF_TRUE_EXIT(MessageBox(NULL, L"Do you want to remove this application and unregister its subscription?", L"ClickOnce",
        MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL) != IDYES, E_ABORT);

    IF_FAILED_EXIT(CreateVersionManagement(&pVerMan, 0));
    IF_FAILED_EXIT(pVerMan->Uninstall(pwzDisplayNameMask, pwzDesktopManifestPath));

    if (hr == S_FALSE)
    {
        IF_TRUE_EXIT(MessageBox(NULL, L"The application can no longer be located on the system. Do you want to remove this entry?",
            L"ClickOnce", MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL) == IDNO, E_ABORT);

        // delete registry uninstall info
        extern const WCHAR* pwzUninstallSubKey; // defined in versionmanagement.cpp

        // open uninstall key
        lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwzUninstallSubKey, 0,
            DELETE, &hkey);
        IF_WIN32_FAILED_EXIT(lReturn);

        lReturn = RegDeleteKey(hkey, pwzDisplayNameMask);
        IF_WIN32_FAILED_EXIT(lReturn);
    }

exit:
    SAFERELEASE(pVerMan);

    if (hkey)
    {
        lReturn = RegCloseKey(hkey);
        if (SUCCEEDED(hr))
            hr = (HRESULT_FROM_WIN32(lReturn));
    }

    if (FAILED(hr))
    {
        if (hr != E_ABORT)
            ShowError(hr);
    }

    CoUninitialize();

    return;
}


// ---------------------------------------------------------------------------
// StartW
// The single rundll32 entry point for both shell (file type host) and mimehandler/url
// The function should be named as 'Start' on rundll32's command line
// ---------------------------------------------------------------------------
void CALLBACK
StartW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPACTIVATOR pActivator = NULL;
    LPWSTR pwzShortcutPath = NULL;
    LPWSTR pwzShortcutUrl = NULL;
    BOOL bIsFromWeb = FALSE;
    CDebugLog * pDbgLog = NULL;
   
   if (FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
   {
       // ISSUE-2002/03/27-felixybc  work around on longhorn builds, avalon bug 1493
       if(hr == RPC_E_CHANGED_MODE)
           hr = S_OK; // allow RPC_E_CHANGED_MODE error for now.
       else
           goto exit;
   }

    // parse commandline
    // accepted formats: "Path" <OR> "Path" "URL"
    if (*lpszCmdLine == L'\"')
    {
        LPWSTR pwz = NULL;
        
        pwz = wcschr(lpszCmdLine+1, L'\"');
        if (pwz != NULL)
        {
            *pwz = L'\0';

            // case 1 desktop/local, path to shortcut only
            pwzShortcutPath = lpszCmdLine+1;
            
            pwz = wcschr(pwz+1, L'\"');
            if (pwz != NULL)
            {
                pwzShortcutUrl = pwz+1;

                pwz = wcschr(pwzShortcutUrl, L'\"');
                if (pwz != NULL)
                {
                    *pwz = L'\0';
                    // case 2 url/mimehandler, path to temp shortcut and source URL
                    bIsFromWeb = TRUE;
                }
            }
        }
    }

    // exit if invalid arguments. ShortcutUrl is incomplete if bIsFromWeb is FALSE
    IF_FALSE_EXIT(!(pwzShortcutPath == NULL || (pwzShortcutUrl != NULL && !bIsFromWeb)), E_INVALIDARG);

    IF_FAILED_EXIT(CreateLogObject(&pDbgLog, NULL));

    IF_FAILED_EXIT(CreateActivator(&pActivator, pDbgLog, 0));

    IF_FAILED_EXIT(pActivator->Initialize(pwzShortcutPath, pwzShortcutUrl));

    IF_FAILED_EXIT(pActivator->Process());

    IF_FAILED_EXIT(pActivator->Execute());

exit:

    if(pDbgLog)
    {
        DUMPDEBUGLOG(pDbgLog, -1, hr);
    }

    SAFERELEASE(pActivator);

    if (FAILED(hr))
    {
        if (hr != E_ABORT)
            ShowError(hr);
    }

    if (bIsFromWeb)
    {
        // delete the temp file from the mimehandler
        // ignore return value
        DeleteFile(pwzShortcutPath);
    }

    CoUninitialize();

    SAFERELEASE(pDbgLog);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\host\ndphostthunk.cpp ===
#if 0
//---------------------------------------------------------------------------------------
// ZoneToString
//---------------------------------------------------------------------------------------
HRESULT ZoneToString(DWORD dwZone, CString & sZone)
{
    HRESULT hr = S_OK;

    switch(dwZone)
    {
        case 0:
            hr = sZone.Assign(L"MyComputer");
            break;
        case 1:
            hr = sZone.Assign(L"Intranet");
            break;
        case 2:
            hr = sZone.Assign(L"Trusted");
            break;
        case 3:
            hr = sZone.Assign(L"Internet");
            break;
        case 4:
        default:
            hr = sZone.Assign(L"Untrusted");
            break;
    }
    return hr;
}
#endif
// handle for fnsshell.dll, saved in shelldll.cpp
extern HINSTANCE g_DllInstance;

//---------------------------------------------------------------------------------------
// MakeCommandLine
//---------------------------------------------------------------------------------------
HRESULT MakeCommandLine(LPWSTR pwzManifestPath, 
                        LPWSTR pwzCodebase, CString &sHostPath, CString  &sCommandLine)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    LPWSTR pwzClickOncePath = NULL;
    CString sCodebase;

    IF_ALLOC_FAILED_EXIT(pwzClickOncePath = new WCHAR[MAX_PATH]);

    IF_WIN32_FALSE_EXIT(GetModuleFileName(g_DllInstance, pwzClickOncePath, MAX_PATH));

#if 0
    IF_FAILED_EXIT(ZoneToString(dwZone, sZone));
#endif

    if (pwzCodebase != NULL)
    {
        IF_FAILED_EXIT(sCodebase.Assign(pwzCodebase));
        IF_FAILED_EXIT(sCodebase.RemoveLastElement());
        IF_FAILED_EXIT(sCodebase.Append(L"/"));
    }
    else
    {
        //run from source
        IF_FAILED_EXIT(sCodebase.Assign(L"file://"));
        IF_FAILED_EXIT(sCodebase.Append(pwzManifestPath));
        IF_FAILED_EXIT(sCodebase.RemoveLastElement());
        IF_FAILED_EXIT(sCodebase.Append(L"/"));
    }
    
    IF_FAILED_EXIT(sHostPath.TakeOwnership(pwzClickOncePath, 0));
    pwzClickOncePath = NULL;
    IF_FAILED_EXIT(sHostPath.RemoveLastElement());
    IF_FAILED_EXIT(sHostPath.Append(L"\\ndphost.exe"));

    // NDP doesn't like a commandline without the path to exe
    IF_FAILED_EXIT(sCommandLine.Assign(L"\""));
    IF_FAILED_EXIT(sCommandLine.Append(sHostPath));
    IF_FAILED_EXIT(sCommandLine.Append(L"\" "));

#if 0        
    // NTRAID#NTBUG9-588432-2002/03/27-felixybc  validate codebase, asmname, asm class, method, args
    // - asm names can have spaces,quotes?
    IF_FAILED_EXIT(sCommandLine.Append(L"-appbase: \""));
    IF_FAILED_EXIT(sCommandLine.Append(pwzAppRootDir));

    IF_FAILED_EXIT(sCommandLine.Append(L"\" -zone: "));
    IF_FAILED_EXIT(sCommandLine.Append(sZone));
    IF_FAILED_EXIT(sCommandLine.Append(L" -url: \""));
    IF_FAILED_EXIT(sCommandLine.Append(sCodebase));

    IF_FAILED_EXIT(sCommandLine.Append(L"\" -asmname: \""));
    IF_FAILED_EXIT(sCommandLine.Append(pwzAsmName));
    IF_FAILED_EXIT(sCommandLine.Append(L"\" "));

    if(pwzAsmClass)
    {
        IF_FAILED_EXIT(sCommandLine.Append(L" -class: "));
        IF_FAILED_EXIT(sCommandLine.Append(pwzAsmClass));

        if(pwzAsmMethod)
        {
            IF_FAILED_EXIT(sCommandLine.Append(L" -method: "));
            IF_FAILED_EXIT(sCommandLine.Append(pwzAsmMethod));

            if(pwzAsmArgs)
            {
                IF_FAILED_EXIT(sCommandLine.Append(L" -args: \""));
                IF_FAILED_EXIT(sCommandLine.Append(pwzAsmArgs));
                IF_FAILED_EXIT(sCommandLine.Append(L"\" "));
            }
        }
    }
#endif

    IF_FAILED_EXIT(sCommandLine.Append(L"\"file://"));
    IF_FAILED_EXIT(sCommandLine.Append(pwzManifestPath));
    IF_FAILED_EXIT(sCommandLine.Append(L"\" \""));
    IF_FAILED_EXIT(sCommandLine.Append(sCodebase));
    IF_FAILED_EXIT(sCommandLine.Append(L"\""));

    LPWSTR ptr = sCommandLine._pwz;

    // bugbug - need to ensure no \" at end of command line or else thinks its a literal quote.
    // and fix this for only filepath
    while (*ptr)
    {
        if (*ptr == L'\\')
            *ptr = L'/';
        ptr++;
    }

exit:
    SAFEDELETEARRAY(pwzClickOncePath);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\service\server\update.cpp ===
//
// update.cpp -   assembly update
//
#include <windows.h>
#include <objbase.h>
#include <fusenetincludes.h>

//#include "Iface.h"
#include "server.h"
#include "CUnknown.h" // Base class for IUnknown
#include "update.h"
#include "cfactory.h"
#include "list.h"
#include "version.h"

// used in OnProgress(), copied from guids.c
DEFINE_GUID( IID_IAssemblyManifestImport,
0x696fb37f,0xda64,0x4175,0x94,0xe7,0xfd,0xc8,0x23,0x45,0x39,0xc4);

#define WZ_URL                                                 L"Url"
#define WZ_SYNC_INTERVAL                             L"SyncInterval"
#define WZ_SYNC_EVENT                                   L"SyncEvent"
#define WZ_EVENT_DEMAND_CONNECTION       L"EventDemandConnection"
#define SUBSCRIPTION_REG_KEY                       L"1.0.0.0\\Subscription\\"
#define UPDATE_REG_KEY                                  L"CurrentService"

extern HWND                     g_hwndUpdateServer;
extern CRITICAL_SECTION g_csServer;

List <CDownloadInstance*> g_ActiveDownloadList;
HANDLE g_hAbortTimeout = INVALID_HANDLE_VALUE;
BOOL g_fSignalUpdate = FALSE;


// ---------------------------------------------------------------------------
// Main timer callback for servicing subscriptions.
// ---------------------------------------------------------------------------
VOID CALLBACK SubscriptionTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    DWORD dwHash = 0, nMilliseconds = 0, i= 0;
    BOOL bIsDuplicate = FALSE;
    
    CString sUrl;
    CRegImport *pRegImport = NULL;    
    CRegImport *pSubRegImport = NULL;

    IAssemblyDownload *pAssemblyDownload = NULL;
    CAssemblyBindSink *pCBindSink                 = NULL;
    CDownloadInstance *pCDownloadInstance = NULL;

    // If update detected stop processing
    // subscriptions and kick off new server.
    hr = CAssemblyUpdate::CheckForUpdate();
    IF_FAILED_EXIT(hr);
    if (hr == S_OK)
        goto exit;
        
    IF_FAILED_EXIT(CRegImport::Create(&pRegImport, SUBSCRIPTION_REG_KEY));
    if (hr == S_FALSE)
        goto exit;
        
    // Enum over subscription keys.
    while ((hr = pRegImport->EnumKeys(i++, &pSubRegImport)) == S_OK)
    {
        // Get url and polling inteval.
        IF_FAILED_EXIT(pSubRegImport->ReadString(WZ_URL, sUrl));
        IF_FAILED_EXIT(pSubRegImport->ReadDword(WZ_SYNC_INTERVAL, &nMilliseconds));
        
        // Get url hash
        IF_FAILED_EXIT(sUrl.Get65599Hash(&dwHash, CString::CaseInsensitive));        

        // Check the hash.
        if ((dwHash == idEvent))
        {
            // hash checks, now check for dupe and skip if found.
            IF_FAILED_EXIT(CAssemblyUpdate::IsDuplicate(sUrl._pwz, &bIsDuplicate));
            if (bIsDuplicate)
            {
                SAFEDELETE(pSubRegImport);
                continue;
            }
            
            // Create the download object.
            IF_FAILED_EXIT(CreateAssemblyDownload(&pAssemblyDownload, NULL, 0));

            // Create bind sink object with download pointer
            IF_ALLOC_FAILED_EXIT(pCBindSink = new CAssemblyBindSink(pAssemblyDownload));

            // Create the download instance object.
            IF_ALLOC_FAILED_EXIT(pCDownloadInstance = new CDownloadInstance);

            // Download instance references pAssemblyDownload.
            pCDownloadInstance->_pAssemblyDownload = pAssemblyDownload;
            IF_FAILED_EXIT(pCDownloadInstance->_sUrl.Assign(sUrl));

            // Push download object onto list and fire off download; bind sink will remove and release on completion.
            EnterCriticalSection(&g_csServer);
            g_ActiveDownloadList.AddHead(pCDownloadInstance);
            LeaveCriticalSection(&g_csServer);

            // Invoke the download.
            hr = pAssemblyDownload->DownloadManifestAndDependencies(sUrl._pwz, 
                (IAssemblyBindSink*) pCBindSink, DOWNLOAD_FLAGS_NOTIFY_BINDSINK);

            if(hr == STG_E_TERMINATED)
            {
                hr = S_FALSE; // there was an error in download. Log it but don't break into debugger/assert.
            }

            IF_FAILED_EXIT(hr);
        }

        SAFEDELETE(pSubRegImport);
    }

exit:

    // The active download list looks like:
    //                                                                         (circ. refcount)
    // pCDownloadInstance ---> pAssemblyDownload <=========> pCBindSink
    //         |
    //         v
    //       ...
    //
    // pAssemblyDownload, pCBindSink each have refcount of 1 and will be released
    // on successful completion.
    // DON'T RELEASE THEM HERE UNLESS A FAILURE OCCURED.
    if (FAILED(hr))
    {
        SAFERELEASE(pAssemblyDownload);
        SAFERELEASE(pCBindSink);
        SAFEDELETE(pCDownloadInstance);
    }

    SAFEDELETE(pRegImport);
    SAFEDELETE(pSubRegImport);

    return;
}



///////////////////////////////////////////////////////////
//
// Interface IAssemblyBindSink
//

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyBindSink::CAssemblyBindSink(IAssemblyDownload *pAssemblyDownload)
{
    _cRef = 1;
    _pAssemblyDownload = pAssemblyDownload;
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyBindSink::~CAssemblyBindSink()
{}


// ---------------------------------------------------------------------------
// OnProgress
// ---------------------------------------------------------------------------
HRESULT CAssemblyBindSink::OnProgress(
        DWORD          dwNotification,
        HRESULT        hrNotification,
        LPCWSTR        szNotification,
        DWORD          dwProgress,
        DWORD          dwProgressMax,
        IUnknown       *pUnk)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    LPASSEMBLY_MANIFEST_IMPORT pManifestImport = NULL;
    LPASSEMBLY_IDENTITY              pAppId = NULL;

    CAssemblyUpdate *pAssemblyUpdate  = NULL;
    LPMANIFEST_INFO pAppAssemblyInfo  = NULL;
    LPMANIFEST_INFO pSubsInfo                 = NULL;

    if (dwNotification == ASM_NOTIFICATION_SUBSCRIPTION_MANIFEST)
    {
        LPWSTR pwz = NULL;
        DWORD cb = 0, cc = 0, dwFlag = 0;
        CString sAppName;
        
        // szNotification == URL to manifest
        IF_NULL_EXIT(szNotification, E_INVALIDARG);
        
        // pUnk == manifest import of manifest
        IF_FAILED_EXIT(pUnk->QueryInterface(IID_IAssemblyManifestImport, (LPVOID*) &pManifestImport));

        // Get the dependent (application) assembly info (0th index)
        IF_FAILED_EXIT(pManifestImport->GetNextAssembly(0, &pAppAssemblyInfo));
        IF_NULL_EXIT(pAppAssemblyInfo, E_INVALIDARG);

        // Get dependent (application) assembly identity
        IF_FAILED_EXIT(pAppAssemblyInfo->Get(MAN_INFO_DEPENDENT_ASM_ID, (LPVOID *)&pAppId, &cb, &dwFlag));
        IF_NULL_EXIT(pAppId, E_INVALIDARG);
        
        // Get application text name.
        IF_FAILED_EXIT(hr = pAppId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwz, &cc));
        IF_FAILED_EXIT(sAppName.TakeOwnership(pwz, cc));

        pAssemblyUpdate = new CAssemblyUpdate();
        IF_ALLOC_FAILED_EXIT(pAssemblyUpdate);
        
        // Get subscription info from manifest
        IF_FAILED_EXIT(pManifestImport->GetSubscriptionInfo(&pSubsInfo));

        // Register the subscription.
        IF_FAILED_EXIT(pAssemblyUpdate->RegisterAssemblySubscriptionFromInfo(sAppName._pwz, 
                (LPWSTR) szNotification, pSubsInfo));
    }
    else if ((dwNotification == ASM_NOTIFICATION_DONE)
        || (dwNotification == ASM_NOTIFICATION_ABORT)
        || (dwNotification == ASM_NOTIFICATION_ERROR))

    {
        // Synchronize with SubscriptionTimerProc.
        EnterCriticalSection(&g_csServer);
    
        LISTNODE pos = NULL;
        LISTNODE posRemove = NULL;
        CDownloadInstance *pDownloadInstance = NULL;
        
        // Walk the global download instance list.
        pos = g_ActiveDownloadList.GetHeadPosition();
            
        while ((posRemove = pos) && (pDownloadInstance = g_ActiveDownloadList.GetNext(pos)))
        {
            // Check for match against callback's interface pointer value.
            if (pDownloadInstance->_pAssemblyDownload == _pAssemblyDownload)
            {
                // If match found, remove from list and release.
                g_ActiveDownloadList.RemoveAt(posRemove);

                // If an update has been signalled the client thread will wait until
                // the active download list has been drained via abort handling on
                // each download object. Signal this when the list is empty.
                if (g_fSignalUpdate && (g_ActiveDownloadList.GetCount() == 0))
                    SetEvent(g_hAbortTimeout);
                    
                _pAssemblyDownload->Release();
                SAFEDELETE(pDownloadInstance);

                break;
            }
        }

        LeaveCriticalSection(&g_csServer);

        // Because of the circular refcount between CAssemblyDownload and CAssemblyBindSink
        // we don't addreff this instance and it is responsible for deleting itself.
        
        delete this;
    }
        


exit:
    
    SAFERELEASE(pManifestImport);
    SAFERELEASE(pAppId);
    SAFEDELETE(pAssemblyUpdate);
    SAFERELEASE(pAppAssemblyInfo);
    SAFERELEASE(pSubsInfo);
    
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyBindSink::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyBindSink::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyBindSink)
       )
    {
        *ppvObj = static_cast<IAssemblyBindSink*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyBindSink::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyBindSink::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyBindSink::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyBindSink::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}


///////////////////////////////////////////////////////////
//
// Interface IAssemblyUpdate
//

HRESULT __stdcall CAssemblyUpdate::RegisterAssemblySubscription(LPWSTR pwzDisplayName,
        LPWSTR pwzUrl, DWORD dwInterval)
{
    // ISSUE-2002/04/19-felixybc  dummy method to keep interface unchanged.
    //    This method should not be called.
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// RegisterAssemblySubscriptionEx
// ---------------------------------------------------------------------------
HRESULT __stdcall CAssemblyUpdate::RegisterAssemblySubscriptionEx(LPWSTR pwzDisplayName, 
    LPWSTR pwzUrl, DWORD dwInterval, DWORD dwIntervalUnit,
    DWORD dwEvent, BOOL bEventDemandConnection)
{
    DWORD dwMilliseconds = 0, dwDemandConnection = 0, 
        dwHash = 0, dwFactor = 1;

    CString sUrl;
    CString sSubscription;

    CRegEmit *pRegEmit = NULL;
    
    dwDemandConnection = bEventDemandConnection;    // BOOL -> DWORD
    
    switch(dwIntervalUnit)
    {
        case SUBSCRIPTION_INTERVAL_UNIT_DAYS:
                            dwFactor *= 24; // falls thru, 1 hr*24 = 1 day
        case SUBSCRIPTION_INTERVAL_UNIT_HOURS:
        default:
                            dwFactor *= 60; // falls thru, 1 min*60 = 1 hr
        case SUBSCRIPTION_INTERVAL_UNIT_MINUTES:
                            dwFactor *= 60000; // 1ms*60000 = 1 min
                            break;
    }

    // BUGBUG: check overflow
    dwMilliseconds = dwInterval * dwFactor;

#ifdef DBG
#define REG_KEY_FUSION_SETTINGS              TEXT("Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Subscription")
    // BUGBUG: code to facilitate testing ONLY - shorten minutes to seconds
    {
        // read subkey, default is false
        if (SHRegGetBoolUSValue(REG_KEY_FUSION_SETTINGS, L"ShortenMinToSec", FALSE, FALSE))
        {
            dwMilliseconds /= 60;    // at this point, dwMilliseconds >= 60000
        }
    }
#endif


    // Get hash of url
    // BUGBUG - this could just be a global counter, right?
    IF_FAILED_EXIT(sUrl.Assign(pwzUrl));
    IF_FAILED_EXIT(sUrl.Get65599Hash(&dwHash, CString::CaseInsensitive));

    // Form subscription regstring.
    IF_FAILED_EXIT(sSubscription.Assign(SUBSCRIPTION_REG_KEY));
    IF_FAILED_EXIT(sSubscription.Append(pwzDisplayName));

    // Set the subscription regkeys.
    IF_FAILED_EXIT(CRegEmit::Create(&pRegEmit, sSubscription._pwz));
    IF_FAILED_EXIT(pRegEmit->WriteDword(WZ_SYNC_INTERVAL, dwMilliseconds));
    IF_FAILED_EXIT(pRegEmit->WriteDword(WZ_SYNC_EVENT, dwEvent));
    IF_FAILED_EXIT(pRegEmit->WriteDword(WZ_EVENT_DEMAND_CONNECTION, dwDemandConnection));
    IF_FAILED_EXIT(pRegEmit->WriteString(WZ_URL, sUrl));

    // Fire off the timer.
    IF_WIN32_FALSE_EXIT(SetTimer((HWND) g_hwndUpdateServer, dwHash, dwMilliseconds, SubscriptionTimerProc));

    IF_FAILED_EXIT(CheckForUpdate());

    _hr = S_OK;

exit:

    SAFEDELETE(pRegEmit);
    return _hr;
}

// ---------------------------------------------------------------------------
// UnRegisterAssemblySubscription
// ---------------------------------------------------------------------------
HRESULT __stdcall CAssemblyUpdate::UnRegisterAssemblySubscription(LPWSTR pwzDisplayName)
{ 
    CRegEmit *pRegEmit = NULL;
    
    // Form full regkey path.
    IF_FAILED_EXIT(CRegEmit::Create(&pRegEmit, SUBSCRIPTION_REG_KEY));
    IF_FAILED_EXIT(pRegEmit->DeleteKey(pwzDisplayName));  

    IF_FAILED_EXIT(CheckForUpdate());

    _hr = S_OK;

exit:

    SAFEDELETE(pRegEmit);
    return _hr;
}


// ---------------------------------------------------------------------------
// Initialize servicing subscriptions.
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::InitializeSubscriptions()
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    DWORD dwHash = 0, nMilliseconds = 0, i=0;
    
    CString sUrl;
    CRegImport *pRegImport = NULL;    
    CRegImport *pSubRegImport = NULL;

    IF_FAILED_EXIT(CRegImport::Create(&pRegImport, SUBSCRIPTION_REG_KEY));
     if (hr == S_FALSE)
        goto exit;

    // Enum over subscription keys.
    while ((hr = pRegImport->EnumKeys(i++, &pSubRegImport)) == S_OK)
    {
        // Get url and polling inteval.
        IF_FAILED_EXIT(pSubRegImport->ReadString(WZ_URL, sUrl));
        IF_FAILED_EXIT(pSubRegImport->ReadDword(WZ_SYNC_INTERVAL, &nMilliseconds));
        
        // Get url hash
        IF_FAILED_EXIT(sUrl.Get65599Hash(&dwHash, CString::CaseInsensitive));

        // Set the subscription timer event.
        IF_WIN32_FALSE_EXIT(SetTimer((HWND) g_hwndUpdateServer, dwHash, nMilliseconds, SubscriptionTimerProc));

        SAFEDELETE(pSubRegImport);
    }
    
    g_hAbortTimeout = CreateEvent(NULL, TRUE, FALSE, NULL);
    IF_WIN32_FALSE_EXIT(g_hAbortTimeout != NULL);


exit:

    SAFEDELETE(pRegImport);
    SAFEDELETE(pSubRegImport);

    return hr;
    
}



// ---------------------------------------------------------------------------
// CheckForUpdate
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::CheckForUpdate()
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
        
    ULONGLONG ullUpdateVersion = 0, 
        ullCurrentVersion = 0;

    CString sUpdatePath;
    BOOL bUpdate = FALSE, bDoRelease = TRUE;
    DWORD dwWaitState = 0;
    
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};

    EnterCriticalSection(&g_csServer);
    
    if (g_fSignalUpdate == TRUE)
        goto exit;
        
    // Check the registry update location. The service will terminate
    // if no key is found (uninstall) or if update with higher version is found.

    // ISSUE-2002/03/19-adriaanc
    // A race condition exists when Darwin upgrades v1->v2 of ClickOnce - 
    // Major upgrade first uninstalls v1, then installs v2 so the registry key
    // may not be present when checking and we will incorrectly shutdown.
    // Mitigating factor is that this requires a major upgrade - so reboot implicit?
    // One possible solution is to zomby the process for a time and reverify 
    // the uninstall by rechecking the regkey.
    IF_FAILED_EXIT(ReadUpdateRegistryEntry(&ullUpdateVersion, sUpdatePath));
    if (hr == S_OK)        
    {
        GetCurrentVersion(&ullCurrentVersion);    
        if (ullUpdateVersion <= ullCurrentVersion)
        {
            hr = S_FALSE;
            goto exit;
        }
        bUpdate = TRUE;
    }
    else
        hr = S_OK;

    // Revoke the class factories.
    CFactory::StopFactories();

    // Nuke outstanding jobs.
    if (g_ActiveDownloadList.GetCount())
    {
        LISTNODE pos = NULL;
        CDownloadInstance *pDownloadInstance = NULL;
        
        // Walk the global download instance list and cancel
        // any outstanding jobs.
        pos = g_ActiveDownloadList.GetHeadPosition();

        // Walk the list and cancel the downloads. 
        // DO NOT remove them from the list or release
        // them - this will be taken care of by the bindsink.
        while (pos && (pDownloadInstance = g_ActiveDownloadList.GetNext(pos)))
            IF_FAILED_EXIT(pDownloadInstance->_pAssemblyDownload->CancelDownload());

    }

    // CreateProcess on updated server.
    if (bUpdate)
    {
        si.cb = sizeof(si);
        IF_WIN32_FALSE_EXIT(CreateProcess(sUpdatePath._pwz, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi));
    }


    // Flag that an update has been signalled. We are now entering process termination phase.
    g_fSignalUpdate = TRUE;
    

    // The process must stay resident until any outstanding async callback threads have had a chance to 
    // complete their aborts. An efficient check is to first check if the active download queue has any 
    // entries. We can do this here because we are under the global crit sect and BITS callbacks can
    // only be extant when one or more downloads are in the queue and no additional downloads will 
    // be submitted because g_fSignalUpdate before we leave the critsect.
    if (g_ActiveDownloadList.GetCount())
    {        
        // Downloads are currently in progress. Wait for the aborts to complete.
        // We synchronize on the abort event with a 1 minute timeout in the 
        // case that one or more aborts failed to complete. This is technically 
        // an error condition but we still MUST exit the process. 

        // It is necessary to release the global critsect so that the 
        // downloaders may update the active download list.
        bDoRelease = FALSE;
        ::LeaveCriticalSection(&g_csServer);

        // Sync on the abort timeout.
        dwWaitState = WaitForSingleObject(g_hAbortTimeout, 60000);    
        IF_WIN32_FALSE_EXIT((dwWaitState != WAIT_FAILED));       

        // In retail builds we would ignore the timeout. In debug catch the assert.
        if (dwWaitState != WAIT_OBJECT_0)
        {
            ASSERT(FALSE);
        }
    }
    
    // decrement artificial ref count; ensures server
    // exits on last interface released.
   ::InterlockedDecrement(&CFactory::s_cServerLocks) ;

    // And attempt to terminate the process.
    CFactory::CloseExe();
    
    exit:
    
    if (bDoRelease)
        ::LeaveCriticalSection(&g_csServer);



    return hr;
}

// ---------------------------------------------------------------------------
// RegisterAssemblySubscriptionFromInfo
// NOTE - this is NOT a public method on IAssemblyUpdate
// NOTE - what types of validation should be done here if any?
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::RegisterAssemblySubscriptionFromInfo(LPWSTR pwzDisplayName, 
    LPWSTR pwzUrl, IManifestInfo *pSubscriptionInfo)
{
    DWORD *pdw = NULL;
    BOOL *pb = NULL;
    DWORD dwInterval = 0, dwUnit = SUBSCRIPTION_INTERVAL_UNIT_MAX;
    DWORD dwEvent = 0;
    BOOL bDemandConnection = FALSE;
    DWORD dwCB = 0, dwFlag = 0;

    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_INTERVAL, (LPVOID *)&pdw, &dwCB, &dwFlag));    
    if (pdw != NULL)
    {
        dwInterval = *pdw;
        SAFEDELETEARRAY(pdw);
    }

    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_INTERVAL_UNIT, (LPVOID *)&pdw, &dwCB, &dwFlag));
    if (pdw != NULL)
    {
        dwUnit = *pdw;
        SAFEDELETEARRAY(pdw);
    }

    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_SYNCHRONIZE_EVENT, (LPVOID *)&pdw, &dwCB, &dwFlag));
    if (pdw != NULL)
    {
        dwEvent = *pdw;
        SAFEDELETEARRAY(pdw);
    }

    IF_FAILED_EXIT(pSubscriptionInfo->Get(MAN_INFO_SUBSCRIPTION_EVENT_DEMAND_CONNECTION, (LPVOID *)&pb, &dwCB, &dwFlag));
    if (pb != NULL)
    {
        bDemandConnection = *pb;
        SAFEDELETEARRAY(pb);
    }

    IF_FAILED_EXIT(RegisterAssemblySubscriptionEx(pwzDisplayName, 
            pwzUrl, dwInterval, dwUnit, dwEvent, bDemandConnection));
            
exit:

    return _hr;
}




// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyUpdate::CAssemblyUpdate()
: CUnknown(), _hr(S_OK)
{
    // Empty
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyUpdate::~CAssemblyUpdate()
{
}

// ---------------------------------------------------------------------------
// QueryInterface
// ---------------------------------------------------------------------------
HRESULT __stdcall CAssemblyUpdate::QueryInterface(const IID& iid,
                                                  void** ppv)
{ 
    if (   IsEqualIID(iid, IID_IUnknown)
        || IsEqualIID(iid, IID_IAssemblyUpdate)
       )
    {
        return CUnknown::FinishQI((IAssemblyUpdate*)this, ppv) ;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyDownload::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyUpdate::AddRef()
{
    return CUnknown::AddRef();
}

// ---------------------------------------------------------------------------
// CAssemblyDownload::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyUpdate::Release()
{
    return CUnknown::Release();
}


// ---------------------------------------------------------------------------
// Creation function used by CFactory
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::CreateInstance(IUnknown* pUnknownOuter,
                           CUnknown** ppNewComponent)
{
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    *ppNewComponent = new CAssemblyUpdate() ;
    return S_OK ;
}

// ---------------------------------------------------------------------------
// Init function used by CFactory
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::Init()
{
    return S_OK;
}

// ---------------------------------------------------------------------------
// GetCurrentVersion
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::GetCurrentVersion(ULONGLONG *pullCurrentVersion)
{
    ULONGLONG ullVer = 0;

    WORD wVer[4] = { FUS_VER_MAJORVERSION , FUS_VER_MINORVERSION, 
        FUS_VER_PRODUCTBUILD, FUS_VER_PRODUCTBUILD_QFE };
    
    for (int i = 0; i < 4; i++)
        ullVer |=  ((ULONGLONG) wVer[i]) << (sizeof(WORD) * 8 * (3-i));

    *pullCurrentVersion = ullVer;

    return S_OK;
}

// ---------------------------------------------------------------------------
// RemoveUpdateRegEntry
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::RemoveUpdateRegistryEntry()
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CRegEmit *pEmit = NULL;
    IF_FAILED_EXIT(CRegEmit::Create(&pEmit, NULL));
    IF_FAILED_EXIT(pEmit->DeleteKey(UPDATE_REG_KEY));

  exit:

  return hr;
}

// ---------------------------------------------------------------------------
// ReadUpdateRegistryEntry
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::ReadUpdateRegistryEntry(ULONGLONG *pullUpdateVersion, CString &sUpdatePath)
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    LPWSTR pwz              = NULL;
    WORD wVer[4]          = {0,0,0,0};
    ULONGLONG ullVer    = 0;
    INT i= 0, iVersion      = 0;
    BOOL fDot                  = TRUE;
    
    CString sVersion;
    CRegImport *pRegImport = NULL;

    hr = CRegImport::Create(&pRegImport, UPDATE_REG_KEY);
    if (hr == S_FALSE)
        goto exit;

    IF_FAILED_EXIT(hr);
    IF_FAILED_EXIT(pRegImport->ReadString(L"Version", sVersion));
    IF_FAILED_EXIT(pRegImport->ReadString(L"Path", sUpdatePath));
    
    // Parse the version to ulonglong
    pwz = sVersion._pwz;
    while (*pwz)
    {        
        if (fDot)
        {
            iVersion=StrToInt(pwz);
            wVer[i++] = (WORD) iVersion;
            fDot = FALSE;
        }

        if (*pwz == L'.')
            fDot = TRUE;

        pwz++;
        if (i > 3)
            break;
    }

    for (i = 0; i < 4; i++)
        ullVer |=  ((ULONGLONG) wVer[i]) << (sizeof(WORD) * 8 * (3-i));

    *pullUpdateVersion = ullVer;

exit:

    SAFEDELETE(pRegImport);
    return hr;
    
}




// ---------------------------------------------------------------------------
// Helper function for determining dupes in active subscription list.
// ---------------------------------------------------------------------------
HRESULT CAssemblyUpdate::IsDuplicate(LPWSTR pwzURL, BOOL *pbIsDuplicate)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    BOOL bDuplicate = FALSE;
    INT iCompare = 0;
    LISTNODE pos = NULL;
    CDownloadInstance *pDownloadInstance = NULL;

    EnterCriticalSection(&g_csServer);

    // Walk the global download instance list.
    pos = g_ActiveDownloadList.GetHeadPosition();

    while ( (pos) && (pDownloadInstance = g_ActiveDownloadList.GetNext(pos)))
    {
        iCompare = CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, 
            pDownloadInstance->_sUrl._pwz, -1, pwzURL, -1);
        IF_WIN32_FALSE_EXIT(iCompare);
        
        if (iCompare == CSTR_EQUAL)
        {
            bDuplicate = TRUE;
            break;
        }
    }


    *pbIsDuplicate = bDuplicate;

exit:

    LeaveCriticalSection(&g_csServer);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\arp\versionmanagement.cpp ===
#include <fusenetincludes.h>
#include <sxsapi.h>
#include <versionmanagement.h>


// note: this class should potentially reside in fusenet.dll or server.exe...

// text for uninstall subkey
const WCHAR* pwzUninstallSubKey = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall";

// Update services
#include "server.h"
DEFINE_GUID(IID_IAssemblyUpdate,
    0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(CLSID_CAssemblyUpdate,
    0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);

// copied from fusion.h
//#include <fusion.h>
DEFINE_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);

// ---------------------------------------------------------------------------
// CreateVersionManagement
// ---------------------------------------------------------------------------
STDAPI
CreateVersionManagement(
    LPVERSION_MANAGEMENT       *ppVersionManagement,
    DWORD                       dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CVersionManagement *pVerMan = NULL;

    IF_ALLOC_FAILED_EXIT(pVerMan = new(CVersionManagement));
    
exit:

    *ppVersionManagement = pVerMan;//static_cast<IVersionManagement*> (pVerMan);

    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CVersionManagement::CVersionManagement()
    : _dwSig('namv'), _cRef(1), _hr(S_OK), _pFusionAsmCache(NULL)
{}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CVersionManagement::~CVersionManagement()
{
    SAFERELEASE(_pFusionAsmCache);
}


// BUGBUG: look for the Open verb and its command string in the registry and execute that instead
// rundll32.exe should be in c:\windows\system32
// BUGBUG: security hole with CreateProcess- consider using full path with ""
#define WZ_RUNDLL32_STRING        L"rundll32.exe \""  // note ending space
#define WZ_FNSSHELL_STRING        L"adfshell.dll"
#define WZ_UNINSTALL_STRING       L"\",Uninstall \""//%s\" \"%s\""
#define WZ_ROLLBACK_STRING        L"\",DisableCurrentVersion \""//%s\""

// ---------------------------------------------------------------------------
// CVersionManagement::RegisterInstall
//
//  pwzDesktopManifestFilePath can be NULL
// ---------------------------------------------------------------------------
HRESULT CVersionManagement::RegisterInstall(LPASSEMBLY_MANIFEST_IMPORT pManImport, LPCWSTR pwzDesktopManifestFilePath)
{
    // take a man import, create registry uninstall info only if necessary
    // note: may need registry HKLM write access

    HKEY hkey = NULL;
    HKEY hkeyApp = NULL;
    LONG lReturn = 0;
    DWORD  dwDisposition = 0;
    
    DWORD  dwManifestType = MANIFEST_TYPE_UNKNOWN;
    LPASSEMBLY_IDENTITY pAsmId = NULL;
    LPASSEMBLY_IDENTITY pAsmIdMask = NULL;
    LPMANIFEST_INFO pAppInfo = NULL;
    LPWSTR pwz = NULL;
    LPWSTR pwzString = NULL;
    DWORD ccString = 0;
    DWORD dwCount = 0;
    DWORD dwFlag = 0;

    LPWSTR pwzFnsshellFilePath = NULL;
    CString sDisplayName;
    CString sDisplayVersion;
    CString sUninstallString;
    CString sModifyPath;

    IF_NULL_EXIT(pManImport, E_INVALIDARG);

    // get the manifest type
    pManImport->ReportManifestType(&dwManifestType);
    // has to be an application manifest in order to get the exact version number of the app which has just installed
    IF_FALSE_EXIT(dwManifestType == MANIFEST_TYPE_APPLICATION, E_INVALIDARG);

    IF_FAILED_EXIT(pManImport->GetAssemblyIdentity(&pAsmId));
    IF_FAILED_EXIT(CloneAssemblyIdentity(pAsmId, &pAsmIdMask));

    IF_FAILED_EXIT(pAsmIdMask->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzString, &ccString));

    // assume Version == major.minor.build.rev

    // NTRAID#NTBUG9-588036-2002/03/27-felixybc  version string validation needed, should not allow "major"

    pwz = wcschr(pwzString, L'.');
    if (pwz == NULL || *(pwz+1) == L'\0')
    {
        // if "major" || "major." -> append "*"

        // check overflow
        IF_FALSE_EXIT(ccString+1 > ccString, HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));

        pwz = new WCHAR[ccString+1];
        IF_ALLOC_FAILED_EXIT(pwz);

        memcpy(pwz, pwzString, ccString * sizeof(WCHAR));
        *(pwz+ccString-1) = L'*';
        *(pwz+ccString) = L'\0';
        delete [] pwzString;
        pwzString = pwz;
    }
    else
    {
        *(pwz+1) = L'*';
        *(pwz+2) = L'\0';
    }

    IF_FAILED_EXIT(sDisplayVersion.TakeOwnership(pwzString));
    pwzString = NULL;

    // set Version major.minor.build.rev to be major.wildcard
    IF_FAILED_EXIT(pAsmIdMask->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
        sDisplayVersion._pwz, sDisplayVersion._cc));

    // get displayname as is
    IF_FAILED_EXIT(pAsmIdMask->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzString, &ccString));

    IF_FAILED_EXIT(sDisplayName.TakeOwnership(pwzString, ccString));
    pwzString = NULL;

    // open uninstall key
    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwzUninstallSubKey, 0,
        KEY_CREATE_SUB_KEY | DELETE, &hkey);
    IF_WIN32_FAILED_EXIT(lReturn);

    lReturn = RegCreateKeyEx(hkey, sDisplayName._pwz, 0, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_SET_VALUE, NULL, &hkeyApp, &dwDisposition);
    IF_WIN32_FAILED_EXIT(lReturn);

    // check if already exists
    IF_TRUE_EXIT(dwDisposition == REG_OPENED_EXISTING_KEY, S_FALSE);    // already there, nothing to do

    // get path to adfshell.dll
    // BUGBUG: current process must have adfshell.dll loaded

    HMODULE hFnsshell = NULL;
    // assume adfshell.dll is never freed, thus HMODULE always valid
    hFnsshell = GetModuleHandle(WZ_FNSSHELL_STRING);
    IF_WIN32_FALSE_EXIT((hFnsshell != NULL));

    IF_ALLOC_FAILED_EXIT(pwzFnsshellFilePath = new WCHAR[MAX_PATH]);
    IF_WIN32_FALSE_EXIT(GetModuleFileName(hFnsshell, pwzFnsshellFilePath, MAX_PATH));

    // "UninstallString"="rundll32.exe adfshell.dll,Uninstall \"x86_microsoft.webapps.msn6_EAED21A64CF3CD39_6.*_en\" \"C:\\Documents and Settings\\user\\Start Menu\\Programs\\MSN Explorer 6.manifest\""
    IF_FAILED_EXIT(sUninstallString.Assign(WZ_RUNDLL32_STRING));
    IF_FAILED_EXIT(sUninstallString.Append(pwzFnsshellFilePath));
    IF_FAILED_EXIT(sUninstallString.Append(WZ_UNINSTALL_STRING));

    IF_FAILED_EXIT(sUninstallString.Append(sDisplayName));
    IF_FAILED_EXIT(sUninstallString.Append(L"\" \""));
    if (pwzDesktopManifestFilePath != NULL)
    {
        IF_FAILED_EXIT(sUninstallString.Append((LPWSTR)pwzDesktopManifestFilePath));
    }
    IF_FAILED_EXIT(sUninstallString.Append(L"\""));

    // set UninstallString
    lReturn = RegSetValueEx(hkeyApp, L"UninstallString", 0, REG_SZ, 
        (const BYTE *)sUninstallString._pwz, sUninstallString._cc*sizeof(WCHAR));
    IF_WIN32_FAILED_EXIT(lReturn);

    // "ModifyPath"="rundll32.exe adfshell.dll,DisableCurrentVersion \"x86_microsoft.webapps.msn6_EAED21A64CF3CD39_6.*_en\""
    IF_FAILED_EXIT(sModifyPath.Assign(WZ_RUNDLL32_STRING));
    IF_FAILED_EXIT(sModifyPath.Append(pwzFnsshellFilePath));
    IF_FAILED_EXIT(sModifyPath.Append(WZ_ROLLBACK_STRING));

    IF_FAILED_EXIT(sModifyPath.Append(sDisplayName));
    IF_FAILED_EXIT(sModifyPath.Append(L"\""));

    // set ModifyPath
    lReturn = RegSetValueEx(hkeyApp, L"ModifyPath", 0, REG_SZ, 
        (const BYTE *)sModifyPath._pwz, sModifyPath._cc*sizeof(WCHAR));
    IF_WIN32_FAILED_EXIT(lReturn);

    // "DisplayVersion"="6.*"
    // set DisplayVersion
    lReturn = RegSetValueEx(hkeyApp, L"DisplayVersion", 0, REG_SZ, 
        (const BYTE *)sDisplayVersion._pwz, sDisplayVersion._cc*sizeof(WCHAR));
    IF_WIN32_FAILED_EXIT(lReturn);

    // get application info
    IF_FAILED_EXIT(pManImport->GetManifestApplicationInfo(&pAppInfo));
    IF_FALSE_EXIT(_hr == S_OK, E_FAIL); // can't continue without this...

    // "DisplayIcon"=""    //full path to icon exe
    IF_FAILED_EXIT(pAppInfo->Get(MAN_INFO_APPLICATION_ICONFILE, (LPVOID *)&pwzString, &dwCount, &dwFlag));

    if (pwzString != NULL)
    {
        CString sIconFile;
        BOOL bExists = FALSE;

        // note: similar code in shell\shortcut\extricon.cpp.
        IF_FAILED_EXIT(CheckFileExistence(pwzString, &bExists));

        if (!bExists)
        {
            // if the file specified by iconfile does not exist, try again in working dir
            // it can be a relative path...

            LPASSEMBLY_CACHE_IMPORT pCacheImport = NULL;

            IF_FAILED_EXIT(CreateAssemblyCacheImport(&pCacheImport, pAsmId, CACHEIMP_CREATE_RETRIEVE));
            if (_hr == S_OK)
            {
                LPWSTR pwzWorkingDir = NULL;

                // get app root dir
                _hr = pCacheImport->GetManifestFileDir(&pwzWorkingDir, &dwCount);
                pCacheImport->Release();
                IF_FAILED_EXIT(_hr);

                _hr = sIconFile.TakeOwnership(pwzWorkingDir, dwCount);
                if (SUCCEEDED(_hr))
                {
                    IF_FAILED_EXIT(sIconFile.Append(pwzString));   // pwzWorkingDir ends with '\'
                    IF_FAILED_EXIT(CheckFileExistence(sIconFile._pwz, &bExists));
                    if (!bExists)
                        sIconFile.FreeBuffer();
                }
                else
                {
                    SAFEDELETEARRAY(pwzWorkingDir);
                    ASSERT(PREDICATE);
                    goto exit;
                }
            }

            delete [] pwzString;
            pwzString = NULL;
        }
        else
        {
            IF_FAILED_EXIT(sIconFile.TakeOwnership(pwzString));
            pwzString = NULL;
        }

        if (sIconFile._cc != 0)
        {
            // set DisplayIcon
            // BUGBUG: should it set DisplayIcon using iconFile?
            lReturn = RegSetValueEx(hkeyApp, L"DisplayIcon", 0, REG_SZ, 
                (const BYTE *)sIconFile._pwz, sIconFile._cc*sizeof(WCHAR));
            IF_WIN32_FAILED_EXIT(lReturn);
        }
    }

    // "DisplayName"="MSN Explorer 6"
    IF_FAILED_EXIT(pAppInfo->Get(MAN_INFO_APPLICATION_FRIENDLYNAME, (LPVOID *)&pwzString, &dwCount, &dwFlag));

    // BUGBUG: should somehow continue even w/o a friendly name? name conflict?
    IF_NULL_EXIT(pwzString, E_FAIL);

    // set DisplayName ( == Friendly name)
    lReturn = RegSetValueEx(hkeyApp, L"DisplayName", 0, REG_SZ, 
        (const BYTE *)pwzString, dwCount);
    IF_WIN32_FAILED_EXIT(lReturn);    

    _hr = S_OK;

exit:
    //delete app key created if failed
    if (FAILED(_hr) && (hkeyApp != NULL))
    {
        lReturn = RegCloseKey(hkeyApp);  // check return value?
        hkeyApp = NULL;

        //ignore return value
        lReturn = RegDeleteKey(hkey, sDisplayName._pwz);
    }

    SAFERELEASE(pAppInfo);
    SAFERELEASE(pAsmId);
    SAFERELEASE(pAsmIdMask);
    SAFEDELETEARRAY(pwzString);
    SAFEDELETEARRAY(pwzFnsshellFilePath);

    if (hkeyApp)
    {
        lReturn = RegCloseKey(hkeyApp);
        if (SUCCEEDED(_hr))
            _hr = (HRESULT_FROM_WIN32(lReturn));
    }

    if (hkey)
    {
        lReturn = RegCloseKey(hkey);
        if (SUCCEEDED(_hr))
            _hr = (HRESULT_FROM_WIN32(lReturn));
    }
    return _hr;
}


// ---------------------------------------------------------------------------
// CVersionManagement::Uninstall
//
//  pwzDesktopManifestFilePath can be NULL or  ""
// return: S_FALSE if not found
// ---------------------------------------------------------------------------
HRESULT CVersionManagement::Uninstall(LPCWSTR pwzDisplayNameMask, LPCWSTR pwzDesktopManifestFilePath)
{
    // take a displayname mask, enumerate all applicable versions, delete desktop manifest,
    //  remove subscription, uninstall assemblies from GAC, delete app files/dirs, delete registry uninstall info
    // note: need registry HKLM write access

    HKEY hkey = NULL;
    LONG lReturn = 0;
    LPASSEMBLY_IDENTITY pAsmIdMask = NULL;
    LPASSEMBLY_CACHE_ENUM pCacheEnum = NULL;
    LPASSEMBLY_CACHE_IMPORT pCacheImport = NULL;
    LPWSTR pwzName = NULL;
    LPWSTR pwzAppDir = NULL;
    DWORD dwCount = 0;

    IF_NULL_EXIT(pwzDisplayNameMask, E_INVALIDARG);
    IF_FALSE_EXIT(pwzDisplayNameMask[0] != L'\0', E_INVALIDARG);

    IF_FAILED_EXIT(CreateAssemblyIdentityEx(&pAsmIdMask, 0, (LPWSTR)pwzDisplayNameMask));

    // get all applicable versions
    IF_FAILED_EXIT(CreateAssemblyCacheEnum(&pCacheEnum, pAsmIdMask, 0));
    // found nothing, cannot continue
    if (_hr == S_FALSE)
        goto exit;

/*    pCacheEnum->GetCount(&dwCount);
    if (dwCount > 1)
    {
        // multiple versions.... prompt/UI?
    }*/

    // delete desktop manifest
    if (pwzDesktopManifestFilePath != NULL && pwzDesktopManifestFilePath[0] != L'\0')
        IF_WIN32_FALSE_EXIT(DeleteFile(pwzDesktopManifestFilePath));

    // remove subscription
    IF_FAILED_EXIT(pAsmIdMask->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzName, &dwCount));
    IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    {
        IAssemblyUpdate *pAssemblyUpdate = NULL;

        // register for updates
        _hr = CoCreateInstance(CLSID_CAssemblyUpdate, NULL, CLSCTX_LOCAL_SERVER, 
                                IID_IAssemblyUpdate, (void**)&pAssemblyUpdate);
        if (SUCCEEDED(_hr))
        {
            _hr = pAssemblyUpdate->UnRegisterAssemblySubscription(pwzName);
            pAssemblyUpdate->Release();
        }

        if (FAILED(_hr))    // _hr from CoCreateInstance or UnRegisterAssemblySubscription
        {
            // UI?
            MessageBox(NULL, L"Error in update services. Cannot unregister update subscription.", L"ClickOnce",
                MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
            //goto exit; do not terminate!
        }

        // BUGBUG: need a way to recover from this and unregister later

        delete[] pwzName;
    }

    // uninstall assemblies from GAC and
    // delete app files/dirs
    while (TRUE)
    {
        IF_FAILED_EXIT(pCacheEnum->GetNext(&pCacheImport));
        if (_hr == S_FALSE)
            break;

        IF_NULL_EXIT(pCacheImport, E_UNEXPECTED);   // cacheimport cannot be created (app dir may have been deleted)

        IF_FAILED_EXIT(UninstallGACAssemblies(pCacheImport));

        IF_FAILED_EXIT(pCacheImport->GetManifestFileDir(&pwzAppDir, &dwCount));
        IF_FALSE_EXIT(dwCount >= 2, E_FAIL);

        // remove last L'\\'
        if (*(pwzAppDir+dwCount-2) == L'\\')
            *(pwzAppDir+dwCount-2) = L'\0';
        //PathRemoveBackslash(pwzAppDir);

        IF_FAILED_EXIT(RemoveDirectoryAndChildren(pwzAppDir));

        SAFEDELETEARRAY(pwzAppDir);
        SAFERELEASE(pCacheImport);
    }

    // last step: delete registry uninstall info

    // open uninstall key
    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwzUninstallSubKey, 0,
        DELETE, &hkey);
    IF_WIN32_FAILED_EXIT(lReturn);

    lReturn = RegDeleteKey(hkey, pwzDisplayNameMask);
    IF_WIN32_FAILED_EXIT(lReturn);    

    _hr = S_OK;

exit:
    SAFEDELETEARRAY(pwzAppDir);

    SAFERELEASE(pCacheImport);
    SAFERELEASE(pCacheEnum);
    SAFERELEASE(pAsmIdMask);

    if (hkey)
    {
        lReturn = RegCloseKey(hkey);
        if (SUCCEEDED(_hr))
            _hr = (HRESULT_FROM_WIN32(lReturn));
    }

    return _hr;
}


// ---------------------------------------------------------------------------
// CVersionManagement::UninstallGACAssemblies
// ---------------------------------------------------------------------------
HRESULT CVersionManagement::UninstallGACAssemblies(LPASSEMBLY_CACHE_IMPORT pCacheImport)
{
    LPASSEMBLY_MANIFEST_IMPORT pManImport = NULL;
    LPASSEMBLY_IDENTITY pIdentity = NULL;
    LPMANIFEST_INFO pDependAsm   = NULL;

    LPWSTR pwz = NULL;
    DWORD dwCount = 0;
    DWORD n = 0, dwFlag = 0;

    CString sAppAssemblyId;

    IF_FAILED_EXIT(pCacheImport->GetManifestFilePath(&pwz, &dwCount));

    // open to read from the application manifest file
    IF_FAILED_EXIT(CreateAssemblyManifestImport(&pManImport, pwz, NULL, 0));

    SAFEDELETEARRAY(pwz);

    // get the app assembly id
    IF_FAILED_EXIT(pManImport->GetAssemblyIdentity(&pIdentity));
    IF_FAILED_EXIT(pIdentity->GetDisplayName(0, &pwz, &dwCount));
    IF_FAILED_EXIT(sAppAssemblyId.TakeOwnership(pwz, dwCount));
    pwz = NULL;
    SAFERELEASE(pIdentity);

    // uninstall all dependent assemblies that are installed to the GAC
    while (TRUE)
    {
        IF_FAILED_EXIT(pManImport->GetNextAssembly(n++, &pDependAsm));
        if (_hr == S_FALSE)
            break;

        IF_FAILED_EXIT(pDependAsm->Get(MAN_INFO_DEPENDENT_ASM_ID, (LPVOID *)&pIdentity, &dwCount, &dwFlag));
        IF_NULL_EXIT(pIdentity, E_UNEXPECTED);

        IF_FAILED_EXIT(::IsKnownAssembly(pIdentity, KNOWN_TRUSTED_ASSEMBLY));
        if (_hr == S_FALSE)
        {
            // ISSUE-2002/07/12-felixybc  This has to be cleaned up to use the same mechanism as the download path
            IF_FAILED_EXIT(::IsKnownAssembly(pIdentity, KNOWN_SYSTEM_ASSEMBLY));
        }
        if (_hr == S_OK)
        {
            CString sAssemblyName;
            FUSION_INSTALL_REFERENCE fiRef = {0};
            ULONG ulDisposition = 0;

            // avalon assemblies are installed to the GAC

            // lazy init
            if (_pFusionAsmCache == NULL)
                IF_FAILED_EXIT(CreateFusionAssemblyCacheEx(&_pFusionAsmCache));

            IF_FAILED_EXIT(pIdentity->GetCLRDisplayName(0, &pwz, &dwCount));

            IF_FAILED_EXIT(sAssemblyName.TakeOwnership(pwz, dwCount));
            pwz = NULL;

            // setup the necessary reference struct
            fiRef.cbSize = sizeof(FUSION_INSTALL_REFERENCE);
            fiRef.dwFlags = 0;
            fiRef.guidScheme = FUSION_REFCOUNT_OPAQUE_STRING_GUID;
            fiRef.szIdentifier = sAppAssemblyId._pwz;
            fiRef.szNonCannonicalData = NULL;

            // remove from GAC

            IF_FAILED_EXIT(_pFusionAsmCache->UninstallAssembly(0, sAssemblyName._pwz, &fiRef, &ulDisposition));
            // BUGBUG: need to recover from the STILL_IN_USE case
            IF_FALSE_EXIT(ulDisposition != IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE
                    && ulDisposition != IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND, E_FAIL);
        }
        
        SAFERELEASE(pIdentity);
        SAFERELEASE(pDependAsm);
    }

exit:
    SAFERELEASE(pDependAsm);
    SAFERELEASE(pIdentity);
    SAFERELEASE(pManImport);

    SAFEDELETEARRAY(pwz);
    return _hr;
}


// ---------------------------------------------------------------------------
// CVersionManagement::Rollback
// return: S_FALSE if not found, E_ABORT if aborted
// ---------------------------------------------------------------------------
HRESULT CVersionManagement::Rollback(LPCWSTR pwzDisplayNameMask)
{
    // take a displayname mask, make the latest version not visible
    // note: a per user setting

    // rollback does not check integrity of app cached. if only 2 app dirs exist and all app files deleted,
    //   rollback still reports success

    // timing window: depends on the timing of this and check for max version in cache in app start....

    HKEY hkey = NULL;
    LPASSEMBLY_IDENTITY pAsmIdMask = NULL;
    LPASSEMBLY_CACHE_ENUM pCacheEnum = NULL;
    LPASSEMBLY_CACHE_IMPORT pCacheImport = NULL;
    DWORD dwCount = 0;
    CString sRegKeyString;
    LPWSTR pwzDisplayName = NULL;
    LPWSTR pwzCacheDir = NULL;

    LONG lResult = 0;

    IF_NULL_EXIT(pwzDisplayNameMask, E_INVALIDARG);
    IF_FALSE_EXIT(pwzDisplayNameMask[0] != L'\0', E_INVALIDARG);

    IF_FAILED_EXIT(CreateAssemblyIdentityEx(&pAsmIdMask, 0, (LPWSTR)pwzDisplayNameMask));

    // get all applicable, visible versions
    IF_FAILED_EXIT(CreateAssemblyCacheEnum(&pCacheEnum, pAsmIdMask, CACHEENUM_RETRIEVE_VISIBLE));
    // found nothing, cannot continue
    if (_hr == S_FALSE)
        goto exit;

    // count must be >= 1
    pCacheEnum->GetCount(&dwCount);
    if (dwCount == 1)
    {
        MessageBox(NULL, L"Only one active version of this application in the system. Use 'Remove' to remove this application and unregister its subscription.",
            L"ClickOnce", MB_OK | MB_ICONINFORMATION  | MB_TASKMODAL);
        _hr = E_ABORT;
        goto exit;
    }

    // multiple versions, count > 1
    // prompt/UI? ask confirmation to continue
    IF_TRUE_EXIT(MessageBox(NULL, 
        L"This application has been updated. If it is not working correctly you can disable the current version. Do you want to go back to a previous version of this application?",
        L"ClickOnce", MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL) != IDYES, E_ABORT);

    // get max cached
    // BUGBUG: sort cache enum so that max cached is at index 0, and use that instead
    // notenote: a timing window - a version can turn invisible or a new version can complete
    //  between cache enum (a snapshot) above and CreateAsmCacheImport(RESOLVE_REF) below
    IF_FAILED_EXIT(CreateAssemblyCacheImport(&pCacheImport, pAsmIdMask, CACHEIMP_CREATE_RESOLVE_REF));
//        MessageBox(NULL, L"Error retrieving cached version. Cannot continue.", L"ClickOnce",
//            MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
    IF_FALSE_EXIT(_hr == S_OK, E_FAIL);

    IF_FAILED_EXIT(pCacheImport->GetManifestFileDir(&pwzCacheDir, &dwCount));
    IF_FALSE_EXIT(dwCount >= 2, E_FAIL);

    // remove last L'\\'
    if (*(pwzCacheDir+dwCount-2) == L'\\')
        *(pwzCacheDir+dwCount-2) = L'\0';
    // find the name to use from the cache path
    pwzDisplayName = wcsrchr(pwzCacheDir, L'\\');
    IF_NULL_EXIT(pwzDisplayName, E_FAIL);

    // BUGBUG: use CAssemblyCache::SetStatus()
    // this has to be the same as how assemblycache does it!
    IF_FAILED_EXIT(sRegKeyString.Assign(L"Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Cache\\"));
    IF_FAILED_EXIT(sRegKeyString.Append(pwzDisplayName));

    // create key if not exist, ignore disposition information
    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, sRegKeyString._pwz, 0, NULL, 
                REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkey, NULL);
    IF_WIN32_FAILED_EXIT(lResult);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwValue = 0;

        // set to 0 to make it not visible so that StartW/host/cache will ignore it
        // when executing the app but keep the dir name so that download
        // will assume it is handled - assemblycache.cpp & assemblydownload.cpp's check
        lResult = RegSetValueEx(hkey, L"Visible", NULL, REG_DWORD,
                (PBYTE) &dwValue, sizeof(dwValue));
        IF_WIN32_FAILED_EXIT(lResult);

        if (lResult == ERROR_SUCCESS)
        {
            MessageBox(NULL, L"Current version disabled. Next time another version of the application will run instead.", L"ClickOnce",
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL);
        }
    }

exit:
    SAFEDELETEARRAY(pwzCacheDir);

    SAFERELEASE(pCacheImport);
    SAFERELEASE(pCacheEnum);
    SAFERELEASE(pAsmIdMask);

    if (hkey)
    {
        lResult = RegCloseKey(hkey);
        if (SUCCEEDED(_hr))
            _hr = (HRESULT_FROM_WIN32(lResult));
    }

    return _hr;
}

// IUnknown methods

// ---------------------------------------------------------------------------
// CVersionManagement::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CVersionManagement::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
//        || IsEqualIID(riid, IID_IVersionManagement)
       )
    {
        *ppvObj = this; //static_cast<IVersionManagement*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CVersionManagement::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CVersionManagement::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CVersionManagement::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CVersionManagement::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\debbase.h ===
/*
 * debbase.h - Base debug macros and their retail translations.
 */


// BUGBUG: this should be fixed/beef up

/* Macros
 *********/

/* debug assertion macro */

/*
 * ASSERT() may only be used as a statement, not as an expression.
 *
 * E.g.,
 *
 * ASSERT(pszRest);
 */

#ifdef DEBUG

#define ASSERT(exp) \
   if (exp) \
      ; \
   else \
      ERROR_OUT(("assertion failed '%s'", (LPCWSTR)#exp))

#else

#define ASSERT(exp)

#endif   /* DEBUG */

/* debug evaluation macro */

/*
 * EVAL() may only be used as a logical expression.
 *
 * E.g.,
 *
 * if (EVAL(exp))
 *    bResult = TRUE;
 */

/*#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || \
    (ERROR_OUT(("evaluation failed '%s'", (LPCWSTR)#exp)), 0))

#else
*/
#define EVAL(exp) \
   ((exp) != 0)

/*#endif*/   /* DEBUG */

/* handle validation macros */

extern BOOL IsValidHWND(HWND);

#ifdef DEBUG

extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHEVENT(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHGLOBAL(HGLOBAL);
extern BOOL IsValidHMENU(HMENU);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidHPROCESS(HANDLE);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);

#endif

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (ERROR_OUT(("invalid H" #type " - %#08lx", (hnd))), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\refcount.hpp ===
/*
 * refcount.hpp - RefCount class description.
 */

#pragma once

#include <objbase.h>
#include <windows.h>

/* Types
 ********/

/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;

public:
   RefCount(void);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};
DECLARE_STANDARD_TYPES(RefCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\shcut.h ===
#pragma once
#ifndef _SHCUT_DLL_H
#define _SHCUT_DLL_H

#include <objbase.h>
#include <windows.h>

#include <shlobj.h>
#include "refcount.hpp"

#include "fusenet.h"

// Shortcut flags

typedef enum _fusshcutflags
{
	FUSSHCUT_FL_NOTDIRTY	= 0x0000,
	FUSSHCUT_FL_DIRTY		= 0x0001,

	ALL_FUSSHCUT_FLAGS   //= FUSSHCUT_FL_DIRTY
}
FUSSHCUTFLAGS;

#define DEFAULTSHOWCMD			SW_NORMAL


// BUGBUG?: revise length restrictions

#define DISPLAYNAMESTRINGLENGTH		26
#define TYPESTRINGLENGTH			20

#define MAX_URL_LENGTH				2084 // same as INTERNET_MAX_URL_LENGTH+1 from wininet.h


// Clases and interfaces

class CFusionShortcutClassFactory : public IClassFactory
{
public:
	CFusionShortcutClassFactory		();

	// IUnknown Methods
	STDMETHOD_    (ULONG, AddRef)	();
	STDMETHOD_    (ULONG, Release)	();
	STDMETHOD     (QueryInterface)	(REFIID, void **);

	// IClassFactory Moethods
	STDMETHOD     (LockServer)		(BOOL);
	STDMETHOD     (CreateInstance)	(IUnknown*,REFIID,void**);

protected:
	long			_cRef;
};

// Shortcut Shell extension

class CFusionShortcut : public RefCount,
					public IExtractIcon,
					public IPersistFile,
					public IShellExtInit,
					public IShellLink,
					public IShellPropSheetExt,
					public IQueryInfo
{
public:
	CFusionShortcut(void);
	~CFusionShortcut(void);

	// IUnknown methods

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	// IExtractIcon methods

	HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags, LPWSTR pwzIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
	HRESULT STDMETHODCALLTYPE Extract(LPCWSTR pcwzFile, UINT uIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT ucIconSize);

	// IPersist method

	HRESULT STDMETHODCALLTYPE GetClassID(CLSID* pclsid);

	// IPersistFile methods

	HRESULT STDMETHODCALLTYPE IsDirty(void);
	HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pcwszFileName, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pcwszFileName);
	HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pcwszFileName, DWORD dwMode);
	HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR *ppwszFileName);

	// IShellExtInit method

	HRESULT STDMETHODCALLTYPE Initialize(LPCITEMIDLIST pcidlFolder, IDataObject* pidobj, HKEY hkeyProgID);

	// IShellLink methods

	HRESULT STDMETHODCALLTYPE SetPath(LPCWSTR pcwzPath);
	HRESULT STDMETHODCALLTYPE GetPath(LPWSTR pwzFile, int ncFileBufLen, PWIN32_FIND_DATA pwfd, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE SetRelativePath(LPCWSTR pcwzRelativePath, DWORD dwReserved);
	HRESULT STDMETHODCALLTYPE SetIDList(LPCITEMIDLIST pcidl);
	HRESULT STDMETHODCALLTYPE GetIDList(LPITEMIDLIST *ppidl);
	HRESULT STDMETHODCALLTYPE SetDescription(LPCWSTR pcwzDescription);
	HRESULT STDMETHODCALLTYPE GetDescription(LPWSTR pwzDescription, int ncDesciptionBufLen);
	HRESULT STDMETHODCALLTYPE SetArguments(LPCWSTR pcwzArgs);
	HRESULT STDMETHODCALLTYPE GetArguments(LPWSTR pwzArgs, int ncArgsBufLen);
	HRESULT STDMETHODCALLTYPE SetWorkingDirectory(LPCWSTR pcwzWorkingDirectory);
	HRESULT STDMETHODCALLTYPE GetWorkingDirectory(LPWSTR pwzWorkingDirectory, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetHotkey(WORD wHotkey);
	HRESULT STDMETHODCALLTYPE GetHotkey(PWORD pwHotkey);
	HRESULT STDMETHODCALLTYPE SetShowCmd(int nShowCmd);
	HRESULT STDMETHODCALLTYPE GetShowCmd(PINT pnShowCmd);
	HRESULT STDMETHODCALLTYPE SetIconLocation(LPCWSTR pcwzIconFile, int niIcon);
	HRESULT STDMETHODCALLTYPE GetIconLocation(LPWSTR pwzIconFile, int ncbLen, PINT pniIcon);
	HRESULT STDMETHODCALLTYPE Resolve(HWND hwnd, DWORD dwFlags);

	// IShellPropSheetExt methods

	HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
	HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

	// IQueryInfo methods

	HRESULT STDMETHODCALLTYPE GetInfoFlags(DWORD *pdwFlags);
	HRESULT STDMETHODCALLTYPE GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip);

	// other get/set methods (used by prop sheet)

	HRESULT STDMETHODCALLTYPE SetCodebase(LPCWSTR pcwzCodebase);
	HRESULT STDMETHODCALLTYPE GetCodebase(LPWSTR pwzCodebase, int ncbLen);

	// other methods

	HRESULT STDMETHODCALLTYPE GetAssemblyIdentity(LPASSEMBLY_IDENTITY* ppAsmId);
	HRESULT STDMETHODCALLTYPE GetCurFile(LPWSTR pwzFile, UINT ucbLen);
	HRESULT STDMETHODCALLTYPE Dirty(BOOL bDirty);

private:
	DWORD m_dwFlags;

	LPWSTR m_pwzShortcutFile;
	LPWSTR m_pwzPath;
	LPWSTR m_pwzDesc;
	LPWSTR m_pwzIconFile;
	int      m_niIcon;
	LPWSTR m_pwzWorkingDirectory;
	int      m_nShowCmd;
	WORD   m_wHotkey;

	LPWSTR	m_pwzCodebase;
	
	LPASSEMBLY_IDENTITY		m_pIdentity;
};

extern const GUID CLSID_FusionShortcut;

#endif // _SHCUT_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\project.hpp ===
/*
 * project.hpp - project header file for CFusionShortcut Shell
 *               extension DLL.
 */

// * note: debug check/code incomplete.
//#define DEBUG

/* Common Headers
 *****************/

#define INC_OLE2				// for windows.h
#define CONST_VTABLE			// for objbase.h

#ifndef WIN32_LEAN_AND_MEAN		// NT builds define this for us
#define WIN32_LEAN_AND_MEAN		// for windows.h
#endif							//  WIN32_LEAN_AND_MEAN

#define NOSERVICE
#define NOMCX
#define NOIME
#define NOSOUND
#define NOCOMM
#define NOKANJI
#define NORPC
#define NOPROXYSTUB
#define NOIMAGE
#define NOTAPE 
   
#include <windows.h>

#include <shellapi.h>

#include <limits.h>				// for ULONG_MAX

#ifdef __cplusplus
extern "C" {					// Assume C declarations for C++.
#endif   /* __cplusplus */

#include "debbase.h"

#ifdef __cplusplus
}								// End of extern "C" {.
#endif   /* __cplusplus */



/* Project Headers
 ******************/

#include "shcut.h"
#include "refcount.hpp"

#include <sxsapi.h>

// bit flag manipulation ---

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))

// util stuff ---

HRESULT GetLastWin32Error();

bool PathAppend(LPWSTR wzDest, LPCWSTR wzSrc);

const WCHAR g_cwzWhiteSpace[]		= L" \t";
const WCHAR g_cwzPathSeparators[]	= L":/\\";
const WCHAR g_cwzEmptyString[]		= L"";

extern BOOL AnyNonWhiteSpace(LPCWSTR pcsz);

// debug stuff ---

extern BOOL IsValidPath(PCWSTR pcwzPath);
extern BOOL IsValidPathResult(HRESULT hr, PCWSTR pcwzPath, UINT ucbPathBufLen);
extern BOOL IsValidIconIndex(HRESULT hr, PCWSTR pcwzIconFile, UINT ucbIconFileBufLen, int niIcon);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\shellres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shelllc.rc, dialog.rc
//
#define IDD_LINKDIALOG              102
#define IDC_TEXT                         103
#define IDC_OK                             104
#define IDD_NAME                        200
#define IDD_HOTKEY                      1000
#define IDD_START_IN                    3002
#define IDD_ICON                        3301
#define IDD_LINE_1                      3327
#define IDD_LINE_2                      3328
#define IDD_CHANGE_ICON                 3407
#define IDD_SHOW_CMD                    3408
#define IDC_STATIC                      -1
#define DLG_FUS_SHORTCUT_PROP_SHEET_APPNAME 101
#define IDD_CODEBASE                    1001
#define IDD_VERSION                     1002
#define IDD_CULTURE                     1003
#define DLG_FUS_SHORTCUT_PROP_SHEET     1040
#define IDD_TYPE                        3303
#define IDD_ENTRYPOINT                  3304
#define IDD_DISPLAY_NAME                3305
#define IDD_PKT                         3306
#define IDS_SHOW_NORMAL                 1 // # must be in order
#define IDS_SHOW_MINIMIZED              2
#define IDS_SHOW_MAXIMIZED              3
#define IDS_TIP_NAME                      4
#define IDS_TIP_TYPE                      5
#define IDS_TIP_LOCATION                  6
#define IDS_TIP_CODEBASE                 7

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\includes\versionmanagement.h ===
#pragma once
#ifndef _VERSION_MAN_H
#define _VERSION_MAN_H

#include <objbase.h>
#include <windows.h>

// ----------------------------------------------------------------------

class CVersionManagement;
typedef CVersionManagement *LPVERSION_MANAGEMENT;

STDAPI CreateVersionManagement(
    LPVERSION_MANAGEMENT       *ppVersionManagement,
    DWORD                       dwFlags);

// ----------------------------------------------------------------------

class CVersionManagement : public IUnknown//: public IVersionManagement
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IVersionManagement methods

    STDMETHOD(RegisterInstall)(
        /* in */ LPASSEMBLY_MANIFEST_IMPORT pManImport,
        /* in */ LPCWSTR pwzDesktopManifestFilePath);

    STDMETHOD(Uninstall)(
        /* in */ LPCWSTR pwzDisplayNameMask,
        /* in */ LPCWSTR pwzDesktopManifestFilePath);

    STDMETHOD(Rollback)(
        /* in */ LPCWSTR pwzDisplayNameMask);


    CVersionManagement();
    ~CVersionManagement();

private:
    DWORD                       _dwSig;
    DWORD                       _cRef;
    DWORD                       _hr;

    IAssemblyCache*             _pFusionAsmCache;

    HRESULT UninstallGACAssemblies(LPASSEMBLY_CACHE_IMPORT pCacheImport);

friend HRESULT CreateVersionManagement(
    LPVERSION_MANAGEMENT       *ppVersionManagement,
    DWORD                       dwFlags);
};   

#endif // _VERSION_MAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\extricon.cpp ===
/*
 * extricon.cpp - IExtractIcon implementation for CFusionShortcut class.
 */


/* Headers
 **********/

#include "project.hpp"
#include <stdio.h> // for _snwprintf

/* Global Constants
 *******************/

const WCHAR g_cwzDefaultIconKey[]	= L"manifestfile\\DefaultIcon";

const HKEY g_hkeySettings			= HKEY_CLASSES_ROOT;

/* Module Constants
 *******************/

const WCHAR s_cwzGenericIconFile[]	= L"adfshell.dll";

const int s_ciGenericIconFileIndex	= 0;


void TrimString(PWSTR pwzTrimMe, PCWSTR pwzTrimChars)
{
	PWSTR pwz = pwzTrimMe;;
	PWSTR pwzStartMeat = NULL;

	if ( !pwzTrimMe || !pwzTrimChars )
		goto exit;

	// Trim leading characters.

	while (*pwz && wcschr(pwzTrimChars, *pwz))
	{
		//CharNext(pwz);
		if (*pwz != L'\0')	// this really will not be false...
			pwz++;
	}

	pwzStartMeat = pwz;

	// Trim trailing characters.

	if (*pwz)
	{
		pwz += wcslen(pwz);

		//CharPrev(pwzStartMeat, pwz);
		if (pwz != pwzStartMeat)	// this check is not really necessary...
			pwz--;

		if (pwz > pwzStartMeat)
		{
			while (wcschr(pwzTrimChars, *pwz))
			{
				//CharPrev(pwzStartMeat, pwz);
				if (pwz != pwzStartMeat)	// this really will not be false...
					pwz--;
			}

			//CharNext(pwz);
			if (*pwz != L'\0')	// this check is not really necessary...
				pwz++;

			ASSERT(pwz > pwzStartMeat);

			*pwz = L'\0';
		}
	}

	// Relocate stripped string.

	if (*pwzStartMeat && pwzStartMeat > pwzTrimMe)
		// (+ 1) for null terminator.
		// BUGBUG?: is this going to bite us later?
		MoveMemory(pwzTrimMe, pwzStartMeat, (wcslen(pwzStartMeat)+1) * sizeof(WCHAR));
	else if (!*pwzStartMeat)
		pwzTrimMe[0] = L'\0';
	else
		ASSERT(pwzStartMeat == pwzTrimMe);

exit:
	return;
}

/*
** TrimWhiteSpace()
**
** Trims leading and trailing white space from a string in place.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void TrimWhiteSpace(PWSTR pwzTrimMe)
{
	TrimString(pwzTrimMe, g_cwzWhiteSpace);

	// TrimString() validates pwzTrimMe on output.

	return;
}

/*
** GetRegKeyValue()
**
** Retrieves the data from a registry key's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
LONG GetRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                   PCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
	LONG lResult;
	HKEY hkeySubKey;

	ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
	ASSERT(! pcwzSubKey || ! pcwzValue || ! pdwValueType || ! pbyteBuf);

	lResult = RegOpenKeyEx(hkeyParent, pcwzSubKey, 0, KEY_QUERY_VALUE,
			&hkeySubKey);

	if (lResult == ERROR_SUCCESS)
	{
		LONG lResultClose;

		lResult = RegQueryValueEx(hkeySubKey, pcwzValue, NULL, pdwValueType,
				pbyteBuf, pdwcbBufLen);

		lResultClose = RegCloseKey(hkeySubKey);

		if (lResult == ERROR_SUCCESS)
			lResult = lResultClose;
	}

	return(lResult);
}

/*
** GetRegKeyStringValue()
**
** Retrieves the data from a registry key's string value.
**
** Arguments:
**
** Returns: ERROR_CANTREAD if not string
**
** Side Effects:  none
*/
LONG GetRegKeyStringValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                         PCWSTR pcwzValue, PWSTR pwzBuf,
                                         PDWORD pdwcbBufLen)
{
	LONG lResult;
	DWORD dwValueType;

	// GetRegKeyValue() will verify the parameters.

	lResult = GetRegKeyValue(hkeyParent, pcwzSubKey, pcwzValue, &dwValueType,
			(PBYTE)pwzBuf, pdwcbBufLen);

	if (lResult == ERROR_SUCCESS &&	dwValueType != REG_SZ)
		lResult = ERROR_CANTREAD;

	return(lResult);
}


/*
** GetDefaultRegKeyValue()
**
** Retrieves the data from a registry key's default string value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
LONG GetDefaultRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                          PWSTR pwzBuf, PDWORD pdwcbBufLen)
{
	// GetRegKeyStringValue() will verify the parameters.

	return(GetRegKeyStringValue(hkeyParent, pcwzSubKey, NULL, pwzBuf,
			pdwcbBufLen));
}

/***************************** Private Functions *****************************/

/*
** ParseIconEntry()
**
**
** Arguments:
**
** Returns:       S_OK if icon entry parsed successfully.
**                S_FALSE if not (empty string).
**                (get 0 if icon index empty, or
**                 if icon index parsing fails)
**
** Side Effects:  The contents of pwzIconEntry are modified.
**
*/
HRESULT ParseIconEntry(LPWSTR pwzIconEntry, PINT pniIcon)
{
	HRESULT hr = S_OK;
	LPWSTR pwzComma;

	// caller GetGenericIcon() will verify the parameters.

	pwzComma = wcschr(pwzIconEntry, L',');

	if (pwzComma)
	{
		*pwzComma++ = L'\0';
		LPWSTR pwzStopString=NULL;
		*pniIcon = (int) wcstol(pwzComma, &pwzStopString, 10);
	}
	else
	{
		*pniIcon = 0;
	}

	TrimWhiteSpace(pwzIconEntry);

	if (pwzIconEntry[0] == L'\0')
	{
		hr = S_FALSE;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconEntry, MAX_PATH, *pniIcon));

	return(hr);
}


/*
** GetFallBackGenericIcon()
**
**
** Arguments:
**
** Returns:       S_OK if fallback generic icon information retrieved
**                successfully.
**                E_FAIL if not.
**
** Side Effects:  none
*/
HRESULT GetFallBackGenericIcon(LPWSTR pwzIconFile,
                                               UINT ucbIconFileBufLen,
                                               PINT pniIcon)
{
	HRESULT hr = S_OK;

	// Fall back to first icon in this module.
	// caller GetGenericIcon() will verify the parameters.

	if (ucbIconFileBufLen >= ( sizeof(s_cwzGenericIconFile) / sizeof(WCHAR) ))
	{
		wcscpy(pwzIconFile, s_cwzGenericIconFile);
		*pniIcon = s_ciGenericIconFileIndex;

	}
	else
	{
		hr = E_FAIL;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon));

	return(hr);
}


/*
** GetGenericIcon()
**
**
** Arguments:
**
** Returns:       S_OK if generic icon information retrieved successfully.
**                Otherwise error (E_FAIL).
**
** Side Effects:  none
*/
// assumptions: always structure the reg key value and fallback path so that the iconfile
//       can be found by the shell!!
//       should also consider making it a fully qualify path
//       finally the iconfile must exist
HRESULT GetGenericIcon(LPWSTR pwzIconFile,
                                       UINT ucbIconFileBufLen, PINT pniIcon)
{
	HRESULT hr = S_OK;
	DWORD dwcbLen = ucbIconFileBufLen;

	// caller GetIconLocation() will verify parameters

	ASSERT(IS_VALID_HANDLE(g_hkeySettings, KEY));

	if (GetDefaultRegKeyValue(g_hkeySettings, g_cwzDefaultIconKey, pwzIconFile, &dwcbLen)
			== ERROR_SUCCESS)
		hr = ParseIconEntry(pwzIconFile, pniIcon);
	else
	{
		// no icon entry
		hr = S_FALSE;
	}

	if (hr == S_FALSE)
		hr = GetFallBackGenericIcon(pwzIconFile, ucbIconFileBufLen, pniIcon);

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon));

	return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetIconLocation(UINT uInFlags,
                                                      LPWSTR pwzIconFile,
                                                      UINT ucbIconFileBufLen,
                                                      PINT pniIcon,
                                                      PUINT puOutFlags)
{
	// is there any pref hit by doing this logic/probing here?
	//  maybe this can be done in IPersistFile::Load instead?

	// always attempt to return S_OK or S_FALSE
	// only exception is that one case of E_INVALIDARG right below
	HRESULT hr=S_OK;

	if (!pwzIconFile || !pniIcon || ucbIconFileBufLen <= 0)
	{
		// should this return S_FALSE anyway so that the default shell icon is used?
		hr = E_INVALIDARG;
		goto exit;
	}

	if (IS_FLAG_CLEAR(uInFlags, GIL_OPENICON))
	{
		// .. this get the path ...
		hr = GetIconLocation(pwzIconFile, ucbIconFileBufLen, pniIcon);

		if (hr == S_OK && GetFileAttributes(pwzIconFile) == (DWORD)-1)
		{
			// if the file specified by iconfile does not exist, try again in working dir
			// it can be a relative path...

			// see note in shlink.cpp for string array size
			LPWSTR pwzWorkingDir = new WCHAR[ucbIconFileBufLen];

			hr = GetWorkingDirectory(pwzWorkingDir, ucbIconFileBufLen);
			if (hr != S_OK)
				hr = S_FALSE;
			else
			{
				LPWSTR pwzPath = new WCHAR[ucbIconFileBufLen];

				// working dir does not end w/ '\'
				_snwprintf(pwzPath, ucbIconFileBufLen, L"%s\\%s", pwzWorkingDir, pwzIconFile);

				if (GetFileAttributes(pwzPath) == (DWORD)-1)
					hr = S_FALSE;
				else
					wcscpy(pwzIconFile, pwzPath);

				delete [] pwzPath;
			}

			delete [] pwzWorkingDir;
		}

		// BUGBUG?: change to '!= S_OK'?
		// no need because GetIconLocation(,,) only returns S_OK/S_FALSE here
		if (hr == S_FALSE)
		{
			if (m_pwzPath)
			{
				// no icon file, use the entry point...
				// BUGBUG?: passing NULL as PWIN32_FIND_DATA will assert..
				hr = GetPath(pwzIconFile, ucbIconFileBufLen, NULL, SLGP_SHORTPATH); //?????? 0);
				if (hr != S_OK || GetFileAttributes(pwzIconFile) == (DWORD)-1)
					hr = S_FALSE;

				*pniIcon = 0;
			}
			/*else
				hr = S_FALSE;*/

			if (hr == S_FALSE)
			{
				// ... there's nothing?
				// Use generic URL icon.

				// see assumptions on GetGenericIcon()
				hr = GetGenericIcon(pwzIconFile, ucbIconFileBufLen, pniIcon);

				if (FAILED(hr))
					// worst case: ask shell to use its generic icon
					hr = S_FALSE;
			}
		}
	}
	else
		// No "open look" icon.
		hr = S_FALSE;

	if (hr != S_OK)
	{
		// see shelllink?
		if (ucbIconFileBufLen > 0)
			*pwzIconFile = L'\0';

		*pniIcon = 0;
	}

exit:
	if (puOutFlags)
		*puOutFlags = 0;
	// ignore puOutFlags == NULL case

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon))// &&

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Extract(LPCWSTR pcwzIconFile,
                                                    UINT uiIcon,
                                                    HICON* phiconLarge,
                                                    HICON* phiconSmall,
                                                    UINT ucIconSize)
{
	HRESULT hr;

	ASSERT(IsValidIconIndex(S_OK, pcwzIconFile, MAX_PATH, uiIcon));

	// FEATURE: Validate ucIconSize here.

	if (phiconLarge)
		*phiconLarge = NULL;
	if (phiconSmall)
		*phiconSmall = NULL;

	// Use caller's default implementation of ExtractIcon().
	// GetIconLocation() should return good path and index

	hr = S_FALSE;

	ASSERT((hr == S_OK &&
		IS_VALID_HANDLE(*phiconLarge, ICON) &&
		IS_VALID_HANDLE(*phiconSmall, ICON)) ||
		(hr != S_OK &&
		! *phiconLarge &&
		! *phiconSmall));

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\infotip.cpp ===
/*
 * infotip.cpp - IQueryInfo implementation
 */


/* Headers
 **********/

#include "project.hpp"
#include <stdio.h>    // for _snwprintf
#include "shellres.h"

const UINT s_ucMaxNameLen         = 20;
const UINT s_ucMaxTypeLen           = 10;
const UINT s_ucMaxLocationLen     = 15;
const UINT s_ucMaxCodebaseLen   = 15;

// see GetInfoTip() for how the tip string/string-length is assembled
const UINT s_ucMaxTipLen        = s_ucMaxNameLen+s_ucMaxTypeLen+s_ucMaxLocationLen \
                            +s_ucMaxCodebaseLen+DISPLAYNAMESTRINGLENGTH \
                            +TYPESTRINGLENGTH+MAX_PATH+MAX_URL_LENGTH+8;

extern HINSTANCE g_DllInstance;

// ----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CFusionShortcut::GetInfoFlags(DWORD *pdwFlags)
{
    if (pdwFlags)
        *pdwFlags = 0;

    return S_OK; //E_NOTIMPL?
}

// ----------------------------------------------------------------------------

// BUGBUG?: maybe replace the use of g_cwzEmptyString with L"(unknown)"?
HRESULT STDMETHODCALLTYPE CFusionShortcut::GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip)
{
    HRESULT hr = S_OK;
    LPMALLOC lpMalloc = NULL;

    WCHAR wzTip[s_ucMaxTipLen];
    WCHAR wzNameHint[s_ucMaxNameLen];
    WCHAR wzTypeHint[s_ucMaxTypeLen];
    WCHAR wzLocationHint[s_ucMaxLocationLen];
    WCHAR wzCodebaseHint[s_ucMaxCodebaseLen];

    LPWSTR pwzName = (m_pwzDesc ? m_pwzDesc : (LPWSTR) g_cwzEmptyString);
    LPWSTR pwzLocation = (m_pwzPath ? m_pwzPath : (LPWSTR) g_cwzEmptyString);
    LPWSTR pwzCodebase = (m_pwzCodebase ? m_pwzCodebase : (LPWSTR) g_cwzEmptyString);
    LPWSTR pwzAppType = NULL;

    LPASSEMBLY_IDENTITY pId = NULL;

    // dwFlags ignored

    if (ppwszTip)
        *ppwszTip = NULL;
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Allocate a shell memory object.
    hr = SHGetMalloc (&lpMalloc);
    if (FAILED (hr))
        goto exit;

    wzTip[0] = L'\0';

    // load resources
    if (!LoadString(g_DllInstance, IDS_TIP_NAME, wzNameHint, s_ucMaxNameLen))
    {
        // do not fail
        wzNameHint[0] = L'\0';
    }

    if (!LoadString(g_DllInstance, IDS_TIP_TYPE, wzTypeHint, s_ucMaxTypeLen))
    {
        // do not fail
        wzTypeHint[0] = L'\0';
    }

    if (!LoadString(g_DllInstance, IDS_TIP_LOCATION, wzLocationHint, s_ucMaxLocationLen))
    {
        // do not fail
        wzLocationHint[0] = L'\0';
    }

    if (!LoadString(g_DllInstance, IDS_TIP_CODEBASE, wzCodebaseHint, s_ucMaxCodebaseLen))
    {
        // do not fail
        wzCodebaseHint[0] = L'\0';
    }

    if (SUCCEEDED(hr = GetAssemblyIdentity(&pId)))
    {
        DWORD ccString = 0;

        if (FAILED(pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE, &pwzAppType, &ccString)))
            pwzAppType = NULL;

        pId->Release();
        pId = NULL;
    }

    // ignore error
    // BUGBUG?: "(null)" is displayed if m_pwzDesc or m_pwzPath == NULL...
    if (_snwprintf(wzTip, s_ucMaxTipLen, L"%s %s\n%s %s\n%s %s\n%s %s",
            wzNameHint, pwzName, wzTypeHint, (pwzAppType ? pwzAppType : g_cwzEmptyString),
            wzLocationHint, pwzLocation, wzCodebaseHint, pwzCodebase) < 0)
        wzTip[s_ucMaxTipLen-1] = L'\0';

    // Get some memory
    *ppwszTip = (LPWSTR) lpMalloc->Alloc ((wcslen(wzTip)+1)*sizeof(WCHAR));
    if (! *ppwszTip)
    {
        hr = E_OUTOFMEMORY;
        goto exit; // Error - could not allocate memory
    }

    wcscpy(*ppwszTip, wzTip);

exit:
    if (pwzAppType)
        delete [] pwzAppType;

    if (lpMalloc)
        lpMalloc->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\persist.cpp ===
/*
 * persist.cpp - IPersist, IPersistFile implementations for
 *               CFusionShortcut class.
 */


/* Headers
 **********/

#include "project.hpp" // for GetLastWin32Error

/* Global Constants
 *******************/

const WCHAR g_cwzDefaultFileNamePrompt[]  = L"*.manifest";

// ----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CFusionShortcut::GetCurFile(LPWSTR pwzFile,
                                                       UINT ucbLen)
{
    HRESULT hr=S_OK;

    if (m_pwzShortcutFile)
    {
        wcsncpy(pwzFile, m_pwzShortcutFile, ucbLen-1);
        pwzFile[ucbLen-1] = L'\0';
    }
    else
        hr = S_FALSE;

    ASSERT(hr == S_OK ||
            hr == S_FALSE);

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Dirty(BOOL bDirty)
{
    HRESULT hr=S_OK;

    if (bDirty)
    {
        SET_FLAG(m_dwFlags, FUSSHCUT_FL_DIRTY);
        //m_dwFlags = FUSSHCUT_FL_DIRTY;
    }
    else
    {
        CLEAR_FLAG(m_dwFlags, FUSSHCUT_FL_DIRTY);
        //m_dwFlags = FUSSHCUT_FL_NOTDIRTY;
    }

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetClassID(CLSID* pclsid)
{
    HRESULT hr=S_OK;

    if (pclsid == NULL)
        hr = E_INVALIDARG;
    else
        *pclsid = CLSID_FusionShortcut;

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::IsDirty(void)
{
    HRESULT hr;

    if (IS_FLAG_SET(m_dwFlags, FUSSHCUT_FL_DIRTY))
    //if (m_dwFlags == FUSSHCUT_FL_DIRTY)
        // modified
        hr = S_OK;
    else
        // not modified
        hr = S_FALSE;

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Save(LPCOLESTR pcwszFile,
                                                 BOOL bRemember)
{
    // BUGBUG: no save for now!
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SaveCompleted(LPCOLESTR pcwszFile)
{
    // BUGBUG: no save for now!
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Load(LPCOLESTR pcwszFile,
                                                 DWORD dwMode)
{
    HRESULT hr = S_OK;
    LPWSTR pwzWorkingDir = NULL;
    LPWSTR pwzValue = NULL;
    DWORD dwCC = 0, dwCB = 0, dwFlag = 0;
    LPASSEMBLY_MANIFEST_IMPORT    pManImport = NULL;
    LPASSEMBLY_CACHE_IMPORT   pCacheImport = NULL;
    IManifestInfo *pAppInfo = NULL;
    IManifestInfo *pDependAsmInfo = NULL;

    // FEATURE: Validate dwMode here.
    // FEAUTRE: Implement dwMode flag support.

    if (!pcwszFile)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // a hack check
    // BUGBUG?: this shouldn't be called more than once?
    // BUT: the rest of this code works even if called multiple times
    if (m_pwzWorkingDirectory)
    {
        hr = E_FAIL;
        goto exit;
    }

    // store the shortcut file name
    if (m_pwzShortcutFile)
        delete [] m_pwzShortcutFile;

    // (+ 1) for null terminator.
    m_pwzShortcutFile = new(WCHAR[wcslen(pcwszFile) + 1]);
    if (m_pwzShortcutFile)
    {
        wcscpy(m_pwzShortcutFile, pcwszFile);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (FAILED(hr = CreateAssemblyManifestImport(&pManImport, m_pwzShortcutFile, NULL, 0)))
        goto exit;

    // check this 1st for pref...
    if (FAILED(hr=pManImport->GetManifestApplicationInfo(&pAppInfo)))
        goto exit;

    // can't continue without this...
    if (hr==S_FALSE)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (m_pIdentity)
        m_pIdentity->Release();

    if (FAILED(hr = pManImport->GetAssemblyIdentity(&m_pIdentity)))
        goto exit;

    // can't continue without a cache dir, 'cos otherwise unknown behavior
    // BUGBUG: should check/code to ensure some continue to work
    //    even without the complete name, eg. shell icon path, part of infotip
    if (FAILED(hr = CreateAssemblyCacheImport(&pCacheImport, m_pIdentity, CACHEIMP_CREATE_RESOLVE_REF_EX)))
        goto exit;

    pCacheImport->GetManifestFileDir(&pwzWorkingDir, &dwCC);
    if (dwCC < 2)
    {
        // this should never happen
        hr = E_UNEXPECTED;
        goto exit;
    }
    // remove last L'\\'
    *(pwzWorkingDir+dwCC-2) = L'\0';

    if (FAILED(hr=SetWorkingDirectory(pwzWorkingDir)))
        goto exit;

    // ignore failure
    pAppInfo->Get(MAN_INFO_APPLICATION_SHOWCOMMAND, (LPVOID *)&pwzValue, &dwCB, &dwFlag);
    if (pwzValue != NULL)
    {
        // default is normal
        int nShowCmd = SW_SHOWNORMAL;

        if (!_wcsicmp(pwzValue, L"maximized"))
        {
            nShowCmd = SW_SHOWMAXIMIZED;
        }
        else if (!_wcsicmp(pwzValue, L"minimized"))
        {
            nShowCmd = SW_SHOWMINIMIZED;
        }

        if (FAILED(hr=SetShowCmd(nShowCmd)))
            goto exit;

        delete [] pwzValue;
    }

    // ignore failure
    pAppInfo->Get(MAN_INFO_APPLICATION_ENTRYPOINT, (LPVOID *)&pwzValue, &dwCB, &dwFlag);
    if (pwzValue != NULL)
    {
        size_t ccWorkingDir = wcslen(pwzWorkingDir)+1;
        size_t ccEntryPoint = wcslen(pwzValue)+1;
        LPWSTR pwzTemp = new WCHAR[ccWorkingDir+ccEntryPoint];    // 2 strings + '\\' + '\0'

        // like .lnk or .url, entry point is under wzWorkingDir
        // 'path' is the target file of the shortcut, ie. the entry point of the app in this case

        if (pwzTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        memcpy(pwzTemp, pwzWorkingDir, ccWorkingDir * sizeof(WCHAR));
        if (!PathAppend(pwzTemp, pwzValue))
            hr = E_FAIL;
        else
            hr=SetPath(pwzTemp);

        delete [] pwzTemp;
        if (FAILED(hr))
            goto exit;

        delete [] pwzValue;
    }
    //else
    // ... if no entry point leave it blank so that the default icon will be used

    // ignore failure
    pAppInfo->Get(MAN_INFO_APPLICATION_FRIENDLYNAME, (LPVOID *)&pwzValue, &dwCB, &dwFlag);
    if (pwzValue != NULL)
    {
        if (FAILED(hr=SetDescription(pwzValue)))
            goto exit;

        delete [] pwzValue;
    }

    // ignore failure
    pAppInfo->Get(MAN_INFO_APPLICATION_ICONFILE, (LPVOID *)&pwzValue, &dwCB, &dwFlag);
    if (pwzValue != NULL)
    {
        LPWSTR pwzValue2 = NULL;

        pAppInfo->Get(MAN_INFO_APPLICATION_ICONINDEX, (LPVOID *)&pwzValue2, &dwCB, &dwFlag);
        if (pwzValue2 != NULL)
        {
            LPWSTR pwzStopString = NULL;
            hr=SetIconLocation(pwzValue, (int) wcstol(pwzValue2, &pwzStopString, 10));
            delete [] pwzValue2;
            if (FAILED(hr))
                goto exit;
        }

        delete [] pwzValue;
    }

    // ignore failure
    pAppInfo->Get(MAN_INFO_APPLICATION_HOTKEY, (LPVOID *)&pwzValue, &dwCB, &dwFlag);
    if (pwzValue != NULL)
    {
        LPWSTR pwzStopString = NULL;
        if (FAILED(hr=SetHotkey((WORD) wcstol(pwzValue, &pwzStopString, 10))))
            goto exit;

        delete [] pwzValue;
    }

    // note: this method of getting the codebase is only valid for desktop (and subscription) manifests
    //    thus the hardcoded index '0'
    // ignore failure
    pManImport->GetNextAssembly(0, &pDependAsmInfo);
    if (pDependAsmInfo != NULL)
    {
        pDependAsmInfo->Get(MAN_INFO_DEPENDENT_ASM_CODEBASE, (LPVOID *)&pwzValue, &dwCB, &dwFlag);
        if (pwzValue != NULL)
        {
            if (FAILED(hr=SetCodebase(pwzValue)))
                goto exit;

            delete [] pwzValue;
        }
    }

    pwzValue = NULL;

exit:
    if (pwzValue != NULL)
        delete [] pwzValue;

    if (pwzWorkingDir != NULL)
        delete [] pwzWorkingDir;

    if (pDependAsmInfo != NULL)
        pDependAsmInfo->Release();
    
    if (pAppInfo != NULL)
        pAppInfo->Release();

    if (pCacheImport != NULL)
        pCacheImport->Release();

    if (pManImport != NULL)
        pManImport->Release();

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetCurFile(LPOLESTR *ppwszFile)
{
    HRESULT hr = S_OK;
    LPOLESTR pwszTempFile;

    if (ppwszFile == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    // BUGBUG?: ensure *ppwszFile NULL?

    if (m_pwzShortcutFile)
    {
        pwszTempFile = m_pwzShortcutFile;
    }
    else
    {
        pwszTempFile = (LPWSTR) g_cwzDefaultFileNamePrompt;

        hr = S_FALSE;
    }

    *ppwszFile = (LPOLESTR) CoTaskMemAlloc((wcslen(pwszTempFile) + 1) * sizeof(*pwszTempFile));

    if (*ppwszFile)
        wcscpy(*ppwszFile, pwszTempFile);
    else
        hr = E_OUTOFMEMORY;

exit:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\refcount.cpp ===
/*
 * refcount.cpp - RefCount class implementation.
 */


/* Headers
 **********/

#include "project.hpp" // for ULONG_MAX...
#include "refcount.hpp"

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

/********************************** Methods **********************************/


RefCount::RefCount(void)
{
	// Don't validate this until after initialization.

	m_ulcRef = 1;
	DllAddRef();

	return;
}


RefCount::~RefCount(void)
{
	// m_ulcRef may be any value.

	DllRelease();

	return;
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ULONG ulRet = 0;

	// this is really bad... returns an error of some kind
	if(m_ulcRef >= ULONG_MAX)
	{
		ulRet = 0;
		goto exit;
	}

	m_ulcRef++;

	ulRet = m_ulcRef;
exit:
	return(ulRet);
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ULONG ulcRef;

	if (m_ulcRef > 0)
		m_ulcRef--;

	ulcRef = m_ulcRef;

	if (! ulcRef)
		delete this;

	return(ulcRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\propsht.cpp ===
/*
 * propsht.cpp - IPropSheetExt implementation for CFusionShortcut class.
 */



// * NOTE!!: this code is incomplete. Also error checking (any leak?),
// *        restructuring (for better coding/efficiency) to be done.
// *        Make 'Get'/'Set' private and use 'friend'?


//BUGBUG: need wrappers around calls to m_pIdentity->SetAttribute() to also call Dirty(TRUE)...


// * this file uses CharNext etc as it needs User32 anyway *

/* Headers
 **********/

#include "project.hpp"

#include <prsht.h>

#include "shellres.h"

extern "C" WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPWSTR pwzIconPath, UINT cbIconPath, int *piIconIndex);

extern HINSTANCE g_DllInstance;

/* Types
 ********/

// Fusion Shortcut property sheet data

typedef enum _fusshcutpropsheetpgs
{
    FUSIONSHCUT_PS_SHCUT_PAGE   = 0x0000,
    FUSIONSHCUT_PS_REF_PAGE        = 0x0001,

    ALL_FUSIONSHCUT_PS_PAGES
}
FUSIONSHCUTPSPAGES;

typedef struct _fsps
{
    CFusionShortcut* pfusshcut;

    WCHAR rgchIconFile[MAX_PATH];

    int niIcon;

    FUSIONSHCUTPSPAGES eCurPage;
}
FSPS;
DECLARE_STANDARD_TYPES(FSPS);

typedef FSPS* PFSPS;

/* Module Constants
 *******************/

// Tray notification window class

//copied from shell32!
#define WNDCLASS_TRAYNOTIFY     L"Shell_TrayWnd"    //internal_win40
const WCHAR s_cwzTrayNotificationClass[]  = WNDCLASS_TRAYNOTIFY;

// HACKHACK: WMTRAY_SCREGISTERHOTKEY and WMTRAY_SCUNREGISTERHOTKEY are stolen
// from shelldll\link.c.
typedef const UINT CUINT;
CUINT WMTRAY_SCREGISTERHOTKEY           = (WM_USER + 233);
CUINT WMTRAY_SCUNREGISTERHOTKEY      = (WM_USER + 234);

// show commands - N.b., the order of these constants must match the order of
// the corresponding IDS_ string table constants.

const UINT s_ucMaxShowCmdLen            = MAX_PATH;
const UINT s_ucMaxTypeLen                   = TYPESTRINGLENGTH;

const int s_rgnShowCmds[] =
{
    SW_SHOWNORMAL,
    SW_SHOWMINNOACTIVE,
    SW_SHOWMAXIMIZED
};


/*
** ExtractFileName()
**
** Extracts the file name from a path name.
**
** Arguments:     pcwzPathName - path string from which to extract file name
**
** Returns:       Pointer to file name in path string.
**
** Side Effects:  none
*/
#define BACKSLASH   L'/'
#define SLASH           L'\\'
#define COLON           L':'
#define IS_SLASH(ch)	((ch) == SLASH || (ch) == BACKSLASH)
PCWSTR ExtractFileName(PCWSTR pcwzPathName)
{
    PCWSTR pcwzLastComponent;
    PCWSTR pcwz;

    for (pcwzLastComponent = pcwz = pcwzPathName; *pcwz; pcwz = CharNext(pcwz))
    {
        if (IS_SLASH(*pcwz) || *pcwz == COLON)
            pcwzLastComponent = CharNext(pcwz);
    }

    ASSERT(IsValidPath(pcwzLastComponent));

    return(pcwzLastComponent);
}

/***************************** Private Functions *****************************/


UINT CALLBACK FSPSCallback(HWND hwnd, UINT uMsg,
                    LPPROPSHEETPAGE ppsp)
{
    // this is called after FSPS_DlgProc WM_DESTROY (ie. FSPS_Destroy)
    // this func should do the frees/releases

    UINT uResult = TRUE;
    PFSPS pfsps = (PFSPS)(ppsp->lParam);

    // uMsg may be any value.

    ASSERT(! hwnd ||
        IS_VALID_HANDLE(hwnd, WND));

    switch (uMsg)
    {
        case PSPCB_CREATE:
            // from MSDN: A dialog box for a page is being created.
            // Return nonzero to allow it to be created, or zero to prevent it.
            break;

        case PSPCB_RELEASE:
            // ???? need checking if NULL

            pfsps->pfusshcut->Release();

            // free the FSPS structure, this is created in AddFSPS
            // delete only after the ref is removed
            delete pfsps;
            ppsp->lParam = NULL;

            break;

        default:
            // ignore other msg - unhandled
            break;
    }

    return(uResult);
}


void SetFSPSIcon(HWND hdlg, HICON hicon)
{
    HICON hiconOld;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    ASSERT(IS_VALID_HANDLE(hicon, ICON));

    hiconOld = (HICON)SendDlgItemMessage(hdlg, IDD_ICON, STM_SETICON,
        (WPARAM)hicon, 0);

    if (hiconOld)
        DestroyIcon(hiconOld);

    return;
}


void SetFSPSFileNameAndIcon(HWND hdlg)
{
    HRESULT hr;
    CFusionShortcut* pfusshcut;
    WCHAR rgchFile[MAX_PATH];

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    hr = pfusshcut->GetCurFile(rgchFile, sizeof(rgchFile) / sizeof(WCHAR));

    if (hr == S_OK)
    {
        SHFILEINFO shfi;
        DWORD_PTR dwResult;

        dwResult = SHGetFileInfo(rgchFile, 0, &shfi, sizeof(shfi),
            (SHGFI_DISPLAYNAME | SHGFI_ICON));

        if (dwResult)
        {
            LPWSTR pwzFileName;

            pwzFileName = (LPWSTR)ExtractFileName(shfi.szDisplayName);

            EVAL(SetDlgItemText(hdlg, IDD_NAME, pwzFileName));

            SetFSPSIcon(hdlg, shfi.hIcon);
        }
        else
        {
            hr = E_FAIL;
        }
    }


    if (hr != S_OK)
        EVAL(SetDlgItemText(hdlg, IDD_NAME, g_cwzEmptyString));

    return;
}


void SetFSPSWorkingDirectory(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    WCHAR rgchWorkingDirectory[MAX_PATH];

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    hr = pfusshcut->GetWorkingDirectory(rgchWorkingDirectory,
            sizeof(rgchWorkingDirectory) / sizeof(WCHAR));

    if (hr == S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_START_IN, rgchWorkingDirectory));
    }
    else
    {
        EVAL(SetDlgItemText(hdlg, IDD_START_IN, g_cwzEmptyString));
    }

    return;
}


void InitFSPSHotkey(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    WORD wHotkey;
    HRESULT hr;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    // Set hotkey combinations.

    SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETRULES,
        (HKCOMB_NONE | HKCOMB_A | HKCOMB_C | HKCOMB_S),
        (HOTKEYF_CONTROL | HOTKEYF_ALT));

    // Set current hotkey.

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    hr = pfusshcut->GetHotkey(&wHotkey);
    SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

    return;
}


void InitFSPSShowCmds(HWND hdlg)
{
    int niShowCmd;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    for (niShowCmd = IDS_SHOW_NORMAL;
        niShowCmd <= IDS_SHOW_MAXIMIZED;
        niShowCmd++)
    {
        WCHAR rgchShowCmd[s_ucMaxShowCmdLen];

        if (LoadString(g_DllInstance, niShowCmd, rgchShowCmd,   //MLLoadStringA
            s_ucMaxShowCmdLen))//sizeof(rgchShowCmd)))
        {
            SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_ADDSTRING, 0,
                (LPARAM)rgchShowCmd);
        }
    }

    return;
}


void SetFSPSShowCmd(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    int nShowCmd;
    int i;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    pfusshcut->GetShowCmd(&nShowCmd);

    for (i = 0; i < ARRAY_ELEMENTS(s_rgnShowCmds); i++)
    {
        if (s_rgnShowCmds[i] == nShowCmd)
            break;
    }

    if (i >= ARRAY_ELEMENTS(s_rgnShowCmds))
    {
        ASSERT(i == ARRAY_ELEMENTS(s_rgnShowCmds));

        i = 0; // default is 0 == 'normal'
    }

    SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_SETCURSEL, i, 0);

    return;
}


void SetFSPSFriendlyName(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    WCHAR rgchString[DISPLAYNAMESTRINGLENGTH];

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    hr = pfusshcut->GetDescription(rgchString, sizeof(rgchString) / sizeof(WCHAR));

    if (hr == S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_DISPLAY_NAME, rgchString));
    }
    else
    {
        EVAL(SetDlgItemText(hdlg, IDD_DISPLAY_NAME, g_cwzEmptyString));
    }

    return;
}


void SetFSPSName(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    DWORD ccString = 0;
    LPWSTR pwzString = NULL;
    LPASSEMBLY_IDENTITY pId = NULL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
    {
        hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzString, &ccString);

        if (hr == S_OK)
        {
            EVAL(SetDlgItemText(hdlg, IDD_NAME, pwzString));
            delete [] pwzString;
        }

        pId->Release();
    }

    if (hr != S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_NAME, g_cwzEmptyString));
    }

    return;
}


void SetFSPSVersion(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    DWORD ccString = 0;
    LPWSTR pwzString = NULL;
    LPASSEMBLY_IDENTITY pId = NULL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
    {
        hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzString, &ccString);

        if (hr == S_OK)
        {
            EVAL(SetDlgItemText(hdlg, IDD_VERSION, pwzString));
            delete [] pwzString;
        }

        pId->Release();
    }

    if (hr != S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_VERSION, g_cwzEmptyString));
    }

    return;
}


void SetFSPSCulture(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    DWORD ccString = 0;
    LPWSTR pwzString = NULL;
    LPASSEMBLY_IDENTITY pId = NULL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
    {
        hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzString, &ccString);

        if (hr == S_OK)
        {
            EVAL(SetDlgItemText(hdlg, IDD_CULTURE, pwzString));
            delete [] pwzString;
        }

        pId->Release();
    }

    if (hr != S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_CULTURE, g_cwzEmptyString));
    }

    return;
}


void SetFSPSPKT(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    DWORD ccString = 0;
    LPWSTR pwzString = NULL;
    LPASSEMBLY_IDENTITY pId = NULL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
    {
        hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzString, &ccString);

        if (hr == S_OK)
        {
            EVAL(SetDlgItemText(hdlg, IDD_PKT, pwzString));
            delete [] pwzString;
        }

        pId->Release();
    }

    if (hr != S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_PKT, g_cwzEmptyString));
    }

    return;
}


void SetFSPSCodebase(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    WCHAR rgchString[MAX_URL_LENGTH];

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    hr = pfusshcut->GetCodebase(rgchString, sizeof(rgchString) / sizeof(WCHAR));

    if (hr == S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_CODEBASE, rgchString));
    }
    else
    {
        EVAL(SetDlgItemText(hdlg, IDD_CODEBASE, g_cwzEmptyString));
    }

    return;
}


void SetFSPSEntrypoint(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    WCHAR rgchString[MAX_PATH];

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    hr = pfusshcut->GetPath(rgchString, sizeof(rgchString) / sizeof(WCHAR), NULL, 0);

    if (hr == S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_ENTRYPOINT, rgchString));
    }
    else
    {
        EVAL(SetDlgItemText(hdlg, IDD_ENTRYPOINT, g_cwzEmptyString));
    }

    return;
}


void SetFSPSType(HWND hdlg)
{
    CFusionShortcut* pfusshcut;
    HRESULT hr;
    DWORD ccString = 0;
    LPWSTR pwzString = NULL;
    LPASSEMBLY_IDENTITY pId = NULL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
    {
        hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE, &pwzString, &ccString);

        if (hr == S_OK)
        {
            EVAL(SetDlgItemText(hdlg, IDD_TYPE, pwzString));
            delete [] pwzString;
        }

        pId->Release();
    }

    if (hr != S_OK)
    {
        EVAL(SetDlgItemText(hdlg, IDD_TYPE, g_cwzEmptyString));
    }

    return;
}


BOOL FSPS_InitDialog(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
    // wparam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    // this set PROPSHEETPAGE struct to DWLP_USER
    SetWindowLongPtr(hdlg, DWLP_USER, lparam);

    // Initialize control contents.

    if (((PFSPS)(((PROPSHEETPAGE*)lparam)->lParam))->eCurPage == FUSIONSHCUT_PS_SHCUT_PAGE)
    {
        SetFSPSFileNameAndIcon(hdlg);

        // note: need limits on all editbox!
        SetFSPSFriendlyName(hdlg);

        SendDlgItemMessage(hdlg, IDD_CODEBASE, EM_LIMITTEXT, MAX_URL_LENGTH - 1, 0);
        SetFSPSCodebase(hdlg);

        //InitFSPSType(hdlg);
        SetFSPSType(hdlg);

        SendDlgItemMessage(hdlg, IDD_ENTRYPOINT, EM_LIMITTEXT, MAX_PATH - 1, 0);
        SetFSPSEntrypoint(hdlg);

        SendDlgItemMessage(hdlg, IDD_START_IN, EM_LIMITTEXT, MAX_PATH - 1, 0);
        SetFSPSWorkingDirectory(hdlg);

        InitFSPSHotkey(hdlg);

        InitFSPSShowCmds(hdlg);
        SetFSPSShowCmd(hdlg);
    }
    else if (((PFSPS)(((PROPSHEETPAGE*)lparam)->lParam))->eCurPage == FUSIONSHCUT_PS_REF_PAGE)
    {
        // note: need limits on all editbox!
        SetFSPSFriendlyName(hdlg);
        SetFSPSName(hdlg);
        SetFSPSVersion(hdlg);
        SetFSPSCulture(hdlg);
        SetFSPSPKT(hdlg);
    }
    // else do nothing?

    return(TRUE);
}


BOOL FSPS_Destroy(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
    // FSPSCallback is called after this func. The remaining frees/releases are there

    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    SetWindowLongPtr(hdlg, DWLP_USER, NULL);

    return(TRUE);
}


void FSPSChanged(HWND hdlg)
{
    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    PropSheet_Changed(GetParent(hdlg), hdlg);

    return;
}


HRESULT ChooseIcon(HWND hdlg)
{
    HRESULT hr;
    PFSPS pfsps;
    CFusionShortcut* pfusshcut;
    WCHAR rgchTempIconFile[MAX_PATH];
    int niIcon;
    UINT uFlags;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfsps = (PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
    pfusshcut = pfsps->pfusshcut;

    if (pfusshcut->GetIconLocation(0, rgchTempIconFile,
            sizeof(rgchTempIconFile)/sizeof(WCHAR), &niIcon, &uFlags) != S_OK)
    {
        rgchTempIconFile[0] = '\0';
        niIcon = 0;
    }

    ASSERT(wcslen(rgchTempIconFile) < (sizeof(rgchTempIconFile)/sizeof(WCHAR)));

    // a private shell32.dll export (by ordinal)...
    if (PickIconDlg(hdlg, rgchTempIconFile, sizeof(rgchTempIconFile)/sizeof(WCHAR), &niIcon))   //??? sizeof
    {
        ASSERT(wcslen(rgchTempIconFile) < (sizeof(pfsps->rgchIconFile)/sizeof(WCHAR)));
        wcscpy(pfsps->rgchIconFile, rgchTempIconFile);
        pfsps->niIcon = niIcon;

        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return(hr);
}


void UpdateFSPSIcon(HWND hdlg)
{
    PFSPS pfsps;
    HICON hicon;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfsps = (PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
    ASSERT(pfsps->rgchIconFile[0]);

    hicon = ExtractIcon(g_DllInstance, pfsps->rgchIconFile, pfsps->niIcon);

    if (hicon)
        SetFSPSIcon(hdlg, hicon);

    return;
}


BOOL FSPS_Command(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
    BOOL bMsgHandled = FALSE;
    WORD wCmd;

    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    wCmd = HIWORD(wparam);

    switch (LOWORD(wparam))
    {
        case IDD_CODEBASE:
        case IDD_HOTKEY:
        case IDD_ENTRYPOINT:
        case IDD_START_IN:
        case IDD_DISPLAY_NAME:
        case IDD_NAME:
        case IDD_VERSION:
        case IDD_CULTURE:
        case IDD_PKT:
        case IDD_TYPE:
                if (wCmd == EN_CHANGE)
                {
                        FSPSChanged(hdlg);

                        bMsgHandled = TRUE;
                }
                break;

        case IDD_SHOW_CMD:
                if (wCmd == LBN_SELCHANGE)
                {
                    FSPSChanged(hdlg);

                    bMsgHandled = TRUE;
                }
                break;

        case IDD_CHANGE_ICON:
                // Ignore return value.
                if (ChooseIcon(hdlg) == S_OK)
                {
                    UpdateFSPSIcon(hdlg);
                    FSPSChanged(hdlg);
                }
                bMsgHandled = TRUE;
                break;

        default:
                break;
    }

    return(bMsgHandled);
}


HRESULT InjectFSPSData(HWND hdlg)
{
    // BUGBUG: TODO: this function should validate the user's changes...

    HRESULT hr = S_OK;
    PFSPS pfsps;
    CFusionShortcut* pfusshcut;
    LPWSTR pwzURL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfsps = (PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
    pfusshcut = pfsps->pfusshcut;

    return(hr);
}


HRESULT FSPSSave(HWND hdlg)
{
    HRESULT hr;
    CFusionShortcut* pfusshcut;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

    if (pfusshcut->IsDirty() == S_OK)
    {
        // BUGBUG: TODO: IPersistFile::Save is not implemented
        hr = pfusshcut->Save((LPCOLESTR)NULL, FALSE);
    }
    else
    {
        hr = S_OK;
    }

    return(hr);
}


BOOL FSPS_Notify(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
    BOOL bMsgHandled = FALSE;

    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    switch (((NMHDR*)lparam)->code)
    {
        case PSN_APPLY:
            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FSPSSave(hdlg) == S_OK ?
                            PSNRET_NOERROR :
                            PSNRET_INVALID_NOCHANGEPAGE);
            bMsgHandled = TRUE;
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FAILED(InjectFSPSData(hdlg)));
            bMsgHandled = TRUE;
            break;

        default:
            break;
    }

    return(bMsgHandled);
}


INT_PTR CALLBACK FSPS_DlgProc(HWND hdlg, UINT uMsg, WPARAM wparam,
                    LPARAM lparam)
{
    INT_PTR bMsgHandled = FALSE;

    // uMsg may be any value.
    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            bMsgHandled = FSPS_InitDialog(hdlg, wparam, lparam);
            break;

        case WM_DESTROY:
            bMsgHandled = FSPS_Destroy(hdlg, wparam, lparam);
            break;

        case WM_COMMAND:
            bMsgHandled = FSPS_Command(hdlg, wparam, lparam);
            break;

        case WM_NOTIFY:
            bMsgHandled = FSPS_Notify(hdlg, wparam, lparam);
            break;

        default:
            break;
    }

    return(bMsgHandled);
}


HRESULT AddFSPS(CFusionShortcut* pfusshcut,
                 LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam)
{
    HRESULT hr = S_OK;
    PFSPS pfsps;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpsp;

    PFSPS pfsps2;
    PROPSHEETPAGE psp2;
    HPROPSHEETPAGE hpsp2;

    // lparam may be any value.

    // this is deleted in FSPSCallback
    pfsps = new FSPS;
    if (pfsps == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    ZeroMemory(pfsps, sizeof(*pfsps));

    psp.dwSize = sizeof(psp);
    psp.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
    psp.hInstance = g_DllInstance; //MLGetHinst();
    psp.pszTemplate = MAKEINTRESOURCE(DLG_FUS_SHORTCUT_PROP_SHEET);
    psp.pfnDlgProc = &FSPS_DlgProc;
    psp.pfnCallback = &FSPSCallback;
    psp.lParam = (LPARAM)pfsps;
    psp.hIcon = 0;            // not used
    psp.pszTitle = NULL;    // not used
    psp.pcRefParent = 0;   // not used

    pfsps->pfusshcut = pfusshcut;
    pfsps->eCurPage = FUSIONSHCUT_PS_SHCUT_PAGE; // page 1

    // will psp be copied in this func? else this won't work...!!??
    hpsp = CreatePropertySheetPage(&psp);

    if (hpsp)
    {
        if ((*pfnAddPage)(hpsp, lparam))
        {
            pfusshcut->AddRef();
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
            goto exit;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // this is deleted in FSPSCallback
    pfsps2 = new FSPS;
    if (pfsps2 == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    ZeroMemory(pfsps2, sizeof(*pfsps2));

    psp2.dwSize = sizeof(psp2);
    psp2.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
    psp2.hInstance = g_DllInstance; //MLGetHinst();
    psp2.pszTemplate = MAKEINTRESOURCE(DLG_FUS_SHORTCUT_PROP_SHEET_APPNAME);
    psp2.pfnDlgProc = &FSPS_DlgProc;
    psp2.pfnCallback = &FSPSCallback;
    psp2.lParam = (LPARAM)pfsps2;
    psp2.hIcon = 0;            // not used
    psp2.pszTitle = NULL;    // not used
    psp2.pcRefParent = 0;   // not used

    pfsps2->pfusshcut = pfusshcut;
    pfsps2->eCurPage = FUSIONSHCUT_PS_REF_PAGE; // page 2

    // will psp be copied in this func? else this won't work...!!??
    hpsp2 = CreatePropertySheetPage(&psp2);

    if (hpsp2)
    {
        if ((*pfnAddPage)(hpsp2, lparam))
        {
            pfusshcut->AddRef();
        }
        else
        {
            DestroyPropertySheetPage(hpsp2);
            hr = E_FAIL;
            goto exit;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    return(hr);
}


/****************************** Public Functions *****************************/


BOOL RegisterGlobalHotkey(WORD wOldHotkey, WORD wNewHotkey,
                      LPCWSTR pcwzPath)
{
    // BUGBUG?: does this work??

    BOOL bResult = FALSE;
    HWND hwndTray;

    ASSERT(! wOldHotkey || IsValidHotkey(wOldHotkey));
    ASSERT(! wNewHotkey || IsValidHotkey(wNewHotkey));
    ASSERT(IsValidPath(pcwzPath));

    hwndTray = FindWindow(s_cwzTrayNotificationClass, 0);

    if (hwndTray)
    {
        if (wOldHotkey)
        {
            SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wOldHotkey, 0);
        }

        if (wNewHotkey)
        {
            ATOM atom = GlobalAddAtom(pcwzPath);
            ASSERT(atom);
            if (atom)
            {
                SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey, (LPARAM)atom);
                GlobalDeleteAtom(atom);
            }
        }

        bResult = TRUE;
    }
    /*else
    {
        bResult = FALSE;
    }*/

    return(bResult);
}

/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CFusionShortcut::Initialize(LPCITEMIDLIST pcidlFolder,
                              IDataObject* pido,
                              HKEY hkeyProgID)
{
    HRESULT hr;
    STGMEDIUM stgmed;
    FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    ASSERT(NULL != pido);
    ASSERT(IS_VALID_HANDLE(hkeyProgID, KEY));

    hr = pido->GetData(&fmtetc, &stgmed);
    if (hr == S_OK)
    {
        WCHAR wzPath[MAX_PATH];
        if (DragQueryFile((HDROP)stgmed.hGlobal, 0, wzPath, sizeof(wzPath)/sizeof(*wzPath)))
        {
            //mode is ignored for now
            hr = Load(wzPath, 0);
        }
        // else path len > MAX_PATH or other error

        ReleaseStgMedium(&stgmed);
    }

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage,
                         LPARAM lparam)
{
    HRESULT hr;

    // lparam may be any value.

    hr = AddFSPS(this, pfnAddPage, lparam);

    // BUGBUG: why this does not work?
    // From MSDN:
    //With version 4.71 and later, you can request that a particular property
    //sheet page be displayed first, instead of the default page. To do so,
    //return the one-based index of the desired page. For example, if you
    //want the second of three pages displayed, the return value should be 2.
    //Note that this return value is a request. The property sheet may still
    //display the default page. --> see doc for AddPages()
    if (SUCCEEDED(hr))
        hr = HRESULT(4); // or 3??

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::ReplacePage(UINT uPageID,
                      LPFNADDPROPSHEETPAGE pfnReplaceWith,
                      LPARAM lparam)
{
    HRESULT hr;

    // lparam may be any value.
    // uPageID may be any value.

    hr = E_NOTIMPL;

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetCodebase(LPCWSTR pcwzCodebase)
{
    HRESULT hr = S_OK;
    BOOL bDifferent;
    LPWSTR pwzNewCodebase = NULL;

    // Set m_pwzCodebase to codebase.

    // check if empty string?

    bDifferent = ! ((! pcwzCodebase && ! m_pwzCodebase) ||
                (pcwzCodebase && m_pwzCodebase &&
                ! wcscmp(pcwzCodebase, m_pwzCodebase)));

    if (bDifferent && pcwzCodebase)
    {
        // (+ 1) for null terminator.

        pwzNewCodebase = new(WCHAR[wcslen(pcwzCodebase) + 1]);

        if (pwzNewCodebase)
            wcscpy(pwzNewCodebase, pcwzCodebase);
        else
            hr = E_OUTOFMEMORY;
    }

    if (hr == S_OK && bDifferent)
    {
        if (m_pwzCodebase)
            delete [] m_pwzCodebase;

        m_pwzCodebase = pwzNewCodebase;

        Dirty(TRUE);
    }

    return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetCodebase(LPWSTR pwzCodebase,
                                                      int ncBufLen)
{
    HRESULT hr = S_OK;

    // Get description from m_pwzCodebase.

    if (m_pwzCodebase)
    {
        if (pwzCodebase == NULL || ncBufLen <= 0)
            hr = E_INVALIDARG;
        else
        {
            wcsncpy(pwzCodebase, m_pwzCodebase, ncBufLen-1);
            pwzCodebase[ncBufLen-1] = L'\0';
        }
    }
    else
    {
        if (ncBufLen > 0 && pwzCodebase != NULL)
            pwzCodebase = L'\0';
    }

    ASSERT(hr == S_OK &&
        (ncBufLen <= 0 ||
        EVAL(wcslen(pwzCodebase) < ncBufLen)));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\shcut.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "shcut.h"

// {b95ec110-5c3e-433c-b969-701c10521ef2}
static const GUID CLSID_FusionShortcut = 
{ 0xb95ec110, 0x5c3e, 0x433c, { 0xb9, 0x69, 0x70, 0x1c, 0x10, 0x52, 0x1e, 0xf2 } };

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CFusionShortcutClassFactory::CFusionShortcutClassFactory()
{
	_cRef = 1;
}

// ----------------------------------------------------------------------------

HRESULT
CFusionShortcutClassFactory::QueryInterface(REFIID iid, void **ppv)
{
	HRESULT hr = S_OK;

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return hr;
}

// ----------------------------------------------------------------------------

ULONG
CFusionShortcutClassFactory::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CFusionShortcutClassFactory::Release()
{
	LONG ulCount = InterlockedDecrement(&_cRef);

	if (ulCount <= 0)
	{
		delete this;
	}

    return (ULONG) ulCount;
}

HRESULT
CFusionShortcutClassFactory::LockServer(BOOL lock)
{
    return (lock ? 
            DllAddRef() :
            DllRelease());
}

// ----------------------------------------------------------------------------

HRESULT
CFusionShortcutClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;
    CFusionShortcut *pFusionShortcut = NULL;

	*ppv = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
    {
    	hr = CLASS_E_NOAGGREGATION;
    	goto exit;
    }

    pFusionShortcut = new CFusionShortcut();
    if (pFusionShortcut == NULL)
    {
    	hr = E_OUTOFMEMORY;
    	goto exit;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = (IShellLink *)pFusionShortcut;
        pFusionShortcut->AddRef();
    }
    else
    {
        hr = pFusionShortcut->QueryInterface(iid, ppv);
        if (FAILED(hr))
        	goto exit;
    }

exit:
    if (pFusionShortcut)
        pFusionShortcut->Release();

    return hr;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CFusionShortcut::CFusionShortcut()
	: RefCount()
{
	// Don't validate this until after construction.

	m_dwFlags = FUSSHCUT_FL_NOTDIRTY;
	m_pwzShortcutFile = NULL;
	m_pwzPath = NULL;
	m_pwzDesc = NULL;
	m_pwzIconFile = NULL;
	m_niIcon = 0;
	m_pwzWorkingDirectory = NULL;
	m_nShowCmd = DEFAULTSHOWCMD;
	m_wHotkey = 0;
	m_pwzCodebase = NULL;

	m_pIdentity = NULL;

	return;
}

CFusionShortcut::~CFusionShortcut(void)
{
	if (m_pwzShortcutFile)
	{
		delete [] m_pwzShortcutFile;
		m_pwzShortcutFile = NULL;
	}

	if (m_pwzPath)
	{
		delete [] m_pwzPath;
		m_pwzPath = NULL;
	}

	if (m_pwzDesc)
	{
		delete [] m_pwzDesc;
		m_pwzDesc = NULL;
	}

	if (m_pwzIconFile)
	{
		delete [] m_pwzIconFile;
		m_pwzIconFile = NULL;
		m_niIcon = 0;
	}

	if (m_pwzWorkingDirectory)
	{
		delete [] m_pwzWorkingDirectory;
		m_pwzWorkingDirectory = NULL;
	}

	if (m_pwzCodebase)
	{
		delete [] m_pwzCodebase;
		m_pwzCodebase = NULL;
	}

	if (m_pIdentity)
	{
		m_pIdentity->Release();
	}

	RefCount::~RefCount();

	return;
}


HRESULT CFusionShortcut::GetAssemblyIdentity(LPASSEMBLY_IDENTITY* ppAsmId)
{
	HRESULT hr = S_OK;
	
	if (ppAsmId == NULL)
	{
		hr = E_INVALIDARG;
		goto exit;
	}

	if (m_pIdentity)
	{
		m_pIdentity->AddRef();
 		*ppAsmId = m_pIdentity;
	}
	else
 		*ppAsmId = NULL;

exit:
 	return hr;
}


ULONG STDMETHODCALLTYPE CFusionShortcut::AddRef(void)
{
	ULONG ulcRef;

	ulcRef = RefCount::AddRef();

	return(ulcRef);
}


ULONG STDMETHODCALLTYPE CFusionShortcut::Release(void)
{
	ULONG ulcRef;

	ulcRef = RefCount::Release();

	return(ulcRef);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::QueryInterface(REFIID riid,
                                                           PVOID *ppvObject)
{
	HRESULT hr = S_OK;

	if (riid == IID_IExtractIcon)
	{
	  *ppvObject = (IExtractIcon*)this;
	}
	else if (riid == IID_IPersist)
	{
	  *ppvObject = (IPersist*)(IPersistFile*)this;
	}
	else if (riid == IID_IPersistFile)
	{
	  *ppvObject = (IPersistFile*)this;
	}
	else if (riid == IID_IShellExtInit)
	{
	  *ppvObject = (IShellExtInit*)this;
	}
	else if (riid == IID_IShellLink)
	{
	  *ppvObject = (IShellLink*)this;
	}
	else if (riid == IID_IShellPropSheetExt)
	{
	  *ppvObject = (IShellPropSheetExt*)this;
	}
	else if (riid == IID_IQueryInfo)
	{
	  *ppvObject = (IQueryInfo*)this;
	}
	else if (riid == IID_IUnknown)
	{
	  *ppvObject = (IUnknown*)(IShellLink*)this;
	}
	else
	{
	  *ppvObject = NULL;
	  hr = E_NOINTERFACE;
	}

	if (hr == S_OK)
	  AddRef();

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\shlink.cpp ===
/*
 * shlink.cpp - IShellLink implementation for CFusionShortcut class.
 */


// note: BUGBUG?
// from MSDN, it's unclear that for the GetX methods the len arguments
// are counting the terminating NULL or not.
// "size of the buffer pointed by szX"
// so here, and other methods, assume they do -ie. wcslen(s) + L'\0'

/* Headers
 **********/

#include "project.hpp"

/* Types
 ********/

/*typedef enum isl_getpath_flags
{
   // flag combinations

   ALL_ISL_GETPATH_FLAGS   = (SLGP_SHORTPATH |
                              SLGP_UNCPRIORITY)
}
ISL_GETPATH_FLAGS;*/


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetPath(LPCWSTR pcwzPath)
{
	HRESULT hr = S_OK;
	WCHAR rgchNewPath[MAX_PATH];
	BOOL bChanged = FALSE;
	LPWSTR pwzOriPath = (LPWSTR) pcwzPath; // still, pwzOriPath shouldn't be modified
	LPWSTR pwzFixedPath = NULL;

	ASSERT(! pwzOriPath)

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzOriPath))
		pwzOriPath = NULL;

	if (pwzOriPath)
	{
		LPWSTR pwzFileName;

		// this ignores "If the lpBuffer buffer is too small, the return value is the size
		//  of the buffer, in WCHARs, required to hold the path"
		if (GetFullPathName(pwzOriPath, sizeof(rgchNewPath)/sizeof(WCHAR),
					rgchNewPath, &pwzFileName) > 0)
			pwzOriPath = rgchNewPath;
		else
			hr = GetLastWin32Error();
	}

	if (hr == S_OK)
	{
		bChanged = ! ((! pwzOriPath && ! m_pwzPath) ||
				(pwzOriPath && m_pwzPath &&
				! wcscmp(pwzOriPath, m_pwzPath)));

		if (bChanged && pwzOriPath)
		{
			 // (+ 1) for null terminator.

			pwzFixedPath = new(WCHAR[wcslen(pwzOriPath) + 1]);

			if (pwzFixedPath)
				wcscpy(pwzFixedPath, pwzOriPath);
			else
				hr = E_OUTOFMEMORY;
		}
	}

	if (hr == S_OK && bChanged)
	{
		if (m_pwzPath)
			delete [] m_pwzPath;

		m_pwzPath = pwzFixedPath;

		Dirty(TRUE);
   }

	ASSERT(hr == S_OK || FAILED(hr));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetPath(LPWSTR pwzFile,
                                                    int ncFileBufLen,
                                                    PWIN32_FIND_DATA pwfd,
                                                    DWORD dwFlags)
{
	HRESULT hr = S_OK;

	ASSERT(NULL == pwfd);
	// Ignore dwFlags.

	if (pwfd)
		ZeroMemory(pwfd, sizeof(*pwfd));

	if (m_pwzPath)
	{
		if (pwzFile == NULL || ncFileBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzFile, m_pwzPath, ncFileBufLen-1);
			pwzFile[ncFileBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncFileBufLen > 0 && pwzFile != NULL)
			*pwzFile = L'\0';

		hr = S_FALSE;
	}

	ASSERT((hr == S_OK && ncFileBufLen < 1) ||
			(hr == S_FALSE && 
			(ncFileBufLen < 1 || ! *pwzFile)));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetRelativePath(LPCWSTR pcwzRelativePath,
                                                      DWORD dwReserved)
{
	HRESULT hr;

	// dwReserved may be any value.

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetIDList(LPCITEMIDLIST pcidl)
{
	HRESULT hr;

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetIDList(LPITEMIDLIST *ppidl)
{
	HRESULT hr;

	if (ppidl != NULL)
		*ppidl = NULL;

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetDescription(LPCWSTR pcwzDescription)
{
	HRESULT hr = S_OK;
	BOOL bDifferent;
	LPWSTR pwzNewDesc = NULL;

	// Set m_pwzDesc to description.

	bDifferent = ! ((! pcwzDescription && ! m_pwzDesc) ||
				(pcwzDescription && m_pwzDesc &&
				! wcscmp(pcwzDescription, m_pwzDesc)));

	if (bDifferent && pcwzDescription)
	{
		// (+ 1) for null terminator.

		pwzNewDesc = new(WCHAR[wcslen(pcwzDescription) + 1]);

		if (pwzNewDesc)
			wcscpy(pwzNewDesc, pcwzDescription);
		else
			hr = E_OUTOFMEMORY;
	}

	if (hr == S_OK && bDifferent)
	{
		if (m_pwzDesc)
			delete [] m_pwzDesc;

		m_pwzDesc = pwzNewDesc;

		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetDescription(LPWSTR pwzDescription,
                                                      int ncDesciptionBufLen)
{
	HRESULT hr = S_OK;

	// Get description from m_pwzDesc.

	if (m_pwzDesc)
	{
		if (pwzDescription == NULL || ncDesciptionBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzDescription, m_pwzDesc, ncDesciptionBufLen-1);
			pwzDescription[ncDesciptionBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncDesciptionBufLen > 0 && pwzDescription != NULL)
			pwzDescription = L'\0';
	}

	ASSERT(hr == S_OK &&
		(ncDesciptionBufLen <= 0 ||
		EVAL(wcslen(pwzDescription) < ncDesciptionBufLen)));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetArguments(LPCWSTR pcwzArgs)
{
   HRESULT hr;

   hr = E_NOTIMPL;

   return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetArguments(LPWSTR pwzArgs,
                                                         int ncArgsBufLen)
{
   HRESULT hr;

   if (ncArgsBufLen > 0 && pwzArgs != NULL)
      *pwzArgs = L'\0';

   hr = E_NOTIMPL;

   return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetWorkingDirectory(LPCWSTR pcwzWorkingDirectory)
{
	HRESULT hr = S_OK;
	WCHAR rgchNewPath[MAX_PATH];
	BOOL bChanged = FALSE;
	LPWSTR pwzOriWorkingDirectory = (LPWSTR) pcwzWorkingDirectory; // still, pwzOriWorkingDirectory shouldn't be modified
	LPWSTR pwzFixedWorkingDirectory = NULL;

	ASSERT(! pwzOriWorkingDirectory)

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzOriWorkingDirectory))
		pwzOriWorkingDirectory = NULL;

	if (pwzOriWorkingDirectory)
	{
		LPWSTR pwzFileName;

		// this ignores "If the lpBuffer buffer is too small, the return value is the size
		//  of the buffer, in WCHARs, required to hold the path"
		if (GetFullPathName(pwzOriWorkingDirectory, sizeof(rgchNewPath)/sizeof(WCHAR),
					rgchNewPath, &pwzFileName) > 0)
			pwzOriWorkingDirectory = rgchNewPath;
		else
			hr = GetLastWin32Error();
	}

	if (hr == S_OK)
	{
		bChanged = ! ((! pwzOriWorkingDirectory && ! m_pwzWorkingDirectory) ||
				(pwzOriWorkingDirectory && m_pwzWorkingDirectory &&
				! wcscmp(pwzOriWorkingDirectory, m_pwzWorkingDirectory)));

		if (bChanged && pwzOriWorkingDirectory)
		{
			// (+ 1) for null terminator.

			pwzFixedWorkingDirectory = new(WCHAR[wcslen(pwzOriWorkingDirectory) + 1]);

			if (pwzFixedWorkingDirectory)
				wcscpy(pwzFixedWorkingDirectory, pwzOriWorkingDirectory);
			else
				hr = E_OUTOFMEMORY;
		}
	}

	if (hr == S_OK && bChanged)
	{
		if (m_pwzWorkingDirectory)
			delete [] m_pwzWorkingDirectory;

		m_pwzWorkingDirectory = pwzFixedWorkingDirectory;

		Dirty(TRUE);
	}

	ASSERT(hr == S_OK || FAILED(hr));

	return(hr);
}

HRESULT STDMETHODCALLTYPE CFusionShortcut::GetWorkingDirectory(LPWSTR pwzWorkingDirectory,
                                                int ncbWorkingDirectoryBufLen)
{
	HRESULT hr = S_OK;

	if (m_pwzWorkingDirectory)
	{
		if (pwzWorkingDirectory == NULL || ncbWorkingDirectoryBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzWorkingDirectory, m_pwzWorkingDirectory,
				ncbWorkingDirectoryBufLen-1);
			pwzWorkingDirectory[ncbWorkingDirectoryBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncbWorkingDirectoryBufLen > 0 && pwzWorkingDirectory != NULL)
			*pwzWorkingDirectory = L'\0';

		hr = S_FALSE;
	}

	ASSERT(IsValidPathResult(hr, pwzWorkingDirectory, ncbWorkingDirectoryBufLen));
	ASSERT(hr == S_OK ||
		hr == S_FALSE);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetHotkey(WORD wHotkey)
{
	HRESULT hr=S_OK;

	ASSERT(! wHotkey)

	if (wHotkey != m_wHotkey)
	{
		m_wHotkey = wHotkey;
		
		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetHotkey(PWORD pwHotkey)
{
	HRESULT hr=S_OK;

	if (pwHotkey == NULL)
		hr = E_INVALIDARG;
	else
		*pwHotkey = m_wHotkey;

	ASSERT(! *pwHotkey)

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetShowCmd(int nShowCmd)
{
	HRESULT hr=S_OK;

	ASSERT(IsValidShowCmd(nShowCmd));

	if (nShowCmd != m_nShowCmd)
	{
		m_nShowCmd = nShowCmd;

		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetShowCmd(PINT pnShowCmd)
{
	HRESULT hr=S_OK;

	if (pnShowCmd == NULL)
		hr = E_INVALIDARG;
	else
		*pnShowCmd = m_nShowCmd;

	ASSERT(IsValidShowCmd(m_nShowCmd));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetIconLocation(LPCWSTR pcwzIconFile,
                                                            int niIcon)
{
	HRESULT hr = S_OK;
	BOOL bNewNonWhiteSpace;

	ASSERT(IsValidIconIndex(pcwzIconFile ? S_OK : S_FALSE, pcwzIconFile, MAX_PATH, niIcon));

	bNewNonWhiteSpace = AnyNonWhiteSpace(pcwzIconFile);

	if (hr == S_OK)
	{
		WCHAR rgchOldPath[MAX_PATH];
		int niOldIcon;
		UINT uFlags;

		hr = GetIconLocation(0, rgchOldPath, sizeof(rgchOldPath)/sizeof(WCHAR), &niOldIcon,
			&uFlags);

		// should this continue even if there's error getting icon location??
		if (SUCCEEDED(hr))
		{
			BOOL bOldNonWhiteSpace;
			BOOL bChanged = FALSE;
			LPWSTR pwzNewIconFile = NULL;
			int niNewIcon = 0;

			bOldNonWhiteSpace = AnyNonWhiteSpace(rgchOldPath);

			ASSERT(! *rgchOldPath || bOldNonWhiteSpace);

			// check
			bChanged = ((! bOldNonWhiteSpace && bNewNonWhiteSpace) ||
				(bOldNonWhiteSpace && ! bNewNonWhiteSpace) ||
				(bOldNonWhiteSpace && bNewNonWhiteSpace &&
				(wcscmp(rgchOldPath, pcwzIconFile) != 0 ||
				niIcon != niOldIcon)));

			// clear hr
			hr = S_OK;
			if (bChanged && bNewNonWhiteSpace)
			{
				// (+ 1) for null terminator.

				// BUGBUG: slightly not optimize as it makes a copy even if only the index changes
				pwzNewIconFile = new(WCHAR[wcslen(pcwzIconFile) + 1]);

				if (pwzNewIconFile)
				{
					wcscpy(pwzNewIconFile, pcwzIconFile);
					niNewIcon = niIcon;
				}
				else
					hr = E_OUTOFMEMORY;
			}
 
			if (hr == S_OK && bChanged)
			{
				if (m_pwzIconFile)
					delete [] m_pwzIconFile;

				m_pwzIconFile = pwzNewIconFile;
				m_niIcon = niNewIcon;

				Dirty(TRUE);
			}
		}
	}

	ASSERT(hr == S_OK ||
		hr == E_OUTOFMEMORY ||
		hr == E_FILE_NOT_FOUND);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetIconLocation(LPWSTR pwzIconFile,
                                                         int ncbIconFileBufLen,
                                                         PINT pniIcon)
{
	HRESULT hr=S_OK;

	// this ignores icon index (even if set) if icon file path is not
	if (m_pwzIconFile)
	{
		if (pwzIconFile == NULL || ncbIconFileBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzIconFile, m_pwzIconFile, ncbIconFileBufLen-1);
			pwzIconFile[ncbIconFileBufLen-1] = L'\0';

			if (pniIcon == NULL)
				hr = E_INVALIDARG;
			else
				*pniIcon = m_niIcon;
			
		}
	}
	else
	{
		if (ncbIconFileBufLen > 0 && pwzIconFile != NULL)
			*pwzIconFile = L'\0';

		if (pniIcon != NULL)
			*pniIcon = 0;

		hr = S_FALSE;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ncbIconFileBufLen, *pniIcon));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Resolve(HWND hwnd, DWORD dwFlags)
{
	HRESULT hr;

	ASSERT(IS_VALID_HANDLE(hwnd, WND));

	// BUGBUG?: check dwFlags

	hr = S_OK;

	// BUGBUG?: should this check the shortcut and do the UI/update/save?

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\lv\cdlids.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#define IDD_CDLLOGVIEW                                     1500
#define IDC_CB_VIEWLOG                                     1501
#define IDC_CB_REFRESH                                     1502
#define IDC_CB_DELETE                                      1503
#define IDC_CB_DELETE_ALL                                  1504
#define IDC_LV_LOGMESSAGES                                 1505
#define IDC_STATIC                                         1506
#define IDC_RADIO_DEFAULT                                  1507
#define IDC_RADIO_XSP                                      1508
#define IDC_RADIO_CUSTOM                                   1509
#define IDC_STATIC1                                        1510
#define IDC_CB_ENABLELOG                                   1511

#define ID_FUSLOGVW_BUTTON_VIEW_LOG                        2000
#define ID_FUSLOGVW_BUTTON_DELETE_ENTRY                    2001
#define ID_FUSLOGVW_BUTTON_DELETE_ALL                      2002
#define ID_FUSLOGVW_BUTTON_REFRESH                         2003
#define ID_FUSLOGVW_BUTTON_EXIT                            2004
#define ID_FUSLOGVW_GROUPBOX_LOG_LOCATION                  2005
#define ID_FUSLOGVW_RADIO_LOCATION_DEFAULT                 2006
#define ID_FUSLOGVW_RADIO_LOCATION_ASP_NET                 2007
#define ID_FUSLOGVW_RADIO_LOCATION_CUSTOM                  2008
#define ID_FUSLOGVW_DIALOG_TITLE                           2009
#define ID_FUSLOGVW_CHECKBOX_ENABLELOG                     2010

#define ID_FUSLOGVW_HEADER_TEXT_APPLICATION                3000
#define ID_FUSLOGVW_HEADER_TEXT_DESCRIPTION                3001
#define ID_FUSLOGVW_HEADER_TEXT_DATE_TIME                  3002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\shell\shortcut\util.cpp ===
#include "project.hpp"
#include <stdio.h>    // for _snwprintf

// * note: debug check/code incomplete.

// ----------------------------------------------------------------------------

//
// Return last Win32 error as an HRESULT.
//
HRESULT
GetLastWin32Error()
{
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
}

// ----------------------------------------------------------------------------

bool
PathAppend(LPWSTR wzDest, LPCWSTR wzSrc)
{
    // shlwapi PathAppend-like
	bool bRetVal = TRUE;
	int iPathLen = 0;
	static WCHAR wzWithSeparator[] = L"\\%s";
	static WCHAR wzWithoutSeparator[] = L"%s";

	if (!wzDest || !wzSrc)
	{
		bRetVal = FALSE;
		goto exit;
	}

	iPathLen = wcslen(wzDest);

    if (_snwprintf(wzDest+iPathLen, MAX_PATH-iPathLen, 
    	(wzDest[iPathLen-1] == L'\\' ? wzWithoutSeparator : wzWithSeparator), wzSrc) < 0)
	{
		bRetVal = FALSE;
	}

exit:
	return bRetVal;
}

// ----------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Returns an integer value specifying the length of
         the substring in psz that consists entirely of 
         characters in pszSet.  If psz begins with a character
         not in pszSet, then this function returns 0.

         This is a DBCS-safe version of the CRT strspn().  

Returns: see above
Cond:    --
*/
/*int StrSpnW(LPCWSTR psz, LPCWSTR pszSet)
{
	LPCWSTR pszT;
	LPCWSTR pszSetT;

	ASSERT(psz);
	ASSERT(pszSet);

	// Go thru the string to be inspected 

	for (pszT = psz; *pszT; pszT++)
    {
	    // Go thru the char set

	    for (pszSetT = pszSet; *pszSetT != *pszT; pszSetT++)
	    {
	        if (0 == *pszSetT)
	        {
	            // Reached end of char set without finding a match
	            return (int)(pszT - psz);
	        }
	    }
    }

	return (int)(pszT - psz);
}*/

// find leading spaces
BOOL AnyNonWhiteSpace(PCWSTR pcwz)
{
   ASSERT(! pcwz );

   return(pcwz ? wcsspn(pcwz, g_cwzWhiteSpace) < wcslen(pcwz) : FALSE);	// use (size_t) StrSpnW as above?
}

// ----------------------------------------------------------------------------

BOOL IsValidPath(PCWSTR pcwzPath)
{
   // FEATURE: Beef up path validation.

   return(EVAL((UINT)wcslen(pcwzPath) < MAX_PATH));
}

BOOL IsValidPathResult(HRESULT hr, PCWSTR pcwzPath,
                                   UINT ucbPathBufLen)
{
   return((hr == S_OK &&
           EVAL(IsValidPath(pcwzPath)) &&
           EVAL((UINT)wcslen(pcwzPath) < ucbPathBufLen)) ||
          (hr != S_OK &&
           EVAL(! ucbPathBufLen ||
                ! pcwzPath ||
                ! *pcwzPath)));
}

BOOL IsValidIconIndex(HRESULT hr, PCWSTR pcwzIconFile,
                                  UINT ucbIconFileBufLen, int niIcon)
{
   return(EVAL(IsValidPathResult(hr, pcwzIconFile, ucbIconFileBufLen)) &&
          EVAL(hr == S_OK ||
               ! niIcon));
}

// ----------------------------------------------------------------------------

BOOL IsValidHWND(HWND hwnd)
{
   // Ask User if this is a valid window.

   return(IsWindow(hwnd));
}

#ifdef DEBUG

BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}

BOOL IsValidHEVENT(HANDLE hevent)
{
   return(IsValidHANDLE(hevent));
}

BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}

BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(IsValidHANDLE(hg));
}

BOOL IsValidHMENU(HMENU hmenu)
{
   return(IsValidHANDLE(hmenu));
}

BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(IsValidHANDLE(hinst));
}

BOOL IsValidHICON(HICON hicon)
{
   return(IsValidHANDLE(hicon));
}

BOOL IsValidHKEY(HKEY hkey)
{
   return(IsValidHANDLE(hkey));
}

BOOL IsValidHMODULE(HMODULE hmod)
{
   return(IsValidHANDLE(hmod));
}

BOOL IsValidHPROCESS(HANDLE hprocess)
{
   return(IsValidHANDLE(hprocess));
}

BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}

BOOL IsValidShowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_MINIMIZE:
      case SW_MAXIMIZE:
      case SW_RESTORE:
      case SW_SHOW:
      case SW_SHOWNORMAL:
      case SW_SHOWDEFAULT:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_FORCEMINIMIZE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidShowCmd(): Invalid show command %d.",
                    nShow));
         break;
   }

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\client\client.cpp ===
//
// Client.cpp - client implementation
//
#include <objbase.h>
#include <iostream.h>
#include <assert.h>

#include "fusenet.h"
//#include "Util.h"
#include "server.h"
//#include "Iface.h"

#define INITGUID
#include <guiddef.h>

DEFINE_GUID(IID_IAssemblyUpdate,
0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(LIBID_ServerLib,
0xd3011ee0,0xb997,0x11cf,0xa6,0xbb,0x00,0x80,0xc7,0xb2,0xd6,0x82);

DEFINE_GUID(CLSID_CAssemblyUpdate,
0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);


int __cdecl main()
{
    HRESULT hr;
    DWORD clsctx = CLSCTX_LOCAL_SERVER ;

    cout << "Client Running..." << endl;
    cout << "Attempt to create local component.";

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); 

    IAssemblyUpdate *pAssemblyUpdate = NULL;
//    IAssemblyDownload *pDownload = NULL;
    
    hr = CoCreateInstance(CLSID_CAssemblyUpdate,
                                  NULL, clsctx, 
                                  IID_IAssemblyUpdate, (void**)&pAssemblyUpdate) ;
    if (SUCCEEDED(hr))
    {
        cout << "Successfully created component." << endl;
        cout << "Use interface IAssemblyUpdate." << endl;

//        hr = CreateAssemblyDownload(&pDownload);    
//        pDownload->DownloadManifestAndDependencies(L"http://adriaanc5/msnsubscription.manifest", 
//                NULL, DOWNLOAD_FLAGS_PROGRESS_UI);

        hr = pAssemblyUpdate->RegisterAssemblySubscriptionEx(L"MARS Version 1.0", 
            L"http://adriaanc5/msnsubscription.manifest", 1, 1, 0, FALSE);

        cout << "hr for pAssemblyUpdate->RegisterAssemblySubscription() is " << hr << endl;
        cout << "Release IAssemblyUpdate." << endl;

       pAssemblyUpdate->Release() ;
    
    }
    else
    {
        cout << "Could not create component." << endl;
    }
    // Uninitialize COM Library
    CoUninitialize() ;

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\mg\manifestnode.h ===
#pragma once

#include "fusenet.h"
#include "fusenetincludes.h"

#define UNKNOWN_ASSEMBLY 0
#define PRIVATE_ASSEMBLY 1
#define GAC_ASSEMBLY 2

class ManifestNode {
    public:
        ManifestNode(IAssemblyManifestImport *pManifestImport, 
                           LPWSTR pwzSrcRootDir, 
                           LPWSTR pwzFilePath,
                           DWORD dwType);
        ~ManifestNode();

        HRESULT GetNextAssembly(DWORD index, IManifestInfo **ppManifestInfo);
        HRESULT GetNextFile(DWORD index, IManifestInfo **ppManifestInfo);
        HRESULT GetAssemblyIdentity(IAssemblyIdentity **ppAsmId);
        HRESULT GetManifestFilePath(LPWSTR *ppwzFileName);
        HRESULT SetManifestFilePath(LPWSTR pwzFileName);
        HRESULT GetSrcRootDir(LPWSTR *ppwzSrcRootDir);
        HRESULT SetSrcRootDir(LPWSTR pwzSrcRootDir);
        HRESULT GetManifestType(DWORD *pdwType);
        HRESULT SetManifestType(DWORD dwType);
        HRESULT IsEqual(ManifestNode *pManifestNode);        

        private:
            IAssemblyManifestImport *_pManifestImport;
            LPWSTR _pwzSrcRootDir;
            LPWSTR _pwzFilePath;
            DWORD _dwType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\mg\mg.h ===
#include "fusenet.h"
#include "manifestnode.h"
#include "list.h"

#define HASHTABLE_SIZE 257

#define TOLOWER(a) (((a) >= L'A' && (a) <= L'Z') ? (L'a' + (a - L'A')) : (a))

inline DWORD HashString(LPCWSTR wzKey, DWORD dwHashSize, BOOL bCaseSensitive)
{
    DWORD                                 dwHash = 0;
    DWORD                                 dwLen;
    DWORD                                 i;

    dwLen = lstrlenW(wzKey);
    for (i = 0; i < dwLen; i++)
    {
        if (bCaseSensitive)
            dwHash = (dwHash * 65599) + (DWORD)wzKey[i];
        else
            dwHash = (dwHash * 65599) + (DWORD)TOLOWER(wzKey[i]);
    }

    dwHash %= dwHashSize;

    return dwHash;
}
HRESULT CreateDirectoryHierarchy(LPWSTR pwzRootDir, LPWSTR pwzFilePath);
HRESULT PathNormalize(LPWSTR pwzPath, LPWSTR *ppwzAbsolutePath, DWORD dwFlag);
HRESULT IsUniqueManifest(List<IAssemblyIdentity *> *pSeenAssemblyList, IAssemblyManifestImport *pManifestImport);
HRESULT DequeueItem(List<IAssemblyManifestImport *> *pList, IAssemblyManifestImport ** ppManifestImport);
HRESULT ProbeForAssembly(IAssemblyIdentity *pName, ManifestNode **ppManifestNode);
HRESULT FindAllAssemblies (LPWSTR pwzDir, List<IAssemblyManifestImport *> *pAssemblyList);
HRESULT TraverseManifestDependencyTrees(IAssemblyManifestImport *pManifestImport, List<LPWSTR> *pFileList, BOOL bListMode);
HRESULT CrossReferenceFiles(LPWSTR pwzDir, List<LPWSTR> *pAssemblyFileList, List<LPWSTR> *pRawFiles);
HRESULT PrivatizeAssemblies(List<ManifestNode*> *pUniqueManifestList);
HRESULT GetInitialDependencies(LPWSTR pwzTemplatePath, List<ManifestNode *> *pManifestList);
HRESULT CreateSubscriptionManifest(LPWSTR pwzApplicationManifestPath, LPWSTR pwzSubscriptionManifestPath, LPWSTR pwzUrl, LPWSTR pwzPollingInterval);
HRESULT PrintDependencies(List <LPWSTR> *pRawFileList, List<ManifestNode *> *pUniqueManifestList);
HRESULT Usage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\mg\mg.cpp ===
#include <windows.h>
#include <fusenetincludes.h>
#include <stdio.h>
#include "mg.h"
#include "manifestnode.h"
#include "xmlutil.h"
#include "assemblycache.h"

#include "version.h"

#define DIRECTORY_PATH 0
#define FILE_PATH 1


#define DEFAULT_POLLING_INTERVAL L"6"

#define MAX_DEPLOY_DIRS (5)
CString g_sDeployDirs[MAX_DEPLOY_DIRS];
DWORD   g_dwDeployDirs=0;

typedef enum _COMMAND_MODE_ {
    CmdUsage,
    CmdTemplate,
    CmdList,
    CmdDependencyList,
    CmdSubscription,
    CmdManifest,
} COMMAND_MODE, *LPCOMMAND_MODE;

CString g_sTargetDir;
CString g_sTemplateFile;
CString g_sAppManifestURL;
CString g_sPollingInterval;
CString g_sSubscriptionManifestDir;
CString g_sAppManifestFile;



CString g_sAppBase;

BOOL g_bFailOnWarnings=TRUE;
BOOL g_bLookInGACForDependencies;
BOOL g_bCopyDependentSystemAssemblies;

class __declspec(uuid("f6d90f11-9c73-11d3-b32e-00c04f990bb4")) private_MSXML_DOMDocument30;


typedef HRESULT(*PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);
typedef HRESULT (__stdcall *PFNCREATEASSEMBLYCACHE) (IAssemblyCache **ppAsmCache, DWORD dwReserved);

#define WZ_MSCOREE_DLL_NAME                   L"mscoree.dll"
#define GETCORSYSTEMDIRECTORY_FN_NAME       "GetCORSystemDirectory"
#define CREATEASSEMBLYCACHE_FN_NAME         "CreateAssemblyCache"
#define WZ_FUSION_DLL_NAME                    L"Fusion.dll"

// ---------------------------------------------------------------------------
// CreateFusionAssemblyCache
// ---------------------------------------------------------------------------
HRESULT CreateFusionAssemblyCache(IAssemblyCache **ppFusionAsmCache)
{
    HRESULT      hr = S_OK;
    HMODULE     hEEShim = NULL;
    HMODULE     hFusion = NULL;
    WCHAR       szFusionPath[MAX_PATH];
    DWORD       ccPath = MAX_PATH;

    PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;
    PFNCREATEASSEMBLYCACHE   pfnCreateAssemblyCache = NULL;

    // Find out where the current version of URT is installed
    hEEShim = LoadLibrary(WZ_MSCOREE_DLL_NAME);
    if(!hEEShim)
    {
        hr = E_FAIL;
        goto exit;
    }
    pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY)
        GetProcAddress(hEEShim, GETCORSYSTEMDIRECTORY_FN_NAME);

    if((!pfnGetCorSystemDirectory))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get cor path.
    if (FAILED(hr = (pfnGetCorSystemDirectory(szFusionPath, MAX_PATH, &ccPath))))
        goto exit;


    // Form path to fusion.
    lstrcatW(szFusionPath, WZ_FUSION_DLL_NAME);
    hFusion = LoadLibrary(szFusionPath);
    if(!hFusion)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get method ptr.
    pfnCreateAssemblyCache = (PFNCREATEASSEMBLYCACHE)
        GetProcAddress(hFusion, CREATEASSEMBLYCACHE_FN_NAME);

    if((!pfnCreateAssemblyCache))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Create the fusion cache interface.
    if (FAILED(hr = (pfnCreateAssemblyCache(ppFusionAsmCache, 0))))
        goto exit;

    hr = S_OK;
    
exit:
    return hr;
    
}

/////////////////////////////////////////////////////////////////////////
// PathNormalize
// Creates absolute path from relative, using current directory of mg.exe or parent process.
/////////////////////////////////////////////////////////////////////////
HRESULT PathNormalize(LPWSTR pwzPath, LPWSTR *ppwzAbsolutePath, DWORD dwFlag, BOOL bExists)
{
    HRESULT hr = S_OK;
    WCHAR pwzTempDir[MAX_PATH], pwzAbsolutePath[MAX_PATH];
    DWORD ccDir = MAX_PATH;

    *ppwzAbsolutePath = NULL;
    //If path is relative, prepend the current directory
    if (PathIsRelative(pwzPath))
    {
        GetCurrentDirectory(ccDir, pwzTempDir);
        StrCat(pwzTempDir, L"\\");
        StrCat(pwzTempDir, pwzPath);
    }
    else
        StrCpy(pwzTempDir, pwzPath);


    if (!PathCanonicalize(pwzAbsolutePath, pwzTempDir))
    {
        printf("Dir \"%ws\" canonicalize error\n", pwzTempDir);
        hr = E_FAIL;
        goto exit;
    }

    //If path is supposed to be a diesctory, append a trailing slash if not already there
    ccDir = lstrlen(pwzAbsolutePath);
    if (dwFlag == DIRECTORY_PATH && pwzAbsolutePath[ccDir -1] != L'\\')
    {
        pwzAbsolutePath[ccDir] = L'\\';
        pwzAbsolutePath[ccDir +1] = L'\0';
    }

    //Make sure the direcotry exists
    if (dwFlag == DIRECTORY_PATH && !bExists)
    {
        if(!PathIsDirectory(pwzAbsolutePath))
        {
            printf("Dir \"%ws\" is not a valid directory\n", pwzPath);
            hr = E_FAIL;
            goto exit;
        }
    }
    //Make sure the file exists
    else if (dwFlag == FILE_PATH)
    {
        if(!bExists)
        {
            if(!PathFileExists(pwzAbsolutePath))
            {
                printf("File \"%ws\" does not exist\n", pwzPath);
                hr = E_FAIL;
                goto exit;
            }
        }
        if(PathIsDirectory(pwzAbsolutePath))
        {
            printf("File \"%ws\" is a directory\n", pwzPath);
            hr = E_FAIL;
            goto exit;
        }
    }
           
    (*ppwzAbsolutePath) = WSTRDupDynamic(pwzAbsolutePath);

exit:
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// IsUniqueManifest
/////////////////////////////////////////////////////////////////////////
HRESULT IsUniqueManifest(List<ManifestNode *> *pSeenAssemblyList, 
    ManifestNode *pManifestNode)
{
    HRESULT hr = S_OK;
    ManifestNode *pCurrentNode=NULL;
    LISTNODE pos;

    //cycle through list of unique manifests seen so far
    //if new manifest is not found, add it to the list
    pos = pSeenAssemblyList->GetHeadPosition();
    while (pos)
    {
        if (pCurrentNode = pSeenAssemblyList->GetNext(pos))
        {
            //Not Unique, go return
            if ((hr =pCurrentNode->IsEqual(pManifestNode)) == S_OK)
            {
                hr= S_FALSE;
                goto exit;
            }
        }
    }

    //No match, AsmId is unique, add it to the list
    //Dont release pAsmId since list doesnt ref count
    hr = S_OK;    
    
exit:
    return hr;

}

/////////////////////////////////////////////////////////////////////////
// DequeueItem
/////////////////////////////////////////////////////////////////////////
HRESULT DequeueItem(List<ManifestNode*> *pList, ManifestNode** ppManifestNode)
{
    HRESULT hr = S_OK;
    LISTNODE pos = NULL;

    (*ppManifestNode) = NULL;

    pos = pList->GetHeadPosition();
    if (!pos)
    {
        hr = S_FALSE;
        goto exit;
    }

    (*ppManifestNode) = pList->GetAt(pos);
    pList->RemoveAt(pos);

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// ProbeForAssemblyInPath
/////////////////////////////////////////////////////////////////////////
HRESULT ProbeForAssemblyInPath(CString &sDeployDir, IAssemblyIdentity *pName, ManifestNode **ppManifestNode) //LPWSTR *ppwzFilePath, DWORD *pdwType)
{
    HRESULT hr = S_OK;

    DWORD cbBuf = 0, ccBuf =0 ;
    LPWSTR pwzBuf = NULL;

    CString sName, sLocale, sPublicKeyToken, sCLRDisplayName, sRelativeAssemblyPath;
    CString sProbingPaths[6];
    IAssemblyIdentity *pAssemblyId= NULL;
    IAssemblyManifestImport *pManImport=NULL;


    // first try to find assembly by probing
    if(FAILED(hr = pName->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzBuf, &cbBuf)))
        goto exit;
    sName.TakeOwnership(pwzBuf);

    if(FAILED(hr = pName->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzBuf, &cbBuf)))
        goto exit;
    sLocale.TakeOwnership(pwzBuf);

    if(FAILED(hr = pName->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzBuf, &ccBuf)
        && hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)))
        goto exit;
    else if(hr == S_OK)
        sPublicKeyToken.TakeOwnership(pwzBuf);

    //bugbug - Hack to supress warning messages for not being able to find mscorlib
    if(sPublicKeyToken._pwz && !StrCmpI(sPublicKeyToken._pwz, L"b77a5c561934e089") && !StrCmpI(sName._pwz, L"mscorlib"))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    //Set up the six different probing locations
    // 1: appBase\AssemblyName.dll
    // 2: appBase\AssemblyName.exe
    // 3: appBase\AssemblyName\AssemblyName.dll
    // 4: appBase\AssemblyName\AssemblyName.exe
    // 5: appBase\local\AssemblyName\AssemblyName.dll
    // 6: appBase\local\AssemblyName\AssemblyName.exe
    
    sProbingPaths[0].Assign(sDeployDir);
    sProbingPaths[0].Append(sName);
    sProbingPaths[1].Assign(sProbingPaths[0]);

    sProbingPaths[0].Append(L".dll");
    sProbingPaths[1].Append(L".exe");

    sProbingPaths[2].Assign(sDeployDir);
    sProbingPaths[2].Append(sName);
    sProbingPaths[2].Append(L"\\");
    sProbingPaths[2].Append(sName);
    sProbingPaths[3].Assign(sProbingPaths[2]);

    sProbingPaths[2].Append(L".dll");
    sProbingPaths[3].Append(L".exe");

    sProbingPaths[4].Assign(sDeployDir);
    sProbingPaths[4].Append(sLocale);
    sProbingPaths[4].Append(L"\\");
    sProbingPaths[4].Append(sName);
    sProbingPaths[4].Append(L"\\");
    sProbingPaths[4].Append(sName);
    sProbingPaths[5].Assign(sProbingPaths[4]);

    sProbingPaths[4].Append(L".dll");
    sProbingPaths[5].Append(L".exe");


    for (int i = 0; i < 6; i++)
    {
        //Check first to see if the file exists
        if (GetFileAttributes(sProbingPaths[i]._pwz) != -1)
        {            
            hr = CreateAssemblyManifestImport(&pManImport, sProbingPaths[i]._pwz, NULL, 0);
            if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_BAD_FORMAT))
                goto exit;

            if(hr == HRESULT_FROM_WIN32(ERROR_BAD_FORMAT) || (hr = pManImport->GetAssemblyIdentity(&pAssemblyId)) != S_OK)
            {
                SAFERELEASE(pManImport);
                continue;
            }

            //bugbug - need to make IsEqual function more robust
            //sanity check to make sure the assemblies are the same
            if (pName->IsEqual(pAssemblyId) != S_OK)
            {
                SAFERELEASE(pAssemblyId);
                SAFERELEASE(pManImport);
                continue;
            }

            // Match found            
            (*ppManifestNode) = new ManifestNode(pManImport, 
                                         sDeployDir._pwz, 
                                         sProbingPaths[i]._pwz + sDeployDir._cc - 1, 
                                         PRIVATE_ASSEMBLY);

            SAFERELEASE(pAssemblyId);
            SAFERELEASE(pManImport);
            hr = S_OK;
            goto exit;
        }
    }

    // assembly not found in this dir.
    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

exit:
    
    return hr;

}

/////////////////////////////////////////////////////////////////////////
// ProbeForAssemblyInGAC
/////////////////////////////////////////////////////////////////////////
HRESULT ProbeForAssemblyInGAC(IAssemblyIdentity *pName, ManifestNode **ppManifestNode) //LPWSTR *ppwzFilePath, DWORD *pdwType)
{
    HRESULT hr = S_OK;

    DWORD cbBuf = 0, ccBuf =0 ;
    LPWSTR pwzBuf = NULL;
    IAssemblyManifestImport *pManImport=NULL;

    CString sCLRDisplayName;

    WCHAR pwzPath[MAX_PATH];
    ASSEMBLY_INFO asmInfo;
    IAssemblyCache *pAsmCache = NULL;

    memset(&asmInfo, 0, sizeof(asmInfo));
    asmInfo.pszCurrentAssemblyPathBuf = pwzPath;
    asmInfo.cchBuf = MAX_PATH;

    if (FAILED(hr = CreateFusionAssemblyCache(&pAsmCache)))
        goto exit;
      
    if(FAILED(hr = pName->GetCLRDisplayName(NULL, &pwzBuf, &ccBuf)))
        goto exit;
    sCLRDisplayName.TakeOwnership(pwzBuf, ccBuf);

    if ((hr = pAsmCache->QueryAssemblyInfo(0, sCLRDisplayName._pwz, &asmInfo)) == S_OK) 
    {
        // Assembly found in GAC
         if ((hr = CreateAssemblyManifestImport(&pManImport, asmInfo.pszCurrentAssemblyPathBuf, NULL, 0)) != S_OK)
            goto exit;

        (*ppManifestNode) = new ManifestNode(pManImport,
                                             NULL,
                                             asmInfo.pszCurrentAssemblyPathBuf, 
                                             GAC_ASSEMBLY);
        goto exit;
    }

exit:
    SAFERELEASE(pAsmCache);
    
    return hr;

}

/////////////////////////////////////////////////////////////////////////
// ProbeForAssembly
/////////////////////////////////////////////////////////////////////////
HRESULT ProbeForAssembly(IAssemblyIdentity *pName, ManifestNode **ppManifestNode) //LPWSTR *ppwzFilePath, DWORD *pdwType)
{
    HRESULT hr = S_OK;
    DWORD dwDirCount=0;

    *ppManifestNode = NULL;

    while(dwDirCount < g_dwDeployDirs)
    {
        if(SUCCEEDED(hr = ProbeForAssemblyInPath( g_sDeployDirs[dwDirCount], 
                                                  pName, ppManifestNode)))
            goto exit;

        dwDirCount++;
    }

    if( (IsKnownAssembly(pName, KNOWN_SYSTEM_ASSEMBLY) == S_OK)
        && (!g_bCopyDependentSystemAssemblies) )
    {
        hr = S_FALSE; // ignore system dependencies
        goto exit;
    }


    if( g_bLookInGACForDependencies )
    {
        //Can't find assembly by probing
        //Try to find the assembly in the GAC.
        if(SUCCEEDED(hr = ProbeForAssemblyInGAC(pName, ppManifestNode)))
            goto exit;
    }

    // assembly not found
    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

exit:
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// FindAssemblies
// note: Assumes that pwzDir has a trailing slash.
/////////////////////////////////////////////////////////////////////////
HRESULT FindAllAssemblies (LPWSTR pwzDir, List<ManifestNode *> *pManifestList)
{
    HRESULT hr = S_OK;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdFile;
    IAssemblyIdentity *pTempAsmId=NULL;    
    IAssemblyManifestImport *pManifestImport = NULL;
    ManifestNode *pManifestNode = NULL;
    CString sSearchString;
    DWORD dwLastError = 0;
    
    // set up search string to find all files in the passed in directory
    sSearchString.Assign(pwzDir);
    sSearchString.Append(L"*");

    if (sSearchString._cc > MAX_PATH)
    {
        hr = CO_E_PATHTOOLONG;
        printf("Error: Search path too long\n");
        goto exit;
    }

    hFind = FindFirstFile(sSearchString._pwz, &fdFile);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        // BUGBUG - getlasterror() ?
        hr = E_FAIL;
        printf("Find file error\n");
        goto exit;
    }

    //enumerate through all the files in the directory, 
    // and recursivly call FindAllAssemblies on any directories encountered
    while(TRUE)
    {
        if (StrCmp(fdFile.cFileName, L".") != 0 && StrCmp(fdFile.cFileName, L"..") != 0)
        {
            CString sFilePath;

            //create absolute file name by appending the filename to the dir name
            sFilePath.Assign(pwzDir);
            sFilePath.Append(fdFile.cFileName);

            if (sSearchString._cc > MAX_PATH)
            {
                hr = CO_E_PATHTOOLONG;
                printf("Error: File path too long\n");
                goto exit;
            }

            //If the file is a directory, recursivly call FindAllAssemblies
            if ((fdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            {          
                sFilePath.Append(L"\\");
                if (FAILED(hr = FindAllAssemblies(sFilePath._pwz, pManifestList)))
                    goto exit;
            }
            // If a file, check to see if it is a Assembly, if it is, add it to our master list
            else
            {
                if((hr = CreateAssemblyManifestImport(&pManifestImport, sFilePath._pwz, NULL, 0)) == S_OK)
                {
                    // check to make sure file we just opened wasnt just an XML file
                    if ((hr =pManifestImport->GetAssemblyIdentity(&pTempAsmId)) == S_OK)           
                    {
                        // List does not AddRef, so dont release pManifestImport and refcount will stay at one
                        // Clean up after list is no longer needed.
                        pManifestNode = new ManifestNode(pManifestImport,
                                                         g_sAppBase._pwz,
                                                         sFilePath._pwz+g_sAppBase._cc-1,
                                                         PRIVATE_ASSEMBLY);
                        pManifestList->AddTail(pManifestNode);
                        SAFERELEASE(pTempAsmId);
                    }
                    else if (FAILED(hr))
                        goto exit;

                    SAFERELEASE(pManifestImport);
                }
            }
        }
   
        if (!FindNextFile(hFind, &fdFile))
        {
            dwLastError = GetLastError();
            break;
        }
    }

    if(dwLastError == ERROR_NO_MORE_FILES)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(dwLastError);
exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// TraverseManifestDependencyTree
/////////////////////////////////////////////////////////////////////////
HRESULT TraverseManifestDependencyTrees(List<ManifestNode *> *pManifestList, 
    List<LPWSTR> *pAssemblyFileList, List<ManifestNode *> *pUniqueAssemblyList, BOOL bListMode)
{
    HRESULT hr = S_OK;
    IAssemblyManifestImport *pDepManifestImport=NULL;
    IManifestInfo *pDepAsmInfo=NULL, *pFileInfo=NULL;
    IAssemblyIdentity *pAsmId=NULL;
    ManifestNode *pManifestNode=NULL, *pDepManifestNode = NULL;
    LPWSTR pwz = NULL;
    DWORD index = 0, cb = 0, cc = 0, dwFlag = 0, dwHash=0, dwType=0;
    CString sFileName, sRelativeFilePath, sAbsoluteFilePath, sBuffer, sManifestName;


    while((hr = DequeueItem(pManifestList, &pManifestNode)) == S_OK)
    {
        // If Assembly has already been parsed, no need doing it again, skip to the next assembly
        if ((hr = IsUniqueManifest(pUniqueAssemblyList,  pManifestNode)) != S_OK)
        {
            SAFEDELETE(pManifestNode);
            continue;
        }
        pUniqueAssemblyList->AddTail(pManifestNode);

        pManifestNode->GetManifestFilePath(&pwz);
        sManifestName.TakeOwnership(pwz);

        //If the manifest was found by probing, add its name to the list of files
        hr =pManifestNode->GetManifestType(&dwType);
        if (dwType == PRIVATE_ASSEMBLY)
        {

            dwHash = HashString(sManifestName._pwz, HASHTABLE_SIZE, false);
            pAssemblyFileList[dwHash].AddTail(WSTRDupDynamic(sManifestName._pwz));

            //need the relative dir path of the manifest rwt the app base for future use
            sRelativeFilePath.Assign(sManifestName);

            sRelativeFilePath.RemoveLastElement();
            if(sRelativeFilePath.CharCount() > 1) // add a backslash only if string has any non-null chars. i.e. stringLength is non-zero; note here _cc holds 1(null-char).
                sRelativeFilePath.Append(L"\\");
        }

        if(bListMode)
            fprintf(stderr, "\nAssembly %ws:\n", sManifestName._pwz);
        
        //Add all dependant assemblies to the queue to be later traversed      
        while ((hr = pManifestNode->GetNextAssembly(index++, &pDepAsmInfo)) == S_OK)
        {        
            if(FAILED(hr = pDepAsmInfo->Get(MAN_INFO_DEPENDENT_ASM_ID,  (LPVOID *)&pAsmId, &cb, &dwFlag)))
                goto exit;

            pAsmId->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwz, &cc);
            
            //Try to find the assembly by first probing, then by checking in the GAC.
            if(FAILED(hr = ProbeForAssembly(pAsmId, &pDepManifestNode)))
            {
                //Assembly not found, display warning message
                //Bugbug, should mg still spit out a manifest knowing that things are missing?
                fprintf(stderr, "WRN: Unable to find dependency %ws. in manifest %ws\n", pwz, sManifestName._pwz);
                if(g_bFailOnWarnings)
                {
                    fprintf(stderr, "Warning treated as error. mg exiting....\n");
                    hr = E_FAIL;
                    goto exit;
                }
                SAFERELEASE(pAsmId);    
                continue;
            }
            else if (hr == S_OK)
            {
                //Dont release since no add refing in the list is taking place
                 if ((hr = IsUniqueManifest(pUniqueAssemblyList,  pDepManifestNode)) == S_OK)
                    pManifestList->AddTail(pDepManifestNode);

                SAFERELEASE(pAsmId);

                if(bListMode)
                    fprintf(stderr, "\tDependant Assembly: %ws\n", pwz);
            }
            SAFERELEASE(pDepAsmInfo);
        }

        // Add all files to hash table
        index = 0;
        pManifestNode->GetManifestType(&dwType);
        while (dwType == PRIVATE_ASSEMBLY && pManifestNode->GetNextFile(index++, &pFileInfo) == S_OK)
        {
            LPWSTR pwzFileName = NULL;
            if(FAILED(pFileInfo->Get(MAN_INFO_ASM_FILE_NAME, (LPVOID *)&pwz, &cb, &dwFlag)))
                goto exit;

            sBuffer.TakeOwnership(pwz);
            sFileName.Assign(sRelativeFilePath);
            sFileName.Append(sBuffer);
            sAbsoluteFilePath.Assign(g_sAppBase);
            sAbsoluteFilePath.Append(sFileName);
            sFileName.ReleaseOwnership(&pwzFileName);
            
            dwHash = HashString(pwzFileName, HASHTABLE_SIZE, false);
            pAssemblyFileList[dwHash].AddTail(pwzFileName);

            //If file is listed as part of an assembly, but cannot be found, display a warning.
            //Bugbug, should mg still spit out a manifest knowing that things are missing?
            if(!PathFileExists(sAbsoluteFilePath._pwz))
                printf("Warning: File \"%ws\" does not exist and is called out in \"%ws\"\n",sAbsoluteFilePath._pwz, sManifestName._pwz); 

            if(bListMode)
                fprintf(stderr, "\tDependant File: %ws\n", pwzFileName);

            //Release ownership since string is now part of hash table and hash table does not ref count
//            sFileName.ReleaseOwnership();
        }       
    }

    hr = S_OK;

exit:
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CrossReferenceFiles
/////////////////////////////////////////////////////////////////////////
HRESULT CrossReferenceFiles(LPWSTR pwzDir, List<LPWSTR> *pAssemblyFileList, List<LPWSTR> *pRawFiles)
{
    HRESULT hr = S_OK;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdFile;
    DWORD dwHash = 0;
    LISTNODE pos;
    LPWSTR pwzBuf=NULL;
    bool bRawFile = FALSE;
    DWORD dwLastError = 0;

    CString sSearchString;

    // set up search string to find all files in the passed in directory
    sSearchString.Assign(pwzDir);
    sSearchString.Append(L"*");

    if (sSearchString._cc > MAX_PATH)
    {
        hr = CO_E_PATHTOOLONG;
        printf("Error: Search path too long\n");
        goto exit;
    }

    hFind = FindFirstFile(sSearchString._pwz, &fdFile);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        printf("Find file error\n");
        goto exit;
    }

    //enumerate through all the files in the directory, 
    // and recursivly call FindAllAssemblies on any directories encountered
    while(TRUE)
    {
        if (StrCmp(fdFile.cFileName, L".") != 0 && StrCmp(fdFile.cFileName, L"..") != 0)
        {
            CString sFilePath;

            //create absolute file name by appending the filename to the dir name
            sFilePath.Assign(pwzDir);          
            sFilePath.Append(fdFile.cFileName);

            if (sSearchString._cc > MAX_PATH)
            {
                hr = CO_E_PATHTOOLONG;
                printf("Error: Search path too long\n");
                goto exit;
            }
            
            //if file is actually a direcoty, recrusivly call crossRefernceFiles on the Directory
            if ((fdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            {          
                sFilePath.Append(L"\\");
                if (FAILED(hr = CrossReferenceFiles(sFilePath._pwz, pAssemblyFileList, pRawFiles)))
                    goto exit;
            }
            else
            {
                //Check to see if the file is in the hash table.
                //If it isnt, then we know it is not called out from any assembly
                //add it to the Raw file list
                bRawFile = TRUE;
                dwHash = HashString(sFilePath._pwz+g_sAppBase._cc - 1, HASHTABLE_SIZE, false);

                pos = pAssemblyFileList[dwHash].GetHeadPosition();
                while (pos)
                {
                    pwzBuf = pAssemblyFileList[dwHash].GetNext(pos);
                    if (!StrCmpI(pwzBuf, sFilePath._pwz+g_sAppBase._cc - 1))
                    {
                        bRawFile = FALSE;
                        break;                                                                        
                    }
                }

                if (bRawFile)
                {
                    pwzBuf = WSTRDupDynamic(sFilePath._pwz+g_sAppBase._cc - 1);
                    pRawFiles->AddTail(pwzBuf);                
                }
            }
        }

        // BUGBUG - do fnf, check error.
        if (!FindNextFile(hFind, &fdFile))
        {
            dwLastError = GetLastError();
            break;
        }
    }

    if(dwLastError == ERROR_NO_MORE_FILES)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(dwLastError);   

exit:
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CopyRawFile
/////////////////////////////////////////////////////////////////////////
HRESULT CopyRawFile(LPWSTR pwzFilePath)
{
    HRESULT hr = S_OK;
    CString sDest;
    CString sSrc;


    sDest.Assign(g_sTargetDir);
    sDest.Append(pwzFilePath); // this should be relative path ...

    if(FAILED(hr = CreateDirectoryHierarchy(sDest._pwz, NULL)))
        goto exit;

    sSrc.Assign(g_sAppBase);
    sSrc.Append(pwzFilePath);

    printf(" Copying RawFile from <%ws> TO <%ws>  \n", sSrc._pwz, sDest._pwz);

    if(!::CopyFile(sSrc._pwz, sDest._pwz, FALSE))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

exit:

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CopyAssemblyBits
/////////////////////////////////////////////////////////////////////////
HRESULT CopyAssemblyBits(CString &sSrcDir, CString &sDestDir, ManifestNode *pManifestNode)
{
    HRESULT hr = S_OK;
    DWORD nIndex=0;
    DWORD dwFlag;
    DWORD cbBuf;
    LPWSTR pwzBuf=NULL;
    IManifestInfo *pFileInfo = NULL;


    if(FAILED(hr = CreateDirectoryHierarchy(sDestDir._pwz, NULL)))
        goto exit;

    if(!::CopyFile(sSrcDir._pwz, sDestDir._pwz, FALSE))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    //copy all file dependecies of the assembly as well
    nIndex = 0;

    while (pManifestNode->GetNextFile(nIndex++, &pFileInfo) == S_OK)
    {
        if(FAILED(pFileInfo->Get(MAN_INFO_ASM_FILE_NAME, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag)))
            goto exit;
        // sRelativeFilePath.TakeOwnership(pwzBuf, ccBuf);


        sSrcDir.RemoveLastElement();
        sSrcDir.Append(L"\\");
        sSrcDir.Append(pwzBuf);

        sDestDir.RemoveLastElement();
        sDestDir.Append(L"\\");
        sDestDir.Append(pwzBuf);

        // CreateDirectoryHierarchy(sPrivateAssemblyDir._pwz, sRelativeFilePath._pwz);
        if(!::CopyFile(sSrcDir._pwz, sDestDir._pwz, FALSE))
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }

        SAFEDELETEARRAY(pwzBuf);
        SAFERELEASE(pFileInfo);
    }

exit :

    SAFEDELETEARRAY(pwzBuf);
    SAFERELEASE(pFileInfo);

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CopyAssembly
/////////////////////////////////////////////////////////////////////////
HRESULT CopyAssembly(ManifestNode *pManifestNode)
{
    HRESULT hr = S_OK;
    CString sDest;
    CString sSrc;
    LPWSTR  pwzManifestFilePath = NULL;
    LPWSTR  pwzSrcDir=NULL;
    LPWSTR  pwzTemp = NULL;
    DWORD   dwType;
    IAssemblyIdentity *pAssemblyId = NULL;
    CString sAssemblyName;

    hr = pManifestNode->GetManifestFilePath(&pwzManifestFilePath);

    hr = pManifestNode->GetManifestType(&dwType);

    sDest.Assign(g_sTargetDir);

    if (dwType == PRIVATE_ASSEMBLY)
    {
        sDest.Append(pwzManifestFilePath); // this should be relative path ...

        if(FAILED(hr = pManifestNode->GetSrcRootDir(&pwzSrcDir)))
            goto exit;
        sSrc.Assign(pwzSrcDir);
        sSrc.Append(pwzManifestFilePath);
    }
    else if (dwType == GAC_ASSEMBLY)
    {
        LPWSTR  pwzBuf = NULL;
        DWORD   ccBuf = 0;

        pManifestNode->GetAssemblyIdentity(&pAssemblyId);

        if(FAILED(hr = pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, 
                                                 &pwzBuf, 
                                                 &ccBuf)))
            goto exit;

        if(!(pwzTemp = PathFindFileName(pwzManifestFilePath)))
        {
            hr = E_FAIL;
            goto exit;
        }

        sAssemblyName.TakeOwnership(pwzBuf);

        sAssemblyName.Append(L"\\");
        sAssemblyName.Append(pwzTemp); // manifest file name of the GAC assembly.

        sDest.Append(sAssemblyName);
        sSrc.Assign(pwzManifestFilePath);
    }

    printf(" Copying Assembly Man from <%ws> TO <%ws>  \n", sSrc._pwz, sDest._pwz);
    hr = CopyAssemblyBits(sSrc, sDest, pManifestNode);

    if (dwType == GAC_ASSEMBLY)
    {
        // set the install codebase of the assembly copied from GAC
        // to that of its relative path in target dir. This will be written to manifest ??
        hr = pManifestNode->SetManifestFilePath(sAssemblyName._pwz);
    }

exit:

    SAFEDELETEARRAY(pwzSrcDir);
    SAFEDELETEARRAY(pwzManifestFilePath);
    SAFERELEASE(pAssemblyId);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CopyFilesToTargetDir
/////////////////////////////////////////////////////////////////////////
HRESULT CopyFilesToTargetDir(List<ManifestNode*> *pUniqueManifestList, List<LPWSTR> *pRawFiles)
{
    HRESULT hr = S_OK;
    ManifestNode *pManifestNode = NULL;
    LISTNODE pos;
    LPWSTR pwzBuf;

      
    //Cycle through all of the unique manifests
    pos = pUniqueManifestList->GetHeadPosition();
    while (pos)
    {
        pManifestNode = pUniqueManifestList->GetNext(pos);

        //if the manifest was found by probing initially, then it is already in the Appbase's directory
        //continue to the next manifest
        //if the manifest was found in the GAC and is not a system assembly, copy the
        //assembly into the Appbase
        if(FAILED(hr = CopyAssembly(pManifestNode)))
            goto exit;
    }

    //Copy RawFiles to Target Dir
    pos = pRawFiles->GetHeadPosition();
    while (pos)
    {
        pwzBuf = pRawFiles->GetNext(pos);
        if(FAILED(hr = CopyRawFile(pwzBuf)))
            goto exit;
    }

exit:
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// PrivatizeAssemblies
/////////////////////////////////////////////////////////////////////////
HRESULT PrivatizeAssemblies(List<ManifestNode*> *pUniqueManifestList)
{
    HRESULT hr = S_OK;
    ManifestNode *pManifestNode = NULL;
    LISTNODE pos;
    LPWSTR pwzBuf =NULL;
    DWORD dwType = 0, ccBuf = 0, cbBuf = 0,  dwFlag = 0, nIndex = 0;
    IAssemblyIdentity *pAssemblyId = NULL;
    IManifestInfo *pFileInfo = NULL;
    WCHAR pwzPath[MAX_PATH];
    ASSEMBLY_INFO asmInfo;
    IAssemblyCache *pAsmCache = NULL;

    CString sPublicKeyToken, sCLRDisplayName;
    CString sAssemblyName, sAssemblyManifestFileName;
    CString sPrivateAssemblyPath, sPrivateAssemblyDir;
    CString sAssemblyGACPath, sAssemblyGACDir;
    CString sRelativeFilePath, sFileGACPath, sFilePrivatePath;
    CString sBuffer;

    memset(&asmInfo, 0, sizeof(asmInfo));
    asmInfo.pszCurrentAssemblyPathBuf = pwzPath;
    asmInfo.cchBuf = MAX_PATH;

    if (FAILED(hr = CreateFusionAssemblyCache(&pAsmCache)))
        goto exit;

      
    //Cycle through all of the unique manifests
    pos = pUniqueManifestList->GetHeadPosition();
    while (pos)
    {
        pManifestNode = pUniqueManifestList->GetNext(pos);
        hr = pManifestNode->GetManifestType(&dwType);

        //if the manifest was found by probing initially, then it is already in the Appbase's directory
        //continue to the next manifest
        //if the manifest was found in the GAC and is not a system assembly, copy the
        //assembly into the Appbase

        if (dwType == PRIVATE_ASSEMBLY)
            continue;        
        else if (dwType == GAC_ASSEMBLY)
        {
            pManifestNode->GetAssemblyIdentity(&pAssemblyId);

        hr = pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzBuf, &ccBuf);
        sPublicKeyToken.TakeOwnership(pwzBuf);

        //if the assembly is a system assembly, skip to next manifest
        if (!StrCmpI(sPublicKeyToken._pwz, L"b77a5c561934e089") || !StrCmpI(sPublicKeyToken._pwz, L"b03f5f7f11d50a3a"))          
        {
            SAFERELEASE(pAssemblyId);
            continue;
        }

        //get the assemblies dir by making a call into CreateAssemblyCache
        if(FAILED(hr = pAssemblyId->GetCLRDisplayName(NULL, &pwzBuf, &ccBuf)))
            goto exit;
        sCLRDisplayName.TakeOwnership(pwzBuf, ccBuf);

        if ((hr = pAsmCache->QueryAssemblyInfo(0, sCLRDisplayName._pwz, &asmInfo)) != S_OK) 
            goto exit;

        sAssemblyGACPath.Assign(asmInfo.pszCurrentAssemblyPathBuf);
        sAssemblyGACPath.LastElement(sAssemblyManifestFileName);

        sAssemblyGACDir.Assign(sAssemblyGACPath);
        sAssemblyGACDir.RemoveLastElement();


            hr = pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzBuf, &ccBuf);
            sAssemblyName.TakeOwnership(pwzBuf);

        //set up the new directory to store the assembly in
        // g_sAppBase\assemblyname\,
        sPrivateAssemblyDir.Assign(g_sAppBase);
        sPrivateAssemblyDir.Append(sAssemblyName);
        sPrivateAssemblyDir.Append(L"\\");
        CreateDirectoryHierarchy(sPrivateAssemblyDir._pwz, sAssemblyManifestFileName._pwz);

        sPrivateAssemblyPath.Assign(sPrivateAssemblyDir);
        sPrivateAssemblyPath.Append(sAssemblyManifestFileName);
                    
            ::CopyFile(sAssemblyGACPath._pwz, sPrivateAssemblyPath._pwz, FALSE);

            //copy all file dependecies of the assembly as well
            nIndex = 0;
            while (pManifestNode->GetNextFile(nIndex++, &pFileInfo) == S_OK)
            {
                if(FAILED(pFileInfo->Get(MAN_INFO_ASM_FILE_NAME, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag)))
                    goto exit;
                sRelativeFilePath.TakeOwnership(pwzBuf, ccBuf);

                sFileGACPath.Assign(sAssemblyGACDir);
                sFileGACPath.Append(sRelativeFilePath);

                sFilePrivatePath.Assign(sPrivateAssemblyDir);
                sFilePrivatePath.Append(sRelativeFilePath);

                CreateDirectoryHierarchy(sPrivateAssemblyDir._pwz, sRelativeFilePath._pwz);
                ::CopyFile(sFileGACPath._pwz, sFilePrivatePath._pwz, FALSE);
            }

        //update the manifestnode's FileName field with the new relative path wrt the Appbase
        pManifestNode->SetManifestFilePath(sPrivateAssemblyPath._pwz + g_sAppBase._cc - 1);
        pManifestNode->SetManifestType(PRIVATE_ASSEMBLY);

        SAFERELEASE(pAssemblyId);
    }
    }

exit:

    SAFERELEASE(pAsmCache);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
//GetInitialDependencies
/////////////////////////////////////////////////////////////////////////
//Bugbug, Big Avalon Hack
HRESULT GetInitialDependencies(LPWSTR pwzTemplatePath, List<ManifestNode *> *pManifestList)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument2 *pXMLDoc = NULL;
    IXMLDOMNode *pRootNode = NULL, *pSearchNode = NULL;
    BSTR bstrSearchString=NULL;
    ManifestNode *pManifestNode = NULL;

    WCHAR pwzPath[MAX_PATH];
    ASSEMBLY_INFO asmInfo;
    IAssemblyCache *pAsmCache = NULL;
    IAssemblyManifestImport *pManImport = NULL;

    if(FAILED(hr = LoadXMLDocument(pwzTemplatePath, &pXMLDoc)))
        goto exit;

    if(FAILED(hr = pXMLDoc->get_firstChild(&pRootNode)))
        goto exit;

    bstrSearchString = ::SysAllocString(L"//shellState[@entryImageType=\"avalon\"]");
    if (!bstrSearchString)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    if (FAILED(hr = pRootNode->selectSingleNode(bstrSearchString, &pSearchNode)))
    {
        hr = S_FALSE;
        goto exit;
    }

    if (pSearchNode)
    {
        // Try to find the assembly in the GAC.
        memset(&asmInfo, 0, sizeof(asmInfo));
        asmInfo.pszCurrentAssemblyPathBuf = pwzPath;
        asmInfo.cchBuf = MAX_PATH;

        if (FAILED(hr = CreateFusionAssemblyCache(&pAsmCache)))
            goto exit;

        if ((hr = pAsmCache->QueryAssemblyInfo(0, L"Avalon.Application", &asmInfo)) == S_OK) 
        {
            if ((hr = CreateAssemblyManifestImport(&pManImport, asmInfo.pszCurrentAssemblyPathBuf, NULL, 0)) != S_OK)
                goto exit;
         
            pManifestNode = new ManifestNode(pManImport, 
                                      NULL, 
                                      asmInfo.pszCurrentAssemblyPathBuf, 
                                      GAC_ASSEMBLY);
            pManifestList->AddTail(pManifestNode);
        }
        else
        {
            hr = S_FALSE;
            fprintf(stderr, "Warning: Cannot find Avalon Runtime in GAC\n");
        }
    }
    
exit:
    if (bstrSearchString)
        ::SysFreeString(bstrSearchString);
    SAFERELEASE(pSearchNode);
    SAFERELEASE(pRootNode);
    SAFERELEASE(pXMLDoc);
    SAFERELEASE(pManImport);
    SAFERELEASE(pAsmCache);

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CreateSubscriptionManifest
/////////////////////////////////////////////////////////////////////////
HRESULT CreateSubscriptionManifest(LPWSTR pwzApplicationManifestPath, 
    LPWSTR pwzSubscriptionManifestPath, LPWSTR pwzURL, LPWSTR pwzPollingInterval)
{
    HRESULT hr = S_OK;
    IAssemblyManifestImport *pManImport = NULL;
    IAssemblyIdentity *pAppAssemblyId = NULL;
    CString sSubAssemblyName, sSubcriptionFilePath;
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf = NULL;

    //createmanifest on the input file
    if(FAILED(hr = CreateAssemblyManifestImport(&pManImport, pwzApplicationManifestPath, NULL, 0)))
        goto exit;

    if((hr = pManImport->GetAssemblyIdentity(&pAppAssemblyId)) != S_OK)
    {
        hr = E_FAIL;
        goto exit; 
     }     

    //grab the name of the assembly
    //appended with ".subscription", this will be the subscription manifest name
    if(FAILED(hr = pAppAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, 
            &pwzBuf, &ccBuf)))
        goto exit;
    sSubAssemblyName.TakeOwnership(pwzBuf, ccBuf);
    sSubAssemblyName.Append(L".subscription");

    sSubcriptionFilePath.Assign(pwzSubscriptionManifestPath);
    sSubcriptionFilePath.Append(sSubAssemblyName);

    if(FAILED(hr = CreateDirectoryHierarchy(sSubcriptionFilePath._pwz, NULL)))
        goto exit;
    
   if(FAILED(hr = CreateXMLSubscriptionManifest(sSubcriptionFilePath._pwz, pAppAssemblyId, pwzURL, pwzPollingInterval)))
        goto exit;

exit:
    SAFERELEASE(pManImport);
    SAFERELEASE(pAppAssemblyId);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// PrintDependencies
/////////////////////////////////////////////////////////////////////////
HRESULT PrintDependencies(List <LPWSTR> *pRawFileList, List<ManifestNode *> *pUniqueManifestList)
{
    HRESULT hr = S_OK;
    LPWSTR pwzBuf = NULL, pwz= NULL;
    DWORD dwType = 0;
    ManifestNode *pManifestNode = NULL;
    LISTNODE pos;
    
    pos = pRawFileList->GetHeadPosition();
    while(pos)
    {
        pwzBuf = pRawFileList->GetNext(pos);
        fprintf(stderr, "Raw File : %ws\n", pwzBuf);
    }

    pos = pUniqueManifestList->GetHeadPosition();
    while(pos)
    {
        pManifestNode = pUniqueManifestList->GetNext(pos);
        pManifestNode->GetManifestFilePath(&pwzBuf);
        pManifestNode->GetManifestType(&dwType);
        if (dwType == PRIVATE_ASSEMBLY)
            fprintf(stderr, "Manifest : %ws\n", pwzBuf);
        else
        {
            pwz = StrRChr(pwzBuf, NULL, L'\\') + 1;
            fprintf(stderr, "GAC Manifest : %ws\n", pwz);
        }
        SAFEDELETEARRAY(pwzBuf);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////
// UsageTopLevel
/////////////////////////////////////////////////////////////////////////
HRESULT UsageTopLevel()
{
    printf("Manifest Generator Usage: \n"
             "mg -<mode> [<param_name>:<param_value>  ... ]\n"
             "Modes supported in mg\n"
             "t: Generate Template File Mode\n"
             "l: List Mode\n"
             "d: List Dependency Mode\n"
             "s: Subscription Manifest Gereration Mode \n"
             "m: Manifest Generation Mode\n\n"
             "For help on a Mode, Use \"mg -<mode> help\"  \n"
             "Valid <param_name>:<param_value> pairs \n"
             "sd:<source_directory_path> \n"
             "td:<target_dir> \n"
             "dd:<dependency_dir> \n"
             "tf:<template_file_path> \n"
             "smd:<subscription_dir>  \n"
             "amf:<app_man_file>  \n"
             "amu:<app_man_URL>  \n"
             "si:<sync_interval> \n"
             "WRN:allow -- meaning allow warnings. Deafault is exit on warnings.\n"
             "GAC:follow -- meaning follow dependencies on GAC. Default is don't probe for dependencies in GAC\n"
             "SYS:copy -- copy dependent system assemblies from GAC to target dir\n"
             );
             return S_OK;
}


/////////////////////////////////////////////////////////////////////////
// UsageCmdTemplate
/////////////////////////////////////////////////////////////////////////
HRESULT UsageCmdTemplate()
{
    printf("Usage: \n"
             "Template Mode:\n"
             "mg -t tf:<file_path>\n\n"
             "\t<file_path> = path where template manifest will be created.\n\n"
             );
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
// UsageCmdList
/////////////////////////////////////////////////////////////////////////
HRESULT UsageCmdList()
{
    printf("Usage: \n"
             "List Mode:\n"
             "mg -l sd:<source_directory_path> [tf:<template_file_path>] [dd:<dependency_dir>  \n\n"
             "\t[source_directory_path] = path of Application to chase dependencies\n"
             "\toptional: <template_file_path> = path of Template file\n"
             "\toptional : <dependency_dir> = user defined dependency dir where some dependencies could be found\n\n"
             );
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////
// UsageCmdDependencyList
/////////////////////////////////////////////////////////////////////////
HRESULT UsageCmdDependencyList()
{
    printf("Usage: \n"
             "List Dependency Mode:\n"
             "mg -d sd:<source_directory_path>  [dd:<dependency_dir>  \n\n"
             "\t<source_directory path> = path of Application to chase dependencies\n\n"
             "\toptional : <dependency_dir> = user defined dependency dir where some dependencies could be found\n\n"
             );
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////
// UsageCmdSubscription
/////////////////////////////////////////////////////////////////////////
HRESULT UsageCmdSubscription()
{
    printf("Usage: \n"
             "Subscription Manifest Gereration Mode:\n"
             "mg -s smd:<subscription_dir> amf:<app_man_file> amu:<app_man_URL> [si:<sync_interval>] \n\n"
             "\t<subscription_dir> = path where subscription manifest will be created\n"
             "\t<app_man_file> = path to the Application manifest you wish to generate a subscription for\n"
             "\t<app_man_URL] = URL of application manifest\n"
             "\toptional: <sync_interval] = syncronize interval in hours\n\n"
             );
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
// UsageCmdManifest
/////////////////////////////////////////////////////////////////////////
HRESULT UsageCmdManifest()
{
    printf("Usage: \n"
             "Manifest Generation Mode:\n"
             "mg -m sd:<source_dir> td:<target_dir> tf:<template_file> [dd:<dependency_dir>]\n\n"
             "\t<source_dir> = path of the Application of which you want to generate a manifest for\n"
             "\t<target_dir> = path to which all app files and dependencies will be copied\n"
             "\t<template_file> = path of requried input Template file\n"
             "\toptional : <dependency_dir> = user defined dependency dir where some dependencies could be found\n\n"
             );
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
// UsageAll
/////////////////////////////////////////////////////////////////////////
HRESULT UsageAll()
{
    // call all above functions
    return S_OK;
}

HRESULT UsageCommand(COMMAND_MODE CmdMode)
{
    switch(CmdMode)
    {
    case CmdTemplate:
        UsageCmdTemplate();
        break;

    case CmdList:
        UsageCmdList();
        break;

    case CmdDependencyList:
        UsageCmdDependencyList();
        break;

    case CmdSubscription:
        UsageCmdSubscription();
        break;

    case CmdManifest:
        UsageCmdManifest();
        break;

    default :
        UsageTopLevel();
    }

    return S_OK;
}

HRESULT GetDir( LPWSTR pszSrc, LPWSTR *ppwzDir, BOOL bExists) 
{
    return PathNormalize(pszSrc, ppwzDir, DIRECTORY_PATH, bExists);
}

HRESULT GetFile( LPWSTR pszSrc, LPWSTR *ppwzFile, BOOL bExists)
{
    return PathNormalize(pszSrc, ppwzFile, FILE_PATH, bExists);
}

/////////////////////////////////////////////////////////////////////////
// ParseCommandLineArgs
/////////////////////////////////////////////////////////////////////////
HRESULT  ParseCommandLineArgs(int            argc, 
                              WCHAR          **argv, 
                              COMMAND_MODE & CmdMode
                              )
{
    HRESULT hr = S_OK;
    LPWSTR  pszBuf=NULL;

    if(argc < 2)
    {
        hr = E_FAIL;
        goto exit;
    }

    if ( !StrCmpI(argv[1], L"-t"))
    {
        CmdMode = CmdTemplate;
    }
    else if ( !StrCmpI(argv[1], L"-l"))
    {
        CmdMode = CmdList;
    }
    else if ( !StrCmpI(argv[1], L"-d"))
    {
        CmdMode = CmdDependencyList;
    }
    else if ( !StrCmpI(argv[1], L"-s"))
    {
        CmdMode = CmdSubscription;
    }
    else if ( !StrCmpI(argv[1], L"-m"))
    {
        CmdMode = CmdManifest;
    }
    else
    {
        hr = E_FAIL;
        goto exit;
    }

    int currArg = 2;
    LPWSTR pwzParamName;
    LPWSTR pwzParamValue;

    while ( currArg < argc)
    {
        pwzParamName = argv[currArg];

        if(pwzParamValue = StrChr(pwzParamName, L':'))
        {
            *pwzParamValue = L'\0';
            pwzParamValue++;
        }

        if( (!pwzParamValue) || !lstrlen(pwzParamValue) )
        {
            if ( StrCmpI(pwzParamName, L"help"))
                printf(" Param Value not specified for \"%s\" \n", pwzParamName);
            hr = E_FAIL;
            goto exit;
        }

        if ( !StrCmpI(pwzParamName, L"sd"))
        {
            if(FAILED(hr = GetDir(pwzParamValue, &pszBuf, TRUE)))
                goto exit;

            g_sAppBase.Assign(pszBuf);

            g_sDeployDirs[g_dwDeployDirs++].Assign(pszBuf);
        }
        else if ( !StrCmpI(pwzParamName, L"td"))
        {
            if(FAILED(hr = GetDir(pwzParamValue, &pszBuf, TRUE)))
                goto exit;

            g_sTargetDir.Assign(pszBuf);
        }
        else if ( !StrCmpI(pwzParamName, L"dd"))
        {
            if(FAILED(hr = GetDir(pwzParamValue, &pszBuf, TRUE)))
                goto exit;

            g_sDeployDirs[g_dwDeployDirs++].Assign(pszBuf);
        }
        else if ( !StrCmpI(pwzParamName, L"tf"))
        {
            if(FAILED(hr = GetFile(pwzParamValue, &pszBuf, TRUE)))
                goto exit;

            g_sTemplateFile.Assign(pszBuf);
        }
        else if ( !StrCmpI(pwzParamName, L"amu"))
        {
            g_sAppManifestURL.Assign(pwzParamValue);
        }
        else if ( !StrCmpI(pwzParamName, L"si"))
        {
            g_sPollingInterval.Assign(pwzParamValue);
        }
        else if ( !StrCmpI(pwzParamName, L"smd"))
        {
            if(FAILED(hr = GetDir(pwzParamValue, &pszBuf, TRUE)))
                goto exit;

            g_sSubscriptionManifestDir.Assign(pszBuf);
        }
        else if ( !StrCmpI(pwzParamName, L"amf"))
        {
            if(FAILED(hr = GetFile(pwzParamValue, &pszBuf, TRUE)))
                goto exit;

            g_sAppManifestFile.Assign(pszBuf);
        }
        else if ( !StrCmpI(pwzParamName, L"WRN"))
        {
            g_bFailOnWarnings = 0;
        }
        else if ( !StrCmpI(pwzParamName, L"GAC"))
        {
            g_bLookInGACForDependencies = 1;
        }
        else if ( !StrCmpI(pwzParamName, L"SYS"))
        {
            g_bCopyDependentSystemAssemblies = 1;
        }
        else
        {
            hr = E_FAIL;
            goto exit;
        }

        currArg++;

        SAFEDELETEARRAY(pszBuf);
    }


exit:

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// wmain
/////////////////////////////////////////////////////////////////////////
int __cdecl wmain(int argc, WCHAR **argv)
{
    HRESULT hr = S_OK;
    BOOL bCoInitialized = TRUE;
    List<ManifestNode *> ManifestList;
    List<ManifestNode *> UniqueManifestList;
    List<LPWSTR> AssemblyFileList[HASHTABLE_SIZE];
    List<LPWSTR> RawFiles;
    DWORD dwType=0;
    ManifestNode *pManifestNode = NULL;
    LISTNODE pos;
    BOOL bListMode = FALSE;

    LPWSTR  pwzBuf=NULL;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        bCoInitialized = FALSE;
        goto exit;
    }

    COMMAND_MODE CmdMode = CmdUsage;

    // Parse
    if(FAILED(hr =  ParseCommandLineArgs(argc,  argv, CmdMode)))
    {
        UsageCommand(CmdMode);
        hr = S_OK;
        goto exit;
    }
    
    // execute
    switch(CmdMode)
    {
    case CmdTemplate:
            if(g_sTemplateFile._cc <= 1)
            {
                hr = E_INVALIDARG;
                goto exit;
            }

        hr = CreateAppManifestTemplate(g_sTemplateFile._pwz);
         break;

    case CmdDependencyList:

            bListMode = TRUE;
            // continue with CmdList.....
    case CmdList:
        {
            if(g_sAppBase._cc <= 1)
            {
                hr = E_INVALIDARG;
                goto exit;
            }

            if(g_sTemplateFile._cc >= 1)
            {
                if(FAILED(hr = GetInitialDependencies(g_sTemplateFile._pwz, &ManifestList)))
                    goto exit;
            }

            if(FAILED(hr = FindAllAssemblies(g_sAppBase._pwz, &ManifestList)))
                goto exit;
            if(FAILED(hr = TraverseManifestDependencyTrees(&ManifestList, AssemblyFileList, &UniqueManifestList, bListMode)))
                goto exit;
            if(FAILED(hr = CrossReferenceFiles(g_sAppBase._pwz, AssemblyFileList, &RawFiles)))
                goto exit;

            if(!bListMode)
            {
                if(FAILED(hr = PrintDependencies(&RawFiles, &UniqueManifestList)))
                    goto exit;
            }
        }
        break;

    case CmdManifest:
        {
            if((g_sAppBase._cc <= 1)
               || (g_sTemplateFile._cc <= 1)
               || (g_sTargetDir._cc <= 1)\
               || !StrCmpI(g_sAppBase._pwz, g_sTargetDir._pwz))
            {
                hr = E_INVALIDARG;
                goto exit;
            }

            if(FAILED(hr = GetInitialDependencies(g_sTemplateFile._pwz, &ManifestList)))
                goto exit;
            if(FAILED(hr = FindAllAssemblies(g_sAppBase._pwz, &ManifestList)))
                goto exit;        
            if(FAILED(hr = TraverseManifestDependencyTrees(&ManifestList, AssemblyFileList, &UniqueManifestList, FALSE)))
                goto exit;   
            if(FAILED(hr = CrossReferenceFiles(g_sAppBase._pwz, AssemblyFileList, &RawFiles)))
                goto exit;
            if(FAILED(hr = CopyFilesToTargetDir(&UniqueManifestList, &RawFiles)))
                goto exit;
            if(FAILED(hr = CreateXMLAppManifest(g_sTargetDir._pwz, g_sTemplateFile._pwz, &UniqueManifestList, &RawFiles)))
                goto exit;
        }
        break;

    case CmdSubscription:

        if((g_sAppManifestFile._cc <= 1)
           || (g_sSubscriptionManifestDir._cc <= 1)
           || (g_sAppManifestURL._cc <= 1))
        {
          hr = E_INVALIDARG;
          goto exit;
        }

        if(g_sPollingInterval._cc <= 1)
        {
            g_sPollingInterval.Assign(DEFAULT_POLLING_INTERVAL);
        }

        hr = CreateSubscriptionManifest(g_sAppManifestFile._pwz,
                                        g_sSubscriptionManifestDir._pwz, 
                                        g_sAppManifestURL._pwz,
                                        g_sPollingInterval._pwz);
        break;

    default :
        hr = E_FAIL;
        goto exit;
    }
    
exit:

     // Clean up hash table
    for (int i = 0; i < HASHTABLE_SIZE; i++)
    {
         pos = AssemblyFileList[i].GetHeadPosition();
         while (pos)
         {
             pwzBuf = AssemblyFileList[i].GetNext(pos);
             SAFEDELETEARRAY(pwzBuf);
         }

         AssemblyFileList[i].RemoveAll();
     }

     //clean up Rawfilelist
    pos = RawFiles.GetHeadPosition();
    while (pos)
    {
        pwzBuf = RawFiles.GetNext(pos);
        SAFEDELETEARRAY(pwzBuf);
    }
    RawFiles.RemoveAll();
     
    // clean up ManifestList
    pos = ManifestList.GetHeadPosition();
    while (pos)
    {
        pManifestNode = ManifestList.GetNext(pos);
        SAFEDELETE(pManifestNode);
    }
    ManifestList.RemoveAll();

    // clean up UniqueManifestList
    pos = UniqueManifestList.GetHeadPosition();
    while (pos)
    {
        pManifestNode = UniqueManifestList.GetNext(pos);
        SAFEDELETE(pManifestNode);
    }
    UniqueManifestList.RemoveAll();


    if (bCoInitialized)
        CoUninitialize();

    if (FAILED(hr))
    {
         fprintf(stderr, "\nFailed with code 0x%x \n", hr);
         UsageCommand(CmdMode);

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\mg\manifestnode.cpp ===
#include <windows.h>
#include "ManifestNode.h"

/////////////////////////////////////////////////////////////////////////
// ctor
/////////////////////////////////////////////////////////////////////////
ManifestNode::ManifestNode(IAssemblyManifestImport *pManifestImport, 
                           LPWSTR pwzSrcRootDir, 
                           LPWSTR pwzFilePath,
                           DWORD dwType)
{
    _pManifestImport = pManifestImport;
    _pManifestImport->AddRef();

    _dwType = dwType;

    if (pwzSrcRootDir)
    {
        _pwzSrcRootDir = new WCHAR[lstrlen(pwzSrcRootDir)+1];
        if(_pwzSrcRootDir)
            lstrcpyW(_pwzSrcRootDir, pwzSrcRootDir);
    }
    else
    {
        _pwzSrcRootDir = NULL;  

    }

    if (pwzFilePath)
    {
        _pwzFilePath = new WCHAR[lstrlen(pwzFilePath)+1];
        if(_pwzFilePath)
            lstrcpyW(_pwzFilePath, pwzFilePath);
    }
    else
    {
        _pwzFilePath = NULL;  

    }

}

/////////////////////////////////////////////////////////////////////////
// dtor
/////////////////////////////////////////////////////////////////////////
ManifestNode::~ManifestNode()
{
    SAFERELEASE(_pManifestImport);
    SAFEDELETEARRAY(_pwzSrcRootDir);
    SAFEDELETEARRAY(_pwzFilePath);
}

/////////////////////////////////////////////////////////////////////////
// GetNextAssembly
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::GetNextAssembly(DWORD index, IManifestInfo **ppManifestInfo)
{
    HRESULT hr = S_OK;

    hr = _pManifestImport->GetNextAssembly(index, ppManifestInfo);
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// GetNextFile
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::GetNextFile(DWORD index, IManifestInfo **ppManifestInfo)
{
    HRESULT hr = S_OK;

    hr = _pManifestImport->GetNextFile(index, ppManifestInfo);

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// GetManifestFilePath
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::GetSrcRootDir(LPWSTR *pwzFileName)
{
    HRESULT hr = S_OK;

    if(_pwzSrcRootDir)
        (*pwzFileName) = WSTRDupDynamic(_pwzSrcRootDir);
    else
        hr = S_FALSE;

    return hr;
}


/////////////////////////////////////////////////////////////////////////
// GetManifestFilePath
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::GetManifestFilePath(LPWSTR *pwzFileName)
{
    HRESULT hr = S_OK;

    if(_pwzFilePath)
        (*pwzFileName) = WSTRDupDynamic(_pwzFilePath);
    else
        hr = S_FALSE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// GetAssemblyIdentity
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::IsEqual(ManifestNode *pManifestNode)
{
    HRESULT hr = S_OK;
    IAssemblyIdentity *pAsmId1=NULL, *pAsmId2=NULL;

    if (FAILED(hr = _pManifestImport->GetAssemblyIdentity(&pAsmId1)))
        goto exit;
    if (FAILED(hr = pManifestNode->GetAssemblyIdentity(&pAsmId2)))
        goto exit;

    hr = pAsmId1->IsEqual(pAsmId2);
    
exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// GetAssemblyIdentity
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::GetAssemblyIdentity(IAssemblyIdentity **ppAsmId)
{
    HRESULT hr = S_OK;

    hr = _pManifestImport->GetAssemblyIdentity(ppAsmId);

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// GetManifestType
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::GetManifestType(DWORD *pdwType)
{
    HRESULT hr = S_OK;
    *pdwType = _dwType;
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// SetManifestFileName
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::SetSrcRootDir(LPWSTR pwzFilePath)
{
    HRESULT hr = S_OK;  
    SAFEDELETEARRAY(_pwzSrcRootDir);
    _pwzSrcRootDir = WSTRDupDynamic(pwzFilePath);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// SetManifestFileName
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::SetManifestFilePath(LPWSTR pwzFilePath)
{
    HRESULT hr = S_OK;  
    SAFEDELETEARRAY(_pwzFilePath);
    _pwzFilePath = WSTRDupDynamic(pwzFilePath);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// SetManifestType
/////////////////////////////////////////////////////////////////////////
HRESULT ManifestNode::SetManifestType(DWORD dwType)
{
    HRESULT hr = S_OK;
    _dwType = dwType;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\lv\lv.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  File:       fuslogvw.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    25 Mar 97   t-alans (Alan Shi)   Created
//              12 Jan 00   AlanShi (Alan Shi)   Copied from cdllogvw
//              30 May 00   AlanShi (Alan Shi)   Modified to show date/time
//              01 Dec 00   AlanShi (Alan Shi)   Added application name field
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <wininet.h>
#include <commctrl.h>
#include "cdlids.h"
#include "wininet.h"

#define URL_SEARCH_PATTERN             "?ClickOnceErrorLog!exe="
#define FILESPEC_SEARCH_PATTERN        TEXT("?ClickOnceErrorLog!exe=")
#define DELIMITER_CHAR                 '!'
#define MAX_CACHE_ENTRY_INFO_SIZE      2048
#define MAX_DATE_LEN                   64
#define MAX_RES_TEXT_LEN               1024

#define XSP_APP_CACHE_DIR              TEXT("Temporary ASP.NET Files")
#define XSP_FUSION_LOG_DIR             TEXT("Bind Logs")
#define REG_KEY_FUSION_SETTINGS     TEXT("Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\")
#define REG_VAL_FUSION_LOG_PATH        TEXT("LogPath")
#define REG_VAL_FUSION_LOG_FAILURES    TEXT("LogFailures")

#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

typedef enum tagLogLocation {
    LOG_DEFAULT,
    LOG_XSP,
    LOG_CUSTOM
} LogLocation;

LogLocation g_LogLocation;
TCHAR g_szCustomLogPath[MAX_PATH];
TCHAR g_szXSPLogPath[MAX_PATH];
HINSTANCE g_hInst;

typedef HRESULT(*PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);

LRESULT CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
void ViewLogEntry(HWND hwnd);
void RefreshLogView(HWND hwnd, LogLocation logLocation);
void RefreshCustomView(HWND hwnd, LPCTSTR szPath);
void RefreshWininetView(HWND hwnd);
void DeleteLogEntry(HWND hwnd);
void DeleteAllLogs(HWND hwnd);
void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf);
void InitListView(HWND hwndLV);
void InitText(HWND hwnd);
void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo);
void AddLogItemCustom(HWND hwndLV, WIN32_FIND_DATA *pfindData);
void InitCustomLogPaths();
BOOL InsertCustomLogEntry(LPTSTR szFilePath, HWND hwndLV);
BOOL GetCorSystemDirectory(LPTSTR szCorSystemDir);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   PSTR szCmdLine, int iCmdShow)
{
    g_hInst = hInstance;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_CDLLOGVIEW), NULL, DlgProc);

    return 0;
}

LRESULT CALLBACK DlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND                                 hwndLV;
    HWND                                 hwndRBDefault;
    LPNMHDR                              pnmh = NULL;
    LONG                                 lResult;
    LONG                                 lState;
    HKEY                                 hkey;
    DWORD                                dwLogFailures = 0;
    DWORD                                dwSize;
    DWORD                                dwType;

    switch (iMsg) {
        case WM_INITDIALOG:
            hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
            InitListView(hwndLV);

            hwndRBDefault = GetDlgItem(hwnd, IDC_RADIO_DEFAULT);
            SendMessage(hwndRBDefault, BM_SETCHECK, BST_CHECKED, 0);

            g_LogLocation = LOG_DEFAULT;

            InitCustomLogPaths();
            InitText(hwnd);

            RefreshLogView(hwnd, g_LogLocation);

            lResult = RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
            if (lResult == ERROR_SUCCESS) {
                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_FAILURES, NULL,
                                          &dwType, (LPBYTE)&dwLogFailures, &dwSize);
                RegCloseKey(hkey);
            }

            if (dwLogFailures) {
                SendMessage(GetDlgItem(hwnd, IDC_CB_ENABLELOG), BM_SETCHECK, 1, 0);
            }
            else {
                SendMessage(GetDlgItem(hwnd, IDC_CB_ENABLELOG), BM_SETCHECK, 0, 0);
            }

            // Test for read/write access, and grey out if can't change

            lResult = RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_ALL_ACCESS, &hkey);
            if (lResult == ERROR_SUCCESS) {
                RegCloseKey(hkey);
            }
            else {
                EnableWindow(GetDlgItem(hwnd, IDC_CB_ENABLELOG), FALSE);
            }

            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;
                case IDC_CB_VIEWLOG:
                    ViewLogEntry(hwnd);
                    break;

                case IDC_CB_REFRESH:
                    RefreshLogView(hwnd, g_LogLocation);
                    break;

                case IDC_CB_DELETE:
                    DeleteLogEntry(hwnd);
                    break;

                case IDC_CB_DELETE_ALL:
                    DeleteAllLogs(hwnd);
                    break;

                case IDC_RADIO_DEFAULT:
                    if (g_LogLocation == LOG_DEFAULT) {
                        // No change
                        break;
                    }

                    g_LogLocation = LOG_DEFAULT;
                    RefreshLogView(hwnd, g_LogLocation);

                    break;

                case IDC_RADIO_XSP:
                    if (g_LogLocation == LOG_XSP) {
                        // No change
                        break;
                    }

                    g_LogLocation = LOG_XSP;
                    RefreshLogView(hwnd, g_LogLocation);
                    break;

                case IDC_RADIO_CUSTOM:
                    if (g_LogLocation == LOG_CUSTOM) {
                        // No change
                        break;
                    }

                    g_LogLocation = LOG_CUSTOM;
                    RefreshLogView(hwnd, g_LogLocation);
                    break;
               
                    /*
               case IDC_CB_ENABLELOG:
                    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_ALL_ACCESS, &hkey);
                    if (lResult == ERROR_SUCCESS) {
                        lState = SendMessage(GetDlgItem(hwnd, IDC_CB_ENABLELOG),
                                              BM_GETCHECK, 0, 0);
                        dwLogFailures = (lState == BST_CHECKED) ? (1) : (0);

                        RegSetValueEx(hkey, REG_VAL_FUSION_LOG_FAILURES, 0,
                                      REG_DWORD, (BYTE*)&dwLogFailures, sizeof(dwLogFailures));

                        RegCloseKey(hkey);
                    }
                    break;
                    */
            }

            return TRUE;

        case WM_NOTIFY:
            if (wParam == IDC_LV_LOGMESSAGES) {
                pnmh = (LPNMHDR)lParam;

                if (pnmh->code == LVN_ITEMACTIVATE) {
                    // Double click (or otherwise activated)
                    ViewLogEntry(hwnd);
                }
            }

            return TRUE;
    }

    return FALSE;
}

void DeleteLogEntry(HWND hwnd)
{
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    HWND                            hwndLV;
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szDispNameBuf[INTERNET_MAX_URL_LENGTH];
    char                            szEXEBuf[MAX_PATH];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
    
    lIndex = ListView_GetSelectionMark(hwndLV);

    ListView_GetItemText(hwndLV, lIndex, 0, szEXEBuf, MAX_PATH);
    ListView_GetItemText(hwndLV, lIndex, 2, szDispNameBuf, INTERNET_MAX_URL_LENGTH);

    if (g_LogLocation == LOG_DEFAULT) {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s%s!name=%s", URL_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
        
        pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    
        if (DeleteUrlCacheEntry(szUrl)) {
            RefreshLogView(hwnd, g_LogLocation);
        }
        else {
            MessageBox(hwnd, "Error: Unable to delete cache file!",
                       "Log View Error", MB_OK | MB_ICONERROR);
        }
    }
    else {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s\\%s\\%s%s!name=%s.htm",
                  ((g_LogLocation == LOG_XSP) ? (g_szXSPLogPath) : (g_szCustomLogPath)),
                  szEXEBuf, FILESPEC_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
        if (!DeleteFile(szUrl)) {
            MessageBox(hwnd, "Error: Unable to delete cache file!",
                       "Log View Error", MB_OK | MB_ICONERROR);
        }

        RefreshLogView(hwnd, g_LogLocation);
    }
}

void DeleteAllLogs(HWND hwnd)
{
    HWND                            hwndLV;
    char                            szDispNameBuf[INTERNET_MAX_URL_LENGTH];
    char                            szEXEBuf[MAX_PATH];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    int                             iCount;
    int                             i;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    iCount = ListView_GetItemCount(hwndLV);
    for (i = 0; i < iCount; i++) {
        ListView_GetItemText(hwndLV, i, 0, szEXEBuf, MAX_PATH);
        ListView_GetItemText(hwndLV, i, 2, szDispNameBuf, INTERNET_MAX_URL_LENGTH);
    
        if (g_LogLocation == LOG_DEFAULT) {
            wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s%s!name=%s", URL_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
        
            DeleteUrlCacheEntry(szUrl);
        }
        else {
            wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s\\%s\\%s%s!name=%s.htm",
                      ((g_LogLocation == LOG_XSP) ? (g_szXSPLogPath) : (g_szCustomLogPath)),
                      szEXEBuf, FILESPEC_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
            if (!DeleteFile(szUrl)) {
                MessageBox(hwnd, "Error: Unable to delete cache file!",
                           "Log View Error", MB_OK | MB_ICONERROR);
            }
        }
    }

    RefreshLogView(hwnd, g_LogLocation);
}

void ViewLogEntry(HWND hwnd)
{
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    HWND                            hwndLV;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szDispNameBuf[INTERNET_MAX_URL_LENGTH];
    char                            szEXEBuf[MAX_PATH];
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    lIndex = ListView_GetSelectionMark(hwndLV);
    ListView_GetItemText(hwndLV, lIndex, 0, szEXEBuf, MAX_PATH);
    ListView_GetItemText(hwndLV, lIndex, 2, szDispNameBuf, INTERNET_MAX_URL_LENGTH);
    
    if (g_LogLocation == LOG_DEFAULT) {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s%s!name=%s", URL_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
    
        pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    
        if (GetUrlCacheEntryInfo(szUrl, pCacheEntryInfo, &dwBufferSize)) {
            if (pCacheEntryInfo->lpszLocalFileName != NULL) {
                if (ShellExecute(NULL, "open",  pCacheEntryInfo->lpszLocalFileName,
                                 NULL, NULL, SW_SHOWNORMAL ) <= (HINSTANCE)32) {
                    // ShellExecute returns <= 32 if error occured
                    MessageBox(hwnd, TEXT("Error: Unable to open cache file!"),
                                TEXT("Log View Error"), MB_OK | MB_ICONERROR);
                }
            }
            else {
                    MessageBox(hwnd, TEXT("Error: No file name available!"),
                               TEXT("Log View Error"), MB_OK | MB_ICONERROR);
            }
        }
    }
    else {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s\\%s\\%s%s!name=%s.htm",
                  ((g_LogLocation == LOG_XSP) ? (g_szXSPLogPath) : (g_szCustomLogPath)),
                  szEXEBuf, FILESPEC_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);

        if (ShellExecute(NULL, "open", szUrl,
                         NULL, NULL, SW_SHOWNORMAL ) <= (HINSTANCE)32) {
            // ShellExecute returns <= 32 if error occured
            MessageBox(hwnd, TEXT("Error: Unable to open cache file!"),
                        TEXT("Log View Error"), MB_OK | MB_ICONERROR);
        }
    }
        
}

void RefreshLogView(HWND hwnd, LogLocation logLocation)
{
    HWND                        hwndLV;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    switch (logLocation) {
        case LOG_DEFAULT:
            RefreshWininetView(hwnd);
            break;

        case LOG_XSP:
            if (lstrlen(g_szXSPLogPath)) {
                RefreshCustomView(hwnd, g_szXSPLogPath);
            }
            else {
                ListView_DeleteAllItems(hwndLV);
            }

            break;

        case LOG_CUSTOM:
            if (lstrlen(g_szCustomLogPath)) {
                RefreshCustomView(hwnd, g_szCustomLogPath);
            }
            else {
                hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
                ListView_DeleteAllItems(hwndLV);
            }
            break;
    }
}

void RefreshCustomView(HWND hwnd, LPCTSTR szPath)
{
    HANDLE                              hFile = INVALID_HANDLE_VALUE;
    TCHAR                               szSearchSpec[MAX_PATH];
    TCHAR                               szFileName[MAX_PATH];
    HWND                                hwndLV;
    WIN32_FIND_DATA                     findData;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
    ListView_DeleteAllItems(hwndLV);

#ifdef UNICODE
    wnsprintfW(szSearchSpec, MAX_PATH, L"%ws\\*.*", szPath);
#else
    wnsprintfA(szSearchSpec, MAX_PATH, "%s\\*.*", szPath);
#endif

    hFile = FindFirstFile(szSearchSpec, &findData);
    if (hFile == INVALID_HANDLE_VALUE) {
        goto Exit;
    }

    if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lstrcmp(findData.cFileName, TEXT("."))) &&
        (lstrcmp(findData.cFileName, TEXT("..")))) {

#ifdef UNICODE
        wnsprintfW(szFileName, MAX_PATH, L"%ws\\%ws", szPath, findData.cFileName);
#else
        wnsprintfA(szFileName, MAX_PATH, "%s\\%s", szPath, findData.cFileName);
#endif

        InsertCustomLogEntry(szFileName, hwndLV);
    }

    while (FindNextFile(hFile, &findData)) {
        if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (lstrcmp(findData.cFileName, TEXT("."))) &&
            (lstrcmp(findData.cFileName, TEXT("..")))) {
                
#ifdef UNICODE
            wnsprintfW(szFileName, MAX_PATH, L"%ws\\%ws", szPath, findData.cFileName);
#else
            wnsprintfA(szFileName, MAX_PATH, "%s\\%s", szPath, findData.cFileName);
#endif

            InsertCustomLogEntry(szFileName, hwndLV);
        }
    }

Exit:
    return;
}

BOOL InsertCustomLogEntry(LPTSTR szFilePath, HWND hwndLV)
{
    BOOL                                bRet = TRUE;
    HANDLE                              hFile = INVALID_HANDLE_VALUE;
    TCHAR                               szSearchSpec[MAX_PATH];
    WIN32_FIND_DATA                     findData;

#ifdef UNICODE
    wnsprintfW(szSearchSpec, MAX_PATH, L"%ws\\*.htm" szFilePath);
#else
    wnsprintfA(szSearchSpec, MAX_PATH, "%s\\*.htm", szFilePath);
#endif
    
    hFile = FindFirstFile(szSearchSpec, &findData);
    if (hFile == INVALID_HANDLE_VALUE) {
        bRet = FALSE;
        goto Exit;
    }

    if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        AddLogItemCustom(hwndLV, &findData);
    }
    
    while (FindNextFile(hFile, &findData)) {
        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            continue;
        }
        
        AddLogItemCustom(hwndLV, &findData);
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return bRet;
}

void AddLogItemCustom(HWND hwndLV, WIN32_FIND_DATA *pfindData)
{
    LVITEM                          lvitem;
    LPTSTR                          szNameTag = NULL;
    LPTSTR                          szExt = NULL;
    static TCHAR                    szBuf[MAX_DATE_LEN];
    static TCHAR                    szExeBuf[MAX_PATH];

    memset(&lvitem, 0, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT;
    
    FormatDateBuffer(&pfindData->ftLastAccessTime, szBuf);

    lstrcpy(szExeBuf, pfindData->cFileName + lstrlen(FILESPEC_SEARCH_PATTERN));
    szNameTag = StrStr(szExeBuf, TEXT("!name="));
    if (!szNameTag) {
        // Fatal!
        return;
    }

    *szNameTag++ = TEXT('\0');

    szNameTag += lstrlen(TEXT("name="));
    szExt = StrStrI(szNameTag, TEXT(".htm"));
    if (szExt) {
        *szExt = TEXT('\0');
    }

    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.pszText = szExeBuf;
    lvitem.iItem = ListView_InsertItem(hwndLV, &lvitem);

    lvitem.iSubItem = 1;
    lvitem.pszText = szNameTag;
    ListView_SetItem(hwndLV, &lvitem);

    lvitem.iSubItem = 2;
    lvitem.pszText = szBuf;
    ListView_SetItem(hwndLV, &lvitem);
}

void RefreshWininetView(HWND hwnd)
{
    HANDLE                          hUrlCacheEnum;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    HWND                            hwndLV;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    ListView_DeleteAllItems(hwndLV);
    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    hUrlCacheEnum = FindFirstUrlCacheEntry(URL_SEARCH_PATTERN, pCacheEntryInfo,
                                           &dwBufferSize);
    if (hUrlCacheEnum != NULL) {
        if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
            if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                AddLogItem(hwndLV, pCacheEntryInfo);
            }
        }

        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        while (FindNextUrlCacheEntry(hUrlCacheEnum, pCacheEntryInfo,
                                     &dwBufferSize)) {
            if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
                if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                    AddLogItem(hwndLV, pCacheEntryInfo);
                }
            }

            dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        }
    }
}

void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo)
{
    LVITEM                          lvitem;
    LPSTR                           szNameTag = NULL;
    static char                     szBuf[MAX_DATE_LEN];
    static char                     szExeBuf[MAX_PATH];
    

    memset(&lvitem, 0, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT;
    
    FormatDateBuffer(&pCacheEntryInfo->LastModifiedTime, szBuf);

    lstrcpy(szExeBuf, pCacheEntryInfo->lpszSourceUrlName + lstrlen(URL_SEARCH_PATTERN));
    szNameTag = StrStr(szExeBuf, "!name=");
    if (!szNameTag) {
        // Fatal!
        return;
    }

    *szNameTag++ = TEXT('\0');

    szNameTag += lstrlen("name=");

    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.pszText = szExeBuf;
    lvitem.iItem = ListView_InsertItem(hwndLV, &lvitem);

    lvitem.iSubItem = 1;
    lvitem.pszText =  szBuf;
    ListView_SetItem(hwndLV, &lvitem);

    lvitem.iSubItem = 2;
    lvitem.pszText = szNameTag;
    ListView_SetItem(hwndLV, &lvitem);
}

void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf)
{
    SYSTEMTIME                    systime;
    FILETIME                      ftLocalLastMod;
    char                          szBufDate[MAX_DATE_LEN];
    char                          szBufTime[MAX_DATE_LEN];


    FileTimeToLocalFileTime(pftLastMod, &ftLocalLastMod);
    FileTimeToSystemTime(&ftLocalLastMod, &systime);
    
    if (!GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, szBufDate, MAX_DATE_LEN)) {
        return;
    }

    if (!GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, szBufTime, MAX_DATE_LEN)) {
        return;
    }
    
    wnsprintf(szBuf, MAX_DATE_LEN, "%s @ %s", szBufDate, szBufTime);
}

void InitListView(HWND hwndLV)
{
    LVCOLUMN                lvcol;
    TCHAR                   szText[MAX_RES_TEXT_LEN];

    memset(&lvcol, 0, sizeof(LVCOLUMN));

    lvcol.mask = LVCF_TEXT | LVCF_WIDTH;

    // Application
    
    lvcol.cx = 300;

    if (!LoadString(g_hInst, ID_FUSLOGVW_HEADER_TEXT_APPLICATION, szText, MAX_RES_TEXT_LEN)) {
        return;
    }

    lvcol.pszText = szText;
    ListView_InsertColumn(hwndLV, 0, &lvcol);


    // Date/Time

    if (!LoadString(g_hInst, ID_FUSLOGVW_HEADER_TEXT_DATE_TIME, szText, MAX_RES_TEXT_LEN)) {
        return;
    }

    lvcol.pszText = szText;
    lvcol.cx = 154;

    ListView_InsertColumn(hwndLV, 1, &lvcol);


    // Description

    if (!LoadString(g_hInst, ID_FUSLOGVW_HEADER_TEXT_DESCRIPTION, szText, MAX_RES_TEXT_LEN)) {
        return;
    }

    lvcol.cx = 100;
    lvcol.pszText = szText;

    ListView_InsertColumn(hwndLV, 2, &lvcol);

}

void InitCustomLogPaths()
{
    LONG                            lResult;
    HKEY                            hkey;
    // BOOL                            bRet;
    DWORD                           dwSize;
    DWORD                           dwAttr;
    DWORD                           dwType;
    TCHAR                           szCorSystemDir[MAX_PATH];
    // TCHAR                           szXSPAppCacheDir[MAX_PATH];

    g_szCustomLogPath[0] = L'\0';
    g_szXSPLogPath[0] = L'\0';

    // Custom log path

    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    if (lResult == ERROR_SUCCESS) {
        dwSize = MAX_PATH;
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_PATH, NULL,
                                  &dwType, (LPBYTE)g_szCustomLogPath, &dwSize);
        if (lResult == ERROR_SUCCESS) {
            PathRemoveBackslash(g_szCustomLogPath);
        }

        RegCloseKey(hkey);

        dwAttr = GetFileAttributes(g_szCustomLogPath);
        if (dwAttr == -1 || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
            g_szCustomLogPath[0] = L'\0';
        }
    }

    // XSP log path

    if (!GetCorSystemDirectory(szCorSystemDir)) {
        goto Exit;
    }

    dwSize = lstrlen(szCorSystemDir);
    if (dwSize) {
        if (szCorSystemDir[dwSize - 1] == TEXT('\\')) {
            szCorSystemDir[dwSize - 1] = TEXT('\0');
        }
    }

#ifdef UNICODE
    wnsprintfW(g_szXSPLogPath, MAX_PATH, L"%ws\\%ws\\%ws", szCorSystemDir,
               XSP_APP_CACHE_DIR, XSP_FUSION_LOG_DIR);
#else
    wnsprintfA(g_szXSPLogPath, MAX_PATH, "%s\\%s\\%s", szCorSystemDir,
               XSP_APP_CACHE_DIR, XSP_FUSION_LOG_DIR);
#endif              

    dwAttr = GetFileAttributes(g_szXSPLogPath);
    if (dwAttr == -1) {
        g_szXSPLogPath[0] = TEXT('\0');
    }

Exit:
    return;
}

void InitText(HWND hwnd)
{
    TCHAR                                    szText[MAX_RES_TEXT_LEN];

    szText[0] = L'\0';

    if (LoadString(g_hInst, ID_FUSLOGVW_DIALOG_TITLE, szText, MAX_RES_TEXT_LEN)) {
        SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM) szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_VIEW_LOG, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_VIEWLOG, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_DELETE_ENTRY, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_DELETE, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_DELETE_ALL, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_DELETE_ALL, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_REFRESH, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_REFRESH, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_EXIT, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDCANCEL, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_DEFAULT, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_DEFAULT, szText);
    }
    
    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_DEFAULT, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_DEFAULT, szText);
    }
/*
    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_ASP_NET, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_XSP, szText);
    }
*/
    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_CUSTOM, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_CUSTOM, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_CHECKBOX_ENABLELOG, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_ENABLELOG, szText);
    }
}

BOOL GetCorSystemDirectory(LPTSTR szCorSystemDir)
{
    BOOL fRet = FALSE;
    DWORD ccPath = MAX_PATH;
    WCHAR szDir[MAX_PATH];
    PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;

    HMODULE hEEShim = LoadLibrary(TEXT("mscoree.dll"));
    if (!hEEShim)
        goto exit;

    pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY) 
        GetProcAddress(hEEShim, "GetCORSystemDirectory");

    if (!pfnGetCorSystemDirectory 
        || FAILED(pfnGetCorSystemDirectory(szDir, MAX_PATH, &ccPath)))
        goto exit;

#ifdef UNICODE
    lstrcpyW(szCorSystemDir, szDir);
#else
    if (!WideCharToMultiByte(CP_ACP, 0, szDir, -1, szCorSystemDir, MAX_PATH * sizeof(TCHAR),
                             NULL, NULL)) {
        goto exit;
    }
#endif

    fRet = TRUE;

exit:
    
    if (!fRet)
    {
        FreeLibrary(hEEShim);
    }
    return fRet;
}

int 
_stdcall 
ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), 
                NULL, 
                pszCmdLine,
                (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;           // We never come here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\mg\xmlutil.h ===
#include <msxml2.h>

VOID FowardSlash(LPWSTR pwz);
HRESULT GetHash(LPCWSTR pwzFilename, LPWSTR *ppwzHash);
HRESULT CreateXMLTextNode(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzText, IXMLDOMNode **ppNode);
HRESULT CreateXMLElement(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzElementName, IXMLDOMElement **ppElement);
HRESULT SetXMLElementAttribute(IXMLDOMElement *pElement, LPWSTR pwzAttributeName, LPWSTR pwzAttributeVaule);
HRESULT CreateXMLAssemblyIdElement(IXMLDOMDocument2 *pXMLDoc, IAssemblyIdentity *pAssemblyId, IXMLDOMElement **ppElement);
HRESULT CreateDependantAssemblyNode(IXMLDOMDocument2 *pXMLDoc, ManifestNode*pManifestNode, IXMLDOMNode **ppDependantAssemblyNode);
HRESULT GetAssemblyNode(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode **ppAssemblyNode);
HRESULT FormatXML(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode *pRootNode, LONG dwLevel);
HRESULT CreateXMLAppManifest(LPWSTR pwzAppBase, LPWSTR pwzTemplateFilePath, List<ManifestNode *> *pList, List<LPWSTR> *pFileList);
HRESULT CreateXMLSubscriptionManifest(LPWSTR pwzSubscriptionPath, IAssemblyIdentity *pApplictionAssemblyId,  LPWSTR pwzUrl, LPWSTR pwzPollingInterval);
HRESULT CreateAppManifestTemplate(LPWSTR pwzTempPath);
HRESULT SaveXMLDocument(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzDocumentName);
HRESULT LoadXMLDocument(LPWSTR pwzTemplatePath, IXMLDOMDocument2 **ppXMLDoc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\mg\xmlutil.cpp ===
#include <windows.h>
#include <fusenetincludes.h>
#include <msxml2.h>
#include <stdio.h>
#include <md5.h>
#include "list.h"
#include "manifestnode.h"
#include "xmlutil.h"
#include "version.h"

#define ASSEMBLY L"assembly"
#define NAMESPACE_TITLE L"xmlns:asm_namespace_v1"
#define NAMESPACE_VALUE L"urn:schemas-microsoft-com:asm.v1"
#define MANIFEST_VERSION_TITLE L"manifestVersion"
#define MANIFEST_VERSION_VALUE L"1.0"
#define DESCRIPTION L"description"
#define ASSEMBLY_IDENTITY L"assemblyIdentity"
#define DEPENDENCY L"dependency"
#define DEPENDENCY_QUERY L"/assembly/dependency"
#define DEPENDANT_ASSEMBLY L"dependentAssembly"
#define INSTALL L"install"
#define CODEBASE L"codebase"
#define APPLICATION L"application"
#define SHELL_STATE L"shellState"
#define ACTIVATION  L"activation"
#define FILE L"file"
#define FILE_NAME L"name"
#define FILE_HASH L"hash"



class __declspec(uuid("f6d90f11-9c73-11d3-b32e-00c04f990bb4")) private_MSXML_DOMDocument30;

#define HASHLENGTH          32
#define HASHSTRINGLENGTH    HASHLENGTH+1


/////////////////////////////////////////////////////////////////////////
// FowardSlash
/////////////////////////////////////////////////////////////////////////
VOID FowardSlash(LPWSTR pwz)
{
    LPWSTR ptr = pwz;

    while (*ptr)
    {
        if (*ptr == L'\\')
            *ptr = L'/';
        ptr++;
    }
}

/////////////////////////////////////////////////////////////////////////
// GetHash
/////////////////////////////////////////////////////////////////////////
HRESULT GetHash(LPCWSTR pwzFilename, LPWSTR *ppwzHash)
{
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwLength = 0; // cblength
    LPWSTR pwzHash = new WCHAR[HASHSTRINGLENGTH];

    // BUGBUG - heap allocate large buffers like this.
    unsigned char buffer[16384];
    MD5_CTX md5c;
    int i;
    WCHAR* p;

    if(!pwzHash)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    MD5Init(&md5c);

    hFile = CreateFile(pwzFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {

        hr =  HRESULT_FROM_WIN32(GetLastError());
        printf("Open file error during hashing\n");
        goto exit;
    }

    ZeroMemory(buffer, sizeof(buffer));

    // BUGBUG - error checking here.
    while(ReadFile(hFile, buffer, sizeof(buffer), &dwLength, NULL) && dwLength)
        MD5Update(&md5c, buffer, (unsigned) dwLength);

    CloseHandle(hFile);
    MD5Final(&md5c);

    // convert hash from byte array to hex
    p = pwzHash;
    for (int i = 0; i < sizeof(md5c.digest); i++)
    {       
        wsprintf(p, L"%02X", md5c.digest[i]);
        p += 2;
    }

    *ppwzHash = pwzHash;
    pwzHash = NULL;

exit:
    SAFEDELETEARRAY(pwzHash);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CreateXMLElement
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLTextNode(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzText, IXMLDOMNode **ppNode)
{
    HRESULT hr = S_OK;
    IXMLDOMNode *pNode = NULL;
    BSTR bstrText = NULL;

    bstrText = ::SysAllocString(pwzText);
    if (!bstrText)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if(FAILED(pXMLDoc->createTextNode(bstrText, (IXMLDOMText**)&pNode)))
        goto exit;

    *ppNode = pNode;
    (*ppNode)->AddRef();

exit:
    if (bstrText)
        ::SysFreeString(bstrText);

    SAFERELEASE (pNode);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CreateXMLComment
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLComment(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzComment, 
    IXMLDOMComment **ppComment)
{
    HRESULT hr=S_OK;
    BSTR bstrComment = NULL;
    IXMLDOMComment *pComment = NULL;

    bstrComment = ::SysAllocString(pwzComment);
    if (!bstrComment)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if(FAILED(hr = pXMLDoc->createComment(bstrComment, &pComment)))
        goto exit;

    *ppComment = pComment;
    (*ppComment)->AddRef();
    
exit:

    if (bstrComment)
        ::SysFreeString(bstrComment);

    SAFERELEASE(pComment);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// AddMgVersionAsComment
/////////////////////////////////////////////////////////////////////////
HRESULT AddMgVersionAsComment(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode **ppRoot)
{
    HRESULT hr = S_OK;
    CString sComment;
    IXMLDOMComment *pComment = NULL;
    IXMLDOMNode *pNewNode = NULL;

    // ASSERT(pXMLDoc && ppRoot);

    sComment.Assign(L"Created using mg version ");
    sComment.Append(VER_PRODUCTVERSION_STR_L);

    if(FAILED(hr = CreateXMLComment(pXMLDoc, sComment._pwz, &pComment)))
        goto exit;

    if(*ppRoot)
    {
        if (FAILED(hr = (*ppRoot)->appendChild((IXMLDOMNode *)pComment, &pNewNode)))
            goto exit;
    }
    else
    {
        if (FAILED(hr = pXMLDoc->appendChild((IXMLDOMNode *)pComment, ppRoot)))
            goto exit;
    }

exit:

    SAFERELEASE(pNewNode);
    SAFERELEASE(pComment);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CreateXMLElement
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLElement(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzElementName, 
    IXMLDOMElement **ppElement)
{
    HRESULT hr=S_OK;
    BSTR bstrElementName = NULL;
    IXMLDOMElement *pElement = NULL;
    IXMLDOMNode *pNode =NULL, *pNewNode = NULL;

    bstrElementName = ::SysAllocString(pwzElementName);
    if (!bstrElementName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // NOTENOTE - createElement doesn't append the node to the doc
    // so we're just using pXMLDoc for convenience of calling create.
    if(FAILED(hr = pXMLDoc->createElement(bstrElementName, &pElement)))
        goto exit;

    *ppElement = pElement;
    (*ppElement)->AddRef();
    
exit:

    if (bstrElementName)
        ::SysFreeString(bstrElementName);

    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pElement);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// SetXMLElementAttribute
/////////////////////////////////////////////////////////////////////////
HRESULT SetXMLElementAttribute(IXMLDOMElement *pElement, LPWSTR pwzAttributeName,
    LPWSTR pwzAttributeValue)
{
    HRESULT hr=S_OK;
    BSTR bstrAttributeName = NULL, bstrAttributeValue = NULL;
    VARIANT varAttributeValue;

    bstrAttributeName = ::SysAllocString(pwzAttributeName);
    bstrAttributeValue = ::SysAllocString(pwzAttributeValue);
    if (!bstrAttributeName || (!bstrAttributeValue && pwzAttributeValue))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    VariantInit(&varAttributeValue);
    varAttributeValue.vt = VT_BSTR;
    V_BSTR(&varAttributeValue) = bstrAttributeValue;

    hr = pElement->setAttribute(bstrAttributeName, varAttributeValue);

exit:

    if (bstrAttributeName)
        ::SysFreeString(bstrAttributeName);

    if (bstrAttributeValue)
        ::SysFreeString(bstrAttributeValue);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CreateXMLAssemblyIdElement
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLAssemblyIdElement(IXMLDOMDocument2 *pXMLDoc, IAssemblyIdentity *pAssemblyId, 
    IXMLDOMElement **ppElement)
{
    HRESULT hr = S_OK;
    IXMLDOMElement *pASMIdElement = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf = 0;
    CString sBuffer;

    LPWSTR rpwzAttrNames[6] = 
    {
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
    };

    //Create assemblyIdentity Element
    if(FAILED(hr=CreateXMLElement(pXMLDoc, ASSEMBLY_IDENTITY,  &pASMIdElement)))
        goto exit;

    for (int i = 0; i < 6; i++)
    {
        // BUGBUG - eventually, when we add support for type the only guy which 
        // is optional is the public key token.
        if (FAILED(hr = pAssemblyId->GetAttribute(rpwzAttrNames[i], &pwzBuf, &ccBuf))
            && hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
            goto exit;
        else if (hr == S_OK)
        {            
            sBuffer.TakeOwnership(pwzBuf, ccBuf);
            hr = SetXMLElementAttribute(pASMIdElement, rpwzAttrNames[i], sBuffer._pwz);            
        }
        else
            hr = S_OK;
    }


    *ppElement = pASMIdElement;
    (*ppElement)->AddRef();
    

exit:
    SAFERELEASE(pASMIdElement);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CreateDependantAssemblyNode
/////////////////////////////////////////////////////////////////////////
HRESULT CreateDependantAssemblyNode(IXMLDOMDocument2 *pXMLDoc, ManifestNode*pManifestNode, IXMLDOMNode **ppDependantAssemblyNode)
{
    HRESULT hr = S_OK;
    LPWSTR pwzBuf = NULL;
    DWORD dwType;
    IAssemblyIdentity *pAssemblyId = NULL;
    IXMLDOMElement *pDependantAssemblyNode = NULL, *pElement = NULL;
    IXMLDOMNode  *pNewNode = NULL;
    
    CString sCodeBase;
    
    //Get ASMId for Unique Dependency
    if(FAILED(hr = pManifestNode->GetAssemblyIdentity(&pAssemblyId)))
        goto exit;        

    //Get the type of manifest
    // - Private or GAC, for GACs you don't put the codebase.
    if(FAILED(hr = pManifestNode->GetManifestType(&dwType)))
        goto exit;

    //Get Codebase of the Unique Dependancy
    if(FAILED(hr = pManifestNode->GetManifestFilePath(&pwzBuf)))
        goto exit;
    sCodeBase.TakeOwnership(pwzBuf);

    //Create a dependentAssembly node
    if(FAILED(hr = CreateXMLElement(pXMLDoc, DEPENDANT_ASSEMBLY, &pDependantAssemblyNode)))
        goto exit;

    //Create the AssemblyId for the Dependant Assembly
    if (FAILED(CreateXMLAssemblyIdElement(pXMLDoc, pAssemblyId, &pElement)))
        goto exit;

    if (FAILED(hr=pDependantAssemblyNode->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;
        
    // Node is added and element, node can be released.
    SAFERELEASE(pElement);
    SAFERELEASE(pNewNode);
    
    //read the codebase for this DependantAssembly
    // GACs don't have a codebase.
    if (1) // we need codebase for all assemblies (dwType == PRIVATE_ASSEMBLY)
    {
        if(FAILED(hr = CreateXMLElement(pXMLDoc, INSTALL, &pElement)))
            goto exit;

        FowardSlash(sCodeBase._pwz);        
        if(FAILED(hr = SetXMLElementAttribute(pElement, CODEBASE, sCodeBase._pwz)))
            goto exit;

        if (FAILED(hr=pDependantAssemblyNode->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
            goto exit;
   
        SAFERELEASE(pElement);
        SAFERELEASE(pNewNode);           
    }

    *ppDependantAssemblyNode = pDependantAssemblyNode;
     (*ppDependantAssemblyNode)->AddRef();

exit:
    SAFERELEASE(pAssemblyId);
    SAFERELEASE(pDependantAssemblyNode);
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// GetNode
/////////////////////////////////////////////////////////////////////////
HRESULT GetNode(IXMLDOMDocument2 *pXMLDoc, LPCWSTR pwzNode, IXMLDOMNode **ppNode)
{
    HRESULT hr = S_OK;    
    BSTR bstrtQueryString;

    IXMLDOMNode *pNode=NULL;
    IXMLDOMNodeList *pNodeList = NULL;
    LONG nNodes = 0;
    
    bstrtQueryString = ::SysAllocString(pwzNode);
    if (!bstrtQueryString)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ((hr = pXMLDoc->selectNodes(bstrtQueryString, &pNodeList)) != S_OK)
        goto exit;

    // NOTENOTE - nNodes > 1 should never happen because only one root node in doc.
    hr = pNodeList->get_length(&nNodes);
    if (nNodes > 1)
    {
        // multiple file callouts having the exact same file name/path within a single source assembly
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }
    else if (nNodes < 1)
    {
        hr = S_FALSE;
        goto exit;
    }

    if ((hr = pNodeList->get_item(0, &pNode)) != S_OK)
    {
        hr = S_FALSE ? E_FAIL : hr;
        goto exit;
    }

    *ppNode=pNode;
    (*ppNode)->AddRef();
    
exit:
    if(bstrtQueryString)
        ::SysFreeString(bstrtQueryString);

    SAFERELEASE(pNodeList);
    SAFERELEASE(pNode);
    
    return hr;
}



/////////////////////////////////////////////////////////////////////////
// FormatXML
// Called recursively.
// BUGBUG - t-peterf to document why selectNodes should not be used when
// adding nodes to an existing document.
/////////////////////////////////////////////////////////////////////////
HRESULT FormatXML(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode *pRootNode, LONG dwLevel)
{
    HRESULT hr = S_OK;
    IXMLDOMNode *pNode=NULL, *pNewNode=NULL;
    IXMLDOMNode *pTextNode1=NULL, *pTextNode2=NULL;
    CString sWhiteSpace1, sWhiteSpace2;
    BOOL bHasChildren = FALSE;    
    int i = 0;

    sWhiteSpace1.Assign(L"\n");
    for (i = 0; i < (dwLevel-1); i++)
        sWhiteSpace1.Append(L"\t");

    sWhiteSpace2.Assign(L"\n");
    for (i = 0; i < dwLevel; i++)
        sWhiteSpace2.Append(L"\t");
       
    hr = pRootNode->get_firstChild(&pNode);
    while(pNode != NULL)
    {    
        bHasChildren = TRUE;

        // create whitespace with one extra tab.
        if(FAILED(CreateXMLTextNode(pXMLDoc, sWhiteSpace2._pwz, &pTextNode2)))
            goto exit;
             
        VARIANT varRefNode;
        VariantInit(&varRefNode);
        varRefNode.vt = VT_UNKNOWN;
        V_UNKNOWN(&varRefNode) = pNode;

        if (FAILED(hr = pRootNode->insertBefore(pTextNode2, varRefNode, &pNewNode)))
            goto exit;
        SAFERELEASE(pNewNode);
        SAFERELEASE(pTextNode2);
        
        // Recursively call format on the node.
        if (FAILED(FormatXML(pXMLDoc, pNode, dwLevel+1)))
            goto exit;
      
        pNode->get_nextSibling(&pNewNode);

        SAFERELEASE(pNode);
        pNode = pNewNode;

    }

    if (bHasChildren)
    {   
        if(FAILED(CreateXMLTextNode(pXMLDoc, sWhiteSpace1._pwz, &pTextNode1)))
            goto exit;
    
        if (FAILED(hr = pRootNode->appendChild(pTextNode1, &pNewNode)))
            goto exit;
    }

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CreateManifestFromAssembly
/////////////////////////////////////////////////////////////////////////
HRESULT CreateAppManifestTemplate(LPWSTR pwzTempFile)
{
    HRESULT hr=S_OK;
    IXMLDOMDocument2 *pXMLDoc = NULL;
    IXMLDOMElement *pElement=NULL, *pChildElement=NULL, *pChildElement2=NULL, *pChildElement3=NULL;
    IXMLDOMNode *pNewNode=NULL, *pRoot=NULL, *pTextNode = NULL;

    if(FAILED(hr = CoCreateInstance(__uuidof(private_MSXML_DOMDocument30), 
            NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, (void**)&pXMLDoc)))
        goto exit;

    /*
    if(FAILED(hr = AddMgVersionAsComment(pXMLDoc, &pRoot)))
        goto exit;
    */

    //create the root assembly node and add the default properties
    if(FAILED(hr = CreateXMLElement(pXMLDoc, ASSEMBLY, &pElement)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, NAMESPACE_TITLE, NAMESPACE_VALUE)))
        goto exit;
    
    if(FAILED(hr = SetXMLElementAttribute(pElement, MANIFEST_VERSION_TITLE, MANIFEST_VERSION_VALUE)))
        goto exit;

    //append the root to the DOMDocument
    if (FAILED(hr = pXMLDoc->appendChild((IXMLDOMNode *)pElement, &pRoot)))
        goto exit;    
    SAFERELEASE(pElement);

    //create the tempate assemblyIdentity node with blank attributes
    if(FAILED(hr = CreateXMLElement(pXMLDoc, ASSEMBLY_IDENTITY, &pElement)))
        goto exit;

    hr = SetXMLElementAttribute(pElement, L"type", L"application");
    hr = SetXMLElementAttribute(pElement, L"name", L"");
    hr = SetXMLElementAttribute(pElement, L"version", L"");
    hr = SetXMLElementAttribute(pElement, L"processorArchitecture", L"");
    hr = SetXMLElementAttribute(pElement, L"publicKeyToken", L"");
    hr = SetXMLElementAttribute(pElement, L"language", L"");
    
    //append this to the root node
    if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;
    SAFERELEASE(pElement);
    SAFERELEASE(pNewNode);

    //create a sample description
    if(FAILED(hr = CreateXMLElement(pXMLDoc, DESCRIPTION, &pElement)))
        goto exit;

    if(FAILED(hr = CreateXMLTextNode(pXMLDoc, L"Put a description of your application here", &pTextNode)))
        goto exit;

    if (FAILED(hr=pElement->appendChild(pTextNode, &pNewNode)))
        goto exit;

    SAFERELEASE(pNewNode);
    SAFERELEASE(pTextNode);
    
    if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;

    SAFERELEASE(pNewNode);
    SAFERELEASE(pElement);

    //Create the shellState tag and enter in default information
    if(FAILED(hr = CreateXMLElement(pXMLDoc, APPLICATION, &pElement)))
        goto exit;

    if(FAILED(hr = CreateXMLElement(pXMLDoc, SHELL_STATE, &pChildElement)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"friendlyName", L"")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"entryPoint", L"")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"entryImageType", L"")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"showCommand", L"")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"hotKey", L"")))
        goto exit;

    if (FAILED(hr=pElement->appendChild((IXMLDOMNode *)pChildElement, &pNewNode)))
        goto exit;
    SAFERELEASE (pNewNode);
    SAFERELEASE(pChildElement);

    if(FAILED(hr = CreateXMLElement(pXMLDoc, ACTIVATION, &pChildElement)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"assemblyName", L"")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"assemblyClass", L"")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"assemblyMethod", L"")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement, L"assemblyMethodArgs", L"")))
        goto exit;

    if (FAILED(hr=pElement->appendChild((IXMLDOMNode *)pChildElement, &pNewNode)))
        goto exit;
    SAFERELEASE (pNewNode);
    SAFERELEASE(pChildElement);
    
    if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;

    SAFERELEASE(pElement);    
    SAFERELEASE (pNewNode);

    //Create the dependency platform tag and enter in default information
    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"dependency", &pElement)))
        goto exit;

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"platform", &pChildElement)))
        goto exit;

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"osVersionInfo", &pChildElement2)))
        goto exit;

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"os", &pChildElement3)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pChildElement3, L"majorVersion", L"5")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement3, L"minorVersion", L"1")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement3, L"buildNumber", L"2600")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement3, L"servicePackMajor", L"0")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement3, L"servicePackMinor", L"0")))
        goto exit;

    if (FAILED(hr=pChildElement2->appendChild((IXMLDOMNode *)pChildElement3, NULL)))
        goto exit;
    SAFERELEASE (pChildElement3);

    if (FAILED(hr=pChildElement->appendChild((IXMLDOMNode *)pChildElement2, NULL)))
        goto exit;
    SAFERELEASE (pChildElement2);

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"platformInfo", &pChildElement2)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pChildElement2, L"friendlyName", L"Microsoft Windows XP")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement2, L"href", L"http://www.microsoft.com/windows")))
        goto exit;

    if (FAILED(hr=pChildElement->appendChild((IXMLDOMNode *)pChildElement2, NULL)))
        goto exit;
    SAFERELEASE (pChildElement2);

    if (FAILED(hr=pElement->appendChild((IXMLDOMNode *)pChildElement, NULL)))
        goto exit;
    SAFERELEASE(pChildElement);

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"platform", &pChildElement)))
        goto exit;

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"dotNetVersionInfo", &pChildElement2)))
        goto exit;

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"supportedRuntime", &pChildElement3)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pChildElement3, L"version", L"v1.0.3705")))
        goto exit;

    if (FAILED(hr=pChildElement2->appendChild((IXMLDOMNode *)pChildElement3, NULL)))
        goto exit;
    SAFERELEASE (pChildElement3);

    if (FAILED(hr=pChildElement->appendChild((IXMLDOMNode *)pChildElement2, NULL)))
        goto exit;
    SAFERELEASE (pChildElement2);

    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"platformInfo", &pChildElement2)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pChildElement2, L"friendlyName", L"Microsoft .Net Frameworks")))
        goto exit;
    if(FAILED(hr = SetXMLElementAttribute(pChildElement2, L"href", L"http://www.microsoft.com/net")))
        goto exit;

    if (FAILED(hr=pChildElement->appendChild((IXMLDOMNode *)pChildElement2, NULL)))
        goto exit;
    SAFERELEASE (pChildElement2);

    if (FAILED(hr=pElement->appendChild((IXMLDOMNode *)pChildElement, NULL)))
        goto exit;
    SAFERELEASE(pChildElement);
    
    if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, NULL)))
        goto exit;

    SAFERELEASE(pElement);

    //Format and save the document   
    if(FAILED(hr = FormatXML(pXMLDoc, pRoot, 1)))
        goto exit;

    if(FAILED(hr = SaveXMLDocument(pXMLDoc, pwzTempFile)))
        goto exit;

    printf("\nTemplate file created succesfully\n%ws\n", pwzTempFile);
exit:

    SAFERELEASE(pXMLDoc);
    SAFERELEASE(pElement);
    SAFERELEASE(pChildElement3);
    SAFERELEASE(pChildElement2);
    SAFERELEASE(pChildElement);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pTextNode);
    SAFERELEASE(pRoot);

    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CreateSubscriptionManifest
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLSubscriptionManifest(LPWSTR pwzSubscriptionPath,
    IAssemblyIdentity *pApplictionAssemblyId,  LPWSTR pwzUrl, LPWSTR pwzPollingInterval)   
{
    HRESULT hr=S_OK;
    IXMLDOMDocument2 *pXMLDoc = NULL;
    IXMLDOMElement *pElement=NULL, *pChildElement=NULL, *pDependantAssemblyNode=NULL;
    IXMLDOMNode *pNewNode=NULL, *pRoot=NULL, *pTextNode = NULL, *pDependancyNode = NULL;
    CString sSubscriptionPath, sSubscriptionName;

    sSubscriptionPath.Assign(pwzSubscriptionPath);
    sSubscriptionPath.LastElement(sSubscriptionName);
    sSubscriptionPath.Append(L".manifest");
    if(FAILED(hr = CoCreateInstance(__uuidof(private_MSXML_DOMDocument30), 
            NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, (void**)&pXMLDoc)))
        goto exit;

    if(FAILED(hr = AddMgVersionAsComment(pXMLDoc, &pRoot)))
        goto exit;

    //create the root assembly node and add the default properties
    if(FAILED(hr = CreateXMLElement(pXMLDoc, ASSEMBLY, &pElement)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, NAMESPACE_TITLE, NAMESPACE_VALUE)))
        goto exit;
    
    if(FAILED(hr = SetXMLElementAttribute(pElement, MANIFEST_VERSION_TITLE, MANIFEST_VERSION_VALUE)))
        goto exit;

    //append the root to the DOMDocument
    if (FAILED(hr = pXMLDoc->appendChild((IXMLDOMNode *)pElement, &pRoot)))
        goto exit;    
    SAFERELEASE(pElement);

    //Create the AssemblyId for the Subscription
    //Use the AssemblyId of the application, but change the name and type
    if (FAILED(CreateXMLAssemblyIdElement(pXMLDoc, pApplictionAssemblyId, &pElement)))
        goto exit;
    // bugbug - check return code for consistency.
    hr = SetXMLElementAttribute(pElement, L"type", L"subscription");
    hr = SetXMLElementAttribute(pElement, L"name", sSubscriptionName._pwz);
    
    if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;

    SAFERELEASE(pElement);
    SAFERELEASE(pNewNode);           

    //create a sample description
    //bugbug, should grab description for original manifest and paste it here
    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"description", &pElement)))
        goto exit;

    if(FAILED(hr = CreateXMLTextNode(pXMLDoc, L"Put a description of your application here", &pTextNode)))
        goto exit;

    if (FAILED(hr=pElement->appendChild(pTextNode, &pNewNode)))
        goto exit;

    SAFERELEASE(pNewNode);
    SAFERELEASE(pTextNode);
    
    if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;

    SAFERELEASE(pNewNode);
    SAFERELEASE(pElement);


   //Create the Dependancy Node
    if(FAILED(hr = CreateXMLElement(pXMLDoc, DEPENDENCY, &pElement)))
        goto exit;
    if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pDependancyNode)))
            goto exit;
    SAFERELEASE(pElement);


    //Create a dependentAssembly node
    if(FAILED(hr = CreateXMLElement(pXMLDoc, DEPENDANT_ASSEMBLY, &pDependantAssemblyNode)))
        goto exit;

    //Create the AssemblyId for the Dependant Assembly
    if (FAILED(CreateXMLAssemblyIdElement(pXMLDoc, pApplictionAssemblyId, &pElement)))
        goto exit;

    //Append the AssemblyId to the dependantAssemblyNode
    if (FAILED(hr=pDependantAssemblyNode->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;

    SAFERELEASE(pElement);
    SAFERELEASE(pNewNode);

    //Add the install codebase to the dependantAssemblyNode
    if(FAILED(hr = CreateXMLElement(pXMLDoc, INSTALL, &pElement)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, CODEBASE, pwzUrl)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, L"type", L"required")))
        goto exit;

    if (FAILED(hr=pDependantAssemblyNode->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;
   
    SAFERELEASE(pElement);
    SAFERELEASE(pNewNode);           

    //Add the install codebase to the dependantAssemblyNode
    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"subscription", &pElement)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, L"synchronizeInterval", pwzPollingInterval)))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, L"intervalUnit", L"hours")))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, L"synchronizeEvent", L"onApplicationStartup")))
        goto exit;

    if(FAILED(hr = SetXMLElementAttribute(pElement, L"eventDemandConnection", L"no")))
        goto exit;

    if (FAILED(hr=pDependantAssemblyNode->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;
   
    SAFERELEASE(pElement);
    SAFERELEASE(pNewNode);           

    //Append the dependantAssemblyNode to the dependancy node
    if (FAILED(hr=pDependancyNode->appendChild(pDependantAssemblyNode, &pNewNode)))
        goto exit;

    SAFERELEASE(pDependantAssemblyNode);
    SAFERELEASE(pNewNode);

    //Format and save the document
    hr = FormatXML(pXMLDoc, pRoot, 1);
    if(FAILED(hr = SaveXMLDocument(pXMLDoc, sSubscriptionPath._pwz)))
        goto exit;

    printf("Subscription manifest succesfully created\n%ws\n", sSubscriptionPath._pwz);

exit:


    SAFERELEASE(pXMLDoc);
    SAFERELEASE(pElement);
    SAFERELEASE(pChildElement);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pTextNode);
    SAFERELEASE(pRoot);
    SAFERELEASE(pDependancyNode);
    SAFERELEASE(pDependantAssemblyNode);

    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CreateXMLAppManifest
// Creates the app manifest - may want to rename.
/////////////////////////////////////////////////////////////////////////
// NOTENOTE: rename pList -> pAsmList ?
HRESULT CreateXMLAppManifest(LPWSTR pwzAppBase, LPWSTR pwzTemplateFilePath, List<ManifestNode *> *pList, List<LPWSTR> *pFileList)
{
    HRESULT hr = S_OK;
    DWORD cc = 0, cb = 0, ccName = 0;
    LPWSTR pwz=NULL, pwzCodeBase = NULL, pwzName = NULL;
    IAssemblyIdentity *pASMId= NULL;
    IXMLDOMDocument2 *pXMLDoc=NULL;
    IXMLDOMElement *pElement=NULL, *pAssemblyIdElement = NULL;
    IXMLDOMNode *pRoot=NULL, *pDependancyNode = NULL, *pNewNode = NULL;
    IXMLDOMNode *pAssemblyIdNode = NULL, *pDependantAssemblyNode=NULL;
    BSTR bstrAttribute = NULL;
    VARIANT varAttribute;
    ManifestNode *pManNode = NULL;
    CString sAppName, sFileName, sFileHash, sAbsoluteFilePath, sManifestFilePath;
    LISTNODE pos = NULL;

    VariantInit(&varAttribute);
    //Load the template
    if(FAILED(hr = LoadXMLDocument(pwzTemplateFilePath, &pXMLDoc)))
        goto exit;

    //grab the first child(the only child) as the root node
    if(FAILED(hr = GetNode(pXMLDoc, ASSEMBLY, &pRoot)))
        goto exit;

    if (hr == S_FALSE)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //Get the name from the assemblyId, this will be the manifests file name
    if(FAILED(hr = pRoot->get_firstChild(&pAssemblyIdNode)))
        goto exit;

    //Query for the Element interface
    if (FAILED(hr = pAssemblyIdNode->QueryInterface(IID_IXMLDOMElement, (void**) &pAssemblyIdElement)))
        goto exit;

    bstrAttribute = ::SysAllocString(L"name");
    if (!bstrAttribute)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    if ((hr = pAssemblyIdElement->getAttribute(bstrAttribute, &varAttribute)) != S_OK)
        goto exit;

    ccName = ::SysStringLen(varAttribute.bstrVal) + 1;
    pwzName = new WCHAR[ccName];
    if (!pwzName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memcpy(pwzName, varAttribute.bstrVal, ccName * sizeof(WCHAR));

    if((*pwzName)== NULL)
    {
        hr = E_FAIL;
        printf("Invalid Template Format. Template must have a name attribute in the assemblyIdentity tag\n");
        goto exit;            
    }

    ::SysFreeString(varAttribute.bstrVal);
    ::SysFreeString(bstrAttribute);
    SAFERELEASE(pAssemblyIdElement);
    SAFERELEASE(pAssemblyIdNode);
    

    if(FAILED(hr = AddMgVersionAsComment(pXMLDoc, &pRoot)))
        goto exit;

    // Add all the raw files to the manifest
    pos = pFileList->GetHeadPosition();
    while (pos)       
    {
        pwz = pFileList->GetNext(pos);
        sFileName.Assign(pwz);

        if(FAILED(hr = CreateXMLElement(pXMLDoc, FILE, &pElement)))
            goto exit;

        if(FAILED(hr = SetXMLElementAttribute(pElement, FILE_NAME, sFileName._pwz)))
            goto exit;

        if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
            goto exit;

        //Get Absolute File Path of file
        sAbsoluteFilePath.Assign(pwzAppBase);
        sAbsoluteFilePath.Append(sFileName);

        //get the hash of the file
        if(FAILED(hr = GetHash(sAbsoluteFilePath._pwz, &pwz)))
            goto exit;
        sFileHash.TakeOwnership(pwz);

        if(FAILED(hr = SetXMLElementAttribute(pElement, FILE_HASH, sFileHash._pwz)))
            goto exit;                    

        SAFERELEASE(pNewNode);
    }

    // Get Dependency Node if exists
    if (FAILED(hr = GetNode(pXMLDoc, DEPENDENCY_QUERY, &pDependancyNode)))
        goto exit;

    if (hr == S_FALSE)
    {
        //Create the Dependancy Node
        if(FAILED(hr = CreateXMLElement(pXMLDoc, DEPENDENCY, &pElement)))
            goto exit;
        if (FAILED(hr=pRoot->appendChild((IXMLDOMNode *)pElement, &pDependancyNode)))
                goto exit;
        SAFERELEASE(pElement);
    }

    //Walk thorugh the list of dependant assemblies and add them to the App Manifest
    pos = pList->GetHeadPosition();
    while (pos)       
    {   
        //Get next Dependant Assembly from list
        pManNode = pList->GetNext(pos);
        if (FAILED(hr = CreateDependantAssemblyNode(pXMLDoc,  pManNode, &pDependantAssemblyNode)))
            goto exit;

        if (FAILED(hr=pDependancyNode->appendChild(pDependantAssemblyNode, &pNewNode)))
            goto exit;

        SAFERELEASE(pDependantAssemblyNode);
        SAFERELEASE(pNewNode);        
    }

    //Indent the manifest
    hr = FormatXML(pXMLDoc, pRoot, 1);

    // Save the manifest to a file   
    sManifestFilePath.Assign(pwzAppBase);
    sManifestFilePath.Append(pwzName);
    sManifestFilePath.Append(L".manifest");

    if(FAILED(hr = SaveXMLDocument(pXMLDoc, sManifestFilePath._pwz)))
        goto exit;

    printf("\nManifest created succesfully\n%ws\n", sManifestFilePath._pwz);
    
exit:
    if (varAttribute.bstrVal)
        ::SysFreeString(varAttribute.bstrVal);

    SAFEDELETEARRAY(pwzName);

    SAFERELEASE(pXMLDoc);
    SAFERELEASE(pElement);
    SAFERELEASE(pAssemblyIdElement);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pAssemblyIdNode);
    SAFERELEASE(pRoot);
    SAFERELEASE(pDependancyNode);
    SAFERELEASE(pDependantAssemblyNode);


   return hr;
}

/////////////////////////////////////////////////////////////////////////
// SaveXMLDocument
/////////////////////////////////////////////////////////////////////////
HRESULT SaveXMLDocument(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzDocumentName)
{
    HRESULT hr = S_OK;
    CString sDocumentName;
    BSTR bstrFileName = NULL;
    VARIANT varFileName;
    
    // Save the manifest to a file   
    sDocumentName.Assign(pwzDocumentName);

    bstrFileName = ::SysAllocString(sDocumentName._pwz);
    if (!bstrFileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    VariantInit(&varFileName);
    varFileName.vt = VT_BSTR;
    V_BSTR(&varFileName) = bstrFileName;

    hr = pXMLDoc->save(varFileName);

exit:
    if(bstrFileName)
        ::SysFreeString(bstrFileName);

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//LoadXMLDocument
/////////////////////////////////////////////////////////////////////////
HRESULT LoadXMLDocument(LPWSTR pwzDocumentPath, IXMLDOMDocument2 **ppXMLDoc)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument2 *pXMLDoc;
    VARIANT varFileName;
    VARIANT_BOOL varBool;
    BSTR bstrFileName = NULL;

    bstrFileName = ::SysAllocString(pwzDocumentPath);
    if (!bstrFileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    VariantInit(&varFileName);
    varFileName.vt = VT_BSTR;
    V_BSTR(&varFileName) = bstrFileName;
    
    if(FAILED(hr = CoCreateInstance(__uuidof(private_MSXML_DOMDocument30), 
            NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, (void**)&pXMLDoc)))
        goto exit;

    // Load synchronously
    if (FAILED(hr = pXMLDoc->put_async(VARIANT_FALSE)))
        goto exit;

    if ((hr = pXMLDoc->load(varFileName, &varBool)) != S_OK)
    {
        if(!varBool)
            hr = E_INVALIDARG;
        goto exit;
    }
    *ppXMLDoc=pXMLDoc;
    (*ppXMLDoc)->AddRef();

exit:
    if(bstrFileName)
        ::SysFreeString(bstrFileName);
    SAFERELEASE(pXMLDoc);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\pg\pg.h ===
#pragma once

#define TOLOWER(a) (((a) >= L'A' && (a) <= L'Z') ? (L'a' + (a - L'A')) : (a))
#define SAFEDELETEARRAY(p) if ((p) != NULL) { delete[] (p); (p) = NULL; };
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };

class __declspec(uuid("f6d90f11-9c73-11d3-b32e-00c04f990bb4")) private_MSXML_DOMDocument30;

CString g_sSourceManifest, g_sSourceBase, g_sDestBase;

/////////////////////////////////////////////////////////////////////////
// HashString
///////////////////////////////////////////////////////////////////////
inline DWORD HashString(LPCWSTR wzKey, DWORD dwHashSize, BOOL bCaseSensitive)
{
    DWORD                                 dwHash = 0;
    DWORD                                 dwLen;
    DWORD                                 i;

    dwLen = lstrlenW(wzKey);
    for (i = 0; i < dwLen; i++)
    {
        if (bCaseSensitive)
            dwHash = (dwHash * 65599) + (DWORD)wzKey[i];
        else
            dwHash = (dwHash * 65599) + (DWORD)TOLOWER(wzKey[i]);
    }

    dwHash %= dwHashSize;

    return dwHash;
}


HRESULT CreateDirectoryHierarchy(LPWSTR pwzRootDir, LPWSTR pwzFilePath);
HRESULT PathNormalize(LPWSTR pwzPath, LPWSTR *ppwzAbsolutePath, DWORD dwFlag, BOOL bCreate);
HRESULT IsValidManifestImport (LPWSTR pwzManifestPath);
HRESULT FindAllFiles (LPWSTR pwzDir, List<LPWSTR> *pFileList);
HRESULT CrossReferenceFiles (LPWSTR pwzDir, List<LPWSTR> *pFileList, List<LPWSTR> *pPatchableFiles);
BOOL CALLBACK MyProgressCallback(PVOID CallbackContext, ULONG CurrentPosition, ULONG MaximumPosition);
HRESULT ApplyPatchToFiles (List<LPWSTR> *pPatchableFiles, List<LPWSTR> *pPatchedFiles, LPWSTR pwzSourceDir, LPWSTR pwzDestDir, LPWSTR pwzPatchDir);
HRESULT CheckForDuplicate(LPWSTR pwzSourceManifestPath, LPWSTR pwzDestManifestPath);
HRESULT GetPatchDirectory(LPWSTR pwzSourceManifestPath, LPWSTR *pwzPatchDir);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\pg\pg.cpp ===
#include <windows.h>
#include <fusenetincludes.h>
#include <stdio.h>
#include <msxml2.h>
#include "list.h"
#include "patchapi.h"
#include "patchprv.h"
#include "patchlzx.h"
#include "xmlutil.h"
#include "pg.h"

#define DIRECTORY_PATH 0
#define FILE_PATH 1

#define HASHTABLE_SIZE 257



/////////////////////////////////////////////////////////////////////////
// PathNormalize
/////////////////////////////////////////////////////////////////////////
HRESULT PathNormalize(LPWSTR pwzPath, LPWSTR *ppwzAbsolutePath, DWORD dwFlag, BOOL bCreate)
{
    HRESULT hr = S_OK;
    WCHAR pwzTempDir[MAX_PATH], pwzAbsolutePath[MAX_PATH];
    DWORD ccDir = MAX_PATH;

    *ppwzAbsolutePath = NULL;
    //If path is relative, prepend the current directory
    if (PathIsRelative(pwzPath))
    {
        GetCurrentDirectory(ccDir, pwzTempDir);
        StrCat(pwzTempDir, L"\\");
        StrCat(pwzTempDir, pwzPath);
    }
    else
        StrCpy(pwzTempDir, pwzPath);


    if (!PathCanonicalize(pwzAbsolutePath, pwzTempDir))
    {
        printf("Dir \"%ws\" canonicalize error\n", pwzTempDir);
        hr = E_FAIL;
        goto exit;
    }

    //If path is supposed to be a diesctory, append a trailing slash if not already there
    ccDir = lstrlen(pwzAbsolutePath);
    if (dwFlag == DIRECTORY_PATH && pwzAbsolutePath[ccDir -1] != L'\\')
    {
        pwzAbsolutePath[ccDir] = L'\\';
        pwzAbsolutePath[ccDir +1] = L'\0';
    }

    //Make sure the direcotry exists
    if (dwFlag == DIRECTORY_PATH && !bCreate)
    {
        if(!PathIsDirectory(pwzAbsolutePath))
        {
            printf("Dir \"%ws\" is not a valid directory\n", pwzPath);
            hr = E_FAIL;
            goto exit;
        }
    }
    //Make sure the file exists
    else if (dwFlag == FILE_PATH)
    {
        if(!bCreate)
        {
            if(!PathFileExists(pwzAbsolutePath))
            {
                printf("File \"%ws\" does not exist\n", pwzPath);
                hr = E_FAIL;
                goto exit;
            }
        }
        if(PathIsDirectory(pwzAbsolutePath))
        {
            printf("File \"%ws\" is a directory\n", pwzPath);
            hr = E_FAIL;
            goto exit;
        }
    }
           
    (*ppwzAbsolutePath) = WSTRDupDynamic(pwzAbsolutePath);

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// IsValidManifestImport
/////////////////////////////////////////////////////////////////////////
HRESULT IsValidManifestImport (LPWSTR pwzManifestPath)
{
    HRESULT hr = S_OK;
    IAssemblyManifestImport *pManImport = NULL;
    IAssemblyIdentity *pAssemblyId = NULL;
    if((hr = CreateAssemblyManifestImport(&pManImport, pwzManifestPath, NULL, 0)) != S_OK)
        goto exit;

    if((hr = pManImport->GetAssemblyIdentity(&pAssemblyId)) != S_OK)
        goto exit;
    
exit:
    SAFERELEASE(pAssemblyId);
    SAFERELEASE(pManImport);
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// FindAllFiles
/////////////////////////////////////////////////////////////////////////
HRESULT FindAllFiles (LPWSTR pwzDir, List<LPWSTR> *pFileList)
{
    HRESULT hr = S_OK;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdFile;
    CString sSearchString, sFileName;
    DWORD dwHash = 0;
    DWORD dwLastError = 0;

    // set up search string to find all files in the passed in directory
    sSearchString.Assign(pwzDir);
    sSearchString.Append(L"*");

    if (sSearchString._cc > MAX_PATH)
    {
        hr = CO_E_PATHTOOLONG;
        printf("Error: Search path too long\n");
        goto exit;
    }

    hFind = FindFirstFile(sSearchString._pwz, &fdFile);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        printf("Find file error\n");
        goto exit;
    }

    //enumerate through all the files in the directory, 
    // and recursivly call FindAllAssemblies on any directories encountered
    while(TRUE)
    {
        LPWSTR pwzFileName = NULL;
        if (StrCmp(fdFile.cFileName, L".") != 0 && StrCmp(fdFile.cFileName, L"..") != 0)
        {
            CString sFilePath;

            //create absolute file name by appending the filename to the dir name
            sFilePath.Assign(pwzDir);
            sFilePath.Append(fdFile.cFileName);

            if (sSearchString._cc > MAX_PATH)
            {
                hr = CO_E_PATHTOOLONG;
                printf("Error: File path too long\n");
                goto exit;
            }

            //If the file is a directory, recursivly call FindAllFiles
            if ((fdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            {          
                sFilePath.Append(L"\\");
                if (FAILED(hr = FindAllFiles(sFilePath._pwz, pFileList)))
                    goto exit;
            }
            // If a file add it to our master list
            else
            {
                if (StrCmp(sFilePath._pwz, g_sSourceManifest._pwz))
                {
                    sFileName.Assign(sFilePath._pwz+ g_sSourceBase._cc -1);
                    dwHash = HashString(sFileName._pwz, HASHTABLE_SIZE, false);
                    sFileName.ReleaseOwnership(&pwzFileName);
                    pFileList[dwHash].AddTail(pwzFileName);
                }
            }
        }

        if (!FindNextFile(hFind, &fdFile))
        {
            dwLastError = GetLastError();
            break;
        }

    if(dwLastError == ERROR_NO_MORE_FILES)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(dwLastError);   

    }

    hr = S_OK;
exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CrossReferenceFiles
/////////////////////////////////////////////////////////////////////////
HRESULT CrossReferenceFiles (LPWSTR pwzDir, List<LPWSTR> *pFileList, List<LPWSTR> *pPatchableFiles)
{
    HRESULT hr = S_OK;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdFile;
    CString sSearchString, sFileName;
    DWORD dwHash=0;
    LISTNODE pos;
    LPWSTR pwzBuf = NULL;
    DWORD dwLastError = 0;

    // set up search string to find all files in the passed in directory
    sSearchString.Assign(pwzDir);
    sSearchString.Append(L"*");

    if (sSearchString._cc > MAX_PATH)
    {
        hr = CO_E_PATHTOOLONG;
        printf("Error: Search path too long\n");
        goto exit;
    }

    hFind = FindFirstFile(sSearchString._pwz, &fdFile);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        printf("Find file error\n");
        goto exit;
    }

    //enumerate through all the files in the directory, 
    // and recursivly call FindAllAssemblies on any directories encountered
    while(dwLastError != ERROR_NO_MORE_FILES)
    {
        LPWSTR pwzFileName = NULL;
        if (StrCmp(fdFile.cFileName, L".") != 0 && StrCmp(fdFile.cFileName, L"..") != 0)
        {
            CString sFilePath;

            //create absolute file name by appending the filename to the dir name
            sFilePath.Assign(pwzDir);
            sFilePath.Append(fdFile.cFileName);

            if (sSearchString._cc > MAX_PATH)
            {
                hr = CO_E_PATHTOOLONG;
                printf("Error: File path too long\n");
                goto exit;
            }

            //If the file is a directory, recursivly call CrossReferenceFiles
            if ((fdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            {          
                sFilePath.Append(L"\\");
                if (FAILED(hr = CrossReferenceFiles(sFilePath._pwz, pFileList, pPatchableFiles)))
                    goto exit;
            }
            // If a file, check to see if it can be patched
            else
            {
                sFileName.Assign(sFilePath._pwz+g_sDestBase._cc -1);
                dwHash = HashString(sFileName._pwz, HASHTABLE_SIZE, false);

                pos = pFileList[dwHash].GetHeadPosition();
                while (pos)
                {
                    pwzBuf = pFileList[dwHash].GetNext(pos);

                    //if equal, attempt to path file
                    if (!StrCmpI(pwzBuf, sFileName._pwz))
                    {
                        sFileName.ReleaseOwnership(&pwzFileName);
                        pPatchableFiles->AddTail(pwzFileName);
                        break;
                    }
                }   
            }
        }

        if (!FindNextFile(hFind, &fdFile))
        {
            dwLastError = GetLastError();
            break;
        }
    }

    if(dwLastError == ERROR_NO_MORE_FILES)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(dwLastError);   


    hr = S_OK;
exit:
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// MyProgressCallback
/////////////////////////////////////////////////////////////////////////
BOOL CALLBACK MyProgressCallback(PVOID CallbackContext, ULONG CurrentPosition, 
        ULONG MaximumPosition)
{
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( MaximumPosition != 0 )
        fprintf(stderr, "\r%6.2f%% complete", ( CurrentPosition * 100.0 ) / MaximumPosition );
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// ApplyPatchToFiles
/////////////////////////////////////////////////////////////////////////
HRESULT ApplyPatchToFiles (List<LPWSTR> *pPatchableFiles, /* out */ List<LPWSTR> *pPatchedFiles, LPWSTR pwzSourceDir, LPWSTR pwzDestDir, LPWSTR pwzPatchDir)
{
    HRESULT hr = S_OK;
    LISTNODE pos;
    LPWSTR pwzBuf = NULL, pwzDestFile = NULL;
    CString sSourceFile, sDestFile, sPatchFile, sRelativeDest, sRelativePatch;
  
    PATCH_OPTION_DATA OptionData = { sizeof( PATCH_OPTION_DATA ) };
    PATCH_OPTION_DATA *OptionDataPointer = &OptionData;
    BOOL bSuccess = FALSE;
    ULONG OldFileCount;

    //CreatePatchFileEx allows you to create patchs file which 
    //can patch from multiple source files. You can have up to 
    // 256 different source files, hence the arrays with 256 elements.
    //FileNameArray has 257 elemnts since the destination file (which 
    // there can only be one) is stored as the first element and all the 
    // source files, are stored in the remaining 256 elements.

    // BUGBUG - t-peterf to document why 256, 257.
    PATCH_OLD_FILE_INFO_W OldFileInfo[ 256 ];
    LPWSTR FileNameArray[ 257 ];
    LPSTR OldFileSymPathArray[256];
    LPSTR NewFileSymPath = new CHAR[MAX_PATH];
    
    ULONG OptionFlags =  PATCH_OPTION_USE_LZX_BEST  |
                                       PATCH_OPTION_USE_LZX_LARGE |
                                       PATCH_OPTION_FAIL_IF_SAME_FILE |
                                       PATCH_OPTION_FAIL_IF_BIGGER |
                                       PATCH_OPTION_INTERLEAVE_FILES;                                      

    //Step through list of patchable files
    pos = pPatchableFiles->GetHeadPosition();
    while (pos)
    {    

        pwzBuf = pPatchableFiles->GetNext(pos);

        //Set up source file path
        sSourceFile.Assign(pwzSourceDir);
        sSourceFile.Append(pwzBuf);

        //Set up dest file path
        sDestFile.Assign(pwzDestDir);
        sDestFile.Append(pwzBuf);

        //set up patchfile path
        sPatchFile.Assign(pwzPatchDir);
        sPatchFile.Append(pwzBuf);
        sPatchFile.Append(L"._p");

        CreateDirectoryHierarchy(sPatchFile._pwz, NULL);

        //Set up Patching Information
        OldFileCount = 1;
        OldFileInfo[0].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO);
        OldFileInfo[0].OldFileName = sSourceFile._pwz;
        OldFileInfo[0].IgnoreRangeArray = NULL;
        OldFileInfo[0].IgnoreRangeCount = NULL;
        OldFileInfo[0].RetainRangeArray = NULL;
        OldFileInfo[0].RetainRangeCount = NULL;


        OldFileSymPathArray[0] = new CHAR[MAX_PATH];
        WideCharToMultiByte(CP_ACP, 0, pwzSourceDir, lstrlen(pwzSourceDir), OldFileSymPathArray[0], MAX_PATH, NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pwzDestDir, lstrlen(pwzDestDir), NewFileSymPath, MAX_PATH, NULL, NULL);

        OptionData.SizeOfThisStruct = NULL;
        OptionData.SymLoadCallback = NULL;
        OptionData.SymLoadContext  = FileNameArray;

        OptionData.ExtendedOptionFlags = NULL;
        OptionData.InterleaveMapArray = NULL;
        OptionData.MaxLzxWindowSize = NULL;
        OptionData.SymbolOptionFlags = NULL;

        OptionData.NewFileSymbolPath = (LPCSTR)NewFileSymPath;
        OptionData.OldFileSymbolPathArray = (LPCSTR *)OldFileSymPathArray;
        
        FileNameArray[0] = WSTRDupDynamic(sDestFile._pwz);
        FileNameArray[1] = WSTRDupDynamic(sSourceFile._pwz);
        
        //Applypatch
        bSuccess = CreatePatchFileEx(
              OldFileCount,
              OldFileInfo,
              sDestFile._pwz,
              sPatchFile._pwz,
              OptionFlags,
              OptionDataPointer,
              MyProgressCallback,
              NULL
              );
        
        sRelativeDest.Assign(sDestFile._pwz + g_sDestBase._cc-1);
        sRelativePatch.Assign(sPatchFile._pwz + g_sDestBase._cc-1);

        if(bSuccess)
        {
            fprintf(stderr, "\r%ws has been patched successfully to %ws\n", sRelativeDest._pwz, sRelativePatch._pwz);
            sDestFile.ReleaseOwnership(&pwzDestFile);
            pPatchedFiles->AddTail(pwzDestFile);
        }
        else
            fprintf(stderr, "\rCould/would not patch %ws. Not adding file to patch manifest\n",sRelativeDest._pwz);
        
    }

    SAFEDELETEARRAY(NewFileSymPath);
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CheckForDuplicate
/////////////////////////////////////////////////////////////////////////
HRESULT CheckForDuplicate(LPWSTR pwzSourceManifestPath, LPWSTR pwzDestManifestPath)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument2 *pXMLDoc = NULL;
    IXMLDOMNode *pNode = NULL;
    IAssemblyManifestImport *pSourceManImport = NULL;
    IAssemblyIdentity *pSourceAssemblyId = NULL;
    CString sSearchString, sBuffer;
    BSTR bstrSearchString = NULL;
    LPWSTR pwzBuf=NULL;
    DWORD ccBuf=0;

    LPWSTR rpwzAttrNames[6] = 
    {
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE,
    };

    if(FAILED(hr = LoadXMLDocument(pwzDestManifestPath, &pXMLDoc)))
        goto exit;

    if(FAILED(hr = CreateAssemblyManifestImport(&pSourceManImport, pwzSourceManifestPath, NULL, 0)))
        goto exit;

    if(FAILED(hr = pSourceManImport->GetAssemblyIdentity(&pSourceAssemblyId)))
        goto exit;

    //set up search string
    sSearchString.Assign(L"/assembly/Patch/SourceAssembly/assemblyIdentity[");

    for (int i = 0; i < 6; i++)
    {
        if (i)
            sSearchString.Append(L" and ");

        sSearchString.Append(L"@");
        sSearchString.Append(rpwzAttrNames[i]);
        sSearchString.Append(L"=\"");
            
        if (FAILED(hr = pSourceAssemblyId->GetAttribute(rpwzAttrNames[i], &pwzBuf, &ccBuf)))
            goto exit;
        sBuffer.TakeOwnership(pwzBuf, ccBuf);

        sSearchString.Append(sBuffer);
        sSearchString.Append(L"\"");
    }
    sSearchString.Append(L"]");

    bstrSearchString = ::SysAllocString(sSearchString._pwz);
    if (!bstrSearchString)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    //if source assembly already exists, exit and do nothing
    if (FAILED(hr = pXMLDoc->selectSingleNode(bstrSearchString, &pNode)))
        goto exit;
    else if (hr == S_OK)
    {
         fprintf(stderr, "Duplicate Source Assembly! Not adding to manfiest\n");
         hr = S_FALSE;
         goto exit;
    }
    else if (hr == S_FALSE)
    {
        hr = S_OK;
        goto exit;
    }

exit:
    if(bstrSearchString)
        ::SysFreeString(bstrSearchString);
   
    SAFERELEASE(pXMLDoc);
    SAFERELEASE(pNode);
    SAFERELEASE(pSourceAssemblyId);
    SAFERELEASE(pSourceManImport);
    
    return hr;

}

/////////////////////////////////////////////////////////////////////////
// Usage
/////////////////////////////////////////////////////////////////////////
HRESULT GetPatchDirectory(LPWSTR pwzSourceManifestPath, LPWSTR *ppwzPatchDir)
{
    HRESULT hr = S_OK;
    IAssemblyManifestImport *pSourceManImport = NULL;
    IAssemblyIdentity *pSourceAssemblyId = NULL;
    LPWSTR pwzBuf=NULL;
    DWORD ccBuf =0;
    CString sBuffer, sPatchDir;

    if(FAILED(hr = CreateAssemblyManifestImport(&pSourceManImport, pwzSourceManifestPath, NULL, 0)))
        goto exit;

    if(FAILED(hr = pSourceManImport->GetAssemblyIdentity(&pSourceAssemblyId)))
        goto exit;

    if (FAILED(hr = pSourceAssemblyId->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &ccBuf)))
        goto exit;
    sBuffer.TakeOwnership(pwzBuf, ccBuf);

    sPatchDir.Assign(g_sDestBase);
    sPatchDir.Append(L"__patch__\\");
    sPatchDir.Append(pwzBuf);
    sPatchDir.Append(L"\\");
       
    sPatchDir.ReleaseOwnership(ppwzPatchDir);
   
exit:
    return hr;
}



/////////////////////////////////////////////////////////////////////////
// Usage
/////////////////////////////////////////////////////////////////////////
HRESULT Usage()
{
    printf("Usage: \n"             
             "pg [source manifest path] [dest manifest path]:\n"         
             "\t[source manifest path] = path of the Application for which you want to generate a manifest for\n"
             "\t[dest manifest path] = path of the Application for which you want to generate a manifest for\n");
             return S_OK;
}

/////////////////////////////////////////////////////////////////////////
// wmain
/////////////////////////////////////////////////////////////////////////
int __cdecl wmain(int argc, WCHAR **argv)
{

    HRESULT hr = S_OK;
    LPWSTR pwzSourceManifest=NULL, pwzDestManifest=NULL;
    List <LPWSTR> pFileList[HASHTABLE_SIZE], PatchableFiles, PatchedFiles;
    BOOL bCoInitialized = FALSE;
    CString sPatchDir;
    LPWSTR pwzBuf=NULL;
        
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    bCoInitialized = TRUE;

    if (!StrCmp(argv[1], L"-?") || !(argc == 3))
    {        
        hr = Usage();
        goto exit;
    }

    if (FAILED(hr = PathNormalize(argv[1], &pwzSourceManifest, FILE_PATH, FALSE)))
    {
            hr = Usage();
            goto exit;
    }

    if (FAILED(hr = PathNormalize(argv[2], &pwzDestManifest, FILE_PATH, FALSE)))
    {
            hr = Usage();
            goto exit;
    }

    g_sSourceManifest.Assign(pwzSourceManifest);

    g_sSourceBase.Assign(g_sSourceManifest);
    g_sSourceBase.RemoveLastElement();
    g_sSourceBase.Append(L"\\");
    
    g_sDestBase.Assign(pwzDestManifest);
    g_sDestBase.RemoveLastElement();
    g_sDestBase.Append(L"\\");
    
    //Bugbug, could run into naming conflicts with the patch dir
    sPatchDir.Assign(g_sDestBase);
    sPatchDir.Append(L"__patch__\\");


    if(FAILED(hr = IsValidManifestImport(pwzSourceManifest)))
    {
        fprintf(stderr, "%ws is not a valid application manifest\n", pwzSourceManifest);
        goto exit;
    }
    if(FAILED(hr = IsValidManifestImport(pwzDestManifest)))
    {
        fprintf(stderr, "%ws is not a valid application manifest\n", pwzDestManifest);
        goto exit;
    }

    if((hr = CheckForDuplicate(pwzSourceManifest, pwzDestManifest)) != S_OK)
        goto exit;

    if(FAILED(hr = GetPatchDirectory(g_sSourceManifest._pwz, &pwzBuf)))
        goto exit;
    sPatchDir.TakeOwnership(pwzBuf);

    if(FAILED(hr = FindAllFiles(g_sSourceBase._pwz, pFileList)))
        goto exit;

    if(FAILED(hr = CrossReferenceFiles(g_sDestBase._pwz, pFileList, &PatchableFiles)))
        goto exit;

    if(FAILED(hr = ApplyPatchToFiles(&PatchableFiles, &PatchedFiles, g_sSourceBase._pwz, g_sDestBase._pwz, sPatchDir._pwz)))
        goto exit;

    if(FAILED(hr = CreatePatchManifest(&PatchedFiles, sPatchDir._pwz, pwzSourceManifest, pwzDestManifest)))
        goto exit;

exit:
    SAFEDELETEARRAY(pwzSourceManifest);
    SAFEDELETEARRAY(pwzDestManifest);

    
    if (bCoInitialized)
         CoUninitialize();

     if (FAILED(hr))
         fprintf(stderr, "\nFailed with code 0x%x", hr);
     
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\pg\xmlutil.h ===
#include <msxml2.h>

HRESULT CreateXMLTextNode(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzText, IXMLDOMNode **ppNode);
HRESULT CreateXMLElement(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzElementName, IXMLDOMElement **ppElement);
HRESULT SetXMLElementAttribute(IXMLDOMElement *pElement, LPWSTR pwzAttributeName, LPWSTR pwzAttributeVaule);
HRESULT CreateXMLAssemblyIdElement(IXMLDOMDocument2 *pXMLDoc, IAssemblyIdentity *pAssemblyId, IXMLDOMElement **ppElement);
HRESULT FormatXML(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode *pRootNode, LONG dwLevel);
HRESULT GetAssemblyNode(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode **ppAssemblyNode);
HRESULT CreatePatchManifest(List <LPWSTR> *pPatchedFiles, LPWSTR pwzPatchDir, LPWSTR pwzSourceManifestPath, LPWSTR pwzDestManifestPath);
HRESULT SaveXMLDocument(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzDocumentName);
HRESULT LoadXMLDocument(LPWSTR pwzTemplatePath, IXMLDOMDocument2 **ppXMLDoc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\test\test.cpp ===
#include <fusenetincludes.h>

HRESULT ProcessOrphanedJobs();

#include "cstrings.h"
#include <versionmanagement.h>
#include "dbglog.h"

void CALLBACK
StartW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);
void CALLBACK
UninstallW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);
HRESULT CreateVersionManagement(
    LPVERSION_MANAGEMENT       *ppVersionManagement,
    DWORD                       dwFlags);


int __cdecl wmain(int argc, LPWSTR *argv)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); 
    CVersionManagement *pVerMan = NULL;

    // hr = ProcessOrphanedJobs();    

    /*
    StartW( NULL, 0, argv[1], 0);
    goto exit;
    */

    /*
    CString sCmdLine;

    sCmdLine.Assign(L"\"");
    sCmdLine.Append(argv[1]);  //  L"\"\"   \"");
    sCmdLine.Append(L"\"");

    if (FAILED(hr = CreateVersionManagement(&pVerMan, 0)))
        goto exit;

    if (FAILED(hr = pVerMan->Uninstall(argv[1], argv[2])))  // example input x86_Microsoft.Fusion.ClickOnceTest.URT.SimplePad_144CC461D95B64FF_*_en  "C:\Documents and Settings\shyampa\Start Menu\Programs\SimplePad.manifest"
        goto exit;

    // UninstallW( NULL, 0, sCmdLine._pwz, 0);
    goto exit;
    */

 
    IAssemblyDownload *pDownload = NULL;
    CDebugLog         *pDbgLog = NULL;

    hr = CreateLogObject(&pDbgLog, NULL);
 
    hr = CreateAssemblyDownload(&pDownload, pDbgLog, 0);
    hr = pDownload->DownloadManifestAndDependencies(argv[1], NULL, DOWNLOAD_FLAGS_PROGRESS_UI);

    if(FAILED(hr) && (hr != E_ABORT))
    {
        CString sErrMsg;
        hr = pDbgLog->GetLoggedMsgs(0, sErrMsg);
        IF_FAILED_EXIT(sErrMsg.Append(L"\r\n Error in file download during TEST. Cannot continue."));
        MessageBox(NULL, sErrMsg._pwz, L"Test CliclOnce", 0);
    }

    DUMPDEBUGLOG(pDbgLog, -1, hr);

    SAFERELEASE(pDownload);
    goto exit;


exit :

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\util\dbglog.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "dbglog.h"
#include "wininet.h"
#include "util.h"
//#include "lock.h"
#include "version.h"

extern HINSTANCE g_hInst;
extern WCHAR g_FusionDllPath[MAX_PATH+1];

#define XSP_APP_CACHE_DIR                      L"Temporary ASP.NET Files"
#define XSP_FUSION_LOG_DIR                     L"Bind Logs"

#define REG_KEY_FUSION_SETTINGS     TEXT("Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\")


#define DLTYPE_DEFAULT     L"DEFAULT"
#define DLTYPE_FOREGROUND  L"Foreground"
#define DLTYPE_BACKGROUND  L"Background"

WCHAR g_wzEXEPath[MAX_PATH+1];
DWORD g_dwDisableLog;
DWORD g_dwForceLog;
DWORD g_dwLogFailures;
DWORD g_dwLoggingLevel=1;

void GetExePath()
{
    static BOOL bFirstTime=TRUE;

    if(bFirstTime)
    {
        if (!GetModuleFileNameW(NULL, g_wzEXEPath, MAX_PATH)) {
            lstrcpyW(g_wzEXEPath, L"Unknown");
        }

        bFirstTime=FALSE;
    }
}

BOOL IsHosted()
{
    return FALSE;
}


HRESULT GetRegValues()
{
    DWORD                           dwSize;
    DWORD                           dwType;
    DWORD                           lResult;
    HKEY                            hkey=0;
    DWORD                           dwValue=0;

    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    if(lResult == ERROR_SUCCESS) {

        // Get Logging Level
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_LEVEL, NULL,
                                  &dwType, (LPBYTE)&dwValue, &dwSize);
        if (lResult != ERROR_SUCCESS) {
            g_dwLoggingLevel = 0;
        }
        else
        {
            g_dwLoggingLevel = dwValue;
        }

        // Get Log Failures
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_FAILURES, NULL,
                                  &dwType, (LPBYTE)&dwValue, &dwSize);
        if (lResult != ERROR_SUCCESS) {
            g_dwLogFailures = 0;
        }
        else
        {
            g_dwLogFailures = dwValue;
        }

    }

    return S_OK;
}

HRESULT CreateLogObject(CDebugLog **ppdbglog, LPCWSTR szCodebase)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    IF_FAILED_EXIT(CDebugLog::Create(NULL, NULL, ppdbglog));

    // hr = GetRegValues();

exit:
    return hr;
}

//
// CDebugLogElement Class
//

HRESULT CDebugLogElement::Create(DWORD dwDetailLvl, LPCWSTR pwzMsg,
                                 CDebugLogElement **ppLogElem)
{
    HRESULT                                  hr = S_OK;
    CDebugLogElement                        *pLogElem = NULL;

    if (!ppLogElem || !pwzMsg) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppLogElem = NULL;

    pLogElem = FUSION_NEW_SINGLETON(CDebugLogElement(dwDetailLvl));
    if (!pLogElem) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pLogElem->Init(pwzMsg);
    if (FAILED(hr)) {
        SAFEDELETE(pLogElem);
        goto Exit;
    }

    *ppLogElem = pLogElem;

Exit:
    return hr;
}
                                 
CDebugLogElement::CDebugLogElement(DWORD dwDetailLvl)
: _pszMsg(NULL)
, _dwDetailLvl(dwDetailLvl)
{
}

CDebugLogElement::~CDebugLogElement()
{
    SAFEDELETEARRAY(_pszMsg);
}

HRESULT CDebugLogElement::Init(LPCWSTR pwzMsg)
{
    HRESULT                                    hr = S_OK;

    ASSERT(pwzMsg);

    _pszMsg = WSTRDupDynamic(pwzMsg);
    if (!_pszMsg) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
Exit:
    return hr;
}

/*******************************************************************

    NAME:        Unicode2Ansi
        
    SYNOPSIS:    Converts a unicode widechar string to ansi (MBCS)

    NOTES:        Caller must free out parameter using delete
                    
********************************************************************/
HRESULT Unicode2Ansi(const wchar_t *src, char ** dest)
{
    if ((src == NULL) || (dest == NULL))
        return E_INVALIDARG;

    // find out required buffer size and allocate it.
    int len = WideCharToMultiByte(CP_ACP, 0, src, -1, NULL, 0, NULL, NULL);
    *dest = NEW(char [len*sizeof(char)]);
    if (!*dest)
        return E_OUTOFMEMORY;

    // Now do the actual conversion
    if ((WideCharToMultiByte(CP_ACP, 0, src, -1, *dest, len*sizeof(char), 
                                                            NULL, NULL)) != 0)
        return S_OK; 
    else
        return HRESULT_FROM_WIN32(GetLastError());
}

HRESULT CDebugLogElement::Dump(HANDLE hFile)
{
    HRESULT                                        hr = S_OK;
    DWORD                                          dwLen = 0;
    DWORD                                          dwWritten = 0;
    DWORD                                          dwSize = 0;
    DWORD                                          dwBufSize = 0;
    LPSTR                                          szBuf = NULL;
    BOOL                                           bRet;

    if (!hFile) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwSize = lstrlenW(_pszMsg) + 1;

    hr = Unicode2Ansi(_pszMsg, &szBuf);
    if(FAILED(hr))
        goto Exit;

    bRet = WriteFile(hFile, szBuf, strlen(szBuf), &dwWritten, NULL);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(szBuf);

    return hr;
}

//
// CDebugLog Class
//

HRESULT CDebugLog::Create(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName,
                          CDebugLog **ppdl)
{
    HRESULT                                   hr = S_OK;
    CDebugLog                                *pdl = NULL;

    *ppdl = NULL;

    pdl = NEW(CDebugLog);
    if (!pdl) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pdl->Init(pAppCtx, pwzAsmName);
    if (FAILED(hr)) {
        delete pdl;
        pdl = NULL;
        goto Exit;
    }

    *ppdl = pdl;

Exit:
    return hr;
}

CDebugLog::CDebugLog()
: _pwzAsmName(NULL)
, _cRef(1)
, _bLogToWininet(TRUE)
, _dwNumEntries(0)
, _hr(S_OK)
, _wzEXEName(NULL)
, _bWroteDetails(FALSE)
{
    _szLogPath[0] = L'\0';
    InitializeCriticalSection(&_cs);
    GetExePath();
}

CDebugLog::~CDebugLog()
{
    LISTNODE                                 pos = NULL;
    CDebugLogElement                        *pLogElem = NULL;

    pos = _listDbgMsg.GetHeadPosition();

    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        SAFEDELETE(pLogElem);
    }

    _listDbgMsg.RemoveAll();

    SAFEDELETEARRAY(_pwzAsmName);
    SAFEDELETEARRAY(_wzEXEName);
    DeleteCriticalSection(&_cs);
}

HRESULT CDebugLog::Init(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName)
{
    HRESULT                                  hr = S_OK;
    BOOL                                     bIsHosted = FALSE;
    DWORD                                    dwSize;
    DWORD                                    dwType;
    DWORD                                    lResult;
    DWORD                                    dwAttr;
    HKEY                                     hkey;
    LPWSTR                                   wzAppName = NULL;
    LPWSTR                                   wzEXEName = NULL;


    hr = _sDLType.Assign(DLTYPE_DEFAULT);

    if (wzAppName && lstrlenW(wzAppName)) {
        _wzEXEName = WSTRDupDynamic(wzAppName);
        if (!_wzEXEName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else {
        LPWSTR               wzFileName;

        // Didn't find EXE name in appctx. Use the .EXE name.

        wzFileName = PathFindFileName(g_wzEXEPath);
        ASSERT(wzFileName);

        hr = _sAppName.Assign(wzFileName);

        _wzEXEName = WSTRDupDynamic(wzFileName);
        if (!_wzEXEName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // Log path
    
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    if (lResult == ERROR_SUCCESS) {
        dwSize = MAX_PATH;
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_PATH, NULL,
                                  &dwType, (LPBYTE)_szLogPath, &dwSize);
        if (lResult == ERROR_SUCCESS) {
            PathRemoveBackslashW(_szLogPath);
        }
        else {
            _szLogPath[0] = L'\0';
        }

        RegCloseKey(hkey);

        dwAttr = GetFileAttributesW(_szLogPath);
        if (dwAttr != -1 && (dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
            _bLogToWininet = FALSE;
        }
    }

/*
    bIsHosted = IsHosted();

    if (bIsHosted && !lstrlenW(_szLogPath)) {
        BOOL             bRet;
        WCHAR            wzCorSystemDir[MAX_PATH];
        WCHAR            wzXSPAppCacheDir[MAX_PATH];

        if (!GetCorSystemDirectory(wzCorSystemDir)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        PathRemoveBackslash(wzCorSystemDir);

        wnsprintfW(wzXSPAppCacheDir, MAX_PATH, L"%ws\\%ws", wzCorSystemDir,
                   XSP_APP_CACHE_DIR);

        dwAttr = GetFileAttributes(wzXSPAppCacheDir);
        if (dwAttr == -1) {
            bRet = CreateDirectory(wzXSPAppCacheDir, NULL);
            if (!bRet) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }
                    
        wnsprintfW(_szLogPath, MAX_PATH, L"%ws\\%ws", wzXSPAppCacheDir, XSP_FUSION_LOG_DIR);

        dwAttr = GetFileAttributes(_szLogPath);
        if (dwAttr == -1) {
            bRet = CreateDirectory(_szLogPath, NULL);
            if (!bRet) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }

        _bLogToWininet = FALSE;
    }
*/

Exit:
    SAFEDELETEARRAY(wzAppName);

    return hr;
}

HRESULT CDebugLog::SetAsmName(LPCWSTR pwzAsmName)
{
    HRESULT                                  hr = S_OK;
    int                                      iLen;

    if (_pwzAsmName) {
        // You can only set the name once.
        hr = S_FALSE;
        goto Exit;
    }

    if (!pwzAsmName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    iLen = lstrlenW(pwzAsmName) + 1;
    _pwzAsmName = NEW(WCHAR[iLen]);
    if (!_pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcpyW(_pwzAsmName, pwzAsmName);

Exit:
    return hr;
}

HRESULT CDebugLog::SetDownloadType(DWORD dwFlags)
{
    HRESULT                                  hr = S_OK;
    int                                      iLen;

    if(dwFlags & DOWNLOAD_FLAGS_PROGRESS_UI)
        IF_FAILED_EXIT(_sDLType.Assign(DLTYPE_FOREGROUND));
    else
        IF_FAILED_EXIT(_sDLType.Assign(DLTYPE_BACKGROUND));

exit:
    return hr;
}

HRESULT CDebugLog::SetAppName(LPCWSTR pwzAppName)
{
    HRESULT                                  hr = S_OK;
    int                                      iLen;

    ASSERT(pwzAppName);

    IF_FAILED_EXIT(_sAppName.Assign(pwzAppName));

exit:
    return hr;
}

//
// IUnknown
//

STDMETHODIMP CDebugLog::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                          hr = E_FAIL;

/*
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IFusionBindLog)) {
        *ppv = static_cast<IFusionBindLog *>(this);
    }
    else {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }
*/
    return hr;
}


STDMETHODIMP_(ULONG) CDebugLog::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDebugLog::Release()
{
    ULONG            ulRef;

    ulRef = InterlockedDecrement(&_cRef);
    
    if (ulRef == 0) {
        delete this;
    }

    return ulRef;
}

//
// IFusionBindLog
//

STDMETHODIMP CDebugLog::GetResultCode()
{
    return _hr;
}

HRESULT CDebugLog::GetLoggedMsgs(DWORD dwDetailLevel, CString& sLogMsgs )
{
    HRESULT                                  hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    BOOL bHaveMsgs = FALSE;
    LISTNODE                                 pos = NULL;
    CDebugLogElement                        *pLogElem = NULL;

    pos = _listDbgMsg.GetHeadPosition();
    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        ASSERT(pLogElem);

        if (pLogElem->_dwDetailLvl <= dwDetailLevel) {
            IF_FAILED_EXIT(sLogMsgs.Append(pLogElem->_pszMsg));
            IF_FAILED_EXIT(sLogMsgs.Append( L"\r\n"));
            bHaveMsgs = TRUE;
        }
    }

    if(bHaveMsgs == FALSE)
        hr = S_FALSE;

exit:

    return hr;
}

STDMETHODIMP CDebugLog::GetBindLog(DWORD dwDetailLevel, LPWSTR pwzDebugLog,
                                   DWORD *pcbDebugLog)
{
    HRESULT                                  hr = S_OK;
    LISTNODE                                 pos = NULL;
    DWORD                                    dwCharsReqd;
    CDebugLogElement                        *pLogElem = NULL;

    if (!pcbDebugLog) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    pos = _listDbgMsg.GetHeadPosition();
    if (!pos) {
        // No entries in debug log!
        hr = S_FALSE;
        goto Exit;
    }

    // Calculate total size (entries + new line chars + NULL)

    dwCharsReqd = 0;
    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        ASSERT(pLogElem);

        if (pLogElem->_dwDetailLvl <= dwDetailLevel) {
            dwCharsReqd += lstrlenW(pLogElem->_pszMsg) * sizeof(WCHAR);
            dwCharsReqd += sizeof(L"\r\n");
        }
    }

    dwCharsReqd += 1; // NULL char

    if (!pwzDebugLog || *pcbDebugLog < dwCharsReqd) {
        *pcbDebugLog = dwCharsReqd;

        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *pwzDebugLog = L'\0';

    pos = _listDbgMsg.GetHeadPosition();
    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        ASSERT(pLogElem);

        if (pLogElem->_dwDetailLvl <= dwDetailLevel) {
            StrCatW(pwzDebugLog, pLogElem->_pszMsg);
            StrCatW(pwzDebugLog, L"\r\n");
        }
    }

    ASSERT((DWORD)lstrlenW(pwzDebugLog) * sizeof(WCHAR) < dwCharsReqd);

Exit:
    return hr;
}                                    

//
// CDebugLog helpers
//

HRESULT CDebugLog::SetResultCode(HRESULT hr)
{
    _hr = hr;

    return S_OK;
}

HRESULT CDebugLog::DebugOut(DWORD dwDetailLvl, LPWSTR pwzFormatString, ...)
{
    HRESULT                                  hr = S_OK;
    va_list                                  args;
    LPWSTR                                   wzFormatString = NULL;
    LPWSTR                                   wzDebugStr = NULL;

    /*
    wzFormatString = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzFormatString) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    */

    wzDebugStr = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzDebugStr) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    /*    
    wzFormatString[0] = L'\0';

    if (!WszLoadString(g_hInst, dwResId, wzFormatString, MAX_DBG_STR_LEN)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    */

    va_start(args, pwzFormatString);
    wvnsprintfW(wzDebugStr, MAX_DBG_STR_LEN, pwzFormatString, args);
    va_end(args);

    hr = LogMessage(dwDetailLvl, wzDebugStr, FALSE);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(wzDebugStr);
    SAFEDELETEARRAY(wzFormatString);

    return hr;
}

HRESULT CDebugLog::LogMessage(DWORD dwDetailLvl, LPCWSTR wzDebugStr, BOOL bPrepend)
{
    HRESULT                                  hr = S_OK;
    CDebugLogElement                        *pLogElem = NULL;
    
    hr = CDebugLogElement::Create(dwDetailLvl, wzDebugStr, &pLogElem);
    if (FAILED(hr)) {
        goto Exit;
    }

    _dwNumEntries += 1;

    if (bPrepend) {
        _listDbgMsg.AddHead(pLogElem);
    }
    else {
        _listDbgMsg.AddTail(pLogElem);
    }

Exit:
    return hr;    
}

HRESULT CDebugLog::DumpDebugLog(DWORD dwDetailLvl, HRESULT hrLog)
{
    HRESULT                                    hr = S_OK;
    HANDLE                                     hFile = INVALID_HANDLE_VALUE;
    LISTNODE                                   pos = NULL;
    LPWSTR                                     wzUrlName=NULL;
    CDebugLogElement                          *pLogElem = NULL;
    WCHAR                                     *wzExtension = L"HTM";
    WCHAR                                      wzFileName[MAX_PATH];
    WCHAR                                      wzSiteName[MAX_PATH];
    WCHAR                                      wzAppLogDir[MAX_PATH];
    LPWSTR                                     wzEXEName = NULL;
    LPWSTR                                     wzResourceName = NULL;
    FILETIME                                   ftTime;
    FILETIME                                   ftExpireTime;
    DWORD                                      dwBytes;
    DWORD                                      dwSize;
    BOOL                                       bRet;
//    CCriticalSection                           cs(&_cs);
    
    /*
    if (!g_dwLogFailures && !g_dwForceLog) {
        return S_FALSE;
    }
    */
    /*
    hr = cs.Lock();
    if (FAILED(hr)) {
        return hr;
    }
    */

    pos = _listDbgMsg.GetHeadPosition();
    if (!pos) {
        hr = S_FALSE;
        goto Exit;
    }

    wzUrlName = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzUrlName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Build the log entry URL and Wininet cache file
    
    wnsprintfW(wzUrlName, MAX_URL_LENGTH, L"?ClickOnceErrorLog!exe=%ws!name=%ws", _sAppName._pwz, _sDLType._pwz);

    if( dwDetailLvl == -1)
    {
        dwDetailLvl = g_dwLoggingLevel;
    }

    if (_bLogToWininet) {
        // Replace all characters > 0x80 with '?'
    
        dwSize = lstrlenW(wzUrlName);
        for (unsigned i = 0; i < dwSize; i++) {
            if (wzUrlName[i] > 0x80) {
                wzUrlName[i] = L'?';
            }
        }
        
        bRet = CreateUrlCacheEntryW(wzUrlName, 0, wzExtension, wzFileName, 0);
        if (!bRet) {
            goto Exit;
        }
    }
    else {
        wnsprintfW(wzAppLogDir, MAX_PATH, L"%ws\\%ws", _szLogPath, _wzEXEName);

        if (GetFileAttributes(wzAppLogDir) == -1) {
            BOOL bRet;

            bRet = CreateDirectory(wzAppLogDir, NULL);
            if (!bRet) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }

        if (PathIsURLW(_pwzAsmName)) {
            // This was a where-ref bind. We can't spit out a filename w/
            // the URL of the bind because the URL has invalid filename chars.
            // The best we can do is show that it was a where-ref bind, and
            // give the filename, and maybe the site.

            dwSize = MAX_PATH;
            hr = UrlGetPartW(_pwzAsmName, wzSiteName, &dwSize, URL_PART_HOSTNAME, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            wzResourceName = PathFindFileName(_pwzAsmName);

            ASSERT(wzResourceName);

            if (!lstrlenW(wzSiteName)) {
                lstrcpyW(wzSiteName, L"LocalMachine");
            }

            wnsprintfW(wzFileName, MAX_PATH, L"%ws\\FusionBindError!exe=%ws!name=WhereRefBind!Host=(%ws)!FileName=(%ws).HTM",
                       wzAppLogDir, _wzEXEName, wzSiteName, wzResourceName);
        }
        else {
            wnsprintfW(wzFileName, MAX_PATH, L"%ws\\FusionBindError!exe=%ws!name=%ws.HTM", wzAppLogDir, _wzEXEName, _pwzAsmName);
        }
    }

    // Create the and write the log file

    hr = CreateLogFile(&hFile, wzFileName, _wzEXEName, hrLog);
    if (FAILED(hr)) {
        goto Exit;
    }

    pos = _listDbgMsg.GetHeadPosition();
    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        ASSERT(pLogElem);

        if (pLogElem->_dwDetailLvl <= dwDetailLvl) {
            pLogElem->Dump(hFile);
            WriteFile(hFile, DEBUG_LOG_NEW_LINE, lstrlenW(DEBUG_LOG_NEW_LINE) * sizeof(WCHAR),
                      &dwBytes, NULL);
        }
    }

    // Close the log file and commit the wininet cache entry

    hr = CloseLogFile(&hFile);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_bLogToWininet) {
        GetSystemTimeAsFileTime(&ftTime);
        ftExpireTime.dwLowDateTime = (DWORD)0;
        ftExpireTime.dwHighDateTime = (DWORD)0;
        
        bRet = CommitUrlCacheEntryW(wzUrlName, wzFileName, ftExpireTime, ftTime,
                                    NORMAL_CACHE_ENTRY, NULL, 0, NULL, 0);
        if (!bRet) {
            hr = FusionpHresultFromLastError();
            goto Exit;
        }
        
    }

Exit:
//    cs.Unlock();
    SAFEDELETEARRAY(wzUrlName);

    return hr;
}

HRESULT CDebugLog::CloseLogFile(HANDLE *phFile)
{
    HRESULT                               hr = S_OK;
    DWORD                                 dwBytes;

    if (!phFile) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    WriteFile(*phFile, DEBUG_LOG_HTML_END, lstrlenW(DEBUG_LOG_HTML_END) * sizeof(WCHAR),
              &dwBytes, NULL);

    CloseHandle(*phFile);

    *phFile = INVALID_HANDLE_VALUE;

Exit:
    return hr;
}

HRESULT CDebugLog::CreateLogFile(HANDLE *phFile, LPCWSTR wzFileName,
                                 LPCWSTR wzEXEName, HRESULT hrLog)
{
    HRESULT                              hr = S_OK;
    SYSTEMTIME                           systime;
    LPWSTR                               pwzFormatMessage = NULL;
    DWORD                                dwFMResult = 0;
    LPWSTR                               wzBuffer = NULL;
    LPWSTR                               wzBuf = NULL;
    LPWSTR                               wzResultText = NULL;
    WCHAR                                wzDateBuffer[MAX_DATE_LEN];
    WCHAR                                wzTimeBuffer[MAX_DATE_LEN];

    if (!phFile || !wzFileName || !wzEXEName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzBuffer = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzBuf = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzResultText = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzResultText) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *phFile = CreateFile(wzFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL,
                         CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (*phFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (!_bWroteDetails) {
    
        // Details

        LogMessage(0, ID_COL_DETAILED_LOG, TRUE);
        
        // Executable path
        
        wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, L"%ws %ws", ID_COL_EXECUTABLE, g_wzEXEPath);
        LogMessage(0, wzBuffer, TRUE);

        dwFMResult = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                  FORMAT_MESSAGE_FROM_SYSTEM, 0, hrLog, 0,
                                    (LPWSTR)&pwzFormatMessage, 0, NULL);
        if (dwFMResult) {                               
            wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, ID_COL_FINAL_HR, hrLog, pwzFormatMessage);
        }
        else {
            WCHAR                             wzNoDescription[MAX_DBG_STR_LEN] = L" ";
            wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, ID_COL_FINAL_HR, hrLog, wzNoDescription);
        }
    
        LogMessage(0, wzBuffer, TRUE);
    
        // Header text
    
        GetLocalTime(&systime);

        if (!GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, wzDateBuffer, MAX_DATE_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        
        if (!GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, wzTimeBuffer, MAX_DATE_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    
        wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, L"%ws (%ws @ %ws) *** (Version=%ws)\n", ID_COL_HEADER_TEXT, wzDateBuffer, wzTimeBuffer, VER_PRODUCTVERSION_STR_L);
        LogMessage(0, wzBuffer, TRUE);
        
        // HTML start/end
    
        LogMessage(0, DEBUG_LOG_HTML_START, TRUE);
        LogMessage(0, DEBUG_LOG_HTML_META_LANGUAGE, TRUE);

        _bWroteDetails = TRUE;
    }
    
Exit:
    if (pwzFormatMessage) {
        LocalFree(pwzFormatMessage);
    }

    SAFEDELETEARRAY(wzBuffer);
    SAFEDELETEARRAY(wzBuf);
    SAFEDELETEARRAY(wzResultText);

    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\util\tlist.cpp ===
#include <fusenetincludes.h>
#include <tlist.h>

//-----------------------------------------------------------------------------
// slist::insert
// Insert single link element at head.
//-----------------------------------------------------------------------------
void slist::insert(slink *p)
{
    if (last)
        p->next = last->next;
    else
        last = p;

    last->next = p;
}

//-----------------------------------------------------------------------------
// slist::append
// Append single link element at tail.
//-----------------------------------------------------------------------------
void slist::append(slink* p)
{
    if (last)
    {
        p->next = last->next;
        last = last->next = p;
    }
    else
        last = p->next = p;
}


//-----------------------------------------------------------------------------
// slist::get
// Return next single link element ptr.
//-----------------------------------------------------------------------------
slink* slist::get()
{
    if (last == NULL) 
        return NULL;

    slink* p = last->next;

    if (p == last)
        last = NULL;
    else
        last->next = p->next;
    
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\util\regclass.cpp ===
#include <windows.h>
#include <fusenetincludes.h>

#define REGISTRY_BASE_LOCATION L"Software\\Microsoft\\Fusion\\Installer\\"

//////////////////////////////////////////////////////////////////////////////
//
//                      Emitter
//
//////////////////////////////////////////////////////////////////////////////

// ---------------------------------------------------------------------------
// CRegEmit ctor
// ---------------------------------------------------------------------------
CRegEmit::CRegEmit()
    : _hr(S_OK), _hBaseKey((HKEY) INVALID_HANDLE_VALUE)
{}


// ---------------------------------------------------------------------------
// CRegEmit dtor
// ---------------------------------------------------------------------------
CRegEmit::~CRegEmit()
{
    if (_hBaseKey != INVALID_HANDLE_VALUE)
        IF_FAILED_EXIT(RegCloseKey(_hBaseKey));

 exit:
    return;
}

// ---------------------------------------------------------------------------
// CRegEmit::Create
// ---------------------------------------------------------------------------
HRESULT CRegEmit::Create(CRegEmit **ppEmit, LPCWSTR pwzRelKeyPath, 
    CRegEmit* pParentEmit)
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    
    LONG lReturn = 0;
    DWORD dwDisposition = 0;

    CString sBasePath;
    CRegEmit *pEmit = NULL;
    
    if (!pParentEmit)
    {
        IF_FAILED_EXIT(sBasePath.Assign(REGISTRY_BASE_LOCATION));
        if (pwzRelKeyPath)
            IF_FAILED_EXIT(sBasePath.Append(pwzRelKeyPath));
        hKey = HKEY_CURRENT_USER;
    }
    else
    {
        IF_NULL_EXIT(pwzRelKeyPath, E_INVALIDARG);
        sBasePath.Assign(pwzRelKeyPath);
        hKey = pParentEmit->_hBaseKey;
    }
    IF_ALLOC_FAILED_EXIT(pEmit = new CRegEmit);
    
    lReturn = RegCreateKeyEx(
        hKey, 
        sBasePath._pwz, 
        0, 
        NULL, 
        REG_OPTION_NON_VOLATILE, 
        KEY_WRITE, 
        NULL, 
        &pEmit->_hBaseKey, 
        &dwDisposition);
    
    IF_WIN32_FAILED_EXIT(lReturn);

    *ppEmit = pEmit;

exit:
    if (FAILED(hr))
        SAFEDELETE(pEmit);

    return hr;
}

// ---------------------------------------------------------------------------
// WriteDword
// ---------------------------------------------------------------------------
HRESULT CRegEmit::WriteDword(LPCWSTR pwzValue, DWORD dwData)
{
    LONG lReturn = 0;
    
    lReturn = RegSetValueEx(_hBaseKey, pwzValue, 0, REG_DWORD, (LPBYTE) &dwData, sizeof(DWORD));

    IF_WIN32_FAILED_EXIT(lReturn);

exit:

    return _hr;

}

// ---------------------------------------------------------------------------
// WriteString
// ---------------------------------------------------------------------------
HRESULT CRegEmit::WriteString(LPCWSTR pwzValue, LPCWSTR pwzData, DWORD ccData)
{
    LONG lReturn = 0;
    DWORD cbData = 0;    
    
    IF_FALSE_EXIT(pwzData, E_INVALIDARG);

    if (ccData)
        cbData = ccData * sizeof(WCHAR);
    else
        cbData = (lstrlen(pwzData) + 1) * sizeof(WCHAR);
    
    lReturn = RegSetValueEx(_hBaseKey, pwzValue, 0, REG_SZ, (LPBYTE) pwzData, cbData);

    IF_WIN32_FAILED_EXIT(lReturn);

exit:

    return _hr;

}

// ---------------------------------------------------------------------------
// WriteString
// ---------------------------------------------------------------------------
HRESULT CRegEmit::WriteString(LPCWSTR pwzValue, CString &sData)
{
    return WriteString(pwzValue, sData._pwz, sData._cc);
}

// ---------------------------------------------------------------------------
// DeleteKey
// The one and only place we use the lousy Shlwapi apis.
// ---------------------------------------------------------------------------
HRESULT CRegEmit::DeleteKey(LPCWSTR pwzSubKey)
{
    IF_FAILED_EXIT(SHDeleteKey(_hBaseKey, pwzSubKey));

exit:
    return _hr;
}


//////////////////////////////////////////////////////////////////////////////
//
//                      Importer
//
//////////////////////////////////////////////////////////////////////////////


        
// ---------------------------------------------------------------------------
// CRegImport ctor
// ---------------------------------------------------------------------------
CRegImport::CRegImport()
    : _hr(S_OK), _hBaseKey((HKEY) INVALID_HANDLE_VALUE)
{}


// ---------------------------------------------------------------------------
// CRegImport dtor
// ---------------------------------------------------------------------------
CRegImport::~CRegImport()
{
    if (_hBaseKey != INVALID_HANDLE_VALUE)
        IF_FAILED_EXIT(RegCloseKey(_hBaseKey));

 exit:
    return;
}


// ---------------------------------------------------------------------------
// CRegImport::Create
// ---------------------------------------------------------------------------
HRESULT CRegImport::Create(CRegImport **ppImport, LPCWSTR pwzRelKeyPath,
    CRegImport *pParentImport)
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    
    LONG lReturn = 0;
    DWORD dwDisposition = 0;

    CString sBasePath;
    CRegImport *pImport = NULL;
    
    if (!pParentImport)
    {
        IF_FAILED_EXIT(sBasePath.Assign(REGISTRY_BASE_LOCATION));

        if (pwzRelKeyPath)
            IF_FAILED_EXIT(sBasePath.Append(pwzRelKeyPath));
        hKey = HKEY_CURRENT_USER;
    }
    else
    {
        IF_NULL_EXIT(pwzRelKeyPath, E_INVALIDARG);
        sBasePath.Assign(pwzRelKeyPath);
        hKey = pParentImport->_hBaseKey;
     }

    IF_ALLOC_FAILED_EXIT(pImport = new CRegImport);
    
    lReturn = RegOpenKeyEx(
        hKey,
        sBasePath._pwz,
        0,
        KEY_READ,
        &pImport->_hBaseKey);
    
    if (lReturn == ERROR_FILE_NOT_FOUND)
    {
        hr = S_FALSE;
        *ppImport = NULL;
        goto exit;
    }

    IF_WIN32_FAILED_EXIT(lReturn);

    *ppImport = pImport;

exit:
    if (FAILED(hr))
        SAFEDELETE(pImport);
    return hr;
}


// ---------------------------------------------------------------------------
// CRegImport::Create
// ---------------------------------------------------------------------------
HRESULT CRegImport::Create(CRegImport **ppImport, LPCWSTR pwzRelKeyPath,
    HKEY hkeyRoot)
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    LONG lReturn = 0;
    DWORD dwDisposition = 0;

    CString sBasePath;
    CRegImport *pImport = NULL;

    IF_NULL_EXIT(pwzRelKeyPath, E_INVALIDARG);

    IF_FAILED_EXIT(sBasePath.Assign(pwzRelKeyPath));

    IF_ALLOC_FAILED_EXIT(pImport = new CRegImport);
    
    lReturn = RegOpenKeyEx(
        hkeyRoot,
        sBasePath._pwz,
        0,
        KEY_READ,
        &pImport->_hBaseKey);
    
    if (lReturn == ERROR_FILE_NOT_FOUND)
    {
        hr = S_FALSE;
        *ppImport = NULL;
        goto exit;
    }

    IF_WIN32_FAILED_EXIT(lReturn);

    *ppImport = pImport;

exit:
    if (FAILED(hr))
        SAFEDELETE(pImport);
    return hr;
}


// ---------------------------------------------------------------------------
// Check
// ---------------------------------------------------------------------------
HRESULT CRegImport::Check(LPCWSTR pwzValue, BOOL &bExist)
{
    LONG lReturn = 0;

    bExist = FALSE;

    lReturn = RegQueryValueEx(_hBaseKey, pwzValue, NULL, NULL, NULL, NULL);

    IF_TRUE_EXIT(lReturn == ERROR_FILE_NOT_FOUND, S_FALSE);
    IF_WIN32_FAILED_EXIT(lReturn);

    bExist = TRUE;

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// ReadDword
// ---------------------------------------------------------------------------
HRESULT CRegImport::ReadDword(LPCWSTR pwzValue, LPDWORD pdwData)
{
    LONG lReturn = 0;
    DWORD dwType = REG_DWORD;
    DWORD cbData = sizeof(DWORD);

    lReturn = RegQueryValueEx(_hBaseKey, pwzValue, NULL, &dwType, (LPBYTE) pdwData, &cbData);        
    
    IF_WIN32_FAILED_EXIT(lReturn);

    // Validate reg value type
    IF_FALSE_EXIT(dwType == REG_DWORD || dwType == REG_DWORD_LITTLE_ENDIAN, E_UNEXPECTED);

exit:

    return _hr;
}

// ---------------------------------------------------------------------------
// ReadString
// ---------------------------------------------------------------------------
HRESULT CRegImport::ReadString(LPCWSTR pwzValue, CString& sData)
{
    LONG lReturn = 0;
    DWORD dwType = REG_SZ;
    DWORD cbData = 0;
    DWORD dwCC = 0;
    DWORD dwBufLen = 0;
    CStringAccessor<CString> acc;
    LPWSTR pwzData = NULL;

//    IF_FALSE_EXIT(pwzValue, E_INVALIDARG); // if pwzValue == NULL or "", the "default" value is returned

    lReturn = RegQueryValueEx(_hBaseKey, pwzValue, NULL, &dwType, NULL, &cbData);        

    IF_WIN32_FAILED_EXIT(lReturn);
    IF_FALSE_EXIT(cbData, E_FAIL);

    // Validate reg value type
    IF_FALSE_EXIT(dwType == REG_SZ || dwType == REG_EXPAND_SZ, E_UNEXPECTED);

    // Allocate for call to RQEX, with one extra char in case
    // returned buffer is not null terminated.
    dwCC = cbData / sizeof(WCHAR);
    dwBufLen = dwCC+1;

    // check overflow
    IF_FALSE_EXIT(dwBufLen > dwCC, HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));

    IF_ALLOC_FAILED_EXIT(pwzData = new WCHAR[dwBufLen]);

    lReturn = RegQueryValueEx(_hBaseKey, pwzValue, NULL, &dwType, (LPBYTE) pwzData, &cbData);        

    IF_WIN32_FAILED_EXIT(lReturn);

    // Null terminate returned buffer.
    *(pwzData + dwCC) = L'\0';

    if (*(pwzData + dwCC - 1) != L'\0')
        dwCC++;

    sData.FreeBuffer();

    // Attach accessor, set buffer, detach with corrected length.
    IF_FAILED_EXIT(acc.Attach(sData));
    *(&acc) = pwzData;

    // Buffer size could be dwCC+1
    IF_FAILED_EXIT(acc.Detach(dwCC));
    // If Detach succeeds, reset pointer so that it is freed once.
    pwzData = NULL;

exit:

    SAFEDELETEARRAY(pwzData);
    return _hr;
}


// ---------------------------------------------------------------------------
// EnumKeys
// ---------------------------------------------------------------------------
HRESULT CRegImport::EnumKeys(DWORD n, CString &sSubKey)
{
    LONG lReturn = 0;

    DWORD cSubKeys = 0, ccMaxSubKeyLen = 0, cValues = 0, 
        cMaxValueNameLen = 0, cMaxValueLen = 0;
    
    DWORD ccSubKey = 0;
    LPWSTR pwzSubKey = NULL;

    // ISSUE-2002/03/04-adriaanc
    // A race condition exists where a key could be added
    // between RegQueryInfoKey and RegEnumKey. If a key 
    // greater than ccMaxSubKeyLen is added this will cause
    // the enum call to fail. Need synchronization.
    lReturn = RegQueryInfoKey(
        _hBaseKey,
        NULL,
        NULL,
        NULL,
        &cSubKeys,
        &ccMaxSubKeyLen,
        NULL,
        &cValues,
        &cMaxValueNameLen,
        &cMaxValueLen,
        NULL,
        NULL);

    IF_WIN32_FAILED_EXIT(lReturn);

    ccSubKey = ccMaxSubKeyLen + 1;
    IF_ALLOC_FAILED_EXIT(pwzSubKey = new WCHAR[ccSubKey]);

    lReturn = RegEnumKeyEx(
        _hBaseKey,
        n,
        pwzSubKey,
        &ccSubKey,
        0,
        NULL, 
        NULL,
        NULL);

    if (lReturn == ERROR_NO_MORE_ITEMS)
    {
        _hr = S_FALSE;
        goto exit;
    }

    IF_WIN32_FAILED_EXIT(lReturn);    

    sSubKey.Assign(pwzSubKey);    

exit:

    SAFEDELETEARRAY(pwzSubKey);
    
    return _hr;
}

// ---------------------------------------------------------------------------
// EnumKeys
// ---------------------------------------------------------------------------
HRESULT CRegImport::EnumKeys(DWORD n, CRegImport **ppImport)
{
    CString sSubKey;
    CRegImport *pImport = NULL;
    
    IF_FAILED_EXIT(EnumKeys(n, sSubKey));

    if (_hr == S_FALSE)
    {
        *ppImport = NULL;
        goto exit;
    }

    IF_FAILED_EXIT(CRegImport::Create(&pImport, sSubKey._pwz, this));

    *ppImport = pImport;

exit:

    return _hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\tools\pg\xmlutil.cpp ===
#include <windows.h>
#include <fusenetincludes.h>
#include <msxml2.h>
#include <stdio.h>
#include <md5.h>
#include "list.h"
#include "xmlutil.h"


class __declspec(uuid("f6d90f11-9c73-11d3-b32e-00c04f990bb4")) private_MSXML_DOMDocument30;

#define HASHLENGTH          32
#define HASHSTRINGLENGTH    HASHLENGTH+1
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };



/////////////////////////////////////////////////////////////////////////
// FormatXML
// Called recursively.
// BUGBUG - t-peterf to document why selectNodes should not be used when
// adding nodes to an existing document.
/////////////////////////////////////////////////////////////////////////
HRESULT FormatXML(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode *pRootNode, LONG dwLevel)
{
    HRESULT hr = S_OK;
    IXMLDOMNode *pNode=NULL, *pNewNode=NULL;
    IXMLDOMNode *pTextNode1=NULL, *pTextNode2=NULL;
    CString sWhiteSpace1, sWhiteSpace2;
    BOOL bHasChildren = FALSE;    
    int i = 0;

    sWhiteSpace1.Assign(L"\n");
    for (i = 0; i < (dwLevel-1); i++)
        sWhiteSpace1.Append(L"\t");

    sWhiteSpace2.Assign(L"\n");
    for (i = 0; i < dwLevel; i++)
        sWhiteSpace2.Append(L"\t");
       
    hr = pRootNode->get_firstChild(&pNode);
    while(pNode != NULL)
    {    
        bHasChildren = TRUE;

        // create whitespace with one extra tab.
        if(FAILED(CreateXMLTextNode(pXMLDoc, sWhiteSpace2._pwz, &pTextNode2)))
            goto exit;
             
        VARIANT varRefNode;
        VariantInit(&varRefNode);
        varRefNode.vt = VT_UNKNOWN;
        V_UNKNOWN(&varRefNode) = pNode;

        if (FAILED(hr = pRootNode->insertBefore(pTextNode2, varRefNode, &pNewNode)))
            goto exit;
        SAFERELEASE(pNewNode);
        SAFERELEASE(pTextNode2);
        
        // Recursively call format on the node.
        if (FAILED(FormatXML(pXMLDoc, pNode, dwLevel+1)))
            goto exit;
      
        pNode->get_nextSibling(&pNewNode);

        SAFERELEASE(pNode);
        pNode = pNewNode;

    }

    if (bHasChildren)
    {   
        if(FAILED(CreateXMLTextNode(pXMLDoc, sWhiteSpace1._pwz, &pTextNode1)))
            goto exit;
    
        if (FAILED(hr = pRootNode->appendChild(pTextNode1, &pNewNode)))
            goto exit;
    }

exit:
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// GetAssemblyNode
/////////////////////////////////////////////////////////////////////////
HRESULT GetAssemblyNode(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode **ppAssemblyNode)
{
    HRESULT hr = S_OK;    
    BSTR bstrtQueryString;

    IXMLDOMNode *pAssemblyNode=NULL;
    IXMLDOMNodeList *pNodeList = NULL;
    LONG nNodes;
    
    bstrtQueryString = ::SysAllocString(L"assembly");
    if (!bstrtQueryString)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ((hr = pXMLDoc->selectNodes(bstrtQueryString, &pNodeList)) != S_OK)
        goto exit;

    hr = pNodeList->get_length(&nNodes);
    if (nNodes > 1)
    {        
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }

    if ((hr = pNodeList->get_item(0, &pAssemblyNode)) != S_OK)
    {
        hr = E_FAIL;
        goto exit;
    }

    *ppAssemblyNode=pAssemblyNode;
    (*ppAssemblyNode)->AddRef();
    
exit:
    if(bstrtQueryString)
        ::SysFreeString(bstrtQueryString);
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// SetXMLElementAttribute
/////////////////////////////////////////////////////////////////////////
HRESULT CreatePatchManifest(List <LPWSTR> *pPatchedFiles, LPWSTR pwzPatchDir,
    LPWSTR pwzSourceManifestPath, LPWSTR pwzDestManifestPath)
{
    HRESULT hr=S_OK;
    IXMLDOMDocument2 *pXMLDoc = NULL;
    IXMLDOMElement *pElement=NULL;
    IXMLDOMNode *pNewNode=NULL, *pRoot=NULL, *pPatchNode = NULL, *pSourceAssemblyNode= NULL;
    IAssemblyManifestImport *pSourceManImport = NULL;
    IAssemblyIdentity *pSourceAssemblyId = NULL;

    LISTNODE pos = NULL;
    CString sPatchFileName, sDestAppBase;
    LPWSTR pwzBuf=NULL;
    BSTR bstrText;

    sDestAppBase.Assign(pwzDestManifestPath);
    sDestAppBase.RemoveLastElement();
    sDestAppBase.Append(L"\\");

    //Load the manifest
    if(FAILED(hr = LoadXMLDocument(pwzDestManifestPath, &pXMLDoc)))
        goto exit;

    //Get the assemblyIdentity of the source assembly
    if((hr = CreateAssemblyManifestImport(&pSourceManImport, pwzSourceManifestPath, NULL, 0)) != S_OK)
        goto exit;

    if((hr = pSourceManImport->GetAssemblyIdentity(&pSourceAssemblyId)) != S_OK)
        goto exit;
    SAFERELEASE(pSourceManImport);

    //grab the first child(the only child) as the root node
    if(FAILED(GetAssemblyNode(pXMLDoc, &pRoot)))
        goto exit;
     
    //create the Patch node
    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"Patch", &pElement)))
        goto exit;

    //append to the assembly (root) node
    if (FAILED(hr = pRoot->appendChild((IXMLDOMNode *)pElement, &pPatchNode)))
        goto exit;    
    SAFERELEASE(pElement);

    //create the tempate assemblyIdentity node with blank attributes
    if(FAILED(hr = CreateXMLElement(pXMLDoc, L"SourceAssembly", &pElement)))
        goto exit;

    //append to the patch node 
    if (FAILED(hr = pPatchNode->appendChild((IXMLDOMNode *)pElement, &pSourceAssemblyNode)))
        goto exit;    
    SAFERELEASE(pElement);

    //Create the source assemblyId and append the source assembly node
    if(FAILED(hr = CreateXMLAssemblyIdElement(pXMLDoc, pSourceAssemblyId, &pElement)))
        goto exit;

    if (FAILED(hr = pSourceAssemblyNode->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
        goto exit;    
    SAFERELEASE(pElement);
    SAFERELEASE(pNewNode);

    //Add all the patchInfo node to the source assembly node
    pos = pPatchedFiles->GetHeadPosition();  
    while (pos)
    {
        pwzBuf= pPatchedFiles->GetNext(pos);

        pwzBuf += sDestAppBase._cc -1;

        sPatchFileName.Assign(pwzPatchDir + sDestAppBase._cc -1);
        sPatchFileName.Append(pwzBuf);
        sPatchFileName.Append(L"._p");

        if(FAILED(hr = CreateXMLElement(pXMLDoc, L"PatchInfo", &pElement)))
            goto exit;

        hr = SetXMLElementAttribute(pElement, L"file", pwzBuf);
        hr = SetXMLElementAttribute(pElement, L"patchfile", sPatchFileName._pwz);

        if (FAILED(hr = pSourceAssemblyNode->appendChild((IXMLDOMNode *)pElement, &pNewNode)))
            goto exit;    
        SAFERELEASE(pElement);
        SAFERELEASE(pNewNode);
    }


    hr = FormatXML(pXMLDoc, pRoot, 1);
    hr = SaveXMLDocument(pXMLDoc, pwzDestManifestPath);

exit:

    SAFERELEASE(pXMLDoc)
    SAFERELEASE(pElement)
    SAFERELEASE(pNewNode)
    SAFERELEASE(pRoot)
    SAFERELEASE(pPatchNode)
    SAFERELEASE(pSourceAssemblyNode)
    SAFERELEASE(pSourceManImport)
    SAFERELEASE(pSourceAssemblyId);
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// SaveXMLDocument
/////////////////////////////////////////////////////////////////////////
HRESULT SaveXMLDocument(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzDocumentName)
{
    HRESULT hr = S_OK;
    CString sDocumentName;
    BSTR bstrFileName = NULL;
    VARIANT varFileName;
    
    // Save the manifest to a file   
    sDocumentName.Assign(pwzDocumentName);

    bstrFileName = ::SysAllocString(sDocumentName._pwz);
    if (!bstrFileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    VariantInit(&varFileName);
    varFileName.vt = VT_BSTR;
    V_BSTR(&varFileName) = bstrFileName;

    hr = pXMLDoc->save(varFileName);

exit:
    if(bstrFileName)
        ::SysFreeString(bstrFileName);

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//LoadXMLTemplate
/////////////////////////////////////////////////////////////////////////
HRESULT LoadXMLDocument(LPWSTR pwzTemplatePath, IXMLDOMDocument2 **ppXMLDoc)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument2 *pXMLDoc=NULL;
    VARIANT varFileName;
    VARIANT_BOOL varBool;
    BSTR bstrFileName;

    bstrFileName = ::SysAllocString(pwzTemplatePath);
    if (!bstrFileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    VariantInit(&varFileName);
    varFileName.vt = VT_BSTR;
    V_BSTR(&varFileName) = bstrFileName;
    
    if(FAILED(hr = CoCreateInstance(__uuidof(private_MSXML_DOMDocument30), 
            NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, (void**)&pXMLDoc)))
        goto exit;

    // Load synchronously
    if (FAILED(hr = pXMLDoc->put_async(VARIANT_FALSE)))
        goto exit;

    if ((hr = pXMLDoc->load(varFileName, &varBool)) != S_OK)
        goto exit;

    *ppXMLDoc=pXMLDoc;
    (*ppXMLDoc)->AddRef();

exit:
    if(bstrFileName)
        ::SysFreeString(bstrFileName);
    SAFERELEASE(pXMLDoc);
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CreateXMLElement
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLTextNode(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzText, IXMLDOMNode **ppNode)
{
    HRESULT hr = S_OK;
    IXMLDOMNode *pNode = NULL;
    BSTR bstrText = NULL;

    bstrText = ::SysAllocString(pwzText);
    if (!bstrText)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if(FAILED(pXMLDoc->createTextNode(bstrText, (IXMLDOMText**)&pNode)))
        goto exit;

    *ppNode = pNode;
    (*ppNode)->AddRef();

exit:
    if (bstrText)
        ::SysFreeString(bstrText);

    SAFERELEASE (pNode);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CreateXMLElement
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLElement(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwzElementName, 
    IXMLDOMElement **ppElement)
{
    HRESULT hr=S_OK;
    BSTR bstrElementName = NULL;
    IXMLDOMElement *pElement = NULL;
    IXMLDOMNode *pNode =NULL, *pNewNode = NULL;

    bstrElementName = ::SysAllocString(pwzElementName);
    if (!bstrElementName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // NOTENOTE - createElement doesn't append the node to the doc
    // so we're just using pXMLDoc for convenience of calling create.
    if(FAILED(hr = pXMLDoc->createElement(bstrElementName, &pElement)))
        goto exit;

    *ppElement = pElement;
    (*ppElement)->AddRef();
    
exit:

    if (bstrElementName)
        ::SysFreeString(bstrElementName);

    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pElement);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// SetXMLElementAttribute
/////////////////////////////////////////////////////////////////////////
HRESULT SetXMLElementAttribute(IXMLDOMElement *pElement, LPWSTR pwzAttributeName,
    LPWSTR pwzAttributeValue)
{
    HRESULT hr=S_OK;
    BSTR bstrAttributeName = NULL, bstrAttributeValue = NULL;
    VARIANT varAttributeValue;

    bstrAttributeName = ::SysAllocString(pwzAttributeName);
    bstrAttributeValue = ::SysAllocString(pwzAttributeValue);
    if (!bstrAttributeName || (!bstrAttributeValue && pwzAttributeValue))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    VariantInit(&varAttributeValue);
    varAttributeValue.vt = VT_BSTR;
    V_BSTR(&varAttributeValue) = bstrAttributeValue;

    hr = pElement->setAttribute(bstrAttributeName, varAttributeValue);

exit:

    if (bstrAttributeName)
        ::SysFreeString(bstrAttributeName);

    if (bstrAttributeValue)
        ::SysFreeString(bstrAttributeValue);
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////
// CreateXMLAssemblyIdElement
/////////////////////////////////////////////////////////////////////////
HRESULT CreateXMLAssemblyIdElement(IXMLDOMDocument2 *pXMLDoc, IAssemblyIdentity *pAssemblyId, 
    IXMLDOMElement **ppElement)
{
    HRESULT hr = S_OK;
    IXMLDOMElement *pASMIdElement = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf = 0;
    CString sBuffer;

    LPWSTR rpwzAttrNames[6] = 
    {
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
    };

    //Create assemblyIdentity Element
    if(FAILED(hr=CreateXMLElement(pXMLDoc, L"assemblyIdentity",  &pASMIdElement)))
        goto exit;

    for (int i = 0; i < 6; i++)
    {
        // BUGBUG - eventually, when we add support for type the only guy which 
        // is optional is the public key token.
        if (FAILED(hr = pAssemblyId->GetAttribute(rpwzAttrNames[i], &pwzBuf, &ccBuf))
            && hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
            goto exit;
        else if (hr == S_OK)
        {            
            sBuffer.TakeOwnership(pwzBuf, ccBuf);
            hr = SetXMLElementAttribute(pASMIdElement, rpwzAttrNames[i], sBuffer._pwz);            
        }
        else
            hr = S_OK;
    }


    *ppElement = pASMIdElement;
    (*ppElement)->AddRef();
    

exit:
    SAFERELEASE(pASMIdElement);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\alignstr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    alignstr.c

Abstract:

    This module implements a number of UNICODE string routines.  These
    routines are equivalent to the corresponding C runtime routines
    with the exception that they can handle unaligned parameters.

Author:

    Forrest Foltz (forrestf) 1-Jan-2000

Revision History:

--*/


#include "basedll.h"

#if !defined(_X86_)

//
// These routines are not intended to be called directly from source,
// rather they are worker functions designed to be called from corresponding
// inlines in alignstr.h.
//
// alignstr.h will never reference these routines on an x86 platform.
//

//++
//
// PUWSTR
// __cdecl
// uaw_wcschr(
//     IN PCUWSTR String,
//     IN WCHAR   Character
//     )
//
// Routine Description:
//
//    Searches String for the first occurence of Character.
//
// Arguments:
//
//    String - Supplies an unaligned pointer to the null-terminated UNICODE
//             string to search.
//
//    Character - Supplies the UNICODE character to search for.
//
// Return Value:
//
//    Returns an unaligned pointer to the first matching character within String
//    if found, or NULL if no match was located.
//
//--

PUWSTR
__cdecl
uaw_wcschr(
    IN PCUWSTR String,
    IN WCHAR   Character
    )
{
    PUWSTR pch;

    //
    // Search the whole string looking for the first matching character.
    // Note that the search INCLUDES the terminating null character.
    //

    pch = (PUWSTR)String;
    while (TRUE) {

        if (*pch == Character) {
            return pch;
        }

        if (*pch == 0) {
            return NULL;
        }
        pch++;
    }
}

//++
//
// PUWSTR
// __cdecl
// uaw_wcscpy(
//     IN PUWSTR  Destination,
//     IN PCUWSTR Source
//     )
//
// Routine Description:
//
//    Copies a null-terminated UNICODE string.
//
// Arguments:
//
//    Destination - Supplies a possibly unaligned pointer to the destination
//                  of the copy.
//
//    Source - Supplies a possibly unaligned pointer to the UNICODE string
//             to be copied.
//
// Return Value:
//
//    Returns a possibly unaligned pointer to the destination of the copy.
//
//--

PUWSTR
_cdecl
uaw_wcscpy(
    IN PUWSTR  Destination,
    IN PCUWSTR Source
    )
{
    PCUWSTR src;
    PUWSTR dst;

    src = Source;
    dst = Destination;

    while (TRUE) {

        *dst = *src;
        if (*src == 0) {
            return Destination;
        }

        dst++;
        src++;
    }
}

//++
//
// size_t
// __cdecl
// uaw_wcslen(
//     IN PCUWSTR String
//     )
//
// Routine Description:
//
//    Determines the number of characters within a null-terminated UNICODE
//    string, excluding the null-terminator.
//
// Arguments:
//
//    String - Supplies an unaligned pointer to the null-terminated UNICODE
//             string.
//
// Return Value:
//
//    Returns the number of characters within String.
//
//--

size_t
__cdecl
uaw_wcslen(
    IN PCUWSTR String
    )
{
    PCUWSTR pch;
    
    pch = String;
    while (*pch != 0) {
        pch++;
    }
    return pch - String;
}

//++
//
// PUWSTR
// __cdecl
// uaw_wcsrchr(
//     IN PCUWSTR String,
//     IN WCHAR   Character
//     )
//
// Routine Description:
//
//    Searches String for the last occurence of Character.
//
// Arguments:
//
//    String - Supplies an unaligned pointer to the null-terminated UNICODE
//             string to search.
//
//    Character - Supplies the UNICODE character to search for.
//
// Return Value:
//
//    Returns an unaligned pointer to the last matching character within String
//    if found, or NULL if no match was located.
//
//--

PUWSTR
__cdecl
uaw_wcsrchr(
    IN PCUWSTR String,
    IN WCHAR   Character
    )
{
    PCUWSTR pch;
    PUWSTR lastMatch;

    lastMatch = NULL;
    pch = String;

    //
    // Search the whole string looking for the last matching character.
    // Note that the search INCLUDES the terminating null character.
    //

    while (TRUE) {
        if (*pch == Character) {

            //
            // Found either the first match or a new match closer to the end,
            // record its position.
            //

            lastMatch = (PUWSTR)pch;
        }

        if (*pch == 0) {
            return lastMatch;
        }
        pch++;
    }
}

int
APIENTRY
uaw_lstrcmpW(
    PCUWSTR String1,
    PCUWSTR String2
    )
{
    PCWSTR alignedString1;
    PCWSTR alignedString2;

    //
    // Create aligned copies of these strings and pass to the real
    // function.
    //

    WSTR_ALIGNED_STACK_COPY( &alignedString1, String1 );
    WSTR_ALIGNED_STACK_COPY( &alignedString2, String2 );

    return lstrcmpW( alignedString1, alignedString2 );
}

int
APIENTRY
uaw_lstrcmpiW(
    PCUWSTR String1,
    PCUWSTR String2
    )
{
    PCWSTR alignedString1;
    PCWSTR alignedString2;

    //
    // Create aligned copies of these strings and pass to the real
    // function.
    //

    WSTR_ALIGNED_STACK_COPY( &alignedString1, String1 );
    WSTR_ALIGNED_STACK_COPY( &alignedString2, String2 );

    return lstrcmpiW( alignedString1, alignedString2 );
}

int
APIENTRY
uaw_lstrlenW(
    LPCUWSTR lpString
    )
{
    if (!lpString)
        return 0;
    __try {
        return uaw_wcslen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}


#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\backup.c ===
//
//        Copyright (c) 1991  Microsoft Corporation & Maynard Electornics
//
//        Module Name:
//
//            backup.c
//
//        Abstract:
//
//            This module implements Win32 Backup APIs
//
//        Author:
//
//            Steve DeVos (@Maynard)    2 March, 1992   15:38:24
//
//        Revision History:

#include <basedll.h>
#pragma hdrstop

#include <windows.h>


#define CWCMAX_STREAMNAME        512
#define CB_NAMELESSHEADER        FIELD_OFFSET(WIN32_STREAM_ID, cStreamName)

typedef struct
{
    DWORD BufferSize;
    DWORD AllocSize;
    BYTE *Buffer;
} BUFFER;

//
//  BACKUPCONTEXT is the structure used to note the state of the backup.
//  

typedef struct
{
    //
    //  Public header describing current stream. Since this structure precedes
    //  a variable-length stream name, we must reserve space for that name
    //  following the header.
    //
    
    WIN32_STREAM_ID head;
    union {
         WCHAR            awcName[CWCMAX_STREAMNAME];
    } ex ;

    LARGE_INTEGER    cbSparseOffset ;

    //
    //  Offset in the current segment of the backup stream.  This includes
    //  the size of the above header (including variable length name).
    //

    LONGLONG        liStreamOffset;

    //
    //  BackupRead machine state
    //
    
    DWORD            StreamIndex;
    
    //
    //  Calculated size of the above header.
    //

    DWORD            cbHeader;
    
    //
    //  Handle to alternate data stream
    //

    HANDLE            hAlternate;

    //
    //  Buffers
    //

    BUFFER          DataBuffer;         //  Data buffer
    DWORD           dwSparseMapSize ;   //  size of the sparse file map
    DWORD           dwSparseMapOffset ; //  offset into the sparse map
    BOOLEAN         fSparseBlockStart ; //  TRUE if start of sparse block
    BOOLEAN         fSparseHandAlt  ;   //  TRUE if sparse stream is alt stream

    DWORD           iNameBuffer;        //  Offset into stream name buffer
    BUFFER          StreamNameBuffer;   //  Stream name buffer
    BOOLEAN            NamesReady;         //  TRUE if stream name buffer has data in it
    
    BOOLEAN            fStreamStart;       //  TRUE if start of new stream
    BOOLEAN            fMultiStreamType;   //  TRUE if stream type has > 1 stream hdr
    BOOLEAN            fAccessError;       //  TRUE if access to a stream was denied
    DWORD              fAttribs;           //  object attributes...
} BACKUPCONTEXT;


//
//  BACKUPIOFRAME describes the current user BackupRead/Write request
//

typedef struct
{
    BYTE   *pIoBuffer;
    DWORD  *pcbTransferred;
    DWORD   cbRequest;
    BOOLEAN fProcessSecurity;
} BACKUPIOFRAME;


#define CBMIN_BUFFER  1024

#define BufferOverflow(s) \
    ((s) == STATUS_BUFFER_OVERFLOW || (s) == STATUS_BUFFER_TOO_SMALL)

int mwStreamList[] =
{
    BACKUP_SECURITY_DATA,
    BACKUP_REPARSE_DATA,
    BACKUP_DATA,
    BACKUP_EA_DATA,
    BACKUP_ALTERNATE_DATA,
    BACKUP_OBJECT_ID,
    BACKUP_INVALID,
};



__inline VOID *
BackupAlloc (DWORD cb)
/*++

Routine Description:

    This is an internal routine that wraps heap allocation with tags.

Arguments:

    cb - size of block to allocate

Return Value:

    pointer to allocated memory or NULL

--*/
{
    return RtlAllocateHeap( RtlProcessHeap( ), MAKE_TAG( BACKUP_TAG ), cb );
}


__inline VOID
BackupFree (IN VOID *pv)
/*++

Routine Description:

    This is an internal routine that wraps heap freeing.

Arguments:

    pv - memory to be freed

Return Value:

    None.

--*/
{
    RtlFreeHeap( RtlProcessHeap( ), 0, pv );
}


BOOL
GrowBuffer (IN OUT BUFFER *Buffer, IN DWORD cbNew)
/*++

Routine Description:

    Attempt to grow the buffer in the backup context.

Arguments:

    Buffer - pointer to buffer
    
    cbNew - size of buffer to allocate

Return Value:

    TRUE if buffer was successfully allocated.

--*/
{
    VOID *pv;

    if ( Buffer->AllocSize < cbNew ) {
         pv = BackupAlloc( cbNew );
    
         if (pv == NULL) {
             SetLastError( ERROR_NOT_ENOUGH_MEMORY );
             return FALSE;                                                     
         }
    
         RtlCopyMemory( pv, Buffer->Buffer, Buffer->BufferSize );
         
         BackupFree( Buffer->Buffer );
    
         Buffer->Buffer = pv;
         Buffer->AllocSize = cbNew ;
     }
    
     Buffer->BufferSize = cbNew;

     return TRUE;
}

__inline VOID
FreeBuffer (IN OUT BUFFER *Buffer)
/*++

Routine Description:

    Free the buffer

Arguments:

    Buffer - pointer to buffer
    
Return Value:

    Nothing

--*/
{
    if (Buffer->Buffer != NULL) {
        BackupFree( Buffer->Buffer );
        Buffer->Buffer = NULL;
    }
}

VOID ResetAccessDate( HANDLE hand )
{
        
   LONGLONG tmp_time = -1 ;
   FILETIME *time_ptr ;

   time_ptr = (FILETIME *)(&tmp_time);

   if (hand && (hand != INVALID_HANDLE_VALUE)) {
       SetFileTime( hand,
             time_ptr, 
             time_ptr, 
             time_ptr ) ; 

   }
   
}


VOID
FreeContext (IN OUT LPVOID *lpContext)
/*++

Routine Description:

    Free a backup context and release all resources assigned to it.

Arguments:

    lpContext - pointer to pointer backup context

Return Value:

    None.

--*/
{
    BACKUPCONTEXT *pbuc = *lpContext;

    if (pbuc != INVALID_HANDLE_VALUE) {
        
        FreeBuffer( &pbuc->DataBuffer );
        FreeBuffer( &pbuc->StreamNameBuffer );
        
        ResetAccessDate( pbuc->hAlternate ) ;
        if (pbuc->hAlternate != INVALID_HANDLE_VALUE) {

            CloseHandle( pbuc->hAlternate );
        }
        
        BackupFree(pbuc);
        
        *lpContext = INVALID_HANDLE_VALUE;
    }
}


BACKUPCONTEXT *
AllocContext (IN DWORD cbBuffer)
/*++

Routine Description:

    Allocate a backup context with a buffer of a specified size

Arguments:

    cbBuffer - desired length of the buffer

Return Value:

    pointer to initialized backupcontext or NULL if out of memory.

--*/
{
    BACKUPCONTEXT *pbuc;

    pbuc = BackupAlloc( sizeof( *pbuc ));

    if (pbuc != NULL) {
        RtlZeroMemory( pbuc, sizeof( *pbuc ));
        pbuc->fStreamStart = TRUE;

        if (cbBuffer != 0 && !GrowBuffer( &pbuc->DataBuffer, cbBuffer )) {
            BackupFree( pbuc );
            pbuc = NULL;
        }
    }
    
    if (pbuc == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return(pbuc);
}



LONGLONG
ComputeRemainingSize (IN BACKUPCONTEXT *pbuc)
/*++

Routine Description:

    (Re)Compute the number of bytes required to store the current 
    stream.  This needs to take into account the header length as
    well.

Arguments:

    pbuc - backup context

Return Value:

    Amount of data still remaining to transfer.  Includes header
    size.

--*/
{
    LARGE_INTEGER ret_size ;

    ret_size.QuadPart = pbuc->cbHeader + pbuc->head.Size.QuadPart 
                               - pbuc->liStreamOffset;

    //
    // since the internally we treat the sparse buffer offset 
    // as part of the header and since the caller need to see it
    // as part of the data, this code make the internal correction.
    //
    if ( pbuc->head.dwStreamId == BACKUP_SPARSE_BLOCK  ) {

         ret_size.QuadPart -= sizeof(LARGE_INTEGER) ;
    }

    return ret_size.QuadPart ; 
}


DWORD
ComputeRequestSize (BACKUPCONTEXT *pbuc, DWORD cbrequest)
/*++

Routine Description:

    Given a transfer size request, return the number of
    bytes remaining that can safely be returned to the
    caller

Arguments:

    pbuc - context of call
    
    cbRequest - desired transfer size

Return Value:

    amount of data available to return.

--*/
{
    LONGLONG licbRemain;

    licbRemain = ComputeRemainingSize( pbuc );
    
    return (DWORD) min( cbrequest, licbRemain );
}


VOID
ReportTransfer(BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif, DWORD cbtransferred)
/*++

Routine Description:

    Note that a transfer has occurred and update contexts

Arguments:

    pbuc - context of call
    
    pbif - BACKUPIOFRAME of call detailing call
    
    cbtransferred - amount successfully transferred

Return Value:

    None.

--*/
{
    pbuc->liStreamOffset += cbtransferred;
    *pbif->pcbTransferred += cbtransferred;
    pbif->cbRequest -= cbtransferred;
    pbif->pIoBuffer += cbtransferred;
}



VOID
BackupReadBuffer (BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from the buffer in the backup
    context.

Arguments:

    pbuc - context of call
    
    pbif - frame describing desired user BackupRead request

Return Value:

    None.

--*/
{
    DWORD cbrequest;
    BYTE *pb;

    //
    //  Determine size of allowable transfer and pointer to source
    //  data
    //
    
    cbrequest = ComputeRequestSize( pbuc, pbif->cbRequest );
    pb = &pbuc->DataBuffer.Buffer[ pbuc->liStreamOffset - pbuc->cbHeader ];

    //
    //  Move the data to the user's buffer
    //
    
    RtlCopyMemory(pbif->pIoBuffer, pb, cbrequest);

    //
    //  Update statistics
    //
    
    ReportTransfer(pbuc, pbif, cbrequest);
}



BOOL
BackupReadStream (HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from the stream.

Arguments:

    hFile - handle to file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    DWORD cbrequest;
    DWORD cbtransferred;
    BOOL fSuccess;

    if (pbuc->fSparseBlockStart) {

        PFILE_ALLOCATED_RANGE_BUFFER range_buf ;
        LARGE_INTEGER licbFile ;

        range_buf = (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer + pbuc->dwSparseMapOffset) ;

        pbuc->head.Size.QuadPart = range_buf->Length.QuadPart + sizeof(LARGE_INTEGER) ;

        pbuc->head.dwStreamId = BACKUP_SPARSE_BLOCK ;
        pbuc->head.dwStreamAttributes = STREAM_SPARSE_ATTRIBUTE;

        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER + sizeof( LARGE_INTEGER ) ;

        pbuc->cbSparseOffset = range_buf->FileOffset ;

        RtlCopyMemory( pbuc->head.cStreamName, &pbuc->cbSparseOffset, sizeof( LARGE_INTEGER ) ) ;

        pbuc->fSparseBlockStart = FALSE;

        licbFile.HighPart = 0;

        licbFile.HighPart = range_buf->FileOffset.HighPart;

        licbFile.LowPart = SetFilePointer( hFile,
                              range_buf->FileOffset.LowPart,
                              &licbFile.HighPart,
                              FILE_BEGIN );

        if ( licbFile.QuadPart != range_buf->FileOffset.QuadPart ) {
            pbuc->fAccessError = TRUE;
            return FALSE ;
        } else {
            return TRUE ;
        }
    }    


    if (pbuc->liStreamOffset < pbuc->cbHeader) {

       return TRUE ;
    }

    cbrequest = ComputeRequestSize( pbuc, pbif->cbRequest );

    fSuccess = ReadFile( hFile, pbif->pIoBuffer, cbrequest, &cbtransferred, NULL );

    if (cbtransferred != 0) {
        
        ReportTransfer( pbuc, pbif, cbtransferred );
    
    } else if (fSuccess && cbrequest != 0) {
        
        SetLastError( ERROR_IO_DEVICE );
        fSuccess = FALSE;
    }
    
    return(fSuccess);
}



BOOL
BackupGetSparseMap (HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Reads the sparse data map.

Arguments:

    hFile - handle to file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
     FILE_ALLOCATED_RANGE_BUFFER  req_buf ;
     PFILE_ALLOCATED_RANGE_BUFFER last_ret_buf ;
     DWORD     out_buf_size ;
     DWORD     data_size = 4096 ;
     IO_STATUS_BLOCK iosb ;
     LARGE_INTEGER   file_size ;
     NTSTATUS        Status ;
     BOOLEAN         empty_file = FALSE ;

     req_buf.FileOffset.QuadPart = 0 ;

     pbuc->dwSparseMapSize   = 0 ;
     pbuc->dwSparseMapOffset = 0 ;
     pbuc->fSparseBlockStart = FALSE ;

     req_buf.Length.LowPart = GetFileSize( hFile, 
                                           &req_buf.Length.HighPart );

     file_size = req_buf.Length ;

     do {
          if ( GrowBuffer( &pbuc->DataBuffer, 
                           data_size ) ) {
          
               iosb.Information = 0 ;

               Status = NtFsControlFile( hFile,
                                NULL,  // overlapped event handle
                                NULL,  // Apc routine
                                NULL,  // overlapped structure
                                &iosb,
                                FSCTL_QUERY_ALLOCATED_RANGES,   
                                &req_buf,
                                sizeof( req_buf ),
                                pbuc->DataBuffer.Buffer + pbuc->dwSparseMapSize,
                                pbuc->DataBuffer.AllocSize - pbuc->dwSparseMapSize ) ;

               out_buf_size = 0 ;

               if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS( Status ) ) {
                    out_buf_size = (DWORD)iosb.Information ;
                    if ( out_buf_size == 0 ) {
                         empty_file = TRUE ;
                    }
               }

               if ( out_buf_size != 0 ) {
                    pbuc->dwSparseMapSize += out_buf_size ;

                    last_ret_buf = 
                         (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer +
                                                    pbuc->dwSparseMapSize -
                                                    sizeof(FILE_ALLOCATED_RANGE_BUFFER)) ;

                    req_buf.FileOffset = last_ret_buf->FileOffset ;
                    req_buf.FileOffset.QuadPart += last_ret_buf->Length.QuadPart ;

                    //
                    // if we can't fit any more in the buffer lets increase
                    //   the size and get more data otherwise assume were done.
                    //
                    if ( pbuc->dwSparseMapSize + sizeof(FILE_ALLOCATED_RANGE_BUFFER) >
                         pbuc->DataBuffer.AllocSize ) {
                         data_size += 4096 ;

                    } else {

                         break ;
                    }

               } else {

                    // reallocate for one more buffer entry
                    if ( out_buf_size + sizeof(FILE_ALLOCATED_RANGE_BUFFER) > data_size ) {
                         data_size += 4096 ;
                         continue ;
                    }

                    break ;
               }
          
          } else {

               pbuc->dwSparseMapSize = 0 ;
               break ;

          }
               
     } while ( TRUE ) ;

     //
     // if there are RANGE_BUFFERS and it isn't simply the whole file, then
     //     go into sparse read mode.
     //

     // hold on to your hat...   

     //  If there are no allocated ranges and the file is NOT 0 length
     //    then we want to manufacture a record for the file length.
     //

     if ( (empty_file && ( file_size.QuadPart != 0 )) || (pbuc->dwSparseMapSize >= sizeof( FILE_ALLOCATED_RANGE_BUFFER) ) ) {

          last_ret_buf = (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer ) ;

          if ( empty_file ||
               ( last_ret_buf->FileOffset.QuadPart != 0 ) ||
               ( last_ret_buf->Length.QuadPart != file_size.QuadPart ) ) {


               // first lets add a record for the EOF marker 
               pbuc->dwSparseMapSize += sizeof(FILE_ALLOCATED_RANGE_BUFFER) ;
               last_ret_buf = 
                      (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer +
                                                 pbuc->dwSparseMapSize -
                                                    sizeof(FILE_ALLOCATED_RANGE_BUFFER)) ;

               last_ret_buf->FileOffset.QuadPart = file_size.QuadPart ;
               last_ret_buf->Length.QuadPart = 0 ;

               pbuc->fSparseBlockStart = TRUE ;
               return TRUE ;
          }
     } 

     pbuc->dwSparseMapSize = 0 ;
     return FALSE ;
}
     

BOOL
BackupReadData (HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Read default data for a user BackupRead request.

Arguments:

    hFile - handle to file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    LARGE_INTEGER licbFile ;

    //
    //  If the context is not initialized for this transfer,
    //  set up based on file size.
    //
    
    if (pbuc->fStreamStart) {

        if (pbuc->fAttribs & FILE_ATTRIBUTE_ENCRYPTED) {
            return TRUE;
        }

        if (pbuc->fAttribs & FILE_ATTRIBUTE_DIRECTORY) {
            return TRUE;
        }

        licbFile.LowPart = GetFileSize( hFile, &licbFile.HighPart );

        if (licbFile.QuadPart == 0) {
            return TRUE;
        }
        
        if (licbFile.LowPart == 0xffffffff && GetLastError() != NO_ERROR) {
            return FALSE;
        }


        pbuc->head.dwStreamId = BACKUP_DATA;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;

        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;
        pbuc->fStreamStart = FALSE;

        if ( BackupGetSparseMap( hFile, pbuc, pbif ) ) {

            pbuc->head.Size.QuadPart = 0 ;
            pbuc->head.dwStreamAttributes = STREAM_SPARSE_ATTRIBUTE;

        } else {

            pbuc->head.Size = licbFile;

            licbFile.HighPart = 0;
            SetFilePointer( hFile, 0, &licbFile.HighPart, FILE_BEGIN );
        }


        return TRUE;
    }

    //
    //  If there's more data for us to read, then go and
    //  get it from the stream
    //
    

    return BackupReadStream( hFile, pbuc, pbif );
}



BOOL
BackupReadAlternateData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from alternate data streams.

Arguments:

    hFile - handle to base file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    //
    //  If we haven't started transferring alternate data streams then
    //  buffer all the stream information from the file system
    //
    
    if (pbuc->fStreamStart) {
        NTSTATUS Status;
        FILE_STREAM_INFORMATION *pfsi;
        IO_STATUS_BLOCK iosb;

        if (pbuc->fAttribs & FILE_ATTRIBUTE_ENCRYPTED) {
             if ( !(pbuc->fAttribs & FILE_ATTRIBUTE_DIRECTORY) ) {

                 return TRUE;
             }
        }

        //
        //  Loop, growing the names buffer, until it is large enough to 
        //  contain all the alternate data
        //
        
        if (!pbuc->NamesReady) {
            
            if (!GrowBuffer( &pbuc->StreamNameBuffer, 1024 ) ) {
                    
                 return FALSE;
            }
            
            while (TRUE) {
                //
                //  Resize the buffer.  If we cannot grow it, then fail.
                //
                
                Status = NtQueryInformationFile(
                            hFile,
                            &iosb,
                            pbuc->StreamNameBuffer.Buffer,
                            pbuc->StreamNameBuffer.BufferSize,
                            FileStreamInformation);

                //
                //  If we succeeded in reading some data, set the buffer
                //  up and finish initializing
                //
                
                if (NT_SUCCESS(Status) && iosb.Information != 0) {
                    pbuc->iNameBuffer = 0;
                    pbuc->NamesReady = TRUE;
                    break;
                }
                
                //
                //  If the error was not due to overflow, then skip
                //  all alternate streams
                //
                
                if (!BufferOverflow(Status)) {
                    return TRUE;        
                }

                //
                // simply inlarge the buffer and try again.
                //
                if (!GrowBuffer( &pbuc->StreamNameBuffer, 
                                 pbuc->StreamNameBuffer.BufferSize * 2)) {
                    
                    return FALSE;
                }

            }
        }

        pbuc->hAlternate = INVALID_HANDLE_VALUE;
        pbuc->fStreamStart = FALSE;
        pfsi = (FILE_STREAM_INFORMATION *) &pbuc->StreamNameBuffer.Buffer[pbuc->iNameBuffer];

        //
        //  Skip first stream if it is the default data stream.  This 
        //  code is NTFS-specific and relies on behaviour not documented anywhere.
        //
        
        if (pfsi->StreamNameLength >= 2 * sizeof(WCHAR) &&
            pfsi->StreamName[1] == ':') {
            
            if (pfsi->NextEntryOffset == 0) {
                return TRUE;                // No more, do next stream type
            }
            
            pbuc->iNameBuffer += pfsi->NextEntryOffset;
        
        }
        
        pbuc->head.Size.LowPart = 1;
    
    //
    //  If we don't have an open stream
    //

    } else if (pbuc->hAlternate == INVALID_HANDLE_VALUE) {
        NTSTATUS Status;
        PFILE_STREAM_INFORMATION pfsi;
        UNICODE_STRING strName;
        OBJECT_ATTRIBUTES oa;
        IO_STATUS_BLOCK iosb;
        DWORD reparse_flg = 0 ;

        pbuc->head.Size.QuadPart = 0;

        //
        //  Form the relative name of the stream and try to
        //  open it relative to the base file
        //
        
        pfsi = (FILE_STREAM_INFORMATION *) &pbuc->StreamNameBuffer.Buffer[pbuc->iNameBuffer];

        strName.Length = (USHORT) pfsi->StreamNameLength;
        strName.MaximumLength = strName.Length;
        strName.Buffer = pfsi->StreamName;


        if (pbuc->fAttribs & FILE_ATTRIBUTE_REPARSE_POINT ) {

             reparse_flg = FILE_OPEN_REPARSE_POINT ;

        }

        InitializeObjectAttributes(
                 &oa,
                 &strName,
                 OBJ_CASE_INSENSITIVE,
                 hFile,
                 NULL);

        Status = NtOpenFile(
                    &pbuc->hAlternate,
                    FILE_READ_DATA | SYNCHRONIZE,
                    &oa,
                    &iosb,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | reparse_flg);

        //
        //  If we did not succeed, skip this entry and set up for another stream
        //

        if (!NT_SUCCESS( Status )) {
            pbuc->iNameBuffer += pfsi->NextEntryOffset;
            if (pfsi->NextEntryOffset != 0) {
                pbuc->head.Size.LowPart = 1;
                pbuc->fMultiStreamType = TRUE;        // more to come
            }
            SetLastError( ERROR_SHARING_VIOLATION );
            return FALSE;
        }

        // if we can't lock all records, return an error
        if (!LockFile( pbuc->hAlternate, 0, 0, 0xffffffff, 0xffffffff )) {
            SetLastError( ERROR_SHARING_VIOLATION );
            return FALSE;
        }

        //
        //  Perform common header initialization
        //
        
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = pfsi->StreamNameLength;

        pbuc->cbHeader = CB_NAMELESSHEADER + pfsi->StreamNameLength;

        RtlCopyMemory(
            pbuc->head.cStreamName,
            pfsi->StreamName,
            pfsi->StreamNameLength);

        //
        //  Advance to the next stream in the stream information block
        //
        
        if (pfsi->NextEntryOffset != 0) {
            pbuc->iNameBuffer += pfsi->NextEntryOffset;
            pbuc->fMultiStreamType = TRUE;
        }
    
        //
        //  If we are a data stream, set up for data stream copy
        //

        if (BasepIsDataAttribute( pfsi->StreamNameLength, pfsi->StreamName )) {

            pbuc->head.dwStreamId = BACKUP_ALTERNATE_DATA;


            if ( BackupGetSparseMap( pbuc->hAlternate, pbuc, pbif ) ) {

                 pbuc->head.Size.QuadPart = 0 ;
                 pbuc->head.dwStreamAttributes = STREAM_SPARSE_ATTRIBUTE;

            } else {

                pbuc->head.Size.LowPart = GetFileSize(
                    pbuc->hAlternate,
                    &pbuc->head.Size.HighPart );

            }
        }

    //
    //  If we need to return the name
    //
    } else if ( pbuc->liStreamOffset < pbuc->cbHeader) {
        return TRUE ;

    //
    //  If there is more data in this stream to transfer
    //
    
    } else if ( (pbuc->head.dwStreamId == BACKUP_ALTERNATE_DATA) ||
                (pbuc->head.dwStreamId == BACKUP_SPARSE_BLOCK) ) {
    
        return BackupReadStream( pbuc->hAlternate, pbuc, pbif );
    
    }
    return TRUE;
}


BOOL
BackupReadEaData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from EA data.

Arguments:

    hFile - handle to file with EAs
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    //
    //  If we are just starting out on the EA data
    //
    
    if (pbuc->fStreamStart) {
        IO_STATUS_BLOCK iosb;

        //
        //  Loop trying to read all EA data into the buffer and
        //  resize the buffer if necessary
        //
        
        while (TRUE) {
            NTSTATUS Status;
            FILE_EA_INFORMATION fei;

            Status = NtQueryEaFile(
                        hFile,
                        &iosb,
                        pbuc->DataBuffer.Buffer,
                        pbuc->DataBuffer.BufferSize,
                        FALSE,
                        NULL,
                        0,
                        0,
                        (BOOLEAN) TRUE );
            
            //
            //  If we successfully read all the data, go complete
            //  the initialization
            //
            if (NT_SUCCESS( Status ) && iosb.Information != 0) {
                pbuc->NamesReady = TRUE;
                break;
            }

            //
            //  If we received a status OTHER than buffer overflow then
            //  skip EA's altogether
            //

            if (!BufferOverflow(Status)) {
                return TRUE;
            }

            //
            //  Get a stab at the total EA size 
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &iosb,
                        &fei,
                        sizeof(fei),
                        FileEaInformation);

            //
            //  This call should never have failed (since we were able to 
            //  QueryEaFile) above.  However, if it does, skip EAs altogether
            //
            
            if (!NT_SUCCESS(Status)) {
                return TRUE;
            }
            
            //
            //  Resize the buffer to something that seems reasonable.  No guarantees
            //  about whether this will work or not...  If we couldn't grow the buffer
            //  fail this call.
            //
            
            if (!GrowBuffer( &pbuc->DataBuffer, (fei.EaSize * 5) / 4)) {
                pbuc->fAccessError = TRUE;
                return FALSE;
            }
        }

        //
        //  Set up the header for the EA stream
        //
        
        pbuc->head.dwStreamId = BACKUP_EA_DATA;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        pbuc->head.Size.QuadPart = iosb.Information;

        pbuc->fStreamStart = FALSE;
    
    //
    //  If we have more data in the buffer to read then go
    //  copy it out.
    //
    
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        BackupReadBuffer( pbuc, pbif );
    }

    return TRUE;
}


BOOL
BackupReadObjectId(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from NtObject ID data.

Arguments:

    hFile - handle to file with EAs
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    //
    //  If we are just starting out on the Object ID data
    //
    
    if (pbuc->fStreamStart) {
        IO_STATUS_BLOCK iosb;
        NTSTATUS Status ;

        if (!GrowBuffer( &pbuc->DataBuffer, 1024 ) ) {
            pbuc->fAccessError = TRUE;
            return FALSE;
        }


        Status = NtFsControlFile( hFile,
                         NULL,  // overlapped event handle
                         NULL,  // Apc routine
                         NULL,  // overlapped structure
                         &iosb,
                         FSCTL_GET_OBJECT_ID,
                         NULL,
                         0,
                         pbuc->DataBuffer.Buffer,
                         pbuc->DataBuffer.BufferSize ) ;

        if ( !NT_SUCCESS(Status) ) {
             return TRUE ;
        }

        //
        //  Set up the header for the Object ID stream
        //

        pbuc->NamesReady = TRUE;
        
        pbuc->head.dwStreamId = BACKUP_OBJECT_ID ;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        pbuc->head.Size.QuadPart = iosb.Information;

        pbuc->fStreamStart = FALSE;
    
    //
    //  If we have more data in the buffer to read then go
    //  copy it out.
    //
    
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        BackupReadBuffer( pbuc, pbif );
    }

    return TRUE;
}


BOOL
BackupReadReparseData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from Reparse tag data.

Arguments:

    hFile - handle to file with EAs
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{

    IO_STATUS_BLOCK iosb;
    PREPARSE_DATA_BUFFER rp_buf_ptr ;
    NTSTATUS Status ;

    struct RP_SUMMARY {
           USHORT tag ;
           USHORT rp_size ;
    } *rp_summary_ptr =(struct RP_SUMMARY*) &(iosb.Information) ;


    //
    //  If the object is not a reparse then simply return
    //
    if ( !(pbuc->fAttribs & FILE_ATTRIBUTE_REPARSE_POINT) ) { 
         return TRUE ;
    }
 
    //
    //  If we are just starting out on the ReParse data
    //
    
    if (pbuc->fStreamStart) {

        //
        //  Loop trying to read all EA data into the buffer and
        //  resize the buffer if necessary
        //
     
        // for some reason a TOO_SMALL error is not setting the information
        //    member of the iosb....

        rp_summary_ptr->rp_size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE ;

        Status = NtFsControlFile( hFile,
                         NULL,  // overlapped event handle
                         NULL,  // Apc routine
                         NULL,  // overlapped structure
                         &iosb,
                         FSCTL_GET_REPARSE_POINT,
                         NULL,
                         0,
                         pbuc->DataBuffer.Buffer,
                         pbuc->DataBuffer.BufferSize ) ;


        if ( BufferOverflow( Status ) ) {
                    
            if ( rp_summary_ptr->rp_size == 0 ) {
                 rp_summary_ptr->rp_size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE ;
            }

            if (!GrowBuffer( &pbuc->DataBuffer, 
                            rp_summary_ptr->rp_size ) ) {

                 pbuc->fAccessError = TRUE;
                 return FALSE;
            }

            Status = NtFsControlFile( hFile,
                             NULL,  // overlapped event handle
                             NULL,  // Apc routine
                             NULL,  // overlapped structure
                             &iosb,
                             FSCTL_GET_REPARSE_POINT,
                             NULL,
                             0,
                             pbuc->DataBuffer.Buffer,
                             pbuc->DataBuffer.BufferSize ) ;

        }

        //
        //  If we successfully read all the data, go complete
        //  the initialization
        //
        if ( !NT_SUCCESS( Status ) ) {
            return TRUE ;
        }


        //
        //  Set up the header for the ReParse stream
        //
        
        rp_buf_ptr = (PREPARSE_DATA_BUFFER)(pbuc->DataBuffer.Buffer) ;

        pbuc->NamesReady = TRUE;

        pbuc->head.dwStreamId = BACKUP_REPARSE_DATA;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        if ( IsReparseTagMicrosoft( rp_buf_ptr->ReparseTag ) ) {
             pbuc->head.Size.QuadPart = rp_buf_ptr->ReparseDataLength +
                                        FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) ;
        } else {
             pbuc->head.Size.QuadPart = rp_buf_ptr->ReparseDataLength +
                                        FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer.DataBuffer) ;
        }

        if( (unsigned)pbuc->head.Size.QuadPart > iosb.Information ) {
            //
            // sanity check the reparse point buffer size so we don't AV
            //
            pbuc->head.Size.QuadPart = iosb.Information;
        }

        pbuc->fStreamStart = FALSE;
    
    //
    //  If we have more data in the buffer to read then go
    //  copy it out.
    //
    
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        BackupReadBuffer( pbuc, pbif );
    }

    return TRUE;
}



BOOL
BackupReadSecurityData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
{
    //
    //  If we are to skip security then do so.
    //
    
    if (!pbif->fProcessSecurity) {
        return TRUE;
    }

    //
    //  If we are just starting out on the security data
    //
    
    if (pbuc->fStreamStart) {
        
        //
        //  Loop trying to read all security data into the buffer and
        //  resize the buffer if necessary
        //
        
        while (TRUE) {
            NTSTATUS Status;
            DWORD cbSecurityInfo;

            RtlZeroMemory( pbuc->DataBuffer.Buffer, pbuc->DataBuffer.BufferSize );

            Status = NtQuerySecurityObject(
                        hFile,
                        OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION |
                            SACL_SECURITY_INFORMATION,
                        pbuc->DataBuffer.Buffer,
                        pbuc->DataBuffer.BufferSize,
                        &cbSecurityInfo );

            //
            //  If we failed but it wasn't due to buffer overflow
            //
            
            if (!NT_SUCCESS( Status ) && !BufferOverflow( Status )) {

                //
                //  Try reading everything but SACL
                //

                Status = NtQuerySecurityObject(
                            hFile,
                            OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                            pbuc->DataBuffer.Buffer,
                            pbuc->DataBuffer.BufferSize,
                            &cbSecurityInfo );
            }
            
            //
            //  If we got it all, then go continue initialization
            //

            if (NT_SUCCESS( Status )) {
                pbuc->NamesReady = TRUE;
                break;
            }


            //
            //  If not due to overflowing buffer, skip security altogether
            //
            
            if (!BufferOverflow( Status )) {
                return TRUE;
            }

            //
            //  Resize the buffer to the expected size.  If we fail, fail
            //  the entire call
            //

            if (!GrowBuffer( &pbuc->DataBuffer, cbSecurityInfo )) {
                return FALSE;
            }
        }

        //
        //  Initialize the stream header
        //

        pbuc->head.dwStreamId = BACKUP_SECURITY_DATA;
        pbuc->head.dwStreamAttributes = STREAM_CONTAINS_SECURITY;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        pbuc->head.Size.QuadPart = RtlLengthSecurityDescriptor(pbuc->DataBuffer.Buffer);

        pbuc->fStreamStart = FALSE;
    
    //
    //  If there is more data in the buffer to transfer, go
    //  do it
    //
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        
        BackupReadBuffer( pbuc, pbif );
    
    }
    
    return TRUE;
}



VOID
BackupTestRestartStream(BACKUPCONTEXT *pbuc)
{
    LONGLONG licbRemain;

    licbRemain = ComputeRemainingSize( pbuc );
    if (licbRemain == 0) {

        if ( pbuc->dwSparseMapOffset != pbuc->dwSparseMapSize ) {   // only true at backup

             if ( !pbuc->fSparseBlockStart ) {
                  pbuc->dwSparseMapOffset += sizeof ( FILE_ALLOCATED_RANGE_BUFFER ) ;
             }
        }

        if ( pbuc->dwSparseMapOffset != pbuc->dwSparseMapSize ) {   // only true at backup
             pbuc->fSparseBlockStart = TRUE ;

             pbuc->cbHeader = 0 ;
             pbuc->liStreamOffset = 0;                

        } else {
             if ( !pbuc->fSparseHandAlt && (pbuc->hAlternate != NULL)) {
                 CloseHandle(pbuc->hAlternate);        // releases any locks
                 pbuc->hAlternate = NULL;
             }
             pbuc->cbHeader = 0;
             pbuc->fStreamStart = TRUE;
             pbuc->fSparseBlockStart = TRUE;

             pbuc->liStreamOffset = 0;                // for BackupWrite

             if (!pbuc->fMultiStreamType) {                // for BackupRead
                 pbuc->StreamIndex++;
                 pbuc->head.dwStreamId = mwStreamList[pbuc->StreamIndex] ;
                 pbuc->NamesReady = FALSE;
             }
        }
    }
}



//  Routine Description:
//
//    Data can be Backed up from an object using BackupRead.
//
//    This API is used to read data from an object.  After the
//    read completes, the file pointer is adjusted by the number of bytes
//    actually read.  A return value of TRUE coupled with a bytes read of
//    0 indicates that end of file has been reached.
//
//  Arguments:
//
//    hFile - Supplies an open handle to a file that is to be read.  The
//          file handle must have been created with GENERIC_READ access.
//
//    lpBuffer - Supplies the address of a buffer to receive the data read
//          from the file.
//
//    nNumberOfBytesToRead - Supplies the number of bytes to read from the
//          file.
//
//    lpNumberOfBytesRead - Returns the number of bytes read by this call.
//          This parameter is always set to 0 before doing any IO or error
//          checking.
//
//    bAbort - If TRUE, then all resources associated with the context will
//          be released.
//
//    bProcessSecurity - If TRUE, then the NTFS ACL data will be read.
//          If FALSE, then the ACL stream will be skipped.
//
//    lpContext - Points to a buffer pointer setup and maintained by
//          BackupRead.
//
//
//  Return Value:
//
//    TRUE - The operation was successul.
//
//    FALSE - The operation failed.  Extended error status is available
//          using GetLastError.
//
//
// NOTE:
// The NT File Replication Service (NTFRS) performs an MD5 checksum on the 
// stream of data returned by BackupRead().  If the sequence of file information 
// returned changes then two machines, one downlevel and one uplevel will 
// compute different MD5 checksums for the same file data.  Under certain 
// conditions this will cause needless file replication.  Bear this in mind 
// if a change in the returned data sequence is contemplated.  The sources for
// NTFRS are in \nt\private\net\svcimgs\ntrepl.
// 

BOOL WINAPI
BackupRead(
    HANDLE  hFile,
    LPBYTE  lpBuffer,
    DWORD   nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    BOOL    bAbort,
    BOOL    bProcessSecurity,
    LPVOID  *lpContext)
{
    BACKUPCONTEXT *pbuc;
    BACKUPIOFRAME bif;
    BOOL fSuccess = FALSE;
    IO_STATUS_BLOCK iosb ;

    pbuc = *lpContext;
    bif.pIoBuffer = lpBuffer;
    bif.cbRequest = nNumberOfBytesToRead;
    bif.pcbTransferred = lpNumberOfBytesRead;
    bif.fProcessSecurity = (BOOLEAN)bProcessSecurity;

    if (bAbort) {
        if (pbuc != NULL) {
            ResetAccessDate( hFile ) ;
            FreeContext(lpContext);
        }
        return TRUE;
    }
    *bif.pcbTransferred = 0;

    if (pbuc == INVALID_HANDLE_VALUE || bif.cbRequest == 0) {
        return TRUE;
    }

    if (pbuc != NULL && mwStreamList[pbuc->StreamIndex] == BACKUP_INVALID) {
        ResetAccessDate( hFile ) ;
        FreeContext(lpContext);
        return TRUE;
    }

    // Allocate our Context Control Block on first call.

    if (pbuc == NULL) {
        pbuc = AllocContext(CBMIN_BUFFER);        // Alloc initial buffer

        // ok, we allocated the context, Lets initialize it.
        if (pbuc != NULL) {
            NTSTATUS Status ;
            FILE_BASIC_INFORMATION fbi;

            Status = NtQueryInformationFile(
                        hFile,
                        &iosb,
                        &fbi,
                        sizeof(fbi),
                        FileBasicInformation );

            if ( NT_SUCCESS( Status ) ) {
               pbuc->fAttribs = fbi.FileAttributes ;
            } else {
               BaseSetLastNTError( Status );
               return FALSE ;
            }

        }
          
    }

    if (pbuc != NULL) {
        *lpContext = pbuc;

        do {

            if (pbuc->fStreamStart) {
                pbuc->head.Size.QuadPart = 0;

                pbuc->liStreamOffset = 0;

                pbuc->dwSparseMapOffset = 0;
                pbuc->dwSparseMapSize   = 0;

                pbuc->fMultiStreamType = FALSE;
            }
            fSuccess = TRUE;

            switch (mwStreamList[pbuc->StreamIndex]) {
                case BACKUP_DATA:
                    fSuccess = BackupReadData(hFile, pbuc, &bif);
                    break;

                case BACKUP_ALTERNATE_DATA:
                    fSuccess = BackupReadAlternateData(hFile, pbuc, &bif);
                    break;

                case BACKUP_EA_DATA:
                    fSuccess = BackupReadEaData(hFile, pbuc, &bif);
                    break;

                case BACKUP_OBJECT_ID:
                    fSuccess = BackupReadObjectId(hFile, pbuc, &bif);
                    break;

                case BACKUP_REPARSE_DATA:
                    fSuccess = BackupReadReparseData(hFile, pbuc, &bif);
                    break;

                case BACKUP_SECURITY_DATA:
                    fSuccess = BackupReadSecurityData(hFile, pbuc, &bif);
                    break;

                default:
                    pbuc->StreamIndex++;
                    pbuc->fStreamStart = TRUE;
                    break;
            }

            // if we're in the phase of reading the header, copy the header

            if (pbuc->liStreamOffset < pbuc->cbHeader) {

                DWORD cbrequest;

                //  Send the current stream header;

                cbrequest = 
                    (ULONG)min( pbuc->cbHeader - pbuc->liStreamOffset,
                                bif.cbRequest);

                RtlCopyMemory(
                    bif.pIoBuffer,
                    (BYTE *) &pbuc->head + pbuc->liStreamOffset,
                    cbrequest);

                ReportTransfer(pbuc, &bif, cbrequest);
            }

            //
            // if we are at the end of a stream then
            //          start at the beginning of the next stream
            //

            if (pbuc->liStreamOffset >= pbuc->cbHeader) {
                 BackupTestRestartStream(pbuc);
            }

        } while (fSuccess &&
                 mwStreamList[pbuc->StreamIndex] != BACKUP_INVALID &&
                 bif.cbRequest != 0);
    }
    
    if (fSuccess && *bif.pcbTransferred == 0) {
        ResetAccessDate( hFile ) ;
        FreeContext(lpContext);
    }
    
    return(fSuccess);
}



//  Routine Description:
//
//    Data can be skiped during BackupRead or BackupWrite by using
//    BackupSeek.
//
//    This API is used to seek forward from the current position the
//    specified number of bytes.  This function does not seek over a
//    stream header.  The number of bytes actually seeked is returned.
//    If a caller wants to seek to the start of the next stream it can
//    pass 0xffffffff, 0xffffffff as the amount to seek.  The number of
//    bytes actually skiped over is returned.
//
//  Arguments:
//
//    hFile - Supplies an open handle to a file that is to be read.  The
//          file handle must have been created with GENERIC_READ or
//          GENERIC_WRITE access.
//
//    dwLowBytesToSeek - Specifies the low 32 bits of the number of bytes
//          requested to seek.
//
//    dwHighBytesToSeek - Specifies the high 32 bits of the number of bytes
//          requested to seek.
//
//    lpdwLowBytesSeeked - Points to the buffer where the low 32 bits of the
//          actual number of bytes to seek is to be placed.
//
//    lpdwHighBytesSeeked - Points to the buffer where the high 32 bits of the
//          actual number of bytes to seek is to be placed.
//
//    bAbort - If true, then all resources associated with the context will
//          be released.
//
//    lpContext - Points to a buffer pointer setup and maintained by
//          BackupRead.
//
//
//  Return Value:
//
//    TRUE - The operation successfuly seeked the requested number of bytes.
//
//    FALSE - The requested number of bytes could not be seeked. The number
//          of bytes actually seeked is returned.

BOOL WINAPI
BackupSeek(
    HANDLE  hFile,
    DWORD   dwLowBytesToSeek,
    DWORD   dwHighBytesToSeek,
    LPDWORD lpdwLowBytesSeeked,
    LPDWORD lpdwHighBytesSeeked,
    LPVOID *lpContext)
{
    BACKUPCONTEXT *pbuc;
    LONGLONG licbRemain;
    LARGE_INTEGER licbRequest;
    BOOL fSuccess;
    LARGE_INTEGER sparse_bytes ;

    pbuc = *lpContext;

    sparse_bytes.QuadPart = 0 ;

    *lpdwHighBytesSeeked = 0;
    *lpdwLowBytesSeeked = 0;

    if (pbuc == INVALID_HANDLE_VALUE || pbuc == NULL || pbuc->fStreamStart) {
        return FALSE;
    }

    if (pbuc->liStreamOffset < pbuc->cbHeader) {
        return FALSE;
    }

    //
    // If we made it here, we are in the middle of a stream
    //

    licbRemain = ComputeRemainingSize( pbuc );

    licbRequest.LowPart = dwLowBytesToSeek;
    licbRequest.HighPart = dwHighBytesToSeek & 0x7fffffff;

    if (licbRequest.QuadPart > licbRemain) {
        licbRequest.QuadPart = licbRemain;
    }
    fSuccess = TRUE;

    switch (pbuc->head.dwStreamId) {
    case BACKUP_EA_DATA:
    case BACKUP_SECURITY_DATA:
    case BACKUP_OBJECT_ID :
    case BACKUP_REPARSE_DATA :

        // assume less than 2gig of data

        break;

    case BACKUP_SPARSE_BLOCK :
         if ( pbuc->liStreamOffset < sizeof(LARGE_INTEGER) ) {
              sparse_bytes.QuadPart = ( sizeof(LARGE_INTEGER) - pbuc->liStreamOffset ) ;
              if ( sparse_bytes.QuadPart < licbRequest.QuadPart ) {
                  licbRequest.QuadPart -= sparse_bytes.QuadPart ;
              } else {
                  licbRequest.QuadPart = 0 ;
              }
         }
    case BACKUP_DATA:
    case BACKUP_ALTERNATE_DATA:
        {
            LARGE_INTEGER liCurPos;
            LARGE_INTEGER liNewPos;
            HANDLE hf;
    
            //        set up the correct handle to seek with
    
            if (pbuc->head.dwStreamId == BACKUP_DATA) {
                hf = hFile;
            }
            else {
                hf = pbuc->hAlternate;
            }
    
            // first, let's get the current position
    
            liCurPos.HighPart = 0;
            liCurPos.LowPart = SetFilePointer(
                    hf,
                    0,
                    &liCurPos.HighPart,
                    FILE_CURRENT);
    
            // Now seek the requested number of bytes
    
            liNewPos.HighPart = licbRequest.HighPart;
            liNewPos.LowPart = SetFilePointer(
                    hf,
                    licbRequest.LowPart,
                    &liNewPos.HighPart,
                    FILE_CURRENT);
    
            // Assume that we seek the requested amount because if we do not,
            // subsequent reads will fail and the caller will never be able
            // to read to the next stream.
    
            break;
        }

    default:
        break;
    }
    
    if (dwHighBytesToSeek != (DWORD) licbRequest.HighPart ||
        dwLowBytesToSeek != licbRequest.LowPart) {
        fSuccess = FALSE;
    }
    licbRequest.QuadPart += sparse_bytes.QuadPart ;
    pbuc->liStreamOffset += licbRequest.QuadPart ;

    *lpdwLowBytesSeeked = licbRequest.LowPart;
    *lpdwHighBytesSeeked = licbRequest.HighPart;

    BackupTestRestartStream(pbuc);

    if (!fSuccess) {
        SetLastError(ERROR_SEEK);
    }
    return(fSuccess);
}



BOOL
BackupWriteHeader(BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif, DWORD cbHeader)
/*++

Routine Description:

    This is an internal routine that fills our internal backup header
    from the user's data.

Arguments:

    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
    cbHeader - size of header to fill

Return Value:

    None.

--*/
{
    //
    //  Determine how much data we can transfer into our header.  
    //
    
    DWORD cbrequest = 
        (DWORD) min( pbif->cbRequest, cbHeader - pbuc->liStreamOffset );

    //
    //  Copy from user buffer into header
    //


    if ( pbuc->liStreamOffset+cbrequest > CWCMAX_STREAMNAME + CB_NAMELESSHEADER ) {
         return FALSE ;
    }

    RtlCopyMemory(
        (CHAR *) &pbuc->head + pbuc->liStreamOffset,
        pbif->pIoBuffer,
        cbrequest);

    //
    //  Update transfer statistics
    //
    
    ReportTransfer(pbuc, pbif, cbrequest);

    //
    //  If we've filled up the header, mark the header as complete
    //  even though we might need more if names are present
    //
    
    if (pbuc->liStreamOffset == cbHeader) {
        pbuc->cbHeader = cbHeader;
    }

    return TRUE ;
}



typedef enum {
    BRB_FAIL,
    BRB_DONE,
    BRB_MORE,
} BUFFERSTATUS;

BUFFERSTATUS
BackupWriteBuffer(BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that fills our internal buffer
    from the user's data.

Arguments:

    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    BRB_FAIL if an error occurred (out of memory)
    
    BRB_DONE if buffer is full or was successfully filled
    
    BRB_MORE if buffer is partially full

--*/
{
    DWORD cbrequest;

    //
    //  If we're starting out on the buffer, we make sure
    //  we have a buffer to contain all of the data since
    //  the Nt calls we'll use must have all the data 
    //  present
    //

    if (pbuc->fStreamStart) {
        pbuc->fStreamStart = FALSE;

        if (pbuc->DataBuffer.BufferSize < pbuc->head.Size.QuadPart &&
            !GrowBuffer( &pbuc->DataBuffer, pbuc->head.Size.LowPart )) {

            return(BRB_FAIL);
        }
    }

    //
    //  Determine how much data from the user buffer is
    //  needed to fill our buffer
    //
    
    cbrequest = ComputeRequestSize( pbuc, pbif->cbRequest );
    
    //
    //  Fill in the next portion of the buffer
    //
    
    RtlCopyMemory(
        pbuc->DataBuffer.Buffer + pbuc->liStreamOffset - pbuc->cbHeader,
        pbif->pIoBuffer,
        cbrequest);

    //
    //  Update transfer statistics
    //
    
    ReportTransfer(pbuc, pbif, cbrequest);

    //
    //  If we've entirely filled the buffer, let our caller know
    //
    
    return ComputeRemainingSize( pbuc ) == 0 ? BRB_DONE : BRB_MORE;
}


BOOL
BackupWriteSparse(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes sparse block of stream data from
    the user's buffer into the output handle.  The BACKUPCONTEXT contains
    the total length of data to be output.

Arguments:

    hFile - output file handle
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if data was successfully written, FALSE otherwise.

--*/
{
     LARGE_INTEGER licbFile ;
     DWORD cbrequest;
     DWORD cbtransferred;
     BOOL fSuccess;

     if ( pbuc->fSparseBlockStart ) {

         RtlCopyMemory( &pbuc->cbSparseOffset, pbuc->head.cStreamName, sizeof( LARGE_INTEGER ) ) ;

         licbFile = pbuc->cbSparseOffset;

         licbFile.LowPart = SetFilePointer( pbuc->fSparseHandAlt?pbuc->hAlternate:hFile,
                              licbFile.LowPart,
                              &licbFile.HighPart,
                              FILE_BEGIN );

         if ( licbFile.QuadPart != pbuc->cbSparseOffset.QuadPart ) {
            return FALSE ;
         }

         if ( pbuc->head.Size.QuadPart == sizeof( LARGE_INTEGER ) ) {
              SetEndOfFile(pbuc->fSparseHandAlt?pbuc->hAlternate:hFile) ;
         }    
         pbuc->fSparseBlockStart = FALSE ;
     }

     //
     //  Determine how much data from the user buffer is
     //  needed to be written into the stream and perform
     //  the transfer.
     //
     
     cbrequest = ComputeRequestSize(pbuc, pbif->cbRequest);

     fSuccess = WriteFile(
                     pbuc->fSparseHandAlt?pbuc->hAlternate:hFile,
                     pbif->pIoBuffer,
                     cbrequest,
                     &cbtransferred,
                     NULL);

     //
     //  Update transfer statistics
     //

     ReportTransfer(pbuc, pbif, cbtransferred);
     
     return(fSuccess);

     return TRUE ;
}


BOOL
BackupWriteStream(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes stream data from the user's
    buffer into the output handle.  The BACKUPCONTEXT contains the total
    length of data to be output.

Arguments:

    hFile - output file handle
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if data was successfully written, FALSE otherwise.

--*/
{
    DWORD cbrequest;
    DWORD cbtransferred;
    BOOL fSuccess;
    IO_STATUS_BLOCK iosb;


    if ( pbuc->fStreamStart ) {

       if  ( pbuc->head.dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE ) {

            // if it was sparse when be backed it up make is sparse again.
            NtFsControlFile( hFile,
              NULL,  // overlapped event handle
              NULL,  // Apc routine
              NULL,  // overlapped structure
              &iosb,
              FSCTL_SET_SPARSE ,
              NULL,
              0,
              NULL,
              0 ) ;

       } else {

              LARGE_INTEGER end_of_file ;

              end_of_file.QuadPart = pbuc->head.Size.QuadPart ;
              SetFilePointer( hFile,
                              end_of_file.LowPart,
                              &end_of_file.HighPart,
                              FILE_BEGIN );

              SetEndOfFile(hFile) ;

              end_of_file.QuadPart = 0 ;
              SetFilePointer( hFile,
                              end_of_file.LowPart,
                              &end_of_file.HighPart,
                              FILE_BEGIN );


       }

       pbuc->fStreamStart = FALSE;
    }

    //
    //  Determine how much data from the user buffer is
    //  needed to be written into the stream and perform
    //  the transfer.
    //
    
    cbrequest = ComputeRequestSize(pbuc, pbif->cbRequest);

    fSuccess = WriteFile(
                    hFile,
                    pbif->pIoBuffer,
                    cbrequest,
                    &cbtransferred,
                    NULL);

    //
    //  Update transfer statistics
    //
    
    ReportTransfer(pbuc, pbif, cbtransferred);
    
    return(fSuccess);
}



BOOL
BackupWriteAlternateData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that overwrites an alternate data stream with
    data from the user's buffer.  

Arguments:

    hFile - handle to the file itself.  This is not the handle to the stream
        being overwritten.
    
    pbuc - CONTEXT of call.  This contains the name of the stream.
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if data was successfully written, FALSE otherwise.

--*/
{
    //
    //  If we are just starting out on this stream then attempt to
    //  overwrite the new stream.
    //
    
    if (pbuc->fStreamStart) {
        NTSTATUS Status;
        UNICODE_STRING strName;
        OBJECT_ATTRIBUTES oa;
        IO_STATUS_BLOCK iosb;
        DWORD reparse_flg = 0 ;

        strName.Length = (USHORT) pbuc->head.dwStreamNameSize;
        strName.MaximumLength = strName.Length;
        strName.Buffer = pbuc->head.cStreamName;

        if (pbuc->hAlternate != INVALID_HANDLE_VALUE) {
             CloseHandle(pbuc->hAlternate);        
             pbuc->hAlternate = INVALID_HANDLE_VALUE;
             pbuc->fSparseHandAlt = FALSE ;
        }


        if (pbuc->fAttribs & FILE_ATTRIBUTE_REPARSE_POINT ) {
             reparse_flg = FILE_OPEN_REPARSE_POINT ;
        }

        InitializeObjectAttributes(
                &oa,
                &strName,
                OBJ_CASE_INSENSITIVE,
                hFile,
                NULL);

        Status = NtCreateFile(
                    &pbuc->hAlternate,
                    FILE_WRITE_DATA | SYNCHRONIZE,
                    &oa,
                    &iosb,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    FILE_OVERWRITE_IF,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | reparse_flg,
                    NULL,
                    0L);

        //
        //  If we failed, map the error, record the failure, and return failure.
        //
        
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            pbuc->fAccessError = TRUE;
            return FALSE;
        }

        if ( pbuc->head.dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE ) {
           pbuc->fSparseHandAlt = TRUE ;

           // if it was sparse when be backed it up make is sparse again.
           NtFsControlFile( pbuc->hAlternate,
                  NULL,  // overlapped event handle
                  NULL,  // Apc routine
                  NULL,  // overlapped structure
                  &iosb,
                  FSCTL_SET_SPARSE ,
                  NULL,
                  0,
                  NULL,
                  0 ) ;
        }

        // don't reset stream start because WriteStream will do it.

    }

    //
    //  If we have no handle for the transfer, record this failure
    //  and return failure.
    //
    
    if (pbuc->hAlternate == INVALID_HANDLE_VALUE) {
        pbuc->fAccessError = TRUE;
        return FALSE;
    }
    
    //
    //  Let the normal stream copy perform the transfer
    //
    
    return BackupWriteStream( pbuc->hAlternate, pbuc, pbif );
}



BOOL
BackupWriteEaData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes EA data on the file from 
    the user's buffer

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if EA data was successfully written, FALSE otherwise.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK iosb;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer( pbuc, pbif )) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our EA data.  Set the
    //  EA data on the file.
    //
    
    Status = NtSetEaFile(
                hFile,
                &iosb,
                pbuc->DataBuffer.Buffer,
                pbuc->head.Size.LowPart );

    //
    //  If we failed, map the error and return failure
    //
    
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
    }
    
    return TRUE;
}


BOOL
BackupWriteReparseData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes Reparse data on the file from 
    the user's buffer

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if EA data was successfully written, FALSE otherwise.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK iosb;
    DWORD *rp_tag_ptr ;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer( pbuc, pbif )) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our Reparse data.  Set the
    //  Reparse data on the file.
    //


    rp_tag_ptr = (DWORD *)(pbuc->DataBuffer.Buffer) ;
    
    pbuc->fAttribs |= FILE_ATTRIBUTE_REPARSE_POINT ;


    Status = NtFsControlFile( hFile,
                     NULL,  // overlapped event handle
                     NULL,  // Apc routine
                     NULL,  // overlapped structure
                     &iosb,
                     FSCTL_SET_REPARSE_POINT,
                     pbuc->DataBuffer.Buffer,
                     pbuc->head.Size.LowPart,
                     NULL,
                     0 ) ;
    
    //
    //  If we failed, map the error and return failure
    //
    
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
    }
    
    return TRUE;
}


BOOL
BackupWriteObjectId(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes the Object IDa on the file from 
    the user's buffer. Birth ids are made reborn. i.e. the volume id component
    of the birth id is changed to the current volume's id, and the object id
    component of the birth id is changed to the current object id.

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if Object ID was successfully written, FALSE otherwise.

--*/
{
    IO_STATUS_BLOCK iosb;
    NTSTATUS  Status ;
    FILE_FS_OBJECTID_INFORMATION fsobOID;
    GUID guidZero;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer( pbuc, pbif )) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    // Zero out the birth ID (the extended 48 bytes)
    //

    memset(&pbuc->DataBuffer.Buffer[sizeof(GUID)], 0, 3*sizeof(GUID));

    //
    //  Set the ID on the file.
    //
    
    Status = NtFsControlFile( hFile,
                     NULL,  // overlapped event handle
                     NULL,  // Apc routine
                     NULL,  // overlapped structure
                     &iosb,
                     FSCTL_SET_OBJECT_ID,
                     pbuc->DataBuffer.Buffer,
                     pbuc->head.Size.LowPart,
                     NULL,
                     0);


    //
    //  Ignore errors
    //

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
    }

    return( TRUE );
    
}




BOOL
BackupWriteSecurityData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that sets security information on the 
    file from data in the user's buffer.

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if security was successfully written, FALSE otherwise.

--*/
{
    NTSTATUS Status;
    SECURITY_INFORMATION si;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer(pbuc, pbif)) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our security data.  If we 
    //  are to ignore it, then return success
    //
    
    if (!pbif->fProcessSecurity) {
        return TRUE;
    }
    
    //  
    //  Find out what security information is present so we know what to 
    //  set.

    si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION;

    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_DACL_PRESENT) {
        si |= DACL_SECURITY_INFORMATION;
    }

    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_SACL_PRESENT) {
        si |= SACL_SECURITY_INFORMATION;
    }

    //
    // If the security descriptor has AUTO_INHERITED set, set the appropriate REQ bits.
    //
    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_DACL_AUTO_INHERITED) {
        ((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_SACL_AUTO_INHERITED) {
        ((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }
    
    Status = NtSetSecurityObject( hFile, si, pbuc->DataBuffer.Buffer );

    if (!NT_SUCCESS( Status )) {

        NTSTATUS Status2;

        //
        //  If that didn't work, the caller is probably not running as Backup
        //  Operator, so we can't set the owner and group.  Keep the current
        //  status code, and attempt to set the DACL and SACL while ignoring
        //  failures.
        //

        if (si & SACL_SECURITY_INFORMATION) {
            NtSetSecurityObject(
                        hFile,
                        SACL_SECURITY_INFORMATION,
                        pbuc->DataBuffer.Buffer );
        }

        if (si & DACL_SECURITY_INFORMATION) {
            Status = NtSetSecurityObject(
                            hFile,
                            DACL_SECURITY_INFORMATION,
                            pbuc->DataBuffer.Buffer);
        }

        Status2 = NtSetSecurityObject(
                            hFile,
                            OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION,
                            pbuc->DataBuffer.Buffer);

        if (NT_SUCCESS(Status)) {
            Status = Status2;
        }
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    
    return TRUE;
}



BOOL
BackupWriteLinkData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that establishes links based on the
    user's data.

Arguments:

    hFile - handle of file being restored
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if link was successfully established, FALSE otherwise.

--*/
{
    FILE_LINK_INFORMATION *pfli;
    WCHAR *pwc;
    WCHAR *pwcSlash;
    INT cbName;
    INT cSlash;
    WCHAR wcSave;
    BOOL fSuccess;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer(pbuc, pbif)) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our link data.  
    //  Find the last component of the name.
    //
    
    cSlash = 0;
    pwcSlash = NULL;
    pwc = (WCHAR *) pbuc->DataBuffer.Buffer;
    cbName = sizeof(WCHAR);

    while (*pwc != L'\0') {
        if (*pwc == L'\\') {
            pwcSlash = pwc;
            cSlash++;
            cbName = 0;
        }
        pwc++;
        cbName += sizeof(WCHAR);
    }

    pfli = BackupAlloc( sizeof(*pfli) + cbName );

    if (pfli == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RtlCopyMemory( pfli->FileName, pwcSlash + 1, cbName );
    pfli->FileNameLength = cbName - sizeof(WCHAR);
    if (cSlash > 1) {
        wcSave = L'\\';
    }
    else {
        wcSave = *pwcSlash++;
    }
    *pwcSlash = L'\0';

    //
    //  Open the parent of the link target
    //
    
    pfli->RootDirectory = CreateFileW(
        (WCHAR *) pbuc->DataBuffer.Buffer,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL| FILE_FLAG_BACKUP_SEMANTICS,
        NULL );

    *pwcSlash = wcSave;
    pfli->ReplaceIfExists = TRUE;

    fSuccess = TRUE;

    if (pfli->RootDirectory == INVALID_HANDLE_VALUE) {
        SetLastError( ERROR_FILE_NOT_FOUND );
        fSuccess = FALSE;
    }
    else {
        NTSTATUS Status;
        IO_STATUS_BLOCK iosb;

        Status = NtSetInformationFile(
                    hFile,
                    &iosb,
                    pfli,
                    sizeof(*pfli) + cbName,
                    FileLinkInformation );

        CloseHandle( pfli->RootDirectory );
        pfli->RootDirectory = INVALID_HANDLE_VALUE;
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            fSuccess = FALSE;
        } else {
            if (iosb.Information == FILE_OVERWRITTEN) {
                SetLastError( ERROR_ALREADY_EXISTS );
            } else {
                SetLastError( 0 );
            }
        }
    }
    
    BackupFree( pfli );
    
    return fSuccess;
}



//  Routine Description:
//
//    Data can be written to a file using BackupWrite.
//
//    This API is used to Restore data to an object.  After the
//    write completes, the file pointer is adjusted by the number of bytes
//    actually written.
//
//    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
//    or extend the file.  If this function is required, SetEndOfFile
//    should be used.
//
//  Arguments:
//
//    hFile - Supplies an open handle to a file that is to be written.  The
//          file handle must have been created with GENERIC_WRITE access to
//          the file.
//
//    lpBuffer - Supplies the address of the data that is to be written to
//          the file.
//
//    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
//          file. Unlike DOS, a value of zero is interpreted a null write.
//
//    lpNumberOfBytesWritten - Returns the number of bytes written by this
//          call. Before doing any work or error processing, the API sets this
//          to zero.
//
//    bAbort - If true, then all resources associated with the context will
//          be released.
//
//    bProcessSecurity - If TRUE, then the NTFS ACL data will be written.
//          If FALSE, then the ACL stream will be ignored.
//
//    lpContext - Points to a buffer pointer setup and maintained by
//          BackupRead.
//
//
//  Return Value:
//
//    TRUE - The operation was a success.
//
//    FALSE - The operation failed.  Extended error status is
//          available using GetLastError.

BOOL WINAPI
BackupWrite(
    HANDLE  hFile,
    LPBYTE  lpBuffer,
    DWORD   nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    BOOL    bAbort,
    BOOL    bProcessSecurity,
    LPVOID  *lpContext)
{
    BACKUPCONTEXT *pbuc;
    BACKUPIOFRAME bif;
    BOOL fSuccess = FALSE;

    pbuc = *lpContext;
    bif.pIoBuffer = lpBuffer;
    bif.cbRequest = nNumberOfBytesToWrite;
    bif.pcbTransferred = lpNumberOfBytesWritten;
    bif.fProcessSecurity = (BOOLEAN)bProcessSecurity;

    //
    // Allocate our Context Control Block on first call.
    //

    if (bAbort) {
        if (pbuc != NULL) {
            FreeContext(lpContext);
        }
        return TRUE;
    }

    *bif.pcbTransferred = 0;
    if (pbuc == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    // Allocate our Context Control Block on first call.

    if (pbuc == NULL) {
        pbuc = AllocContext(0);                        // No initial buffer

        //
        //  If we have no space then return failure
        //
        
        if (pbuc == NULL) {
            return FALSE;           
        }

    }

    *lpContext = pbuc;

    do {
        DWORD cbrequest;
        LONGLONG licbRemain;

        //
        //  If we do not have a complete header, go
        //  fill it in.
        //
        
        if (pbuc->cbHeader == 0) {

            pbuc->fMultiStreamType = TRUE ;    //restore does not auto inc stream index.
            pbuc->fStreamStart = TRUE ;

            BackupWriteHeader(pbuc, &bif, CB_NAMELESSHEADER) ;

        }

        //
        //  If no more data, then exit
        //
        
        if (bif.cbRequest == 0) {
            return TRUE;
        }

        //
        //  If a stream name was expected, go read it in
        //
        
        if (pbuc->cbHeader == CB_NAMELESSHEADER &&
            pbuc->head.dwStreamNameSize != 0) {

            if ( !BackupWriteHeader(
                    pbuc,
                    &bif,
                    pbuc->cbHeader + pbuc->head.dwStreamNameSize) )
            {
                 SetLastError( ERROR_INVALID_DATA );
                 return FALSE ;
            }

            //
            //  If no more data then exit
            //
            
            if (bif.cbRequest == 0) {
                return TRUE;
            }
        } 

     
        if ( ( pbuc->cbHeader == CB_NAMELESSHEADER ) &&
             ( pbuc->head.dwStreamId == BACKUP_SPARSE_BLOCK ) ) {
      
            BackupWriteHeader(
                pbuc,
                &bif,
                pbuc->cbHeader + sizeof(LARGE_INTEGER) );

            //
            //  If no more data then exit
            //
            
            if (bif.cbRequest == 0) {

               if ( pbuc->cbHeader == CB_NAMELESSHEADER ) {
                   return TRUE;
               }
            }
        }
        
        //
        //  Determine amount of data remaining in user buffer
        //  that can be transferred as part of this section
        //  of the backup stream
        //

        cbrequest = ComputeRequestSize(pbuc, bif.cbRequest);

        //
        //  Determine total amount of data left in this section
        //  of backup stream.
        //
        
        licbRemain = ComputeRemainingSize( pbuc );

        //
        //  If we had an error in the transfer and we're done
        //  doing the transfer then pretend that we successfully 
        //  completed the section.
        //
        
        if (pbuc->fAccessError && licbRemain == 0) {

            ReportTransfer(pbuc, &bif, cbrequest);
            continue;
        }
        
        //
        //  Begin or continue the transfer of data.  We assume that there
        //  are no errors
        //
        
        pbuc->fAccessError = FALSE;

        switch (pbuc->head.dwStreamId) {

        case BACKUP_SPARSE_BLOCK :
            fSuccess = BackupWriteSparse( hFile, pbuc, &bif ) ;
            break ;

        case BACKUP_DATA:
            fSuccess = BackupWriteStream( hFile, pbuc, &bif );
            break;

        case BACKUP_ALTERNATE_DATA:
            fSuccess = BackupWriteAlternateData( hFile, pbuc, &bif );
            break;

        case BACKUP_EA_DATA:
            fSuccess = BackupWriteEaData( hFile, pbuc, &bif );
            break;

        case BACKUP_OBJECT_ID:
            fSuccess = BackupWriteObjectId( hFile, pbuc, &bif );
            break;

        case BACKUP_REPARSE_DATA:
            fSuccess = BackupWriteReparseData( hFile, pbuc, &bif );
            break;

        case BACKUP_SECURITY_DATA:
            fSuccess = BackupWriteSecurityData( hFile, pbuc, &bif );
            break;

        case BACKUP_LINK:
            fSuccess = BackupWriteLinkData( hFile, pbuc, &bif );
            break;

        default:
            SetLastError(ERROR_INVALID_DATA);
            fSuccess = FALSE;
            break;
        }

        BackupTestRestartStream(pbuc);
    } while (fSuccess && bif.cbRequest != 0);

    if (fSuccess && *bif.pcbTransferred == 0) {
        FreeContext(lpContext);
    }
    
    return(fSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\util\util.cpp ===
#include <fusenetincludes.h>
#include <version.h>
#include "cstrings.h"


HRESULT ConvertVersionStrToULL(LPCWSTR pwzVerStr, ULONGLONG *pullVersion)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    LPCWSTR pwz              = NULL;
    WORD wVer[4]          = {0,0,0,0};
    ULONGLONG ullVer    = 0;
    INT i= 0, iVersion      = 0;
    BOOL fDot                  = TRUE;

    IF_NULL_EXIT(pwzVerStr, E_INVALIDARG);
    IF_NULL_EXIT(pullVersion, E_INVALIDARG);

        // Parse the version to ulonglong
    pwz = pwzVerStr;
    while (*pwz)
    {        
        if (fDot)
        {
            iVersion=StrToInt(pwz);
            wVer[i++] = (WORD) iVersion;
            fDot = FALSE;
        }

        if (*pwz == L'.')
            fDot = TRUE;

        pwz++;
        if (i > 3)
            break;
    }

    for (i = 0; i < 4; i++)
        ullVer |=  ((ULONGLONG) wVer[i]) << (sizeof(WORD) * 8 * (3-i));

    *pullVersion = ullVer;

exit:

    return hr;

}

HRESULT FusionCompareString(LPCWSTR pwz1, LPWSTR pwz2, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    DWORD iCompare = CompareString(LOCALE_USER_DEFAULT, dwFlags,
        pwz1, -1, pwz2, -1);

    IF_WIN32_FALSE_EXIT(iCompare);

    hr = (iCompare == CSTR_EQUAL) ? S_OK : S_FALSE;

exit:

    return hr;
}

VOID MakeRandomString(LPWSTR wzRandom, DWORD cc)
{
    static DWORD g_dwCounter;
    LPWSTR pwzRandom = wzRandom;
    for (DWORD i = 0; i < cc; i++)
    {
        DWORD dwChar;
        DWORD dwRandom;
        dwRandom = (GetTickCount() * rand()) + g_dwCounter++;
        dwChar = dwRandom % 36; // 10 digits + 26 letters
        *pwzRandom++  = (dwChar < 10 ) ? 
            (WCHAR)(L'0' + dwChar) : (WCHAR)(L'A' + (dwChar - 10));            
    }        
}

HRESULT CreateRandomDir(LPWSTR pwzRootPath, LPWSTR pwzRandomDir, DWORD cchDirLen)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD dwLastError = 0;

    CString sTempDirPath;
    BOOL bDone = FALSE;
    DWORD dwCount=0;

    IF_FAILED_EXIT(::CreateDirectoryHierarchy(NULL, pwzRootPath));

    do
    {

        ::MakeRandomString(pwzRandomDir, cchDirLen);

        IF_FAILED_EXIT(sTempDirPath.Assign(pwzRootPath));
        IF_FAILED_EXIT(sTempDirPath.Append(pwzRandomDir));

        ::SetLastError(0);

        ::CreateDirectory(sTempDirPath._pwz, NULL);

        dwLastError = ::GetLastError();

        switch(dwLastError)
        {
        case NO_ERROR:
            bDone = TRUE;

        case ERROR_ALREADY_EXISTS :
            break;

        default :
            _hr = HRESULT_FROM_WIN32(dwLastError);
            goto exit;
        }

        if(bDone)
            break;

        if(dwCount > 1000)
        {
            // we tried enough ??
            hr = E_FAIL;
            goto exit;
        }
        else
        {
            dwCount++;
        }

    } while (1);

exit :

    return hr;
}

HRESULT CheckFileExistence(LPCWSTR pwzFile, BOOL *pbExists)
{
    HRESULT                               hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    DWORD                                 dw;

    ASSERT(pwzFile && pbExists);

    dw = GetFileAttributes(pwzFile);
    if (dw == INVALID_FILE_ATTRIBUTES) {
        hr = FusionpHresultFromLastError();
        
        if ( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) || 
            (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
        {
            *pbExists = FALSE;
            hr = S_OK;
        }

        goto exit;
    }

    *pbExists = TRUE;

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////
// CreateDirectoryHierarchy
/////////////////////////////////////////////////////////////////////////
HRESULT CreateDirectoryHierarchy(LPWSTR pwzRootDir, LPWSTR pwzFilePath)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwzPath, pwzEnd;
    CString sCombinedPath;

    IF_FALSE_EXIT(pwzRootDir || pwzFilePath, E_INVALIDARG);

    if (pwzRootDir)    
        IF_FAILED_EXIT(sCombinedPath.Assign(pwzRootDir));

    if (pwzFilePath)
	    IF_FAILED_EXIT(sCombinedPath.Append(pwzFilePath));

    pwzPath = sCombinedPath._pwz;
    pwzEnd = pwzPath + sizeof("C:\\");    
    while (pwzEnd = StrChr(pwzEnd, L'\\'))
    {
        BOOL bExists;
        *pwzEnd = L'\0';

        IF_FAILED_EXIT(CheckFileExistence(pwzPath, &bExists));

        if (!bExists)
        {
            if(!CreateDirectory(pwzPath, NULL))
            {
                hr = FusionpHresultFromLastError();
                goto exit;
            }
        }
        *(pwzEnd++) = L'\\';
    }
    
exit:
    return hr;
}



HRESULT RemoveDirectoryAndChildren(LPWSTR szDir)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    CString sBuf;
    DWORD dwError = 0;

    IF_NULL_EXIT(szDir && lstrlenW(szDir), E_INVALIDARG);

    IF_FAILED_EXIT(sBuf.Assign(szDir));

    // Cannot delete root. Path must have greater length than "x:\"
    if (lstrlenW(sBuf._pwz) < 4) {
//        ASSERT(0);
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto exit;
    }
 
    if (RemoveDirectory(sBuf._pwz)) {
        goto exit;
    }
 
    // ha! we have a case where the directory is probbaly not empty

    IF_FAILED_EXIT(sBuf.Append(TEXT("\\*")));
 
    if ((hf = FindFirstFile(sBuf._pwz, &fd)) == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        if(dwError == ERROR_PATH_NOT_FOUND)
            hr = S_FALSE;
        else
            hr = HRESULT_FROM_WIN32(dwError);
        goto exit;
    }
 
    do {
 
        IF_FAILED_EXIT(FusionCompareString(fd.cFileName, TEXT("."), 0));
        if(hr == S_OK)
            continue;

        IF_FAILED_EXIT(FusionCompareString(fd.cFileName, TEXT(".."), 0));
        if(hr == S_OK)
            continue;

        IF_FAILED_EXIT(sBuf.Assign(szDir));
        IF_FAILED_EXIT(sBuf.Append(TEXT("\\")));
        IF_FAILED_EXIT(sBuf.Append(fd.cFileName));
 
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
 
            SetFileAttributes(sBuf._pwz, 
                FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL);

            IF_FAILED_EXIT(RemoveDirectoryAndChildren(sBuf._pwz));
 
        } else {
 
            SetFileAttributes(sBuf._pwz, FILE_ATTRIBUTE_NORMAL);
            IF_WIN32_FALSE_EXIT(DeleteFile(sBuf._pwz));
        }
 

    } while (FindNextFile(hf, &fd));
 

    dwError = GetLastError();

    if (dwError != ERROR_NO_MORE_FILES) {
        hr = HRESULT_FROM_WIN32(dwError);
        goto exit;
    }
 
    if (hf != INVALID_HANDLE_VALUE) {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }
 
    // here if all subdirs/children removed
    /// re-attempt to remove the main dir
    if (!RemoveDirectory(szDir)) {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        goto exit;
    }

exit:
 
    if (hf != INVALID_HANDLE_VALUE)
        FindClose(hf);
 
    return hr;
}

HRESULT FusionpHresultFromLastError()
{
    HRESULT hr = S_OK;
    DWORD dwLastError = GetLastError();
    if (dwLastError != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(dwLastError);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

// ---------------------------------------------------------------------------
// IsKnownAssembly
// ---------------------------------------------------------------------------
HRESULT IsKnownAssembly(IAssemblyIdentity *pId, DWORD dwFlags)
{
    HRESULT hr = S_FALSE;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwz = NULL;
    DWORD cc = 0;
    CString sPublicKeyToken;
      
    // URT system assemblies; these are not downloaded or installed.
    LPWSTR wzSystemTokens[] = { L"b03f5f7f11d50a3a", L"b77a5c561934e089" };

    // Avalon assemblies - can be installed to gac.
    LPWSTR wzAvalonTokens[] = { L"a29c01bbd4e39ac5" };

    // Get the public key token in string form.
    if (pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwz, &cc) != S_OK)
        goto exit;

    sPublicKeyToken.TakeOwnership(pwz);
    
    // Check for system assembly.
    if (dwFlags == KNOWN_SYSTEM_ASSEMBLY)
    {
        for (int i = 0; i < 2; i++)
        {
            IF_FAILED_EXIT(FusionCompareString(wzSystemTokens[i], sPublicKeyToken._pwz, NORM_IGNORECASE));

            if(hr == S_OK)
                break;
        }
    }
    // check for Avalon assembly.
    else if (dwFlags == KNOWN_TRUSTED_ASSEMBLY)
    {
        IF_FAILED_EXIT(FusionCompareString(wzAvalonTokens[0], sPublicKeyToken._pwz, NORM_IGNORECASE));
    }        

exit:

    return hr;
}


BOOL DoHeapValidate()
{
    HANDLE h = GetProcessHeap();

    return HeapValidate(h, 0, NULL);
}



//=--------------------------------------------------------------------------=
// EnsureDebuggerPresent
//=--------------------------------------------------------------------------=
// Ensures that a debugger is present.  If one isn't present, this will attempt
// to attach one.  If no debugger is installed on the machine, this will
// display a message and return FALSE.
//
BOOL EnsureDebuggerPresent()
{
    BOOL fRet = TRUE;
    HRESULT  hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HKEY hKey = NULL;

    typedef BOOL (WINAPI* ISDEBUGGERPRESENT)();

    static BOOL              _fStartedDebugger = FALSE;
    static ISDEBUGGERPRESENT _IsDebuggerPresent = NULL;

    // If we've already done the work to start the debugger, we're fine
    //
    if (_fStartedDebugger)
    {
        fRet = TRUE;
        goto exit;
    }

    // First, if we don't have an IsDebuggerPresent API, look for one.
    //
    if (!_IsDebuggerPresent)
    {
        HMODULE hKernel = NULL;

        hKernel = GetModuleHandle (L"Kernel32.dll");

        if (!hKernel) 
        {
            MessageBox(NULL, L"Unable to attach to debugger because we could not find Kernel32.dll", L"VsAssert", MB_OK | MB_ICONSTOP);
            fRet = FALSE;
            goto exit;
        }

        _IsDebuggerPresent = (ISDEBUGGERPRESENT)GetProcAddress(hKernel, "IsDebuggerPresent");

        if (!_IsDebuggerPresent)
        {
            MessageBox(NULL, L"Unable to attach to debugger because we could not find a suitable IsDebuggerPresent API", L"VsAssert", MB_OK | MB_ICONSTOP);
            fRet = FALSE;
            goto exit;
        }
    }

    // Now find out if the debugger is indeed present.
    //
    if (_IsDebuggerPresent())
    {
        _fStartedDebugger = TRUE;
    }
    else
    {
        // The debugger has not been started yet.  Do this here.
        //
        BOOL fJIT = FALSE;

        //
        //  Magic!  Location of the JIT debugger info...
        //
        WCHAR *wzRegKey = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug";
        LONG lRetVal;

        lRetVal = RegOpenKeyEx(
                              HKEY_LOCAL_MACHINE,
                              wzRegKey,
                              0,
                              KEY_READ,
                              &hKey);

        CString sCommandLine;
        DWORD dwSize = MAX_PATH;
        BOOL fResult;
        PROCESS_INFORMATION pi;

        IF_FAILED_EXIT(sCommandLine.ResizeBuffer(dwSize+1));

        if (lRetVal == ERROR_SUCCESS)
        {
            DWORD dwType;

            lRetVal = RegQueryValueEx(
                                     hKey,
                                     L"Debugger",
                                     0,
                                     &dwType,
                                     (BYTE *)sCommandLine._pwz,
                                     &dwSize);
            RegCloseKey(hKey);
            hKey = NULL; // reset the value after closing....

            if (lRetVal == ERROR_SUCCESS)
            {
                fJIT = TRUE;

            }
        }
        else
        {
            //
            //  Try WIN.INI
            GetProfileString(L"AeDebug", L"Debugger", L"", sCommandLine._pwz,
                             dwSize);

            if (lstrlen(sCommandLine._pwz) != 0)
            {
                fJIT = TRUE;
            }
        }

        if (!fJIT)
        {
            MessageBox(NULL, L"Unable to attach to debugger because we could not find a debugger on this machine.", L"VsAssert", MB_OK | MB_ICONSTOP);
            fRet = FALSE;
            goto exit;
        }

        HANDLE hEvent;

        //
        //  Now that we have the JIT debugger, try to start it.
        //  The JIT needs a process ID (ours), and an event.
        //
        SECURITY_ATTRIBUTES sa;
        memset(&sa, 0 , sizeof(sa));
        sa.nLength = sizeof(sa);
        sa.bInheritHandle = TRUE;

        hEvent = CreateEvent(&sa, TRUE, FALSE, NULL);

        if (hEvent != NULL)
        {
            CString sCommand;
            DWORD ccSize = 2 * MAX_PATH + 1 ;
            BOOL fResult;
            PROCESS_INFORMATION pi;

            IF_FAILED_EXIT(sCommand.ResizeBuffer(ccSize));

            wnsprintf(sCommand._pwz, ccSize-1, sCommandLine._pwz, GetCurrentProcessId(), hEvent);
            sCommand._pwz[ccSize-1] = L'\0';

            __try
            {
                STARTUPINFO si;

                memset(&si, 0, sizeof(STARTUPINFO));
                si.cb = sizeof(STARTUPINFO);

                fResult = CreateProcess(
                                       NULL,
                                       sCommand._pwz,
                                       NULL,
                                       NULL,
                                       TRUE,
                                       0,
                                       NULL,
                                       NULL,
                                       &si,
                                       &pi);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                fResult = FALSE;
            }

            if (fResult)
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);

                _fStartedDebugger = TRUE;

                WaitForSingleObject(hEvent, INFINITE);
                CloseHandle(hEvent);
            }
            else 
            {
                CString sPoof;
                DWORD ccSize = 2 * MAX_PATH + 100 ;
                IF_FAILED_EXIT(sPoof.ResizeBuffer(ccSize));

                wnsprintf(sPoof._pwz, sPoof._cc, L"Unable to invoke the debugger.  The invocation command we used was:\r\n\r\n%s", sCommand._pwz);
                sPoof._pwz[ccSize-1] = L'\0';
                MessageBox(NULL, sPoof._pwz, L"VsAssert", MB_OK | MB_ICONSTOP);
                fRet = FALSE;
                goto exit;
            }

        }
    }

exit :

    if(hKey)
        RegCloseKey(hKey);
    return fRet;
}


// shlwapi either path- or url-combine
HRESULT DoPathCombine(CString& sDest, LPWSTR pwzSource)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwzDir = NULL, pwzTemp = NULL;
    DWORD ccSource = 0, ccCombined = 0, dwFlags = 0;
    ccSource = lstrlen(pwzSource) + 1;
    ccCombined = sDest._cc + ccSource;

    IF_FAILED_EXIT(sDest.ResizeBuffer(ccCombined));

    pwzDir = WSTRDupDynamic(sDest._pwz);

    pwzTemp = ::PathCombine(sDest._pwz, pwzDir, pwzSource);
    IF_NULL_EXIT(pwzTemp, E_FAIL);

    sDest._cc = lstrlen(sDest._pwz) + 1;

exit:
    SAFEDELETEARRAY(pwzDir);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\ahcache.c ===
/*
    Cache handling functions for use in kernel32.dll


    VadimB




*/

#include "basedll.h"
#include "ahcache.h"
#pragma hdrstop



#ifdef DbgPrint
#undef DbgPrint
#endif


//
//
//
#define DbgPrint 0 && DbgPrint

//
// the define below makes for additional checks
//

// #define DBG_CHK

//
// so that we do not handle exceptions
//

#define NO_EXCEPTION_HANDLING

#if 0  // moved to kernel mode

#define APPCOMPAT_CACHE_KEY_NAME \
    L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

#define APPCOMPAT_CACHE_VALUE_NAME \
    L"AppCompatCache"

#endif

static UNICODE_STRING AppcompatKeyPathLayers =
    RTL_CONSTANT_STRING(L"\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers");

static UNICODE_STRING AppcompatKeyPathCustom =
    RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom\\");

//
// Reasons for having to call into apphelp.dll
// these flags are also defined in apphelp.h (windows\appcompat\apphelp)
//

#ifndef SHIM_CACHE_NOT_FOUND

#define SHIM_CACHE_NOT_FOUND 0x00000001
#define SHIM_CACHE_BYPASS    0x00000002 // bypass cache (either removable media or temp dir)
#define SHIM_CACHE_LAYER_ENV 0x00000004 // layer env variable set
#define SHIM_CACHE_MEDIA     0x00000008
#define SHIM_CACHE_TEMP      0x00000010
#define SHIM_CACHE_NOTAVAIL  0x00000020

#endif

//
// global strings that we check to see if an exe is running in temp directory
//

UNICODE_STRING gustrWindowsTemp;
UNICODE_STRING gustrSystemdriveTemp;

// this macro aligns a given value on dword boundary, not needed for now
//
// #define ALIGN_DWORD(nSize) (((nSize) + (sizeof(DWORD)-1)) & ~(sizeof(DWORD)-1))

//
// Locally defined functions
//
BOOL
BasepShimCacheInitTempDirs(
    VOID
    );

BOOL
BasepIsRemovableMedia(
    HANDLE FileHandle,
    BOOL   bCacheNetwork
    );


VOID
WINAPI
BaseDumpAppcompatCache(
    VOID
    );

BOOL
BasepCheckCacheExcludeList(
    LPCWSTR pwszPath
    );

BOOL
BasepCheckCacheExcludeCustom(
    LPCWSTR pwszPath
    );




//
// Init support for this user - to be called from WinLogon ONLY
//

BOOL
WINAPI
BaseInitAppcompatCacheSupport(
    VOID
    )
{
    BasepShimCacheInitTempDirs();

    return TRUE;
}


BOOL
WINAPI
BaseCleanupAppcompatCacheSupport(
    BOOL bWrite
    )
{
    RtlFreeUnicodeString(&gustrWindowsTemp);
    RtlFreeUnicodeString(&gustrSystemdriveTemp);

    return TRUE;
}



BOOL
BasepCheckStringPrefixUnicode(
    IN  PUNICODE_STRING pStrPrefix,     // the prefix to check for
    IN  PUNICODE_STRING pString,        // the string
    IN  BOOL            CaseInSensitive
    )
/*++
    Return: TRUE if the specified string contains pStrPrefix at it's start.

    Desc:   Verifies if a string is a prefix in another unicode counted string.
            It is equivalent to RtlStringPrefix.
--*/
{
    PWSTR ps1, ps2;
    UINT  n;
    WCHAR c1, c2;

    n = pStrPrefix->Length;
    if (pString->Length < n || n == 0) {
        return FALSE;                // do not prefix with blank strings
    }

    n /= sizeof(WCHAR); // convert to char count

    ps1 = pStrPrefix->Buffer;
    ps2 = pString->Buffer;

    if (CaseInSensitive) {
        while (n--) {
            c1 = *ps1++;
            c2 = *ps2++;

            if (c1 != c2) {
                c1 = RtlUpcaseUnicodeChar(c1);
                c2 = RtlUpcaseUnicodeChar(c2);
                if (c1 != c2) {
                    return FALSE;
                }
            }
        }
    } else {
        while (n--) {
            if (*ps1++ != *ps2++) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
BasepInitUserTempPath(
    PUNICODE_STRING pustrTempPath
    )
{
    DWORD dwLength;
    WCHAR wszBuffer[MAX_PATH];
    BOOL  TranslationStatus;
    BOOL  bSuccess = FALSE;

    dwLength = BasepGetTempPathW(BASEP_GET_TEMP_PATH_PRESERVE_TEB, sizeof(wszBuffer)/sizeof(wszBuffer[0]), wszBuffer);
    if (dwLength && dwLength < sizeof(wszBuffer)/sizeof(wszBuffer[0])) {
        TranslationStatus = RtlDosPathNameToNtPathName_U(wszBuffer,
                                                        pustrTempPath,
                                                        NULL,
                                                        NULL);
        if (!TranslationStatus) {
            DbgPrint("Failed to translate temp directory to nt\n");
        }

        bSuccess = TranslationStatus;
    }

    if (!bSuccess) {
        DbgPrint("BasepInitUserTempPath: Failed to obtain user's temp path\n");
    }

    return bSuccess;
}



BOOL
BasepShimCacheInitTempDirs(
    VOID
    )
{
    DWORD           dwLength;
    WCHAR           wszTemp[] = L"\\TEMP";
    LPWSTR          pwszTemp;
    NTSTATUS        Status;
    UNICODE_STRING  ustrSystemDrive;
    UNICODE_STRING  ustrSystemDriveEnvVarName;
    BOOL            TranslationStatus;
    WCHAR           wszBuffer[MAX_PATH];

    // next is windows dir

    dwLength = GetWindowsDirectoryW(wszBuffer, sizeof(wszBuffer)/sizeof(wszBuffer[0]));
    if (dwLength && dwLength < sizeof(wszBuffer)/sizeof(wszBuffer[0])) {
        pwszTemp = wszTemp;

        if (wszBuffer[dwLength - 1] == L'\\') {
            pwszTemp++;
        }

        wcscpy(&wszBuffer[dwLength], pwszTemp);

        TranslationStatus = RtlDosPathNameToNtPathName_U(wszBuffer,
                                                        &gustrWindowsTemp,
                                                        NULL,
                                                        NULL);
        if (!TranslationStatus) {
            DbgPrint("Failed to translate windows\\temp to nt\n");
        }
    }

    //
    // The last one up is Rootdrive\temp for stupid legacy apps.
    //
    // Especially stupid apps may receive c:\temp as the temp directory
    // (what if you don't have drive c, huh?)
    //

    RtlInitUnicodeString(&ustrSystemDriveEnvVarName, L"SystemDrive");
    ustrSystemDrive.Length = 0;
    ustrSystemDrive.Buffer = wszBuffer;
    ustrSystemDrive.MaximumLength = sizeof(wszBuffer);

    Status = RtlQueryEnvironmentVariable_U(NULL,
                                           &ustrSystemDriveEnvVarName,
                                           &ustrSystemDrive);
    if (NT_SUCCESS(Status)) {
        pwszTemp = wszTemp;
        dwLength = ustrSystemDrive.Length / sizeof(WCHAR);

        if (wszBuffer[dwLength - 1] == L'\\') {
            pwszTemp++;
        }

        wcscpy(&wszBuffer[dwLength], pwszTemp);

        TranslationStatus = RtlDosPathNameToNtPathName_U(wszBuffer,
                                                        &gustrSystemdriveTemp,
                                                        NULL,
                                                        NULL);
        if (!TranslationStatus) {
            DbgPrint("Failed to translate windows\\temp to nt\n");
        }

    }

    DbgPrint("BasepShimCacheInitTempDirs: Temporary Windows Dir: %S\n", gustrWindowsTemp.Buffer != NULL ? gustrWindowsTemp.Buffer : L"");
    DbgPrint("BasepShimCacheInitTempDirs: Temporary SystedDrive: %S\n", gustrSystemdriveTemp.Buffer != NULL ? gustrSystemdriveTemp.Buffer : L"");


    return TRUE;
}

BOOL
BasepShimCacheCheckBypass(
    IN  LPCWSTR pwszPath,       // the full path to the EXE to be started
    IN  HANDLE  hFile,
    IN  WCHAR*  pEnvironment,   // the environment of the starting EXE
    IN  BOOL    bCheckLayer,    // should we check the layer too?
    OUT DWORD*  pdwReason
    )
/*++
    Return: TRUE if the cache should be bypassed, FALSE otherwise.

    Desc:   This function checks if any of the conditions to bypass the cache are met.
--*/
{
    UNICODE_STRING  ustrPath;
    PUNICODE_STRING rgp[3];
    int             i;
    NTSTATUS        Status;
    UNICODE_STRING  ustrCompatLayerVarName;
    UNICODE_STRING  ustrCompatLayer;
    BOOL            bBypassCache = FALSE;
    DWORD           dwReason = 0;
    UNICODE_STRING  ustrUserTempPath = { 0 };

    //
    // Is the EXE is running from removable media we need to bypass the cache.
    //
    if (hFile != INVALID_HANDLE_VALUE && BasepIsRemovableMedia(hFile, TRUE)) {
        bBypassCache = TRUE;
        dwReason |= SHIM_CACHE_MEDIA;
        goto CheckLayer;
    }

    //
    // init user's temp path now and get up-to-date one
    //
    BasepInitUserTempPath(&ustrUserTempPath);

    //
    // Check now if the EXE is launched from one of the temp directories.
    //
    RtlInitUnicodeString(&ustrPath, pwszPath);

    rgp[0] = &gustrWindowsTemp;
    rgp[1] = &ustrUserTempPath;
    rgp[2] = &gustrSystemdriveTemp;

    for (i = 0; i < sizeof(rgp) / sizeof(rgp[0]); i++) {
        if (rgp[i]->Buffer != NULL && BasepCheckStringPrefixUnicode(rgp[i], &ustrPath, TRUE)) {
            DbgPrint("Application \"%ls\" is running in temp directory\n", pwszPath);
            bBypassCache = TRUE;
            dwReason |= SHIM_CACHE_TEMP;
            break;
        }
    }
    RtlFreeUnicodeString(&ustrUserTempPath);


CheckLayer:

    if (bCheckLayer) {

        //
        // Check if the __COMPAT_LAYER environment variable is set
        //
        RtlInitUnicodeString(&ustrCompatLayerVarName, L"__COMPAT_LAYER");

        ustrCompatLayer.Length        = 0;
        ustrCompatLayer.MaximumLength = 0;
        ustrCompatLayer.Buffer        = NULL;

        Status = RtlQueryEnvironmentVariable_U(pEnvironment,
                                               &ustrCompatLayerVarName,
                                               &ustrCompatLayer);

        //
        // If the Status is STATUS_BUFFER_TOO_SMALL this means the variable is set.
        //

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            dwReason |= SHIM_CACHE_LAYER_ENV;
            bBypassCache = TRUE;
        }
    }

    if (pdwReason != NULL) {
        *pdwReason = dwReason;
    }

    return bBypassCache;
}


BOOL
BasepIsRemovableMedia(
    HANDLE FileHandle,
    BOOL   bCacheNetwork
    )
/*++
    Return: TRUE if the media from where the app is run is removable,
            FALSE otherwise.

    Desc:   Queries the media for being removable.
--*/
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;
    BOOL                        bRemovable = FALSE;

    Status = NtQueryVolumeInformationFile(FileHandle,
                                          &IoStatusBlock,
                                          &DeviceInfo,
                                          sizeof(DeviceInfo),
                                          FileFsDeviceInformation);

    if (!NT_SUCCESS(Status)) {
        /*
        DBGPRINT((sdlError,
                  "IsRemovableMedia",
                  "NtQueryVolumeInformationFile Failed 0x%x\n",
                  Status));
        */

        DbgPrint("BasepIsRemovableMedia: NtQueryVolumeInformationFile failed 0x%lx\n", Status);
        return TRUE;
    }

    //
    // We look at the characteristics of this particular device.
    // If the media is cdrom then we DO NOT need to convert to local time
    //
    bRemovable = (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA);

    if (!bCacheNetwork) {
        bRemovable |= (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE);
    }

    if (!bRemovable) {
        //
        // Check the device type now.
        //
        switch (DeviceInfo.DeviceType) {
        case FILE_DEVICE_CD_ROM:
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            bRemovable = TRUE;
            break;

        case FILE_DEVICE_NETWORK:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            if (!bCacheNetwork) {
                bRemovable = TRUE;
            }
            break;
        }
    }

    if (bRemovable) {

        DbgPrint("BasepIsRemovableMedia: Host device is removable, Shim cache deactivated\n");

        /*
        DBGPRINT((sdlInfo,
                  "IsRemovableMedia",
                  "The host device is removable. Shim cache deactivated for this file\n"));
        */
    }

    return bRemovable;
}


BOOL
BasepShimCacheSearch(
    IN  LPCWSTR pwszPath,
    IN  HANDLE  FileHandle
    )
/*++
    Return: TRUE if we have a cache hit, FALSE otherwise.

    Desc:   Search the cache, return TRUE if we have a cache hit
            pIndex will receive an index into the rgIndex array that contains
            the entry which has been hit
            So that if entry 5 contains the hit, and rgIndexes[3] == 5 then
            *pIndex == 3
--*/
{
    int    nIndex, nEntry;
    WCHAR* pCachePath;
    BOOL   bSuccess;
    UNICODE_STRING FileName;
    NTSTATUS Status;
    AHCACHESERVICEDATA Data;


    RtlInitUnicodeString(&Data.FileName, pwszPath);
    Data.FileHandle = FileHandle;

    Status = NtApphelpCacheControl(ApphelpCacheServiceLookup,
                                   &Data);
    return NT_SUCCESS(Status);
}

BOOL
BasepShimCacheRemoveEntry(
    IN LPCWSTR pwszPath
    )
/*++
    Return: TRUE.

    Desc:   Remove the entry from the cache.
            We remove the entry by placing it as the last lru entry
            and emptying the path. This routine assumes that the index
            passed in is valid.
--*/
{
    AHCACHESERVICEDATA Data;
    NTSTATUS           Status;

    RtlInitUnicodeString(&Data.FileName, pwszPath);
    Data.FileHandle = INVALID_HANDLE_VALUE;

    Status = NtApphelpCacheControl(ApphelpCacheServiceRemove,
                                   &Data);


    return NT_SUCCESS(Status);
}

//
// This function is called to search the cache and update the
// entry if found. It will not check for the removable media -- but
// it does check other conditions (update file for instance)
//

BOOL
BasepShimCacheLookup(
    LPCWSTR          pwszPath,
    HANDLE           hFile
    )
{
    NTSTATUS Status;

    if (!BasepShimCacheSearch(pwszPath, hFile)) {
        return FALSE; // not found, sorry
    }

    //
    // check if this entry has been disallowed
    //
    if (!BasepCheckCacheExcludeList(pwszPath) || !BasepCheckCacheExcludeCustom(pwszPath)) {
        DbgPrint("BasepShimCacheLookup: Entry for %ls was disallowed yet found in cache, cleaning up\n", pwszPath);
        BasepShimCacheRemoveEntry(pwszPath);
        return FALSE;
    }

    return TRUE;

}

/*++
    Callable functions, with protection, etc
    BasepCheckAppcompatCache returns true if an app has been found in cache, no fixes are needed

    if BasepCheckAppcompatCache returns false - we will have to call into apphelp.dll to check further
    apphelp.dll will then call BasepUpdateAppcompatCache if an app has no fixes to be applied to it

--*/

BOOL
WINAPI
BaseCheckAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    PVOID   pEnvironment,
    DWORD*  pdwReason
    )
{
    BOOL  bFoundInCache = FALSE;
    BOOL  bLayer        = FALSE;
    DWORD dwReason      = 0;

    if (BasepShimCacheCheckBypass(pwszPath, hFile, pEnvironment, TRUE, &dwReason)) {
        //
        // cache bypass was needed
        //
        dwReason |= SHIM_CACHE_BYPASS;
        DbgPrint("Application \"%S\" Cache bypassed reason 0x%lx\n", pwszPath, dwReason);
        goto Exit;
    }


    bFoundInCache = BasepShimCacheLookup(pwszPath, hFile);
    if (!bFoundInCache) {
        dwReason |= SHIM_CACHE_NOT_FOUND;
    }

    if (bFoundInCache) {
        DbgPrint("Application \"%S\" found in cache\n", pwszPath);
    } else {
        DbgPrint("Application \"%S\" not found in cache\n", pwszPath);
    }

Exit:
    if (pdwReason != NULL) {
        *pdwReason = dwReason;
    }

    return bFoundInCache;
}


//
// returns TRUE if cache is allowed
//

BOOL
BasepCheckCacheExcludeList(
    LPCWSTR pwszPath
    )
{
    NTSTATUS           Status;
    ULONG              ResultLength;
    OBJECT_ATTRIBUTES  ObjectAttributes;
    UNICODE_STRING     KeyPathUser = { 0 }; // path to hkcu
    UNICODE_STRING     ExePathNt;           // temp holder
    KEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    RTL_UNICODE_STRING_BUFFER  ExePathBuffer; // buffer to store exe path
    RTL_UNICODE_STRING_BUFFER  KeyNameBuffer;
    UCHAR              BufferKey[MAX_PATH * 2];
    UCHAR              BufferPath[MAX_PATH * 2];
    HANDLE             KeyHandle          = NULL;
    BOOL               bCacheAllowed      = FALSE;

    RtlInitUnicodeStringBuffer(&ExePathBuffer, BufferPath, sizeof(BufferPath));
    RtlInitUnicodeStringBuffer(&KeyNameBuffer, BufferKey,  sizeof(BufferKey));

    Status = RtlFormatCurrentUserKeyPath(&KeyPathUser);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to format user key path 0x%lx\n", Status);
        goto Cleanup;
    }

    //
    // allocate a buffer that'd be large enough -- or use a local buffer
    //

    Status = RtlAssignUnicodeStringBuffer(&KeyNameBuffer, &KeyPathUser);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to copy hkcu path status 0x%lx\n", Status);
        goto Cleanup;
    }

    Status = RtlAppendUnicodeStringBuffer(&KeyNameBuffer, &AppcompatKeyPathLayers);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to copy layers path status 0x%lx\n", Status);
        goto Cleanup;
    }

    // we have a string for the key path

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyNameBuffer.String,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       KEY_READ|KEY_WOW64_64KEY,  // note - read access only
                       &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        bCacheAllowed = (STATUS_OBJECT_NAME_NOT_FOUND == Status);
        goto Cleanup;
    }

    //
    // now create value name
    //
    RtlInitUnicodeString(&ExePathNt, pwszPath);

    Status = RtlAssignUnicodeStringBuffer(&ExePathBuffer, &ExePathNt);
    if (!NT_SUCCESS(Status)) {
         DbgPrint("BasepCheckCacheExcludeList: failed to acquire sufficient buffer size for path %ls status 0x%lx\n", pwszPath, Status);
         goto Cleanup;
    }

    Status = RtlNtPathNameToDosPathName(0, &ExePathBuffer, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to convert nt path name %ls to dos path name status 0x%lx\n", pwszPath, Status);
        goto Cleanup;
    }

    // now we shall query the value
    Status = NtQueryValueKey(KeyHandle,
                             &ExePathBuffer.String,
                             KeyValuePartialInformation,
                             &KeyValueInformation,
                             sizeof(KeyValueInformation),
                             &ResultLength);

    bCacheAllowed = (Status == STATUS_OBJECT_NAME_NOT_FOUND); // does not exist is more like it


Cleanup:

    if (KeyHandle) {
        NtClose(KeyHandle);
    }

    RtlFreeUnicodeString(&KeyPathUser);

    RtlFreeUnicodeStringBuffer(&ExePathBuffer);
    RtlFreeUnicodeStringBuffer(&KeyNameBuffer);

    if (!bCacheAllowed) {
        DbgPrint("BasepCheckCacheExcludeList: Cache not allowed for %ls\n", pwszPath);
    }

    return bCacheAllowed;
}

BOOL
BasepCheckCacheExcludeCustom(
    LPCWSTR pwszPath
    )
{
    LPCWSTR pwszFileName;
    RTL_UNICODE_STRING_BUFFER KeyPath; // buffer to store exe path
    UCHAR BufferKeyPath[MAX_PATH * 2];
    NTSTATUS Status;

    UNICODE_STRING ustrPath;
    UNICODE_STRING ustrPathSeparators = RTL_CONSTANT_STRING(L"\\/");

    USHORT uPrefix;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle   = NULL;
    BOOL bCacheAllowed = FALSE;

    RtlInitUnicodeString(&ustrPath, pwszPath);

    Status = RtlFindCharInUnicodeString(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                        &ustrPath,
                                        &ustrPathSeparators,
                                        &uPrefix);
    if (NT_SUCCESS(Status) && (uPrefix + sizeof(WCHAR)) < ustrPath.Length) {

        //
        // uPrefix is number of character preceding the one we found not including it
        //
        ustrPath.Buffer        += uPrefix / sizeof(WCHAR) + 1;
        ustrPath.Length        -= (uPrefix + sizeof(WCHAR));
        ustrPath.MaximumLength -= (uPrefix + sizeof(WCHAR));
    }


    //
    // construct path for custom sdb lookup
    //

    RtlInitUnicodeStringBuffer(&KeyPath, BufferKeyPath, sizeof(BufferKeyPath));

    Status = RtlAssignUnicodeStringBuffer(&KeyPath, &AppcompatKeyPathCustom);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeCustom: failed to copy appcompat custom path status 0x%lx\n", Status);
        goto Cleanup;
    }

    Status = RtlAppendUnicodeStringBuffer(&KeyPath, &ustrPath);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeCustom: failed to append %ls status 0x%lx\n", ustrPath.Buffer, Status);
        goto Cleanup;
    }

    // we have built the key, try open

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyPath.String,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       KEY_READ|KEY_WOW64_64KEY,  // note - read access only
                       &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        bCacheAllowed = (STATUS_OBJECT_NAME_NOT_FOUND == Status);
    }


Cleanup:

    if (KeyHandle) {
        NtClose(KeyHandle);
    }

    RtlFreeUnicodeStringBuffer(&KeyPath);

    if (!bCacheAllowed) {
        DbgPrint("BasepCheckCacheExcludeList: Cache not allowed for %ls\n", pwszPath);
    }

    return bCacheAllowed;
}

VOID
WINAPI
BaseDumpAppcompatCache(
    VOID
    )
{
    NtApphelpCacheControl(ApphelpCacheServiceDump,
                          NULL);
}

BOOL
WINAPI
BaseFlushAppcompatCache(
    VOID
    )
{
    NTSTATUS Status;

    Status = NtApphelpCacheControl(ApphelpCacheServiceFlush,
                                   NULL);

    return NT_SUCCESS(Status);
}

VOID
BasepFreeAppCompatData(
    PVOID  pAppCompatData,
    SIZE_T cbAppCompatData,
    PVOID  pSxsData,
    SIZE_T cbSxsData
    )
{
    if (pAppCompatData) {
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &pAppCompatData,
                            &cbAppCompatData,
                            MEM_RELEASE);
    }

    if (pSxsData) {
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &pSxsData,
                            &cbSxsData,
                            MEM_RELEASE);

    }
}

BOOL
WINAPI
BaseUpdateAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    BOOL    bRemove
    )
{
    if (bRemove) {

        return BasepShimCacheRemoveEntry(pwszPath);
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\basesxs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    basesxs.h

Abstract:

    Side-by-side stuff that has to be factored out of basedll.h and ntwow64b.h.

Author:

    Jay Krell (a-JayK) June 2000

Revision History:

--*/

#ifndef _BASESXS_
#define _BASESXS_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Passing a run of three handles into functions is confusing.
// There's nothing enforcing getting them in the right order.
// I had it wrong. This addresses that.
//
typedef struct _BASE_MSG_SXS_HANDLES {
    HANDLE File;

    //
    // Process is the process to map section into, it can
    // be NtCurrentProcess; ensure that case is optimized.
    //
    HANDLE Process;
    HANDLE Section;

    ULONG64 ViewBase;
} BASE_MSG_SXS_HANDLES, *PBASE_MSG_SXS_HANDLES;
typedef const BASE_MSG_SXS_HANDLES* PCBASE_MSG_SXS_HANDLES;

typedef struct _SXS_OVERRIDE_STREAM {
    UNICODE_STRING Name;
    PVOID          Address;
    SIZE_T         Size;
} SXS_OVERRIDE_STREAM, *PSXS_OVERRIDE_STREAM;
typedef const SXS_OVERRIDE_STREAM* PCSXS_OVERRIDE_STREAM;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\baseinit.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    baseinit.c

Abstract:

    This module implements Win32 base initialization

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"


ULONG BaseDllTag;
BOOLEAN BaseRunningInServerProcess;
UINT_PTR SystemRangeStart;

#if defined(_WIN64) || defined(BUILD_WOW6432)
SYSTEM_BASIC_INFORMATION SysInfo;
SYSTEM_PROCESSOR_INFORMATION NativeProcessorInfo;
#endif

WCHAR BaseDefaultPathBuffer[ 3072 ];
extern const WCHAR PsapiDllString[] = L"psapi.dll";
UNICODE_STRING BaseDefaultPath;
UNICODE_STRING BaseDefaultPathAppend;
PWSTR BaseCSDVersion;
WORD BaseCSDNumber;
WORD BaseRCNumber;
UNICODE_STRING BaseUnicodeCommandLine;
ANSI_STRING BaseAnsiCommandLine;
LPSTARTUPINFOA BaseAnsiStartupInfo;
PBASE_STATIC_SERVER_DATA BaseStaticServerData;
ULONG BaseIniFileUpdateCount;
RTL_CRITICAL_SECTION gcsAppCert;
LIST_ENTRY BasepAppCertDllsList;
RTL_CRITICAL_SECTION gcsAppCompat;
PTERMSRVFORMATOBJECTNAME gpTermsrvFormatObjectName;
PTERMSRVGETCOMPUTERNAME  gpTermsrvGetComputerName;
PTERMSRVADJUSTPHYMEMLIMITS gpTermsrvAdjustPhyMemLimits;
PTERMSRVGETWINDOWSDIRECTORYA gpTermsrvGetWindowsDirectoryA;
PTERMSRVGETWINDOWSDIRECTORYW gpTermsrvGetWindowsDirectoryW;
PTERMSRVCONVERTSYSROOTTOUSERDIR gpTermsrvConvertSysRootToUserDir;
PTERMSRVBUILDINIFILENAME gpTermsrvBuildIniFileName;
PTERMSRVCORINIFILE gpTermsrvCORIniFile;
PTERMSRVUPDATEALLUSERMENU gpTermsrvUpdateAllUserMenu;
PGETTERMSRCOMPATFLAGS gpGetTermsrCompatFlags;
PTERMSRVBUILDSYSINIPATH gpTermsrvBuildSysIniPath;
PTERMSRVCOPYINIFILE gpTermsrvCopyIniFile;
PTERMSRVGETSTRING gpTermsrvGetString;
PTERMSRVLOGINSTALLINIFILE gpTermsrvLogInstallIniFile;
HANDLE BaseDllHandle;
HANDLE BaseNamedObjectDirectory;
PVOID BaseHeap;
RTL_HANDLE_TABLE BaseHeapHandleTable;
UNICODE_STRING BaseWindowsDirectory;
UNICODE_STRING BaseWindowsSystemDirectory;
UNICODE_STRING BaseDllDirectory = { 0, 0, NULL };
RTL_CRITICAL_SECTION BaseDllDirectoryLock;
RTL_CRITICAL_SECTION BaseLZSemTable;
#ifdef WX86
UNICODE_STRING BaseWindowsSys32x86Directory;
#endif

//
//  Dispatch functions for Oem/Ansi sensitive conversions
//

NTSTATUS (*Basep8BitStringToUnicodeString)(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    ) = RtlAnsiStringToUnicodeString;

NTSTATUS (*BasepUnicodeStringTo8BitString)(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    ) = RtlUnicodeStringToAnsiString;

ULONG (*BasepUnicodeStringTo8BitSize)(
    PUNICODE_STRING UnicodeString
    ) = BasepUnicodeStringToAnsiSize;

ULONG (*Basep8BitStringToUnicodeSize)(
    PANSI_STRING AnsiString
    ) = BasepAnsiStringToUnicodeSize;

VOID
WINAPI
SetFileApisToOEM(
    VOID
    )
{
    Basep8BitStringToUnicodeString = RtlOemStringToUnicodeString;
    BasepUnicodeStringTo8BitString = RtlUnicodeStringToOemString;
    BasepUnicodeStringTo8BitSize  = BasepUnicodeStringToOemSize;
    Basep8BitStringToUnicodeSize = BasepOemStringToUnicodeSize;
}

VOID
WINAPI
SetFileApisToANSI(
    VOID
    )
{
    Basep8BitStringToUnicodeString = RtlAnsiStringToUnicodeString;
    BasepUnicodeStringTo8BitString = RtlUnicodeStringToAnsiString;
    BasepUnicodeStringTo8BitSize  = BasepUnicodeStringToAnsiSize;
    Basep8BitStringToUnicodeSize = BasepAnsiStringToUnicodeSize;
}

BOOL
WINAPI
AreFileApisANSI(
    VOID
    )
{
    return Basep8BitStringToUnicodeString == RtlAnsiStringToUnicodeString;
}

BOOLEAN
ConDllInitialize(
    IN ULONG Reason,
    IN PWSTR pObjectDirectory OPTIONAL
    );

BOOLEAN
NlsDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PBASE_STATIC_SERVER_DATA BaseStaticServerData
    );

VOID
NlsThreadCleanup(
    VOID);


#if DBG
VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted (
    VOID
    );
#endif

extern const UNICODE_STRING BasePathVariableName = RTL_CONSTANT_STRING(L"PATH");
extern const UNICODE_STRING BaseUserProfileVariableName = RTL_CONSTANT_STRING(L"USERPROFILE");
extern const UNICODE_STRING BaseTmpVariableName = RTL_CONSTANT_STRING(L"TMP");
extern const UNICODE_STRING BaseTempVariableName = RTL_CONSTANT_STRING(L"TEMP");
extern const UNICODE_STRING BaseDotVariableName = RTL_CONSTANT_STRING(L".");
extern const UNICODE_STRING BaseDotTmpSuffixName = RTL_CONSTANT_STRING(L".tmp");
extern const UNICODE_STRING BaseDotComSuffixName = RTL_CONSTANT_STRING(L".com");
extern const UNICODE_STRING BaseDotPifSuffixName = RTL_CONSTANT_STRING(L".pif");
extern const UNICODE_STRING BaseDotExeSuffixName = RTL_CONSTANT_STRING(L".exe");

extern const UNICODE_STRING BaseConsoleInput = RTL_CONSTANT_STRING(L"CONIN$");
extern const UNICODE_STRING BaseConsoleOutput = RTL_CONSTANT_STRING(L"CONOUT$");
extern const UNICODE_STRING BaseConsoleGeneric = RTL_CONSTANT_STRING(L"CON");

BOOLEAN
BaseDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function implements Win32 base dll initialization.
    It's primary purpose is to create the Base heap.

Arguments:

    DllHandle - Saved in BaseDllHandle global variable

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*/

{
    BOOLEAN Success;
    NTSTATUS Status;
    PPEB Peb;
    LPWSTR p, p1;
    BOOLEAN ServerProcess;
    HANDLE hNlsCacheMutant;
    USHORT Size;
#if !defined(BUILD_WOW6432)
    ULONG SizeMutant;
#endif
    WCHAR szSessionDir[MAX_SESSION_PATH];


    Peb = NtCurrentPeb();

    SessionId = Peb->SessionId;

    BaseDllHandle = DllHandle;

    Success = TRUE;


    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        Basep8BitStringToUnicodeString = RtlAnsiStringToUnicodeString;

        RtlSetThreadPoolStartFunc( BaseCreateThreadPoolThread,
                                   BaseExitThreadPoolThread );

        LdrSetDllManifestProber(&BasepProbeForDllManifest);

        BaseDllTag = RtlCreateTagHeap( RtlProcessHeap(),
                                       0,
                                       L"BASEDLL!",
                                       L"TMP\0"
                                       L"BACKUP\0"
                                       L"INI\0"
                                       L"FIND\0"
                                       L"GMEM\0"
                                       L"LMEM\0"
                                       L"ENV\0"
                                       L"RES\0"
                                       L"VDM\0"
                                     );

        BaseIniFileUpdateCount = 0;

        BaseDllInitializeMemoryManager();

        BaseDefaultPath.Length = 0;
        BaseDefaultPath.MaximumLength = 0;
        BaseDefaultPath.Buffer = NULL;

        //
        // Connect to BASESRV.DLL in the server process
        //

#if !defined(BUILD_WOW6432)
        SizeMutant = sizeof(hNlsCacheMutant);
#endif

        if ( SessionId == 0 ) {
           //
           // Console Session
           //
           wcscpy(szSessionDir, WINSS_OBJECT_DIRECTORY_NAME);
        } else {
           swprintf(szSessionDir,L"%ws\\%ld%ws",SESSION_ROOT,SessionId,WINSS_OBJECT_DIRECTORY_NAME);
        }

#if defined(BUILD_WOW6432) || defined(_WIN64)
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &SysInfo,
                                          sizeof(SYSTEM_BASIC_INFORMATION),
                                          NULL
                                         );

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        Status = RtlGetNativeSystemInformation(
                    SystemProcessorInformation,
                    &NativeProcessorInfo,
                    sizeof(SYSTEM_PROCESSOR_INFORMATION),
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

#endif

#if defined(BUILD_WOW6432)
        Status = CsrBaseClientConnectToServer(szSessionDir,
                                              &hNlsCacheMutant,
                                              &ServerProcess
                                             );
#else
        Status = CsrClientConnectToServer( szSessionDir,
                                           BASESRV_SERVERDLL_INDEX,
                                           &hNlsCacheMutant,
                                           &SizeMutant,
                                           &ServerProcess
                                         );
#endif

        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }

        BaseStaticServerData = BASE_SHARED_SERVER_DATA;

        if (!ServerProcess) {
            CsrNewThread();
            BaseRunningInServerProcess = FALSE;
            }
        else {
            BaseRunningInServerProcess = TRUE;
            }

        BaseCSDVersion = BaseStaticServerData->CSDVersion;
        BaseCSDNumber = BaseStaticServerData->CSDNumber;
        BaseRCNumber = BaseStaticServerData->RCNumber;
        if ((BaseCSDVersion) &&
            (!Peb->CSDVersion.Buffer)) {

            RtlInitUnicodeString(&Peb->CSDVersion, BaseCSDVersion);

        }

        BASE_SERVER_STR_TO_LOCAL_STR(&BaseWindowsDirectory, &BaseStaticServerData->WindowsDirectory);
        BASE_SERVER_STR_TO_LOCAL_STR(&BaseWindowsSystemDirectory, &BaseStaticServerData->WindowsSystemDirectory);

#ifdef WX86
        BASE_SERVER_STR_TO_LOCAL_STR(&BaseWindowsSys32x86Directory, &BaseStaticServerData->WindowsSys32x86Directory);
#endif
        BaseUnicodeCommandLine = Peb->ProcessParameters->CommandLine;
        Status = RtlUnicodeStringToAnsiString(
                    &BaseAnsiCommandLine,
                    &BaseUnicodeCommandLine,
                    TRUE
                    );
        if ( !NT_SUCCESS(Status) ){
            BaseAnsiCommandLine.Buffer = NULL;
            BaseAnsiCommandLine.Length = 0;
            BaseAnsiCommandLine.MaximumLength = 0;
            }

        p = BaseDefaultPathBuffer;

        p1 = BaseWindowsSystemDirectory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';

#ifdef WX86

        //
        // Wx86 system dir follows 32 bit system dir
        //

        p1 = BaseWindowsSys32x86Directory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';
#endif


        //
        // 16bit system directory follows 32bit system directory
        //
        p1 = BaseWindowsDirectory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        p1 = L"\\system";
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';

        p1 = BaseWindowsDirectory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';

        if (IsTerminalServer()) {

           WCHAR TermSrvWindowsPath[MAX_PATH];
           SIZE_T TermSrvWindowsPathLength = 0;
           NTSTATUS TermSrvWindowsPathStatus;

           TermSrvWindowsPathStatus = GetPerUserWindowsDirectory(
               TermSrvWindowsPath,
               RTL_NUMBER_OF(TermSrvWindowsPath),
               &TermSrvWindowsPathLength
               );

           if (NT_SUCCESS(TermSrvWindowsPathStatus)
               && TermSrvWindowsPathLength != 0
               ) {
              RtlCopyMemory(p, TermSrvWindowsPath, (TermSrvWindowsPathLength * sizeof(p[0])));
              p += TermSrvWindowsPathLength;
              *p++ = L';';
           }
        }

        *p = UNICODE_NULL;

        BaseDefaultPath.Buffer = BaseDefaultPathBuffer;
        BaseDefaultPath.Length = (USHORT)((ULONG_PTR)p - (ULONG_PTR)BaseDefaultPathBuffer);
        BaseDefaultPath.MaximumLength = sizeof( BaseDefaultPathBuffer );

        BaseDefaultPathAppend.Buffer = p;
        BaseDefaultPathAppend.Length = 0;
        BaseDefaultPathAppend.MaximumLength = (USHORT)
            (BaseDefaultPath.MaximumLength - BaseDefaultPath.Length);

        if (!NT_SUCCESS(RtlInitializeCriticalSection(&BaseDllDirectoryLock))) {
           return FALSE;
        }

        if (!NT_SUCCESS(RtlInitializeCriticalSection(&BaseLZSemTable))) {
           return FALSE;
        }

        BaseDllInitializeIniFileMappings( BaseStaticServerData );


        if ( Peb->ProcessParameters ) {
            if ( Peb->ProcessParameters->Flags & RTL_USER_PROC_PROFILE_USER ) {

                LoadLibraryW(PsapiDllString);

                }

            if (Peb->ProcessParameters->DebugFlags) {
                DbgBreakPoint();
                }
            }

        //
        // call the NLS API initialization routine
        //
        if ( !NlsDllInitialize( DllHandle,
                                Reason,
                                BaseStaticServerData ) )
        {
            return FALSE;
        }

        //
        // call the console initialization routine
        //
        if ( !ConDllInitialize(Reason,szSessionDir) ) {
            return FALSE;
            }


        InitializeListHead( &BasepAppCertDllsList );

        if (!NT_SUCCESS(RtlInitializeCriticalSection(&gcsAppCert))) {
           return FALSE;
        }

        if (!NT_SUCCESS(RtlInitializeCriticalSection(&gcsAppCompat))) {
           return(FALSE);
        }


#if DBG

        AssertDelayLoadFailureMapsAreSorted ();
#endif

        break;

    case DLL_PROCESS_DETACH:

        //
        // Make sure any open registry keys are closed.
        //

        if (BaseIniFileUpdateCount != 0) {
            WriteProfileStringW( NULL, NULL, NULL );
            }

        break;

    case DLL_THREAD_ATTACH:
        //
        // call the console initialization routine
        //
        if ( !ConDllInitialize(Reason,NULL) ) {
            return FALSE;
            }
        break;

    case DLL_THREAD_DETACH:

        //
        // Delete the thread NLS cache, if exists.
        //
        NlsThreadCleanup();

        break;

    default:
        break;
    }

    return Success;
}

NTSTATUS
NTAPI
BaseProcessInitPostImport()
/*

    Routine Description:

        Called by the ntdll process initialization code after all of the
        import tables for the static imports of the EXE have been processed,
        but before any DLL_PROCESS_ATTACHes are sent with the exception of
        kernel32.dll's.

        Needed for the terminal server app compat hooks.


*/
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    //
    // Intialize TerminalServer(Hydra) hook function pointers for app compatibility
    //
    if (IsTerminalServer()) {
        Status = BasepInitializeTermsrvFpns();
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


HANDLE
BaseGetNamedObjectDirectory(
    VOID
    )
{
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    const static UNICODE_STRING RestrictedObjectDirectory = RTL_CONSTANT_STRING(L"Restricted");
    ACCESS_MASK DirAccess = DIRECTORY_ALL_ACCESS &
                            ~(DELETE | WRITE_DAC | WRITE_OWNER);
    HANDLE hRootNamedObject;
    HANDLE BaseHandle;
    HANDLE Token, NewToken;

    if ( BaseNamedObjectDirectory != NULL) {
        return BaseNamedObjectDirectory;
    }

    if (NtCurrentTeb()->IsImpersonating) {
        //
        // If we're impersonating, save the impersonation token, and
        // revert to self for the duration of the directory creation.
        //
        Status = NtOpenThreadToken(NtCurrentThread(),
                                   TOKEN_IMPERSONATE,
                                   TRUE,
                                   &Token);
        if (! NT_SUCCESS(Status)) {
            return BaseNamedObjectDirectory;
        }

        NewToken = NULL;
        Status = NtSetInformationThread(NtCurrentThread(),
                                        ThreadImpersonationToken,
                                        (PVOID) &NewToken,
                                        (ULONG) sizeof(NewToken));
        if (! NT_SUCCESS(Status)) {
            NtClose(Token);
            return BaseNamedObjectDirectory;
        }

    } else {
        Token = NULL;
    }

    RtlAcquirePebLock();

    if ( !BaseNamedObjectDirectory ) {

        BASE_READ_REMOTE_STR_TEMP(TempStr);
        InitializeObjectAttributes( &Obja,
                                    BASE_READ_REMOTE_STR(BaseStaticServerData->NamedObjectDirectory, TempStr),
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );

        Status = NtOpenDirectoryObject( &BaseHandle,
                                        DirAccess,
                                        &Obja
                                      );

        // if the intial open failed, try again with just traverse, and
        // open the restricted subdirectory

        if ( !NT_SUCCESS(Status) ) {
            Status = NtOpenDirectoryObject( &hRootNamedObject,
                                            DIRECTORY_TRAVERSE,
                                            &Obja
                                          );
            if ( NT_SUCCESS(Status) ) {

                InitializeObjectAttributes( &Obja,
                                            (PUNICODE_STRING)&RestrictedObjectDirectory,
                                            OBJ_CASE_INSENSITIVE,
                                            hRootNamedObject,
                                            NULL
                                            );
                Status = NtOpenDirectoryObject( &BaseHandle,
                                                DirAccess,
                                                &Obja
                                              );
                NtClose( hRootNamedObject );
            }

        }
        if ( NT_SUCCESS(Status) ) {
            BaseNamedObjectDirectory = BaseHandle;
        }
    }
    RtlReleasePebLock();

    if (Token) {
        NtSetInformationThread(NtCurrentThread(),
                               ThreadImpersonationToken,
                               (PVOID) &Token,
                               (ULONG) sizeof(Token));        
        NtClose(Token);
    }
    
    return BaseNamedObjectDirectory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\basedll.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basedll.h

Abstract:

    This module contains private function prototypes
    and types for the 32-bit windows base APIs.

Author:

    Mark Lucovsky (markl) 18-Sep-1990

Revision History:

--*/

#ifndef _BASEP_
#define _BASEP_
#if _MSC_VER > 1000
#pragma once
#endif

#undef UNICODE

#if defined(__cplusplus)
extern "C" {
#endif

//
// Include Common Definitions.
//

#include <base.h>
#include <dbt.h>

#include <sxstypes.h>

//
// Include DLL definitions for CSR
//

#include "ntcsrdll.h"
#include "ntcsrsrv.h"

#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>

//
// Include message definitions for communicating between client and server
// portions of the Base portion of the Windows subsystem
//

#include "basemsg.h"
#include "winuserp.h"
#include "basesxs.h"

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;

typedef struct _LOAD_MODULE_PARAMS {
    LPVOID lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

typedef struct _RELATIVE_NAME {
    STRING RelativeName;
    HANDLE ContainingDirectory;
} RELATIVE_NAME, *PRELATIVE_NAME;


extern HANDLE BaseDllHandle;
extern HANDLE BaseNamedObjectDirectory;

extern PVOID BaseHeap;
extern RTL_HANDLE_TABLE BaseHeapHandleTable;

extern UNICODE_STRING BaseWindowsDirectory;
extern UNICODE_STRING BaseWindowsSystemDirectory;
#ifdef WX86
extern UNICODE_STRING BaseWindowsSys32x86Directory;
#endif

extern const UNICODE_STRING BasePathVariableName;
extern const UNICODE_STRING BaseTmpVariableName;
extern const UNICODE_STRING BaseTempVariableName;
extern const UNICODE_STRING BaseUserProfileVariableName;
extern const UNICODE_STRING BaseDotVariableName;
extern const UNICODE_STRING BaseDotTmpSuffixName;
extern const UNICODE_STRING BaseDotComSuffixName;
extern const UNICODE_STRING BaseDotPifSuffixName;
extern const UNICODE_STRING BaseDotExeSuffixName;

extern UNICODE_STRING BaseDefaultPath;
extern UNICODE_STRING BaseDefaultPathAppend;
extern UNICODE_STRING BaseDllDirectory;
extern RTL_CRITICAL_SECTION BaseDllDirectoryLock;
extern PWSTR BaseCSDVersion;
extern WORD BaseCSDNumber;
extern WORD BaseRCNumber;

extern const UNICODE_STRING BaseConsoleInput;
extern const UNICODE_STRING BaseConsoleOutput;
extern const UNICODE_STRING BaseConsoleGeneric;
extern UNICODE_STRING BaseUnicodeCommandLine;
extern ANSI_STRING BaseAnsiCommandLine;

extern LPSTARTUPINFOA BaseAnsiStartupInfo;

extern PBASE_STATIC_SERVER_DATA BaseStaticServerData;

#if defined(BUILD_WOW6432) || defined(_WIN64)
extern SYSTEM_BASIC_INFORMATION SysInfo;
extern SYSTEM_PROCESSOR_INFORMATION NativeProcessorInfo;
#endif

extern UINT_PTR SystemRangeStart;
extern BOOLEAN BaseRunningInServerProcess;

extern ULONG BaseIniFileUpdateCount;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG_PTR)(SIZE) + (ULONG_PTR)BASE_SYSINFO.PageSize - 1) & ~((ULONG_PTR)BASE_SYSINFO.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG_PTR)(SIZE)) & ~((ULONG_PTR)BASE_SYSINFO.PageSize - 1))

#define BASE_COPY_FILE_CHUNK (64*1024)
#define BASE_MAX_PATH_STRING 4080

extern BOOLEAN BasepFileApisAreOem;

#define DATA_ATTRIBUTE_NAME         L":$DATA"
#define DATA_ATTRIBUTE_LENGTH       (sizeof( DATA_ATTRIBUTE_NAME ) - sizeof( WCHAR ))

extern WCHAR BasepDataAttributeType[];

#define CERTAPP_KEY_NAME L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls"
#define CERTAPP_ENTRYPOINT_NAME "CreateProcessNotify"
#define CERTAPP_EMBEDDED_DLL_NAME L"EmbdTrst.DLL"
#define CERTAPP_EMBEDDED_DLL_EP "ImageOkToRunOnEmbeddedNT"
extern RTL_CRITICAL_SECTION gcsAppCert;
extern LIST_ENTRY BasepAppCertDllsList;

extern RTL_CRITICAL_SECTION gcsAppCompat;

extern RTL_CRITICAL_SECTION BaseLZSemTable;

NTSTATUS
BasepConfigureAppCertDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
BasepSaveAppCertRegistryValue(
    IN OUT PLIST_ENTRY ListHead,
    IN PWSTR Name,
    IN PWSTR Value OPTIONAL
    );


typedef struct _BASEP_APPCERT_ENTRY {
    LIST_ENTRY Entry;
    UNICODE_STRING Name;
    NTSTATUS (WINAPI *fPluginCertFunc)(LPCWSTR lpApplicationName,ULONG Reason);
} BASEP_APPCERT_ENTRY, *PBASEP_APPCERT_ENTRY;

extern RTL_QUERY_REGISTRY_TABLE BasepAppCertTable[];

#define APPCERT_IMAGE_OK_TO_RUN     1
#define APPCERT_CREATION_ALLOWED    2
#define APPCERT_CREATION_DENIED     3


__inline
BOOL
BasepIsDataAttribute(
    ULONG Count,
    const WCHAR *Name
    )
{
    return Count > DATA_ATTRIBUTE_LENGTH &&
         !_wcsnicmp( &Name[(Count - DATA_ATTRIBUTE_LENGTH) / sizeof( WCHAR )],
                     BasepDataAttributeType,
                     DATA_ATTRIBUTE_LENGTH / sizeof( WCHAR ));
}

PUNICODE_STRING
Basep8BitStringToStaticUnicodeString(
    IN LPCSTR SourceString
    );

BOOL
Basep8BitStringToDynamicUnicodeString(
    OUT PUNICODE_STRING UnicodeString,
    IN LPCSTR lpSourceString
    );

extern
NTSTATUS
(*Basep8BitStringToUnicodeString)(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

extern
NTSTATUS
(*BasepUnicodeStringTo8BitString)(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

extern
ULONG
(*BasepUnicodeStringTo8BitSize)(
    PUNICODE_STRING UnicodeString
    );

ULONG
BasepUnicodeStringToAnsiSize(
    PUNICODE_STRING UnicodeString
    );

ULONG
BasepUnicodeStringToOemSize(
    PUNICODE_STRING UnicodeString
    );

extern
ULONG
(*Basep8BitStringToUnicodeSize)(
    PANSI_STRING AnsiString
    );

ULONG
BasepAnsiStringToUnicodeSize(
    PANSI_STRING AnsiString
    );

ULONG
BasepOemStringToUnicodeSize(
    PANSI_STRING OemString
    );

HANDLE
BaseGetNamedObjectDirectory(
    VOID
    );

void
BaseDllInitializeMemoryManager( VOID );

typedef
NTSTATUS
(*BASECLIENTCONNECTROUTINE)(
    PVOID MustBeNull,
    PVOID ConnectionInformation,
    PULONG ConnectionInformationLength
    );


POBJECT_ATTRIBUTES
BaseFormatObjectAttributes(
    POBJECT_ATTRIBUTES ObjectAttributes,
    PSECURITY_ATTRIBUTES SecurityAttributes,
    PUNICODE_STRING ObjectName
    );

PLARGE_INTEGER
BaseFormatTimeOut(
    PLARGE_INTEGER TimeOut,
    DWORD Milliseconds
    );

ULONG
BaseSetLastNTError(
    NTSTATUS Status
    );

VOID
BaseSwitchStackThenTerminate(
    PVOID CurrentStack,
    PVOID NewStack,
    DWORD ExitCode
    );

VOID
BaseFreeStackAndTerminate(
    PVOID OldStack,
    DWORD ExitCode
    );

NTSTATUS
BaseCreateStack(
    HANDLE Process,
    SIZE_T StackSize,
    SIZE_T MaximumStackSize,
    PINITIAL_TEB InitialTeb
    );

VOID
BasepSwitchToFiber(
    PFIBER CurrentFiber,
    PFIBER NewFiber
    );

VOID
BaseFiberStart(
    VOID
    );

VOID
BaseThreadStart(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

typedef DWORD (WINAPI *PPROCESS_START_ROUTINE)(
    VOID
    );

VOID
BaseProcessStart(
    PPROCESS_START_ROUTINE lpStartAddress
    );

VOID
BaseThreadStartThunk(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

VOID
BaseProcessStartThunk(
    LPVOID lpProcessStartAddress,
    LPVOID lpParameter
    );

typedef enum _BASE_CONTEXT_TYPE {
    BaseContextTypeProcess,
    BaseContextTypeThread,
    BaseContextTypeFiber
} BASE_CONTEXT_TYPE, *PBASE_CONTEXT_TYPE;

VOID
BaseInitializeContext(
    PCONTEXT Context,
    PVOID Parameter,
    PVOID InitialPc,
    PVOID InitialSp,
    BASE_CONTEXT_TYPE ContextType
    );

#if defined(WX86) || defined(_AXP64_)
NTSTATUS
BaseCreateWx86Tib(
    HANDLE Process,
    HANDLE Thread,
    ULONG InitialPc,
    ULONG CommittedStackSize,
    ULONG MaximumStackSize,
    BOOLEAN EmulateInitialPc
    );
#endif

VOID
BaseFreeThreadStack(
     HANDLE hProcess,
     HANDLE hThread,
     PINITIAL_TEB InitialTeb
     );

#define BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT  (0x00000001)

BOOL
BasePushProcessParameters(
    DWORD dwFlags,
    HANDLE Process,
    PPEB Peb,
    LPCWSTR ApplicationPathName,
    LPCWSTR CurrentDirectory,
    LPCWSTR CommandLine,
    LPVOID Environment,
    LPSTARTUPINFOW lpStartupInfo,
    DWORD dwCreationFlags,
    BOOL bInheritHandles,
    DWORD dwSubsystem,
    PVOID pAppCompatData,
    DWORD cbAppCompatData
    );

LPWSTR
BaseComputeProcessDllPath(
    LPCWSTR AppName,
    LPVOID  Environment
    );

LPWSTR
BaseComputeProcessSearchPath(
    VOID
    );

LPWSTR
BaseComputeProcessExePath(
    LPCWSTR ExeName
    );

extern PCLDR_DATA_TABLE_ENTRY BasepExeLdrEntry;

VOID
BasepLocateExeLdrEntry(
    IN PCLDR_DATA_TABLE_ENTRY Entry,
    IN PVOID Context,
    IN OUT BOOLEAN *StopEnumeration
    );

FORCEINLINE
VOID
BasepCheckExeLdrEntry(
    VOID
    )
{
    if (! BasepExeLdrEntry) {
        LdrEnumerateLoadedModules(0,
                                  &BasepLocateExeLdrEntry,
                                  NtCurrentPeb()->ImageBaseAddress);
    }
}

LPCWSTR
BasepEndOfDirName(
    IN LPCWSTR FileName
    );

DWORD
BaseDebugAttachThread(
    LPVOID ThreadParameter
    );

HANDLE
BaseFindFirstDevice(
    PCUNICODE_STRING FileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

PCUNICODE_STRING
BaseIsThisAConsoleName(
    PCUNICODE_STRING FileNameString,
    DWORD dwDesiredAccess
    );


typedef ULONG (FAR WINAPI *CSRREMOTEPROCPROC)(HANDLE, CLIENT_ID *);

#if DBG
VOID
BaseHeapBreakPoint( VOID );
#endif

ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    );

//
// Data structure for CopyFileEx context
//

typedef struct _COPYFILE_CONTEXT {
    LARGE_INTEGER TotalFileSize;
    LARGE_INTEGER TotalBytesTransferred;
    DWORD dwStreamNumber;
    LPBOOL lpCancel;
    LPVOID lpData;
    LPPROGRESS_ROUTINE lpProgressRoutine;
} COPYFILE_CONTEXT, *LPCOPYFILE_CONTEXT;

//
// Data structure for tracking restart state
//

typedef struct _RESTART_STATE {
    CSHORT Type;
    CSHORT Size;
    DWORD NumberOfStreams;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER WriteTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER FileSize;
    LARGE_INTEGER LastKnownGoodOffset;
    DWORD CurrentStream;
    DWORD Checksum;
} RESTART_STATE, *PRESTART_STATE, *LPRESTART_STATE;

#define SUCCESS_RETURNED_STATE 2

DWORD
BaseCopyStream(
    LPCWSTR lpExistingFileName,
    HANDLE hSourceFile,
    ACCESS_MASK SourceFileAccess OPTIONAL,
    LPCWSTR lpNewFileName,
    HANDLE hTargetFile OPTIONAL,
    LARGE_INTEGER *lpFileSize,
    LPDWORD lpCopyFlags,
    LPHANDLE lpDestFile,
    LPDWORD lpCopySize,
    LPCOPYFILE_CONTEXT *lpCopyFileContext,
    LPRESTART_STATE lpRestartState OPTIONAL,
    BOOL OpenFileAsReparsePoint,
    DWORD dwReparseTag,
    PDWORD DestFileFsAttributes
    );

BOOL
BasepCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags,
    DWORD dwPrivCopyFlags,
    LPHANDLE phSource OPTIONAL,
    LPHANDLE phDest OPTIONAL
    );

VOID
BaseMarkFileForDelete(
    HANDLE File,
    DWORD FileAttributes
    );


PVOID
BasepMapModuleHandle(
    IN HMODULE hModule,
    IN BOOLEAN bResourcesOnly
    );

ULONG_PTR
BaseDllMapResourceIdA(
    PCSTR lpId
    );

ULONG_PTR
BaseDllMapResourceIdW(
    PCWSTR lpId
    );

VOID
BaseDllFreeResourceId(
    ULONG_PTR Id
    );

//
// Data structures and interfaces used by dllini.c
//

typedef struct _INIFILE_CACHE {
    struct _INIFILE_CACHE *Next;
    ULONG EnvironmentUpdateCount;
    UNICODE_STRING NtFileName;
    PINIFILE_MAPPING_FILENAME FileMapping;
    HANDLE FileHandle;
    BOOLEAN WriteAccess;
    BOOLEAN UnicodeFile;
    BOOLEAN LockedFile;
    ULONG EndOfFile;
    PVOID BaseAddress;
    SIZE_T CommitSize;
    SIZE_T RegionSize;
    ULONG UpdateOffset;
    ULONG UpdateEndOffset;
    ULONG DirectoryInformationLength;
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
} INIFILE_CACHE, *PINIFILE_CACHE;

typedef enum _INIFILE_OPERATION {
    FlushProfiles,
    ReadKeyValue,
    WriteKeyValue,
    DeleteKey,
    ReadKeyNames,
    ReadSectionNames,
    ReadSection,
    WriteSection,
    DeleteSection,
    RefreshIniFileMapping
} INIFILE_OPERATION;

typedef struct _INIFILE_PARAMETERS {
    INIFILE_OPERATION Operation;
    BOOLEAN WriteOperation;
    BOOLEAN Unicode;
    BOOLEAN ValueBufferAllocated;
    PINIFILE_MAPPING_FILENAME IniFileNameMapping;
    PINIFILE_CACHE IniFile;
    UNICODE_STRING BaseFileName;
    UNICODE_STRING FileName;
    UNICODE_STRING NtFileName;
    ANSI_STRING ApplicationName;
    ANSI_STRING VariableName;
    UNICODE_STRING ApplicationNameU;
    UNICODE_STRING VariableNameU;
    BOOLEAN MultiValueStrings;
    union {
        //
        // This structure filled in for write operations
        //
        struct {
            LPSTR ValueBuffer;
            ULONG ValueLength;
            PWSTR ValueBufferU;
            ULONG ValueLengthU;
        };
        //
        // This structure filled in for read operations
        //
        struct {
            ULONG ResultChars;
            ULONG ResultMaxChars;
            LPSTR ResultBuffer;
            PWSTR ResultBufferU;
        };
    };


    //
    // Remaining fields only valid when parsing an on disk .INI file mapped into
    // memory.
    //

    PVOID TextCurrent;
    PVOID TextStart;
    PVOID TextEnd;

    ANSI_STRING SectionName;
    ANSI_STRING KeywordName;
    ANSI_STRING KeywordValue;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PANSI_STRING AnsiKeywordValue;
    UNICODE_STRING SectionNameU;
    UNICODE_STRING KeywordNameU;
    UNICODE_STRING KeywordValueU;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PUNICODE_STRING UnicodeKeywordValue;
} INIFILE_PARAMETERS, *PINIFILE_PARAMETERS;

NTSTATUS
BaseDllInitializeIniFileMappings(
    PBASE_STATIC_SERVER_DATA StaticServerData
    );

NTSTATUS
BasepAcquirePrivilege(
    ULONG Privilege,
    PVOID *ReturnedState
    );

NTSTATUS
BasepAcquirePrivilegeEx(
    ULONG Privilege,
    PVOID *ReturnedState
    );

VOID
BasepReleasePrivilege(
    PVOID StatePointer
    );

NTSTATUS
NTAPI
BaseCreateThreadPoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    PVOID Parameter,
    HANDLE * ThreadHandle
    );

NTSTATUS
NTAPI
BaseExitThreadPoolThread(
    NTSTATUS Status
    );

//
// Function for returning the volume name from a reparse point.
//

BOOL
BasepGetVolumeNameFromReparsePoint(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength,
    PBOOL ResultOfOpen
    );


#if defined(_WIN64) || defined(BUILD_WOW6432)

//
// COM+ Support routines
//

NTSTATUS
BasepIsComplusILImage(
    IN HANDLE SectionImageHandle,
    OUT BOOLEAN *IsComplusILImage
    );

#endif


//
// Definitions for memory handles used by Local/GlobalAlloc functions
//

typedef struct _BASE_HANDLE_TABLE_ENTRY {
    USHORT Flags;
    USHORT LockCount;
    union {
        PVOID Object;                               // Allocated handle
        ULONG Size;                                 // Handle to discarded obj.
    };
} BASE_HANDLE_TABLE_ENTRY, *PBASE_HANDLE_TABLE_ENTRY;

#define BASE_HANDLE_MOVEABLE    (USHORT)0x0002
#define BASE_HANDLE_DISCARDABLE (USHORT)0x0004
#define BASE_HANDLE_DISCARDED   (USHORT)0x0008
#define BASE_HANDLE_SHARED      (USHORT)0x8000

//
// Handles are 32-bit pointers to the u.Object field of a
// BASE_HANDLE_TABLE_ENTRY.  Since this field is 4 bytes into the
// structure and the structures are always on 8 byte boundaries, we can
// test the 0x4 bit to see if it is a handle.
//
// In Sundown, these handles are 64-bit pointers to the u.Object field
// which is 8 bytes into the structure.  Therefore, we should test the
// 0x8 bit to see if it is a handle.
//
//on sundown
//     #define BASE_HANDLE_MARK_BIT (ULONG_PTR)0x00000008
//on 32 bit systems
//     #define BASE_HANDLE_MARK_BIT (ULONG_PTR)0x00000004
//

#define BASE_HANDLE_MARK_BIT (ULONG_PTR)FIELD_OFFSET(BASE_HANDLE_TABLE_ENTRY,Object)
#define BASE_HEAP_FLAG_MOVEABLE  HEAP_SETTABLE_USER_FLAG1
#define BASE_HEAP_FLAG_DDESHARE  HEAP_SETTABLE_USER_FLAG2


extern ULONG BaseDllTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseDllTag, t ))

#define TMP_TAG 0
#define BACKUP_TAG 1
#define INI_TAG 2
#define FIND_TAG 3
#define GMEM_TAG 4
#define LMEM_TAG 5
#define ENV_TAG 6
#define RES_TAG 7
#define VDM_TAG 8


#include <vdmapi.h>
#include "vdm.h"
#include "basevdm.h"

#include "stdlib.h"     // for atol
#include "stdio.h"     // for atol

#include <objidl.h>         //  needs nturtl.h
#include <propset.h>        //  needs objidl.h
#include <tsappcmp.h>

//
// Hydra function for supporting beeps on remote sessions
//
typedef HANDLE (WINAPI * PWINSTATIONBEEPOPEN)(ULONG);
HANDLE WINAPI
_WinStationBeepOpen(
    ULONG SessionId
    );
PWINSTATIONBEEPOPEN pWinStationBeepOpen;

//
//  Private functions for communication with CSR.
//
VOID
CsrBasepSoundSentryNotification(
    ULONG VideoMode
    );

NTSTATUS
CsrBaseClientConnectToServer(
    PWSTR szSessionDir,
    PHANDLE phMutant,
    PBOOLEAN pServerProcess
    );

NTSTATUS
CsrBasepRefreshIniFileMapping(
    PUNICODE_STRING BaseFileName
    );

NTSTATUS
CsrBasepDefineDosDevice(
    DWORD dwFlags,
    PUNICODE_STRING pDeviceName,
    PUNICODE_STRING pTargetPath
    );

UINT
CsrBasepGetTempFile(
    VOID
    );

NTSTATUS
CsrBasepCreateProcess(
    PBASE_CREATEPROCESS_MSG a
    );

VOID
CsrBasepExitProcess(
    UINT uExitCode
    );

NTSTATUS
CsrBasepSetProcessShutdownParam(
    DWORD dwLevel,
    DWORD dwFlags
    );

NTSTATUS
CsrBasepGetProcessShutdownParam(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    );

NTSTATUS
CsrBasepSetTermsrvAppInstallMode(
    BOOL bState
    );

NTSTATUS
CsrBasepSetClientTimeZoneInformation(
    IN PBASE_SET_TERMSRVCLIENTTIMEZONE c
    );

NTSTATUS
CsrBasepCreateThread(
    HANDLE ThreadHandle,
    CLIENT_ID ClientId
    );

//
// This should be merged with BasepCreateActCtx, its only caller.
//
#define BASEP_CREATE_ACTCTX_FLAG_NO_ADMIN_OVERRIDE 0x00000001
NTSTATUS
BasepCreateActCtx(
    ULONG           Flags,
    IN PCACTCTXW    ActParams,
    OUT PVOID*      ActivationContextData
    );

NTSTATUS
CsrBasepCreateActCtx(
    IN PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message
    );

#if defined(BUILD_WOW6432)
#include "ntwow64b.h"
#endif

BOOL TermsrvSyncUserIniFile(PINIFILE_PARAMETERS a);

BOOL TermsrvLogInstallIniFile(PINIFILE_PARAMETERS a);

extern PTERMSRVGETCOMPUTERNAME  gpTermsrvGetComputerName;
extern PTERMSRVADJUSTPHYMEMLIMITS gpTermsrvAdjustPhyMemLimits;
extern PTERMSRVGETWINDOWSDIRECTORYA gpTermsrvGetWindowsDirectoryA;
extern PTERMSRVGETWINDOWSDIRECTORYW gpTermsrvGetWindowsDirectoryW;
extern PTERMSRVCONVERTSYSROOTTOUSERDIR gpTermsrvConvertSysRootToUserDir;
extern PTERMSRVBUILDINIFILENAME gpTermsrvBuildIniFileName;
extern PTERMSRVCORINIFILE gpTermsrvCORIniFile;
extern PTERMSRVUPDATEALLUSERMENU gpTermsrvUpdateAllUserMenu;
extern PGETTERMSRCOMPATFLAGS gpGetTermsrCompatFlags;
extern PTERMSRVBUILDSYSINIPATH gpTermsrvBuildSysIniPath;
extern PTERMSRVCOPYINIFILE gpTermsrvCopyIniFile;
extern PTERMSRVGETSTRING gpTermsrvGetString;
extern PTERMSRVLOGINSTALLINIFILE gpTermsrvLogInstallIniFile;

//
//  For periodic timers that fire APCs set when a non-default activation context is active
//  we leak this structure.
//

#define BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK (0x00000001)

typedef struct _BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK {
    DWORD Flags;
    PVOID CallbackFunction;
    PVOID CallbackContext;
    PACTIVATION_CONTEXT ActivationContext;
} BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK, *PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK;

#define BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK (0x00000001)
#define BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT (0x00000002)

NTSTATUS
BasepAllocateActivationContextActivationBlock(
    IN DWORD Flags,
    IN PVOID CallbackFunction,
    IN PVOID CallbackContext,
    OUT PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK *ActivationBlock
    );

VOID
BasepFreeActivationContextActivationBlock(
    IN PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock
    );

VOID
WINAPI
BasepActivationContextActivationIoCompletion(
    IN PVOID ApcContext, // actually PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );

VOID
CALLBACK
BasepTimerAPCProc(
    IN PVOID ApcContext, // actually PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK
    IN ULONG TimerLowValue,
    IN LONG TimerHighValue
    );

#define SXS_POLICY_SUFFIX       L".Config"
#define SXS_MANIFEST_SUFFIX     L".Manifest"
extern const UNICODE_STRING SxsPolicySuffix;

typedef struct _SXS_CONSTANT_WIN32_NT_PATH_PAIR {
    PCUNICODE_STRING Win32;
    PCUNICODE_STRING Nt;
} SXS_CONSTANT_WIN32_NT_PATH_PAIR, *PSXS_CONSTANT_WIN32_NT_PATH_PAIR;
typedef const SXS_CONSTANT_WIN32_NT_PATH_PAIR* PCSXS_CONSTANT_WIN32_NT_PATH_PAIR;

typedef struct _SXS_WIN32_NT_PATH_PAIR {
    PRTL_UNICODE_STRING_BUFFER   Win32;
    PRTL_UNICODE_STRING_BUFFER   Nt;
} SXS_WIN32_NT_PATH_PAIR, *PSXS_WIN32_NT_PATH_PAIR;
typedef const SXS_WIN32_NT_PATH_PAIR *PCSXS_WIN32_NT_PATH_PAIR;

NTSTATUS
BasepSxsCreateResourceStream(
    IN ULONG                  LdrCreateOutOfProcessImageFlags,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES Handles,
    IN ULONG_PTR              MappedResourceName,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

NTSTATUS
BasepSxsCreateFileStream(
    IN ACCESS_MASK            AccessMask,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES Handles,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

// Pass the address of this to force policy to be empty.
// It doesn't have a special address, just the right values.
extern const SXS_OVERRIDE_STREAM SxsForceEmptyPolicy;

VOID
BasepSxsOverrideStreamToMessageStream(
    IN  PCSXS_OVERRIDE_STREAM OverrideStream,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

#define BASEP_SXS_CREATESTREAMS_FLAG_LIKE_CREATEPROCESS 0x00000001

NTSTATUS
BasepSxsCreateStreams(
    IN ULONG                                Flags,
    IN ULONG                                LdrCreateOutOfProcessImageFlags,
    IN ACCESS_MASK                          AccessMask,
    IN PCSXS_OVERRIDE_STREAM                OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM                OverridePolicy OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestFilePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestImagePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestImageHandles,
// If none of the optional parameters are passed, then you could have directly
// called a simpler function.
    IN ULONG_PTR                            MappedManifestResourceName OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    PolicyPathPair OPTIONAL,
    IN OUT PBASE_MSG_SXS_HANDLES            PolicyHandles OPTIONAL,
    OUT PULONG                              MessageFlags,
    OUT PBASE_MSG_SXS_STREAM                ManifestMessageStream,
    OUT PBASE_MSG_SXS_STREAM                PolicyMessageStream  OPTIONAL
    );

BOOL
BasepSxsIsStatusFileNotFoundEtc(
    NTSTATUS Status
    );

BOOL
BasepSxsIsStatusResourceNotFound(
    NTSTATUS Status
    );

NTSTATUS
BasepSxsCreateProcessCsrMessage(
    IN PCSXS_OVERRIDE_STREAM             OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM             OverridePolicy   OPTIONAL,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      ManifestFilePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR ManifestImagePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestImageHandles,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      PolicyPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         PolicyHandles,
    IN OUT PRTL_UNICODE_STRING_BUFFER    Win32AssemblyDirectoryBuffer,
    OUT PBASE_SXS_CREATEPROCESS_MSG      Message
    );

NTSTATUS
BasepSxsGetProcessImageBaseAddress(
    PBASE_MSG_SXS_HANDLES Handles
    );

VOID
NTAPI
BasepSxsActivationContextNotification(
    IN ULONG NotificationType,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN const VOID *ActivationContextData,
    IN PVOID NotificationContext,
    IN PVOID NotificationData,
    IN OUT PBOOLEAN DisableNotification
    );

VOID
BasepSxsDbgPrintMessageStream(
    PCSTR Function,
    PCSTR StreamName,
    PBASE_MSG_SXS_STREAM MessageStream
    );

extern const UNICODE_STRING SxsManifestSuffix;
extern const UNICODE_STRING SxsPolicySuffix;

VOID
BasepSxsCloseHandles(
    IN PCBASE_MSG_SXS_HANDLES Handles
    );

extern const WCHAR AdvapiDllString[];

//
// These functions implement apphelp cache functionality (ahcache.c)
//

//
// Routines in ahcache.c
//


BOOL
WINAPI
BaseCheckAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    PVOID   pEnvironment,
    DWORD*  dwReason
    );

//
// function that we call from winlogon
//

BOOL
WINAPI
BaseInitAppcompatCacheSupport(
    VOID
    );


BOOL
WINAPI
BaseCleanupAppcompatCacheSupport(
    BOOL bWrite
    );

//
// function that calls into csrss to check on app's compatibility
//

BOOL
NTAPI
BaseCheckRunApp(
    IN  HANDLE  FileHandle,
    IN  LPCWSTR pwszApplication,
    IN  PVOID   pEnvironment,
    IN  USHORT  uExeType,
    IN  DWORD   dwReason,
    OUT PVOID*  ppData,
    OUT PDWORD  pcbData,
    OUT PVOID*  ppSxsData,
    OUT PDWORD  pcbSxsData,
    OUT PDWORD  pdwFusionFlag
    );

VOID
BasepFreeAppCompatData(
    PVOID  pAppCompatData,
    SIZE_T cbAppCompatData,
    PVOID  pSxsData,
    SIZE_T cbSxsData
    );


NTSTATUS
NTAPI
BasepProbeForDllManifest(
    IN PVOID DllBase,
    IN PCWSTR FullDllPath,
    OUT PVOID *ActivationContext
    );

#define BASEP_GET_MODULE_HANDLE_EX_NO_LOCK                    (0x00000001)
BOOL
BasepGetModuleHandleExW(
    IN DWORD        dwPrivateFlags,
    IN DWORD        dwPublicFlags,
    IN LPCWSTR      lpModuleName,
    OUT HMODULE*    phModule
    );

#define BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR    1
#define BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS  2
#define BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE 3
ULONG
BasepGetModuleHandleExParameterValidation(
    IN DWORD        dwFlags,
    IN CONST VOID*  lpModuleName,
    OUT HMODULE*    phModule
    );

#define BASEP_GET_TEMP_PATH_PRESERVE_TEB         (0x00000001)
DWORD
BasepGetTempPathW(
    ULONG  Flags,
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

// There are defined in Termutil.c

NTSTATUS
BasepInitializeTermsrvFpns(
    VOID
    );

BOOL
IsCallerAdminOrSystem(
    VOID
    );

BOOL
IsTerminalServerCompatible(
    VOID
    );

NTSTATUS
IsTSAppCompatEnabled(
    OUT PBOOL
    );

NTSTATUS
GetPerUserWindowsDirectory(
    OUT PWCHAR TermSrvWindowsPath,
    IN SIZE_T  InLength,
    IN PSIZE_T OutLength
    );

UINT
GetErrorMode(
    VOID
    );

DWORD
GetThreadErrorMode(
    VOID
    );

#if defined(__cplusplus)
}
#endif

#endif // _BASEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\beep.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    This module contains the Win32 Beep APIs

Author:

    Steve Wood (stevewo)  5-Oct-1991

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include <ntddbeep.h>
#include "conapi.h"

#define IsActiveConsoleSession() (BOOLEAN)(USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)

/*
 * Forward declaration
 */

VOID NotifySoundSentry(VOID);

BOOL
APIENTRY
Beep(
    DWORD dwFreq,
    DWORD dwDuration
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    BEEP_SET_PARAMETERS BeepParameters;
    HANDLE hBeepDevice, hTSBeepDevice;

    if ( IsTerminalServer() ) {

        if ( !pWinStationBeepOpen ) {
            HMODULE hwinsta = NULL;
            /*
             *  Get handle to winsta.dll
             */
            if ( (hwinsta = LoadLibraryW( L"WINSTA" )) != NULL ) {

                PWINSTATIONBEEPOPEN BeepOpenFunction;

                BeepOpenFunction = (PWINSTATIONBEEPOPEN)
                    GetProcAddress( hwinsta, "_WinStationBeepOpen" );

                if (BeepOpenFunction
                    && ! InterlockedCompareExchangePointer((PVOID *)&pWinStationBeepOpen,
                                                           BeepOpenFunction,
                                                           NULL)) {
                    // We got a function, and we were the first to
                    // store our function to the global -- so pin the
                    // dll containing the function.
                    LdrAddRefDll(LDR_ADDREF_DLL_PIN, hwinsta);
                } else {
                    // Either we didn't get a function, or we weren't
                    // the first to store our function to the global
                    // -- so we don't need our reference to the dll.
                    FreeLibrary(hwinsta);
                }
            }
        }

        hTSBeepDevice = NULL;

        if ( pWinStationBeepOpen )
            hTSBeepDevice = (*pWinStationBeepOpen)( -1 ); //Current Session
    }

    if ( IsTerminalServer() && !IsActiveConsoleSession() ) {

        hBeepDevice = hTSBeepDevice;

        if ( hBeepDevice == NULL )
            Status = STATUS_ACCESS_DENIED;
        else
            Status = STATUS_SUCCESS;
    }
    else {

        RtlInitUnicodeString( &NameString, DD_BEEP_DEVICE_NAME_U );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &NameString,
                                    0,
                                    NULL,
                                    NULL
                                  );
        Status = NtCreateFile( &hBeepDevice,
                               FILE_READ_DATA | FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,
                               0,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN_IF,
                               0,
                               NULL,
                               0L
                             );
    }
    if (!NT_SUCCESS( Status )) {
        if ( IsTerminalServer() && hTSBeepDevice ) {
            NtClose( hTSBeepDevice );
        }
        BaseSetLastNTError( Status );
        return( FALSE );
        }

    //
    // 0,0 is a special case used to turn off a beep.  Otherwise
    // validate the dwFreq parameter to be in range.
    //

    if ((dwFreq != 0 || dwDuration != 0) &&
        (dwFreq < (ULONG)0x25 || dwFreq > (ULONG)0x7FFF)
       ) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else {
        BeepParameters.Frequency = dwFreq;
        BeepParameters.Duration = dwDuration;

        Status = NtDeviceIoControlFile( hBeepDevice,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_BEEP_SET,
                                        &BeepParameters,
                                        sizeof( BeepParameters ),
                                        NULL,
                                        0
                                      );
        }

    if ( IsTerminalServer() && IsActiveConsoleSession() && hTSBeepDevice ) {

        //
        // It's the console and since we got a beep device, it's being shadowed.
        // So let's do it one more time for the shadow client.
        //
        if ( NT_SUCCESS(Status) ) {
             NtDeviceIoControlFile( hTSBeepDevice,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatus,
                                    IOCTL_BEEP_SET,
                                    &BeepParameters,
                                    sizeof( BeepParameters ),
                                    NULL,
                                    0
                                  );
        }

        NtClose( hTSBeepDevice );
    }

    
    NotifySoundSentry();

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        NtClose( hBeepDevice );
        return( FALSE );
        }
    else {
        //
        // Beep device is asynchronous, so sleep for duration
        // to allow this beep to complete.
        //

        if (dwDuration != (DWORD)-1 && (dwFreq != 0 || dwDuration != 0)) {
            SleepEx( dwDuration, TRUE );
            }

        NtClose( hBeepDevice );
        return( TRUE );
        }
}


VOID
NotifySoundSentry(VOID)
{

#if defined(BUILD_WOW6432)
    ULONG VideoMode;

    if (!GetConsoleDisplayMode(&VideoMode)) {
        VideoMode = 0;
    }

    //
    // SoundSentry is currently only supported for Windows mode - no
    // full screen support.
    //
     
    if (VideoMode == 0) {    
        CsrBasepSoundSentryNotification(VideoMode);
    }
#else
    BASE_API_MSG m;
    PBASE_SOUNDSENTRY_NOTIFICATION_MSG e = &m.u.SoundSentryNotification;

    if (!GetConsoleDisplayMode(&e->VideoMode)) {
        e->VideoMode = 0;
    }
    //
    // SoundSentry is currently only supported for Windows mode - no
    // full screen support.
    //
    if (e->VideoMode == 0) {
        CsrClientCallServer((PCSR_API_MSG)&m,
                            NULL,
                            CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                 BasepSoundSentryNotification ),
                            sizeof( *e )
                            );
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\compname.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    COMPNAME.H

Abstract:

    Contains the common data structures for the Get/SetComputerName API

Author:

    Dan Hinsley  (DanHi)   16-Apr-1992

Revision History:

--*/

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\Current_Control_Set\\Services\\ComputerName"

#define NON_VOLATILE_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\Current_Control_Set\\Services\\ComputerName\\ComputerName"

#define VOLATILE_COMPUTERNAME L"ActiveComputerName"
#define NON_VOLATILE_COMPUTERNAME L"ComputerName"
#define COMPUTERNAME_VALUE_NAME L"ComputerName"
#define CLASS_STRING L"Network ComputerName"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\comm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    comm.c

Abstract:

    This module implements Win32 comm APIs

Author:

    Anthony V. Ercolano (tonye) 25-April-1991

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include "ntddser.h"
#include "cfgmgr32.h"

WCHAR CfgmgrDllString[] = L"cfgmgr32.dll";

typedef struct _LOCALMATCHSTR {
    DWORD FoundIt;
    LPCWSTR FriendlyName;
    } LOCALMATCHSTR,*PLOCALMATCHSTR;


static
NTSTATUS
GetConfigDialogName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

{

    PUNICODE_STRING dllToLoad = Context;
    if (ValueType != REG_SZ) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Allocate heap to hold the unicode string.  We know
    // that the string is zero terminated.  Allocate that
    // much.  Set the maximum size and size to
    // sizeof(WCHAR) - ValueLength.
    //

    RtlInitUnicodeString(
        dllToLoad,
        NULL
        );

    dllToLoad->Buffer = RtlAllocateHeap(
                            RtlProcessHeap(),
                            MAKE_TAG( TMP_TAG ),
                            ValueLength
                            );

    if (!dllToLoad->Buffer) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlCopyMemory(
        dllToLoad->Buffer,
        ValueData,
        ValueLength
        );

    dllToLoad->Length = (USHORT)(ValueLength - (sizeof(WCHAR)));
    dllToLoad->MaximumLength = (USHORT)ValueLength;

    return STATUS_SUCCESS;
}

static
NTSTATUS
GetFriendlyMatchComm(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

{

    UNICODE_STRING s1;
    UNICODE_STRING s2;
    PLOCALMATCHSTR localMatch = Context;

    RtlInitUnicodeString(
        &s1,
        localMatch->FriendlyName
        );
    RtlInitUnicodeString(
        &s2,
        ValueData
        );

    if (RtlEqualUnicodeString(
            &s1,
            &s2,
            TRUE
            )) {

        localMatch->FoundIt = TRUE;

    }

    return STATUS_SUCCESS;
}

VOID
GetFriendlyUi(
    LPCWSTR FriendlyName,
    PUNICODE_STRING DllToInvoke
    )

{

    RTL_QUERY_REGISTRY_TABLE paramTable[2] = {0};
    LOCALMATCHSTR localMatch = {0,FriendlyName};
    HINSTANCE libHandle;
    NTSTATUS Status;


    paramTable[0].QueryRoutine = GetFriendlyMatchComm;
    paramTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    //
    // First things first.  Load the cfg manager library.
    //

    libHandle = LoadLibraryW(CfgmgrDllString);

    if (libHandle) {

        FARPROC getSize;
        FARPROC getList;
        FARPROC locateDevNode;
        FARPROC openDevKey;

        try {
            getSize = GetProcAddress(
                          libHandle,
                          "CM_Get_Device_ID_List_SizeW"
                          );

            getList = GetProcAddress(
                          libHandle,
                          "CM_Get_Device_ID_ListW"
                          );

            locateDevNode = GetProcAddress(
                                libHandle,
                                "CM_Locate_DevNodeW"
                                );

            openDevKey = GetProcAddress(
                             libHandle,
                             "CM_Open_DevNode_Key"
                             );

            if (getSize && getList && locateDevNode && openDevKey) {

                PWCHAR bufferForList = NULL;
                DWORD sizeOfBuffer;

                //
                // Find how much memory for the buffer.
                //

                if (getSize(
                        &sizeOfBuffer,
                        L"MODEM",
                        CM_GETIDLIST_FILTER_SERVICE
                        ) == CR_SUCCESS) {

                    //
                    // Allocate 2 extra wchar.
                    //

                    bufferForList = RtlAllocateHeap(
                                        RtlProcessHeap(),
                                        MAKE_TAG( TMP_TAG ),
                                        (sizeOfBuffer*sizeof(WCHAR))
                                         +(sizeof(WCHAR)*2)
                                        );

                    if (bufferForList) {

                        PWCHAR currentId;

                        try {

                            if (getList(
                                    L"modem",
                                    bufferForList,
                                    sizeOfBuffer,
                                    CM_GETIDLIST_FILTER_SERVICE
                                    ) == CR_SUCCESS) {

                                for (
                                    currentId = bufferForList;
                                    *currentId;
                                    currentId += wcslen(currentId)+1
                                    ) {

                                    DWORD devInst = 0;

                                    if (locateDevNode(
                                            &devInst,
                                            currentId,
                                            CM_LOCATE_DEVINST_NORMAL
                                            ) == CR_SUCCESS) {

                                        HANDLE handleToDev;

                                        if (openDevKey(
                                                devInst,
                                                KEY_ALL_ACCESS,
                                                0,
                                                RegDisposition_OpenAlways,
                                                &handleToDev,
                                                CM_REGISTRY_SOFTWARE
                                                ) == CR_SUCCESS) {

                                            NTSTATUS statusOfQuery;

                                            localMatch.FoundIt = 0;
                                            paramTable[0].Name =
                                                L"FriendlyName";

                                            //
                                            // We now have an open
                                            // handle to a dev node.
                                            //
                                            // Check to see if it's
                                            // friendly name matches ours.
                                            //

                                            if (!NT_SUCCESS(
                                                     RtlQueryRegistryValues(
                                                         RTL_REGISTRY_HANDLE,
                                                         handleToDev,
                                                         &paramTable[0],
                                                         &localMatch,
                                                         NULL
                                                         )
                                                     )) {

                                                CloseHandle(handleToDev);
                                                continue;

                                            }

                                            if (!localMatch.FoundIt) {

                                                CloseHandle(handleToDev);
                                                continue;

                                            }

                                            //
                                            // The names match.  Now look
                                            // for the config dll name.
                                            //

                                            paramTable[0].QueryRoutine =
                                                GetConfigDialogName;
                                            paramTable[0].Name =
                                                L"ConfigDialog";
                                            statusOfQuery =
                                                RtlQueryRegistryValues(
                                                    RTL_REGISTRY_HANDLE,
                                                    handleToDev,
                                                    &paramTable[0],
                                                    DllToInvoke,
                                                    NULL
                                                    );

                                            paramTable[0].QueryRoutine =
                                                GetFriendlyMatchComm;

                                            if (!NT_SUCCESS(statusOfQuery)) {

                                                //
                                                // We had a bad status
                                                // back from getting the dll
                                                // name we should have gotten.
                                                //
                                                // There is no point in
                                                // looking for anymore
                                                //

                                                BaseSetLastNTError(
                                                    statusOfQuery
                                                    );
                                                CloseHandle(handleToDev);
                                                return;

                                            }

                                            //
                                            // We know that we are dealing
                                            // with a local registry here.
                                            // we just call closehandle.
                                            //

                                            CloseHandle(handleToDev);

                                            if (DllToInvoke->Buffer) {

                                                //
                                                // We have found a dll for
                                                // the friendly name.  Just
                                                // leave.  The finally
                                                // handlers will clean up
                                                // our allocations.
                                                //

                                                return;

                                            }

                                        }

                                    }

                                }

                            }


                        } finally {

                            //
                            // Free the idlist memory.
                            //

                            RtlFreeHeap(
                                RtlProcessHeap(),
                                0,
                                bufferForList
                                );

                        }

                    }

                }

            }

        } finally {

            FreeLibrary(libHandle);

        }

    }

    if (!DllToInvoke->Buffer) {

        //
        // Couldn't find the friendly name in the enum tree.
        // See if the value is a valid comm port name.  If
        // it is, default return serialui.dll
        //

        paramTable[0].Name = NULL;
        Status = RtlQueryRegistryValues(
            RTL_REGISTRY_DEVICEMAP,
            L"SERIALCOMM",
            paramTable,
            &localMatch,
            NULL
            );

        if (NT_SUCCESS(Status)
            && localMatch.FoundIt) {

            static const WCHAR dll[] = L"serialui.dll";

            DllToInvoke->Buffer = RtlAllocateHeap(
                                      RtlProcessHeap(),
                                      MAKE_TAG( TMP_TAG ),
                                      sizeof(dll)
                                      );

            if (!DllToInvoke->Buffer) {

                BaseSetLastNTError(STATUS_INSUFFICIENT_RESOURCES);
                return;

            }

            DllToInvoke->MaximumLength = sizeof(dll);
            DllToInvoke->Length = sizeof(dll) - sizeof(WCHAR);
            memcpy(DllToInvoke->Buffer, dll, sizeof(dll));

        } else {

            SetLastError(ERROR_INVALID_PARAMETER);

        }

    }

}


BOOL
CommConfigDialogW(
    LPCWSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    )

{


    UNICODE_STRING dllName = {0};
    BOOL boolToReturn = TRUE;
    HINSTANCE libInstance = 0;
    DWORD statOfCall = 0;


    //
    // Given the "friendly name" get the name of the dll to load.
    //

    GetFriendlyUi(
        lpszName,
        &dllName
        );

    try {

        if (dllName.Buffer) {

            //
            // Got the new library name.  Try to load it.
            //

            libInstance = LoadLibraryW(dllName.Buffer);

            if (libInstance) {

                FARPROC procToCall;

                //
                // Got the lib.  Get the proc address we need.
                //

                procToCall = GetProcAddress(
                                 libInstance,
                                 "drvCommConfigDialogW"
                                 );
                if (procToCall == NULL) {
                    boolToReturn = FALSE;
                    statOfCall = GetLastError();
                }
                else
                statOfCall = (DWORD)procToCall(
                                 lpszName,
                                 hWnd,
                                 lpCC
                                 );

            } else {

                statOfCall = GetLastError();
                boolToReturn = FALSE;

            }

        } else {

            //
            // Assume that an appropriate error has been set.
            //

            boolToReturn = FALSE;

        }


    } finally {

        if (dllName.Buffer) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                dllName.Buffer
                );

        }

        if (libInstance) {

            FreeLibrary(libInstance);

        }

        if (statOfCall) {

            SetLastError(statOfCall);
            boolToReturn = FALSE;

        }

    }

    return boolToReturn;


}

BOOL
CommConfigDialogA(
    LPCSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    )

{

    UNICODE_STRING tmpString;
    ANSI_STRING ansiString;
    BOOL uniBool;
    NTSTATUS Status;

    Status = RtlInitAnsiStringEx(
        &ansiString,
        lpszName
        );

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    Status = RtlAnsiStringToUnicodeString(
        &tmpString,
        &ansiString,
        TRUE
        );

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    try {

        uniBool = CommConfigDialogW(
                      tmpString.Buffer,
                      hWnd,
                      lpCC
                      );


    } finally {

        RtlFreeUnicodeString(&tmpString);

    }

    return uniBool;

}

BOOL
GetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    )
{

    UNICODE_STRING dllName = {0};
    BOOL boolToReturn = TRUE;
    HINSTANCE libInstance = 0;
    DWORD statOfCall = 0;


    //
    // Given the "friendly name" get the name of the dll to load.
    //

    GetFriendlyUi(
        lpszName,
        &dllName
        );

    try {

        if (dllName.Buffer) {

            //
            // Got the new library name.  Try to load it.
            //

            libInstance = LoadLibraryW(dllName.Buffer);

            if (libInstance) {

                FARPROC procToCall;

                //
                // Got the lib.  Get the proc address we need.
                //

                procToCall = GetProcAddress(
                                 libInstance,
                                 "drvGetDefaultCommConfigW"
                                 );
                if (procToCall == NULL) {
                    statOfCall = GetLastError();
                    boolToReturn = FALSE;
                }
                else
                statOfCall = (DWORD)procToCall(
                                 lpszName,
                                 lpCC,
                                 lpdwSize
                                 );

            } else {

                statOfCall = GetLastError();
                boolToReturn = FALSE;

            }

        } else {

            //
            // Assume that an appropriate error has been set.
            //

            boolToReturn = FALSE;

        }


    } finally {

        if (dllName.Buffer) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                dllName.Buffer
                );

        }

        if (libInstance) {

            FreeLibrary(libInstance);

        }

        if (statOfCall) {

            SetLastError(statOfCall);
            boolToReturn = FALSE;

        }

    }

    return boolToReturn;

}

BOOL
GetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    )
{
    UNICODE_STRING tmpString;
    ANSI_STRING ansiString;
    BOOL uniBool;
    NTSTATUS Status;

    Status = RtlInitAnsiStringEx(
        &ansiString,
        lpszName
        );

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    Status = RtlAnsiStringToUnicodeString(
        &tmpString,
        &ansiString,
        TRUE
        );

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    try {

        uniBool = GetDefaultCommConfigW(
                      tmpString.Buffer,
                      lpCC,
                      lpdwSize
                      );

    } finally {

        RtlFreeUnicodeString(&tmpString);

    }

    return uniBool;

}

BOOL
SetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    )
{

    UNICODE_STRING dllName = {0};
    BOOL boolToReturn = TRUE;
    HINSTANCE libInstance = 0;
    DWORD statOfCall = 0;


    //
    // Given the "friendly name" get the name of the dll to load.
    //

    GetFriendlyUi(
        lpszName,
        &dllName
        );

    try {

        if (dllName.Buffer) {

            //
            // Got the new library name.  Try to load it.
            //

            libInstance = LoadLibraryW(dllName.Buffer);

            if (libInstance) {

                FARPROC procToCall;

                //
                // Got the lib.  Get the proc address we need.
                //

                procToCall = GetProcAddress(
                                 libInstance,
                                 "drvSetDefaultCommConfigW"
                                 );
                if (procToCall == NULL) {
                    boolToReturn = FALSE;
                    statOfCall = GetLastError();
                }
                else
                statOfCall = (DWORD)procToCall(
                                 lpszName,
                                 lpCC,
                                 dwSize
                                 );

            } else {

                statOfCall = GetLastError();
                boolToReturn = FALSE;

            }

        } else {

            //
            // Assume that an appropriate error has been set.
            //

            boolToReturn = FALSE;

        }


    } finally {

        if (dllName.Buffer) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                dllName.Buffer
                );

        }

        if (libInstance) {

            FreeLibrary(libInstance);

        }

        if (statOfCall) {

            SetLastError(statOfCall);
            boolToReturn = FALSE;

        }

    }
    return boolToReturn;
}

BOOL
SetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    )
{
    UNICODE_STRING tmpString;
    ANSI_STRING ansiString;
    BOOL uniBool = TRUE;
    NTSTATUS Status;

    Status = RtlInitAnsiStringEx(
        &ansiString,
        lpszName
        );

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    Status = RtlAnsiStringToUnicodeString(
        &tmpString,
        &ansiString,
        TRUE
        );

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    try {

        uniBool = SetDefaultCommConfigW(
                      tmpString.Buffer,
                      lpCC,
                      dwSize
                      );

    } finally {

        RtlFreeUnicodeString(&tmpString);

    }

    return uniBool;

}

BOOL
ClearCommBreak(
    HANDLE hFile
    )

/*++

Routine Description:

    The function restores character transmission and places the transmission
    line in a nonbreak state.

Arguments:

    hFile - Specifies the communication device to be adjusted.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    return EscapeCommFunction(hFile,CLRBREAK);

}

BOOL
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    )

/*++

Routine Description:

    In case of a communications error, such as a buffer overrun or
    framing error, the communications software will abort all
    read and write operations on the communication port.  No further
    read or write operations will be accepted until this function
    is called.

Arguments:

    hFile - Specifies the communication device to be adjusted.

    lpErrors - Points to the DWORD that is to receive the mask of the
               error that occured.

    lpStat - Points to the COMMSTAT structure that is to receive
             the device status.  The structure contains information
             about the communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_STATUS LocalStat;

    RtlZeroMemory(&LocalStat, sizeof(SERIAL_STATUS));

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_COMMSTATUS,
                 NULL,
                 0,
                 &LocalStat,
                 sizeof(LocalStat)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (lpStat) {

        //
        // All is well up to this point.  Translate the NT values
        // into win32 values.
        //

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_CTS) {

            lpStat->fCtsHold = TRUE;

        } else {

            lpStat->fCtsHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DSR) {

            lpStat->fDsrHold = TRUE;

        } else {

            lpStat->fDsrHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DCD) {

            lpStat->fRlsdHold = TRUE;

        } else {

            lpStat->fRlsdHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_XON) {

            lpStat->fXoffHold = TRUE;

        } else {

            lpStat->fXoffHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_XOFF_SENT) {

            lpStat->fXoffSent = TRUE;

        } else {

            lpStat->fXoffSent = FALSE;

        }

        lpStat->fEof = LocalStat.EofReceived;
        lpStat->fTxim = LocalStat.WaitForImmediate;
        lpStat->cbInQue = LocalStat.AmountInInQueue;
        lpStat->cbOutQue = LocalStat.AmountInOutQueue;

    }

    if (lpErrors) {

        *lpErrors = 0;

        if (LocalStat.Errors & SERIAL_ERROR_BREAK) {

            *lpErrors = *lpErrors | CE_BREAK;

        }

        if (LocalStat.Errors & SERIAL_ERROR_FRAMING) {

            *lpErrors = *lpErrors | CE_FRAME;

        }

        if (LocalStat.Errors & SERIAL_ERROR_OVERRUN) {

            *lpErrors = *lpErrors | CE_OVERRUN;

        }

        if (LocalStat.Errors & SERIAL_ERROR_QUEUEOVERRUN) {

            *lpErrors = *lpErrors | CE_RXOVER;

        }

        if (LocalStat.Errors & SERIAL_ERROR_PARITY) {

            *lpErrors = *lpErrors | CE_RXPARITY;

        }

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    )

/*++

Routine Description:

    The communication device is not initialized until SetupComm is
    called.  This function allocates space for receive and transmit
    queues.  These queues are used by the interrupt-driven transmit/
    receive software and are internal to the provider.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwInQueue - Specifies the recommended size of the provider's
                internal receive queue in bytes.  This value must be
                even.  A value of -1 indicates that the default should
                be used.

    dwOutQueue - Specifies the recommended size of the provider's
                 internal transmit queue in bytes.  This value must be
                 even.  A value of -1 indicates that the default should
                 be used.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;

    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_QUEUE_SIZE NewSizes = {0};

    //
    // Make sure that the sizes are even.
    //

    if (dwOutQueue != ((DWORD)-1)) {

        if (((dwOutQueue/2)*2) != dwOutQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    if (dwInQueue != ((DWORD)-1)) {

        if (((dwInQueue/2)*2) != dwInQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    NewSizes.InSize = dwInQueue;
    NewSizes.OutSize = dwOutQueue;


    if (!(SyncEvent = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_SET_QUEUE_SIZE,
                 &NewSizes,
                 sizeof(SERIAL_QUEUE_SIZE),
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    )

/*++

Routine Description:

    This function directs the communication-device specified by the
    hFile parameter to carry out the extended function specified by
    the dwFunc parameter.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwFunc - Specifies the function code of the extended function.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    ULONG ControlCode;
    HANDLE Event;

    switch (dwFunc) {

        case SETXOFF: {
            ControlCode = IOCTL_SERIAL_SET_XOFF;
            break;
        }

        case SETXON: {
            ControlCode = IOCTL_SERIAL_SET_XON;
            break;
        }

        case SETRTS: {
            ControlCode = IOCTL_SERIAL_SET_RTS;
            break;
        }

        case CLRRTS: {
            ControlCode = IOCTL_SERIAL_CLR_RTS;
            break;
        }

        case SETDTR: {
            ControlCode = IOCTL_SERIAL_SET_DTR;
            break;
        }

        case CLRDTR: {
            ControlCode = IOCTL_SERIAL_CLR_DTR;
            break;
        }

        case RESETDEV: {
            ControlCode = IOCTL_SERIAL_RESET_DEVICE;
            break;
        }

        case SETBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_ON;
            break;
        }

        case CLRBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_OFF;
            break;
        }
        default: {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;


        }
    }


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 Event,
                 NULL,
                 NULL,
                 &Iosb,
                 ControlCode,
                 NULL,
                 0,
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( Event, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(Event);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(Event);
    return TRUE;

}

BOOL
GetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    )
{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    ULONG configLength;
    HANDLE Event;
    DWORD olddwSize = *lpdwSize;


    //
    // Ask the device how big the device config structure is.
    //

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hCommDev,
                 Event,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_CONFIG_SIZE,
                 NULL,
                 0,
                 &configLength,
                 sizeof(configLength)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( Event, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        configLength = 0;

    }

    if (!configLength) {

        //
        // The size needed is simply the size of the comm config structure.
        //

        CloseHandle(Event);
        if (!ARGUMENT_PRESENT(lpdwSize)) {

            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;

        } else {

            *lpdwSize = sizeof(COMMCONFIG);

            if (ARGUMENT_PRESENT(lpCC)) {

                //
                // Fill in the random fields.
                //

                lpCC->dwSize = sizeof(COMMCONFIG);
                lpCC->wVersion = 1;
                lpCC->wReserved = 0;
                lpCC->dwProviderSubType = PST_RS232;
                lpCC->dwProviderOffset = 0;
                lpCC->dwProviderSize = 0;
                lpCC->wcProviderData[0] = 0;

                return GetCommState(
                           hCommDev,
                           &lpCC->dcb
                           );

            } else {

                return TRUE;

            }

        }

    } else {

        if (!ARGUMENT_PRESENT(lpdwSize)) {

            CloseHandle(Event);
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;

        } else {

            if (*lpdwSize < sizeof(COMMCONFIG)) {

                CloseHandle(Event);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                *lpdwSize = configLength;
                return FALSE;

            } else {

                if (ARGUMENT_PRESENT(lpCC)) {

                    lpCC->wVersion = 1;
                    lpCC->dwProviderSubType = PST_MODEM;

                    if (*lpdwSize < configLength) {

                        lpCC->dwProviderOffset = 0;
                        lpCC->dwProviderSize = 0;
                        lpCC->wcProviderData[0] = 0;
                        *lpdwSize = sizeof(COMMCONFIG);
                        CloseHandle(Event);

                        return GetCommState(
                                   hCommDev,
                                   &lpCC->dcb
                                   );

                    } else {

                        *lpdwSize = configLength;

                        //
                        // Call down to the lower level serial provider
                        // if there is a passed comm config.  Assume
                        // that the buffer is as large as it needs to be.
                        // Parameter validation will insure that we
                        // can write to at least that much.
                        //

                        Status = NtDeviceIoControlFile(
                                     hCommDev,
                                     Event,
                                     NULL,
                                     NULL,
                                     &Iosb,
                                     IOCTL_SERIAL_GET_COMMCONFIG,
                                     NULL,
                                     0,
                                     lpCC,
                                     configLength
                                     );

                        if ( Status == STATUS_PENDING) {

                            // Operation must complete before return & IoStatusBlock destroyed

                            Status = NtWaitForSingleObject( Event, FALSE, NULL );
                            if ( NT_SUCCESS(Status)) {

                                Status = Iosb.Status;

                            }
                        }

                        if (NT_ERROR(Status)) {

                            CloseHandle(Event);
                            BaseSetLastNTError(Status);
                            return FALSE;

                        }

                        //
                        // Got the config stuff, get the comm state too.
                        //

                        CloseHandle(Event);
                        return GetCommState(
                                   hCommDev,
                                   &lpCC->dcb
                                   );

                    }

                } else {


                    *lpdwSize = configLength;
                    CloseHandle(Event);
                    return TRUE;

                }

            }

        }

    }

}

BOOL
GetCommMask(
    HANDLE hFile,
    LPDWORD lpEvtMask
    )

/*++

Routine Description:


    This function retrieves the value of the event mask for the handle
    hFile. The mask is not cleared

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpEvtMask - Points to a DWORD which is to receive the mask of events
                which are currently enabled.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;

    //
    // First we do an assert to make sure that the
    // values in the win header files are the same
    // as the nt serial interface, and that the
    // size of the win32 wait mask is the same size
    // as the nt wait mask.
    //

    ASSERT((SERIAL_EV_RXCHAR   == EV_RXCHAR  ) &&
           (SERIAL_EV_RXFLAG   == EV_RXFLAG  ) &&
           (SERIAL_EV_TXEMPTY  == EV_TXEMPTY ) &&
           (SERIAL_EV_CTS      == EV_CTS     ) &&
           (SERIAL_EV_DSR      == EV_DSR     ) &&
           (SERIAL_EV_RLSD     == EV_RLSD    ) &&
           (SERIAL_EV_BREAK    == EV_BREAK   ) &&
           (SERIAL_EV_ERR      == EV_ERR     ) &&
           (SERIAL_EV_RING     == EV_RING    ) &&
           (SERIAL_EV_PERR     == EV_PERR    ) &&
           (SERIAL_EV_RX80FULL == EV_RX80FULL) &&
           (SERIAL_EV_EVENT1   == EV_EVENT1  ) &&
           (SERIAL_EV_EVENT2   == EV_EVENT2  ) &&
           (sizeof(ULONG) == sizeof(DWORD)));

    //
    // All is well, get the mask from the driver.
    //

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_WAIT_MASK,
                 NULL,
                 0,
                 lpEvtMask,
                 sizeof(ULONG)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommModemStatus(
    HANDLE hFile,
    LPDWORD lpModemStat
    )

/*++

Routine Description:

    This routine returns the most current value of the modem
    status registers non-delta values.


Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpEvtMask - Points to a DWORD which is to receive the mask of
                non-delta values in the modem status register.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_MODEMSTATUS,
                 NULL,
                 0,
                 lpModemStat,
                 sizeof(DWORD)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommProperties(
    HANDLE hFile,
    LPCOMMPROP lpCommProp
    )

/*++

Routine Description:

    This function fills the ubffer pointed to by lpCommProp with the
    communications properties associated with the communications device
    specified by the hFile.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpCommProp - Points to the COMMPROP data structure that is to
                 receive the communications properties structure.  This
                 structure defines certain properties of the communications
                 device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    DWORD bufferLength;

    //
    // Make sure that the windows defines and the nt defines are
    // still in sync.
    //

    ASSERT((SERIAL_PCF_DTRDSR        == PCF_DTRDSR) &&
           (SERIAL_PCF_RTSCTS        == PCF_RTSCTS) &&
           (SERIAL_PCF_CD            == PCF_RLSD) &&
           (SERIAL_PCF_PARITY_CHECK  == PCF_PARITY_CHECK) &&
           (SERIAL_PCF_XONXOFF       == PCF_XONXOFF) &&
           (SERIAL_PCF_SETXCHAR      == PCF_SETXCHAR) &&
           (SERIAL_PCF_TOTALTIMEOUTS == PCF_TOTALTIMEOUTS) &&
           (SERIAL_PCF_INTTIMEOUTS   == PCF_INTTIMEOUTS) &&
           (SERIAL_PCF_SPECIALCHARS  == PCF_SPECIALCHARS) &&
           (SERIAL_PCF_16BITMODE     == PCF_16BITMODE) &&
           (SERIAL_SP_PARITY         == SP_PARITY) &&
           (SERIAL_SP_BAUD           == SP_BAUD) &&
           (SERIAL_SP_DATABITS       == SP_DATABITS) &&
           (SERIAL_SP_STOPBITS       == SP_STOPBITS) &&
           (SERIAL_SP_HANDSHAKING    == SP_HANDSHAKING) &&
           (SERIAL_SP_PARITY_CHECK   == SP_PARITY_CHECK) &&
           (SERIAL_SP_CARRIER_DETECT == SP_RLSD) &&
           (SERIAL_BAUD_075          == BAUD_075) &&
           (SERIAL_BAUD_110          == BAUD_110) &&
           (SERIAL_BAUD_134_5        == BAUD_134_5) &&
           (SERIAL_BAUD_150          == BAUD_150) &&
           (SERIAL_BAUD_300          == BAUD_300) &&
           (SERIAL_BAUD_600          == BAUD_600) &&
           (SERIAL_BAUD_1200         == BAUD_1200) &&
           (SERIAL_BAUD_1800         == BAUD_1800) &&
           (SERIAL_BAUD_2400         == BAUD_2400) &&
           (SERIAL_BAUD_4800         == BAUD_4800) &&
           (SERIAL_BAUD_7200         == BAUD_7200) &&
           (SERIAL_BAUD_9600         == BAUD_9600) &&
           (SERIAL_BAUD_14400        == BAUD_14400) &&
           (SERIAL_BAUD_19200        == BAUD_19200) &&
           (SERIAL_BAUD_38400        == BAUD_38400) &&
           (SERIAL_BAUD_56K          == BAUD_56K) &&
           (SERIAL_BAUD_57600        == BAUD_57600) &&
           (SERIAL_BAUD_115200       == BAUD_115200) &&
           (SERIAL_BAUD_USER         == BAUD_USER) &&
           (SERIAL_DATABITS_5        == DATABITS_5) &&
           (SERIAL_DATABITS_6        == DATABITS_6) &&
           (SERIAL_DATABITS_7        == DATABITS_7) &&
           (SERIAL_DATABITS_8        == DATABITS_8) &&
           (SERIAL_DATABITS_16       == DATABITS_16) &&
           (SERIAL_DATABITS_16X      == DATABITS_16X) &&
           (SERIAL_STOPBITS_10       == STOPBITS_10) &&
           (SERIAL_STOPBITS_15       == STOPBITS_15) &&
           (SERIAL_STOPBITS_20       == STOPBITS_20) &&
           (SERIAL_PARITY_NONE       == PARITY_NONE) &&
           (SERIAL_PARITY_ODD        == PARITY_ODD) &&
           (SERIAL_PARITY_EVEN       == PARITY_EVEN) &&
           (SERIAL_PARITY_MARK       == PARITY_MARK) &&
           (SERIAL_PARITY_SPACE      == PARITY_SPACE));
    ASSERT((SERIAL_SP_UNSPECIFIED    == PST_UNSPECIFIED) &&
           (SERIAL_SP_RS232          == PST_RS232) &&
           (SERIAL_SP_PARALLEL       == PST_PARALLELPORT) &&
           (SERIAL_SP_RS422          == PST_RS422) &&
           (SERIAL_SP_RS423          == PST_RS423) &&
           (SERIAL_SP_RS449          == PST_RS449) &&
           (SERIAL_SP_FAX            == PST_FAX) &&
           (SERIAL_SP_SCANNER        == PST_SCANNER) &&
           (SERIAL_SP_BRIDGE         == PST_NETWORK_BRIDGE) &&
           (SERIAL_SP_LAT            == PST_LAT) &&
           (SERIAL_SP_TELNET         == PST_TCPIP_TELNET) &&
           (SERIAL_SP_X25            == PST_X25));

    ASSERT(sizeof(SERIAL_COMMPROP) == sizeof(COMMPROP));
    //
    // Get the total length of what to pass down.  If the
    // application indicates that there is provider specific data
    // (by setting dwProvSpec1 to COMMPROP_INITIAILIZED) then
    // use what's at the start of the commprop.
    //

    bufferLength = sizeof(COMMPROP);

    if (lpCommProp->dwProvSpec1 == COMMPROP_INITIALIZED) {

        bufferLength = lpCommProp->wPacketLength;

    }

    //
    // Zero out the commprop.  This might create an access violation
    // if it isn't big enough.  Which is ok, since we would rather
    // get it before we create the sync event.
    //

    RtlZeroMemory(lpCommProp, bufferLength);

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_PROPERTIES,
                 NULL,
                 0,
                 lpCommProp,
                 bufferLength
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function fills the buffer pointed to by the lpDCB parameter with
    the device control block of the communication device specified by hFile
    parameter.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpDCB - Points to the DCB data structure that is to receive the current
            device control block.  The structure defines the control settings
            for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    //
    // Make sure the windows mapping is the same as the NT mapping.
    //

    ASSERT((ONESTOPBIT == STOP_BIT_1) &&
           (ONE5STOPBITS == STOP_BITS_1_5) &&
           (TWOSTOPBITS == STOP_BITS_2));

    ASSERT((NOPARITY == NO_PARITY) &&
           (ODDPARITY == ODD_PARITY) &&
           (EVENPARITY == EVEN_PARITY) &&
           (MARKPARITY == MARK_PARITY) &&
           (SPACEPARITY == SPACE_PARITY));

    //
    // Zero out the dcb.  This might create an access violation
    // if it isn't big enough.  Which is ok, since we would rather
    // get it before we create the sync event.
    //

    RtlZeroMemory(lpDCB, sizeof(DCB));

    lpDCB->DCBlength = sizeof(DCB);
    lpDCB->fBinary = TRUE;

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_BAUD_RATE,
                 NULL,
                 0,
                 &LocalBaud,
                 sizeof(LocalBaud)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->BaudRate = LocalBaud.BaudRate;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_LINE_CONTROL,
                 NULL,
                 0,
                 &LineControl,
                 sizeof(LineControl)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->Parity = LineControl.Parity;
    lpDCB->ByteSize = LineControl.WordLength;
    lpDCB->StopBits = LineControl.StopBits;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_CHARS,
                 NULL,
                 0,
                 &Chars,
                 sizeof(Chars)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->XonChar = Chars.XonChar;
    lpDCB->XoffChar = Chars.XoffChar;
    lpDCB->ErrorChar = Chars.ErrorChar;
    lpDCB->EofChar = Chars.EofChar;
    lpDCB->EvtChar = Chars.EventChar;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_HANDFLOW,
                 NULL,
                 0,
                 &HandFlow,
                 sizeof(HandFlow)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) {

        lpDCB->fOutxCtsFlow = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) {

        lpDCB->fOutxDsrFlow = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) {

        lpDCB->fOutX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) {

        lpDCB->fInX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_NULL_STRIPPING) {

        lpDCB->fNull = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_ERROR_CHAR) {

        lpDCB->fErrorChar = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_XOFF_CONTINUE) {

        lpDCB->fTXContinueOnXoff = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) {

        lpDCB->fAbortOnError = TRUE;

    }

    switch (HandFlow.FlowReplace & SERIAL_RTS_MASK) {
        case 0:
            lpDCB->fRtsControl = RTS_CONTROL_DISABLE;
            break;
        case SERIAL_RTS_CONTROL:
            lpDCB->fRtsControl = RTS_CONTROL_ENABLE;
            break;
        case SERIAL_RTS_HANDSHAKE:
            lpDCB->fRtsControl = RTS_CONTROL_HANDSHAKE;
            break;
        case SERIAL_TRANSMIT_TOGGLE:
            lpDCB->fRtsControl = RTS_CONTROL_TOGGLE;
            break;
    }

    switch (HandFlow.ControlHandShake & SERIAL_DTR_MASK) {
        case 0:
            lpDCB->fDtrControl = DTR_CONTROL_DISABLE;
            break;
        case SERIAL_DTR_CONTROL:
            lpDCB->fDtrControl = DTR_CONTROL_ENABLE;
            break;
        case SERIAL_DTR_HANDSHAKE:
            lpDCB->fDtrControl = DTR_CONTROL_HANDSHAKE;
            break;
    }

    lpDCB->fDsrSensitivity =
        (HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY)?(TRUE):(FALSE);
    lpDCB->XonLim = (WORD)HandFlow.XonLimit;
    lpDCB->XoffLim = (WORD)HandFlow.XoffLimit;

    CloseHandle(SyncEvent);
    return TRUE;
}

BOOL
GetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function returns the timeout characteristics for all read and
    write operations on the handle specified by hFile.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpCommTimeouts - Points to a structure which is to receive the
                     current communications timeouts.


Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_TIMEOUTS To;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {


        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_GET_TIMEOUTS,
                     NULL,
                     0,
                     &To,
                     sizeof(To)
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS( Status )) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            BaseSetLastNTError(Status);
            CloseHandle(Event);
            return FALSE;

        }

        CloseHandle(Event);

        //
        // Everything went ok.  Move the value from the Nt records
        // to the windows record.
        //

        lpCommTimeouts->ReadIntervalTimeout = To.ReadIntervalTimeout;
        lpCommTimeouts->ReadTotalTimeoutMultiplier = To.ReadTotalTimeoutMultiplier;
        lpCommTimeouts->ReadTotalTimeoutConstant = To.ReadTotalTimeoutConstant;
        lpCommTimeouts->WriteTotalTimeoutMultiplier = To.WriteTotalTimeoutMultiplier;
        lpCommTimeouts->WriteTotalTimeoutConstant = To.WriteTotalTimeoutConstant;

        return TRUE;

    }

}

BOOL
PurgeComm(
    HANDLE hFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    This function is used to purge all characters from the transmit
    or receive queues of the communication device specified by the
    hFile parameter.  The dwFlags parameter specifies what function
    is to be performed.

Arguments:

    hFile - Specifies the communication device to be purged.
            The CreateFile function returns this value.

    dwFlags - Bit mask defining actions to be taken.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_PURGE,
                     &dwFlags,
                     sizeof(ULONG),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS( Status )) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }


}

BOOL
SetCommBreak(
    HANDLE hFile
    )

/*++

Routine Description:

    The function suspends character transmission and places the transmission
    line in a break state until the break condition is cleared..

Arguments:

    hFile - Specifies the communication device to be suspended.
            The CreateFile function returns this value.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    return EscapeCommFunction(hFile,SETBREAK);

}

BOOL
SetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    )

{


    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;
    LPCOMMCONFIG comConf = lpCC;

    if (lpCC->dwProviderOffset) {

        if (!(Event = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

            return FALSE;

        }

        //
        //
        // Call the driver to set the config structure.
        //

        Status = NtDeviceIoControlFile(
                     hCommDev,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_COMMCONFIG,
                     lpCC,
                     dwSize,
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }
        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);

    }

    return SetCommState(
               hCommDev,
               &comConf->dcb
               );
}

BOOL
SetCommMask(
    HANDLE hFile,
    DWORD dwEvtMask
    )

/*++

Routine Description:

    The function enables the event mask of the communication device
    specified by the hFile parameter.  The bits of the nEvtMask parameter
    define which events are to be enabled.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwEvtMask - Specifies which events are to enabled.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    //
    // First we do an assert to make sure that the
    // values in the win header files are the same
    // as the nt serial interface and the the size
    // mask that serial expects is the same as the
    // size that win32 expects.
    //

    ASSERT((SERIAL_EV_RXCHAR   == EV_RXCHAR  ) &&
           (SERIAL_EV_RXFLAG   == EV_RXFLAG  ) &&
           (SERIAL_EV_TXEMPTY  == EV_TXEMPTY ) &&
           (SERIAL_EV_CTS      == EV_CTS     ) &&
           (SERIAL_EV_DSR      == EV_DSR     ) &&
           (SERIAL_EV_RLSD     == EV_RLSD    ) &&
           (SERIAL_EV_BREAK    == EV_BREAK   ) &&
           (SERIAL_EV_ERR      == EV_ERR     ) &&
           (SERIAL_EV_RING     == EV_RING    ) &&
           (SERIAL_EV_PERR     == EV_PERR    ) &&
           (SERIAL_EV_RX80FULL == EV_RX80FULL) &&
           (SERIAL_EV_EVENT1   == EV_EVENT1  ) &&
           (SERIAL_EV_EVENT2   == EV_EVENT2  ) &&
           (sizeof(DWORD) == sizeof(ULONG)));


    //
    // Make sure that the users mask doesn't contain any values
    // we don't support.
    //

    if (dwEvtMask & (~(EV_RXCHAR   |
                       EV_RXFLAG   |
                       EV_TXEMPTY  |
                       EV_CTS      |
                       EV_DSR      |
                       EV_RLSD     |
                       EV_BREAK    |
                       EV_ERR      |
                       EV_RING     |
                       EV_PERR     |
                       EV_RX80FULL |
                       EV_EVENT1   |
                       EV_EVENT2))) {

        SetLastError(ERROR_INVALID_DATA);
        return FALSE;

    }


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {


        //
        // All is well, send the mask to the driver.
        //

        ULONG LocalMask = dwEvtMask;

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_WAIT_MASK,
                     &LocalMask,
                     sizeof(ULONG),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS( Status )) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    The SetCommState function sets a communication device to the state
    specified in the lpDCB parameter.  The device is identified by the
    hFile parameter.  This function reinitializes all hardwae and controls
    as specified byt the lpDCB, but does not empty the transmit or
    receive queues.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpDCB - Points to a DCB structure that contains the desired
            communications setting for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow = {0};
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Keep a copy of what the DCB was like before we started
    // changing things.  If some error occurs we can use
    // it to restore the old setup.
    //
    DCB OldDcb;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.  While it would be very
    // strange to be setting the comm state while IO is active
    // we need to make sure we don't compound the problem by
    // returning before this API's IO is actually finished.  This
    // can happen because the file handle is set on the completion
    // of any IO.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    if (GetCommState(
            hFile,
            &OldDcb
            )) {

        //
        // Try to set the baud rate.  If we fail here, we just return
        // because we never actually got to set anything.
        //

        if (!(SyncEvent = CreateEvent(
                              NULL,
                              TRUE,
                              FALSE,
                              NULL
                              ))) {

            return FALSE;

        }

        LocalBaud.BaudRate = lpDCB->BaudRate;
        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_BAUD_RATE,
                     &LocalBaud,
                     sizeof(LocalBaud),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        LineControl.StopBits = lpDCB->StopBits;
        LineControl.Parity = lpDCB->Parity;
        LineControl.WordLength = lpDCB->ByteSize;
        LocalBaud.BaudRate = lpDCB->BaudRate;
        Chars.XonChar   = lpDCB->XonChar;
        Chars.XoffChar  = lpDCB->XoffChar;
        Chars.ErrorChar = lpDCB->ErrorChar;
        Chars.BreakChar = lpDCB->ErrorChar;
        Chars.EofChar   = lpDCB->EofChar;
        Chars.EventChar = lpDCB->EvtChar;

        HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
        switch (lpDCB->fRtsControl) {
            case RTS_CONTROL_DISABLE:
                break;
            case RTS_CONTROL_ENABLE:
                HandFlow.FlowReplace |= SERIAL_RTS_CONTROL;
                break;
            case RTS_CONTROL_HANDSHAKE:
                HandFlow.FlowReplace |= SERIAL_RTS_HANDSHAKE;
                break;
            case RTS_CONTROL_TOGGLE:
                HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        HandFlow.ControlHandShake &= ~SERIAL_DTR_MASK;
        switch (lpDCB->fDtrControl) {
            case DTR_CONTROL_DISABLE:
                break;
            case DTR_CONTROL_ENABLE:
                HandFlow.ControlHandShake |= SERIAL_DTR_CONTROL;
                break;
            case DTR_CONTROL_HANDSHAKE:
                HandFlow.ControlHandShake |= SERIAL_DTR_HANDSHAKE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        if (lpDCB->fDsrSensitivity) {

            HandFlow.ControlHandShake |= SERIAL_DSR_SENSITIVITY;

        }

        if (lpDCB->fOutxCtsFlow) {

            HandFlow.ControlHandShake |= SERIAL_CTS_HANDSHAKE;

        }

        if (lpDCB->fOutxDsrFlow) {

            HandFlow.ControlHandShake |= SERIAL_DSR_HANDSHAKE;

        }

        if (lpDCB->fOutX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_TRANSMIT;

        }

        if (lpDCB->fInX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_RECEIVE;

        }

        if (lpDCB->fNull) {

            HandFlow.FlowReplace |= SERIAL_NULL_STRIPPING;

        }

        if (lpDCB->fErrorChar) {

            HandFlow.FlowReplace |= SERIAL_ERROR_CHAR;
        }

        if (lpDCB->fTXContinueOnXoff) {

            HandFlow.FlowReplace |= SERIAL_XOFF_CONTINUE;

        }

        if (lpDCB->fAbortOnError) {

            HandFlow.ControlHandShake |= SERIAL_ERROR_ABORT;

        }

        //
        // For win95 compatiblity, if we are setting with
        // xxx_control_XXXXXXX then set the modem status line
        // to that state.
        //

        if (lpDCB->fRtsControl == RTS_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETRTS
                );

        } else if (lpDCB->fRtsControl == RTS_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRRTS
                );

        }
        if (lpDCB->fDtrControl == DTR_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETDTR
                );

        } else if (lpDCB->fDtrControl == DTR_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRDTR
                );

        }




        HandFlow.XonLimit = lpDCB->XonLim;
        HandFlow.XoffLimit = lpDCB->XoffLim;


        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_LINE_CONTROL,
                     &LineControl,
                     sizeof(LineControl),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_CHARS,
                     &Chars,
                     sizeof(Chars),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_HANDFLOW,
                     &HandFlow,
                     sizeof(HandFlow),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }
        CloseHandle(SyncEvent);
        return TRUE;

    }

    return FALSE;

}

BOOL
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function establishes the timeout characteristics for all
    read and write operations on the handle specified by hFile.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpCommTimeouts - Points to a structure containing timeout parameters.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_TIMEOUTS To;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    To.ReadIntervalTimeout = lpCommTimeouts->ReadIntervalTimeout;
    To.ReadTotalTimeoutMultiplier = lpCommTimeouts->ReadTotalTimeoutMultiplier;
    To.ReadTotalTimeoutConstant = lpCommTimeouts->ReadTotalTimeoutConstant;
    To.WriteTotalTimeoutMultiplier = lpCommTimeouts->WriteTotalTimeoutMultiplier;
    To.WriteTotalTimeoutConstant = lpCommTimeouts->WriteTotalTimeoutConstant;


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_TIMEOUTS,
                     &To,
                     sizeof(To),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
TransmitCommChar(
    HANDLE hFile,
    char cChar
    )

/*++

Routine Description:

    The function marks the character specified by the cChar parameter
    for immediate transmission, by placing it at the head of the transmit
    queue.

Arguments:

    hFile - Specifies the communication device to send the character.
            The CreateFile function returns this value.

    cChar - Specifies the character to be placed in the recieve queue.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_IMMEDIATE_CHAR,
                     &cChar,
                     sizeof(UCHAR),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
WaitCommEvent(
    HANDLE hFile,
    LPDWORD lpEvtMask,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    This function will wait until any of the events occur that were
    provided as the nEvtMask parameter to SetcommMask.  If while waiting
    the event mask is changed (via another call to SetCommMask), the
    function will return immediately.  The function will fill the EvtMask
    pointed to by the lpEvtMask parameter with the reasons that the
    wait was satisfied.

Arguments:

    hFile - Specifies the communication device to be waited on.
            The CreateFile function returns this value.

    lpEvtMask - Points to a mask that will receive the reason that
                the wait was satisfied.

    lpOverLapped - An optional overlapped handle.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;

    if (ARGUMENT_PRESENT(lpOverlapped)) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtDeviceIoControlFile(
                     hFile,
                     lpOverlapped->hEvent,
                     NULL,
                     (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                     (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                     IOCTL_SERIAL_WAIT_ON_MASK,
                     NULL,
                     0,
                     lpEvtMask,
                     sizeof(ULONG)
                     );

        if (!NT_ERROR(Status) && (Status != STATUS_PENDING)) {

            return TRUE;

        } else {

            BaseSetLastNTError(Status);
            return FALSE;

        }

    } else {

        IO_STATUS_BLOCK Iosb;
        HANDLE Event;

        if (!(Event = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

            return FALSE;

        } else {

            Status = NtDeviceIoControlFile(
                         hFile,
                         Event,
                         NULL,
                         NULL,
                         &Iosb,
                         IOCTL_SERIAL_WAIT_ON_MASK,
                         NULL,
                         0,
                         lpEvtMask,
                         sizeof(ULONG)
                         );

            if ( Status == STATUS_PENDING) {

                //
                // Operation must complete before return &
                // IoStatusBlock destroyed

                Status = NtWaitForSingleObject( Event, FALSE, NULL );
                if ( NT_SUCCESS(Status)) {

                    Status = Iosb.Status;

                }

            }

            CloseHandle(Event);

            if (NT_ERROR(Status)) {

                BaseSetLastNTError(Status);
                return FALSE;

            }

            return TRUE;

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bnd.c ===
//
// Program to test boundry conditions of APIs which take a string buffer.
// Conditions tested are strlen-1, strlen, and strlen+1
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <wchar.h>
//
// Define these to match your machine.  If these are not set properly, its
// very likely the tests will pass when they didn't deserve to. 
//
                                      // List of all logical drives

#define LOGICAL_DRIVES "a:\\\0c:\\\0"
#define LOGICAL_DRIVES_W L"a:\\\0c:\\\0"
#define LEN_LOGICAL_DRIVES 8
#define SYSTEM_DIR  "c:\\winnt\\system32"  // Where is system dir
#define SYSTEM_DIR_W  L"c:\\winnt\\system32"  // Where is system dir
#define WINDOWS_DIR "c:\\winnt"          // Where is windows dir
#define WINDOWS_DIR_W L"c:\\winnt"          // Where is windows dir
#define TEMP_DIRA   "c:\\tmp"         // For GetTempPath, env var tmp or temp
#define TEMP_DIR_WA   L"c:\\tmp"         // For GetTempPath, env var tmp or temp
#define TEMP_DIRB   "c:\\tmp\\"         // For GetTempPath, env var tmp or temp
#define TEMP_DIR_WB   L"c:\\tmp\\"         // For GetTempPath, env var tmp or temp
#define TEMP_DIRC   "c:\\"         // For GetTempPath, env var tmp or temp
#define TEMP_DIR_WC   L"c:\\"         // For GetTempPath, env var tmp or temp
#define VOLUME_NAME "MARKLTST433"        // Name of volume where c: partition is
#define VOLUME_NAME_W L"MARKLTST433"        // Name of volume where c: partition is
#define FILE_SYSTEM_NAME "FAT"        // Name of file system on c: partition
#define FILE_SYSTEM_NAME_W L"FAT"        // Name of file system on c: partition
                                      // { FAT, HPFS, NTFS }

//
// Global vars, constants and prototypes
//

#define SIGNATURE 0xf
#define SIGNATURE_W 0xaaff
#define SIZE_BUFF 128

void init_buff();
void init_buffw();
void check(DWORD retcode, DWORD size_passed, int expected_ret,BOOL shouldxfer);
void checkw(DWORD retcode, DWORD size_passed, int expected_ret,BOOL shouldxfer);

char buff[SIZE_BUFF], *cur_test;
wchar_t buffw[SIZE_BUFF];
LPSTR exp_val;
LPWSTR exp_valw;

//
// main
//

void _cdecl main(void)
{
    int   exp_len;
    int   wexp_len;
    LPSTR lpJunk;
    LPWSTR lpwJunk;
    BOOL  bRet;

    //
    // GetSystemDirectory
    //

    cur_test = "GetSystemDirectory";
    exp_len  = strlen(SYSTEM_DIR);
    exp_val = SYSTEM_DIR;
    exp_valw = SYSTEM_DIR_W;

    printf("\nGetSystemDirectory: Expected string is <%s>\n", SYSTEM_DIR);

    init_buff();
    check(GetSystemDirectory(buff, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetSystemDirectory(buff, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetSystemDirectory(buff, exp_len+1), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetSystemDirectoryW(buffw, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetSystemDirectoryW(buffw, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetSystemDirectoryW(buffw, exp_len+1), exp_len+1, exp_len,TRUE);

    //
    // GetWindowsDirectory
    //

    cur_test = "GetWindowsDirectory";
    exp_len  = strlen(WINDOWS_DIR);
    exp_val = WINDOWS_DIR;
    exp_valw = WINDOWS_DIR_W;

    printf("\nGetWindowsDirectory: Expected string is <%s>\n", WINDOWS_DIR);

    init_buff();
    check(GetWindowsDirectory(buff, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetWindowsDirectory(buff, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetWindowsDirectory(buff, exp_len+1), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetWindowsDirectoryW(buffw, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetWindowsDirectoryW(buffw, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetWindowsDirectoryW(buffw, exp_len+1), exp_len+1, exp_len,TRUE);

    //
    // GetLogicalDriveStrings 
    //

    cur_test = "GetLogicalDriveStrings";
    exp_len  = LEN_LOGICAL_DRIVES;
    exp_val = LOGICAL_DRIVES;
    exp_valw = LOGICAL_DRIVES_W;

    printf("\nGetLogicalDriveStrings: Expected string is <%s>\n",
           LOGICAL_DRIVES);

    init_buff();
    check(GetLogicalDriveStrings(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetLogicalDriveStrings(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetLogicalDriveStrings(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetLogicalDriveStringsW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetLogicalDriveStringsW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetLogicalDriveStringsW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    //
    // GetVolumeInformation: Be sure that does not stomp on VolumeName buffer,
    // and be sure it returns FALSE when the volume name would not fit into
    // the provided buffer
    //

    cur_test = "GetVolumeInformation 1";
    exp_len  = strlen(VOLUME_NAME);
    exp_val = VOLUME_NAME;
    exp_valw = VOLUME_NAME_W;

    printf("\nGetVolumeInformation 1: Expected string is <%s>\n", VOLUME_NAME);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                buff,      // volume name buffer
                                exp_len-1,
                                NULL, NULL, NULL, NULL, 0);

    check(bRet, exp_len-1, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                buff,      // volume name buffer
                                exp_len,
                                NULL, NULL, NULL, NULL, 0);

    check(bRet, exp_len, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                buff,      // volume name buffer
                                exp_len+1,
                                NULL, NULL, NULL, NULL, 0);
    check(bRet, exp_len+1, TRUE,TRUE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                buffw,      // volume name buffer
                                exp_len-1,
                                NULL, NULL, NULL, NULL, 0);

    checkw(bRet, exp_len-1, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                buffw,      // volume name buffer
                                exp_len,
                                NULL, NULL, NULL, NULL, 0);

    checkw(bRet, exp_len, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                buffw,      // volume name buffer
                                exp_len+1,
                                NULL, NULL, NULL, NULL, 0);
    checkw(bRet, exp_len+1, TRUE,TRUE);

    //
    // GetVolumeInformation: Be sure that does not stomp on the File system
    // name buffer this time, and be sure returns FALSE when not enough room.
    //

    cur_test = "GetVolumeInformation 2";
    exp_len  = strlen(FILE_SYSTEM_NAME);
    exp_val = FILE_SYSTEM_NAME;
    exp_valw = FILE_SYSTEM_NAME_W;

    printf("\nGetVolumeInformation 2: Expected string is <%s>\n",
            FILE_SYSTEM_NAME);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buff,      // file system name buffer, ex: FAT
                                exp_len-1);

    check(bRet, exp_len-1, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buff,      // file system name buffer, ex: FAT
                                exp_len);

    check(bRet, exp_len, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buff,      // file system name buffer, ex: FAT
                                exp_len+1);

    check(bRet, exp_len+1, TRUE,TRUE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buffw,      // file system name buffer, ex: FAT
                                exp_len-1);

    checkw(bRet, exp_len-1, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buffw,      // file system name buffer, ex: FAT
                                exp_len);

    checkw(bRet, exp_len, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buffw,      // file system name buffer, ex: FAT
                                exp_len+1);

    checkw(bRet, exp_len+1, TRUE,TRUE);

    //
    // GetEnvironmentVariable: set variable JUNK=junk and check
    //

    cur_test = "GetEnvironmentVariable";
    exp_val = "junk";
    exp_valw = L"junk";

    printf("\nGetEnvironmentVariable: Expected string is <%s>\n", "junk");

    if ( ! SetEnvironmentVariable("JUNK", "junk") ) {
        printf("Error setting environment variable\n");
        exit(1);
    }

    init_buff();
    check(GetEnvironmentVariable("JUNK", buff, 3), 3, 5,FALSE);
    init_buff();
    check(GetEnvironmentVariable("JUNK", buff, 4), 4, 5,FALSE);
    init_buff();
    check(GetEnvironmentVariable("JUNK", buff, 5), 5, 4,TRUE);

    init_buffw();
    checkw(GetEnvironmentVariableW(L"JUNK", buffw, 3), 3, 5,FALSE);
    init_buffw();
    checkw(GetEnvironmentVariableW(L"JUNK", buffw, 4), 4, 5,FALSE);
    init_buffw();
    checkw(GetEnvironmentVariableW(L"JUNK", buffw, 5), 5, 4,TRUE);


    //
    // GetCurrentDirectory: set to c:\ and check
    //

    cur_test = "GetCurrentDirectory";
    exp_val = "c:\\winnt";
    exp_valw = L"c:\\winnt";
    exp_len = strlen(exp_val);

    printf("\nGetCurrentDirectory: Expected string is <%s>\n", "c:\\winnt");

    if ( ! SetCurrentDirectory("c:\\winnt") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    init_buff();
    check(GetCurrentDirectory(exp_len-1, buff), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len, buff), exp_len, exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len-1, buffw), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len, buffw), exp_len, exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    cur_test = "GetCurrentDirectory";
    exp_val = "c:\\";
    exp_valw = L"c:\\";
    exp_len = strlen(exp_val);

    printf("\nGetCurrentDirectory: Expected string is <%s>\n", "c:\\");

    if ( ! SetCurrentDirectory("c:\\") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    init_buff();
    check(GetCurrentDirectory(exp_len-1, buff), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len, buff), exp_len, exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len-1, buffw), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len, buffw), exp_len, exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);


    //
    // GetFullPathName: this assumes that the current directory is c:\, which
    // was set earlier as part of the GetCurrentDirectory test.  c:\junk.txt
    // is a total of 11 chars.
    //

    cur_test = "GetFullPathName";
    exp_val = "c:\\junk.txt";
    exp_valw = L"c:\\junk.txt";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName(exp_val, exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(exp_val, exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(exp_val, exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(exp_valw, exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(exp_valw, exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(exp_valw, exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    cur_test = "GetFullPathName";
    exp_val = "\\\\.\\lpt1";
    exp_valw = L"\\\\.\\lpt1";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName("lpt1", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("lpt1", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("lpt1", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(L"lpt1", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"lpt1", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"lpt1", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    if ( ! SetCurrentDirectory("c:\\winnt\\dump") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    cur_test = "GetFullPathName";
    exp_val = "c:\\winnt\\dump";
    exp_valw = L"c:\\winnt\\dump";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName(".", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    if ( ! SetCurrentDirectory("c:\\winnt") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    cur_test = "GetFullPathName";
    exp_val = "c:\\winnt\\dump";
    exp_valw = L"c:\\winnt\\dump";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName("c:dump", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("c:dump", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("c:dump", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);
    init_buffw();
    checkw(GetFullPathNameW(L"c:dump", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"c:dump", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"c:dump", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    if ( ! SetCurrentDirectory("c:\\") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    cur_test = "GetFullPathName";
    exp_val = "c:\\";
    exp_valw = L"c:\\";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName(".", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);


    //
    // GetTempPath
    //

    cur_test = "GetTempPath";
    exp_len  = strlen(TEMP_DIRB);
    exp_val = TEMP_DIRB;
    exp_valw = TEMP_DIR_WB;
    if ( ! SetEnvironmentVariable("TMP", TEMP_DIRA)) {
        printf("Error setting tmp environment variable\n");
        exit(1);
    }

    printf("\nGetTempPath: Expected string is <%s>\n", TEMP_DIRB);

    init_buff();
    check(GetTempPath(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetTempPathW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    cur_test = "GetTempPath";
    exp_len  = strlen(TEMP_DIRB);
    exp_val = TEMP_DIRB;
    exp_valw = TEMP_DIR_WB;
    if ( ! SetEnvironmentVariable("TMP", TEMP_DIRB)) {
        printf("Error setting tmp environment variable\n");
        exit(1);
    }

    printf("\nGetTempPath: Expected string is <%s>\n", TEMP_DIRB);

    init_buff();
    check(GetTempPath(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetTempPathW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    cur_test = "GetTempPath";
    exp_len  = strlen(TEMP_DIRC);
    exp_val = TEMP_DIRC;
    exp_valw = TEMP_DIR_WC;
    if ( ! SetEnvironmentVariable("TMP", TEMP_DIRC)) {
        printf("Error setting tmp environment variable\n");
        exit(1);
    }

    printf("\nGetTempPath: Expected string is <%s>\n", TEMP_DIRC);

    init_buff();
    check(GetTempPath(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetTempPathW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);


    cur_test = "SearchPath";
    exp_len  = strlen("c:\\winnt\\system32\\kernel32.dll");
    exp_val = "c:\\winnt\\system32\\kernel32.dll";
    exp_valw = L"c:\\winnt\\system32\\kernel32.dll";

    printf("\nSearchPath: Expected string is <%s>\n", exp_val);

    init_buff();
    check(SearchPath(NULL,"kernel32",".dll",exp_len-1,buff,&lpJunk),exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(SearchPath(NULL,"kernel32",".dll",exp_len,buff,&lpJunk),exp_len,exp_len+1,FALSE);
    init_buff();
    check(SearchPath(NULL,"kernel32",".dll",exp_len+1,buff,&lpJunk),exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(SearchPathW(NULL,L"kernel32",L".dll",exp_len-1,buffw,&lpwJunk),exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(SearchPathW(NULL,L"kernel32",L".dll",exp_len,buffw,&lpwJunk),exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(SearchPathW(NULL,L"kernel32",L".dll",exp_len+1,buffw,&lpwJunk),exp_len+1,exp_len,TRUE);

    cur_test = "GetModuleFileName";
    exp_len  = strlen("c:\\winnt\\system32\\bnd.exe");
    exp_val = "c:\\winnt\\system32\\bnd.exe";
    exp_valw = L"c:\\winnt\\system32\\bnd.exe";

    printf("\nGetModuleFileName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetModuleFileName(NULL,buff,exp_len-1),exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetModuleFileName(NULL,buff,exp_len),exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetModuleFileName(NULL,buff,exp_len+1),exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetModuleFileNameW(NULL,buffw,exp_len-1),exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetModuleFileNameW(NULL,buffw,exp_len),exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetModuleFileNameW(NULL,buffw,exp_len+1),exp_len+1,exp_len,TRUE);


}

//
// Function to init the global buffer to the SIGNATURE
//

void init_buff()
{
    int i;

    for ( i=0; i<SIZE_BUFF; i++ )
        buff[i] = SIGNATURE;

    buff[SIZE_BUFF-1] = '\0'; // to ensure its null-terminated somewhere
                              // (for debugging)
}

void init_buffw()
{
    int i;

    for ( i=0; i<SIZE_BUFF; i++ )
        buffw[i] = SIGNATURE_W;

    buffw[SIZE_BUFF-1] = 0;

}

//
// Function to check whether the API wrote past the end of the buffer, and
// whether it returned what was expected
//
// It assumes that the global vars cur_test is set and buff was used
//

void check(DWORD retcode, DWORD size_passed, int expected_ret, BOOL shouldxfer)
{

    int i;

    if ( buff[size_passed] != SIGNATURE ) {
        printf("\nFAILURE: %s wrote past end of buffer, when passed %d\n",
                cur_test, size_passed);
        return;
    }

    if ( retcode != (DWORD)expected_ret ) {
        printf("\nFAILURE: %s returned %d, expected %d, when passed %d\n",
               cur_test, retcode, expected_ret, size_passed);
        return;
    }

    if ( shouldxfer ) {
        for (i=0;i<expected_ret;i++){
            if ( toupper(buff[i]) != toupper(exp_val[i]) ) {
                printf("\nFAILURE: %s mismatch at %d",cur_test, i);
                return;
            }
        }
    }
    printf("\nPASSED:  %s when passed %d\n", cur_test, size_passed);
}


void checkw(DWORD retcode, DWORD size_passed, int expected_ret,BOOL shouldxfer)
{
    int i;
    if ( buffw[size_passed] != SIGNATURE_W ) {
        printf("\nFAILURE: %s wrote past end of buffer, when passed %d\n",
                cur_test, size_passed);
        return;
    }

    if ( retcode != (DWORD)expected_ret ) {
        printf("\nFAILURE: %s returned %d, expected %d, when passed %d\n",
               cur_test, retcode, expected_ret, size_passed);
        return;
    }

    if (shouldxfer) {
        for (i=0;i<expected_ret;i++){
            if ( towupper(buffw[i]) != towupper(exp_valw[i]) ) {
                printf("\nFAILURE: %s mismatch at %d",cur_test, i);
                return;
            }
        }
    }
    printf("\nPASSED:  %s when passed %d\n", cur_test, size_passed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\compstrs.c ===
#include <stdio.h>
#include <windows.h>
#include <winioctl.h>

int main(int argc, char *argv[ ])
{

    BOOL b;
    DWORD FsFlags;
    LPSTR lp;
    HANDLE hMod;
    UINT w;
    CHAR FileName[MAX_PATH];
    HANDLE hFile;
    DWORD Nbytes;
    DWORD FileSize;
    WORD State;
    DWORD Length;
    DWORD wrap;


    b = GetVolumeInformation(NULL,NULL,0,NULL,NULL,&FsFlags,NULL,0);

    if ( !b ) {
        printf("compstrs: Failure getting volumeinformation %d\n",GetLastError());
        return 0;
        }

    if ( !(FsFlags & FS_FILE_COMPRESSION) ) {
        printf("compstrs: File system does not support per-file compression %x\n",FsFlags);
        return 0;
        }

    //
    // Get a temp file
    //

    w = GetTempFileName(".","cstr",0,FileName);
    if ( !w ) {
        printf("compstrs: unable to get temp file name\n");
        return 0;
        }

    //
    // Create the tempfile
    //

    hFile = CreateFile(
                FileName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf("compstrs: failure creating %s %d\n",FileName,GetLastError());
        return 0;
        }

    //
    // Write the file that we want to compress. It is a copy of kernel32 and ntdll
    //

    hMod = GetModuleHandle("kernel32");
    if ( !hMod ) {
        printf("compstrs: failure getting handle to kernel32.dll\n");
        CloseHandle(hFile);
        DeleteFile(FileName);
        return 0;
        }

    lp = (LPSTR)hMod;

    b = TRUE;
    FileSize = 0;
    while(b) {
        b = WriteFile(hFile,lp,512, &Nbytes, NULL);
        if ( b ) {
            FileSize += Nbytes;
            lp += Nbytes;
            }
        }

    hMod = GetModuleHandle("ntdll");
    if ( !hMod ) {
        printf("compstrs: failure getting handle to ntdll\n");
        CloseHandle(hFile);
        DeleteFile(FileName);
        return 0;
        }

    lp = (LPSTR)hMod;

    b = TRUE;
    while(b) {
        b = WriteFile(hFile,lp,512, &Nbytes, NULL);
        if ( b ) {
            FileSize += Nbytes;
            lp += Nbytes;
            }
        }

    wrap = 0;
    while(1) {

        //
        // compress and de-compress this file forever
        //

        State = 1;

        b = DeviceIoControl(
                hFile,
                FSCTL_SET_COMPRESSION,
                &State,
                sizeof(WORD),
                NULL,
                0,
                &Length,
                NULL
                );
        if ( !b ) {
            printf("compstrs: compress failed %d\n",GetLastError());
            wrap = 0;
            }
        else {
            FlushFileBuffers(hFile);
            printf("C");
            wrap++;
            }

        Sleep(500);

        //
        // Decompress
        //

        State = 0;

        b = DeviceIoControl(
                hFile,
                FSCTL_SET_COMPRESSION,
                &State,
                sizeof(WORD),
                NULL,
                0,
                &Length,
                NULL
                );
        if ( !b ) {
            printf("compstrs: uncompress failed %d\n",GetLastError());
            wrap = 0;
            }
        else {
            FlushFileBuffers(hFile);
            printf("U");
            wrap++;
            }

        if ( wrap > 50 ) {
            printf("\n");
            wrap = 0;
            }
    }

    CloseHandle(hFile);
    DeleteFile(FileName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\blddcb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blddcb.c

Abstract:

    This module implements Win32 comm api buildcommdcb

Author:

    Anthony V. Ercolano (tonye) 10-March-1992

    Actually this code was generously donated by
    ramonsa.  It is basically the code used for
    the mode command.

Revision History:

--*/

#include <basedll.h>

typedef struct _PARSE_CONTEXT {
    PSTR CharIndex;
    PSTR AdvanceIndex;
    PSTR MatchBegin;
    PSTR MatchEnd;
    } PARSE_CONTEXT,*PPARSE_CONTEXT;

static
BOOL
BuildDcb (
    LPCSTR L,
    LPDCB Dcb,
    LPCOMMTIMEOUTS To
    );

static
BOOL
Match(
    PPARSE_CONTEXT C,
    PSTR Pattern
    );

static
VOID
Advance(
    PPARSE_CONTEXT C
    );

static
DWORD
GetNumber(
    PPARSE_CONTEXT C
    );

static
BOOL
ConvertBaudRate (
    DWORD BaudIn,
    PDWORD BaudRate
    );

static
BOOL
ConvertDataBits (
    DWORD DataBitsIn,
    PBYTE DataBitsOut
    );

static
BOOL
ConvertStopBits (
    DWORD StopBitsIn,
    PBYTE StopBits
    );

static
BOOL
ConvertParity (
    CHAR ParityIn,
    PBYTE Parity
    );

static
BOOL
ConvertDtrControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE DtrControl
    );

static
BOOL
ConvertRtsControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE RtsControl
    );

static
VOID
IgnoreDeviceName(
    IN PPARSE_CONTEXT C
    );

static
NTSTATUS
DeviceNameCompare(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );


BOOL
BuildCommDCBAndTimeoutsW(
    LPCWSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.
    It also sets the timeouts if specified.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

    lpCommTimeouts - It "TO" included, it will set the timeouts.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL AnsiBool;

    RtlInitUnicodeString(
        &Unicode,
        lpDef
        );

    Status = RtlUnicodeStringToAnsiString(
                 &Ansi,
                 &Unicode,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError(Status);
        return FALSE;

    }

    AnsiBool = BuildCommDCBAndTimeoutsA(
                   (LPCSTR)Ansi.Buffer,
                   lpDCB,
                   lpCommTimeouts
                   );

    RtlFreeAnsiString(&Ansi);
    return AnsiBool;

}

BOOL
BuildCommDCBAndTimeoutsA(
    LPCSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.
    It can also set the timeout value.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

    lpCommTimeouts - If TO included in string then timeouts are also set.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    if (!BuildDcb(
             lpDef,
             lpDCB,
             lpCommTimeouts
             )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    } else {

        return TRUE;

    }

}

BOOL
BuildCommDCBW(
    LPCWSTR lpDef,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL AnsiBool;

    RtlInitUnicodeString(
        &Unicode,
        lpDef
        );

    Status = RtlUnicodeStringToAnsiString(
                 &Ansi,
                 &Unicode,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError(Status);
        return FALSE;

    }

    AnsiBool = BuildCommDCBA(
                   (LPCSTR)Ansi.Buffer,
                   lpDCB
                   );

    RtlFreeAnsiString(&Ansi);
    return AnsiBool;

}

BOOL
BuildCommDCBA(
    LPCSTR lpDef,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    COMMTIMEOUTS JunkTimeouts;

    if (!BuildDcb(
             lpDef,
             lpDCB,
             &JunkTimeouts
             )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    } else {

        return TRUE;

    }

}

static
BOOL
BuildDcb (
    LPCSTR L,
    LPDCB Dcb,
    LPCOMMTIMEOUTS To
    )

/*++

Routine Description:


Arguments:

    L - A pointer to the string to convert to a DCB.
    Dcb - The dcb to fill in.

Return Value:

    FALSE if the string has some error, TRUE otherwise.

--*/

{

    BOOL        SetBaud         =   FALSE;
    BOOL        SetDataBits     =   FALSE;
    BOOL        SetStopBits     =   FALSE;
    BOOL        SetParity       =   FALSE;
    BOOL        SetRetry        =   FALSE;
    BOOL        SetTimeOut      =   FALSE;
    BOOL        SetXon          =   FALSE;
    BOOL        SetOdsr         =   FALSE;
    BOOL        SetIdsr         =   FALSE;
    BOOL        SetOcts         =   FALSE;
    BOOL        SetDtrControl   =   FALSE;
    BOOL        SetRtsControl   =   FALSE;

    DWORD       Baud;
    BYTE        DataBits;
    BYTE        StopBits;
    BYTE        Parity;
    BOOL        TimeOut;
    BOOL        Xon;
    BOOL        Odsr;
    BOOL        Idsr;
    BOOL        Octs;
    BYTE        DtrControl;
    BYTE        RtsControl;
    PARSE_CONTEXT C = {0};

    C.CharIndex = C.AdvanceIndex = (PSTR)L;

    //
    // This following call will query all of the *current* serial
    // provider names.  If it finds that the argurment string
    // contains the name (with an optional :) it will simply
    // advance past it.
    //

    IgnoreDeviceName(&C);

    if ( Match(&C, "#" ) ) {

        //
        //   Old syntax, where parameter are positional and comma-delimited.
        //
        //   We will use the following automata for parsing the input
        //   (eoi = end of input):
        //
        //           eoi
        //    [Baud]------------->[End]
        //      |            ^
        //      |,           |eoi
        //      v            |
        //     [a]-----------+
        //      |            ^
        //      | @          |eoi
        //      +-->[Parity]-+
        //      |     |      ^
        //      |     |,     |
        //      |<----+      |
        //      |            |
        //      |,           |eoi
        //      |            |
        //      v            |
        //     [b]-----------+
        //      |            ^
        //      | #          |eoi
        //      +-->[Data]---+
        //      |     |      ^
        //      |     |,     |
        //      |<----+      |
        //      |            |
        //      |,           |eoi
        //      v            |
        //     [c]-----------+
        //      |            ^
        //      | #          |eoi
        //      +-->[Stop]---+
        //

        //
        // Assume xon=off
        //

        SetXon      = TRUE;
        SetOdsr     = TRUE;
        SetOcts     = TRUE;
        SetDtrControl = TRUE;
        SetRtsControl = TRUE;
        Xon         = FALSE;
        Odsr        = FALSE;
        Octs        = FALSE;
        DtrControl = DTR_CONTROL_ENABLE;
        RtsControl = RTS_CONTROL_ENABLE;

        if (!ConvertBaudRate( GetNumber(&C), &Baud )) {
            return FALSE;
        }
        SetBaud = TRUE;
        Advance(&C);

        //
        //    A:
        //
        if ( !Match(&C, "," ) ) {
            goto Eoi;
        }
        Advance(&C);

        if ( !Match(&C, "," ) && Match(&C, "@" ) ) {

            //
            //    Parity
            //
            if (!ConvertParity( *C.MatchBegin,&Parity )) {
                return FALSE;
            }
            SetParity = TRUE;
            Advance(&C);
        }

        //
        //    B:
        //
        if ( !Match(&C, "," )) {
            goto Eoi;
        }
        Advance(&C);

        if ( Match(&C, "#" )) {

            //
            //    Data bits
            //
            if (!ConvertDataBits( GetNumber(&C),&DataBits )) {
                return FALSE;
            }
            SetDataBits = TRUE;
            Advance(&C);
        }

        //
        //    C:
        //
        if ( !Match(&C, "," )) {
            goto Eoi;
        }
        Advance(&C);

        if ( Match(&C, "1.5" ) ) {
            StopBits = ONE5STOPBITS;
            SetStopBits = TRUE;
            Advance(&C);
        } else if ( Match(&C, "#" ) ) {
            if (!ConvertStopBits( GetNumber(&C),&StopBits)) {
                return FALSE;
            }
            SetStopBits = TRUE;
            Advance(&C);
        }

        if ( !Match(&C, "," )) {
            goto Eoi;
        }

        Advance(&C);

        if ( Match(&C, "x" ) ) {

            //
            //  XON=ON
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = TRUE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_CONTROL_ENABLE;
            RtsControl = RTS_CONTROL_ENABLE;
            Advance(&C);

        } else if ( Match(&C, "p" ) ) {

            //
            //  Permanent retry - Hardware handshaking
            //

            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = TRUE;
            Octs        = TRUE;
            DtrControl = DTR_CONTROL_HANDSHAKE;
            RtsControl = RTS_CONTROL_HANDSHAKE;
            Advance(&C);

        } else {

            //
            //  XON=OFF
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_CONTROL_ENABLE;
            RtsControl = RTS_CONTROL_ENABLE;
        }

Eoi:
        if ( *C.CharIndex != '\0' ) {

            //
            //    Error
            //
            return FALSE;

        }

    } else {

        //
        // New Form
        //

        while ( *C.CharIndex != '\0' ) {

            if ( Match(&C, "BAUD=#" ) ) {
                //
                //  BAUD=
                //
                if ( !ConvertBaudRate(GetNumber(&C), &Baud ) ) {
                    return FALSE;
                }
                SetBaud     = TRUE;
                Advance(&C);

            } else if ( Match(&C, "PARITY=@"   ) ) {
                //
                //  PARITY=
                //
                if ( !ConvertParity( *C.MatchBegin, &Parity ) ) {
                    return FALSE;
                }
                SetParity   = TRUE;
                Advance(&C);

            } else if ( Match(&C, "DATA=#" ) ) {
                //
                //  DATA=
                //
                if ( !ConvertDataBits(GetNumber(&C), &DataBits ) ) {
                    return FALSE;
                }
                SetDataBits = TRUE;
                Advance(&C);

            } else if ( Match(&C, "STOP=1.5" ) ) {
                //
                //  STOP=1.5
                //
                StopBits    =  ONE5STOPBITS;
                SetStopBits = TRUE;
                Advance(&C);

            } else if ( Match(&C, "STOP=#" ) ) {
                //
                //  STOP=
                //
                if ( !ConvertStopBits(GetNumber(&C), &StopBits ) ) {
                    return FALSE;
                }
                SetStopBits = TRUE;
                Advance(&C);

            } else if ( Match(&C, "TO=ON" ) ) {
                //
                //  TO=ON
                //
                SetTimeOut  =   TRUE;
                TimeOut     =   TRUE;
                Advance(&C);

            } else if ( Match(&C, "TO=OFF" ) ) {
                //
                //  TO=ON
                //
                SetTimeOut  =   TRUE;
                TimeOut     =   FALSE;
                Advance(&C);

            } else if ( Match(&C, "XON=ON" ) ) {
                //
                //  XON=ON
                //
                SetXon      = TRUE;
                Xon         = TRUE;
                Advance(&C);

            } else if ( Match(&C, "XON=OFF" ) ) {
                //
                //  XON=OFF
                //
                SetXon      = TRUE;
                Xon         = FALSE;
                Advance(&C);

            } else if ( Match(&C, "ODSR=ON" ) ) {
                //
                //  ODSR=ON
                //
                SetOdsr     = TRUE;
                Odsr        = TRUE;
                Advance(&C);

            } else if ( Match(&C, "ODSR=OFF" ) ) {
                //
                //  ODSR=OFF
                //
                SetOdsr     = TRUE;
                Odsr        = FALSE;
                Advance(&C);

            } else if ( Match(&C, "IDSR=ON" ) ) {
                //
                //  IDSR=ON
                //
                SetIdsr = TRUE;
                Idsr    = TRUE;
                Advance(&C);

            } else if ( Match(&C, "IDSR=OFF" ) ) {
                //
                //  IDSR=OFF
                //
                SetIdsr = TRUE;
                Idsr    = FALSE;
                Advance(&C);

            } else if ( Match(&C, "OCTS=ON" ) ) {
                //
                //  OCS=ON
                //
                SetOcts     = TRUE;
                Octs        = TRUE;
                Advance(&C);

            } else if ( Match(&C, "OCTS=OFF" ) ) {
                //
                //  OCS=OFF
                //
                SetOcts     = TRUE;
                Octs        = FALSE;
                Advance(&C);

            } else if ( Match(&C, "DTR=*"   ) ) {
                //
                //  DTR=
                //
                if ( !ConvertDtrControl(C.MatchBegin, C.MatchEnd, &DtrControl ) ) {
                    return FALSE;
                }
                SetDtrControl   = TRUE;
                Advance(&C);

            } else if ( Match(&C, "RTS=*"   ) ) {
                //
                //  RTS=
                //
                if ( !ConvertRtsControl(C.MatchBegin, C.MatchEnd, &RtsControl ) ) {
                    return FALSE;
                }
                SetRtsControl   = TRUE;
                Advance(&C);

            } else {

                return FALSE;
            }
        }

    }

    if ( SetBaud ) {
        Dcb->BaudRate = Baud;
    }

    if ( SetDataBits ) {
        Dcb->ByteSize = DataBits;
    }

    if ( SetStopBits ) {
        Dcb->StopBits = StopBits;
    } else if ( SetBaud && (Baud == 110) ) {
        Dcb->StopBits = TWOSTOPBITS;
    } else {
        Dcb->StopBits = ONESTOPBIT;
    }

    if ( SetParity ) {
        Dcb->Parity = Parity;
    }

    if ( SetXon ) {
        if ( Xon ) {
            Dcb->fInX   = TRUE;
            Dcb->fOutX  = TRUE;
        } else {
            Dcb->fInX   = FALSE;
            Dcb->fOutX  = FALSE;
        }
    }

    if ( SetOcts ) {

        if ( Octs ) {
            Dcb->fOutxCtsFlow = TRUE;
        } else {
            Dcb->fOutxCtsFlow = FALSE;
        }
    }


    if ( SetOdsr ) {
        if ( Odsr ) {
            Dcb->fOutxDsrFlow = TRUE;
        } else {
            Dcb->fOutxDsrFlow = FALSE;
        }
    }

    if ( SetIdsr ) {
        if ( Idsr ) {
            Dcb->fDsrSensitivity = TRUE;
        } else {
            Dcb->fDsrSensitivity = FALSE;
        }
    }

    if ( SetDtrControl ) {
        Dcb->fDtrControl = DtrControl;
    }

    if ( SetRtsControl ) {
        Dcb->fRtsControl = RtsControl;
    }

    if ( SetTimeOut ) {
        if (TimeOut) {
            To->ReadIntervalTimeout = 0;
            To->ReadTotalTimeoutMultiplier = 0;
            To->ReadTotalTimeoutConstant = 0;
            To->WriteTotalTimeoutMultiplier = 0;
            To->WriteTotalTimeoutConstant = 60000;
        } else {
            To->ReadIntervalTimeout = 0;
            To->ReadTotalTimeoutMultiplier = 0;
            To->ReadTotalTimeoutConstant = 0;
            To->WriteTotalTimeoutMultiplier = 0;
            To->WriteTotalTimeoutConstant = 0;
        }
    }



    return TRUE;
}

static
BOOL
Match(
    PPARSE_CONTEXT C,
    PSTR Pattern
    )

/*++

Routine Description:

    This function matches a pattern against whatever
    is in the command line at the current position.

    Note that this does not advance our current position
    within the command line.

    If the pattern has a magic character, then the
    variables C->MatchBegin and C->MatchEnd delimit the
    substring of the command line that matched that
    magic character.

Arguments:

    C - The parse context.
    Pattern - Supplies pointer to the pattern to match

Return Value:

    BOOLEAN - TRUE if the pattern matched, FALSE otherwise

Notes:

--*/

{

    PSTR    CmdIndex;       //  Index within command line
    PSTR    PatternIndex;   //  Index within pattern
    CHAR    PatternChar;    //  Character in pattern
    CHAR    CmdChar;        //  Character in command line;

    CmdIndex        = C->CharIndex;
    PatternIndex    = Pattern;

    while ( (PatternChar = *PatternIndex) != '\0' ) {

        switch ( PatternChar ) {

        case '#':

            //
            //    Match a number
            //
            C->MatchBegin = CmdIndex;
            C->MatchEnd   = C->MatchBegin;

            //
            //    Get all consecutive digits
            //
            while ( ((CmdChar = *C->MatchEnd) != '\0') &&
                    isdigit( (char)CmdChar ) ) {
                C->MatchEnd++;
            }
            C->MatchEnd--;

            if ( C->MatchBegin > C->MatchEnd ) {
                //
                //    No number
                //
                return FALSE;
            }

            CmdIndex = C->MatchEnd + 1;
            PatternIndex++;

            break;


        case '@':

            //
            //    Match one character
            //
            if ( *CmdIndex == '\0' ) {
                return FALSE;
            }

            C->MatchBegin = C->MatchEnd = CmdIndex;
            CmdIndex++;
            PatternIndex++;

            break;


        case '*':

            //
            //    Match everything up to next blank (or end of input)
            //
            C->MatchBegin    = CmdIndex;
            C->MatchEnd    = C->MatchBegin;

            while ( ( (CmdChar = *C->MatchEnd ) != '\0' )  &&
                    ( CmdChar !=  ' ' ) ) {

                C->MatchEnd++;
            }
            C->MatchEnd--;

            CmdIndex = C->MatchEnd+1;
            PatternIndex++;

            break;

        case '[':

            //
            //    Optional sequence
            //
            PatternIndex++;

            PatternChar = *PatternIndex;
            CmdChar     = *CmdIndex;

            //
            //    If the first charcter in the input does not match the
            //    first character in the optional sequence, we just
            //    skip the optional sequence.
            //
            if ( ( CmdChar == '\0' ) ||
                 ( CmdChar == ' ')             ||
                 ( toupper(CmdChar) != toupper(PatternChar) ) ) {

                while ( PatternChar != ']' ) {
                    PatternIndex++;
                    PatternChar = *PatternIndex;
                }
                PatternIndex++;

            } else {

                //
                //    Since the first character in the sequence matched, now
                //    everything must match.
                //
                while ( PatternChar != ']' ) {

                    if ( toupper(PatternChar) != toupper(CmdChar) ) {
                        return FALSE;
                    }
                    CmdIndex++;
                    PatternIndex++;
                    CmdChar = *CmdIndex;
                    PatternChar = *PatternIndex;
                }

                PatternIndex++;
            }

            break;

        default:

            //
            //    Both characters must match
            //
            CmdChar = *CmdIndex;

            if ( ( CmdChar == '\0' ) ||
                 ( toupper(CmdChar) != toupper(PatternChar) ) ) {

                return FALSE;

            }

            CmdIndex++;
            PatternIndex++;

            break;

        }
    }

    C->AdvanceIndex = CmdIndex;

    return TRUE;

}

static
VOID
Advance(
    PPARSE_CONTEXT C
    )

/*++

Routine Description:

    Advances our pointers to the beginning of the next lexeme

Arguments:

    C - The parse context.

Return Value:

    None


--*/

{

    C->CharIndex = C->AdvanceIndex;

    //
    //    Skip blank space
    //
    if ( *C->CharIndex  == ' ' ) {

        while ( *C->CharIndex  == ' ' ) {

            C->CharIndex++;
        }

    }
}

static
DWORD
GetNumber(
    PPARSE_CONTEXT C
    )

/*++

Routine Description:

    Converts the substring delimited by C->MatchBegin and C->MatchEnd into
    a number.

Arguments:

    C - The parse context

Return Value:

    ULONG - The matched string converted to a number


--*/

{
    DWORD   Number;
    CHAR    c;
    PSTR    p = C->MatchEnd+1;

    c = *p;
//    *p = '\0';
    //intf( "Making number: %s\n", C->MatchBegin );
    Number = atol( C->MatchBegin );
//    *p  = c;

    return Number;

}

static
BOOL
ConvertBaudRate (
    DWORD BaudIn,
    PDWORD BaudRate
    )

/*++

Routine Description:

    Validates a baud rate given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    BaudIn - Supplies the baud rate given by the user
    BaudRate - if returning TRUE then the baud rate to use.

Return Value:

    If a valid baud rate then returns TRUE, otherwise FALSE.

--*/

{
    switch ( BaudIn ) {

    case 11:
    case 110:
        *BaudRate = 110;
        break;

    case 15:
    case 150:
        *BaudRate = 150;
        break;

    case 30:
    case 300:
        *BaudRate = 300;
        break;

    case 60:
    case 600:
        *BaudRate = 600;
        break;

    case 12:
    case 1200:
        *BaudRate = 1200;
        break;

    case 24:
    case 2400:
        *BaudRate = 2400;
        break;

    case 48:
    case 4800:
        *BaudRate = 4800;
        break;

    case 96:
    case 9600:
        *BaudRate = 9600;
        break;

    case 19:
    case 19200:
        *BaudRate = 19200;
        break;

    default:

        *BaudRate = BaudIn;

    }

    return TRUE;
}

static
BOOL
ConvertDataBits (
    DWORD DataBitsIn,
    PBYTE DataBitsOut
    )

/*++

Routine Description:

    Validates the number of data bits given as an argument to the program,
    and converts  it to something that the COMM_DEVICE understands.

Arguments:

    DataBitsIn - Supplies the number given by the user
    DataBitsOut - if returning TRUE, then the number of data bits.

Return Value:

    If a valid data bits then TRUE, otherwise FALSE.

--*/

{

    if ( ( DataBitsIn != 5 ) &&
         ( DataBitsIn != 6 ) &&
         ( DataBitsIn != 7 ) &&
         ( DataBitsIn != 8 ) ) {

        return FALSE;

    }

    *DataBitsOut = (BYTE)DataBitsIn;

    return TRUE;

}

static
BOOL
ConvertStopBits (
    DWORD StopBitsIn,
    PBYTE StopBits
    )

/*++

Routine Description:

    Validates a number of stop bits given as an argument to the program,
    and converts it to something that the COMM_DEVICE understands.

Arguments:

    StopBitsIn - Supplies the number given by the user
    StopBits - If returning true then a valid stop bits setting.

Return Value:

    If a valid stop bits setting then TRUE, otherwise false.

--*/

{

    switch ( StopBitsIn ) {

    case 1:
        *StopBits = ONESTOPBIT;
        break;

    case 2:
        *StopBits = TWOSTOPBITS;
        break;

    default:
        return FALSE;

    }

    return TRUE;

}

static
BOOL
ConvertParity (
    CHAR ParityIn,
    PBYTE Parity
    )

/*++

Routine Description:

    Validates a parity given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    ParityIn - Supplies the baud rate given by the user
    Parity - The valid parity if return true.

Return Value:

    If a valid parity setting then TRUE otherwise false.

--*/

{

    //
    //    Set the correct parity value depending on the character.
    //
    switch ( tolower(ParityIn) ) {

    case 'n':
        *Parity = NOPARITY;
        break;

    case 'o':
        *Parity = ODDPARITY;
        break;

    case 'e':
        *Parity = EVENPARITY;
        break;

    case 'm':
        *Parity = MARKPARITY;
        break;

    case 's':
        *Parity = SPACEPARITY;
        break;

    default:
        return FALSE;

    }

    return TRUE;
}

static
BOOL
ConvertDtrControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE DtrControl
    )

/*++

Routine Description:

    Validates a DTR control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    IdxBegin - Supplies Index of first character
    IdxEnd - Supplies Index of last character
    DtrControl - If returning true, the valid dtr setting.

Return Value:

    DTR_CONTROL -   The DTR control value


--*/

{

    PSTR    p;

    p = IdxBegin;
    if ( (tolower(*p)  == 'o' ) &&
         p++                    &&
         (tolower(*p)  == 'n' ) &&
         (IdxEnd == p)) {


        *DtrControl = DTR_CONTROL_ENABLE;
        return TRUE;

    }

    p = IdxBegin;
    if ( (tolower(*p) == 'o')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         (IdxEnd == p ) ) {

        *DtrControl =  DTR_CONTROL_DISABLE;
        return TRUE;
    }

    p = IdxBegin;
    if ( (tolower(*p) == 'h')   &&
         p++                    &&
         (tolower(*p++) == 's') &&
         (IdxEnd == p ) ) {

        *DtrControl =  DTR_CONTROL_HANDSHAKE;
        return TRUE;
    }

    return FALSE;
}

static
BOOL
ConvertRtsControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE RtsControl
    )

/*++

Routine Description:

    Validates a RTS control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    IdxBegin - Supplies Index of first character
    IdxEnd - Supplies Index of last character
    RtsControl - If returning true, the valid rts setting.

Return Value:

    RTS_CONTROL -   The RTS control value

--*/

{

    PSTR    p;
    p = IdxBegin;
    if ( (tolower(*p)  == 'o' ) &&
         p++                    &&
         (tolower(*p)  == 'n' ) &&
         (IdxEnd == p)) {


        *RtsControl = RTS_CONTROL_ENABLE;
        return TRUE;

    }

    p = IdxBegin;
    if ( (tolower(*p) == 'o')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         (IdxEnd == p ) ) {

        *RtsControl =  RTS_CONTROL_DISABLE;
        return TRUE;
    }

    p = IdxBegin;
    if ( (tolower(*p) == 'h')   &&
         p++                    &&
         (tolower(*p++) == 's') &&
         (IdxEnd == p ) ) {

        *RtsControl =  RTS_CONTROL_HANDSHAKE;
        return TRUE;
    }

    p = IdxBegin;
    if ( (tolower(*p) == 't')   &&
         p++                    &&
         (tolower(*p++) == 'g') &&
         (IdxEnd == p ) ) {

        *RtsControl =  RTS_CONTROL_TOGGLE;
        return TRUE;
    }

    return FALSE;

}

static
NTSTATUS
DeviceNameCompare(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

{

    PPARSE_CONTEXT C = EntryContext;
    UNICODE_STRING uniName;
    ANSI_STRING ansiName;

    RtlInitUnicodeString(
        &uniName,
        ValueData
        );

    if (!NT_SUCCESS(RtlUnicodeStringToAnsiString(
                        &ansiName,
                        &uniName,
                        TRUE
                        ))) {

        //
        // Oh well, couldn't form the name.  Just get out.
        //
        return STATUS_SUCCESS;

    }

    //
    // See if we got a name match.
    //

    if (Match(C,ansiName.Buffer)) {

        //
        // Ok, got a name match, advance past it.
        //

        Advance(C);

        //
        // See if they've got the optional : following the
        // device name.
        //

        if (Match(C,":")) {

            //
            // Go past it.
            //

            Advance(C);

        }

    }
    RtlFreeAnsiString(&ansiName);
    return STATUS_SUCCESS;

}

static
VOID
IgnoreDeviceName(
    IN PPARSE_CONTEXT C
    )

{

    RTL_QUERY_REGISTRY_TABLE qTable[2] = {0};

    //
    // Build the query table.
    //

    qTable[0].QueryRoutine = DeviceNameCompare;
    qTable[0].EntryContext = C;

    RtlQueryRegistryValues(
        RTL_REGISTRY_DEVICEMAP,
        L"SERIALCOMM",
        &qTable[0],
        NULL,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\compsup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    compsup.c

Abstract:

    This module implements COM+ support routines to detect COM+ images.

Author:

    Samer Arafeh (samera) 23-Oct-2000

Revision History:

--*/

#include "basedll.h"
#include <wow64t.h>


BOOL
SetComPlusPackageInstallStatus(
    ULONG ComPlusPackage
    )

/*++

Routine Description:

    This function updates the COM+ package status on the system.
    

Arguments:

    ComPlusPackage - Com+ package value to update.

Return Value:

    BOOL.

--*/

{
    NTSTATUS NtStatus;

    if (ComPlusPackage & COMPLUS_INSTALL_FLAGS_INVALID)
    {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    NtStatus = NtSetSystemInformation(
                   SystemComPlusPackage,
                   &ComPlusPackage,
                   sizeof (ULONG)
                   );

    if (!NT_SUCCESS (NtStatus))
    {
        BaseSetLastNTError (NtStatus);
        return FALSE;
    }

    return TRUE;
}


ULONG
GetComPlusPackageInstallStatus(
    VOID
    )

/*++

Routine Description:

    This function reads the COM+ package status on the system.    

Arguments:

    None.
    
Return Value:

    ULONG representing the COM+ package value.

--*/

{
    NTSTATUS NtStatus;
    ULONG ComPlusPackage;


    ComPlusPackage = USER_SHARED_DATA->ComPlusPackage;

    if (ComPlusPackage == (ULONG)-1)
    {
        //
        // If this is the first call ever, let's get the information from
        // the kernel.
        //

        NtQuerySystemInformation(
            SystemComPlusPackage,
            &ComPlusPackage,
            sizeof (ULONG),
            NULL
            );
    }

    return ComPlusPackage;
}


#if defined(_WIN64) || defined(BUILD_WOW6432)

NTSTATUS
BasepIsComplusILImage(
    IN HANDLE SectionImageHandle,
    OUT BOOLEAN *IsComplusILImage
    )

/*++

Routine Description:

    This function is called each time a COM+ image is about to be launched. It checks
    to see if the image is an ILONLY image or not.
    

Arguments:

    ImageSection - Open handle to the image section to examine.

    IsComplusILImage - Out boolean. TRUE if SectionImageHandle corresponds to an IL only 
        COM+ image, otherwise FALSE.

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN MappedAsImage;
    PVOID ViewBase;
    SIZE_T ViewSize;
    ULONG EntrySize;
    PIMAGE_COR20_HEADER Cor20Header;
    PIMAGE_NT_HEADERS NtImageHeader;
    ULONG ComPlusPackage64;
    SIZE_T ReturnLength;
    MEMORY_BASIC_INFORMATION MemoryInformation;
#if defined(BUILD_WOW6432)
    ULONG   NativePageSize = Wow64GetSystemNativePageSize();
#else
    #define NativePageSize  BASE_SYSINFO.PageSize
#endif
    NTSTATUS NtStatus = STATUS_SUCCESS;

    *IsComplusILImage = FALSE;

    //
    // Let's map in the image and look inside the headers
    //

    ViewSize = 0;
    ViewBase = NULL;
    NtStatus = NtMapViewOfSection (
                   SectionImageHandle,
                   NtCurrentProcess(),
                   &ViewBase,
                   0L,
                   0L,
                   NULL,
                   &ViewSize,
                   ViewShare,
                   0L,
                   PAGE_READONLY
                   );

    if (!NT_SUCCESS (NtStatus)) {
        ViewBase = NULL;
        goto Exit;
    }

    MappedAsImage = TRUE;

    //
    // Examine the image
    //

    __try {
        NtStatus = RtlImageNtHeaderEx(0, ViewBase, ViewSize, &NtImageHeader);
        if (!NT_SUCCESS(NtStatus)) {
            __leave;
        }
        if (NtImageHeader == NULL) {
            NtStatus = STATUS_INTERNAL_ERROR;
            __leave;
        }
        if (NtImageHeader->OptionalHeader.SectionAlignment < NativePageSize) {

            NtStatus = NtQueryVirtualMemory (NtCurrentProcess(),
                                             ViewBase,
                                             MemoryBasicInformation,
                                             &MemoryInformation,
                                             sizeof MemoryInformation,
                                             &ReturnLength);

            if ((NT_SUCCESS(NtStatus)) &&
                ((MemoryInformation.Protect == PAGE_READONLY) ||
                 (MemoryInformation.Protect == PAGE_EXECUTE_READ))) {

                //
                // This is mapped as a native image if the PE header isn't
                // already copy on write.
                //

                NOTHING;
            }
            else {
                MappedAsImage = FALSE;
                ViewBase = LDR_VIEW_TO_DATAFILE (ViewBase);
            }
        }

        Cor20Header = RtlImageDirectoryEntryToData (
                          ViewBase,
                          MappedAsImage,
                          IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                          &EntrySize
                          );

        if ((Cor20Header != NULL) && (EntrySize != 0))
        {
            if ((Cor20Header->Flags & (COMIMAGE_FLAGS_32BITREQUIRED | COMIMAGE_FLAGS_ILONLY)) == 
                    COMIMAGE_FLAGS_ILONLY)
            {
                ComPlusPackage64 = GetComPlusPackageInstallStatus ();
                  
                if ((ComPlusPackage64 & COMPLUS_ENABLE_64BIT) != 0)
                {
                    *IsComplusILImage = TRUE;
                }
            }
        }
        NtStatus = STATUS_SUCCESS;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }

Exit:
    //
    // Unmap the section from memory
    //
    if (ViewBase != NULL) {
        NtUnmapViewOfSection (
            NtCurrentProcess(),
            LDR_DATAFILE_TO_VIEW(ViewBase)
            );
    }
    return NtStatus;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\compname.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    COMPNAME.C

Abstract:

    This module contains the GetComputerName and SetComputerName APIs.
    Also: DnsHostnameToComputerName
	  AddLocalAlternateComputerName
	  RemoveLocalAlternateComputerName
	  SetLocalPrimaryComputerName
	  EnumerateLocalComputerNames

Author:

    Dan Hinsley (DanHi)    2-Apr-1992


Revision History:

    Greg Johnson (gregjohn)  13-Feb-2001
    
Notes:

    Currently there is no way to enumerate the list of Alternate Netbios
    names.  Presumably this will be fixed in a future release (Blackcomb?).
    The flags parameter to all the *Local* API's is for this use.

--*/

#include <basedll.h>
#include <dnsapi.h>

typedef DNS_STATUS
(WINAPI DNS_VALIDATE_NAME_FN)(
    IN LPCWSTR Name,
    IN DNS_NAME_FORMAT Format
    );

    //
    //      

#define REASONABLE_LENGTH 128

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName"

#define NON_VOLATILE_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"

#define VOLATILE_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
    
#define ALT_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters"

#define VOLATILE_COMPUTERNAME L"ActiveComputerName"
#define NON_VOLATILE_COMPUTERNAME L"ComputerName"
#define COMPUTERNAME_VALUE_NAME L"ComputerName"
#define COMPUTERNAME_OPTIONAL_NAME L"OptionalNames"
#define CLASS_STRING L"Network ComputerName"

#define TCPIP_POLICY_ROOT \
        L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\System\\DNSclient"

#define TCPIP_POLICY_DOMAINNAME \
        L"PrimaryDnsSuffix"

#define TCPIP_ROOT \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters"

#define TCPIP_HOSTNAME \
        L"Hostname"
	
#define TCPIP_NV_HOSTNAME \
        L"NV Hostname"

#define TCPIP_DOMAINNAME \
        L"Domain"

#define TCPIP_NV_DOMAINNAME \
        L"NV Domain"
	
#define DNSCACHE_ROOT \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters"
	
#define DNS_ALT_HOSTNAME \
        L"AlternateComputerNames"

//
// Allow the cluster guys to override the returned
// names with their own virtual names
//

const PWSTR ClusterNameVars[] = {
                L"_CLUSTER_NETWORK_NAME_",
                L"_CLUSTER_NETWORK_HOSTNAME_",
                L"_CLUSTER_NETWORK_DOMAIN_",
                L"_CLUSTER_NETWORK_FQDN_"
                };

//
// Disallowed control characters (not including \0)
//

#define CTRL_CHARS_0       L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Combinations of the above
//

#define ILLEGAL_NAME_CHARS_STR  L"\"/\\[]:|<>+=;,?" CTRL_CHARS_STR

WCHAR DnsApiDllString[] = L"DNSAPI.DLL";

#define DNS_HOSTNAME 0
#define DNS_DOMAINNAME 1

DWORD
BaseMultiByteToWideCharWithAlloc(
    LPCSTR   lpBuffer,
    LPWSTR * ppBufferW
    )
/*++

Routine Description:

  Converts Ansi strings to Unicode strings and allocs it's own space.


Arguments:

  lpBuffer - Ansi to convert
  ppBufferW - Unicode result

Return Value:

  ERROR_SUCCESS, or various failures

--*/
{
    ULONG cchBuffer = 0;
    BOOL fSuccess = TRUE;

    if (lpBuffer==NULL) {
        *ppBufferW=NULL;
	return ERROR_SUCCESS;
    }

    cchBuffer = strlen(lpBuffer);
    
    // get enough space to cover the string and a trailing null
    *ppBufferW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchBuffer + 1) * sizeof(WCHAR));
    if (*ppBufferW==NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    fSuccess = MultiByteToWideChar(CP_ACP, 
			      0,
			      lpBuffer,
			      (cchBuffer+1)*sizeof(CHAR),
			      *ppBufferW,
			      cchBuffer+1
			      );
    if (fSuccess) {
	return ERROR_SUCCESS;
    }
    else {
	return GetLastError();
    }
}

DWORD
BaseWideCharToMultiByteWithAlloc(
    LPCWSTR lpBuffer,
    LPSTR * ppBufferA
    )
/*++

Routine Description:

  Converts Unicode strings to Ansi strings and allocs it's own space.


Arguments:

  lpBuffer - Unicode to convert
  ppBufferA - Ansi result

Return Value:

  ERROR_SUCCESS, or various failures

--*/
{
    ULONG cchBuffer = 0;
    DWORD err = ERROR_SUCCESS;

    cchBuffer = wcslen(lpBuffer);
    *ppBufferA = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchBuffer + 1) * sizeof(CHAR));
    if (*ppBufferA==NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    err = WideCharToMultiByte(CP_ACP, 
			      0,
			      lpBuffer,
			      cchBuffer+1,
			      *ppBufferA,
			      (cchBuffer+1)*sizeof(CHAR),
			      NULL,
			      NULL
			      );
    if (err!=0) {
	return ERROR_SUCCESS;
    }
    else {
	return GetLastError();
    }
}

//
// Worker routine
//

NTSTATUS
GetNameFromValue(
    HANDLE hKey,
    LPWSTR SubKeyName,
    LPWSTR ValueValue,
    LPDWORD nSize
    )

/*++

Routine Description:

  This returns the value of "ComputerName" value entry under the subkey
  SubKeyName relative to hKey.  This is used to get the value of the
  ActiveComputerName or ComputerName values.


Arguments:

    hKey       - handle to the Key the SubKey exists under

    SubKeyName - name of the subkey to look for the value under

    ValueValue - where the value of the value entry will be returned

    nSize      - pointer to the size (in characters) of the ValueValue buffer

Return Value:


--*/
{

#define VALUE_BUFFER_SIZE (sizeof(KEY_VALUE_FULL_INFORMATION) + \
    (sizeof( COMPUTERNAME_VALUE_NAME ) + MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR))

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hSubKey;
    BYTE ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_FULL_INFORMATION pKeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    DWORD ValueLength;
    PWCHAR pTerminator;

    //
    // Open the node for the Subkey
    //

    RtlInitUnicodeString(&KeyName, SubKeyName);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              hKey,
                              NULL
                              );

    NtStatus = NtOpenKey(&hSubKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(NtStatus)) {

        RtlInitUnicodeString(&ValueName, COMPUTERNAME_VALUE_NAME);

        NtStatus = NtQueryValueKey(hSubKey,
                                   &ValueName,
                                   KeyValueFullInformation,
                                   pKeyValueInformation,
                                   VALUE_BUFFER_SIZE,
                                   &ValueLength);

        NtClose(hSubKey);

        if (NT_SUCCESS(NtStatus) && 
            (pKeyValueInformation->DataLength > 0 )) {

            //
            // If the user's buffer is big enough, move it in
            // First see if it's null terminated.  If it is, pretend like
            // it's not.
            //

            pTerminator = (PWCHAR)((PBYTE) pKeyValueInformation +
                pKeyValueInformation->DataOffset +
                pKeyValueInformation->DataLength);
            pTerminator--;

            if (*pTerminator == L'\0') {
               pKeyValueInformation->DataLength -= sizeof(WCHAR);
            }

            if (*nSize >= pKeyValueInformation->DataLength/sizeof(WCHAR) + 1) {
               //
               // This isn't guaranteed to be NULL terminated, make it so
               //
                    RtlCopyMemory(ValueValue,
                        (LPWSTR)((PBYTE) pKeyValueInformation +
                        pKeyValueInformation->DataOffset),
                        pKeyValueInformation->DataLength);

                    pTerminator = (PWCHAR) ((PBYTE) ValueValue +
                        pKeyValueInformation->DataLength);
                    *pTerminator = L'\0';

                    //
                    // Return the number of characters to the caller
                    //

                    *nSize = wcslen(ValueValue);
            }
            else {
                NtStatus = STATUS_BUFFER_OVERFLOW;
                *nSize = pKeyValueInformation->DataLength/sizeof(WCHAR) + 1;
            }

        }
        else {
            //
            // If the value has been deleted (zero length data),
            // return object not found.
            //

            if ( NT_SUCCESS( NtStatus ) )
            {
                NtStatus = STATUS_OBJECT_NAME_NOT_FOUND ;
            }
        }
    }

    return(NtStatus);
}

VOID
BaseConvertCharFree(
    VOID * lpBuffer
    )
/*++

Routine Description:

  Frees space Convert functions.


Arguments:

  lpBuffer - Buffer to free

Return Value:

    None!

--*/
{
    if (lpBuffer!=NULL) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpBuffer);
    }
}

NTSTATUS
BasepGetNameFromReg(
    PCWSTR Path,
    PCWSTR Value,
    PWSTR Buffer,
    PDWORD Length
    )
/*++

Routine Description:

  This routine gets a string from the value at the specified registry key.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to retrieve

  Buffer - Buffer to return the value

  Length - size of the buffer in characters

Return Value:

  STATUS_SUCCESS, or various failures

--*/

{
    NTSTATUS Status ;
    HANDLE Key ;
    OBJECT_ATTRIBUTES ObjA ;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;


    BYTE ValueBuffer[ REASONABLE_LENGTH ];
    PKEY_VALUE_FULL_INFORMATION pKeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    BOOLEAN FreeBuffer = FALSE ;
    DWORD ValueLength;
    PWCHAR pTerminator;

    //
    // Open the node for the Subkey
    //

    RtlInitUnicodeString(&KeyName, Path );

    InitializeObjectAttributes(&ObjA,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    Status = NtOpenKey(&Key, KEY_READ, &ObjA );

    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString( &ValueName, Value );

        Status = NtQueryValueKey(Key,
                                   &ValueName,
                                   KeyValueFullInformation,
                                   pKeyValueInformation,
                                   REASONABLE_LENGTH ,
                                   &ValueLength);

        if ( Status == STATUS_BUFFER_OVERFLOW )
        {
            pKeyValueInformation = RtlAllocateHeap( RtlProcessHeap(),
                                                    0,
                                                    ValueLength );

            if ( pKeyValueInformation )
            {
                FreeBuffer = TRUE ;

                Status = NtQueryValueKey( Key,
                                          &ValueName,
                                          KeyValueFullInformation,
                                          pKeyValueInformation,
                                          ValueLength,
                                          &ValueLength );

            }
        }

        if ( NT_SUCCESS(Status) ) {

            //
            // If the user's buffer is big enough, move it in
            // First see if it's null terminated.  If it is, pretend like
            // it's not.
            //

            pTerminator = (PWCHAR)((PBYTE) pKeyValueInformation +
                pKeyValueInformation->DataOffset +
                pKeyValueInformation->DataLength);
            pTerminator--;

            if (*pTerminator == L'\0') {
               pKeyValueInformation->DataLength -= sizeof(WCHAR);
            }

            if ( ( *Length >= pKeyValueInformation->DataLength/sizeof(WCHAR) + 1) &&
                 ( Buffer != NULL ) ) {
               //
               // This isn't guaranteed to be NULL terminated, make it so
               //
                    RtlCopyMemory(Buffer,
                        (LPWSTR)((PBYTE) pKeyValueInformation +
                        pKeyValueInformation->DataOffset),
                        pKeyValueInformation->DataLength);

                    pTerminator = (PWCHAR) ((PBYTE) Buffer +
                        pKeyValueInformation->DataLength);
                    *pTerminator = L'\0';

                    //
                    // Return the number of characters to the caller
                    //

                    *Length = pKeyValueInformation->DataLength / sizeof(WCHAR) ;

            }
            else {
                Status = STATUS_BUFFER_OVERFLOW;
                *Length = pKeyValueInformation->DataLength/sizeof(WCHAR) + 1;
            }

        }

        NtClose( Key );
    }

    if ( FreeBuffer )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInformation );
    }

    return Status ;

}

NTSTATUS
BaseSetNameInReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

  This routine sets a string in the value at the registry key.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to set

  Buffer - Buffer to set

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
    ULONG ValueLength;

    //
    // Open the ComputerName\ComputerName node
    //

    RtlInitUnicodeString(&KeyName, Path);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtOpenKey(&hKey, KEY_READ | KEY_WRITE, &ObjectAttributes);

    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus ;
    }

    //
    // Update the value under this key
    //

    RtlInitUnicodeString(&ValueName, Value);

    ValueLength = (wcslen( Buffer ) + 1) * sizeof(WCHAR);

    NtStatus = NtSetValueKey(hKey,
                             &ValueName,
                             0,
			     REG_SZ,
                             (LPWSTR) Buffer,
                             ValueLength);

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtFlushKey( hKey );
    }

    NtClose(hKey);

    return NtStatus ;
}

NTSTATUS
BaseSetMultiNameInReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer,
    DWORD  BufferSize
    )
/*++

Routine Description:

  This routine sets a string in the value at the specified multivalued registry key.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to set

  Buffer - Buffer to set

  BufferSize - Size of the buffer in characters
	       This is needed since there can be
	       many nulls in the buffer which we
	       want to write

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
   
    //
    // Open the ComputerName\ComputerName node
    //

    RtlInitUnicodeString(&KeyName, Path);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtCreateKey(&hKey, 
			   KEY_READ | KEY_WRITE, 
			   &ObjectAttributes,
			   0,
			   NULL,
			   0,
			   NULL);

    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus ;
    }

    //
    // Update the value under this key
    //

    RtlInitUnicodeString(&ValueName, Value);

    NtStatus = NtSetValueKey(hKey,
                             &ValueName,
                             0,
                             REG_MULTI_SZ,
                             (LPWSTR) Buffer,
                             BufferSize);

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtFlushKey( hKey );
    }

    NtClose(hKey);

    return NtStatus ;
}

NTSTATUS
BaseCreateMultiValue(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

  Create a multivalued registry value and initialize it with Buffer.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to set

  Buffer - Buffer to set

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpMultiValue = NULL;

    lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG ( TMP_TAG ), (wcslen(Buffer)+2)*sizeof(WCHAR));
    if (lpMultiValue==NULL) {
	NtStatus = STATUS_NO_MEMORY;
    }
    else { 
	memcpy(lpMultiValue, Buffer, wcslen(Buffer)*sizeof(WCHAR));
	lpMultiValue[wcslen(Buffer)] = L'\0';
	lpMultiValue[wcslen(Buffer)+1] = L'\0';
	NtStatus = BaseSetMultiNameInReg(Path,
					 Value,
					 lpMultiValue,
					 (wcslen(Buffer)+2)*sizeof(WCHAR));
	RtlFreeHeap(RtlProcessHeap(), 0, lpMultiValue);
    }
    return NtStatus;
}

DWORD 
BasepGetMultiValueAddr(
    IN LPWSTR       lpMultiValue,
    IN DWORD        dwIndex,
    OUT LPWSTR *    ppFound,
    OUT LPDWORD     pcchIndex
    )
/*++

Routine Description:

    Given an index into a Multivalued register (string), return
    the string at that index (not a copy), and it's char count location in the 
    full multivalued string

Arguments:

    lpMultiValue - the register string (returned from NtQueryKey)
    dwIndex - the index of which string to return
    ppFound - the string found (if found) - user shouldn't free
    pcchIndex - the location in lpMultiValue (in characters) of ppFound

Return Value:

    ERROR (ERROR_NOT_FOUND if not found)

--*/
{
    DWORD i = 0;
    DWORD err = ERROR_SUCCESS;
    DWORD cchTempIndex = 0;

    // lpMultiValue is a concatenated string of (non-null)strings, null terminated
    for (i=0; (i<dwIndex) && (lpMultiValue[0] != L'\0'); i++) {
	cchTempIndex += wcslen(lpMultiValue) + 1;
	lpMultiValue += wcslen(lpMultiValue) + 1;
    }
    
    // if we found the correct index, it's in lpMultiValue
    if (lpMultiValue[0]!=L'\0') {
	*ppFound = lpMultiValue;
	*pcchIndex = cchTempIndex;
	err = ERROR_SUCCESS; 
    }
    else {
	err = ERROR_NOT_FOUND;
    }

    return err;
}

DWORD 
BaseGetMultiValueIndex(
    IN LPWSTR   lpMultiValue,
    IN LPCWSTR  lpValue,
    OUT DWORD * pcchIndex
    )
/*++

Routine Description:

    Given a Multivalued register (string), and lpValue, return
    the index of lpValue in lpMultiValue (ie, the 0th string, the 1st, etc).

Arguments:

    lpMultiValue -  the register string (returned from NtQueryKey)
    lpValue - the string for which to search
    pcchIndex - the index of the string matched (if found)

Return Value:

    ERROR (ERROR_NOT_FOUND if not found)

--*/
{
    LPWSTR lpFound = NULL;
    DWORD cchFoundIndex = 0;
    DWORD i = 0;
    DWORD err = ERROR_SUCCESS;
    BOOL fFound = FALSE;
   
    while ((err==ERROR_SUCCESS) && !fFound) {
	err = BasepGetMultiValueAddr(lpMultiValue,
				   i,
				   &lpFound,
				   &cchFoundIndex);
	if (err == ERROR_SUCCESS) { 
	    if ((wcslen(lpFound)==wcslen(lpValue)) && (!_memicmp(lpFound,lpValue, wcslen(lpValue)*sizeof(WCHAR)))) {
		fFound = TRUE;
		*pcchIndex = i;
	    }
	}
	i++;
    }
    return err;
}

DWORD 
BaseRemoveMultiValue(
    IN OUT LPWSTR    lpMultiValue,
    IN DWORD         dwIndex,
    IN OUT LPDWORD   pcchMultiValue
    )
/*++

Routine Description:

    Given a multivalued registry value, and an index, it removes the string
    located at that index.

Arguments:

    lpMultiValue - the register string (returned from NtQueryKey)
    dwIndex - the index of which string to remove
    pcchMultiValue - number of chars in lpMultiValue (before and after)

Return Value:

    ERRORS

--*/
{
    DWORD err = ERROR_SUCCESS;
    LPWSTR lpRest = NULL;
    LPWSTR lpFound = NULL;
    DWORD dwIndexFound = 0;
    DWORD dwIndexRest = 0;

    err = BasepGetMultiValueAddr(lpMultiValue,
			       dwIndex,
			       &lpFound,
			       &dwIndexFound);
    if (err==ERROR_SUCCESS) {
	// lpFound is a pointer to a string
	// inside of lpMultiValue, to delete it,
	// copy the rest of the string down
	err = BasepGetMultiValueAddr(lpMultiValue,
				   dwIndex+1,
				   &lpRest,
				   &dwIndexRest);
	if (err == ERROR_SUCCESS) {
	    // copy everything down

	    memmove(lpFound,lpRest,(*pcchMultiValue - dwIndexRest)*sizeof(WCHAR));
	    *pcchMultiValue = *pcchMultiValue - (dwIndexRest-dwIndexFound);
	    lpMultiValue[*pcchMultiValue] = L'\0';
	}
	else if (err == ERROR_NOT_FOUND) {
	    // string to remove is last string, simply write an extra null to orphan the string 
	    *pcchMultiValue = *pcchMultiValue - (wcslen(lpFound) +1);
	    lpMultiValue[*pcchMultiValue] = L'\0';
	    err = ERROR_SUCCESS;
	} 
    }
    return err;
}

DWORD 
BaseAddMultiValue(
    IN OUT LPWSTR    lpMultiValue,
    IN LPCWSTR       lpValue,
    IN DWORD         cchMultiValue
    )
/*++

Routine Description:

    Given a multivalued registry value, add another value.

Arguments:

    lpMultiValue - the multivalued string (must be big enough to 
		    hold current values + lpValue plus extra NULL
    lpValue - the value to add
    cchMultiValue - the count of characters USED in lpMultivalue
                    (not counting final null)

Return Value:

    ERRORS

--*/
{
    memcpy(lpMultiValue + cchMultiValue, lpValue, (wcslen(lpValue)+1)*sizeof(WCHAR));
    lpMultiValue[cchMultiValue + wcslen(lpValue) + 1] = L'\0';

    return ERROR_SUCCESS;
}

NTSTATUS
BaseAddMultiNameInReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

  This routine adds a string to the values at the specified multivalued registry key.
  If the value already exists in the key, it does nothing.

Arguments:

  Path - Path to the registry key

  Value - Name of the value

  Buffer - Buffer to add

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpMultiValue = NULL;
    ULONG  cchMultiValue = 0;
    DWORD dwIndex = 0;
    DWORD err = ERROR_SUCCESS;

    NtStatus = BasepGetNameFromReg(Path,
				   Value,
				   lpMultiValue,
				   &cchMultiValue);

    if ( NtStatus==STATUS_NOT_FOUND || NtStatus==STATUS_OBJECT_NAME_NOT_FOUND) {
	// create it, then we are done
	NtStatus = BaseCreateMultiValue(Path,Value,Buffer);  
	return NtStatus;
    } else if ( NtStatus==STATUS_BUFFER_OVERFLOW ) {
	lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchMultiValue+2+wcslen(Buffer))*sizeof(WCHAR));
	if (lpMultiValue==NULL) {
	    NtStatus = STATUS_NO_MEMORY;
	}
	else {
	    NtStatus = BasepGetNameFromReg(Path,
					   Value,
					   lpMultiValue,
					   &cchMultiValue);
	}
    } 

    if (NT_SUCCESS( NtStatus)) {
	// does it already exist in this structure?  
	err = BaseGetMultiValueIndex(lpMultiValue,
				     Buffer, &dwIndex);

	// if err==ERROR_SUCCESS, then the above function found the string already in the value.
	// don't add a duplicate
	if (err!=ERROR_SUCCESS) {

	    err = BaseAddMultiValue(lpMultiValue, Buffer, cchMultiValue);
	       
	    if (err == ERROR_SUCCESS) {
		NtStatus = BaseSetMultiNameInReg(Path, Value, lpMultiValue, (cchMultiValue+2+wcslen(Buffer))*sizeof(WCHAR));
	    }
	}
    }

    if (lpMultiValue) {
	RtlFreeHeap( RtlProcessHeap(), 0, lpMultiValue);
    }
    return NtStatus ;

}


NTSTATUS
BaseRemoveMultiNameFromReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

    Removes a name from a multivalued registry.  If the value exists more than once in the
    list, removes them all.  

Arguments:
 
  Path - Path to the registry key

  Value - Name of the value

  Buffer - Buffer to remove

Return Value:

    ERRORS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD err = ERROR_SUCCESS;
    DWORD dwIndex = 0;
    LPWSTR lpMultiValue = NULL;
    ULONG  cchNames = 0;
    BOOL fNameRemoved = FALSE;

    NtStatus = BasepGetNameFromReg(Path,
				   Value,
				   lpMultiValue,
				   &cchNames);

    if (NtStatus==STATUS_BUFFER_OVERFLOW) {
	lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchNames) * sizeof(WCHAR));
	if (lpMultiValue==NULL) {
	    NtStatus = STATUS_NO_MEMORY;
	}
	else { 
	    NtStatus = BasepGetNameFromReg(Path,
					   Value,
					   lpMultiValue,
					   &cchNames);
	    err = RtlNtStatusToDosError(NtStatus);
	    if (err == ERROR_SUCCESS) {
		// search for and remove all values in structure 
		while (err==ERROR_SUCCESS) { 
		    err = BaseGetMultiValueIndex(lpMultiValue,
						 Buffer,
						 &dwIndex);
		    if (err == ERROR_SUCCESS) {
			err = BaseRemoveMultiValue(lpMultiValue,
						   dwIndex,
						   &cchNames);
			fNameRemoved = TRUE;
		    }
		}
		// if we removed a name, write it to the registry...
		if (fNameRemoved) {
		    NtStatus = BaseSetMultiNameInReg(
			Path,
			Value,
			lpMultiValue,
			(cchNames+1)*sizeof(WCHAR));  
		} 
		else {
		    // Nothing to remove! ERRROR
		    NtStatus = STATUS_NOT_FOUND;
		    
		}
	    }
	    RtlFreeHeap(RtlProcessHeap(), 0, lpMultiValue);
	}
    }
    return NtStatus;
}

LPWSTR
BasepGetNameNonVolatileFromReg(
    COMPUTER_NAME_TYPE NameType
    )
/*++

Routine Description:

    Get the non volatile name from the reg

Arguments:
 
    NameType -

Return Value:

    name in non-volatile reg, return value must be freed

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpBuffer = NULL;
    ULONG cchBuffer = 0;
    LPWSTR key = NULL;
    LPWSTR value = NULL;

    switch (NameType) {
    case ComputerNameNetBIOS:
    case ComputerNamePhysicalNetBIOS:
	key = NON_VOLATILE_COMPUTERNAME_NODE;
	value = NON_VOLATILE_COMPUTERNAME;
	break;
    case ComputerNameDnsHostname:
    case ComputerNamePhysicalDnsHostname:
	key = TCPIP_ROOT;
	value = TCPIP_NV_HOSTNAME;
	break;
    case ComputerNameDnsDomain:
    case ComputerNamePhysicalDnsDomain:
	key = TCPIP_ROOT;
	value = TCPIP_NV_DOMAINNAME;
	break;
    default:
	return NULL;
    }

    NtStatus = BasepGetNameFromReg(
	key,
	value,
	lpBuffer,
	&cchBuffer);

    if (NtStatus==STATUS_BUFFER_OVERFLOW) {
	lpBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchBuffer) * sizeof(WCHAR));
	if (lpBuffer!=NULL) { 
	    NtStatus = BasepGetNameFromReg(	
		key,
		value,
		lpBuffer,
		&cchBuffer);
	}
    }

    if (!NT_SUCCESS(NtStatus)) {
	if (lpBuffer!=NULL) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpBuffer);
	}
	lpBuffer = NULL;
    }

    return lpBuffer ;
}

LPWSTR
BasepGetComputerNameExWRtlAlloc(
    COMPUTER_NAME_FORMAT NameType
    )
/*++

Routine Description:

    Call get GetComptuerNameExW and allocate the memory
    required and return the value.  Returned value
    must be freed with RtlFreeHeap

Arguments:
 
    NameType -

Return Value:

    NULL if error, Alloced name otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpBuffer = NULL;
    ULONG cchBuffer = 0;
    DWORD err = ERROR_SUCCESS;

    if ((GetComputerNameExW(NameType, lpBuffer, &cchBuffer)==ERROR_SUCCESS) ||
	((err = GetLastError()) != ERROR_MORE_DATA)) {
	if (lpBuffer!=NULL) {
	    RtlFreeHeap(RtlProcessHeap(),0, lpBuffer);
	}
	return NULL;
    }
        
    lpBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchBuffer*sizeof(WCHAR));
    if ((lpBuffer!=NULL) && (GetComputerNameExW(NameType, lpBuffer, &cchBuffer)!=ERROR_SUCCESS)) {
	return NULL;
    }

    return lpBuffer ;
}

LPWSTR
BasepGetNameNonVolatile(
    COMPUTER_NAME_FORMAT NameType
    )
/*++

Routine Description:

    Get the non volatile name

Arguments:
 
    NameType -

Return Value:

    non-volatile name, return value must be freed

--*/
{
    LPWSTR lpDnsHostname = NULL;
    LPWSTR lpDnsDomain = NULL;
    LPWSTR lpName = NULL;
    ULONG cchDnsHostname = 0;
    ULONG cchDnsDomain = 0;

    switch (NameType) {
    case ComputerNameNetBIOS:
    case ComputerNamePhysicalNetBIOS:
    case ComputerNameDnsHostname:
    case ComputerNamePhysicalDnsHostname:
    case ComputerNameDnsDomain:
    case ComputerNamePhysicalDnsDomain:
	lpName = BasepGetNameNonVolatileFromReg(NameType);
	break;
    case ComputerNameDnsFullyQualified:
    case ComputerNamePhysicalDnsFullyQualified:
	// build it
	lpDnsHostname = BasepGetNameNonVolatile(ComputerNameDnsHostname);
	lpDnsDomain = BasepGetNameNonVolatile(ComputerNameDnsDomain);

	// if both are null, then there is no non-volatile name set
	// if one is null, get volatile name for that part of name
	if ((lpDnsHostname==NULL) && (lpDnsDomain==NULL)) {
	    // no non-volatile name set
	    lpName = NULL;
	} else { 
	    if (lpDnsHostname==NULL) {
		lpDnsHostname = BasepGetComputerNameExWRtlAlloc(ComputerNameDnsHostname);
	    } else if (lpDnsDomain==NULL) {
		lpDnsDomain = BasepGetComputerNameExWRtlAlloc(ComputerNameDnsDomain);
	    }
	    cchDnsHostname = wcslen(lpDnsHostname);
	    cchDnsDomain = wcslen(lpDnsDomain);
	    // build the full dns name
	    // if there is no domain name, return just the hostname.
	    // if there is no hostname, just return it (NULL);
	    if ((cchDnsDomain==0) || (cchDnsHostname==0)) {
		lpName = lpDnsHostname;
	    } else {
		if ((cchDnsDomain==1) && (lpDnsDomain[0]==L'.')) {
		    // the dns domain can legally be a single .
		    RtlFreeHeap(RtlProcessHeap(), 0, lpDnsDomain);
		    lpDnsDomain = NULL;
		    cchDnsDomain = 0;
		}
		// allocate space for the . and the null and the strings to concatenate in.
		lpName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchDnsHostname + cchDnsDomain + 2) * sizeof(WCHAR));
		if (lpName!=NULL) {  
		    wcscpy(lpName, lpDnsHostname);
		    wcscat(lpName, L".");
		    if (lpDnsDomain!=NULL) {
			wcscat(lpName, lpDnsDomain);
		    }
		}
		if (lpDnsHostname) {
		    RtlFreeHeap(RtlProcessHeap(), 0, lpDnsHostname);
		}
	    }  
	    if (lpDnsDomain) {
		RtlFreeHeap(RtlProcessHeap(), 0, lpDnsDomain);
	    }
	}  
    }
    return lpName;
}

BOOL
BaseValidateFlags(
    ULONG ulFlags
    )
/*++

Routine Description:

  Validates unused flags.  For now the flags parameter of 
    AddLocalAlternateComputerName*
    RemoveLocalAlternateComputerName*
    EnumerateLocalAlternateComputerName*
    SetLocalPrimaryComputerName*
  are all reserved and should be 0.  In subsequent releases
  this function should change to check for a mask of valid
  flags.   

Arguments:

  ulFlags - 

Return Value:

    BOOL

--*/
{
    if (ulFlags!=0) {
	return FALSE;
    }
    return TRUE;
}

BOOL
BaseValidateNetbiosName(
    IN LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Checks that the input is an acceptable Netbios name.

Arguments:

    lpComputerName - name to validate  

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG cchComputerName;
    ULONG AnsiComputerNameLength;

    cchComputerName = wcslen(lpComputerName);

    //
    // The name length limitation should be based on ANSI. (LanMan compatibility)
    // 

    NtStatus = RtlUnicodeToMultiByteSize(&AnsiComputerNameLength,
                                         (LPWSTR)lpComputerName,
                                         cchComputerName * sizeof(WCHAR));

    if ((!NT_SUCCESS(NtStatus)) ||
        (AnsiComputerNameLength == 0 )||(AnsiComputerNameLength > MAX_COMPUTERNAME_LENGTH)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for illegal characters; return an error if one is found
    //

    if (wcscspn(lpComputerName, ILLEGAL_NAME_CHARS_STR) < cchComputerName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for leading or trailing spaces
    //

    if (lpComputerName[0] == L' ' ||
        lpComputerName[cchComputerName-1] == L' ') {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);

    }

    return(TRUE);
}

BOOL
BaseValidateFQDnsName(
    LPCWSTR lpDnsHostname
    )
/*++

Routine Description:

    Checks that the inputted name is an acceptable Dns hostname.


Arguments:

    lpDnsHostName - name to validate  

Return Value:

    BOOL, GetLastError

--*/
{

    HANDLE DnsApi ;
    DNS_VALIDATE_NAME_FN * DnsValidateNameFn ;
    DNS_STATUS DnsStatus ;

    DnsApi = LoadLibraryW(DnsApiDllString);

    if ( !DnsApi ) {
	SetLastError(ERROR_DLL_NOT_FOUND);
	return FALSE ;
    }

    DnsValidateNameFn = (DNS_VALIDATE_NAME_FN *) GetProcAddress( DnsApi, "DnsValidateName_W" );

    if ( !DnsValidateNameFn )
    {
        FreeLibrary( DnsApi );
	SetLastError(ERROR_INVALID_DLL);
        return FALSE ;
    }

    DnsStatus = DnsValidateNameFn( lpDnsHostname, DnsNameHostnameFull );

    FreeLibrary( DnsApi );

    if ( ( DnsStatus == 0 ) ||
         ( DnsStatus == DNS_ERROR_NON_RFC_NAME ) )
    {
	return TRUE;
    }
    else
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
}

LPWSTR
BasepGetLatestName(
    COMPUTER_NAME_FORMAT compFormat
    )
/*++

Routine Description:

    Get the NV version of this name if it exists.  If it's an empty string, or it
    doesn't exist, then just get the regular name.  


Arguments:

    lpDnsHostName - name to validate  

Return Value:

    Pointer to a name, must be freed.

--*/
{
    LPWSTR lpTemp = NULL;
    lpTemp = BasepGetNameNonVolatile(compFormat);
    if (lpTemp==NULL || lpTemp[0]==L'\0') {
	// if the non-volatile name isn't there - ie they're not trying to set it, 
	// then get the regular name
	if (lpTemp!=NULL) {
	    // returned empty string, free it before getting a newer name
	    RtlFreeHeap(RtlProcessHeap(), 0, lpTemp);
	}
   
	lpTemp = BasepGetComputerNameExWRtlAlloc(compFormat);
    } 

    return lpTemp;
}

BOOL
BaseValidateDns(
    LPCWSTR lpBuffer,
    ULONG type)
/*++

Routine Description:

    Checks that the inputted name is an acceptable Dns name, either
    hostname or domain name with the latest names.


Arguments:

    lpBuffer - name to validate  
    type - type of Buffer to validate (either DNS_HOSTNAME or DNS_DOMAINNAME)

Return Value:

    BOOL, GetLastError

--*/
{
    LPWSTR lpDomain = NULL;
    LPWSTR lpHostname = NULL;
    LPWSTR lpTemp = NULL;
    LPWSTR lpDnsFQHostname = NULL;
    ULONG cchDnsFQHostname = 0;
    BOOL fReturnVal = TRUE;

    // type should be DNS_HOSTNAME or DNS_DOMAINNAME
    if (type==DNS_HOSTNAME) {
	// validating the hostname
	lpHostname = (LPWSTR)lpBuffer;
	lpTemp = lpDomain = BasepGetLatestName(ComputerNameDnsDomain);
    } else if (type==DNS_DOMAINNAME) {
	// validating the domainname
	lpDomain = (LPWSTR)lpBuffer;
	lpTemp = lpHostname = BasepGetLatestName(ComputerNameDnsHostname);
    } else {
	// bad news - should never get here.
	SetLastError(ERROR_INTERNAL_ERROR);
	fReturnVal = FALSE;
    }

    if (lpBuffer==NULL) {
	SetLastError(ERROR_INVALID_PARAMETER);
	fReturnVal = FALSE;
    }
   
    if (fReturnVal && lpDomain && memcmp(lpDomain, L".", 2*sizeof(WCHAR))) {
	// if the domain not a single "." then we'll add a "."
	cchDnsFQHostname++;
    }

    if (fReturnVal && lpDomain && lpHostname) {
	cchDnsFQHostname += wcslen(lpDomain) + wcslen(lpHostname) + 1;
	lpDnsFQHostname = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchDnsFQHostname*sizeof(WCHAR));
	if (lpDnsFQHostname==NULL) {
	    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	    fReturnVal = FALSE;
	} 

	if (fReturnVal) { 
	    wcscpy(lpDnsFQHostname, lpHostname);
	    if (memcmp(lpDomain, L".", 2*sizeof(WCHAR))) {
		wcscat(lpDnsFQHostname, L"."); 
	    }
	    wcscat(lpDnsFQHostname, lpDomain);
	    // okay, validate the FQ hostname.
	    if (!BaseValidateFQDnsName(lpDnsFQHostname)) {
		SetLastError(ERROR_INVALID_PARAMETER);
		fReturnVal = FALSE;
	    }
	} 
    } // else nothing is set yet, don't invalidate because of that.

    if (lpTemp) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpTemp);
    }

    if (lpDnsFQHostname) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpDnsFQHostname);
    }

    return fReturnVal;
}

BOOL
BaseValidateDnsHostname(
    LPCWSTR lpHostname
    )
/*++

Routine Description:

    Checks that the inputted name is an acceptable dns hostname concatenated
    with the dns domain name of the next boot (what is currently set anyway)

Arguments:

    lpHostname - name to validate

Return Value:

    BOOL, GetLastError

--*/
{
    return BaseValidateDns(lpHostname, DNS_HOSTNAME);
}

BOOL
BaseValidateDnsDomain(
    LPCWSTR lpDomain
    )
/*++

Routine Description:

    Checks that the inputted name is an acceptable dns domain name concatenated
    with the dns hostname of the next boot (what is currently set anyway)

Arguments:

    lpDomain - name to validate

Return Value:

    BOOL, GetLastError

--*/
{
    return BaseValidateDns(lpDomain, DNS_DOMAINNAME);
}


LPWSTR
BaseParseDnsName(
    IN LPCWSTR lpDnsName,
    IN ULONG NamePart
    )
/*++

Routine Description:

  Given a dns name, parse out either the hostname or the domain name. 

Arguments:

    lpDnsName - a dns name, of the form hostname.domain - domain name optional
    NamePart - DNS_HOSTNAME or DNS_DOMAINNAME
    
Return Value:

    String requested

--*/
{

    DWORD cchCharIndex = 0;
    ULONG cchName = 0;
    LPWSTR lpName = NULL;

    if (lpDnsName==NULL) {
	return NULL;
    }
    
    cchCharIndex = wcscspn(lpDnsName, L".");

    if (NamePart==DNS_HOSTNAME) {
	cchName = cchCharIndex;
    }
    else {
	if (cchCharIndex==wcslen(lpDnsName)) {
	    // no period found, 
	    cchName = 0;
	}
	else {
	    cchName =  wcslen(lpDnsName)-(cchCharIndex+1);
	}
    }

    lpName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchName + 1)*sizeof(WCHAR));
    if (lpName==NULL) {
	return NULL; 
    }

    // copy the correct part into the structure
    if (NamePart==DNS_HOSTNAME) {
	wcsncpy(lpName, lpDnsName, cchName);
    }
    else {
	wcsncpy(lpName, (LPWSTR)(lpDnsName + cchCharIndex + 1), cchName); 
    }
    lpName[cchName] = L'\0';

    return lpName;
}

BOOL
BaseSetNetbiosName(
    IN LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Sets the computer's net bios name  

Arguments:
 
  lpComputerName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus ;

    //
    // Validate that the supplied computername is valid (not too long,
    // no incorrect characters, no leading or trailing spaces)
    //

    if (!BaseValidateNetbiosName(lpComputerName)) {
	return(FALSE);
    }

    //
    // Open the ComputerName\ComputerName node
    //

    NtStatus = BaseSetNameInReg( NON_VOLATILE_COMPUTERNAME_NODE,
                                 COMPUTERNAME_VALUE_NAME,
                                 lpComputerName );

    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );

        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseSetDnsName(
    LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Sets the computer's Dns hostname  

Arguments:
 
  lpComputerName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{

    UNICODE_STRING NewComputerName ;
    UNICODE_STRING DnsName ;
    NTSTATUS Status ;
    BOOL Return ;
    HANDLE DnsApi ;
    DNS_VALIDATE_NAME_FN * DnsValidateNameFn ;
    DNS_STATUS DnsStatus ;

    DnsApi = LoadLibraryW(DnsApiDllString);

    if ( !DnsApi )
    {
        return FALSE ;
    }

    DnsValidateNameFn = (DNS_VALIDATE_NAME_FN *) GetProcAddress( DnsApi, "DnsValidateName_W" );

    if ( !DnsValidateNameFn )
    {
        FreeLibrary( DnsApi );

        return FALSE ;
    }

    DnsStatus = DnsValidateNameFn( lpComputerName, DnsNameHostnameLabel );

    FreeLibrary( DnsApi );

    if ( ( DnsStatus == 0 ) ||
         ( DnsStatus == DNS_ERROR_NON_RFC_NAME ) )
    {
        Status = BaseSetNameInReg( TCPIP_ROOT,
                                   TCPIP_NV_HOSTNAME,
                                   lpComputerName );
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        RtlInitUnicodeString( &DnsName, lpComputerName );

        Status = RtlDnsHostNameToComputerName( &NewComputerName,
                                               &DnsName,
                                               TRUE );

        if ( NT_SUCCESS( Status ) )
        {
            Return = BaseSetNetbiosName( NewComputerName.Buffer );

            RtlFreeUnicodeString( &NewComputerName );

            if ( !Return )
            {
                //
                // What?  Rollback?
                //

                return FALSE ;
            }

            return TRUE ;
        }
    }

    BaseSetLastNTError( Status ) ;

    return FALSE ;
}

BOOL
BaseSetDnsDomain(
    LPCWSTR lpName
    )
/*++

Routine Description:

    Sets the computer's Dns domain name  

Arguments:
 
  lpName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS Status ;
    HANDLE DnsApi ;
    DNS_VALIDATE_NAME_FN * DnsValidateNameFn ;
    DNS_STATUS DnsStatus ;

    //
    // Special case the empty string, which is legal, but not according to dnsapi
    //

    if ( *lpName )
    {
        DnsApi = LoadLibraryW(DnsApiDllString);

        if ( !DnsApi )
        {
            return FALSE ;
        }

        DnsValidateNameFn = (DNS_VALIDATE_NAME_FN *) GetProcAddress( DnsApi, "DnsValidateName_W" );

        if ( !DnsValidateNameFn )
        {
            FreeLibrary( DnsApi );

            return FALSE ;
        }

        DnsStatus = DnsValidateNameFn( lpName, DnsNameDomain );

        FreeLibrary( DnsApi );
    }
    else
    {
        DnsStatus = 0 ;
    }

    //
    // If the name is good, then keep it.
    //


    if ( ( DnsStatus == 0 ) ||
         ( DnsStatus == DNS_ERROR_NON_RFC_NAME ) )
    {
        Status = BaseSetNameInReg(
                        TCPIP_ROOT,
                        TCPIP_NV_DOMAINNAME,
                        lpName );
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER ;
    }



    if ( !NT_SUCCESS( Status ) )
    {
        BaseSetLastNTError( Status );

        return FALSE ;
    }
    return TRUE ;

}

BOOL
BaseSetAltNetBiosName(
    IN LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Sets the computer's alternate net bios name  

Arguments:
 
  lpComputerName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (!BaseValidateNetbiosName(lpComputerName)) {
	BaseSetLastNTError( STATUS_INVALID_PARAMETER );
	return(FALSE);
    }

    NtStatus = BaseAddMultiNameInReg( 
	ALT_COMPUTERNAME_NODE,
	COMPUTERNAME_OPTIONAL_NAME,
	lpComputerName );

    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseSetAltDnsFQHostname(
    IN LPCWSTR lpDnsFQHostname
    )
/*++

Routine Description:

    Sets the computer's alternate fully qualified Dns name  

Arguments:
 
  lpDnsFQHostname - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = BaseAddMultiNameInReg(
	DNSCACHE_ROOT,
	DNS_ALT_HOSTNAME,  
	lpDnsFQHostname);

    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseIsAltDnsFQHostname(
    LPCWSTR lpAltDnsFQHostname
    )
/*++

Routine Description:

    Verifies if lpAltDnsFQHostname is a previosly defined
    alternate dns name  

Arguments:
 
  lpDnsFQHostname - name to check

Return Value:

    TRUE if verifiably in use, FALSE otherwise, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpNames = NULL;
    ULONG cchNames = 0;
    BOOL fFound = FALSE;
    DWORD dwIndex = 0;
    DWORD err = ERROR_SUCCESS;

    NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT,
				   DNS_ALT_HOSTNAME,
				   lpNames,
				   &cchNames);

    if (NtStatus==STATUS_BUFFER_OVERFLOW) {
	lpNames = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchNames) * sizeof(WCHAR));
	if (lpNames!=NULL) { 
	    NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT,
					   DNS_ALT_HOSTNAME,
					   lpNames,
					   &cchNames);
	    err = RtlNtStatusToDosError(NtStatus);
	    if (err == ERROR_SUCCESS) {

		err = BaseGetMultiValueIndex(lpNames,
					     lpAltDnsFQHostname,
					     &dwIndex);
		fFound = err==ERROR_SUCCESS; 
	    }
	    RtlFreeHeap( RtlProcessHeap(), 0, lpNames);
	}
    }
    return fFound;
}

BOOL
BaseRemoveAltNetBiosName(
    IN LPCWSTR lpAltComputerName
    )
/*++

Routine Description:

    Removes an alternate net bios name  

Arguments:
 
    lpAltComputerName - name to remove

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = BaseRemoveMultiNameFromReg ( ALT_COMPUTERNAME_NODE,
					    COMPUTERNAME_OPTIONAL_NAME,
					    lpAltComputerName );
    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseRemoveAltDnsFQHostname(
    IN LPCWSTR lpAltDnsFQHostname
    )
/*++

Routine Description:

    Removes an alternate Dns hostname  

Arguments:
 
    lpAltDnsFqHostname - name to remove

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = BaseRemoveMultiNameFromReg ( DNSCACHE_ROOT,
					 DNS_ALT_HOSTNAME,
					 lpAltDnsFQHostname );
    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

DWORD
BaseEnumAltDnsFQHostnames(
    OUT LPWSTR lpAltDnsFQHostnames,
    IN OUT LPDWORD nSize
    )

/*++

Routine Description:

   Wrapper for BasepGetNameFromReg to return ERRORS, instead of STATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    status = BasepGetNameFromReg(
	DNSCACHE_ROOT,
	DNS_ALT_HOSTNAME,  
	lpAltDnsFQHostnames,
	nSize);

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
	if ((lpAltDnsFQHostnames!=NULL) && (*nSize>0)) {
	    lpAltDnsFQHostnames[0]=L'\0';
	    *nSize=0;
	    status=STATUS_SUCCESS;
	}
	else {
	    *nSize=1;
	    status=STATUS_BUFFER_OVERFLOW;
	} 
    }

    return RtlNtStatusToDosError(status);
}

BOOL
BaseIsNetBiosNameInUse(
    LPWSTR lpCompName
    )
/*++

Routine Description:

  Verify whether lpCompName is being used by any alternate DNS names 
  (ie whether any existing alternate DNS names map to lpCompName with 
  DnsHostnameToComputerNameW) 

Arguments:

    lpCompName - net bios name to verify
    
Return Value:

    FALSE if verifiably is not being used, true otherwise, GetLastError()    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpMultiValue = NULL;
    ULONG cchMultiValue = 0;
    LPWSTR lpAltDnsFQHostname = NULL;
    ULONG cchAltDnsHostname = 0;
    DWORD dwIndex = 0;
    LPWSTR lpAltCompName = NULL;
    ULONG cchAltCompName = 0;
    DWORD err = ERROR_SUCCESS;
    BOOL fInUse = FALSE;
    BOOL fIsNetBiosNameInUse = TRUE;

    NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT, 
				   DNS_ALT_HOSTNAME, 
				   lpMultiValue, 
				   &cchMultiValue);
    err = RtlNtStatusToDosError(NtStatus);
    if (err==ERROR_MORE_DATA) {
	lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchMultiValue * sizeof(WCHAR));
	if (lpMultiValue==NULL) {
	    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	    return TRUE;
	}
	NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT,
				       DNS_ALT_HOSTNAME,
				       lpMultiValue,
				       &cchMultiValue);
	err=RtlNtStatusToDosError(NtStatus); 
    }
    if ((err==ERROR_SUCCESS) && (lpMultiValue==NULL)) {
	return FALSE; // not in use if the reg values are null
    }
    if (err == ERROR_SUCCESS) {
	dwIndex = 0;
	while (err == ERROR_SUCCESS) { 
	    err = BasepGetMultiValueAddr(lpMultiValue,
					 dwIndex,
					 &lpAltDnsFQHostname,
					 &cchAltDnsHostname);

	    // get net bios names
	    if (err == ERROR_SUCCESS) {
		if (!DnsHostnameToComputerNameW(lpAltDnsFQHostname,
						      lpAltCompName,
						      &cchAltCompName)) {
		    err = GetLastError();
		    if (err==ERROR_MORE_DATA) {
			// DnsHostNameToComputerNameW bug
			cchAltCompName += 1;
			// DnsHostNameToComputerNameW bug

			lpAltCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchAltCompName*sizeof(WCHAR));
			if (lpAltCompName==NULL) {
			    err = ERROR_NOT_ENOUGH_MEMORY;
			}
			else if (!DnsHostnameToComputerNameW(lpAltDnsFQHostname, lpAltCompName, &cchAltCompName)) {
				err = GetLastError();
			} else {
			    err = ERROR_SUCCESS;
			}
		    }  
		}
		if (err==ERROR_SUCCESS) {
		    if (!_wcsicmp(lpAltCompName, lpCompName)) {
			fInUse = TRUE;
		    }
		}
	    }
	    dwIndex++;
	}
	
	// exits the above while loop when err==ERROR_NOT_FOUND, whether found or not
	if (err==ERROR_NOT_FOUND) {
	    fIsNetBiosNameInUse = fInUse;
	    err = ERROR_SUCCESS;
	}
	else {
	    // error, default to in use
	    fIsNetBiosNameInUse = TRUE;
	}
    }

    if (lpMultiValue) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpMultiValue);
    }
    if (lpAltCompName) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpAltCompName);
    }
    return fIsNetBiosNameInUse;
}


//
// UNICODE APIs
//

BOOL
WINAPI
GetComputerNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    )

/*++

Routine Description:

  This returns the active computername.  This is the computername when the
  system was last booted.  If this is changed (via SetComputerName) it does
  not take effect until the next system boot.


Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH + 1 to allow
        sufficient room in the buffer for the computer name.  The length
        of the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING Class;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
    HANDLE hNewKey = NULL;
    ULONG Disposition;
    ULONG ValueLength;
    BOOL ReturnValue;
    DWORD Status;
    DWORD errcode;

    //
    // First check to see if the cluster computername variable is set.
    // If so, this overrides the actual computername to fool the application
    // into working when its network name and computer name are different.
    //

    ValueLength = GetEnvironmentVariableW(L"_CLUSTER_NETWORK_NAME_",
                                          lpBuffer,
                                          *nSize);
    if (ValueLength != 0) {
        //
        // The environment variable exists, return it directly but make sure
        // we honor return semantics
        //
        ReturnValue = ( *nSize >= ValueLength ? TRUE : FALSE );
        if ( !ReturnValue ) {
            SetLastError( ERROR_BUFFER_OVERFLOW );
        }
        *nSize = ValueLength;
        return(ReturnValue);
    }


    if ( (gpTermsrvGetComputerName) &&
            ((errcode =  gpTermsrvGetComputerName(lpBuffer, nSize)) != ERROR_RETRY) ) {

        if (errcode == ERROR_BUFFER_OVERFLOW ) {
            ReturnValue = FALSE;
            goto Cleanup;

        } else {
            goto GoodReturn;
        }

    }

    //
    // Open the Computer node, both computername keys are relative
    // to this node.
    //

    RtlInitUnicodeString(&KeyName, COMPUTERNAME_ROOT);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // This should never happen!  This key should have been created
        // at setup, and protected by an ACL so that only the ADMIN could
        // write to it.  Generate an event, and return a NULL computername.
        //

        // NTRAID#NTBUG9-174986-2000/08/31-DavePr Log event or do alert or something.

        //
        // Return a NULL computername
        //

        if (ARGUMENT_PRESENT(lpBuffer))
        {
            lpBuffer[0] = L'\0';
        }
        *nSize = 0;
        goto GoodReturn;
    }

    if (!NT_SUCCESS(NtStatus)) {

        //
        // Some other error, return it to the caller
        //

        goto ErrorReturn;
    }

    //
    // Try to get the name from the volatile key
    //

    NtStatus = GetNameFromValue(hKey, VOLATILE_COMPUTERNAME, lpBuffer,
        nSize);

    //
    // The user's buffer wasn't big enough, just return the error.
    //

    if(NtStatus == STATUS_BUFFER_OVERFLOW) {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        ReturnValue = FALSE;
        goto Cleanup;
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // The volatile copy is already there, just return it
        //

        goto GoodReturn;
    }

    //
    // The volatile key isn't there, try for the non-volatile one
    //

    NtStatus = GetNameFromValue(hKey, NON_VOLATILE_COMPUTERNAME, lpBuffer,
        nSize);

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // This should never happen!  This value should have been created
        // at setup, and protected by an ACL so that only the ADMIN could
        // write to it.  Generate an event, and return an error to the
        // caller
        //

        // NTRAID#NTBUG9-174986-2000/08/31-DavePr Log event or do alert or something.

        //
        // Return a NULL computername
        //

        lpBuffer[0] = L'\0';
        *nSize = 0;
        goto GoodReturn;
    }

    if (!NT_SUCCESS(NtStatus)) {

        //
        // Some other error, return it to the caller
        //

        goto ErrorReturn;
    }

    //
    // Now create the volatile key to "lock this in" until the next boot
    //

    RtlInitUnicodeString(&Class, CLASS_STRING);

    //
    // Turn KeyName into a UNICODE_STRING
    //

    RtlInitUnicodeString(&KeyName, VOLATILE_COMPUTERNAME);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              hKey,
                              NULL
                              );

    //
    // Now create the key
    //

    NtStatus = NtCreateKey(&hNewKey,
                         KEY_WRITE | KEY_READ,
                         &ObjectAttributes,
                         0,
                         &Class,
                         REG_OPTION_VOLATILE,
                         &Disposition);

    if (Disposition == REG_OPENED_EXISTING_KEY) {

        //
        // Someone beat us to this, just get the value they put there
        //

        NtStatus = GetNameFromValue(hKey, VOLATILE_COMPUTERNAME, lpBuffer,
           nSize);

        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // This should never happen!  It just told me it existed
            //

            NtStatus = STATUS_UNSUCCESSFUL;
            goto ErrorReturn;
        }
    }

    //
    // Create the value under this key
    //

    RtlInitUnicodeString(&ValueName, COMPUTERNAME_VALUE_NAME);
    ValueLength = (wcslen(lpBuffer) + 1) * sizeof(WCHAR);
    NtStatus = NtSetValueKey(hNewKey,
                             &ValueName,
                             0,
                             REG_SZ,
                             lpBuffer,
                             ValueLength);

    if (!NT_SUCCESS(NtStatus)) {

        goto ErrorReturn;
    }

    goto GoodReturn;

ErrorReturn:

    //
    // An error was encountered, convert the status and return
    //

    BaseSetLastNTError(NtStatus);
    ReturnValue = FALSE;
    goto Cleanup;

GoodReturn:

    //
    // Everything went ok, update nSize with the length of the buffer and
    // return
    //

    *nSize = wcslen(lpBuffer);
    ReturnValue = TRUE;
    goto Cleanup;

Cleanup:

    if (hKey) {
        NtClose(hKey);
    }

    if (hNewKey) {
        NtClose(hNewKey);
    }

    return(ReturnValue);
}



BOOL
WINAPI
SetComputerNameW (
    LPCWSTR lpComputerName
    )

/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
    ULONG ValueLength;
    ULONG ComputerNameLength;
    ULONG AnsiComputerNameLength;

    //
    // Validate that the supplied computername is valid (not too long,
    // no incorrect characters, no leading or trailing spaces)
    //

    ComputerNameLength = wcslen(lpComputerName);

    //
    // The name length limitation should be based on ANSI. (LanMan compatibility)
    //

    NtStatus = RtlUnicodeToMultiByteSize(&AnsiComputerNameLength,
                                         (LPWSTR)lpComputerName,
                                         ComputerNameLength * sizeof(WCHAR));

    if ((!NT_SUCCESS(NtStatus)) ||
        (AnsiComputerNameLength == 0 )||(AnsiComputerNameLength > MAX_COMPUTERNAME_LENGTH)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for illegal characters; return an error if one is found
    //

    if (wcscspn(lpComputerName, ILLEGAL_NAME_CHARS_STR) < ComputerNameLength) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for leading or trailing spaces
    //

    if (lpComputerName[0] == L' ' ||
        lpComputerName[ComputerNameLength-1] == L' ') {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);

    }
    //
    // Open the ComputerName\ComputerName node
    //

    RtlInitUnicodeString(&KeyName, NON_VOLATILE_COMPUTERNAME_NODE);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtOpenKey(&hKey, KEY_READ | KEY_WRITE, &ObjectAttributes);

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // This should never happen!  This key should have been created
        // at setup, and protected by an ACL so that only the ADMIN could
        // write to it.  Generate an event, and return a NULL computername.
        //

        // NTRAID#NTBUG9-174986-2000/08/31-DavePr Log event or do alert or something.
        // (One alternative for this instance would be to actually create the missing
        // entry here -- but we'd have to be sure to get the right ACLs etc, etc.

        SetLastError(ERROR_GEN_FAILURE);
        return(FALSE);
    }

    //
    // Update the value under this key
    //

    RtlInitUnicodeString(&ValueName, COMPUTERNAME_VALUE_NAME);
    ValueLength = (wcslen(lpComputerName) + 1) * sizeof(WCHAR);
    NtStatus = NtSetValueKey(hKey,
                             &ValueName,
                             0,
                             REG_SZ,
                             (LPWSTR)lpComputerName,
                             ValueLength);

    if (!NT_SUCCESS(NtStatus)) {

        BaseSetLastNTError(NtStatus);
        NtClose(hKey);
        return(FALSE);
    }

    NtFlushKey(hKey);
    NtClose(hKey);
    return(TRUE);

}

BOOL
WINAPI
GetComputerNameExW(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )

/*++

Routine Description:

  This returns the active computername in a particular format.  This is the
  computername when the system was last booted.  If this is changed (via
  SetComputerName) it does not take effect until the next system boot.


Arguments:

    NameType - Possible name formats to return the computer name in:

        ComputerNameNetBIOS - netbios name (compatible with GetComputerName)
        ComputerNameDnsHostname - DNS host name
        ComputerNameDnsDomain - DNS Domain name
        ComputerNameDnsFullyQualified - DNS Fully Qualified (hostname.dnsdomain)

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH + 1 to allow
        sufficient room in the buffer for the computer name.  The length
        of the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    NTSTATUS Status ;
    DWORD ValueLength ;
    DWORD HostLength ;
    DWORD DomainLength ;
    BOOL DontSetReturn = FALSE ;
    COMPUTER_NAME_FORMAT HostNameFormat, DomainNameFormat ;


    if ( NameType >= ComputerNameMax )
    {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE ;
    }

    if ((nSize==NULL) || ((lpBuffer==NULL) && (*nSize>0))) {
	SetLastError(ERROR_INVALID_PARAMETER);
	return(FALSE);
    }

    //
    // For general names, allow clusters to override the physical name:
    //

    if ( (NameType >= ComputerNameNetBIOS) &&
         (NameType <= ComputerNameDnsFullyQualified ) )
    {
        ValueLength = GetEnvironmentVariableW(
                            ClusterNameVars[ NameType ],
                            lpBuffer,
                            *nSize );

        if ( ValueLength )
        {
            BOOL ReturnValue;
            //
            // ValueLength is the length+NULL of the env. string regardless of
            // how much was copied (gregjohn 1/30/01 note:  this isn't the behaivor
	    // of the rest of the function, which returns length+NULL on failure
	    // and length on success). Indicate how many characters are in the string
            // and if the user's buffer wasn't big enough, return FALSE
            // 
            ReturnValue = ( *nSize >= ValueLength ? TRUE : FALSE );
            if ( !ReturnValue ) {
                SetLastError( ERROR_MORE_DATA );
            }
            *nSize = ValueLength ;
            return ReturnValue;
        }
    }

    if ( lpBuffer && (*nSize > 0) )
    {
        lpBuffer[0] = L'\0';
    }

    switch ( NameType )
    {
        case ComputerNameNetBIOS:
        case ComputerNamePhysicalNetBIOS:
            Status = BasepGetNameFromReg(
                        VOLATILE_COMPUTERNAME_NODE,
                        COMPUTERNAME_VALUE_NAME,
                        lpBuffer,
                        nSize );
     
            if ( !NT_SUCCESS( Status ) )
            {
                if ( Status != STATUS_BUFFER_OVERFLOW )
                {
                    //
                    // Hmm, the value (or key) is missing.  Try the non-volatile
                    // one.
                    //

                    Status = BasepGetNameFromReg(
                                NON_VOLATILE_COMPUTERNAME_NODE,
                                COMPUTERNAME_VALUE_NAME,
                                lpBuffer,
                                nSize );


                }
            }

            break;

        case ComputerNameDnsHostname:
        case ComputerNamePhysicalDnsHostname:
            Status = BasepGetNameFromReg(
                        TCPIP_ROOT,
                        TCPIP_HOSTNAME,
                        lpBuffer,
                        nSize );

            break;

        case ComputerNameDnsDomain:
        case ComputerNamePhysicalDnsDomain:

	    //
	    //  Allow policy to override the domain name from the
	    //  tcpip key.
	    //

	    Status = BasepGetNameFromReg(
		TCPIP_POLICY_ROOT,
		TCPIP_POLICY_DOMAINNAME,
		lpBuffer,
		nSize );

	    //
            // If no policy read from the tcpip key.
            //

            if ( !NT_SUCCESS( Status ) )
            {
		if ( Status != STATUS_BUFFER_OVERFLOW )
                {
		    Status = BasepGetNameFromReg(
			TCPIP_ROOT,
			TCPIP_DOMAINNAME,
			lpBuffer,
			nSize );
		}
            }

            break;

        case ComputerNameDnsFullyQualified:
        case ComputerNamePhysicalDnsFullyQualified:

            //
            // This is the tricky case.  We have to construct the name from
            // the two components for the caller.
            //

            //
            // In general, don't set the last status, since we'll end up using
            // the other calls to handle that for us.
            //

            DontSetReturn = TRUE ;

            Status = STATUS_UNSUCCESSFUL ;

            if ( lpBuffer == NULL )
            {
                //
                // If this is just the computation call, quickly do the
                // two components
                //

                HostLength = DomainLength = 0 ;

                GetComputerNameExW( ComputerNameDnsHostname, NULL, &HostLength );

		if ( GetLastError() == ERROR_MORE_DATA )
                {
                    GetComputerNameExW( ComputerNameDnsDomain, NULL, &DomainLength );

                    if ( GetLastError() == ERROR_MORE_DATA )
                    {
                        //
                        // Simply add.  Note that since both account for a
                        // null terminator, the '.' that goes between them is
                        // covered.
                        //

                        *nSize = HostLength + DomainLength ;

                        Status = STATUS_BUFFER_OVERFLOW ;

                        DontSetReturn = FALSE ;
                    }
                }
            }
            else
            {
                HostLength = *nSize ;

                if ( GetComputerNameExW( ComputerNameDnsHostname,
                                         lpBuffer,
                                         &HostLength ) )
                {
                    
                    HostLength += 1; // Add in the zero character (or . depending on perspective)
                    lpBuffer[ HostLength - 1 ] = L'.';

                    DomainLength = *nSize - HostLength ;

                    if (GetComputerNameExW( ComputerNameDnsDomain,
                                            &lpBuffer[ HostLength ],
                                            &DomainLength ) )
                    {
                        Status = STATUS_SUCCESS ;

                        if ( DomainLength == 0 )
                        {
                            lpBuffer[ HostLength - 1 ] = L'\0';
                            HostLength-- ;
                        }
                        else if ( ( DomainLength == 1 ) && 
                                  ( lpBuffer[ HostLength ] == L'.' ) )
                        {
                            //
                            // Legally, the domain name can be a single
                            // dot '.', indicating that this host is part
                            // of the root domain.  An odd case, to be sure, 
                            // but needs to be handled.  Since we've already
                            // stuck a dot separator in the result string,
                            // get rid of this one, and adjust the values
                            // accordingly.
                            //
                            lpBuffer[ HostLength ] = L'\0' ;
                            DomainLength = 0 ;
                        }

                        *nSize = HostLength + DomainLength ;

                        DontSetReturn = TRUE ;
                    }
                    else if ( GetLastError() == ERROR_MORE_DATA )
                    {
                        //
                        // Simply add.  Note that since both account for a
                        // null terminator, the '.' that goes between them is
                        // covered.
                        //

                        *nSize = HostLength + DomainLength ;

                        Status = STATUS_BUFFER_OVERFLOW ;

                        DontSetReturn = FALSE ;
                    }
                    else
                    {
                        //
                        // Other error from trying to get the DNS Domain name.
                        // Let the error from the call trickle back.
                        //

                        *nSize = 0 ;

                        Status = STATUS_UNSUCCESSFUL ;

                        DontSetReturn = TRUE ;
                    }

                }
                else if ( GetLastError() == ERROR_MORE_DATA )
                {
                    DomainLength = 0;
                    GetComputerNameExW( ComputerNameDnsDomain, NULL, &DomainLength );

                    if ( GetLastError() == ERROR_MORE_DATA )
                    {
                        //
                        // Simply add.  Note that since both account for a
                        // null terminator, the '.' that goes between them is
                        // covered.
                        //

                        *nSize = HostLength + DomainLength ;

                        Status = STATUS_BUFFER_OVERFLOW ;

                        DontSetReturn = FALSE ;
                    }
                }
                else
                {

                    //
                    // Other error from trying to get the DNS Hostname.
                    // Let the error from the call trickle back.
                    //

                    *nSize = 0 ;

                    Status = STATUS_UNSUCCESSFUL ;

                    DontSetReturn = TRUE ;
                }
            }


            break;



    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( !DontSetReturn )
        {
            BaseSetLastNTError( Status );
        }
        return FALSE ;
    }

    return TRUE ;
}

BOOL
WINAPI
SetComputerNameExW(
    IN COMPUTER_NAME_FORMAT NameType,
    IN LPCWSTR lpBuffer
    )

/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    NameType - Name to set for the system

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{
    ULONG Length ;

    //
    // Validate name:
    //

    if ( !lpBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE ;
    }

    Length = wcslen( lpBuffer );

    if ( Length )
    {
        if ( ( lpBuffer[0] == L' ') ||
             ( lpBuffer[ Length - 1 ] == L' ' ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE ;
        }

    }

    if (wcscspn(lpBuffer, ILLEGAL_NAME_CHARS_STR) < Length) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch ( NameType ) {
    
    case ComputerNamePhysicalNetBIOS:
	return BaseSetNetbiosName( lpBuffer );

    case ComputerNamePhysicalDnsHostname:    
	return (BaseValidateDnsHostname(lpBuffer) && BaseSetDnsName( lpBuffer ));
    case ComputerNamePhysicalDnsDomain:
	return (BaseValidateDnsDomain(lpBuffer) && BaseSetDnsDomain( lpBuffer ));
    default:
	SetLastError( ERROR_INVALID_PARAMETER );
	return FALSE ;

    }
}


//
// ANSI APIs
//

BOOL
WINAPI
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    )

/*++

Routine Description:

  This returns the active computername.  This is the computername when the
  system was last booted.  If this is changed (via SetComputerName) it does
  not take effect until the next system boot.


Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH to allow
        sufficient room in the buffer for the computer name.  The length of
        the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{

    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPWSTR UnicodeBuffer;
    ULONG AnsiSize;
    ULONG UnicodeSize;
    NTSTATUS Status;

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    AnsiString.MaximumLength = (USHORT) *nSize;
    AnsiString.Length = 0;
    AnsiString.Buffer = lpBuffer;

    //
    // Call the UNICODE version to do the work
    //

    UnicodeSize = *nSize ;

    if (!GetComputerNameW(UnicodeBuffer, &UnicodeSize)) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Find out the required size of the ANSI buffer and validate it against
    // the passed in buffer size
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);
    AnsiSize = RtlUnicodeStringToAnsiSize(&UnicodeString);
    if (AnsiSize > *nSize) {

        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);

        BaseSetLastNTError( STATUS_BUFFER_OVERFLOW );

        *nSize = AnsiSize + 1 ;

        return(FALSE);
    }


    //
    // Now convert back to ANSI for the caller
    //

    Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        *nSize = 0;
        return FALSE;
    }

    *nSize = AnsiString.Length;
    return(TRUE);

}



BOOL
WINAPI
SetComputerNameA (
    LPCSTR lpComputerName
    )

/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{

    NTSTATUS NtStatus;
    BOOL ReturnValue;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    ULONG ComputerNameLength;

    //
    // Validate that the supplied computername is valid (not too long,
    // no incorrect characters, no leading or trailing spaces)
    //

    ComputerNameLength = strlen(lpComputerName);
    if ((ComputerNameLength == 0 )||(ComputerNameLength > MAX_COMPUTERNAME_LENGTH)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString(&AnsiString, lpComputerName);
    NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
        TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    ReturnValue = SetComputerNameW((LPCWSTR)UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);
}

BOOL
WINAPI
GetComputerNameExA(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
/*++

Routine Description:

  This returns the active computername in a particular format.  This is the
  computername when the system was last booted.  If this is changed (via
  SetComputerName) it does not take effect until the next system boot.


Arguments:

    NameType - Possible name formats to return the computer name in:

        ComputerNameNetBIOS - netbios name (compatible with GetComputerName)
        ComputerNameDnsHostname - DNS host name
        ComputerNameDnsDomain - DNS Domain name
        ComputerNameDnsFullyQualified - DNS Fully Qualified (hostname.dnsdomain)

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH + 1 to allow
        sufficient room in the buffer for the computer name.  The length
        of the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    LPWSTR UnicodeBuffer;

    //
    // Validate Input
    // 

    if ((nSize==NULL) || ((lpBuffer==NULL) && (*nSize>0))) {
	SetLastError(ERROR_INVALID_PARAMETER);
	return(FALSE);
    }

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
   
    //
    // Call the UNICODE version to do the work
    //

    if ( !GetComputerNameExW(NameType, UnicodeBuffer, nSize) ) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    // Note:  Since we passed the above if statement, 
    // GetComputerNameExW succeeded, and set *nSize to the number of
    // characters in the string (like wcslen).  We need to convert
    // all these characters and the trailing NULL, so inc *nSize for
    // the conversion call.
    //

    WideCharToMultiByte(CP_ACP,
			0,
			UnicodeBuffer,
			*nSize+1,
			lpBuffer,
			(*nSize+1) * sizeof(CHAR), 
			NULL, 
			NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);


}

BOOL
WINAPI
SetComputerNameExA(
    IN COMPUTER_NAME_FORMAT NameType,
    IN LPCSTR lpBuffer
    )
/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    NameType - Name to set for the system

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{
    NTSTATUS NtStatus;
    BOOL ReturnValue;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;


    RtlInitAnsiString(&AnsiString, lpBuffer);
    NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
        TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    ReturnValue = SetComputerNameExW(NameType, (LPCWSTR)UnicodeString.Buffer );
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);
}

DWORD
WINAPI
AddLocalAlternateComputerNameW(
    LPCWSTR lpDnsFQHostname,
    ULONG   ulFlags
    )
/*++

Routine Description:

    This sets an alternate computer name for the computer to begin to
    respond to.  


Arguments:

    lpDnsFQHostname - The alternate name to add (in ComputerNameDnsFullyQualified Format)

    ulFlags - TBD

Return Value:

    Returns ERROR

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    DWORD err = ERROR_SUCCESS;
    LPWSTR lpNetBiosCompName = NULL;
    ULONG ulNetBiosCompNameSize = 0;

    //
    // validate input
    //

    if ((lpDnsFQHostname==NULL) || (!BaseValidateFlags(ulFlags)) || (!BaseValidateFQDnsName(lpDnsFQHostname))) {
	return ERROR_INVALID_PARAMETER;
    }

    // get write lock?

    status = BaseAddMultiNameInReg(
	DNSCACHE_ROOT,
	DNS_ALT_HOSTNAME,  
	lpDnsFQHostname);

    err = RtlNtStatusToDosError(status);
    
    if (err==ERROR_SUCCESS) {
	// get NetBios name (use DNSHostNameToComputerNameW) and add that to reg for OptionalNames
	if (!DnsHostnameToComputerNameW(
	    lpDnsFQHostname,
	    NULL,
	    &ulNetBiosCompNameSize)) {
	    err = GetLastError(); 
	}

	if (err==ERROR_MORE_DATA) {
	    // bug in DNSHostname, returns a size 1 character too small	(forgets null) 
	    // update when bug is fixed...
	    ulNetBiosCompNameSize += 1;
	    lpNetBiosCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), ulNetBiosCompNameSize * sizeof(WCHAR));
	    if (lpNetBiosCompName==NULL) {  
		err = ERROR_NOT_ENOUGH_MEMORY;
	    }
	    else {  
		if (!DnsHostnameToComputerNameW(lpDnsFQHostname, 
						lpNetBiosCompName,
						&ulNetBiosCompNameSize)) {
		    err = GetLastError();
		}
		else if (!BaseSetAltNetBiosName(lpNetBiosCompName)) {
		    err = GetLastError();
		} else {
		    err = ERROR_SUCCESS;
		}
		RtlFreeHeap(RtlProcessHeap(), 0, lpNetBiosCompName);  
	    }
	}

	if (err!=ERROR_SUCCESS) {
	    // remove multi name in reg
	    // rollback?
	}
    }
    // release write lock?
    return err;
}

DWORD
WINAPI
AddLocalAlternateComputerNameA(
    LPCSTR lpDnsFQHostname,
    ULONG  ulFlags
    )
{

    LPWSTR lpDnsFQHostnameW = NULL;
    DWORD err = ERROR_SUCCESS;

    if (lpDnsFQHostname==NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    err = BaseMultiByteToWideCharWithAlloc(lpDnsFQHostname, &lpDnsFQHostnameW);

    if (err==ERROR_SUCCESS) {
	err = AddLocalAlternateComputerNameW(lpDnsFQHostnameW, ulFlags);
    }

    BaseConvertCharFree((VOID *)lpDnsFQHostnameW);
    return err;
}

DWORD
WINAPI
RemoveLocalAlternateComputerNameW(
    LPCWSTR lpAltDnsFQHostname,
    ULONG ulFlags
    )
/*++

Routine Description:

    Remove an alternate computer name.  


Arguments:

    lpAltDnsFQHostname - The alternate name to remove(in ComputerNameDnsFullyQualified Format)

    ulFlags - TBD

Return Value:

    Returns ERROR

--*/
{
    DWORD err = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpAltNetBiosCompName = NULL;
    ULONG cchAltNetBiosCompName = 0;

    if ((!BaseValidateFlags(ulFlags)) || (lpAltDnsFQHostname==NULL)) {
	return ERROR_INVALID_PARAMETER;
    }    
    
    // aquire a write lock?

    NtStatus = BaseRemoveMultiNameFromReg(DNSCACHE_ROOT, DNS_ALT_HOSTNAME, lpAltDnsFQHostname);
    err = RtlNtStatusToDosError(NtStatus);

    if (err==ERROR_SUCCESS) {
	if (!DnsHostnameToComputerNameW(
	    lpAltDnsFQHostname,
	    NULL,
	    &cchAltNetBiosCompName)) {
	    err = GetLastError(); 
	}
	if (err==ERROR_MORE_DATA) {
	    // bug in DNSHostname, returns a size 1 character too small	(forgets null)
	    cchAltNetBiosCompName += 1;
	    lpAltNetBiosCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchAltNetBiosCompName * sizeof(WCHAR));
	    if (lpAltNetBiosCompName==NULL) {  
		err = ERROR_NOT_ENOUGH_MEMORY;
	    }
	    else {    
		if (!DnsHostnameToComputerNameW(lpAltDnsFQHostname, 
						lpAltNetBiosCompName,
						&cchAltNetBiosCompName)) {
		    err = GetLastError();  
		} else if (BaseIsNetBiosNameInUse(lpAltNetBiosCompName)) {
		    err = ERROR_SUCCESS;
		    // do nothing, this name is still being used by another AltDnsHostname ...  
		} else if (!BaseRemoveAltNetBiosName(lpAltNetBiosCompName)) {
		    err = GetLastError();
		} else {
		    err = ERROR_SUCCESS;
		}
		RtlFreeHeap(RtlProcessHeap(), 0, lpAltNetBiosCompName);
	    } 
	}
    }

    // release write lock?

    return err;
}

DWORD 
WINAPI
RemoveLocalAlternateComputerNameA(
    LPCSTR lpAltDnsFQHostname,
    ULONG  ulFlags
    )
{
    LPWSTR lpAltDnsFQHostnameW = NULL;
    DWORD err = ERROR_SUCCESS;

    if (lpAltDnsFQHostname==NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    err = BaseMultiByteToWideCharWithAlloc(lpAltDnsFQHostname, &lpAltDnsFQHostnameW);

    if (err==ERROR_SUCCESS) {
	err = RemoveLocalAlternateComputerNameW(lpAltDnsFQHostnameW, ulFlags);
    }

    BaseConvertCharFree((VOID *)lpAltDnsFQHostnameW);
    return err;
}

DWORD
WINAPI
SetLocalPrimaryComputerNameW(
    LPCWSTR lpAltDnsFQHostname,
    ULONG   ulFlags
    )
/*++

Routine Description:

    Set the computer name to the inputed altCompName


Arguments:

    lpAltDnsFQHostname - The name to set the computer to (in ComputerNameDnsFullyQualified Format)

    ulFlags - TBD

Return Value:

    Returns ERROR

--*/
{

    DWORD err = ERROR_SUCCESS;
    ULONG cchNetBiosName = 0;
    LPWSTR lpNetBiosName = NULL;
    ULONG cchCompName = 0;
    LPWSTR lpCompName = NULL;
    LPWSTR lpHostname = BaseParseDnsName(lpAltDnsFQHostname, DNS_HOSTNAME);
    LPWSTR lpDomainName = BaseParseDnsName(lpAltDnsFQHostname, DNS_DOMAINNAME);
  
    if ((lpAltDnsFQHostname==NULL) || (!BaseValidateFlags(ulFlags))) {
	return ERROR_INVALID_PARAMETER;
    }
     
    // aquire a write lock?

    // check to see that the given name is a valid alternate dns hostname
    if (!BaseIsAltDnsFQHostname(lpAltDnsFQHostname)) {
	if (lpHostname) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpHostname);
	}
	if (lpDomainName) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpDomainName);
	}
	return ERROR_INVALID_PARAMETER;
    }
    
    // get the current netbios name and add it to the alternate names
    if (!GetComputerNameExW(ComputerNamePhysicalNetBIOS, NULL, &cchNetBiosName)) {
	err = GetLastError();
    }
    if (err==ERROR_MORE_DATA) {
	lpNetBiosName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchNetBiosName*sizeof(WCHAR));
	if (lpNetBiosName==NULL) {
	    err = ERROR_NOT_ENOUGH_MEMORY;
	}
	else if (!GetComputerNameExW(ComputerNamePhysicalNetBIOS, lpNetBiosName, &cchNetBiosName)) {
	    err = GetLastError();
	}
	else if (!BaseSetAltNetBiosName(lpNetBiosName)) {
	    err = GetLastError();
	} 
	else {
	    err = ERROR_SUCCESS;
	}
	if (lpNetBiosName) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpNetBiosName);
	}
    }
    // get the current non-volatile netbios name and add it to the alternate names	
    lpNetBiosName = BasepGetNameNonVolatile(ComputerNamePhysicalNetBIOS);
    if (lpNetBiosName!=NULL) {
	if (!BaseSetAltNetBiosName(lpNetBiosName)) {
	    err = GetLastError();
	}
	else {
	    err = ERROR_SUCCESS;
	}
	RtlFreeHeap(RtlProcessHeap(), 0, lpNetBiosName);
    }

    if (err==ERROR_SUCCESS) {
	// add the current physical dnsname to the list of alternate hostnames...
	
	if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, NULL, &cchCompName)) {
	    err = GetLastError();
	}
	if (err==ERROR_MORE_DATA) {
	    lpCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchCompName*sizeof(WCHAR));
	    if (lpCompName==NULL) {
		err = ERROR_NOT_ENOUGH_MEMORY;
	    }
	    else if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, lpCompName, &cchCompName)) {
		err = GetLastError(); 
	    }
	    else if (!BaseSetAltDnsFQHostname(lpCompName)) {
		err = GetLastError(); 
	    }
	    else {
		err = ERROR_SUCCESS;
	    }
	    if (lpCompName) {
		RtlFreeHeap(RtlProcessHeap(), 0, lpCompName);
	    }
	}
    }

    if (err==ERROR_SUCCESS) {
	// add the non-volitile physical dnsname to the list of alternate hostnames...	
	lpCompName = BasepGetNameNonVolatile(ComputerNamePhysicalDnsFullyQualified);
	if (lpNetBiosName!=NULL) {
	    if (!BaseSetAltDnsFQHostname(lpCompName)) {
		err = GetLastError();
	    }
	    else {
		err = ERROR_SUCCESS;
	}
	    RtlFreeHeap(RtlProcessHeap(), 0, lpCompName);
	}
    }
 
    // set the new physical dns hostname
    if (err==ERROR_SUCCESS) { 
	if (!SetComputerNameExW(ComputerNamePhysicalDnsHostname, lpHostname)) {
	    err = GetLastError();
	} 
    }

    if (err==ERROR_SUCCESS) { 
	if (!SetComputerNameExW(ComputerNamePhysicalDnsDomain, lpDomainName)) {
	    err = GetLastError();
	} 
    }

    // remove the alternate name (now primary) from the alternate lists
    if (err==ERROR_SUCCESS) {
	err = RemoveLocalAlternateComputerNameW(lpAltDnsFQHostname, 0);
    }

    if (lpHostname) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpHostname);
    }
    if (lpDomainName) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpDomainName);
    }
    // release write lock?

    return err;
    
}

DWORD
WINAPI
SetLocalPrimaryComputerNameA(
    LPCSTR lpAltDnsFQHostname,
    ULONG  ulFlags
    )
{
    LPWSTR lpAltDnsFQHostnameW = NULL;
    DWORD err = ERROR_SUCCESS;

    if (lpAltDnsFQHostname==NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    err = BaseMultiByteToWideCharWithAlloc(lpAltDnsFQHostname, &lpAltDnsFQHostnameW);
    if (err == ERROR_SUCCESS) {
	err = SetLocalPrimaryComputerNameW(lpAltDnsFQHostnameW, ulFlags);
    }
    BaseConvertCharFree((VOID *)lpAltDnsFQHostnameW);

    return err;
}

DWORD
WINAPI
EnumerateLocalComputerNamesW(
    COMPUTER_NAME_TYPE       NameType,
    ULONG                    ulFlags,
    LPWSTR                   lpDnsFQHostnames,
    LPDWORD                  nSize    
    )
/*++

Routine Description: 

    Returns the value of the computer's names requested.  The returned values are concatenated together,
    with a trailing NULl terminating the output (since each name is a LPWSTR, the end of lpDnsFQHostname
    has 2 NULLS, one for the last name, and one to terminate lpDnsFQHostname).
    

Arguments:

    NameType - Which of the computer's names are requested
	PrimaryComputerName - Similar to GetComputerEx(ComputerNamePhysicalNetBios, ...
	AlternateComputerNames - All known alt names
	AllComputerNames - All of the above
	
    ulFlags - TBD
    
    lpBuffer - Buffer to hold returned names concatenated together, and trailed with a NULL
    
    nSize - Size of buffer to hold returned names.

Return Value:

    Returns ERROR

--*/
{
    DWORD err = ERROR_SUCCESS;
    DWORD SizePrimary = 0;
    DWORD SizeAlternate = 0;
    LPWSTR lpTempCompNames = NULL;

    if ((!BaseValidateFlags(ulFlags)) || (NameType>=ComputerNameTypeMax) || (NameType<PrimaryComputerName)) { 
	return ERROR_INVALID_PARAMETER;
    }

    // get read lock?
    switch(NameType) {
    case PrimaryComputerName:  
	if (nSize==NULL) {
	    err = ERROR_INVALID_PARAMETER;
	}
	else { 
	    SizePrimary = *nSize ? *nSize - 1 : *nSize; // if *nSize == 0, pass in 0 else pass in *nSize - 1
	    if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, lpDnsFQHostnames, &SizePrimary)) {
		err = GetLastError();
	    }
	    else {
		if (lpDnsFQHostnames!=NULL) { 
		    // this test should be purely for prefix's benefit
		    // GetComputerNameExW *should* never return successfully if lpDnsFQHostnames
		    // is NULL.
		    lpDnsFQHostnames[SizePrimary + 1] = L'\0';
		} else {
		    // should NEVER happen - can't assert or log here, so just error out.
		    err = ERROR_GEN_FAILURE;
		}
	    }
	    *nSize = SizePrimary + 1; 
	}
	break;
    case AlternateComputerNames:
	if ((nSize==NULL) || ((lpDnsFQHostnames==NULL) && (*nSize>0))) {
	    err = ERROR_INVALID_PARAMETER;
	}
	else {
	    err = BaseEnumAltDnsFQHostnames(lpDnsFQHostnames, nSize);
	}
	break;
    case AllComputerNames:
	if ((nSize==NULL) || ((lpDnsFQHostnames==NULL) && (*nSize>0))) {
	    err = ERROR_INVALID_PARAMETER;
	}
	else {
	    SizePrimary = *nSize;
	    lpTempCompNames = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
	    if (lpTempCompNames==NULL) {
		err = ERROR_NOT_ENOUGH_MEMORY;
		break;
	    }
	    // Get primary name
	    if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, lpTempCompNames, &SizePrimary)) {
		err = GetLastError();
	    }

	    // on success, holds the number of characters copied into lpTempCompNames NOT counting NULL
	    // on failure, holds the space needed to copy in, (num characters PLUS NULL)
	    if (err==ERROR_SUCCESS) { 
		SizeAlternate = *nSize - (SizePrimary + 1); 
		err = BaseEnumAltDnsFQHostnames(lpTempCompNames+SizePrimary+1, &SizeAlternate);  
		*nSize = SizePrimary + 1 + SizeAlternate;
		if (err==ERROR_SUCCESS) { 
		    memcpy(lpDnsFQHostnames, lpTempCompNames, (*nSize+1)*sizeof(WCHAR));
		}  
	    }
	    else if (err==ERROR_MORE_DATA) {
		// return total size required
		SizeAlternate = 0;
		err = BaseEnumAltDnsFQHostnames(NULL, &SizeAlternate);
		if (err==ERROR_SUCCESS) {
		    // no alt names exist, keep ERROR_MORE_DATA to return to client
		    err = ERROR_MORE_DATA;
		}
		*nSize = SizePrimary + SizeAlternate;
	    }
	    RtlFreeHeap(RtlProcessHeap(), 0, lpTempCompNames); 
	}
	break;
    default:
	err = ERROR_INVALID_PARAMETER;
	break;
    }
    // release read lock?
    return err;
}

DWORD
WINAPI
EnumerateLocalComputerNamesA(
    COMPUTER_NAME_TYPE      NameType,
    ULONG                   ulFlags,
    LPSTR                   lpDnsFQHostnames,
    LPDWORD                 nSize
    )
{
    DWORD err = ERROR_SUCCESS;
    LPWSTR lpDnsFQHostnamesW = NULL;
    
    //
    // Validate Input
    // 

    if ((nSize==NULL) || ((lpDnsFQHostnames==NULL) && (*nSize>0))) {
	return ERROR_INVALID_PARAMETER;
    }
    
    if (lpDnsFQHostnames!=NULL) {
	lpDnsFQHostnamesW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
	if (lpDnsFQHostnamesW==NULL) {
	    err = ERROR_NOT_ENOUGH_MEMORY;
	}
    }

    if (err==ERROR_SUCCESS) {
	err = EnumerateLocalComputerNamesW(NameType, ulFlags, lpDnsFQHostnamesW, nSize);
    }

    if (err==ERROR_SUCCESS) {
	if (!WideCharToMultiByte(CP_ACP, 0, lpDnsFQHostnamesW, *nSize+1,
				 lpDnsFQHostnames, (*nSize+1)* sizeof(CHAR), NULL, NULL)) {
	    err = GetLastError();
	}
    }

    if (lpDnsFQHostnamesW) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpDnsFQHostnamesW);
    }
    return err;

}

BOOL
WINAPI
DnsHostnameToComputerNameW(
    IN LPCWSTR Hostname,
    OUT LPWSTR ComputerName,
    IN OUT LPDWORD nSize)
/*++

Routine Description:

    This routine will convert a DNS Hostname to a Win32 Computer Name.

Arguments:

    Hostname - DNS Hostname (any length)

    ComputerName - Win32 Computer Name (max length of MAX_COMPUTERNAME_LENGTH)

    nSize - On input, size of the buffer pointed to by ComputerName.  On output,
            size of the Computer Name, in characters.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/

{
    WCHAR CompName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD Size = MAX_COMPUTERNAME_LENGTH + 1 ;
    UNICODE_STRING CompName_U ;
    UNICODE_STRING Hostname_U ;
    NTSTATUS Status ;
    BOOL Ret ;

    CompName[0] = L'\0';
    CompName_U.Buffer = CompName ;
    CompName_U.Length = 0 ;
    CompName_U.MaximumLength = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof( WCHAR );

    RtlInitUnicodeString( &Hostname_U, Hostname );

    Status = RtlDnsHostNameToComputerName( &CompName_U,
                                           &Hostname_U,
                                           FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        if ( *nSize >= CompName_U.Length / sizeof(WCHAR) + 1 )
        {
            RtlCopyMemory( ComputerName,
                           CompName_U.Buffer,
                           CompName_U.Length );

            ComputerName[ CompName_U.Length / sizeof( WCHAR ) ] = L'\0';

            Ret = TRUE ;
        }
        else
        {
            BaseSetLastNTError( STATUS_BUFFER_OVERFLOW );
            Ret = FALSE ;
        }

        //
        // returns the count of characters
        //

        *nSize = CompName_U.Length / sizeof( WCHAR );
    }
    else
    {
        BaseSetLastNTError( Status );

        Ret = FALSE ;
    }

    return Ret ;

}

BOOL
WINAPI
DnsHostnameToComputerNameA(
    IN LPCSTR Hostname,
    OUT LPSTR ComputerName,
    IN OUT LPDWORD nSize)
/*++

Routine Description:

    This routine will convert a DNS Hostname to a Win32 Computer Name.

Arguments:

    Hostname - DNS Hostname (any length)

    ComputerName - Win32 Computer Name (max length of MAX_COMPUTERNAME_LENGTH)

    nSize - On input, size of the buffer pointed to by ComputerName.  On output,
            size of the Computer Name, in characters.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{
    WCHAR CompName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD Size = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL Ret ;
    UNICODE_STRING CompName_U ;
    UNICODE_STRING Hostname_U ;
    NTSTATUS Status ;
    ANSI_STRING CompName_A ;


    

    if ( RtlCreateUnicodeStringFromAsciiz( &Hostname_U, Hostname ) )
    {
        CompName[0] = L'\0';
        CompName_U.Buffer = CompName ;
        CompName_U.Length = 0 ;
        CompName_U.MaximumLength = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof( WCHAR );

        Status = RtlDnsHostNameToComputerName( &CompName_U,
                                               &Hostname_U,
                                               FALSE );

        if ( NT_SUCCESS( Status ) )
        {
            CompName_A.Buffer = ComputerName ;
            CompName_A.Length = 0 ;
            CompName_A.MaximumLength = (USHORT) *nSize ;

            Status = RtlUnicodeStringToAnsiString( &CompName_A, &CompName_U, FALSE );

            if ( NT_SUCCESS( Status ) )
            {
                *nSize = CompName_A.Length ;
            }

        }

    } else {
	Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        BaseSetLastNTError( Status );
        return FALSE ;
    }

    return TRUE ;

}





#include "dfsfsctl.h"
DWORD
BasepGetComputerNameFromNtPath (
    PUNICODE_STRING NtPathName,
    HANDLE hFile,
    LPWSTR lpBuffer,
    LPDWORD nSize
    )

/*++

Routine Description:

  Look at a path and determine the computer name of the host machine.
  In the future, we should remove this code, and add the capbility to query
  handles for their computer name.

  The name can only be obtained for NetBios paths - if the path is IP or DNS
  an error is returned.  (If the NetBios name has a "." in it, it will
  cause an error because it will be misinterpreted as a DNS path.  This case
  becomes less and less likely as the NT5 UI doesn't allow such computer names.)
  For DFS paths, the leaf server's name is returned, as long as it wasn't
  joined to its parent with an IP or DNS path name.

Arguments:

  NtPathName - points to a unicode string with the path to query.
  lpBuffer - points to buffer receives the computer name
  nSize - points to dword with the size of the input buffer, and the length
    (in characters, not including the null terminator) of the computer name
    on output.

Return Value:

    A Win32 error code.

--*/
{
    ULONG cbComputer = 0;
    DWORD dwError = ERROR_BAD_PATHNAME;
    ULONG AvailableLength = 0;
    PWCHAR PathCharacter = NULL;
    BOOL CheckForDfs = TRUE;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR FileNameInfoBuffer[MAX_PATH+sizeof(FILE_NAME_INFORMATION)];
    PFILE_NAME_INFORMATION FileNameInfo = (PFILE_NAME_INFORMATION)FileNameInfoBuffer;
    WCHAR DfsServerPathName[ MAX_PATH + 1 ];
    WCHAR DosDevice[3] = { L"A:" };
    WCHAR DosDeviceMapping[ MAX_PATH + 1 ];


    UNICODE_STRING UnicodeComputerName;

    const UNICODE_STRING NtUncPathNamePrefix = { 16, 18, L"\\??\\UNC\\"};
    const ULONG cchNtUncPathNamePrefix = 8;

    const UNICODE_STRING NtDrivePathNamePrefix = { 8, 10, L"\\??\\" };
    const ULONG cchNtDrivePathNamePrefix = 4;

    RtlInitUnicodeString( &UnicodeComputerName, NULL );

    // Is this a UNC path?

    if( RtlPrefixString( (PSTRING)&NtUncPathNamePrefix, (PSTRING)NtPathName, TRUE )) {

        // Make sure there's some more to this path than just the prefix
        if( NtPathName->Length <= NtUncPathNamePrefix.Length )
            goto Exit;

        // It appears to be a valid UNC path.  Point to the beginning of the computer
        // name, and calculate how much room is left in NtPathName after that.

        UnicodeComputerName.Buffer = &NtPathName->Buffer[ NtUncPathNamePrefix.Length/sizeof(WCHAR) ];
        AvailableLength = NtPathName->Length - NtUncPathNamePrefix.Length;

    }

    // If it's not a UNC path, then is it a drive-letter path?

    else if( RtlPrefixString( (PSTRING)&NtDrivePathNamePrefix, (PSTRING)NtPathName, TRUE )
             &&
             NtPathName->Buffer[ cchNtDrivePathNamePrefix + 1 ] == L':' ) {

        // It's a drive letter path, but it could still be local or remote

        static const WCHAR RedirectorMappingPrefix[] = { L"\\Device\\LanmanRedirector\\;" };
        static const WCHAR LocalVolumeMappingPrefix[] = { L"\\Device\\Harddisk" };
        static const WCHAR CDRomMappingPrefix[] = { L"\\Device\\CdRom" };
        static const WCHAR FloppyMappingPrefix[] = { L"\\Device\\Floppy" };
        static const WCHAR DfsMappingPrefix[] = { L"\\Device\\WinDfs\\" };

        // Get the correct, upper-cased, drive letter into DosDevice.

        DosDevice[0] = NtPathName->Buffer[ cchNtDrivePathNamePrefix ];
        if( L'a' <= DosDevice[0] && DosDevice[0] <= L'z' )
            DosDevice[0] = L'A' + (DosDevice[0] - L'a');

        // Map the drive letter to its symbolic link under \??.  E.g., say C:, D: & R:
        // are local/DFS/rdr drives, respectively.  You would then see something like:
        //
        //   C: => \Device\Volume1
        //   D: => \Device\WinDfs\G
        //   R: => \Device\LanmanRedirector\;R:0\scratch\scratch

        if( !QueryDosDeviceW( DosDevice, DosDeviceMapping, sizeof(DosDeviceMapping)/sizeof(DosDeviceMapping[0]) )) {
            dwError = GetLastError();
            goto Exit;
        }

        // Now that we have the DosDeviceMapping, we can check ... Is this a rdr drive?

        if( // Does it begin with "\Device\LanmanRedirector\;" ?
            DosDeviceMapping == wcsstr( DosDeviceMapping, RedirectorMappingPrefix )
            &&
            // Are the next letters the correct drive letter, a colon, and a whack?
            ( DosDevice[0] == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) - 1 ]
              &&
              L':' == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) ]
              &&
              (UnicodeComputerName.Buffer = wcschr(&DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) + 1 ], L'\\'))
            )) {

            // We have a valid rdr drive.  Point to the beginning of the computer
            // name, and calculate how much room is availble in DosDeviceMapping after that.

            UnicodeComputerName.Buffer += 1;
            AvailableLength = sizeof(DosDeviceMapping) - sizeof(DosDeviceMapping[0]) * (ULONG)(UnicodeComputerName.Buffer - DosDeviceMapping);

            // We know now that it's not a DFS path
            CheckForDfs = FALSE;

        }

        // If it's not a rdr drive, then maybe it's a local volume, floppy, or cdrom

        else if( DosDeviceMapping == wcsstr( DosDeviceMapping, LocalVolumeMappingPrefix )
                 ||
                 DosDeviceMapping == wcsstr( DosDeviceMapping, CDRomMappingPrefix )
                 ||
                 DosDeviceMapping == wcsstr( DosDeviceMapping, FloppyMappingPrefix ) ) {

            // We have a local drive, so just return the local computer name.

            CheckForDfs = FALSE;

            if( !GetComputerNameW( lpBuffer, nSize))
                dwError = GetLastError();
            else
                dwError = ERROR_SUCCESS;
            goto Exit;
        }

        // Finally, check to see if it's a DFS drive

        else if( DosDeviceMapping == wcsstr( DosDeviceMapping, DfsMappingPrefix )) {

            // Get the full UNC name of this DFS path.  Later, we'll call the DFS
            // driver to find out what the actual server name is.

            NtStatus = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        FileNameInfo,
                        sizeof(FileNameInfoBuffer),
                        FileNameInformation
                        );
            if( !NT_SUCCESS(NtStatus) ) {
                dwError = RtlNtStatusToDosError(NtStatus);
                goto Exit;
            }

            UnicodeComputerName.Buffer = FileNameInfo->FileName + 1;
            AvailableLength = FileNameInfo->FileNameLength;
        }

        // Otherwise, it's not a rdr, dfs, or local drive, so there's nothing we can do.

        else
            goto Exit;

    }   // else if( RtlPrefixString( (PSTRING)&NtDrivePathNamePrefix, (PSTRING)NtPathName, TRUE ) ...

    else {
        dwError = ERROR_BAD_PATHNAME;
        goto Exit;
    }


    // If we couldn't determine above if whether or not this is a DFS path, let the
    // DFS driver decide now.

    if( CheckForDfs && INVALID_HANDLE_VALUE != hFile ) {

        HANDLE hDFS = INVALID_HANDLE_VALUE;
        UNICODE_STRING DfsDriverName;
        OBJECT_ATTRIBUTES ObjectAttributes;

        WCHAR *DfsPathName = UnicodeComputerName.Buffer - 1;    // Back up to the whack
        ULONG DfsPathNameLength = AvailableLength + sizeof(WCHAR);

        // Open the DFS driver

        RtlInitUnicodeString( &DfsDriverName, DFS_DRIVER_NAME );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &DfsDriverName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                );

        NtStatus = NtCreateFile(
                        &hDFS,
                        SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                    );

        if( !NT_SUCCESS(NtStatus) ) {
            dwError = RtlNtStatusToDosError(NtStatus);
            goto Exit;
        }

        // Query DFS's cache for the server name.  The name is guaranteed to
        // remain in the cache as long as the file is open.

        if( L'\\' != DfsPathName[0] ) {
            NtClose(hDFS);
            dwError = ERROR_BAD_PATHNAME;
            goto Exit;
        }

        NtStatus = NtFsControlFile(
                        hDFS,
                        NULL,       // Event,
                        NULL,       // ApcRoutine,
                        NULL,       // ApcContext,
                        &IoStatusBlock,
                        FSCTL_DFS_GET_SERVER_NAME,
                        DfsPathName,
                        DfsPathNameLength,
                        DfsServerPathName,
                        sizeof(DfsServerPathName)
                    );
        NtClose( hDFS );

        // STATUS_OBJECT_NAME_NOT_FOUND means that it's not a DFS path
        if( !NT_SUCCESS(NtStatus) ) {
            if( STATUS_OBJECT_NAME_NOT_FOUND != NtStatus  ) {
                dwError = RtlNtStatusToDosError(NtStatus);
                goto Exit;
            }
        }
        else if( L'\0' != DfsServerPathName[0] ) {

            // The previous DFS call returns the server-specific path to the file in UNC form.
            // Point UnicodeComputerName to just past the two whacks.

            AvailableLength = wcslen(DfsServerPathName) * sizeof(WCHAR);
            if( 3*sizeof(WCHAR) > AvailableLength
                ||
                L'\\' != DfsServerPathName[0]
                ||
                L'\\' != DfsServerPathName[1] )
            {
                dwError = ERROR_BAD_PATHNAME;
                goto Exit;
            }

            UnicodeComputerName.Buffer = DfsServerPathName + 2;
            AvailableLength -= 2 * sizeof(WCHAR);
        }
    }

    // If we get here, then the computer name\share is pointed to by UnicodeComputerName.Buffer.
    // But the Length is currently zero, so we search for the whack that separates
    // the computer name from the share, and set the Length to include just the computer name.

    PathCharacter = UnicodeComputerName.Buffer;

    while( ( (ULONG) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer) < AvailableLength)
           &&
           *PathCharacter != L'\\' ) {

        // If we found a '.', we fail because this is probably a DNS or IP name.
        if( L'.' == *PathCharacter ) {
            dwError = ERROR_BAD_PATHNAME;
            goto Exit;
        }

        PathCharacter++;
    }

    // Set the computer name length

    UnicodeComputerName.Length = UnicodeComputerName.MaximumLength
        = (USHORT) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer);

    // Fail if the computer name exceeded the length of the input NtPathName,
    // or if the length exceeds that allowed.

    if( UnicodeComputerName.Length >= AvailableLength
        ||
        UnicodeComputerName.Length > MAX_COMPUTERNAME_LENGTH*sizeof(WCHAR) ) {
        goto Exit;
    }

    // Copy the computer name into the caller's buffer, as long as there's enough
    // room for the name & a terminating '\0'.

    if( UnicodeComputerName.Length + sizeof(WCHAR) > *nSize * sizeof(WCHAR) ) {
        dwError = ERROR_BUFFER_OVERFLOW;
        goto Exit;
    }

    RtlCopyMemory( lpBuffer, UnicodeComputerName.Buffer, UnicodeComputerName.Length );
    *nSize = UnicodeComputerName.Length / sizeof(WCHAR);
    lpBuffer[ *nSize ] = L'\0';

    dwError = ERROR_SUCCESS;


Exit:

    return( dwError );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\constrs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

VOID
NewProcess()
{

    SMALL_RECT Window;

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 15;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );
    TerminateProcess(GetCurrentProcess(),0);
}


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO	StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL Success;
    DWORD st;
    DWORD ProcessCount;
    SMALL_RECT Window;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    GetStartupInfo(&StartupInfo);
    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 15;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );


    while ( TRUE ) {

        Success = CreateProcess(
                        NULL,
                        "constrs +",
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_CONSOLE,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInfo
                        );

        if (Success) {
            ProcessCount++;
            printf("Process %d Created\n",ProcessCount);
            st = WaitForSingleObject(ProcessInfo.hProcess,-1);
            (st == 0);
            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\count.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    int i=0;
    SMALL_RECT Window;

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 10;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );


    while ( TRUE ) {
        printf("%d\n",++i);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\copylz.c ===
/*
** copylz.c - CopyLZFile() and buffer management functions.
**
** Author:  DavidDi
**
** This module is compiled twice - once with LZA_DLL defined for the Windows
** DLL, and once without LZDLL defined for static DOS library.
*/


// Headers
///////////

#include <basedll.h>
#define LZA_DLL
#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"

#include "lzpriv.h"


/*
** int  APIENTRY LZStart(void);
**
** If the global buffers are not already initialized, allocates buffers in
** preparation for calls to CopyLZFile().  Increments the global buffer lock
** count.  Sets the global buffers' base pointers and lengths.
**
** Arguments:  void
**
** Returns:    int - TRUE if successful.  LZERROR_GLOBALLOC if unsuccessful.
**
** Globals:    none
*/

INT  APIENTRY LZStart(VOID)
{
   return(TRUE);
}


/*
** VOID  APIENTRY LZDone(void);
**
** If any of the global buffers have not already been freed, frees them and
** resets the buffers' base array pointers to NULL.  Decrements the global
** buffer lock count.
**
** Arguments:  void
**
** Returns:    VOID
**
** Globals:    none
*/
VOID  APIENTRY LZDone(VOID)
{
   return;
}

/*
** CopyLZFile()
**
** Alias for LZCopy(). Originally, LZCopy() and
** CopyLZFile() were intended for different purposes, but they were confused
** and misused so much they were made identical.
*/
LONG APIENTRY CopyLZFile(HFILE doshSource, HFILE doshDest)
{
   return(LZCopy(doshSource, doshDest));
}

/*
** LZCopy()
**
** Expand a compressed file, or copy an uncompressed file.
**
** Arguments:  doshSource - source DOS file handle
**             doshDest   - destination DOS file handle
**
** Returns:    LONG - Number of bytes written if copy was successful.
**                    One of the LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
LONG  APIENTRY LZCopy(HFILE doshSource, HFILE doshDest)
{
   INT f;
   LONG lRetVal;
   PLZINFO pLZI;

   // If it's a compressed file handle, translate to a DOS handle.
   if (doshSource >= LZ_TABLE_BIAS)
   {
      LZFile *lpLZ;       // pointer to LZFile struct
      HANDLE hLZFile;         // handle to LZFile struct

      if ((hLZFile = rghLZFileTable[doshSource - LZ_TABLE_BIAS]) == NULL)
      {
         return(LZERROR_BADINHANDLE);
      }

      if ((lpLZ = (LZFile *)GlobalLock(hLZFile)) == NULL)
      {
         return(LZERROR_GLOBLOCK);
      }

      doshSource = lpLZ->dosh;
      doshDest = ConvertDosFHToWin32(doshDest);

      GlobalUnlock(hLZFile);
   }
   else {
      doshDest   = ConvertDosFHToWin32(doshDest);
      doshSource = ConvertDosFHToWin32(doshSource);
   }

   // Initialize buffers
   pLZI = InitGlobalBuffersEx();

   if (!pLZI) {
      return(LZERROR_GLOBALLOC);
   }

   ResetBuffers();

   // Expand / copy file.
   if ((f = ExpandOrCopyFile(doshSource, doshDest, pLZI)) != TRUE) {
      // Expansion / copy failed.
      lRetVal = (LONG)f;
   } else {
      // Expansion / copy successful - return number of bytes written.
      lRetVal = pLZI->cblOutSize;
   }

   // Free global buffers.
   FreeGlobalBuffers(pLZI);

   return(lRetVal);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrahcache.c ===
/*
    Cache handling functions for use in kernel32.dll


    VadimB




*/

#include "basedll.h"
#include "ahcache.h"
#pragma hdrstop


BOOL
NTAPI
BaseCheckRunApp(
    IN  HANDLE  FileHandle,
    IN  LPCWSTR pwszApplication,
    IN  PVOID   pEnvironment,
    IN  USHORT  uExeType,
    IN  DWORD   dwReason,
    OUT PVOID*  ppData,
    OUT PDWORD  pcbData,
    OUT PVOID*  ppSxsData,
    OUT PDWORD  pcbSxsData,
    OUT PDWORD  pdwFusionFlags
    )
{
#if defined(BUILD_WOW6432)

    return NtWow64CsrBaseCheckRunApp(FileHandle,
                                     pwszApplication,
                                     pEnvironment,
                                     uExeType,
                                     dwReason,
                                     ppData,
                                     pcbData,
                                     ppSxsData,
                                     pcbSxsData,
                                     pdwFusionFlags);

#else

    BASE_API_MSG m;
    PBASE_CHECK_APPLICATION_COMPATIBILITY_MSG pMsg = &m.u.CheckApplicationCompatibility;
    UNICODE_STRING EnvVar;
    UNICODE_STRING EnvVarValue;
    UNICODE_STRING ApplicationName;
    NTSTATUS Status;
    ULONG    CaptureBufferSize;
    ULONG    CaptureEnvSize;
    ULONG    CountMessagePointers = 1; // at least the name of the app
    PWCHAR   pEnv;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    BOOL     bRunApp = TRUE;
    INT      i;


    struct _VarDefinitions {
        UNICODE_STRING Name;
        UNICODE_STRING Value;
    } rgImportantVariables[] = {

            { RTL_CONSTANT_STRING(L"SHIM_DEBUG_LEVEL")  },
            { RTL_CONSTANT_STRING(L"SHIM_FILE_LOG")     },
            { RTL_CONSTANT_STRING(L"__COMPAT_LAYER")    },
            { RTL_CONSTANT_STRING(L"__PROCESS_HISTORY") }
    };


    pMsg->FileHandle      = FileHandle;
    pMsg->CacheCookie     = dwReason;
    pMsg->ExeType         = uExeType;
    pMsg->pEnvironment    = NULL;
    pMsg->pAppCompatData  = NULL;
    pMsg->cbAppCompatData = 0;
    pMsg->pSxsData        = NULL;
    pMsg->cbSxsData       = 0;
    pMsg->bRunApp         = TRUE; // optimistic please
    pMsg->FusionFlags     = 0;

    RtlInitUnicodeString(&ApplicationName, pwszApplication);
    pMsg->FileName.MaximumLength = ApplicationName.Length + sizeof(UNICODE_NULL);

    CaptureBufferSize = 0;
    CaptureEnvSize = 0;

    for (i = 0; i < sizeof(rgImportantVariables)/sizeof(rgImportantVariables[0]); ++i) {
        EnvVar.Buffer = NULL;
        EnvVar.Length =
        EnvVar.MaximumLength = 0;

        Status = RtlQueryEnvironmentVariable_U(pEnvironment,
                                               (PUNICODE_STRING)(&rgImportantVariables[i].Name),
                                               &EnvVar);
        if (Status == STATUS_BUFFER_TOO_SMALL) {
            //
            // variable is present, account for the buffer size
            // length of the name string + length of the value string + '=' + null char
            //

            CaptureEnvSize += rgImportantVariables[i].Name.Length +
                              EnvVar.Length + sizeof(WCHAR) +
                              sizeof(UNICODE_NULL);

            rgImportantVariables[i].Value.MaximumLength = EnvVar.Length + sizeof(UNICODE_NULL);
        }

    }

    if (CaptureEnvSize != 0) {
        CaptureEnvSize += sizeof(UNICODE_NULL);
        ++CountMessagePointers;
    }

    CaptureBufferSize = CaptureEnvSize + pMsg->FileName.MaximumLength;

    //
    // at this point we either have one or two parameters to place into the buffer
    //

    CaptureBuffer = CsrAllocateCaptureBuffer(CountMessagePointers,
                                             CaptureBufferSize);
    if (CaptureBuffer == NULL) {
        DbgPrint("BaseCheckRunApp: Failed to allocate capture buffer size 0x%lx\n", CaptureBufferSize);
        goto Cleanup;
    }


    //
    // start allocating message data
    //
    CsrAllocateMessagePointer(CaptureBuffer,
                              pMsg->FileName.MaximumLength,
                              (PVOID)&pMsg->FileName.Buffer);
    RtlCopyUnicodeString(&pMsg->FileName, &ApplicationName);

    //
    // now let's do our "mini-environment block"
    //
    if (CaptureEnvSize) {
        CsrAllocateMessagePointer(CaptureBuffer,
                                  CaptureEnvSize,
                                  (PVOID)&pMsg->pEnvironment);

        //
        // loop through the vars and create mini-env
        //
        pEnv  = pMsg->pEnvironment;
        pMsg->EnvironmentSize = CaptureEnvSize;

        for (i = 0; i < sizeof(rgImportantVariables)/sizeof(rgImportantVariables[0]); ++i) {

            if (rgImportantVariables[i].Value.MaximumLength == 0) {
                continue;
            }

            //
            // we incorporate this variable
            //
            EnvVar.Buffer = pEnv;
            EnvVar.Length = 0;
            EnvVar.MaximumLength = (USHORT)CaptureEnvSize;

            Status = RtlAppendUnicodeStringToString(&EnvVar, &rgImportantVariables[i].Name);
            if (!NT_SUCCESS(Status)) {
                //
                // skip this one
                //
                continue;
            }

            Status = RtlAppendUnicodeToString(&EnvVar, L"=");
            if (!NT_SUCCESS(Status)) {
                continue;
            }


            //
            // now query the variable
            //
            EnvVarValue.Buffer = pEnv + (EnvVar.Length / sizeof(WCHAR));
            EnvVarValue.MaximumLength = (USHORT)(CaptureEnvSize - EnvVar.Length);

            Status = RtlQueryEnvironmentVariable_U(pEnvironment,
                                                   (PUNICODE_STRING)&rgImportantVariables[i].Name,
                                                   &EnvVarValue);
            if (!NT_SUCCESS(Status)) {
                continue;
            }

            //
            // make sure we're zero-terminated, adjust the size
            //
            CaptureEnvSize -= (EnvVar.Length + EnvVarValue.Length);

            //
            // zero-terminate, it may not be after an rt function call
            //
            if (CaptureEnvSize < sizeof(UNICODE_NULL) * 2) {
                //
                // can't zero-terminate
                //
                continue;
            }

            *(pEnv + (EnvVar.Length + EnvVarValue.Length) / sizeof(WCHAR)) = L'\0';
            CaptureEnvSize -= sizeof(UNICODE_NULL);

            pEnv += (EnvVar.Length + EnvVarValue.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR);

        }

        //
        // we always slap another zero at the end please
        //

        if (CaptureEnvSize < sizeof(UNICODE_NULL)) {
            //
            // we cannot double-null terminate, forget the call then, we have failed to transport environment
            // this situation however is impossible -- we will always have at least that much space left
            //
            goto Cleanup;
        }

        //
        // this ensures our simple validation mechanism in server works
        //
        RtlZeroMemory(pEnv, CaptureEnvSize);
    }

    //
    // we are ready to commence a csr call
    //

    Status = CsrClientCallServer((PCSR_API_MSG)&m,
                                 CaptureBuffer,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX, BasepCheckApplicationCompatibility),
                                 sizeof(*pMsg));
    if (NT_SUCCESS(Status)) {

        bRunApp = pMsg->bRunApp;

        //
        // pointers to the appcompat data
        //

        *ppData         = pMsg->pAppCompatData;
        *pcbData        = pMsg->cbAppCompatData;
        *ppSxsData      = pMsg->pSxsData;
        *pcbSxsData     = pMsg->cbSxsData;
        *pdwFusionFlags = pMsg->FusionFlags;

    } else {
        //
        // dbg print here to indicate a failed csr call
        //
        DbgPrint("BaseCheckRunApp: failed to call csrss 0x%lx\n", Status);
    }

Cleanup:

    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer(CaptureBuffer);
    }

    return bRunApp;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrbeep.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrbeep.c

Abstract:

    This module implements functions that are used by the Win32 Beep APIs to communicate
    with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

VOID
CsrBasepSoundSentryNotification(
    ULONG VideoMode
    )
{

#if defined(BUILD_WOW6432)
    
    NtWow64CsrBasepSoundSentryNotification(VideoMode);

#else

    BASE_API_MSG m;
    PBASE_SOUNDSENTRY_NOTIFICATION_MSG e = &m.u.SoundSentryNotification;

    e->VideoMode = VideoMode;

    CsrClientCallServer((PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                             BasepSoundSentryNotification ),
                        sizeof( *e )
                       );
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrbinit.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrbinit.c

Abstract:

    This module implements functions that are used during Win32 base initialization to
    communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBaseClientConnectToServer(
    PWSTR szSessionDir,
    PHANDLE phMutant,
    PBOOLEAN pServerProcess
    )
{

#if defined(BUILD_WOW6432)
   return NtWow64CsrBaseClientConnectToServer(szSessionDir,
                                              phMutant,
                                              pServerProcess
                                              );
#else

    NTSTATUS Status;
    ULONG SizeMutant;
    SizeMutant = sizeof(HANDLE);

    Status = CsrClientConnectToServer( szSessionDir,
                                       BASESRV_SERVERDLL_INDEX,
                                       phMutant,
                                       &SizeMutant,
                                       pServerProcess
                                     );


    return Status;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrdlini.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrdlini.c

Abstract:

    This module implements functions that are used by the Win32 Initialization
    File APIs to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepRefreshIniFileMapping(
    PUNICODE_STRING BaseFileName
    )
{       
    
#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepRefreshIniFileMapping(BaseFileName); 
#else

    NTSTATUS Status;

    BASE_API_MSG m;
    PBASE_REFRESHINIFILEMAPPING_MSG ap = &m.u.RefreshIniFileMapping;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CaptureBuffer = NULL;

    if (BaseFileName->Length > (MAX_PATH * sizeof( WCHAR ))) {
        return STATUS_INVALID_PARAMETER;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              BaseFileName->MaximumLength
                                            );
    if (CaptureBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    CsrCaptureMessageString( CaptureBuffer,
                             (PCHAR)BaseFileName->Buffer,
                             BaseFileName->Length,
                             BaseFileName->MaximumLength,
                             (PSTRING)&ap->IniFileName
                          );

   CsrClientCallServer( (PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                             BasepRefreshIniFileMapping
                                           ),
                        sizeof( *ap )
                     );

   Status = (NTSTATUS)m.ReturnValue;

   CsrFreeCaptureBuffer( CaptureBuffer );
   return Status;

#endif
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrpathm.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrpathm.c

Abstract:

    This module implements functions that are used by the Win32 path functions
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

UINT
CsrBasepGetTempFile(
    VOID
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepGetTempFile();
#else   
    
    BASE_API_MSG m;
    PBASE_GETTEMPFILE_MSG a = &m.u.GetTempFile;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepGetTempFile
                                            ),
                         sizeof( *a )
                      );
    
    return (UINT)m.ReturnValue;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrdosdv.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrdosdv.c

Abstract:

    This module implements functions that are used by the DefineDosDevice API
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepDefineDosDevice(
    DWORD dwFlags,
    PUNICODE_STRING pDeviceName,
    PUNICODE_STRING pTargetPath
    )
{

#if defined(BUILD_WOW6432)
   return NtWow64CsrBasepDefineDosDevice(dwFlags,
                                         pDeviceName,
                                         pTargetPath
                                         );
#else

    BASE_API_MSG m;
    PBASE_DEFINEDOSDEVICE_MSG a = &m.u.DefineDosDeviceApi;
    PCSR_CAPTURE_HEADER p;
    ULONG PointerCount, n;   
 
    if (0 == pTargetPath->MaximumLength) {
       PointerCount = 1;
       n = pDeviceName->MaximumLength;
    } 
    else {
       PointerCount = 2;
       n = pDeviceName->MaximumLength + pTargetPath->MaximumLength;
    }

    p = CsrAllocateCaptureBuffer( PointerCount, n );
    if (p == NULL) {
        return STATUS_NO_MEMORY;
    }

    a->Flags = dwFlags;
    a->DeviceName.MaximumLength =
        (USHORT)CsrAllocateMessagePointer( p,
                                           pDeviceName->MaximumLength,
                                           (PVOID *)&a->DeviceName.Buffer
                                         );
    RtlUpcaseUnicodeString( &a->DeviceName, pDeviceName, FALSE );
    if (pTargetPath->Length != 0) {
        a->TargetPath.MaximumLength =
            (USHORT)CsrAllocateMessagePointer( p,
                                               pTargetPath->MaximumLength,
                                               (PVOID *)&a->TargetPath.Buffer
                                             );
        RtlCopyUnicodeString( &a->TargetPath, pTargetPath );
    }
    else {
        RtlInitUnicodeString( &a->TargetPath, NULL );
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         p,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepDefineDosDevice
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( p );

    return m.ReturnValue;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrterm.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrterm.c

Abstract:

    This module implements functions that are used by the Terminal server support functions
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepSetTermsrvAppInstallMode(
    BOOL bState
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepSetTermsrvAppInstallMode(bState);
#else

    BASE_API_MSG m;
    PBASE_SET_TERMSRVAPPINSTALLMODE c = &m.u.SetTermsrvAppInstallMode;

    c->bState = bState;
    return  CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvAppInstallMode),
                                 sizeof( *c ));
#endif

}


NTSTATUS
CsrBasepSetClientTimeZoneInformation(
    IN PBASE_SET_TERMSRVCLIENTTIMEZONE c
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepSetClientTimeZoneInformation(c);
#else

    BASE_API_MSG m;
    
    RtlCopyMemory(&m.u.SetTermsrvClientTimeZone, c, sizeof(*c));
    
    return  CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvClientTimeZone),
                                 sizeof( *c ));
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrthrd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrthrd.c

Abstract:

    This module implements functions that are used by the Win32 Thread Object APIs
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/
#include "basedll.h"

NTSTATUS
CsrBasepCreateThread(
    HANDLE ThreadHandle,
    CLIENT_ID ClientId
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepCreateThread(ThreadHandle,
                                       ClientId);
#else

    BASE_API_MSG m;
    PBASE_CREATETHREAD_MSG a = &m.u.CreateThread;

    a->ThreadHandle = ThreadHandle;
    a->ClientId = ClientId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepCreateThread
                                            ),
                         sizeof( *a )
                       );

    return m.ReturnValue;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrpro.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrpro.c

Abstract:

    This module implements functions that are used by the Win32 Process Object APIs
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepCreateProcess(
    PBASE_CREATEPROCESS_MSG a
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepCreateProcess(a);
#else
    NTSTATUS Status;
    BASE_API_MSG m;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    m.u.CreateProcess = *a;
    if (m.u.CreateProcess.Sxs.Flags != 0)
    {
        const PUNICODE_STRING StringsToCapture[] =
        {
            &m.u.CreateProcess.Sxs.Manifest.Path,
            &m.u.CreateProcess.Sxs.Policy.Path,
            &m.u.CreateProcess.Sxs.AssemblyDirectory
        };

        Status =
            CsrCaptureMessageMultiUnicodeStringsInPlace(
                &CaptureBuffer,
                RTL_NUMBER_OF(StringsToCapture),
                StringsToCapture
                );
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepCreateProcess
                                            ),
                         sizeof( m.u.CreateProcess )
                       );
    
    if ( CaptureBuffer )
        CsrFreeCaptureBuffer( CaptureBuffer );

    Status = (NTSTATUS)m.ReturnValue;

Exit:
    return Status;
#endif

}

VOID
CsrBasepExitProcess(
    UINT uExitCode
    )
{

#if defined(BUILD_WOW6432)
   NtWow64CsrBasepExitProcess(uExitCode);
   return;
#else

    BASE_API_MSG m;
    PBASE_EXITPROCESS_MSG a = &m.u.ExitProcess;

    a->uExitCode = uExitCode;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepExitProcess
                                            ),
                         sizeof( *a )
                       );
#endif
}


NTSTATUS
CsrBasepSetProcessShutdownParam(
    DWORD dwLevel,
    DWORD dwFlags
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepSetProcessShutdownParam(dwLevel,
                                                  dwFlags);
#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    a->ShutdownLevel = dwLevel;
    a->ShutdownFlags = dwFlags;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepSetProcessShutdownParam),
            sizeof(*a));   

    return m.ReturnValue;

#endif
}

NTSTATUS
CsrBasepGetProcessShutdownParam(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    )
{

#if defined(BUILD_WOW6432)
   return NtWow64CsrBasepGetProcessShutdownParam(lpdwLevel,
                                                 lpdwFlags);
#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepSetProcessShutdownParam),
            sizeof(*a));   

    *lpdwLevel = a->ShutdownLevel;
    *lpdwFlags = a->ShutdownFlags;

    return m.ReturnValue;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\curdir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    curdir.c

Abstract:

    Current directory support

Author:

    Mark Lucovsky (markl) 10-Oct-1990

Revision History:

--*/

#include "basedll.h"

BOOL
CheckForSameCurdir(
    PUNICODE_STRING PathName
    )
{
    PCURDIR CurDir;
    UNICODE_STRING CurrentDir;
    BOOL rv;


    CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);

    if (CurDir->DosPath.Length > 6 ) {
        if ( (CurDir->DosPath.Length-2) != PathName->Length ) {
            return FALSE;
        }
    } else {
        if ( CurDir->DosPath.Length != PathName->Length ) {
            return FALSE;
        }
    }

    RtlAcquirePebLock();

    CurrentDir = CurDir->DosPath;
    if ( CurrentDir.Length > 6 ) {
        CurrentDir.Length -= 2;
    }
    rv = FALSE;

    if ( RtlEqualUnicodeString(&CurrentDir,PathName,TRUE) ) {
        rv = TRUE;
    }
    RtlReleasePebLock();

    return rv;
}


DWORD
APIENTRY
GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    )

/*++

Routine Description:

    ANSI thunk to GetFullPathNameW

--*/

{

    NTSTATUS Status;
    ULONG UnicodeLength;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeResult;
    ANSI_STRING AnsiResult;
    PWSTR Ubuff;
    PWSTR FilePart;
    PWSTR *FilePartPtr;
    INT PrefixLength = 0;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
    } else {
        FilePartPtr = NULL;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &UnicodeString, lpFileName )) {
        return 0;
    }

    Ubuff = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (MAX_PATH<<1) + sizeof(UNICODE_NULL));
    if ( !Ubuff ) {
        RtlFreeUnicodeString(&UnicodeString);
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
    }

    UnicodeLength = RtlGetFullPathName_U(
                        UnicodeString.Buffer,
                        (MAX_PATH<<1),
                        Ubuff,
                        FilePartPtr
                        );

    //
    // UnicodeLength contains the byte count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to get
    // the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS environment,
    // it's definitely WRONG.
    //
    if ( UnicodeLength <= MAX_PATH * sizeof (WCHAR) ) {

        Status = RtlUnicodeToMultiByteSize(&UnicodeLength, Ubuff, UnicodeLength);
        //
        // At this point, UnicodeLength variable contains
        // Ansi based byte length.
        //
        if ( NT_SUCCESS(Status) ) {
            if ( UnicodeLength && ARGUMENT_PRESENT(lpFilePart) && FilePart != NULL ) {
                INT UnicodePrefixLength;

                UnicodePrefixLength = (INT)(FilePart - Ubuff) * sizeof(WCHAR);
                Status = RtlUnicodeToMultiByteSize( &PrefixLength,
                                                    Ubuff,
                                                    UnicodePrefixLength );
                //
                // At this point, PrefixLength variable contains
                // Ansi based byte length.
                //
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    UnicodeLength = 0;
                }
            }
        } else {
            BaseSetLastNTError(Status);
            UnicodeLength = 0;
        }
    } else {
        //
        // we exceed the MAX_PATH limit. we should log the error and
        // return zero. however US code returns the byte count of
        // buffer required and doesn't log any error.
        //
        UnicodeLength = 0;
    }
    if ( UnicodeLength && UnicodeLength < nBufferLength ) {
        RtlInitUnicodeString(&UnicodeResult,Ubuff);
        Status = BasepUnicodeStringTo8BitString(&AnsiResult,&UnicodeResult,TRUE);
        if ( NT_SUCCESS(Status) ) {
            RtlCopyMemory(lpBuffer,AnsiResult.Buffer,UnicodeLength+1);
            RtlFreeAnsiString(&AnsiResult);

            if ( ARGUMENT_PRESENT(lpFilePart) ) {
                if ( FilePart == NULL ) {
                    *lpFilePart = NULL;
                } else {
                    *lpFilePart = lpBuffer + PrefixLength;
                }
            }
        } else {
            BaseSetLastNTError(Status);
            UnicodeLength = 0;
        }
    } else {
        if ( UnicodeLength ) {
            UnicodeLength++;
        }
    }
    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeHeap(RtlProcessHeap(), 0,Ubuff);

    return (DWORD)UnicodeLength;
}

DWORD
APIENTRY
GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )

/*++

Routine Description:

    This function is used to return the fully qualified path name
    corresponding to the specified file name.

    This function is used to return a fully qualified pathname
    corresponding to the specified filename.  It does this by merging
    the current drive and directory together with the specified file
    name.  In addition to this, it calculates the address of the file
    name portion of the fully qualified pathname.

Arguments:

    lpFileName - Supplies the file name of the file whose fully
        qualified pathname is to be returned.

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        specified file.

    lpFilePart - Returns the address of the last component of the fully
        qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{

    return (DWORD) RtlGetFullPathName_U(
                        lpFileName,
                        nBufferLength*2,
                        lpBuffer,
                        lpFilePart
                        )/2;
}


DWORD
APIENTRY
GetCurrentDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )

/*++

Routine Description:

   ANSI thunk to GetCurrentDirectoryW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD ReturnValue;
    ULONG cbAnsiString;

    if ( nBufferLength > MAXUSHORT ) {
        nBufferLength = MAXUSHORT-2;
        }

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    Unicode->Length = (USHORT)RtlGetCurrentDirectory_U(
                                    Unicode->MaximumLength,
                                    Unicode->Buffer
                                    );

    //
    // Unicode->Length contains the byte count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to
    // get the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS
    // environment, it's definitely WRONG.
    //
    Status = RtlUnicodeToMultiByteSize( &cbAnsiString, Unicode->Buffer, Unicode->Length );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = 0;
        }
    else {
        if ( nBufferLength > (DWORD)(cbAnsiString ) ) {
            AnsiString.Buffer = lpBuffer;
            AnsiString.MaximumLength = (USHORT)(nBufferLength);
            Status = BasepUnicodeStringTo8BitString(&AnsiString,Unicode,FALSE);

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = 0;
                }
            else {
                ReturnValue = AnsiString.Length;
                }
            }
        else {
            // The return value is the size of the buffer required to hold the
            // pathname (including the terminating null character).

                ReturnValue = cbAnsiString + 1;
            }
        }
    return ReturnValue;
}

DWORD
APIENTRY
GetCurrentDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )

/*++

Routine Description:

    The current directory for a process can be retreived using
    GetCurrentDirectory.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is to
        receive the current directory string.

    lpBuffer - Returns the current directory string for the current
        process.  The string is a null terminated string and specifies
        the absolute path to the current directory.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    return (DWORD)RtlGetCurrentDirectory_U(nBufferLength*2,lpBuffer)/2;
}


BOOL
APIENTRY
SetCurrentDirectoryA(
    LPCSTR lpPathName
    )

/*++

Routine Description:

    ANSI thunk to SetCurrentDirectoryW

--*/

{

    NTSTATUS Status;
    PUNICODE_STRING Unicode;
    BOOL rv;

    if (lpPathName == NULL) {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    Unicode = Basep8BitStringToStaticUnicodeString (lpPathName);
    if (Unicode == NULL) {
        return FALSE;
    }

    if (!CheckForSameCurdir (Unicode)) {

        Status = RtlSetCurrentDirectory_U (Unicode);

        if (!NT_SUCCESS (Status)) {

            // NOTICE-2002/04/12-earhart: APPCOMPAT
            // claris works 5.0 has a bug where it doesn't strip leading/trailing
            // quotes properly. It ends up calling SetCurrentDirectoryA with a
            // leading quote, and WinExec with a trailing quote. This error path
            // logic will compensate for the leading quote problem
            //
            if (Unicode->Buffer[0] == L'"' && Unicode->Length > 2) {

                Unicode = Basep8BitStringToStaticUnicodeString (lpPathName+1);
                if (Unicode == NULL) {
                    return FALSE;
                }
                Status = RtlSetCurrentDirectory_U (Unicode);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    rv = FALSE;
                } else {
                    rv = TRUE;
                }
            } else {
                BaseSetLastNTError(Status);
                rv = FALSE;
            }
        } else {
            rv = TRUE;
        }
    } else {
        rv = TRUE;
    }

    return rv;

}

BOOL
APIENTRY
SetCurrentDirectoryW(
    LPCWSTR lpPathName
    )

/*++

Routine Description:

    The current directory for a process is changed using
    SetCurrentDirectory.

    Each process has a single current directory.  A current directory is
    made up of type parts.

        - A disk designator either which is either a drive letter followed
          by a colon, or a UNC servername/sharename "\\servername\sharename".

        - A directory on the disk designator.

    For APIs that manipulate files, the file names may be relative to
    the current directory.  A filename is relative to the entire current
    directory if it does not begin with a disk designator or a path name
    separator.  If the file name begins with a path name separator, then
    it is relative to the disk designator of the current directory.  If
    a file name begins with a disk designator, than it is a fully
    qualified absolute path name.


    The value of lpPathName supplies the current directory.  The value
    of lpPathName, may be a relative path name as described above, or a
    fully qualified absolute path name.  In either case, the fully
    qualified absolute path name of the specified directory is
    calculated and is stored as the current directory.

Arguments:

    lpPathName - Supplies the pathname of the directory that is to be
        made the current directory.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    BOOL rv;

    if (lpPathName == NULL) {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    Status = RtlInitUnicodeStringEx (&UnicodeString, lpPathName);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }

    if (!CheckForSameCurdir (&UnicodeString)) {

        Status = RtlSetCurrentDirectory_U (&UnicodeString);

        if (!NT_SUCCESS (Status)) {
            BaseSetLastNTError (Status);
            rv = FALSE;
        } else {
            rv = TRUE;
        }
    } else {
        rv = TRUE;
    }
    return rv;
}



DWORD
APIENTRY
GetLogicalDrives(
    VOID
    )
{
    NTSTATUS Status;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfo.Query,
                                        sizeof( ProcessDeviceMapInfo.Query ),
                                        NULL
                                      );
    if (NT_SUCCESS (Status)) {
        if (ProcessDeviceMapInfo.Query.DriveMap == 0) {
            SetLastError(NO_ERROR);
        }
        return ProcessDeviceMapInfo.Query.DriveMap;
    } else {
        BaseSetLastNTError(Status);
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\datetime.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    datetime.c

Abstract:

    This module implements Win32 time of day functions

Author:

    Mark Lucovsky (markl) 08-Oct-1990

Revision History:

--*/

#include "basedll.h"

#define IsActiveConsoleSession() (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)

ULONG 
CalcClientTimeZoneIdAndBias(
     IN CONST TIME_ZONE_INFORMATION *ptzi,
     OUT KSYSTEM_TIME *pBias);

BOOL IsTimeZoneRedirectionEnabled();

VOID
WINAPI
GetLocalTime(
    LPSYSTEMTIME lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be returned using
    GetLocalTime.

Arguments:

    lpLocalTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER LocalTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER Bias;
    TIME_FIELDS TimeFields;
    
    volatile KSYSTEM_TIME *pRealBias;
        
    if(IsTimeZoneRedirectionEnabled()) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }
    
    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    LocalTime.QuadPart = SystemTime.QuadPart - Bias.QuadPart;

    RtlTimeToTimeFields(&LocalTime,&TimeFields);

    lpLocalTime->wYear         = TimeFields.Year        ;
    lpLocalTime->wMonth        = TimeFields.Month       ;
    lpLocalTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpLocalTime->wDay          = TimeFields.Day         ;
    lpLocalTime->wHour         = TimeFields.Hour        ;
    lpLocalTime->wMinute       = TimeFields.Minute      ;
    lpLocalTime->wSecond       = TimeFields.Second      ;
    lpLocalTime->wMilliseconds = TimeFields.Milliseconds;
}

VOID
WINAPI
GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    The current system date and time (UTC based) can be returned using
    GetSystemTime.

Arguments:

    lpSystemTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    RtlTimeToTimeFields(&SystemTime,&TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;
}

VOID
WINAPI
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    )

/*++

Routine Description:

    The current system date and time (UTC based) can be returned using
    GetSystemTimeAsFileTime.

Arguments:

    lpSystemTimeAsFileTime - Returns the current system date and time formatted as
        a FILETIME structure

Return Value:

    None.

--*/

{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    lpSystemTimeAsFileTime->dwLowDateTime = SystemTime.LowPart;
    lpSystemTimeAsFileTime->dwHighDateTime = SystemTime.HighPart;
}

BOOL
WINAPI
SetSystemTime(
    CONST SYSTEMTIME *lpSystemTime
    )

/*++

Routine Description:

    The current UTC based system date and time can be set using
    SetSystemTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;

    ReturnValue = TRUE;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&SystemTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {
        Status = BasepAcquirePrivilegeEx( SE_SYSTEMTIME_PRIVILEGE, &State );
        if ( NT_SUCCESS(Status) ) {
            Status = NtSetSystemTime(&SystemTime,NULL);
            BasepReleasePrivilege( State );
            }
        if ( !NT_SUCCESS(Status) ) {
            ReturnValue = FALSE;
            }
        }

    if ( !ReturnValue ) {
        BaseSetLastNTError(Status);
        }

    return ReturnValue;
}

BOOL
WINAPI
SetLocalTime(
    CONST SYSTEMTIME *lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be set using
    SetLocalTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;
    LARGE_INTEGER Bias;

    volatile KSYSTEM_TIME *pRealBias;
    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.
    
    if(IsTimeZoneRedirectionEnabled()) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    ReturnValue = TRUE;

    TimeFields.Year         = lpLocalTime->wYear        ;
    TimeFields.Month        = lpLocalTime->wMonth       ;
    TimeFields.Day          = lpLocalTime->wDay         ;
    TimeFields.Hour         = lpLocalTime->wHour        ;
    TimeFields.Minute       = lpLocalTime->wMinute      ;
    TimeFields.Second       = lpLocalTime->wSecond      ;
    TimeFields.Milliseconds = lpLocalTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&LocalTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {

        SystemTime.QuadPart = LocalTime.QuadPart + Bias.QuadPart;
        Status = BasepAcquirePrivilegeEx( SE_SYSTEMTIME_PRIVILEGE, &State );
        if ( NT_SUCCESS(Status) ) {
            Status = NtSetSystemTime(&SystemTime,NULL);
            BasepReleasePrivilege( State );
            if ( !NT_SUCCESS(Status) ) {
                ReturnValue = FALSE;
                }
            }
        else {
            ReturnValue = FALSE;
            }
        }

    if ( !ReturnValue ) {
        BaseSetLastNTError(Status);
        }

    return ReturnValue;
}


DWORD
GetTickCount(
    VOID
    )

/*++

Routine Description:

    Win32 systems implement a free-running millisecond counter.  The
    value of this counter can be read using GetTickCount.

Arguments:

    None.

Return Value:

    This function returns the number of milliseconds that have elapsed
    since the system was started. If the system has been running for
    a long time, it is possible that the count will repeat. The value of
    the counter is accurate within 55 milliseconds.

--*/

{
    return (DWORD)NtGetTickCount();
}


BOOL
APIENTRY
FileTimeToSystemTime(
    CONST FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    This functions converts a 64-bit file time value to a time in system
    time format.

Arguments:

    lpFileTime - Supplies the 64-bit file time to convert to the system
        date and time format.

    lpSystemTime - Returns the converted value of the 64-bit file time.

Return Value:

    TRUE - The 64-bit file time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER FileTime;
    TIME_FIELDS TimeFields;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    if ( FileTime.QuadPart < 0 ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    RtlTimeToTimeFields(&FileTime, &TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;

    return TRUE;
}


BOOL
APIENTRY
SystemTimeToFileTime(
    CONST SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a system time value into a 64-bit file time.

Arguments:

    lpSystemTime - Supplies the time that is to be converted into
        the 64-bit file time format.  The wDayOfWeek field is ignored.

    lpFileTime - Returns the 64-bit file time representation of
        lpSystemTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
    else {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
}

BOOL
WINAPI
FileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    )

/*++

Routine Description:

    This functions converts a UTC based file time to a local file time.

Arguments:

    lpFileTime - Supplies the UTC based file time that is to be
        converted into a local file time

    lpLocalFileTime - Returns the 64-bit local file time representation of
        lpFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    volatile KSYSTEM_TIME *pRealBias;
    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.
    
    if(IsTimeZoneRedirectionEnabled()) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    LocalFileTime.QuadPart = FileTime.QuadPart - Bias.QuadPart;

    lpLocalFileTime->dwLowDateTime = LocalFileTime.LowPart;
    lpLocalFileTime->dwHighDateTime = LocalFileTime.HighPart;

    return TRUE;
}

BOOL
WINAPI
LocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a local file time to a UTC based file time.

Arguments:

    lpLocalFileTime - Supplies the local file time that is to be
        converted into a UTC based file time

    lpFileTime - Returns the 64-bit UTC based file time representation of
        lpLocalFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    volatile KSYSTEM_TIME *pRealBias;
    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.
    
    if(IsTimeZoneRedirectionEnabled()) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    LocalFileTime.LowPart = lpLocalFileTime->dwLowDateTime;
    LocalFileTime.HighPart = lpLocalFileTime->dwHighDateTime;

    FileTime.QuadPart = LocalFileTime.QuadPart + Bias.QuadPart;

    lpFileTime->dwLowDateTime = FileTime.LowPart;
    lpFileTime->dwHighDateTime = FileTime.HighPart;

    return TRUE;
}


#define AlmostTwoSeconds (2*1000*1000*10 - 1)

BOOL
APIENTRY
FileTimeToDosDateTime(
    CONST FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    )

/*++

Routine Description:

    This function converts a 64-bit file time into DOS date and time value
    which is represented as two 16-bit unsigned integers.

    Since the DOS date format can only represent dates between 1/1/80 and
    12/31/2107, this conversion can fail if the input file time is outside
    of this range.

Arguments:

    lpFileTime - Supplies the 64-bit file time to convert to DOS date and
        time format.

    lpFatDate - Returns the 16-bit DOS representation of date.

    lpFatTime - Returns the 16-bit DOS representation of time.

Return Value:

    TRUE - The file time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    FileTime.QuadPart = FileTime.QuadPart + (LONGLONG)AlmostTwoSeconds;

    if ( FileTime.QuadPart < 0 ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    RtlTimeToTimeFields(&FileTime, &TimeFields);

    if (TimeFields.Year < 1980 || TimeFields.Year > 2107) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }

    *lpFatDate = (WORD)( ((USHORT)(TimeFields.Year-(CSHORT)1980) << 9) |
                         ((USHORT)TimeFields.Month << 5) |
                         (USHORT)TimeFields.Day
                       );

    *lpFatTime = (WORD)( ((USHORT)TimeFields.Hour << 11) |
                         ((USHORT)TimeFields.Minute << 5) |
                         ((USHORT)TimeFields.Second >> 1)
                       );

    return TRUE;
}


BOOL
APIENTRY
DosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This function converts a DOS date and time value, which is
    represented as two 16-bit unsigned integers, into a 64-bit file
    time.

Arguments:

    lpFatDate - Supplies the 16-bit DOS representation of date.

    lpFatTime - Supplies the 16-bit DOS representation of time.

    lpFileTime - Returns the 64-bit file time converted from the DOS
        date and time format.

Return Value:

    TRUE - The Dos date and time were successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = (CSHORT)((wFatDate & 0xFE00) >> 9)+(CSHORT)1980;
    TimeFields.Month        = (CSHORT)((wFatDate & 0x01E0) >> 5);
    TimeFields.Day          = (CSHORT)((wFatDate & 0x001F) >> 0);
    TimeFields.Hour         = (CSHORT)((wFatTime & 0xF800) >> 11);
    TimeFields.Minute       = (CSHORT)((wFatTime & 0x07E0) >>  5);
    TimeFields.Second       = (CSHORT)((wFatTime & 0x001F) << 1);
    TimeFields.Milliseconds = 0;

    if (RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
}

LONG
APIENTRY
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    )

/*++

Routine Description:

    This function compares two 64-bit file times.

Arguments:

    lpFileTime1 - pointer to a 64-bit file time.

    lpFileTime2 - pointer to a 64-bit file time.

Return Value:

    -1 - *lpFileTime1 <  *lpFileTime2

     0 - *lpFileTime1 == *lpFileTime2

    +1 - *lpFileTime1 >  *lpFileTime2

--*/

{
    ULARGE_INTEGER FileTime1;
    ULARGE_INTEGER FileTime2;

    FileTime1.LowPart = lpFileTime1->dwLowDateTime;
    FileTime1.HighPart = lpFileTime1->dwHighDateTime;
    FileTime2.LowPart = lpFileTime2->dwLowDateTime;
    FileTime2.HighPart = lpFileTime2->dwHighDateTime;
    if (FileTime1.QuadPart < FileTime2.QuadPart) {
        return( -1 );
        }
    else
    if (FileTime1.QuadPart > FileTime2.QuadPart) {
        return( 1 );
        }
    else {
        return( 0 );
        }
}

DWORD
WINAPI
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to get the current timezone
    parameters These parameters control the Universal time to Local time
    translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    The return value of this function is the systems best guess of
    the current time zone parameters. This is one of:

        - Unknown

        - Standard Time

        - Daylight Savings Time

    If SetTimeZoneInformation was called without the transition date
    information, Unknown is returned, but the currect bias is used for
    local time translation.  Otherwise, the system will correctly pick
    either daylight savings time or standard time.

    The information returned by this API is identical to the information
    stored in the last successful call to SetTimeZoneInformation.  The
    exception is the Bias field returns the current Bias value in

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TIME_ZONE_ID_UNKNOWN - The system can not determine the current
        timezone.  This is usually due to a previous call to
        SetTimeZoneInformation where only the Bias was supplied and no
        transition dates were supplied.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    0xffffffff - The operation failed.  Extended error status is
        available using GetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    //
    // get the timezone data from the system
    // If it's terminal server session use client time zone

    if(IsTimeZoneRedirectionEnabled()) {

        *lpTimeZoneInformation = BaseStaticServerData->tziTermsrvClientTimeZone;
        return BaseStaticServerData->TermsrvClientTimeZoneId;

    } else {

        Status = NtQuerySystemInformation(
                    SystemCurrentTimeZoneInformation,
                    &tzi,
                    sizeof(tzi),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return 0xffffffff;
            }


        lpTimeZoneInformation->Bias         = tzi.Bias;
        lpTimeZoneInformation->StandardBias = tzi.StandardBias;
        lpTimeZoneInformation->DaylightBias = tzi.DaylightBias;

        RtlCopyMemory(&lpTimeZoneInformation->StandardName,&tzi.StandardName,sizeof(tzi.StandardName));
        RtlCopyMemory(&lpTimeZoneInformation->DaylightName,&tzi.DaylightName,sizeof(tzi.DaylightName));

        lpTimeZoneInformation->StandardDate.wYear         = tzi.StandardStart.Year        ;
        lpTimeZoneInformation->StandardDate.wMonth        = tzi.StandardStart.Month       ;
        lpTimeZoneInformation->StandardDate.wDayOfWeek    = tzi.StandardStart.Weekday     ;
        lpTimeZoneInformation->StandardDate.wDay          = tzi.StandardStart.Day         ;
        lpTimeZoneInformation->StandardDate.wHour         = tzi.StandardStart.Hour        ;
        lpTimeZoneInformation->StandardDate.wMinute       = tzi.StandardStart.Minute      ;
        lpTimeZoneInformation->StandardDate.wSecond       = tzi.StandardStart.Second      ;
        lpTimeZoneInformation->StandardDate.wMilliseconds = tzi.StandardStart.Milliseconds;

        lpTimeZoneInformation->DaylightDate.wYear         = tzi.DaylightStart.Year        ;
        lpTimeZoneInformation->DaylightDate.wMonth        = tzi.DaylightStart.Month       ;
        lpTimeZoneInformation->DaylightDate.wDayOfWeek    = tzi.DaylightStart.Weekday     ;
        lpTimeZoneInformation->DaylightDate.wDay          = tzi.DaylightStart.Day         ;
        lpTimeZoneInformation->DaylightDate.wHour         = tzi.DaylightStart.Hour        ;
        lpTimeZoneInformation->DaylightDate.wMinute       = tzi.DaylightStart.Minute      ;
        lpTimeZoneInformation->DaylightDate.wSecond       = tzi.DaylightStart.Second      ;
        lpTimeZoneInformation->DaylightDate.wMilliseconds = tzi.DaylightStart.Milliseconds;

        return USER_SHARED_DATA->TimeZoneId;
    }
}

BOOL
WINAPI
SetTimeZoneInformation(
    CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to set timezone parameters into
    their system.  These parameters control the Universal time to Local
    time translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    This API allows the caller to program the current time zone bias,
    and optionally set up the system to automatically sense daylight
    savings time and standard time transitions.

    The timezone bias information is controlled by the
    TIME_ZONE_INFORMATION structure.

    Bias - Supplies the current bias in minutes for local time
        translation on this machine where LocalTime + Bias = UTC.  This
        is a required filed of this structure.

    StandardName - Supplies an optional abbreviation string associated
        with standard time on this system.  This string is uniterpreted
        and is supplied and used only by callers of this API and of
        GetTimeZoneInformation.

    StandardDate - Supplies an optional date and time (UTC) that
        describes the transition into standard time.  A value of 0 in
        the wMonth field tells the system that StandardDate is not
        specified.  If this field is specified, then DaylightDate must
        also be specified.  Additionally, local time translations done
        during the StandardTime range will be done relative to the
        supplied StandardBias value (added to Bias).

        This field supports two date formats. Absolute form specifies and
        exact date and time when standard time begins. In this form, the
        wYear, wMonth, wDay, wHour, wMinute, wSecond, and wMilliseconds
        of the SYSTEMTIME structure are used to specify an exact date.

        Day-in-month time is specified by setting wYear to 0, setting
        wDayOfWeek to an appropriate weekday, and using wDay in the
        range of 1-5 to select the correct day in the month.  Using this
        notation, the first sunday in april may be specified as can be
        the last thursday in october (5 is equal to "the last").

    StandardBias - Supplies an optional bias value to be used during
        local time translations that occur during Standard Time. This
        field is ignored if StandardDate is not supplied.
         This bias value
        is added to the Bias field to form the Bias used during standard
        time. In most time zones, the value of this field is zero.

    DaylightName - Supplies an optional abbreviation string associated
        with daylight savings time on this system.  This string is
        uniterpreted and is supplied and used only by callers of this
        API and of GetTimeZoneInformation.

    DaylightDate - Supplies an optional date and time (UTC) that
        describes the transition into daylight savings time.  A value of
        0 in the wMonth field tells the system that DaylightDate is not
        specified.  If this field is specified, then StandardDate must
        also be specified.  Additionally, local time translations done
        during the DaylightTime range will be done relative to the
        supplied DaylightBias value (added to Bias). The same dat formats
        supported by StandardDate are supported ib DaylightDate.

    DaylightBias - Supplies an optional bias value to be used during
        local time translations that occur during Daylight Savings Time.
        This field is ignored if DaylightDate is not supplied.  This
        bias value is added to the Bias field to form the Bias used
        during daylight time.  In most time zones, the value of this
        field is -60.

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;
    
    if(IsTimeZoneRedirectionEnabled()) {

        return SetClientTimeZoneInformation(lpTimeZoneInformation);

    } else {

        tzi.Bias            = lpTimeZoneInformation->Bias;
        tzi.StandardBias    = lpTimeZoneInformation->StandardBias;
        tzi.DaylightBias    = lpTimeZoneInformation->DaylightBias;

        RtlCopyMemory(&tzi.StandardName,&lpTimeZoneInformation->StandardName,sizeof(tzi.StandardName));
        RtlCopyMemory(&tzi.DaylightName,&lpTimeZoneInformation->DaylightName,sizeof(tzi.DaylightName));

        tzi.StandardStart.Year         = lpTimeZoneInformation->StandardDate.wYear        ;
        tzi.StandardStart.Month        = lpTimeZoneInformation->StandardDate.wMonth       ;
        tzi.StandardStart.Weekday      = lpTimeZoneInformation->StandardDate.wDayOfWeek   ;
        tzi.StandardStart.Day          = lpTimeZoneInformation->StandardDate.wDay         ;
        tzi.StandardStart.Hour         = lpTimeZoneInformation->StandardDate.wHour        ;
        tzi.StandardStart.Minute       = lpTimeZoneInformation->StandardDate.wMinute      ;
        tzi.StandardStart.Second       = lpTimeZoneInformation->StandardDate.wSecond      ;
        tzi.StandardStart.Milliseconds = lpTimeZoneInformation->StandardDate.wMilliseconds;

        tzi.DaylightStart.Year         = lpTimeZoneInformation->DaylightDate.wYear        ;
        tzi.DaylightStart.Month        = lpTimeZoneInformation->DaylightDate.wMonth       ;
        tzi.DaylightStart.Weekday      = lpTimeZoneInformation->DaylightDate.wDayOfWeek   ;
        tzi.DaylightStart.Day          = lpTimeZoneInformation->DaylightDate.wDay         ;
        tzi.DaylightStart.Hour         = lpTimeZoneInformation->DaylightDate.wHour        ;
        tzi.DaylightStart.Minute       = lpTimeZoneInformation->DaylightDate.wMinute      ;
        tzi.DaylightStart.Second       = lpTimeZoneInformation->DaylightDate.wSecond      ;
        tzi.DaylightStart.Milliseconds = lpTimeZoneInformation->DaylightDate.wMilliseconds;

        Status = RtlSetTimeZoneInformation( &tzi );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        //
        // Refresh the system's concept of time
        //

        NtSetSystemTime(NULL,NULL);
    

        return TRUE;
    }
}

BOOL
WINAPI
GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL  lpTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to support algorithms that want to synchronize
    the time of day (reported via GetSystemTime and GetLocalTime) with
    another time source using a programmed clock adjustment over a
    period of time.

    To facilitate this, the system computes the time of day by adding a
    value to a time of day counter at a periodic interval.  This API
    allows the caller to obtain the periodic interval (clock interrupt
    rate), and the amount added to the time of day with each interrupt.

    A boolean value is also returned which indicates whether or not this
    time adjustment algorithm is even being used.  A value of TRUE
    indicates that adjustment is not being used.  If this is the case,
    the system may attempt to keep the time of day clock in sync using
    its own internal mechanisms.  This may cause time of day to
    periodicly "jump" to the "correct time".


Arguments:

    lpTimeAdjustment - Returns the number of 100ns units added to the
        time of day counter at each clock interrupt.

    lpTimeIncrement - Returns the clock interrupt rate in 100ns units.

    lpTimeAdjustmentDisabled - Returns an indicator which specifies
        whether or not time adjustment is inabled.  A value of TRUE
        indicates that periodic adjustment is disabled
        (*lpTimeAdjustment == *lpTimeIncrement), AND that the system is
        free to serialize time of day using any mechanism it wants.
        This may cause periodic time jumps as the system serializes time
        of day to the "correct time".  A value of false indicates that
        programmed time adjustment is being used to serialize the time
        of day, and that the system will not interfere with this scheme
        and will not attempt to synchronize time of day on its own.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/
{
    NTSTATUS Status;
    SYSTEM_QUERY_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;
    Status = NtQuerySystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        b = FALSE;
        }
    else {
        *lpTimeAdjustment = TimeAdjust.TimeAdjustment;
        *lpTimeIncrement = TimeAdjust.TimeIncrement;
        *lpTimeAdjustmentDisabled = TimeAdjust.Enable;
        b = TRUE;
        }

    return b;
}

BOOL
WINAPI
SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL  bTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to tell the system the parameters it should
    use to periodicaly synchronize time of day with some other source.

    This API supports two modes of operation.

    In the first mode, bTimeAdjustmentDisabled is set to FALSE.  At each
    clock interrupt, the value of dwTimeAdjustment is added to the time
    of day.  The clock interrupt rate may be obtained using
    GetSystemTimeAdjustment, and looking at the returned value of
    lpTimeIncrement.

    In the second mode, bTimeAdjustmentDisabled is set to TRUE.  At each
    clock interrupt, the clock interrupt rate is added to the time of
    day.  The system may also periodically refresh the time of day using
    other internal algorithms.  These may produce "jumps" in time.

    The application must have system-time privilege (the
    SE_SYSTEMTIME_NAME privilege) for this function to succeed.  This
    privilege is disabled by default.  Use the AdjustTokenPrivileges
    function to enable the privilege and again to disable it after the
    time adjustment has been set.

Arguments:

    dwTimeAdjustment - Supplies the value (in 100ns units) that is to be
        added to the time of day at each clock interrupt.

    bTimeAdjustmentDisabled - Supplies a flag which specifies the time
        adjustment mode that the system is to use.  A value of TRUE
        indicates the the system should synchronize time of day using
        its own internal mechanisms.  When this is the case, the value
        of dwTimeAdjustment is ignored.  A value of FALSE indicates that
        the application is in control, and that the value specified by
        dwTimeAdjustment is to be added to the time of day at each clock
        interrupt.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/

{
    NTSTATUS Status;
    SYSTEM_SET_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;

    b = TRUE;
    TimeAdjust.TimeAdjustment = dwTimeAdjustment;
    TimeAdjust.Enable = (BOOLEAN)bTimeAdjustmentDisabled;
    Status = NtSetSystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        b = FALSE;
        }

    return b;
}

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    )
{

    TIME_ZONE_INFORMATION TziData;
    LPTIME_ZONE_INFORMATION Tzi;
    RTL_TIME_ZONE_INFORMATION tzi;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    LARGE_INTEGER CurrentUniversalTime;
    LARGE_INTEGER ComputedLocalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;

    //
    // Get the timezone information into a useful format
    //
    if ( !ARGUMENT_PRESENT(lpTimeZoneInformation) ) {

        //
        // Convert universal time to local time using current timezone info
        //
        if (GetTimeZoneInformation(&TziData) == TIME_ZONE_ID_INVALID) {
            return FALSE;
        }
        Tzi = &TziData;
    } else {
        Tzi = lpTimeZoneInformation;
    }

    tzi.Bias            = Tzi->Bias;
    tzi.StandardBias    = Tzi->StandardBias;
    tzi.DaylightBias    = Tzi->DaylightBias;

    RtlCopyMemory(&tzi.StandardName,&Tzi->StandardName,sizeof(tzi.StandardName));
    RtlCopyMemory(&tzi.DaylightName,&Tzi->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = Tzi->StandardDate.wYear        ;
    tzi.StandardStart.Month        = Tzi->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = Tzi->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = Tzi->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = Tzi->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = Tzi->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = Tzi->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = Tzi->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = Tzi->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = Tzi->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = Tzi->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = Tzi->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = Tzi->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = Tzi->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = Tzi->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = Tzi->DaylightDate.wMilliseconds;

    //
    // convert the input universal time to NT style time
    //
    if ( !SystemTimeToFileTime(lpUniversalTime,(LPFILETIME)&CurrentUniversalTime) ) {
        return FALSE;
        }

    //
    // Get the new timezone bias
    //

    NewTimeZoneBias.QuadPart = Int32x32To64(tzi.Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //

    if ( tzi.StandardStart.Month && tzi.DaylightStart.Month ) {

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.StandardStart,
                &StandardTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.DaylightStart,
                &DaylightTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(tzi.StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(tzi.DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            }
        else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart ) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            }

        //
        // At this point, we know our current timezone and the
        // Universal time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                tzi.DaylightBias*60 :
                                tzi.StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

        }
    else {
        TimeZoneBias = NewTimeZoneBias;
        }

    ComputedLocalTime.QuadPart = CurrentUniversalTime.QuadPart - TimeZoneBias.QuadPart;

    if ( !FileTimeToSystemTime((LPFILETIME)&ComputedLocalTime,lpLocalTime) ) {
        return FALSE;
        }

    return TRUE;
}

BOOL
WINAPI
TzSpecificLocalTimeToSystemTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpLocalTime,
    LPSYSTEMTIME lpUniversalTime
    )
{

    TIME_ZONE_INFORMATION TziData;
    LPTIME_ZONE_INFORMATION Tzi;
    RTL_TIME_ZONE_INFORMATION tzi;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER CurrentLocalTime;
    LARGE_INTEGER ComputedUniversalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;

    //
    // Get the timezone information into a useful format
    //
    if ( !ARGUMENT_PRESENT(lpTimeZoneInformation) ) {

        //
        // Convert universal time to local time using current timezone info
        //
        if (GetTimeZoneInformation(&TziData) == TIME_ZONE_ID_INVALID) {
            return FALSE;
            }
        Tzi = &TziData;
    }
    else {
        Tzi = lpTimeZoneInformation;
    }

    tzi.Bias            = Tzi->Bias;
    tzi.StandardBias    = Tzi->StandardBias;
    tzi.DaylightBias    = Tzi->DaylightBias;

    RtlCopyMemory(&tzi.StandardName,&Tzi->StandardName,sizeof(tzi.StandardName));
    RtlCopyMemory(&tzi.DaylightName,&Tzi->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = Tzi->StandardDate.wYear        ;
    tzi.StandardStart.Month        = Tzi->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = Tzi->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = Tzi->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = Tzi->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = Tzi->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = Tzi->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = Tzi->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = Tzi->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = Tzi->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = Tzi->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = Tzi->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = Tzi->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = Tzi->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = Tzi->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = Tzi->DaylightDate.wMilliseconds;

    //
    // convert the input local time to NT style time
    //
    if ( !SystemTimeToFileTime(lpLocalTime,(LPFILETIME)&CurrentLocalTime) ) {
        return FALSE;
    }

    //
    // Get the new timezone bias
    //

    NewTimeZoneBias.QuadPart = Int32x32To64(tzi.Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //

    if ( tzi.StandardStart.Month && tzi.DaylightStart.Month ) {

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.StandardStart,
                &StandardTime,
                &CurrentLocalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
        }

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.DaylightStart,
                &DaylightTime,
                &CurrentLocalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
        }


        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( DaylightTime.QuadPart < StandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentLocalTime.QuadPart >= DaylightTime.QuadPart) &&
                 (CurrentLocalTime.QuadPart <  StandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
            }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }
        }
        else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentLocalTime.QuadPart >= StandardTime.QuadPart ) &&
                 (CurrentLocalTime.QuadPart <  DaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
            }
        }

        //
        // At this point, we know our current timezone and the
        // local time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                tzi.DaylightBias*60 :
                                tzi.StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

    }
    else {
        TimeZoneBias = NewTimeZoneBias;
    }

    ComputedUniversalTime.QuadPart = CurrentLocalTime.QuadPart + TimeZoneBias.QuadPart;

    if ( !FileTimeToSystemTime((LPFILETIME)&ComputedUniversalTime,lpUniversalTime) ) {
        return FALSE;
    } 

    return TRUE;
}

BOOL 
WINAPI 
SetClientTimeZoneInformation(
     IN CONST TIME_ZONE_INFORMATION *ptzi
     )
/*++

Routine Description:

    Sets information in global structures used 
    to calculate local time in TS session.    

Arguments:

    IN CONST TIME_ZONE_INFORMATION *ptzi 

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.
        Client time zone information may become invalid during this call
        In this case we will use time zone information from server

--*/

{
    NTSTATUS Status;
    
    BASE_API_MSG m;
    PBASE_SET_TERMSRVCLIENTTIMEZONE c = &m.u.SetTermsrvClientTimeZone;
    
    c->fFirstChunk=TRUE; //this meanes that this is only first portion of data
                         //we have to cut it ito two pieces because of
                         //message size restrictions (100 bytes)   
    c->Bias=ptzi->Bias;
    RtlCopyMemory(&c->Name,&ptzi->StandardName,sizeof(ptzi->StandardName));
    c->Date=ptzi->StandardDate;
    c->Bias1=ptzi->StandardBias;
    
#if defined(BUILD_WOW6432)
    Status = CsrBasepSetClientTimeZoneInformation(c);
#else
    Status = CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvClientTimeZone),
                                 sizeof( *c ));
#endif

    if ( !NT_SUCCESS( Status ) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return( FALSE );
    }
    
    c->fFirstChunk=FALSE; //this is a second and last portion of data
    RtlCopyMemory(&c->Name,&ptzi->DaylightName,sizeof(ptzi->DaylightName));
    c->Date=ptzi->DaylightDate;
    c->Bias1=ptzi->DaylightBias;
    c->TimeZoneId=CalcClientTimeZoneIdAndBias(ptzi,&c->RealBias);

#if defined(BUILD_WOW6432)
    Status = CsrBasepSetClientTimeZoneInformation(c);
#else
    Status = CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvClientTimeZone),
                                 sizeof( *c ));
#endif


    if ( !NT_SUCCESS( Status ) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return( FALSE );
    }

    return( TRUE );
}


ULONG 
CalcClientTimeZoneIdAndBias(
     IN CONST TIME_ZONE_INFORMATION *ptzi,
     OUT KSYSTEM_TIME *pBias)
/*++

Routine Description:

    Calculates current bias and time zone ID.    

Arguments:

    IN CONST TIME_ZONE_INFORMATION *ptzi - time zone for which to calculate bias
    OUT KSYSTEM_TIME *pBias - current bias

Return Value:

    TIME_ZONE_ID_UNKNOWN - daylight saving time is not used in the 
        current time zone.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    TIME_ZONE_ID_INVALID - The operation failed.  Extended error status is
        available using GetLastError.

--*/
{
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    SYSTEMTIME CurrentSystemTime;
    LARGE_INTEGER CurrentUniversalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;
    TIME_FIELDS StandardStart,DaylightStart;

    NewTimeZoneBias.QuadPart = Int32x32To64(ptzi->Bias*60, 10000000);

    
    
    //
    // Now see if we have stored cutover times
    //
    if ( ptzi->StandardDate.wMonth && ptzi->DaylightDate.wMonth ) {
        
        GetSystemTime(&CurrentSystemTime);
        SystemTimeToFileTime(&CurrentSystemTime,(LPFILETIME)&CurrentUniversalTime);

        StandardStart.Year         = ptzi->StandardDate.wYear        ;
        StandardStart.Month        = ptzi->StandardDate.wMonth       ;
        StandardStart.Weekday      = ptzi->StandardDate.wDayOfWeek   ;
        StandardStart.Day          = ptzi->StandardDate.wDay         ;
        StandardStart.Hour         = ptzi->StandardDate.wHour        ;
        StandardStart.Minute       = ptzi->StandardDate.wMinute      ;
        StandardStart.Second       = ptzi->StandardDate.wSecond      ;
        StandardStart.Milliseconds = ptzi->StandardDate.wMilliseconds;

        DaylightStart.Year         = ptzi->DaylightDate.wYear        ;
        DaylightStart.Month        = ptzi->DaylightDate.wMonth       ;
        DaylightStart.Weekday      = ptzi->DaylightDate.wDayOfWeek   ;
        DaylightStart.Day          = ptzi->DaylightDate.wDay         ;
        DaylightStart.Hour         = ptzi->DaylightDate.wHour        ;
        DaylightStart.Minute       = ptzi->DaylightDate.wMinute      ;
        DaylightStart.Second       = ptzi->DaylightDate.wSecond      ;
        DaylightStart.Milliseconds = ptzi->DaylightDate.wMilliseconds;

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if((!RtlCutoverTimeToSystemTime(&StandardStart,&StandardTime,
                &CurrentUniversalTime,TRUE)) || 
                (!RtlCutoverTimeToSystemTime(&DaylightStart,&DaylightTime,
                &CurrentUniversalTime,TRUE))) {

            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return TIME_ZONE_ID_INVALID;

        }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;

            } else {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }

        } else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart ) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;

            } else {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;

            }
        }

        //
        // At this point, we know our current timezone and the
        // Universal time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                ptzi->DaylightBias*60 :
                                ptzi->StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

    } else {

        TimeZoneBias = NewTimeZoneBias;
        CurrentTimeZoneId=TIME_ZONE_ID_UNKNOWN;
    }

 
    pBias->LowPart=(ULONG)(TimeZoneBias.LowPart);
    pBias->High1Time=pBias->High2Time=(LONG)(TimeZoneBias.HighPart);

    return CurrentTimeZoneId;
}

BOOL
IsTimeZoneRedirectionEnabled()
{
/*++

Routine Description:

    Checks if all conditions are met to allow Time Zone redirection
    on the TS session.    

Arguments:

    NONE

Return Value:

    TRUE - if we allowed to do TZ redirection.

--*/

    return (BaseStaticServerData->TermsrvClientTimeZoneId != TIME_ZONE_ID_INVALID);
}

/*
//These 2 functions will be needed for new timedate.cpl
DWORD
WINAPI
GetServerTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;
    
    
    //
    // get the timezone data from the system
    //

    Status = NtQuerySystemInformation(
                SystemCurrentTimeZoneInformation,
                &tzi,
                sizeof(tzi),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0xffffffff;
        }

    lpTimeZoneInformation->Bias         = tzi.Bias;
    lpTimeZoneInformation->StandardBias = tzi.StandardBias;
    lpTimeZoneInformation->DaylightBias = tzi.DaylightBias;
    RtlCopyMemory(&lpTimeZoneInformation->StandardName,&tzi.StandardName,sizeof(tzi.StandardName));
    RtlCopyMemory(&lpTimeZoneInformation->DaylightName,&tzi.DaylightName,sizeof(tzi.DaylightName));

    lpTimeZoneInformation->StandardDate.wYear         = tzi.StandardStart.Year        ;
    lpTimeZoneInformation->StandardDate.wMonth        = tzi.StandardStart.Month       ;
    lpTimeZoneInformation->StandardDate.wDayOfWeek    = tzi.StandardStart.Weekday     ;
    lpTimeZoneInformation->StandardDate.wDay          = tzi.StandardStart.Day         ;
    lpTimeZoneInformation->StandardDate.wHour         = tzi.StandardStart.Hour        ;
    lpTimeZoneInformation->StandardDate.wMinute       = tzi.StandardStart.Minute      ;
    lpTimeZoneInformation->StandardDate.wSecond       = tzi.StandardStart.Second      ;
    lpTimeZoneInformation->StandardDate.wMilliseconds = tzi.StandardStart.Milliseconds;

    lpTimeZoneInformation->DaylightDate.wYear         = tzi.DaylightStart.Year        ;
    lpTimeZoneInformation->DaylightDate.wMonth        = tzi.DaylightStart.Month       ;
    lpTimeZoneInformation->DaylightDate.wDayOfWeek    = tzi.DaylightStart.Weekday     ;
    lpTimeZoneInformation->DaylightDate.wDay          = tzi.DaylightStart.Day         ;
    lpTimeZoneInformation->DaylightDate.wHour         = tzi.DaylightStart.Hour        ;
    lpTimeZoneInformation->DaylightDate.wMinute       = tzi.DaylightStart.Minute      ;
    lpTimeZoneInformation->DaylightDate.wSecond       = tzi.DaylightStart.Second      ;
    lpTimeZoneInformation->DaylightDate.wMilliseconds = tzi.DaylightStart.Milliseconds;

    return USER_SHARED_DATA->TimeZoneId;
 
}

BOOL
WINAPI
SetServerTimeZoneInformation(
    CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    )
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    tzi.Bias            = lpTimeZoneInformation->Bias;
    tzi.StandardBias    = lpTimeZoneInformation->StandardBias;
    tzi.DaylightBias    = lpTimeZoneInformation->DaylightBias;

    RtlCopyMemory(&tzi.StandardName,&lpTimeZoneInformation->StandardName,sizeof(tzi.StandardName));
    RtlCopyMemory(&tzi.DaylightName,&lpTimeZoneInformation->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = lpTimeZoneInformation->StandardDate.wYear        ;
    tzi.StandardStart.Month        = lpTimeZoneInformation->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = lpTimeZoneInformation->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = lpTimeZoneInformation->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = lpTimeZoneInformation->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = lpTimeZoneInformation->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = lpTimeZoneInformation->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = lpTimeZoneInformation->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = lpTimeZoneInformation->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = lpTimeZoneInformation->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = lpTimeZoneInformation->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = lpTimeZoneInformation->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = lpTimeZoneInformation->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = lpTimeZoneInformation->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = lpTimeZoneInformation->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = lpTimeZoneInformation->DaylightDate.wMilliseconds;

    Status = RtlSetTimeZoneInformation( &tzi );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    //
    // Refresh the system's concept of time
    //

    NtSetSystemTime(NULL,NULL);

    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\csrsxs.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrsxs.c

Abstract:

    This module implements functions that are used by the Side-by-Side
    Win32 APIs.

Author:

    Samer Arafeh (samera)     20-May-2000

Revision History:

    Jay Krell (a-JayK) June, July 2000
        factored/merged with sxs.c, source code duplication eliminated
        moved file opening out of csrss.exe to client process
--*/

#include "basedll.h"
#include <sxstypes.h>
#include <limits.h>

typedef void * POINTER_32 PVOID32;

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    || (x) == STATUS_RESOURCE_DATA_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_TYPE_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_NAME_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_LANG_NOT_FOUND  \
                                    || (x) == STATUS_SXS_CANT_GEN_ACTCTX      \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

VOID
BasepSxsDbgPrintMessageStream(
    PCSTR Function,
    PCSTR StreamName,
    PBASE_MSG_SXS_STREAM MessageStream
    )
{
    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s() %s {\n"
        "SXS:    FileType:%s\n"
        "SXS:    PathType:%s\n"
        "SXS:    Path:%wZ\n"
        "SXS:    FileHandle:%p\n"
        "SXS:    HandleType:%s\n"
        "SXS:    Handle:%p\n"
        "SXS:    Offset:0x%I64x\n"
        "SXS:    Size:0x%Ix\n"
        "SXS: }\n",
        Function,
        StreamName,
        (MessageStream->FileType == BASE_MSG_FILETYPE_NONE ? "None" :
         MessageStream->FileType == BASE_MSG_FILETYPE_XML ? "Xml" :
         MessageStream->FileType == BASE_MSG_FILETYPE_PRECOMPILED_XML ? "PrecompiledXml" : "Unknown"),

        (MessageStream->PathType == BASE_MSG_PATHTYPE_NONE     ? "None" :
         MessageStream->PathType == BASE_MSG_PATHTYPE_FILE     ? "File" :
         MessageStream->PathType == BASE_MSG_PATHTYPE_URL      ? "Url"  :
         MessageStream->PathType == BASE_MSG_PATHTYPE_OVERRIDE ? "Override" : "Unknown"),

        &MessageStream->Path,

        MessageStream->FileHandle,

        (MessageStream->HandleType == BASE_MSG_HANDLETYPE_NONE ? "None" :
         MessageStream->HandleType == BASE_MSG_HANDLETYPE_PROCESS ? "Process" :
         MessageStream->HandleType == BASE_MSG_HANDLETYPE_CLIENT_PROCESS ? "ClientProcess" :
         MessageStream->HandleType == BASE_MSG_HANDLETYPE_SECTION ? "Section" : "Unknown"),

        MessageStream->Handle,
        MessageStream->Offset,
        MessageStream->Size));
}


NTSTATUS
CsrBasepCreateActCtx(
    IN PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message
    )
{
    NTSTATUS Status;
#if defined(BUILD_WOW6432)
    Status = NtWow64CsrBasepCreateActCtx(Message);
#else
    BASE_API_MSG m;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

	//
	// BUILD_WOW64 means we are 64bit code in a 32bit process "between" csrss and a 32bit client.
	// We are in the static thunk library linked into wow64.dll.
	//
	// Neither native x86 nor native ia64 code needs to worry about the pointer sizes here.
	//
#if defined(BUILD_WOW64)
    PVOID    ActivationContextDataLocal64 = NULL;
    PVOID32* ActivationContextDataOut32 = NULL;
#endif

#if DBG
    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s() Message {\n"
        "SXS:   Flags:(%s | %s | %s)\n"
        "SXS:   ProcessorArchitecture:%lx\n"
        "SXS:   LangId:%lx\n"
        "SXS:   AssemblyDirectory:%wZ\n"
        "SXS:   TextualAssemblyIdentity:%wZ\n"
        "SXS: }\n",
        __FUNCTION__,
        (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) ? "MANIFEST_PRESENT" : "0",
        (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) ? "POLICY_PRESENT" : "0",
        (Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT) ? "TEXTUAL_ASSEMBLY_IDENTITY_PRESENT" : "0",
        Message->ProcessorArchitecture,
        Message->LangId,
        &Message->AssemblyDirectory,
        &Message->TextualAssemblyIdentity
        ));

    if (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) {
        BasepSxsDbgPrintMessageStream(__FUNCTION__, "Manifest", &Message->Manifest);
    }
    if (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) {
        BasepSxsDbgPrintMessageStream(__FUNCTION__, "Policy", &Message->Policy);
    }
#endif

    m.u.SxsCreateActivationContext = *Message;
    
    {
        const PUNICODE_STRING StringsToCapture[] = 
        {
            &m.u.SxsCreateActivationContext.Manifest.Path,
            ( Message->Flags & BASE_MSG_SXS_POLICY_PRESENT )
                ? &m.u.SxsCreateActivationContext.Policy.Path
                : NULL,
            &m.u.SxsCreateActivationContext.AssemblyDirectory,
            ( Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT )
                ? &m.u.SxsCreateActivationContext.TextualAssemblyIdentity
                : NULL
        };


        Status = CsrCaptureMessageMultiUnicodeStringsInPlace(
            &CaptureBuffer,
            RTL_NUMBER_OF(StringsToCapture),
            StringsToCapture
            );

        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() CsrCaptureMessageMultiUnicodeStringsInPlace failed\n", __FUNCTION__);
            goto Exit;
        }
    }

#if defined(BUILD_WOW64)
    if (m.u.SxsCreateActivationContext.ActivationContextData != NULL) {
        ActivationContextDataOut32 = (PVOID32*)m.u.SxsCreateActivationContext.ActivationContextData;
        m.u.SxsCreateActivationContext.ActivationContextData = (PVOID*)&ActivationContextDataLocal64;
    }
#endif

    Status = CsrClientCallServer((PCSR_API_MSG) &m,
                                   CaptureBuffer,
                                   CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX, 
                                                       BasepSxsCreateActivationContext),
                                   sizeof(*Message));

#if defined(BUILD_WOW64)
    if ((m.u.SxsCreateActivationContext.ActivationContextData != NULL) &&
        (ActivationContextDataOut32 != NULL)) {
        *ActivationContextDataOut32 = (PVOID32) ActivationContextDataLocal64;
    }
#endif

Exit:
    if ( CaptureBuffer != NULL )
        CsrFreeCaptureBuffer(CaptureBuffer);
    

#endif
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\debug.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements Win32 Debug APIs

Author:

    Mark Lucovsky (markl) 06-Feb-1991

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#define TmpHandleHead ((PTMPHANDLES *) (&NtCurrentTeb()->DbgSsReserved[0]))
//
// This structure is used to preserve the strange mechanisms used by win2k and nt4 to close the handles to open processes,
// threads and main image file.
//
typedef struct _TMPHANDLES {
    struct _TMPHANDLES *Next;
    HANDLE Thread;
    HANDLE Process;
    DWORD dwProcessId;
    DWORD dwThreadId;
    BOOLEAN DeletePending;
} TMPHANDLES, *PTMPHANDLES;

VOID
SaveThreadHandle (
    DWORD dwProcessId,
    DWORD dwThreadId,
    HANDLE HandleToThread)
/*++

Routine Description:

    This function saves away a handle to a thread in a thread specific list so we can close it later when the thread
    termination message is continued.

Arguments:

    dwProcessId    - Process ID of threads process
    dwThreadId     - Thread ID of thread handle
    HandleToThread - Handle to be closed later

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp;

    Tmp = RtlAllocateHeap (RtlProcessHeap(), 0, sizeof (TMPHANDLES));
    if (Tmp != NULL) {
        Tmp->Thread = HandleToThread;
        Tmp->Process = NULL;
        Tmp->dwProcessId = dwProcessId;
        Tmp->dwThreadId = dwThreadId;
        Tmp->DeletePending = FALSE;
        Tmp->Next = *TmpHandleHead;
        *TmpHandleHead = Tmp;
    }
}

VOID
SaveProcessHandle (
    DWORD dwProcessId,
    HANDLE HandleToProcess
    )
/*++

Routine Description:

    This function saves away a handle to a process and file in a thread specific list so we can close it later
    when the process termination message is continued.

Arguments:

    dwProcessId     - Process ID of threads process
    HandleToProcess - Handle to be closed later
    HandleToFile    - Handle to be closed later

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp;

    Tmp = RtlAllocateHeap (RtlProcessHeap(), 0, sizeof (TMPHANDLES));
    if (Tmp != NULL) {
        Tmp->Process = HandleToProcess;
        Tmp->Thread = NULL;
        Tmp->dwProcessId = dwProcessId;
        Tmp->dwThreadId = 0;
        Tmp->DeletePending = FALSE;
        Tmp->Next = *TmpHandleHead;
        *TmpHandleHead = Tmp;
    }
}

VOID
MarkThreadHandle (
    DWORD dwThreadId
    )
/*++

Routine Description:

    This function marks a saved thread handle so that the next time this thread is continued we close
    its handle

Arguments:

    dwThreadId     - Thread ID of thread handle

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp;

    Tmp = *TmpHandleHead;

    while (Tmp != NULL) {
        if (Tmp->dwThreadId == dwThreadId) {
            Tmp->DeletePending = TRUE;
            break;
        }
        Tmp = Tmp->Next;
    }
}

VOID
MarkProcessHandle (
    DWORD dwProcessId
    )
{
    PTMPHANDLES Tmp;

    Tmp = *TmpHandleHead;

    while (Tmp != NULL) {
        if (Tmp->dwProcessId == dwProcessId && Tmp->dwThreadId == 0) {
            Tmp->DeletePending = TRUE;
            break;
        }
        Tmp = Tmp->Next;
    }
}

VOID 
RemoveHandles (
    DWORD dwThreadId,
    DWORD dwProcessId
    )
/*++

Routine Description:

    This function closes marked handles for this process and thread id

Arguments:

    dwProcessId    - Process ID of threads process
    dwThreadId     - Thread ID of thread handle

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp, *Last;

    Last = TmpHandleHead;

    Tmp = *Last;
    while (Tmp != NULL) {
        if (Tmp->DeletePending) {
            if (Tmp->dwProcessId == dwProcessId || Tmp->dwThreadId == dwThreadId) {
                if (Tmp->Thread != NULL) {
                    CloseHandle (Tmp->Thread);
                }
                if (Tmp->Process != NULL) {
                    CloseHandle (Tmp->Process);
                }
                *Last = Tmp->Next;
                RtlFreeHeap (RtlProcessHeap(), 0, Tmp);
                Tmp = *Last;
                continue;
            }
        }
        Last = &Tmp->Next;
        Tmp = Tmp->Next;
    }
}

VOID
CloseAllProcessHandles (
    DWORD dwProcessId
    )
/*++

Routine Description:

    This function closes all saved handles when we stop debugging a single process

Arguments:

    dwProcessId    - Process ID of threads process

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp, *Last;

    Last = TmpHandleHead;

    Tmp = *Last;
    while (Tmp != NULL) {
        if (Tmp->dwProcessId == dwProcessId) {
            if (Tmp->Thread != NULL) {
                CloseHandle (Tmp->Thread);
            }
            if (Tmp->Process != NULL) {
                CloseHandle (Tmp->Process);
            }
            *Last = Tmp->Next;
            RtlFreeHeap (RtlProcessHeap(), 0, Tmp);
            Tmp = *Last;
            continue;
        }
        Last = &Tmp->Next;
        Tmp = Tmp->Next;
    }

}


BOOL
APIENTRY
IsDebuggerPresent(
    VOID
    )

/*++

Routine Description:

    This function returns TRUE if the current process is being debugged
    and FALSE if not.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return NtCurrentPeb()->BeingDebugged;
}

BOOL
APIENTRY
CheckRemoteDebuggerPresent(
    IN HANDLE hProcess,
    OUT PBOOL pbDebuggerPresent
    )

/*++

Routine Description:

    This function determines whether the remote process is being debugged.

Arguments:

    hProcess - handle to the process
    pbDebuggerPresent - supplies a buffer to receive the result of the check
        TRUE  - remote process is being debugged
        FALSE - remote process is not being debugged

Return Value:

    TRUE  - The function succeeded.
    FALSE - The function fail.  Extended error status is available using
            GetLastError.

--*/

{
    HANDLE hDebugPort;
    NTSTATUS Status;

    if( (hProcess == NULL) || (pbDebuggerPresent == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessDebugPort,
                (PVOID)(&hDebugPort),
                sizeof(hDebugPort),
                NULL
                );

    if( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError( Status );
        return FALSE;
    }

    *pbDebuggerPresent = (hDebugPort != NULL);

    return TRUE;
}

//#ifdef i386
//#pragma optimize("",off)
//#endif // i386
VOID
APIENTRY
DebugBreak(
    VOID
    )

/*++

Routine Description:

    This function causes a breakpoint exception to occur in the caller.
    This allows the calling thread to signal the debugger forcing it to
    take some action.  If the process is not being debugged, the
    standard exception search logic is invoked.  In most cases, this
    will cause the calling process to terminate (due to an unhandled
    breakpoint exception).

Arguments:

    None.

Return Value:

    None.

--*/

{
    DbgBreakPoint();
}
//#ifdef i386
//#pragma optimize("",on)
//#endif // i386

VOID
APIENTRY
OutputDebugStringW(
    LPCWSTR lpOutputString
    )

/*++

Routine Description:

    UNICODE thunk to OutputDebugStringA

--*/

{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    RtlInitUnicodeString (&UnicodeString,lpOutputString);
    Status = RtlUnicodeStringToAnsiString (&AnsiString,&UnicodeString,TRUE);
    if (!NT_SUCCESS (Status)) {
        AnsiString.Buffer = "";
    }
    OutputDebugStringA (AnsiString.Buffer);
    if (NT_SUCCESS (Status)) {
        RtlFreeAnsiString (&AnsiString);
    }
}


#define DBWIN_TIMEOUT   10000
HANDLE CreateDBWinMutex(VOID) {

    SECURITY_ATTRIBUTES SecurityAttributes;
    SECURITY_DESCRIPTOR sd;
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidEveryone = NULL;
    PACL pAcl = NULL;
    DWORD cbAcl, aceIndex;
    HANDLE h = NULL;
    DWORD i;
    //
    // Get the system sid
    //

    Status = RtlAllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                   0, 0, 0, 0, 0, 0, 0, &psidSystem);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Get the Admin sid
    //

    Status = RtlAllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                       DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                       0, 0, 0, 0, &psidAdmin);

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }


    //
    // Get the World sid
    //

    Status = RtlAllocateAndInitializeSid(&authWorld, 1, SECURITY_WORLD_RID,
                      0, 0, 0, 0, 0, 0, 0, &psidEveryone);

    if (!NT_SUCCESS(Status)) {
          goto Exit;
    }

    //
    // Allocate space for the ACL
    //

    cbAcl = sizeof(ACL) +
            3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
            RtlLengthSid(psidSystem) +
            RtlLengthSid(psidAdmin) +
            RtlLengthSid(psidEveryone);

    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }

    Status = RtlCreateAcl(pAcl, cbAcl, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Add Aces.
    //

    Status = RtlAddAccessAllowedAce(pAcl, ACL_REVISION, READ_CONTROL | SYNCHRONIZE | MUTEX_MODIFY_STATE, psidEveryone);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = RtlAddAccessAllowedAce(pAcl, ACL_REVISION, MUTEX_ALL_ACCESS, psidSystem);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = RtlAddAccessAllowedAce(pAcl, ACL_REVISION, MUTEX_ALL_ACCESS, psidAdmin);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status)) {
       goto Exit;
    }

    Status = RtlSetDaclSecurityDescriptor(&sd, TRUE, pAcl, FALSE);
    if (!NT_SUCCESS(Status)) {
       goto Exit;
    }

    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributes.bInheritHandle = FALSE;
    SecurityAttributes.lpSecurityDescriptor = &sd;

    i = 0;
    while (1) {
        h = OpenMutex (READ_CONTROL | SYNCHRONIZE | MUTEX_MODIFY_STATE,
                       FALSE,
                       "DBWinMutex");
        if (h != NULL) {
            break;
        }
        h = CreateMutex(&SecurityAttributes, FALSE, "DBWinMutex");
        if (h != NULL || GetLastError () != ERROR_ACCESS_DENIED || i++ > 100) {
            break;
        }
    }
Exit:
    if (psidSystem) {
        RtlFreeSid(psidSystem);
    }

    if (psidAdmin) {
        RtlFreeSid(psidAdmin);
    }

    if (psidEveryone) {
        RtlFreeSid(psidEveryone);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }
    return h;
}


VOID
APIENTRY
OutputDebugStringA(
    IN LPCSTR lpOutputString
    )

/*++

Routine Description:

    This function allows an application to send a string to its debugger
    for display.  If the application is not being debugged, but the
    system debugger is active, the system debugger displays the string.
    Otherwise, this function has no effect.

Arguments:

    lpOutputString - Supplies the address of the debug string to be sent
        to the debugger.

Return Value:

    None.

--*/

{
    ULONG_PTR ExceptionArguments[2];
    DWORD WaitStatus;

    //
    // Raise an exception. If APP is being debugged, the debugger
    // will catch and handle this. Otherwise, kernel debugger is
    // called.
    //

    try {
        ExceptionArguments[0] = strlen (lpOutputString)+1;
        ExceptionArguments[1] = (ULONG_PTR)lpOutputString;
        RaiseException (DBG_PRINTEXCEPTION_C,0,2,ExceptionArguments);
    } except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // We caught the debug exception, so there's no user-mode
        // debugger.  If there is a DBWIN running, send the string
        // to it.  If not, use DbgPrint to send it to the kernel
        // debugger.  DbgPrint can only handle 511 characters at a
        // time, so force-feed it.
        //

        char   szBuf[512];
        size_t cchRemaining;
        LPCSTR pszRemainingOutput;
        DWORD OldError;

        HANDLE SharedFile = NULL;
        LPSTR SharedMem = NULL;
        HANDLE AckEvent = NULL;
        HANDLE ReadyEvent = NULL;

        static HANDLE DBWinMutex = NULL;
        static BOOLEAN CantGetMutex = FALSE;

        OldError = GetLastError ();

        //
        // look for DBWIN.
        //

        if (!DBWinMutex && !CantGetMutex) {
            HANDLE MutexHandle;

            MutexHandle = CreateDBWinMutex();
            if (MutexHandle == NULL) {
                CantGetMutex = TRUE;
            } else {
                if (InterlockedCompareExchangePointer (&DBWinMutex, MutexHandle, NULL) != NULL) {
                    CloseHandle (MutexHandle);
                }
            }
        }

        if (DBWinMutex) {

            WaitStatus = WaitForSingleObject(DBWinMutex, DBWIN_TIMEOUT);

            if (WaitStatus ==  WAIT_OBJECT_0 || WaitStatus == WAIT_ABANDONED) {

                SharedFile = OpenFileMapping(FILE_MAP_WRITE, FALSE, "DBWIN_BUFFER");

                if (SharedFile) {

                    SharedMem = MapViewOfFile (SharedFile,
                                               FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, 0);
                    if (SharedMem) {

                        AckEvent = OpenEvent(SYNCHRONIZE, FALSE,
                                             "DBWIN_BUFFER_READY");
                        if (AckEvent) {
                            ReadyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE,
                                                   "DBWIN_DATA_READY");
                        }
                    }
                }

                if (!ReadyEvent) {
                    ReleaseMutex(DBWinMutex);
                }
            }

        }

        try {
            pszRemainingOutput = lpOutputString;
            cchRemaining = strlen(pszRemainingOutput);

            while (cchRemaining > 0) {
                int used;

                if (ReadyEvent && WaitForSingleObject(AckEvent, DBWIN_TIMEOUT)
                                                            == WAIT_OBJECT_0) {

                    *((DWORD *)SharedMem) = GetCurrentProcessId();

                    used = (int)((cchRemaining < 4095 - sizeof(DWORD)) ?
                                         cchRemaining : (4095 - sizeof(DWORD)));

                    RtlCopyMemory(SharedMem+sizeof(DWORD),
                                  pszRemainingOutput,
                                  used);
                    SharedMem[used+sizeof(DWORD)] = 0;
                    SetEvent(ReadyEvent);

                } else {
                    used = (int)((cchRemaining < sizeof(szBuf) - 1) ?
                                           cchRemaining : (int)(sizeof(szBuf) - 1));

                    RtlCopyMemory(szBuf, pszRemainingOutput, used);
                    szBuf[used] = 0;
                    DbgPrint("%s", szBuf);
                }

                pszRemainingOutput += used;
                cchRemaining       -= used;

            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            DbgPrint("\nOutputDebugString faulted during output\n");
        }

        if (AckEvent) {
            CloseHandle(AckEvent);
        }

        if (SharedMem) {
            UnmapViewOfFile(SharedMem);
        }

        if (SharedFile) {
            CloseHandle(SharedFile);
        }

        if (ReadyEvent) {
            CloseHandle(ReadyEvent);
            ReleaseMutex(DBWinMutex);
        }

        SetLastError (OldError);
    }
}

BOOL
APIENTRY
WaitForDebugEvent(
    LPDEBUG_EVENT lpDebugEvent,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A debugger waits for a debug event to occur in one of its debuggees
    using WaitForDebugEvent:

    Upon successful completion of this API, the lpDebugEvent structure
    contains the relevant information of the debug event.

Arguments:

    lpDebugEvent - Receives information specifying the type of debug
        event that occured.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test for debug
        events A timeout value of -1 specifies an infinite timeout
        period.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed (or timed out).  Extended error
        status is available using GetLastError.

--*/

{
    NTSTATUS Status;
    DBGUI_WAIT_STATE_CHANGE StateChange;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;


    pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);

again:
    Status = DbgUiWaitStateChange(&StateChange,pTimeOut);
    if ( Status == STATUS_ALERTED || Status == STATUS_USER_APC) {
        goto again;
        }
    if ( !NT_SUCCESS(Status) && Status != DBG_UNABLE_TO_PROVIDE_HANDLE ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( Status == STATUS_TIMEOUT ) {
        SetLastError(ERROR_SEM_TIMEOUT);
        return FALSE;
        }
    Status = DbgUiConvertStateChangeStructure  (&StateChange, lpDebugEvent);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    switch (lpDebugEvent->dwDebugEventCode) {

    case CREATE_THREAD_DEBUG_EVENT :
        //
        // Save away thread handle for later cleanup.
        //
        SaveThreadHandle (lpDebugEvent->dwProcessId,
                          lpDebugEvent->dwThreadId,
                          lpDebugEvent->u.CreateThread.hThread);
        break;

    case CREATE_PROCESS_DEBUG_EVENT :

        SaveProcessHandle (lpDebugEvent->dwProcessId,
                           lpDebugEvent->u.CreateProcessInfo.hProcess);

        SaveThreadHandle (lpDebugEvent->dwProcessId,
                          lpDebugEvent->dwThreadId,
                          lpDebugEvent->u.CreateProcessInfo.hThread);

        break;

    case EXIT_THREAD_DEBUG_EVENT :

        MarkThreadHandle (lpDebugEvent->dwThreadId);

        break;

    case EXIT_PROCESS_DEBUG_EVENT :

        MarkThreadHandle (lpDebugEvent->dwThreadId);
        MarkProcessHandle (lpDebugEvent->dwProcessId);

        break;

    case OUTPUT_DEBUG_STRING_EVENT :
    case RIP_EVENT :
    case EXCEPTION_DEBUG_EVENT :
        break;

    case LOAD_DLL_DEBUG_EVENT :
        break;

    case UNLOAD_DLL_DEBUG_EVENT :
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL
APIENTRY
ContinueDebugEvent(
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwContinueStatus
    )

/*++

Routine Description:

    A debugger can continue a thread that previously reported a debug
    event using ContinueDebugEvent.

    Upon successful completion of this API, the specified thread is
    continued.  Depending on the debug event previously reported by the
    thread certain side effects occur.

    If the continued thread previously reported an exit thread debug
    event, the handle that the debugger has to the thread is closed.

    If the continued thread previously reported an exit process debug
    event, the handles that the debugger has to the thread and to the
    process are closed.

Arguments:

    dwProcessId - Supplies the process id of the process to continue. The
        combination of process id and thread id must identify a thread that
        has previously reported a debug event.

    dwThreadId - Supplies the thread id of the thread to continue. The
        combination of process id and thread id must identify a thread that
        has previously reported a debug event.

    dwContinueStatus - Supplies the continuation status for the thread
        reporting the debug event.

        dwContinueStatus Values:

            DBG_CONTINUE - If the thread being continued had
                previously reported an exception event, continuing with
                this value causes all exception processing to stop and
                the thread continues execution.  For any other debug
                event, this continuation status simply allows the thread
                to continue execution.

            DBG_EXCEPTION_NOT_HANDLED - If the thread being continued
                had previously reported an exception event, continuing
                with this value causes exception processing to continue.
                If this is a first chance exception event, then
                structured exception handler search/dispatch logic is
                invoked.  Otherwise, the process is terminated.  For any
                other debug event, this continuation status simply
                allows the thread to continue execution.

            DBG_TERMINATE_THREAD - After all continue side effects are
                processed, this continuation status causes the thread to
                jump to a call to ExitThread.  The exit code is the
                value DBG_TERMINATE_THREAD.

            DBG_TERMINATE_PROCESS - After all continue side effects are
                processed, this continuation status causes the thread to
                jump to a call to ExitProcess.  The exit code is the
                value DBG_TERMINATE_PROCESS.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    CLIENT_ID ClientId;

    ClientId.UniqueProcess = (HANDLE)LongToHandle(dwProcessId);
    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);


    Status = DbgUiContinue(&ClientId,(NTSTATUS)dwContinueStatus);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    RemoveHandles (dwThreadId, dwProcessId);

    return TRUE;
}

HANDLE
ProcessIdToHandle (
    IN DWORD dwProcessId
    )
{
    OBJECT_ATTRIBUTES oa;
    HANDLE Process;
    CLIENT_ID ClientId;
    NTSTATUS Status;

    if (dwProcessId == -1) {
        ClientId.UniqueProcess = CsrGetProcessId ();
    } else {
        ClientId.UniqueProcess = LongToHandle(dwProcessId);
    }
    ClientId.UniqueThread = NULL;

    InitializeObjectAttributes (&oa, NULL, 0, NULL, NULL);

    Status = NtOpenProcess (&Process,
                            PROCESS_SET_PORT|PROCESS_CREATE_THREAD|PROCESS_QUERY_INFORMATION|PROCESS_VM_OPERATION|
                                PROCESS_VM_WRITE|PROCESS_VM_READ,
                            &oa,
                            &ClientId);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        Process = NULL;
    }
    return Process;
}

BOOL
APIENTRY
DebugActiveProcess(
    DWORD dwProcessId
    )

/*++

Routine Description:

    This API allows a debugger to attach to an active process and debug
    the process.  The debugger specifies the process that it wants to
    debug through the process id of the target process.  The debugger
    gets debug access to the process as if it had created the process
    with the DEBUG_ONLY_THIS_PROCESS creation flag.

    The debugger must have approriate access to the calling process such
    that it can open the process for PROCESS_ALL_ACCESS.  For Dos/Win32
    this never fails (the process id just has to be a valid process id).
    For NT/Win32 this check can fail if the target process was created
    with a security descriptor that denies the debugger approriate
    access.

    Once the process id check has been made and the system determines
    that a valid debug attachment is being made, this call returns
    success to the debugger.  The debugger is then expected to wait for
    debug events.  The system will suspend all threads in the process
    and feed the debugger debug events representing the current state of
    the process.

    The system will feed the debugger a single create process debug
    event representing the process specified by dwProcessId.  The
    lpStartAddress field of the create process debug event is NULL.  For
    each thread currently part of the process, the system will send a
    create thread debug event.  The lpStartAddress field of the create
    thread debug event is NULL.  For each DLL currently loaded into the
    address space of the target process, the system will send a LoadDll
    debug event.  The system will arrange for the first thread in the
    process to execute a breakpoint instruction after it is resumed.
    Continuing this thread causes the thread to return to whatever it
    was doing prior to the debug attach.

    After all of this has been done, the system resumes all threads within
    the process. When the first thread in the process resumes, it will
    execute a breakpoint instruction causing an exception debug event
    to be sent to the debugger.

    All future debug events are sent to the debugger using the normal
    mechanism and rules.


Arguments:

    dwProcessId - Supplies the process id of a process the caller
        wants to debug.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE Process;
    NTSTATUS Status, Status1;


    //
    // Connect to dbgss as a user interface
    //

    Status = DbgUiConnectToDbg ();
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }


    //
    // Convert the process ID to a handle
    //
    Process = ProcessIdToHandle (dwProcessId);
    if (Process == NULL) {
        return FALSE;
    }


    Status = DbgUiDebugActiveProcess (Process);

    if (!NT_SUCCESS (Status))  {
        Status1 = NtClose (Process);
        ASSERT (NT_SUCCESS (Status1));
        BaseSetLastNTError (Status);
        return FALSE;
    }

    Status1 = NtClose (Process);
    ASSERT (NT_SUCCESS (Status1));

    return TRUE;
}

BOOL
APIENTRY
DebugActiveProcessStop(
    DWORD dwProcessId
    )

/*++

Routine Description:



Arguments:

    dwProcessId - Supplies the process id of a process the caller
        wants to stop debugging.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE Process, Thread;
    NTSTATUS Status;
    NTSTATUS Status1;
    DWORD ThreadId;

    Process = ProcessIdToHandle (dwProcessId);
    if (Process == NULL) {
        return FALSE;
    }
    //
    // Tell dbgss we have finished with this process.
    //

    CloseAllProcessHandles (dwProcessId);
    Status = DbgUiStopDebugging (Process);

    Status1 = NtClose (Process);

    ASSERT (NT_SUCCESS (Status1));

    if (!NT_SUCCESS(Status)) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
DebugBreakProcess (
    IN HANDLE Process
    )
/*++

Routine Description:

    This functions creates a thread inside the target process that issues a break.

Arguments:

    Process - Handle to process

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = DbgUiIssueRemoteBreakin (Process);
    if (NT_SUCCESS (Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError (Status);
        return FALSE;
    }
}

BOOL
APIENTRY
DebugSetProcessKillOnExit (
    IN BOOL KillOnExit
    )
/*++

Routine Description:

    This functions sets the action to be performed when the debugging thread dies

Arguments:

    KillOnExit - TRUE: Kill debugged processes on exit, FALSE: Detatch on debug exit

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    HANDLE DebugHandle;
    ULONG Flags;
    NTSTATUS Status;

    DebugHandle = DbgUiGetThreadDebugObject ();
    if (DebugHandle == NULL) {
        BaseSetLastNTError (STATUS_INVALID_HANDLE);
        return FALSE;
    }

    if (KillOnExit) {
        Flags = DEBUG_KILL_ON_CLOSE;
    } else {
        Flags = 0;
    }

    Status = NtSetInformationDebugObject (DebugHandle,
                                          DebugObjectFlags,
                                          &Flags,
                                          sizeof (Flags),
                                          NULL);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }
    return TRUE;
}

BOOL
APIENTRY
GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    )

/*++

Routine Description:

    This function is used to return a descriptor table entry for the
    specified thread corresponding to the specified selector.

    This API is only functional on x86 based systems. For non x86 based
    systems. A value of FALSE is returned.

    This API is used by a debugger so that it can convert segment
    relative addresses to linear virtual address (since this is the only
    format supported by ReadProcessMemory and WriteProcessMemory.

Arguments:

    hThread - Supplies a handle to the thread that contains the
        specified selector.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

    dwSelector - Supplies the selector value to lookup.  The selector
        value may be a global selector or a local selector.

    lpSelectorEntry - If the specified selector is contained withing the
        threads descriptor tables, this parameter returns the selector
        entry corresponding to the specified selector value.  This data
        can be used to compute the linear base address that segment
        relative addresses refer to.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
#if defined(i386)

    DESCRIPTOR_TABLE_ENTRY DescriptorEntry;
    NTSTATUS Status;

    DescriptorEntry.Selector = dwSelector;
    Status = NtQueryInformationThread(
                hThread,
                ThreadDescriptorTableEntry,
                &DescriptorEntry,
                sizeof(DescriptorEntry),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    *lpSelectorEntry = DescriptorEntry.Descriptor;
    return TRUE;

#else
    BaseSetLastNTError(STATUS_NOT_SUPPORTED);
    return FALSE;
#endif // i386

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\dllatom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    atom.c

Abstract:

    This module contains the Win32 Atom Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

typedef ATOM *PATOM;

BOOL
InternalGetIntAtom(
    PUNICODE_STRING UnicodeAtomName,
    PATOM Atom
    );

ATOM
InternalAddAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    );

ATOM
InternalFindAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    );

ATOM
InternalDeleteAtom(
    BOOLEAN UseLocalAtomTable,
    ATOM nAtom
    );

UINT
InternalGetAtomName(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    ATOM nAtom,
    LPSTR AtomName,
    DWORD nSize
    );


ATOM
GlobalAddAtomA(
    LPCSTR lpString
    )
{
    return( InternalAddAtom( FALSE, FALSE, lpString ) );
}

ATOM
GlobalFindAtomA(
    LPCSTR lpString
    )
{
    return( InternalFindAtom( FALSE, FALSE, lpString) );
}

ATOM
GlobalDeleteAtom(
    ATOM nAtom
    )
{
    return( InternalDeleteAtom( FALSE, nAtom ) );
}

UINT
GlobalGetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( FALSE, FALSE, nAtom, lpBuffer, (DWORD)nSize ) );
}

ATOM
APIENTRY
GlobalAddAtomW(
    LPCWSTR lpString
    )
{
    return( InternalAddAtom( FALSE, TRUE, (LPSTR)lpString ) );
}

ATOM
APIENTRY
GlobalFindAtomW(
    LPCWSTR lpString
    )
{
    return( InternalFindAtom( FALSE, TRUE, (LPSTR)lpString) );
}

UINT
APIENTRY
GlobalGetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( FALSE, TRUE, nAtom, (LPSTR)lpBuffer, (DWORD)nSize ) );
}

PVOID BaseLocalAtomTable;

BOOL
APIENTRY
InitAtomTable(
    DWORD nSize
    )
{
    if (nSize < 4 || nSize > 511) {
        nSize = 37;
    }

    return RtlCreateAtomTable( nSize, &BaseLocalAtomTable ) == STATUS_SUCCESS;
}

ATOM
AddAtomA(
    LPCSTR lpString
    )
{
    return( InternalAddAtom( TRUE, FALSE, lpString ) );
}

ATOM
FindAtomA(
    LPCSTR lpString
    )
{
    return( InternalFindAtom( TRUE, FALSE, lpString ) );
}

ATOM
DeleteAtom(
    ATOM nAtom
    )
{
    return( InternalDeleteAtom( TRUE, nAtom ) );
}

UINT
GetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( TRUE, FALSE, nAtom, lpBuffer, (DWORD)nSize ) );
}

ATOM
APIENTRY
AddAtomW(
    LPCWSTR lpString
    )
{
    return( InternalAddAtom( TRUE, TRUE, (LPSTR)lpString ) );
}

ATOM
APIENTRY
FindAtomW(
    LPCWSTR lpString
    )
{
    return( InternalFindAtom( TRUE, TRUE, (LPSTR)lpString ) );
}

UINT
APIENTRY
GetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( TRUE, TRUE, nAtom, (LPSTR)lpBuffer, (DWORD)nSize ) );
}

PVOID
InternalInitAtomTable( void )
{
    NTSTATUS Status;

    if (BaseLocalAtomTable == NULL) {
        Status = RtlCreateAtomTable( 0, &BaseLocalAtomTable );
    }

    return BaseLocalAtomTable;
}

ATOM
InternalAddAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING UnicodeAtomName;
    ATOM Atom;

    if ( (ULONG_PTR)AtomName <= 0xFFFF ) {
        Atom = (ATOM)PtrToShort((PVOID)AtomName);
        if (Atom >= MAXINTATOM) {
            BaseSetLastNTError( STATUS_INVALID_PARAMETER );
            return( INVALID_ATOM );
        } else {
            return( (ATOM)Atom );
        }
    } else {
        try {
            if (IsUnicodeAtomName) {
                UnicodeAtomName = &UnicodeString;
                RtlInitUnicodeString( UnicodeAtomName, (PWSTR)AtomName );
                Status = STATUS_SUCCESS;
            } else {
                RtlInitAnsiString( &AnsiString, AtomName );
                if (AnsiString.MaximumLength > STATIC_UNICODE_BUFFER_LENGTH) {
                    UnicodeAtomName = &UnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, TRUE );
                } else {
                    UnicodeAtomName = &NtCurrentTeb()->StaticUnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, FALSE );
                }
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            return( INVALID_ATOM );
        }
    }

    Atom = INVALID_ATOM;
    try {
        if (UseLocalAtomTable) {
            Status = RtlAddAtomToAtomTable( InternalInitAtomTable(),
                                            UnicodeAtomName->Buffer,
                                            &Atom
                                          );
        } else {
            Status = NtAddAtom( UnicodeAtomName->Buffer,
                                UnicodeAtomName->Length,
                                &Atom
                              );
        }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Atom = INVALID_ATOM;
        }
    } finally {
        if (!IsUnicodeAtomName && UnicodeAtomName == &UnicodeString) {
            RtlFreeUnicodeString( UnicodeAtomName );
        }
    }

    return( (ATOM)Atom );
}

ATOM
InternalFindAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING UnicodeAtomName;
    ATOM Atom;

    if ( (ULONG_PTR)AtomName <= 0xFFFF ) {
        Atom = (ATOM)PtrToShort((PVOID)AtomName);
        if (Atom >= MAXINTATOM) {
            BaseSetLastNTError( STATUS_INVALID_PARAMETER );
            return( INVALID_ATOM );
        } else {
            return( (ATOM)Atom );
        }
    } else {
        try {
            if (IsUnicodeAtomName) {
                UnicodeAtomName = &UnicodeString;
                RtlInitUnicodeString( UnicodeAtomName, (PWSTR)AtomName );
                Status = STATUS_SUCCESS;
            } else {
                RtlInitAnsiString( &AnsiString, AtomName );
                if (AnsiString.MaximumLength > STATIC_UNICODE_BUFFER_LENGTH) {
                    UnicodeAtomName = &UnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, TRUE );
                } else {
                    UnicodeAtomName = &NtCurrentTeb()->StaticUnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, FALSE );
                }
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            return( INVALID_ATOM );
        }
    }

    Atom =  INVALID_ATOM;
    try {
        if (UseLocalAtomTable) {
            Status = RtlLookupAtomInAtomTable( InternalInitAtomTable(),
                                               UnicodeAtomName->Buffer,
                                               &Atom
                                             );
        } else {
            if (UnicodeAtomName->Length == 0) {
                SetLastError( ERROR_INVALID_NAME );
                leave;
            }

            Status = NtFindAtom( UnicodeAtomName->Buffer,
                                 UnicodeAtomName->Length,
                                 &Atom
                               );
        }
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Atom =  INVALID_ATOM;
            leave;
        }
    } finally {
        if (!IsUnicodeAtomName && UnicodeAtomName == &UnicodeString) {
            RtlFreeUnicodeString( UnicodeAtomName );
        }
    }


    return( (ATOM)Atom );
}

ATOM
InternalDeleteAtom(
    BOOLEAN UseLocalAtomTable,
    ATOM nAtom
    )
{
    NTSTATUS Status;

    if (nAtom >= MAXINTATOM) {
        if (UseLocalAtomTable) {
            Status = RtlDeleteAtomFromAtomTable( InternalInitAtomTable(), nAtom );
        } else {
            Status = NtDeleteAtom( nAtom );
        }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            return( INVALID_ATOM );
        }
    }

    return( 0 );
}


UINT
InternalGetAtomName(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    ATOM nAtom,
    LPSTR AtomName,
    DWORD nSize
    )
{
    NTSTATUS Status;
    PVOID FreeBuffer = NULL;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PWSTR UnicodeAtomName;
    ULONG AtomInfoLength, AtomNameLength;
    DWORD ReturnValue;
    PATOM_BASIC_INFORMATION AtomInfo;

    //
    // Trim nSize so that it will not overflow the 16-bit unicode string
    // maximum length field. This prevents people that call us with a >=32KB
    // query buffer from stubbing their toes when they call the Ansi version
    // of the GetAtomName API
    //

    if (!IsUnicodeAtomName && nSize > 0x7000) {
        nSize = 0x7000;
    }

    if (nSize == 0) {
        BaseSetLastNTError( STATUS_BUFFER_OVERFLOW );
        return( 0 );
    }

    if (UseLocalAtomTable) {
        if (IsUnicodeAtomName) {
            UnicodeAtomName = (PWSTR)AtomName;
        } else {
            FreeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          nSize * sizeof( WCHAR )
                                        );
            if (FreeBuffer == NULL) {
                BaseSetLastNTError( STATUS_NO_MEMORY );
                return( 0 );
            }

            UnicodeAtomName = (PWSTR)FreeBuffer;
        }

        AtomNameLength = nSize * sizeof( WCHAR );
        Status = RtlQueryAtomInAtomTable( InternalInitAtomTable(),
                                          nAtom,
                                          NULL,
                                          NULL,
                                          UnicodeAtomName,
                                          &AtomNameLength
                                        );
    } else {
        AtomInfoLength = sizeof( *AtomInfo ) + (nSize * sizeof( WCHAR ));
        FreeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                      MAKE_TAG( TMP_TAG ),
                                      AtomInfoLength
                                    );
        if (FreeBuffer == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            return( 0 );
        }
        AtomInfo = (PATOM_BASIC_INFORMATION)FreeBuffer;

        Status = NtQueryInformationAtom( nAtom,
                                         AtomBasicInformation,
                                         AtomInfo,
                                         AtomInfoLength,
                                         &AtomInfoLength
                                       );
        if (NT_SUCCESS( Status )) {
            AtomNameLength = (ULONG)AtomInfo->NameLength;
            UnicodeAtomName = AtomInfo->Name;
        }
    }

    if (NT_SUCCESS( Status )) {
        if (IsUnicodeAtomName) {
            ReturnValue = AtomNameLength / sizeof( WCHAR );
            if (UnicodeAtomName != (PWSTR)AtomName) {
                RtlMoveMemory( AtomName, UnicodeAtomName, AtomNameLength );
            }
            if (ReturnValue < nSize) {
                *((PWSTR)AtomName + ReturnValue) = UNICODE_NULL;
            }
        } else {
            UnicodeString.Buffer = UnicodeAtomName;
            UnicodeString.Length = (USHORT)AtomNameLength;
            UnicodeString.MaximumLength = (USHORT)(UnicodeString.Length + sizeof( UNICODE_NULL ));
            AnsiString.Buffer = AtomName;
            AnsiString.Length = 0;
            AnsiString.MaximumLength = (USHORT)nSize;
            Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
            if (NT_SUCCESS( Status )) {
                ReturnValue = AnsiString.Length;
            }
        }
    }

    if (FreeBuffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
    }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( 0 );
    } else {
        return( ReturnValue );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\dir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements Win32 Directory functions.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"
#include "mountmgr.h"

BOOL
APIENTRY
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    ANSI thunk to CreateDirectoryW

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpPathName );
    if (Unicode == NULL) {
        return FALSE;
    }
        
    return ( CreateDirectoryW((LPCWSTR)Unicode->Buffer,lpSecurityAttributes) );
}

BOOL
APIENTRY
CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A directory can be created using CreateDirectory.

    This API causes a directory with the specified pathname to be
    created.  If the underlying file system supports security on files
    and directories, then the SecurityDescriptor argument is applied to
    the new directory.

    This call is similar to DOS (int 21h, function 39h) and OS/2's
    DosCreateDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be created.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new directory.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpPathName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    //
    // dont create a directory unless there is room in the directory for
    // at least an 8.3 name. This way everyone will be able to delete all
    // files in the directory by using del *.* which expands to path+\*.*
    //

    if ( FileName.Length > ((MAX_PATH-12)<<1) ) {
        DWORD L;
        LPWSTR lp;

        if ( !(lpPathName[0] == '\\' && lpPathName[1] == '\\' &&
               lpPathName[2] == '?' && lpPathName[3] == '\\') ) {
            L = GetFullPathNameW(lpPathName,0,NULL,&lp);
            if ( !L || L+12 > MAX_PATH ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0,FileName.Buffer);
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
                }
            }
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

    Status = NtCreateFile(
                &Handle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_CREATE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                NULL,
                0L
                );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( NT_SUCCESS(Status) ) {
        NtClose(Handle);
        return TRUE;
        }
    else {
        if ( RtlIsDosDeviceName_U((LPWSTR)lpPathName) ) {
            Status = STATUS_NOT_A_DIRECTORY;
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
CreateDirectoryExA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    ANSI thunk to CreateDirectoryFromTemplateW

--*/

{
    PUNICODE_STRING StaticUnicode;
    UNICODE_STRING DynamicUnicode;
    BOOL b;

    StaticUnicode = Basep8BitStringToStaticUnicodeString( lpTemplateDirectory );
    if (StaticUnicode == NULL) {
        return FALSE;
    }
        
    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicode, lpNewDirectory )) {
        return FALSE;
    }
    
    b = CreateDirectoryExW(
            (LPCWSTR)StaticUnicode->Buffer,
            (LPCWSTR)DynamicUnicode.Buffer,
            lpSecurityAttributes
            );
    
    RtlFreeUnicodeString(&DynamicUnicode);
    
    return b;
}

BOOL
APIENTRY
CreateDirectoryExW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A directory can be created using CreateDirectoryEx, retaining the
    attributes of the original directory file.

    This API causes a directory with the specified pathname to be
    created.  If the underlying file system supports security on files
    and directories, then the SecurityDescriptor argument is applied to
    the new directory.  The other attributes of the template directory are
    retained when creating the new directory.

    If the original directory is a volume mount point then the new directory
    is also a volume mount point to the same volume as the original one.

Arguments:

    lpTemplateDirectory - Supplies the pathname of the directory to be used as
        a template when creating the new directory.

    lpPathName - Supplies the pathname of the directory to be created.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new directory.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE SourceFile;
    HANDLE DestFile;
    UNICODE_STRING PathName;
    UNICODE_STRING TargetName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    BOOLEAN IsNameGrafting = FALSE;
    UNICODE_STRING VolumeName;
    UNICODE_STRING MountPoint;
    PWCHAR VolumeMountPoint = NULL;
    RTL_RELATIVE_NAME_U PathRelativeName;
    RTL_RELATIVE_NAME_U TargetRelativeName;
    PVOID FreePathBuffer;
    PVOID FreeTargetBuffer;
    UNICODE_STRING StreamName;
    WCHAR FileName[MAXIMUM_FILENAME_LENGTH+1];
    HANDLE StreamHandle;
    HANDLE OutputStream;
    PFILE_STREAM_INFORMATION StreamInfo;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    PFILE_STREAM_INFORMATION StreamInfoBase;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    FILE_EA_INFORMATION EaInfo;
    FILE_BASIC_INFORMATION BasicInfo;
    ULONG EaSize;
    ULONG StreamInfoSize;
    ULONG CopySize;
    ULONG i;
    ULONG DesiredAccess = 0;
    DWORD Options;
    DWORD b;
    LPCOPYFILE_CONTEXT CopyFileContext = NULL;

    //
    // Process the input template directory name and then open the directory
    // file, ensuring that it really is a directory.
    //

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpTemplateDirectory,
                            &PathName,
                            NULL,
                            &PathRelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreePathBuffer = PathName.Buffer;

    if ( PathRelativeName.RelativeName.Length ) {
        PathName = PathRelativeName.RelativeName;
        }
    else {
        PathRelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        OBJ_CASE_INSENSITIVE,
        PathRelativeName.ContainingDirectory,
        NULL
        );

    //
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //

    Status = NtOpenFile(
                 &SourceFile,
                 FILE_LIST_DIRECTORY | FILE_READ_EA | FILE_READ_ATTRIBUTES,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
           //   
           // Re-open not inhibiting the reparse behavior.
           //

           Status = NtOpenFile(
                        &SourceFile,
                        FILE_LIST_DIRECTORY | FILE_READ_EA | FILE_READ_ATTRIBUTES,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                        );

           if ( !NT_SUCCESS(Status) ) {
               RtlReleaseRelativeName(&PathRelativeName);
               RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
               BaseSetLastNTError(Status);
               return FALSE;
               }
           }
        else {
           RtlReleaseRelativeName(&PathRelativeName);
           RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
           BaseSetLastNTError(Status);
           return FALSE;
           }
        }
    else { 
        //
        // See whether we have a name grafting operation.
        //

        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

        Status = NtQueryInformationFile(
                     SourceFile,
                     &IoStatusBlock,
                     (PVOID)&BasicInfo,
                     sizeof(BasicInfo),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            RtlReleaseRelativeName(&PathRelativeName);
            RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
            CloseHandle(SourceFile);
            BaseSetLastNTError(Status);
            return FALSE;
            }

        if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
            Status = NtQueryInformationFile(
                         SourceFile,
                         &IoStatusBlock,
                         (PVOID)&FileTagInformation,
                         sizeof(FileTagInformation),
                         FileAttributeTagInformation
                         );

            if ( !NT_SUCCESS(Status) ) {
                RtlReleaseRelativeName(&PathRelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
                CloseHandle(SourceFile);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            if ( FileTagInformation.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {
                //   
                // Close and re-open not inhibiting the reparse behavior.
                //

                CloseHandle(SourceFile);

                Status = NtOpenFile(
                             &SourceFile,
                             FILE_LIST_DIRECTORY | FILE_READ_EA | FILE_READ_ATTRIBUTES,
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                             );

                if ( !NT_SUCCESS(Status) ) {
                    RtlReleaseRelativeName(&PathRelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            else {
                IsNameGrafting = TRUE;                
            }
        }
    }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpNewDirectory,
                            &TargetName,
                            NULL,
                            &TargetRelativeName
                            );

    if ( !TranslationStatus ) {
        RtlReleaseRelativeName(&PathRelativeName);
        RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
        NtClose(SourceFile);
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeTargetBuffer = TargetName.Buffer;

    //
    // Verify that the source and target are different.
    //

    if ( RtlEqualUnicodeString(&PathName, &TargetName, TRUE) ) {
        //
        // Do nothing. Source and target are the same.
        //

        RtlReleaseRelativeName(&PathRelativeName);
        RtlReleaseRelativeName(&TargetRelativeName);
        RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
        NtClose(SourceFile);
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RtlReleaseRelativeName(&PathRelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);

    //
    // Do not create a directory unless there is room in the directory for
    // at least an 8.3 name. This way everyone will be able to delete all
    // files in the directory by using del *.* which expands to path+\*.*
    //

    if ( TargetName.Length > ((MAX_PATH-12)<<1) ) {
        DWORD L;
        LPWSTR lp;
        if ( !(lpNewDirectory[0] == '\\' && lpNewDirectory[1] == '\\' &&
               lpNewDirectory[2] == '?' && lpNewDirectory[3] == '\\') ) {
            L = GetFullPathNameW(lpNewDirectory,0,NULL,&lp);
            if ( !L || L+12 > MAX_PATH ) {
                RtlReleaseRelativeName(&TargetRelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
                CloseHandle(SourceFile);
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
                }
            }
        }

    if ( TargetRelativeName.RelativeName.Length ) {
        TargetName = TargetRelativeName.RelativeName;
        }
    else {
        TargetRelativeName.ContainingDirectory = NULL;
        }

    EaBuffer = NULL;
    EaSize = 0;

    Status = NtQueryInformationFile(
                 SourceFile,
                 &IoStatusBlock,
                 &EaInfo,
                 sizeof(EaInfo),
                 FileEaInformation
                 );

    if ( !NT_SUCCESS(Status) ) {
        RtlReleaseRelativeName(&TargetRelativeName);
        RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
        CloseHandle(SourceFile);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {
        EaSize = EaInfo.EaSize;
        do {
            EaSize *= 2;
            EaBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
            if ( !EaBuffer ) {
                RtlReleaseRelativeName(&TargetRelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
                CloseHandle(SourceFile);
                BaseSetLastNTError(STATUS_NO_MEMORY);
                return FALSE;
                }

            Status = NtQueryEaFile(
                         SourceFile,
                         &IoStatusBlock,
                         EaBuffer,
                         EaSize,
                         FALSE,
                         (PVOID)NULL,
                         0,
                         (PULONG)NULL,
                         TRUE
                         );

            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);
                EaBuffer = NULL;
                IoStatusBlock.Information = 0;
                }
            } while ( Status == STATUS_BUFFER_OVERFLOW ||
                      Status == STATUS_BUFFER_TOO_SMALL );
        EaSize = (ULONG)IoStatusBlock.Information;
        }

    //
    // Open/create the destination directory.
    //

    InitializeObjectAttributes(
        &Obja,
        &TargetName,
        OBJ_CASE_INSENSITIVE,
        TargetRelativeName.ContainingDirectory,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

    DesiredAccess = FILE_LIST_DIRECTORY | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE;
    if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
        //
        // To set the reparse point at the target one needs FILE_WRITE_DATA.
        //

        DesiredAccess |= FILE_WRITE_DATA;
    }

    //
    // Clear the reparse attribute before creating the target. Only the
    // name grafting use of reparse points is preserved at this level.
    // Open first inhibiting the reparse behavior.
    //
    
    BasicInfo.FileAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;

    Status = NtCreateFile(
                 &DestFile,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 NULL,
                 BasicInfo.FileAttributes,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT,
                 EaBuffer,
                 EaSize
                 );

    if ( !NT_SUCCESS(Status) ) {    
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( (Status == STATUS_INVALID_PARAMETER) ||
             (Status == STATUS_ACCESS_DENIED) ) {
            //
            // Either the FS does not support reparse points or we do not have enough
            // access to the target.
            //

            if ( IsNameGrafting ) {
                //
                // We need to return error, as the target cannot be opened correctly.
                //

                RtlReleaseRelativeName(&TargetRelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
                if ( EaBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);
                    }
                CloseHandle(SourceFile);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            Status = NtCreateFile(
                         &DestFile,
                         FILE_LIST_DIRECTORY | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         NULL,
                         BasicInfo.FileAttributes,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_CREATE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                         EaBuffer,
                         EaSize
                         );                        
            }
        }

    RtlReleaseRelativeName(&TargetRelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);

    if ( EaBuffer ) {
        RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);
        }

    if ( !NT_SUCCESS(Status) ) {
        NtClose(SourceFile);
        if ( RtlIsDosDeviceName_U((LPWSTR)lpNewDirectory) ) {
            Status = STATUS_NOT_A_DIRECTORY;
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    else {
        if ( IsNameGrafting ) {
           
            PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
            PUCHAR ReparseBuffer = NULL;

            //
            // Allocate the buffer to get/set the reparse point.
            //

            ReparseBuffer = RtlAllocateHeap(
                                RtlProcessHeap(), 
                                MAKE_TAG( TMP_TAG ), 
                                MAXIMUM_REPARSE_DATA_BUFFER_SIZE);

            if ( ReparseBuffer == NULL) {
                NtClose(SourceFile);
                NtClose(DestFile);
                BaseSetLastNTError(STATUS_NO_MEMORY);
                //
                // Notice that we leave behind the target directory.
                //
                return FALSE;
            }

            //
            // Get the data in the reparse point.
            //

            Status = NtFsControlFile(
                         SourceFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_GET_REPARSE_POINT,
                         NULL,                                //  Input buffer
                         0,                                   //  Input buffer length
                         ReparseBuffer,                       //  Output buffer
                         MAXIMUM_REPARSE_DATA_BUFFER_SIZE     //  Output buffer length
                         );

            if ( !NT_SUCCESS( Status ) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
                NtClose(SourceFile);
                NtClose(DestFile);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            //
            // Defensive sanity check. The reparse buffer should be name grafting.
            //

            ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;

            if ( ReparseBufferHeader->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {
                RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
                NtClose(SourceFile);
                NtClose(DestFile);
                BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
                return FALSE;
                }

            //
            // Finish up the creation of the target directory.
            //

            VolumeName.Length = VolumeName.MaximumLength =
                ReparseBufferHeader->MountPointReparseBuffer.SubstituteNameLength;
            VolumeName.Buffer = (PWCHAR)
                ((PCHAR) ReparseBufferHeader->MountPointReparseBuffer.PathBuffer +
                         ReparseBufferHeader->MountPointReparseBuffer.SubstituteNameOffset);

            if (MOUNTMGR_IS_NT_VOLUME_NAME_WB(&VolumeName)) {
                //
                // Set the volume mount point and be done.
                //
                // SetVolumeMountPoint requires the mount point name
                // to have a trailing backslash.
                //                
                
                RtlInitUnicodeString(&MountPoint, lpNewDirectory);
                VolumeMountPoint = RtlAllocateHeap(RtlProcessHeap(),
                                                   MAKE_TAG(TMP_TAG),
                                                   MountPoint.Length +
                                                   2*sizeof(WCHAR));
                if (!VolumeMountPoint) {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        b = FALSE;
                    }
                else {

                    RtlCopyMemory(VolumeMountPoint, MountPoint.Buffer,
                                  MountPoint.Length);
                    VolumeMountPoint[MountPoint.Length/sizeof(WCHAR)] = 0;

                    if (MountPoint.Buffer[MountPoint.Length/sizeof(WCHAR) - 1] != '\\') {
                        VolumeMountPoint[MountPoint.Length/sizeof(WCHAR)] = '\\';
                        VolumeMountPoint[MountPoint.Length/sizeof(WCHAR) + 1] = 0;
                    }
                        
                    //
                    // The volume name should be like "\\?\Volume{guid}\"
                    //

                    VolumeName.Buffer[1] = '\\';
                    
                    b = SetVolumeMountPointW(
                            VolumeMountPoint, 
                            VolumeName.Buffer
                            );

                    RtlFreeHeap(RtlProcessHeap(), 0, VolumeMountPoint);
                    VolumeName.Buffer[1] = '?';
                    }
                }                
            else {
                //
                // Copy the directory junction and be done.
                //

                b = TRUE;
                Status = NtFsControlFile(
                             DestFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FSCTL_SET_REPARSE_POINT,
                             ReparseBuffer,
                             FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                             NULL,                //  Output buffer
                             0                    //  Output buffer length
                             );                  
                }

            // 
            // Free the buffer.
            //

            RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);

            //
            // Close all files and return appropriatelly.
            //

            NtClose(SourceFile);
            NtClose(DestFile);

            if ( !b ) {
                //
                // No need to set the last error as SetVolumeMountPointW has done it. 
                //
                return FALSE;
                }
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            
            return TRUE;

            //
            // The source directory was a name grafting directory.
            // No data streams are copied.
            //
            }

        //
        // Attempt to determine whether or not this file has any alternate
        // data streams associated with it.  If it does, attempt to copy each
        // to the output file.  If any copy fails, simply drop the error on
        // the floor, and continue.
        //

        StreamInfoSize = 4096;
        CopySize = 4096;
        do {
            StreamInfoBase = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), StreamInfoSize);
            if ( !StreamInfoBase ) {
                BaseMarkFileForDelete(DestFile, BasicInfo.FileAttributes);
                BaseSetLastNTError(STATUS_NO_MEMORY);
                b = FALSE;
                break;
                }
            Status = NtQueryInformationFile(
                         SourceFile,
                         &IoStatusBlock,
                         (PVOID) StreamInfoBase,
                         StreamInfoSize,
                         FileStreamInformation
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                StreamInfoBase = NULL;
                StreamInfoSize *= 2;
                }
            } while ( Status == STATUS_BUFFER_OVERFLOW ||
                      Status == STATUS_BUFFER_TOO_SMALL );

        //
        // Directories do not always have a stream
        //

        if ( NT_SUCCESS(Status) && IoStatusBlock.Information ) {
            StreamInfo = StreamInfoBase;

            for (;;) {

                DWORD DestFileFsAttributes = 0;

                //
                // Build a string descriptor for the name of the stream.
                //

                StreamName.Buffer = &StreamInfo->StreamName[0];
                StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
                StreamName.MaximumLength = StreamName.Length;

                //
                // Open the source stream.
                //

                InitializeObjectAttributes(
                    &Obja,
                    &StreamName,
                    0,
                    SourceFile,
                    NULL
                    );
                Status = NtCreateFile(
                             &StreamHandle,
                             GENERIC_READ | SYNCHRONIZE,
                             &Obja,
                             &IoStatusBlock,
                             NULL,
                             0,
                             FILE_SHARE_READ,
                             FILE_OPEN,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             NULL,
                             0
                             );
                if ( NT_SUCCESS(Status) ) {
                    for ( i = 0; i < (ULONG) StreamName.Length >> 1; i++ ) {
                        FileName[i] = StreamName.Buffer[i];
                        }
                    FileName[i] = L'\0';
                    OutputStream = (HANDLE)NULL;
                    Options = 0;
                    b = BaseCopyStream(
                            NULL,
                            StreamHandle,
                            GENERIC_READ | SYNCHRONIZE,
                            FileName,
                            DestFile,
                            &StreamInfo->StreamSize,
                            &Options,
                            &OutputStream,
                            &CopySize,
                            &CopyFileContext,
                            (LPRESTART_STATE)NULL,
                            (BOOL)FALSE,
                            (DWORD)0,
                            &DestFileFsAttributes
                            );
                    NtClose(StreamHandle);
                    if ( OutputStream ) {
                        NtClose(OutputStream);
                        }
                    }

                if ( StreamInfo->NextEntryOffset ) {
                    StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
                    }
                else {
                    break;
                    }

                }
            }
        if ( StreamInfoBase ) {
            RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
            }
        b = TRUE;
        }
    NtClose(SourceFile);
    if ( DestFile ) {
        NtClose(DestFile);
        }
    return b;
}

BOOL
APIENTRY
RemoveDirectoryA(
    LPCSTR lpPathName
    )

/*++

Routine Description:

    ANSI thunk to RemoveDirectoryW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpPathName );
    if (Unicode == NULL) {
        return FALSE;
    }
        
    return ( RemoveDirectoryW((LPCWSTR)Unicode->Buffer) );
}

BOOL
APIENTRY
RemoveDirectoryW(
    LPCWSTR lpPathName
    )

/*++

Routine Description:

    An existing directory can be removed using RemoveDirectory.

    This API causes a directory with the specified pathname to be
    deleted.  The directory must be empty before this call can succeed.

    This call is similar to DOS (int 21h, function 3Ah) and OS/2's
    DosDeleteDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be removed.
        The path must specify an empty directory to which the caller has
        delete access.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    BOOLEAN IsNameGrafting = FALSE;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    PREPARSE_DATA_BUFFER reparse;
    BOOL b;
    DWORD bytes;
    UNICODE_STRING mountName;
    PWCHAR volumeMountPoint;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpPathName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );
                      
    //
    // Open the directory for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //

    Status = NtOpenFile(
                 &Handle,
                 DELETE | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //   
            // Re-open not inhibiting the reparse behavior and not needing to read the attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

            if ( !NT_SUCCESS(Status) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            RtlReleaseRelativeName(&RelativeName);
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        //
        // If we found a reparse point that is not a name grafting operation,
        // either a symbolic link or a mount point, we re-open without 
        // inhibiting the reparse behavior.
        //

        Status = NtQueryInformationFile(
                     Handle,
                     &IoStatusBlock,
                     (PVOID) &FileTagInformation,
                     sizeof(FileTagInformation),
                     FileAttributeTagInformation
                     );
        
        if ( !NT_SUCCESS(Status) ) {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                 (Status != STATUS_INVALID_PARAMETER) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }

        if ( NT_SUCCESS(Status) &&
            (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ) {
            if ( FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT ) {

                //
                // If this is a volume mount point then fail with
                // "directory not empty".
                //

                reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                          MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
                if (!reparse) {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    NtClose(Handle);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                    }

                b = DeviceIoControl(Handle, FSCTL_GET_REPARSE_POINT, NULL, 0,
                                    reparse, MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
                                    &bytes, NULL);

                if (b) {

                    mountName.Length = mountName.MaximumLength =
                        reparse->MountPointReparseBuffer.SubstituteNameLength;
                    mountName.Buffer = (PWCHAR)
                        ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                         reparse->MountPointReparseBuffer.SubstituteNameOffset);

                    if (MOUNTMGR_IS_VOLUME_NAME(&mountName)) {

                        RtlInitUnicodeString(&mountName, lpPathName);
                        volumeMountPoint = RtlAllocateHeap(RtlProcessHeap(),
                                                           MAKE_TAG(TMP_TAG),
                                                           mountName.Length +
                                                           2*sizeof(WCHAR));
                        if (!volumeMountPoint) {
                            RtlReleaseRelativeName(&RelativeName);
                            RtlFreeHeap(RtlProcessHeap(), 0, reparse);
                            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                            NtClose(Handle);
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            return FALSE;
                            }

                        RtlCopyMemory(volumeMountPoint, mountName.Buffer,
                                      mountName.Length);
                        volumeMountPoint[mountName.Length/sizeof(WCHAR)] = 0;

                        if (mountName.Buffer[mountName.Length/sizeof(WCHAR) - 1] != '\\') {
                            volumeMountPoint[mountName.Length/sizeof(WCHAR)] = '\\';
                            volumeMountPoint[mountName.Length/sizeof(WCHAR) + 1] = 0;
                        }

                        DeleteVolumeMountPointW(volumeMountPoint);

                        RtlFreeHeap(RtlProcessHeap(), 0, volumeMountPoint);
                        }
                    }

                RtlFreeHeap(RtlProcessHeap(), 0, reparse);
                IsNameGrafting = TRUE;
                }
            }
        
        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
             !IsNameGrafting) {
            //
            // Re-open without inhibiting the reparse behavior and not needing to 
            // read the attributes.
            //
  
            NtClose(Handle);
            Status = NtOpenFile(
                         &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

            if ( !NT_SUCCESS(Status) ) {
                //
                // When the FS Filter is absent, delete it any way.
                //

                if ( Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED ) {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //

                    Status = NtOpenFile(
                                 &Handle,
                                 DELETE | SYNCHRONIZE,
                                 &Obja,
                                 &IoStatusBlock,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                                 );
                    }

                if ( !NT_SUCCESS(Status) ) {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            }
        }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &Disposition,
                sizeof(Disposition),
                FileDispositionInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\error.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the Win32 error APIs.

Author:

    Mark Lucovsky (markl) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

DWORD g_dwLastErrorToBreakOn = ERROR_SUCCESS;

UINT
GetErrorMode()
{

    UINT PreviousMode;
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDefaultHardErrorMode,
                (PVOID) &PreviousMode,
                sizeof(PreviousMode),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }

    if (PreviousMode & 1) {
        PreviousMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        PreviousMode |= SEM_FAILCRITICALERRORS;
        }
    return PreviousMode;
}


UINT
SetErrorMode(
    UINT uMode
    )
{

    UINT PreviousMode;
    UINT NewMode;

    PreviousMode = GetErrorMode();

    NewMode = uMode;
    if (NewMode & SEM_FAILCRITICALERRORS ) {
        NewMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        NewMode |= SEM_FAILCRITICALERRORS;
        }

    //
    // Once SEM_NOALIGNMENTFAULTEXCEPT has been enabled for a given
    // process, it cannot be disabled via this API.
    //

    NewMode |= (PreviousMode & SEM_NOALIGNMENTFAULTEXCEPT);

    if ( NT_SUCCESS(NtSetInformationProcess(
                        NtCurrentProcess(),
                        ProcessDefaultHardErrorMode,
                        (PVOID) &NewMode,
                        sizeof(NewMode)
                        ) ) ){
        }

    return( PreviousMode );
}

DWORD
GetLastError(
    VOID
    )

/*++

Routine Description:

    This function returns the most recent error code set by a Win32 API
    call.  Applications should call this function immediately after a
    Win32 API call returns a failure indications (e.g.  FALSE, NULL or
    -1) to determine the cause of the failure.

    The last error code value is a per thread field, so that multiple
    threads do not overwrite each other's last error code value.

Arguments:

    None.

Return Value:

    The return value is the most recent error code as set by a Win32 API
    call.

--*/

{
    return (DWORD)NtCurrentTeb()->LastErrorValue;
}

VOID
SetLastError(
    DWORD dwErrCode
    )

/*++

Routine Description:

    This function set the most recent error code and error string in per
    thread storage.  Win32 API functions call this function whenever
    they return a failure indication (e.g.  FALSE, NULL or -1).
    This function
    is not called by Win32 API function calls that are successful, so
    that if three Win32 API function calls are made, and the first one
    fails and the second two succeed, the error code and string stored
    by the first one are still available after the second two succeed.

    Applications can retrieve the values saved by this function using
    GetLastError.  The use of this function is optional, as an
    application need only call if it is interested in knowing the
    specific reason for an API function failure.

    The last error code value is kept in thread local storage so that
    multiple threads do not overwrite each other's values.

Arguments:

    dwErrCode - Specifies the error code to store in per thread storage
        for the current thread.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    PTEB Teb = NtCurrentTeb();

    if ((g_dwLastErrorToBreakOn != ERROR_SUCCESS) &&
        (dwErrCode == g_dwLastErrorToBreakOn)) {
        DbgBreakPoint();
    }

    // make write breakpoints to this field more meaningful by only writing to it when
    // the value changes.
    if (Teb->LastErrorValue != dwErrCode) {
        Teb->LastErrorValue = dwErrCode;
    }
}

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

HANDLE
WINAPI
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    ULONG_PTR CompletionKey,
    DWORD NumberOfConcurrentThreads
    )

/*++

Routine Description:

    This function creates an I/O completion port.  Completion ports
    provide another mechanism that can be used to to recive I/O
    completion notification.

    Completion ports act as a queue.  The Win32 I/O system can be
    instructed to queue I/O completion notification packets to
    completion ports.  This API provides this mechanism.  If a file
    handle is created for overlapped I/O completion
    (FILE_FLAG_OVERLAPPED) , a completion port can be associated with
    the file handle.  When I/O operations are done on a file handle that
    has an associated completion port, the I/O system will queue a
    completion packet when the I/O operation completes.  The
    GetQueuedCompletionStatus is used to pick up these queued I/O
    completion packets.

    This API can be used to create a completion port and associate it
    with a file.  If you supply a completion port, it can be used to
    associate the specified file with the specified completion port.

Arguments:

    FileHandle - Supplies a handle to a file opened for overlapped I/O
        completion.  This file is associated with either the specified
        completion port, or a new completion port is created, and the
        file is associated with that port.  Once associated with a
        completion port, the file handle may not be used in ReadFileEx
        or WriteFileEx operations.  It is not advisable to share an
        associated file handle through either handle inheritence or
        through DuplicateHandle.  I/O operations done on these
        duplicates will also generate a completion notification.

    ExistingCompletionPort - If this parameter is specified, it supplies
        an existing completion port that is to be associated with the
        specified file handle.  Otherwise, a new completion port is
        created and associated with the specified file handle.

    CompletionKey - Supplies a per-file completion key that is part of
        every I/O completion packet for this file.

    NumberOfConcurrentThreads - This is the number of threads that are
        alowed to be concurrently active and can be used to avoid
        spurious context switches, e.g., context switches that would
        occur simply because of quantum end.  Up to the number of
        threads specified are allowed to execute concurrently.  If one
        of the threads enters a wait state, then another thread is
        allowed to procede.  There may be times when more then the
        specified number of threads are active, but this will be quickly
        throttled.  A value of 0 tells the system to allow the same
        number of threads as there are processors to run.

Return Value:

    Not NULL - Returns the completion port handle associated with the file.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    HANDLE Port;
    IO_STATUS_BLOCK IoSb;
    FILE_COMPLETION_INFORMATION CompletionInfo;

    Port = ExistingCompletionPort;
    if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
        Status = NtCreateIoCompletion (
                    &Port,
                    IO_COMPLETION_ALL_ACCESS,
                    NULL,
                    NumberOfConcurrentThreads
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return NULL;
            }
        }

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CompletionInfo.Port = Port;
        CompletionInfo.Key = (PVOID)CompletionKey;

        Status = NtSetInformationFile(
                    FileHandle,
                    &IoSb,
                    &CompletionInfo,
                    sizeof(CompletionInfo),
                    FileCompletionInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
                NtClose(Port);
                }
            return NULL;
            }
        }
    else {

        //
        // file handle is INVALID_HANDLE_VALUE. Usually this is
        // used to create a new unassociated completion port.
        //
        // Special case here to see if existing completion port was
        // specified and fail if it is
        //

        if ( ARGUMENT_PRESENT(ExistingCompletionPort) ) {
            Port = NULL;
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }

    return Port;
}

BOOL
WINAPI
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    ULONG_PTR dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    This function allows the caller to post an I/O completion packet to
    a completion port. This packet will satisfy an outstanding call to
    GetQueuedCompletionStatus and will provide that caller with the three values
    normally returned from that call.

Arguments:

    CompletionPort - Supplies a handle to a completion port that the caller wants to
        post a completion packet to.

    dwNumberOfBytesTransferred - Supplies the value that is to be
        returned through the lpNumberOfBytesTransfered parameter of the
        GetQueuedCompletionStatus API.

    dwCompletionKey - Supplies the value that is to be returned through
        the lpCompletionKey parameter of the GetQueuedCompletionStatus
        API.

    lpOverlapped - Supplies the value that is to be returned through the
        lpOverlapped parameter of the GetQueuedCompletionStatus API.

Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed, use GetLastError to get detailed error information

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtSetIoCompletion(
                CompletionPort,
                (PVOID)dwCompletionKey,
                (PVOID)lpOverlapped,
                STATUS_SUCCESS,
                dwNumberOfBytesTransferred
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}



BOOL
WINAPI
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    This function waits for pending I/O operations associated with the
    specified completion port to complete.  Server applications may have
    several threads issuing this call on the same completion port.  As
    I/O operations complete, they are queued to this port.  If threads
    are actively waiting in this call, queued requests complete their
    call.

    This API returns a boolean value.

    A value of TRUE means that a pending I/O completed successfully.
    The the number of bytes transfered during the I/O, the completion
    key that indicates which file the I/O occured on, and the overlapped
    structure address used in the original I/O are all returned.

    A value of FALSE indicates one ow two things:

    If *lpOverlapped is NULL, no I/O operation was dequeued.  This
    typically means that an error occured while processing the
    parameters to this call, or that the CompletionPort handle has been
    closed or is otherwise invalid.  GetLastError() may be used to
    further isolate this.

    If *lpOverlapped is non-NULL, an I/O completion packet was dequeud,
    but the I/O operation resulted in an error.  GetLastError() can be
    used to further isolate the I/O error.  The the number of bytes
    transfered during the I/O, the completion key that indicates which
    file the I/O occured on, and the overlapped structure address used
    in the original I/O are all returned.

Arguments:

    CompletionPort - Supplies a handle to a completion port to wait on.

    lpNumberOfBytesTransferred - Returns the number of bytes transfered during the
        I/O operation whose completion is being reported.

    lpCompletionKey - Returns a completion key value specified during
        CreateIoCompletionPort.  This is a per-file key that can be used
        to tall the caller the file that an I/O operation completed on.

    lpOverlapped - Returns the address of the overlapped structure that
        was specified when the I/O was issued.  The following APIs may
        complete using completion ports.  This ONLY occurs if the file
        handle is associated with with a completion port AND an
        overlapped structure was passed to the API.

        LockFileEx
        WriteFile
        ReadFile
        DeviceIoControl
        WaitCommEvent
        ConnectNamedPipe
        TransactNamedPipe

    dwMilliseconds - Supplies an optional timeout value that specifies
        how long the caller is willing to wait for an I/O completion
        packet.

Return Value:

    TRUE - An I/O operation completed successfully.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

    FALSE - If lpOverlapped is NULL, the operation failed and no I/O
        completion data is retured.  GetLastError() can be used to
        further isolate the cause of the error (bad parameters, invalid
        completion port handle).  Otherwise, a pending I/O operation
        completed, but it completed with an error.  GetLastError() can
        be used to further isolate the I/O error.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

--*/

{

    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    IO_STATUS_BLOCK IoSb;
    NTSTATUS Status;
    LPOVERLAPPED LocalOverlapped;
    BOOL rv;


    pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    Status = NtRemoveIoCompletion(
                CompletionPort,
                (PVOID *)lpCompletionKey,
                (PVOID *)&LocalOverlapped,
                &IoSb,
                pTimeOut
                );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        *lpOverlapped = NULL;
        if ( Status == STATUS_TIMEOUT ) {
            SetLastError(WAIT_TIMEOUT);
            }
        else {
            BaseSetLastNTError(Status);
            }
        rv = FALSE;
        }
    else {
        *lpOverlapped = LocalOverlapped;

        *lpNumberOfBytesTransferred = (DWORD)IoSb.Information;

        if ( !NT_SUCCESS(IoSb.Status) ){
            BaseSetLastNTError( IoSb.Status );
            rv = FALSE;
            }
        else {
            rv = TRUE;
            }
        }
    return rv;
}

BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the GetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (((DWORD)lpOverlapped->Internal) == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
        } else {
            WaitReturn = WAIT_TIMEOUT;
        }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            SetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
        }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls BaseSetLastError
        }
    } else {
        //
        // We have seen the status in the overlapped structure has changed
        // but we need to make sure that our read of other fields occur
        // after this point.
        //

#if defined(_IA64_)
        __mf ();
#else
        _ReadWriteBarrier();
#endif
    }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
    } else {
        BaseSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\dload.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    dload.c

Abstract:

    A tiny bit of delayload failure support.

Author:

    Jay Krell (JayKrell) March 2002

Revision History:

--*/

#include "basedll.h"

//
// compare with \nt\mergedcomponents\dload\downlevel_dload.c
//
// These error codes cannot be used downlevel, where FormatMessage
// does not know about them.
//
extern const ULONG g_ulDelayLoad_Win32Error = ERROR_DELAY_LOAD_FAILED;
extern const LONG  g_lDelayLoad_NtStatus = STATUS_DELAY_LOAD_FAILED;

VOID
WINAPI
DelayLoad_SetLastNtStatusAndWin32Error(
    )
{
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(g_lDelayLoad_NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\dllini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllprof.c

Abstract:

    This module contains the client side of the Win32 Initialization
    File APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"
#include <limits.h>

#if DBG
BOOLEAN BaseDllDumpIniCalls;
#endif

PINIFILE_MAPPING BaseDllIniFileMapping;
PINIFILE_CACHE BaseDllIniFileCache;
UNICODE_STRING BaseDllIniUserKeyPath;
UNICODE_STRING BaseDllIniSoftwareKeyPath;
ULONG LockFileKey = 1;

struct {
    PINIFILE_MAPPING_TARGET MappingTarget;
    ULONG MappingFlags;
    BOOLEAN WriteAccess;
    UNICODE_STRING RegistryPath;
    HANDLE RegistryKey;
    CRITICAL_SECTION Lock;
} BaseDllRegistryCache;

NTSTATUS
BaseDllInitializeIniFileMappings(
                                PBASE_STATIC_SERVER_DATA StaticServerData
                                )
{

    BaseDllIniFileMapping = (PINIFILE_MAPPING)StaticServerData->IniFileMapping;
    BaseDllIniFileCache = NULL;

#if DBG

    BaseDllDumpIniCalls = FALSE;

#endif

    // BaseDllDumpIniCalls = TRUE;

    BaseDllIniUserKeyPath.Length = 0;
    BaseDllIniUserKeyPath.MaximumLength = 0;
    BaseDllIniUserKeyPath.Buffer = NULL;
    

    BaseDllIniSoftwareKeyPath.Length = sizeof (L"\\Registry\\Machine\\Software") - sizeof (WCHAR);
    BaseDllIniSoftwareKeyPath.MaximumLength = BaseDllIniSoftwareKeyPath.Length;
    BaseDllIniSoftwareKeyPath.Buffer = L"\\Registry\\Machine\\Software";

    RtlZeroMemory( &BaseDllRegistryCache, sizeof( BaseDllRegistryCache ) );
    BaseDllRegistryCache.RegistryKey = INVALID_HANDLE_VALUE;
    InitializeCriticalSection(&BaseDllRegistryCache.Lock);
    return STATUS_SUCCESS;
}

NTSTATUS
BaseDllReadWriteIniFile(
                       IN BOOLEAN Unicode,
                       IN BOOLEAN WriteOperation,
                       IN BOOLEAN SectionOperation,
                       IN PVOID FileName OPTIONAL,
                       IN PVOID ApplicationName OPTIONAL,
                       IN PVOID VariableName OPTIONAL,
                       IN OUT PVOID VariableValue OPTIONAL,
                       IN OUT PULONG VariableValueLength OPTIONAL
                       );

DWORD
WINAPI
GetPrivateProfileSectionNamesA(
                              LPSTR lpszReturnBuffer,
                              DWORD nSize,
                              LPCSTR lpFileName
                              )
{
    return GetPrivateProfileStringA( NULL,
                                     NULL,
                                     NULL,
                                     lpszReturnBuffer,
                                     nSize,
                                     lpFileName
                                   );
}

DWORD
WINAPI
GetPrivateProfileSectionNamesW(
                              LPWSTR lpszReturnBuffer,
                              DWORD nSize,
                              LPCWSTR lpFileName
                              )
{
    return GetPrivateProfileStringW( NULL,
                                     NULL,
                                     NULL,
                                     lpszReturnBuffer,
                                     nSize,
                                     lpFileName
                                   );
}

#define NibbleToChar(x) (N2C[x])
#define CharToNibble(x) ((x)>='0'&&(x)<='9' ? (x)-'0' : ((10+(x)-'A')&0x000f))
char N2C[] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
};

BOOL
WINAPI
GetPrivateProfileStructA(
                        LPCSTR lpszSection,
                        LPCSTR lpszKey,
                        LPVOID lpStruct,
                        UINT uSizeStruct,
                        LPCSTR szFile
                        )
{
    UCHAR szBuf[256];
    LPSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BYTE checksum;
    BOOL Result;

    if ((INT_MAX - 5) < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    nLen = uSizeStruct*2 + 10;

    if (nLen > sizeof( szBuf )) {
        lpFreeBuffer = (LPSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (LPSTR)szBuf;
    }

    Result = FALSE;
    nLen = GetPrivateProfileStringA( lpszSection,
                                     lpszKey,
                                     NULL,
                                     lpBuf,
                                     nLen,
                                     szFile
                                   );

    if (nLen == uSizeStruct*2+2) {
        /* Room for the one byte check sum */
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            BYTE cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                } else {
                    SetLastError( ERROR_INVALID_DATA );
                }

                break;
            }

            checksum += bStruct;
            *((LPBYTE)lpStruct)++ = bStruct;
        }
    } else {
        SetLastError( ERROR_BAD_LENGTH );
    }

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

BOOL
WINAPI
GetPrivateProfileStructW(
                        LPCWSTR lpszSection,
                        LPCWSTR lpszKey,
                        LPVOID   lpStruct,
                        UINT     uSizeStruct,
                        LPCWSTR szFile
                        )
{
    WCHAR szBuf[256];
    PWSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BYTE checksum;
    BOOL Result;

    nLen = uSizeStruct*2 + 10;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ((nLen > sizeof( szBuf ))
        || ((nLen * sizeof( WCHAR )) > sizeof( szBuf ))) {
        lpFreeBuffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen * sizeof( WCHAR )
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (PWSTR)szBuf;
    }

    Result = FALSE;
    nLen = GetPrivateProfileStringW( lpszSection,
                                     lpszKey,
                                     NULL,
                                     lpBuf,
                                     nLen,
                                     szFile
                                   );

    if (nLen == uSizeStruct*2+2) {
        /* Room for the one byte check sum */
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            WCHAR cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                } else {
                    SetLastError( ERROR_INVALID_DATA );
                }

                break;
            }

            checksum += bStruct;
            *((LPBYTE)lpStruct)++ = bStruct;
        }
    } else {
        SetLastError( ERROR_BAD_LENGTH );
    }

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

BOOL
WINAPI
WritePrivateProfileStructA(
                          LPCSTR lpszSection,
                          LPCSTR lpszKey,
                          LPVOID   lpStruct,
                          UINT     uSizeStruct,
                          LPCSTR szFile
                          )
{
    UCHAR szBuf[256];
    LPSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BOOL Result;
    BYTE checksum;

    if (lpStruct == NULL) {
        return WritePrivateProfileStringA( lpszSection,
                                           lpszKey,
                                           NULL,
                                           szFile
                                         );
    }


    nLen = uSizeStruct*2 + 3;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (nLen > sizeof( szBuf )) {
        lpFreeBuffer = (LPSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (LPSTR)szBuf;
    }

    checksum = 0;
    for (lpBufTemp=lpBuf; uSizeStruct != 0; --uSizeStruct) {
        BYTE bStruct;

        bStruct = *((LPBYTE)lpStruct)++;
        checksum = checksum + bStruct;

        *lpBufTemp++ = NibbleToChar((bStruct>>4)&0x000f);
        *lpBufTemp++ = NibbleToChar(bStruct&0x000f);
    }
    *lpBufTemp++ = NibbleToChar((checksum>>4)&0x000f);
    *lpBufTemp++ = NibbleToChar(checksum&0x000f);
    *lpBufTemp = '\0';

    Result = WritePrivateProfileStringA( lpszSection,
                                         lpszKey,
                                         lpBuf,
                                         szFile
                                       );

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

BOOL
WINAPI
WritePrivateProfileStructW(
                          LPCWSTR lpszSection,
                          LPCWSTR lpszKey,
                          LPVOID   lpStruct,
                          UINT     uSizeStruct,
                          LPCWSTR szFile
                          )
{
    WCHAR szBuf[256];
    PWSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BOOL Result;
    BYTE checksum;

    if (lpStruct == NULL) {
        return WritePrivateProfileStringW( lpszSection,
                                           lpszKey,
                                           NULL,
                                           szFile
                                         );
    }


    nLen = uSizeStruct*2 + 3;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ((nLen * sizeof( WCHAR )) > sizeof( szBuf )) {
        lpFreeBuffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen * sizeof( WCHAR )
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (PWSTR)szBuf;
    }

    checksum = 0;
    for (lpBufTemp=lpBuf; uSizeStruct != 0; --uSizeStruct) {
        BYTE bStruct;

        bStruct = *((LPBYTE)lpStruct)++;
        checksum = checksum + bStruct;

        *lpBufTemp++ = (WCHAR)NibbleToChar((bStruct>>4)&0x000f);
        *lpBufTemp++ = (WCHAR)NibbleToChar(bStruct&0x000f);
    }
    *lpBufTemp++ = (WCHAR)NibbleToChar((checksum>>4)&0x000f);
    *lpBufTemp++ = (WCHAR)NibbleToChar(checksum&0x000f);
    *lpBufTemp = L'\0';

    Result = WritePrivateProfileStringW( lpszSection,
                                         lpszKey,
                                         lpBuf,
                                         szFile
                                       );

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

UINT
GetProfileIntA(
              LPCSTR lpAppName,
              LPCSTR lpKeyName,
              INT nDefault
              )
{
    return( GetPrivateProfileIntA( lpAppName,
                                   lpKeyName,
                                   nDefault,
                                   NULL
                                 )
          );
}

DWORD
GetProfileStringA(
                 LPCSTR lpAppName,
                 LPCSTR lpKeyName,
                 LPCSTR lpDefault,
                 LPSTR lpReturnedString,
                 DWORD nSize
                 )
{
    return( GetPrivateProfileStringA( lpAppName,
                                      lpKeyName,
                                      lpDefault,
                                      lpReturnedString,
                                      nSize,
                                      NULL
                                    )
          );
}

BOOL
WriteProfileStringA(
                   LPCSTR lpAppName,
                   LPCSTR lpKeyName,
                   LPCSTR lpString
                   )
{
    return( WritePrivateProfileStringA( lpAppName,
                                        lpKeyName,
                                        lpString,
                                        NULL
                                      )
          );
}

DWORD
GetProfileSectionA(
                  LPCSTR lpAppName,
                  LPSTR lpReturnedString,
                  DWORD nSize
                  )
{
    return( GetPrivateProfileSectionA( lpAppName,
                                       lpReturnedString,
                                       nSize,
                                       NULL
                                     )
          );
}

BOOL
WriteProfileSectionA(
                    LPCSTR lpAppName,
                    LPCSTR lpString
                    )
{
    return( WritePrivateProfileSectionA( lpAppName,
                                         lpString,
                                         NULL
                                       )
          );
}

UINT
APIENTRY
GetProfileIntW(
              LPCWSTR lpAppName,
              LPCWSTR lpKeyName,
              INT nDefault
              )
{
    return( GetPrivateProfileIntW( lpAppName,
                                   lpKeyName,
                                   nDefault,
                                   NULL
                                 )
          );
}

DWORD
APIENTRY
GetProfileStringW(
                 LPCWSTR lpAppName,
                 LPCWSTR lpKeyName,
                 LPCWSTR lpDefault,
                 LPWSTR lpReturnedString,
                 DWORD nSize
                 )
{
    return( GetPrivateProfileStringW( lpAppName,
                                      lpKeyName,
                                      lpDefault,
                                      lpReturnedString,
                                      nSize,
                                      NULL
                                    )
          );
}

BOOL
APIENTRY
WriteProfileStringW(
                   LPCWSTR lpAppName,
                   LPCWSTR lpKeyName,
                   LPCWSTR lpString
                   )
{
    return( WritePrivateProfileStringW( lpAppName,
                                        lpKeyName,
                                        lpString,
                                        NULL
                                      )
          );
}

DWORD
APIENTRY
GetProfileSectionW(
                  LPCWSTR lpAppName,
                  LPWSTR lpReturnedString,
                  DWORD nSize
                  )
{
    return( GetPrivateProfileSectionW( lpAppName,
                                       lpReturnedString,
                                       nSize,
                                       NULL
                                     )
          );
}

BOOL
APIENTRY
WriteProfileSectionW(
                    LPCWSTR lpAppName,
                    LPCWSTR lpString
                    )
{
    return( WritePrivateProfileSectionW( lpAppName,
                                         lpString,
                                         NULL
                                       )
          );
}


UINT
GetPrivateProfileIntA(
                     LPCSTR lpAppName,
                     LPCSTR lpKeyName,
                     INT nDefault,
                     LPCSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    UCHAR ValueBuffer[ 256 ];
    ULONG cb;

    ReturnValue = 0;
    cb = GetPrivateProfileStringA( lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ),
                                   lpFileName
                                 );
    if (cb == 0) {
        ReturnValue = nDefault;
    } else {
        Status = RtlCharToInteger( ValueBuffer, 0, &ReturnValue );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
        } else {
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}

DWORD
GetPrivateProfileStringA(
                        LPCSTR lpAppName,
                        LPCSTR lpKeyName,
                        LPCSTR lpDefault,
                        LPSTR lpReturnedString,
                        DWORD nSize,
                        LPCSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = "";
    }

    n = nSize;
    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = '\0';
                //
                // GetPrivateProfileString(): don't leave 1st byte of double byte char alone
                //
                lpReturnedString[ n ] = '\0';
                if ( n > 0 ) {
                    LPSTR pc = lpReturnedString;
                    LPSTR pcEnd = lpReturnedString + n - 1;
                    //
                    // if the last character is the 1st byte of
                    // double byte character, erase it.
                    //
                    while ( pc <= pcEnd ) {
                        pc += IsDBCSLeadByte( *pc ) ? 2 : 1;
                    }
                    if ( (pc - pcEnd ) == 2 ) {
                        *pcEnd = '\0';
                    }
                }

                return ( n );
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = strlen( lpDefault );
        while (n > 0 && lpDefault[n-1] == ' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        strncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = '\0';
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = '\0';
    }

    return( n );
}


BOOL
WritePrivateProfileStringA(
                          LPCSTR lpAppName,
                          LPCSTR lpKeyName,
                          LPCSTR lpString,
                          LPCSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}

DWORD
GetPrivateProfileSectionA(
                         LPCSTR lpAppName,
                         LPSTR lpReturnedString,
                         DWORD nSize,
                         LPCSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = '\0';
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = '\0';
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = '\0';
    }

    return( n );
}

BOOL
WritePrivateProfileSectionA(
                           LPCSTR lpAppName,
                           LPCSTR lpString,
                           LPCSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      RTL_CONST_CAST(PVOID)(lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}


UINT
APIENTRY
GetPrivateProfileIntW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     INT nDefault,
                     LPCWSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    WCHAR ValueBuffer[ 256 ];
    UNICODE_STRING Value;
    ANSI_STRING AnsiString;
    ULONG cb;

    ReturnValue = 0;
    cb = GetPrivateProfileStringW( lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ) / sizeof( WCHAR ),
                                   lpFileName
                                 );
    if (cb == 0) {
        ReturnValue = nDefault;
    } else {
        Value.Buffer = ValueBuffer;
        Value.Length = (USHORT)(cb * sizeof( WCHAR ));
        Value.MaximumLength = (USHORT)((cb + 1) * sizeof( WCHAR ));
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &Value,
                                               TRUE
                                             );
        if (NT_SUCCESS( Status )) {
            Status = RtlCharToInteger( AnsiString.Buffer, 0, &ReturnValue );
            RtlFreeAnsiString( &AnsiString );
        }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
        } else {
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}

DWORD
APIENTRY
GetPrivateProfileStringW(
                        LPCWSTR lpAppName,
                        LPCWSTR lpKeyName,
                        LPCWSTR lpDefault,
                        LPWSTR lpReturnedString,
                        DWORD nSize,
                        LPCWSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = L"";
    }

    n = nSize;
    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = UNICODE_NULL;
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = wcslen( lpDefault );
        while (n > 0 && lpDefault[n-1] == L' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        wcsncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}

BOOL
APIENTRY
WritePrivateProfileStringW(
                          LPCWSTR lpAppName,
                          LPCWSTR lpKeyName,
                          LPCWSTR lpString,
                          LPCWSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}

DWORD
APIENTRY
GetPrivateProfileSectionW(
                         LPCWSTR lpAppName,
                         LPWSTR lpReturnedString,
                         DWORD nSize,
                         LPCWSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = UNICODE_NULL;
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


BOOL
APIENTRY
WritePrivateProfileSectionW(
                           LPCWSTR lpAppName,
                           LPCWSTR lpString,
                           LPCWSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      RTL_CONST_CAST(PVOID)(lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}


VOID
BaseDllFlushRegistryCache( VOID );

BOOL
CloseProfileUserMapping( VOID )
{
    BaseDllFlushRegistryCache();
    RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);
    
    if (BaseDllIniUserKeyPath.Buffer != NULL) {
        RtlFreeUnicodeString( &BaseDllIniUserKeyPath );
        RtlInitUnicodeString( &BaseDllIniUserKeyPath, NULL );
    }
    RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);

    return TRUE;
}


BOOL
OpenProfileUserMapping( VOID )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;

    BaseDllFlushRegistryCache();
    RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);

    if (BaseDllIniUserKeyPath.Length == 0) {
        Status = RtlFormatCurrentUserKeyPath( &BaseDllIniUserKeyPath );
        if (NT_SUCCESS( Status )) {
            InitializeObjectAttributes( &ObjectAttributes,
                                        &BaseDllIniUserKeyPath,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );
            Status = NtOpenKey( &Key,
                                GENERIC_READ,
                                &ObjectAttributes
                              );

            if (NT_SUCCESS( Status )) {
                NtClose( Key );
            } else {
                RtlFreeUnicodeString( &BaseDllIniUserKeyPath );
                RtlInitUnicodeString( &BaseDllIniUserKeyPath, NULL );
            }
        }

        if (!NT_SUCCESS( Status )) {
            if (!RtlCreateUnicodeString( &BaseDllIniUserKeyPath, L"\\REGISTRY\\USER\\.DEFAULT" )) {
                RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
                return FALSE;
            }
        }
    }
    RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);

    return TRUE;
}

#if DBG
char *xOperationNames[] = {
    "FlushProfiles",
    "ReadKeyValue",
    "WriteKeyValue",
    "DeleteKey",
    "ReadKeyNames",
    "ReadSectionNames",
    "ReadSection",
    "WriteSection",
    "DeleteSection",
    "RefreshIniFileMapping"
};
#endif

NTSTATUS
BaseDllCaptureIniFileParameters(
                               BOOLEAN UnicodeParameters,
                               INIFILE_OPERATION Operation,
                               BOOLEAN WriteOperation,
                               BOOLEAN MultiValueStrings,
                               PVOID FileName,
                               PVOID ApplicationName,
                               PVOID VariableName,
                               PVOID VariableValue,
                               PULONG ResultMaxChars OPTIONAL,
                               PINIFILE_PARAMETERS *ReturnedParameterBlock
                               );


NTSTATUS
BaseDllReadWriteIniFileViaMapping(
                                 IN PINIFILE_PARAMETERS a
                                 );

NTSTATUS
BaseDllReadWriteIniFileOnDisk(
                             IN PINIFILE_PARAMETERS a
                             );

NTSTATUS
BaseDllOpenIniFileOnDisk(
                        IN PINIFILE_PARAMETERS a
                        );

NTSTATUS
BaseDllCloseIniFileOnDisk(
                         IN PINIFILE_PARAMETERS a
                         );

NTSTATUS
BaseDllAppendNullToResultBuffer(
                               IN PINIFILE_PARAMETERS a
                               );

NTSTATUS
BaseDllAppendStringToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOLEAN IncludeNull
                                 );

NTSTATUS
BaseDllAppendBufferToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PBYTE Buffer OPTIONAL,
                                 IN PWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOLEAN IncludeNull
                                 );

NTSTATUS
BaseDllReadWriteIniFile(
                       IN BOOLEAN Unicode,
                       IN BOOLEAN WriteOperation,
                       IN BOOLEAN SectionOperation,
                       IN PVOID FileName OPTIONAL,
                       IN PVOID ApplicationName OPTIONAL,
                       IN PVOID VariableName OPTIONAL,
                       IN OUT PVOID VariableValue OPTIONAL,
                       IN OUT PULONG VariableValueLength OPTIONAL
                       )
{
    BOOLEAN MultiValueStrings;
    INIFILE_OPERATION Operation;
    PINIFILE_PARAMETERS a;
    NTSTATUS Status;

    if (SectionOperation) {
        VariableName = NULL;
    }

    MultiValueStrings = FALSE;
    if (WriteOperation) {
        if (ARGUMENT_PRESENT( ApplicationName )) {
            if (ARGUMENT_PRESENT( VariableName )) {
                if (ARGUMENT_PRESENT( VariableValue )) {
                    Operation = WriteKeyValue;
                } else {
                    Operation = DeleteKey;
                }
            } else {
                if (ARGUMENT_PRESENT( VariableValue )) {
                    Operation = WriteSection;
                    MultiValueStrings = TRUE;
                } else {
                    Operation = DeleteSection;
                }
            }
        } else {
#if DBG
            if (ARGUMENT_PRESENT( VariableName ) ||
                ARGUMENT_PRESENT( VariableValue )
               ) {
                return STATUS_INVALID_PARAMETER;
            } else
#endif
                if (ARGUMENT_PRESENT( FileName )) {
                Operation = RefreshIniFileMapping;
            } else {
                Operation = FlushProfiles;
            }
        }
    } else {
        if (ARGUMENT_PRESENT( ApplicationName )) {
            if (!ARGUMENT_PRESENT( VariableValue )) {
                return STATUS_INVALID_PARAMETER;
            } else
                if (ARGUMENT_PRESENT( VariableName )) {
                Operation = ReadKeyValue;
            } else
                if (SectionOperation) {
                Operation = ReadSection;
                MultiValueStrings = TRUE;
            } else {
                Operation = ReadKeyNames;
                MultiValueStrings = TRUE;
            }
        } else
            if (SectionOperation || !ARGUMENT_PRESENT( VariableValue )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            VariableName = NULL;
            Operation = ReadSectionNames;
            MultiValueStrings = TRUE;
        }
    }

#if DBG
    if (WriteOperation) {
        ASSERT( Operation == WriteKeyValue || Operation == WriteSection || Operation == DeleteKey || Operation == DeleteSection || Operation == FlushProfiles || Operation == RefreshIniFileMapping );
    } else {
        ASSERT( Operation == ReadKeyValue || Operation == ReadKeyNames || Operation == ReadSectionNames || Operation == ReadSection );
    }
#endif

    Status = BaseDllCaptureIniFileParameters( Unicode,
                                              Operation,
                                              WriteOperation,
                                              MultiValueStrings,
                                              FileName,
                                              ApplicationName,
                                              VariableName,
                                              VariableValue,
                                              VariableValueLength,
                                              &a
                                            );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

#if DBG
    if (BaseDllDumpIniCalls) {
        DbgPrint( "BASEDLL: called with profile operation\n" );
        DbgPrint( "    Operation: %s  Write: %u\n", xOperationNames[ a->Operation ], a->WriteOperation );
        DbgPrint( "    BaseFileName: %wZ\n", &a->BaseFileName );
        DbgPrint( "    IniFileNameMapping: %08x\n", a->IniFileNameMapping );
        DbgPrint( "    FileName: %wZ\n", &a->FileName );
        DbgPrint( "    NtFileName: %wZ\n", &a->NtFileName );
        DbgPrint( "    ApplicationName: %wZ (%Z)\n", &a->ApplicationNameU, &a->ApplicationName );
        DbgPrint( "    VariableName: %wZ (%Z)\n", &a->VariableNameU, &a->VariableName );
        if (a->WriteOperation) {
            DbgPrint( "    VariableValue: %ws (%s)\n", a->ValueBufferU, a->ValueBuffer );
        }
    }
#endif // DBG

    if (a->Operation == RefreshIniFileMapping) {

#if defined(BUILD_WOW6432)
        Status = CsrBasepRefreshIniFileMapping(&a->BaseFileName);
#else
        BASE_API_MSG m;
        PBASE_REFRESHINIFILEMAPPING_MSG ap = &m.u.RefreshIniFileMapping;
        PCSR_CAPTURE_HEADER CaptureBuffer;

        CaptureBuffer = NULL;
        if (a->BaseFileName.Length > (MAX_PATH * sizeof( WCHAR ))) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                      a->BaseFileName.MaximumLength
                                                    );
            if (CaptureBuffer == NULL) {
                Status = STATUS_NO_MEMORY;
            } else {
                CsrCaptureMessageString( CaptureBuffer,
                                         (PCHAR)a->BaseFileName.Buffer,
                                         a->BaseFileName.Length,
                                         a->BaseFileName.MaximumLength,
                                         (PSTRING)&ap->IniFileName
                                       );
                Status = STATUS_SUCCESS;
            }
        }

        if (NT_SUCCESS( Status )) {
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 CaptureBuffer,
                                 CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                      BasepRefreshIniFileMapping
                                                    ),
                                 sizeof( *ap )
                               );

            Status = (NTSTATUS)m.ReturnValue;
        }

        CsrFreeCaptureBuffer( CaptureBuffer );
#endif
    } else
        if (a->IniFileNameMapping != NULL) {
        Status = BaseDllReadWriteIniFileViaMapping( a );
#if DBG
        if (BaseDllDumpIniCalls) {
            if (NT_SUCCESS( Status ) ||
                Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_MORE_PROCESSING_REQUIRED
               ) {
                if (!a->WriteOperation) {
                    if (a->Unicode) {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from registry - '%.*ws' (%u)\n", a->ResultChars, a->ResultBufferU, a->ResultChars );
                        } else {
                            PWSTR s;

                            DbgPrint( "BASEDLL: Return multi-value from registry: (%u)\n", a->ResultChars );
                            s = a->ResultBufferU;
                            s[ a->ResultChars ] = UNICODE_NULL;
                            while (*s) {
                                DbgPrint( "    %ws\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    } else {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from registry - '%.*s' (%u)\n", a->ResultChars, a->ResultBuffer, a->ResultChars );
                        } else {
                            PBYTE s;

                            DbgPrint( "BASEDLL: Return multi-value from registry: (%u)\n", a->ResultChars );
                            s = a->ResultBuffer;
                            s[ a->ResultChars ] = '\0';
                            while (*s) {
                                DbgPrint( "    (%s)\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    }
                } else {
                    DbgPrint( "BASEDLL: Returning success for above write operation\n" );
                }

                if (Status == STATUS_BUFFER_OVERFLOW) {
                    DbgPrint( "    *** above result partial as buffer too small.\n" );
                } else
                    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                    DbgPrint( "    *** above result partial and will now look on disk.\n" );
                }
            } else {
                DbgPrint( "BASEDLL: Profile operation %s failed: Status == %x\n", xOperationNames[ a->Operation ], Status );
            }

            if (a->ValueBufferAllocated) {
                if (a->Unicode) {
                    PWSTR s;

                    DbgPrint( "BASEDLL: Remaining Variables to write to disk:\n" );
                    s = a->ValueBufferU;
                    while (*s) {
                        DbgPrint( "    %ws\n", s );
                        while (*s++) {
                        }
                    }
                } else {
                    PBYTE s;

                    DbgPrint( "BASEDLL: Remaining Variables to write to disk:\n" );
                    s = a->ValueBuffer;
                    while (*s) {
                        DbgPrint( "    (%s)\n", s );
                        while (*s++) {
                        }
                    }

                }
            }
        }
#endif // DBG
    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        Status = BaseDllReadWriteIniFileOnDisk( a );
#if DBG
        if (BaseDllDumpIniCalls) {
            if (NT_SUCCESS( Status ) ||
                Status == STATUS_BUFFER_OVERFLOW
               ) {
                if (!a->WriteOperation) {
                    if (a->Unicode) {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from disk - '%.*ws' (%u)\n", a->ResultChars, a->ResultBufferU, a->ResultChars );
                        } else {
                            PWSTR s;

                            DbgPrint( "BASEDLL: Return multi-value from disk: (%u)\n", a->ResultChars );
                            s = a->ResultBufferU;
                            s[ a->ResultChars ] = UNICODE_NULL;
                            while (*s) {
                                DbgPrint( "    %ws\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    } else {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from disk - '%.*s' (%u)\n", a->ResultChars, a->ResultBuffer, a->ResultChars );
                        } else {
                            PBYTE s;

                            DbgPrint( "BASEDLL: Return multi-value from disk: (%u)\n", a->ResultChars );
                            s = a->ResultBuffer;
                            s[ a->ResultChars ] = '\0';
                            while (*s) {
                                DbgPrint( "    (%s)\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    }

                    if (Status == STATUS_BUFFER_OVERFLOW) {
                        DbgPrint( "    *** above result partial as buffer too small.\n" );
                    }
                } else {
                    DbgPrint( "BASEDLL: Returning success for above write operation.\n" );
                }
            } else {
                DbgPrint( "BASEDLL: Profile operation %s failed: Status == %x\n", xOperationNames[ a->Operation ], Status );
            }
        }
#endif // DBG
    }

    if (BaseRunningInServerProcess || a->Operation == FlushProfiles) {
        BaseDllFlushRegistryCache();
    }

    if (NT_SUCCESS( Status )) {
        if (a->Operation == ReadSectionNames ||
            a->Operation == ReadKeyNames ||
            a->Operation == ReadSection
           ) {
            Status = BaseDllAppendNullToResultBuffer( a );
        }
    }

    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (a->WriteOperation) {
            BaseIniFileUpdateCount++;
        } else
            if (ARGUMENT_PRESENT( VariableValueLength )) {
            *VariableValueLength = a->ResultChars;
        }
    }

    if (a->ValueBufferAllocated) {
        if (a->Unicode) {
            RtlFreeHeap( RtlProcessHeap(), 0, a->ValueBufferU );
        } else {
            RtlFreeHeap( RtlProcessHeap(), 0, a->ValueBuffer );
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, a );

    return Status;
}


ULONG
BaseDllIniFileNameLength(
                        IN BOOLEAN Unicode,
                        IN PVOID *Name
                        );

NTSTATUS
BaseDllFindIniFileNameMapping(
                             IN PUNICODE_STRING FileName,
                             IN PUNICODE_STRING BaseFileName,
                             OUT PINIFILE_MAPPING_FILENAME *ReturnedFileNameMapping
                             );

BOOLEAN
BaseDllGetApplicationName(
                         IN PINIFILE_PARAMETERS a,
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         );

BOOLEAN
BaseDllGetVariableName(
                      IN PINIFILE_PARAMETERS a,
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      );

BOOLEAN
BaseDllGetVariableValue(
                       IN PINIFILE_PARAMETERS a,
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT PWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       );

NTSTATUS
BaseDllCaptureIniFileParameters(
                               BOOLEAN Unicode,
                               INIFILE_OPERATION Operation,
                               BOOLEAN WriteOperation,
                               BOOLEAN MultiValueStrings,
                               PVOID FileName OPTIONAL,
                               PVOID ApplicationName OPTIONAL,
                               PVOID VariableName OPTIONAL,
                               PVOID VariableValue OPTIONAL,
                               PULONG ResultMaxChars OPTIONAL,
                               PINIFILE_PARAMETERS *ReturnedParameterBlock
                               )
{
    NTSTATUS Status;
    PBYTE s;
    PWSTR p, p1;
    ULONG TotalSize,
    CharSize,
    NtFileNameLength,
    FileNameLength,
    ApplicationNameLength,
    VariableNameLength,
    VariableValueLength;
    ANSI_STRING AnsiString;
    PINIFILE_PARAMETERS a;

    if (ARGUMENT_PRESENT( FileName )) {
        if (Unicode) {
            FileNameLength = wcslen( FileName );
        } else {
            FileNameLength = strlen( FileName );
        }
    } else {
        FileNameLength = 0;
    }

    if (ARGUMENT_PRESENT( ApplicationName )) {
        ApplicationNameLength = BaseDllIniFileNameLength( Unicode, &ApplicationName );
    } else {
        ApplicationNameLength = 0;
        VariableName = NULL;
    }

    if (ARGUMENT_PRESENT( VariableName )) {
        VariableNameLength = BaseDllIniFileNameLength( Unicode, &VariableName );
    } else {
        VariableNameLength = 0;
    }

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (ARGUMENT_PRESENT( ResultMaxChars )) {
            VariableValueLength = 0;
        } else {
            if (!MultiValueStrings) {
                if (Unicode) {
                    VariableValueLength = wcslen( VariableValue );
                } else {
                    VariableValueLength = strlen( VariableValue );
                }
            } else {
                if (Unicode) {
                    p = (PWSTR)VariableValue;
                    while (*p) {
                        while (*p++) {
                            ;
                        }
                    }

                    VariableValueLength = (ULONG)(p - (PWSTR)VariableValue);
                } else {
                    s = (PBYTE)VariableValue;
                    while (*s) {
                        while (*s++) {
                            ;
                        }
                    }

                    VariableValueLength = (ULONG)(s - (PBYTE)VariableValue);
                }
            }
        }
    } else {
        VariableValueLength = 0;
    }

    NtFileNameLength = RtlGetLongestNtPathLength() * sizeof( WCHAR );
    TotalSize = sizeof( *a ) + NtFileNameLength;
    if (!Unicode) {
        TotalSize += (FileNameLength + 1 ) * sizeof( WCHAR );
    }

    // We have to allocate enough buffer for DBCS string.
    CharSize = (Unicode ? sizeof(WORD) : sizeof( WCHAR ));
    TotalSize += (ApplicationNameLength + 1 +
                  VariableNameLength + 1 +
                  VariableValueLength + 1
                 ) * CharSize;
    a = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), TotalSize );
    if (a == NULL) {
        KdPrint(( "BASE: Unable to allocate IniFile parameter buffer of %u bytes\n", TotalSize ));
        return STATUS_NO_MEMORY;
    }

    a->Operation = Operation;
    a->WriteOperation = WriteOperation;
    a->Unicode = Unicode;
    a->IniFile = NULL;
    a->ValueBufferAllocated = FALSE;
    a->MultiValueStrings = MultiValueStrings;

    p = (PWSTR)(a + 1);
    a->NtFileName.Buffer = p;
    a->NtFileName.Length = 0;
    a->NtFileName.MaximumLength = (USHORT)NtFileNameLength;
    p = (PWSTR)((PCHAR)p + NtFileNameLength);

    if (ARGUMENT_PRESENT( FileName )) {
        a->FileName.MaximumLength = (USHORT)((FileNameLength + 1) * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->FileName.Length = (USHORT)(FileNameLength * sizeof( WCHAR ));
            a->FileName.Buffer = FileName;
        } else {
            AnsiString.Buffer = FileName;
            AnsiString.Length = (USHORT)FileNameLength;
            AnsiString.MaximumLength = (USHORT)(AnsiString.Length + 1);
            a->FileName.Buffer = p;
            a->FileName.Length = 0;
            p += FileNameLength + 1;
            Status = Basep8BitStringToUnicodeString( &a->FileName, &AnsiString, FALSE );
            if (!NT_SUCCESS( Status )) {
                RtlFreeHeap( RtlProcessHeap(), 0, a );
                return Status;
            }
        }

        a->BaseFileName.Length = 0;
        p1 = a->FileName.Buffer + FileNameLength;
        if (FileNameLength != 0) {
            while (--p1 > a->FileName.Buffer) {
                if (*p1 == OBJ_NAME_PATH_SEPARATOR ||
                    *p1 == L'/' ||
                    *p1 == L':'
                    ) {
                    p1++;
                    break;
                }
            }
        }

        a->BaseFileName.Buffer = p1;
        a->BaseFileName.Length = (USHORT)((FileNameLength - (p1 - a->FileName.Buffer)) * sizeof( WCHAR ));
        a->BaseFileName.MaximumLength = (USHORT)(a->BaseFileName.Length + sizeof( UNICODE_NULL ));
        BaseDllFindIniFileNameMapping( &a->FileName,
                                       &a->BaseFileName,
                                       &a->IniFileNameMapping
                                     );
    } else {
        RtlInitUnicodeString( &a->FileName, L"win.ini" );
        a->BaseFileName = a->FileName;
        a->IniFileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->WinIniFileMapping;
    }

    if (ARGUMENT_PRESENT( ApplicationName )) {
        // We have to keep enough buffer for DBCS string.
        a->ApplicationName.MaximumLength = (USHORT)((ApplicationNameLength * sizeof(WORD)) + 1);
        a->ApplicationNameU.MaximumLength = (USHORT)(a->ApplicationName.MaximumLength * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->ApplicationNameU.Buffer = ApplicationName;
            a->ApplicationNameU.Length = (USHORT)(ApplicationNameLength * sizeof( UNICODE_NULL ));
            a->ApplicationName.Buffer = (PBYTE)p;
            a->ApplicationName.Length = 0;
            p = (PWSTR)((PCHAR)p + (ApplicationNameLength * sizeof(WORD)) + 1);
        } else {
            a->ApplicationName.Buffer = ApplicationName;
            a->ApplicationName.Length = (USHORT)ApplicationNameLength;
            a->ApplicationNameU.Buffer = p;
            a->ApplicationNameU.Length = 0;
            p += ApplicationNameLength + 1;
        }
    } else {
        RtlInitAnsiString( &a->ApplicationName, NULL );
        RtlInitUnicodeString( &a->ApplicationNameU, NULL );
    }

    if (ARGUMENT_PRESENT( VariableName )) {
        // We have to keep enough buffer for DBCS string.
        a->VariableName.MaximumLength = (USHORT)((VariableNameLength *sizeof(WORD)) + 1);
        a->VariableNameU.MaximumLength = (USHORT)(a->VariableName.MaximumLength * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->VariableNameU.Buffer = VariableName;
            a->VariableNameU.Length = (USHORT)(VariableNameLength * sizeof( UNICODE_NULL ));
            a->VariableName.Buffer = (PBYTE)p;
            a->VariableName.Length = 0;
            p = (PWSTR)((PCHAR)p + (VariableNameLength * sizeof(WORD)) + 1);
        } else {
            a->VariableName.Buffer = VariableName;
            a->VariableName.Length = (USHORT)VariableNameLength;
            a->VariableNameU.Buffer = p;
            a->VariableNameU.Length = 0;
            p += VariableNameLength + 1;
        }
    } else {
        RtlInitAnsiString( &a->VariableName, NULL );
        RtlInitUnicodeString( &a->VariableNameU, NULL );
    }

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (a->WriteOperation) {
            if (Unicode) {
                a->ValueBufferU = VariableValue;
                a->ValueLengthU = VariableValueLength * sizeof( WCHAR );
                *(PBYTE)p = '\0';
                a->ValueBuffer = (PBYTE)p;
                a->ValueLength = 0;
            } else {
                a->ValueBuffer = VariableValue;
                a->ValueLength = VariableValueLength;
                *p = UNICODE_NULL;
                a->ValueBufferU = p;
                a->ValueLengthU = 0;
            }
        } else {
            if (ARGUMENT_PRESENT( ResultMaxChars )) {
                a->ResultMaxChars = *ResultMaxChars;
            } else {
                a->ResultMaxChars = 0;
            }
            a->ResultChars = 0;
            if (Unicode) {
                a->ResultBufferU = VariableValue;
                a->ResultBuffer = NULL;
            } else {
                a->ResultBuffer = VariableValue;
                a->ResultBufferU = NULL;
            }
        }
    } else {
        if (a->WriteOperation) {
            a->ValueBuffer = NULL;
            a->ValueLength = 0;
            a->ValueBufferU = NULL;
            a->ValueLengthU = 0;
        } else {
            a->ResultMaxChars = 0;
            a->ResultChars = 0;
            a->ResultBufferU = NULL;
            a->ResultBuffer = NULL;
        }
    }

    *ReturnedParameterBlock = a;
    return STATUS_SUCCESS;
}


BOOLEAN
BaseDllGetApplicationName(
                         IN PINIFILE_PARAMETERS a,
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( ApplicationName )) {
        if (a->ApplicationName.Length == 0) {
            Status = RtlUnicodeStringToAnsiString( &a->ApplicationName, &a->ApplicationNameU, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", &a->ApplicationNameU, Status ));
                return FALSE;
            }
        }

        *ApplicationName = &a->ApplicationName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( ApplicationNameU )) {
        if (a->ApplicationNameU.Length == 0) {
            Status = RtlAnsiStringToUnicodeString( &a->ApplicationNameU, &a->ApplicationName, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", &a->ApplicationName, Status ));
                return FALSE;

            }
        }
        *ApplicationNameU = &a->ApplicationNameU;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
BaseDllGetVariableName(
                      IN PINIFILE_PARAMETERS a,
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( VariableName )) {
        if (a->VariableName.Length == 0) {
            Status = RtlUnicodeStringToAnsiString( &a->VariableName, &a->VariableNameU, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", &a->VariableNameU, Status ));
                return FALSE;
            }
        }

        *VariableName = &a->VariableName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableNameU )) {
        if (a->VariableNameU.Length == 0) {
            Status = RtlAnsiStringToUnicodeString( &a->VariableNameU, &a->VariableName, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", &a->VariableName, Status ));
                return FALSE;

            }
        }
        *VariableNameU = &a->VariableNameU;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
BaseDllGetVariableValue(
                       IN PINIFILE_PARAMETERS a,
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT PWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       )
{
    NTSTATUS Status;
    ULONG Index;

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (a->ValueLength == 0) {
            if (a->ValueBufferU == NULL || a->ValueLengthU == 0) {
                *VariableValue = "";
                *VariableValueLength = 1;
                return TRUE;
            }

            a->ValueLength = a->ValueLengthU;
            Status = RtlUnicodeToMultiByteN( a->ValueBuffer,
                                             a->ValueLength,
                                             &Index,
                                             a->ValueBufferU,
                                             a->ValueLengthU
                                           );

            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %.*ws failed (%08x)\n",
                          a->ValueLengthU / sizeof( WCHAR ), a->ValueBufferU, Status
                        ));
                return FALSE;
            }

            // Set real converted size
            a->ValueLength = Index;
            a->ValueBuffer[ Index ] = '\0';       // Null terminate converted value
        } else {
            Index = a->ValueLength;
        }

        *VariableValue = a->ValueBuffer;
        *VariableValueLength = Index + 1;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableValueU )) {
        if (a->ValueLengthU == 0) {
            if (a->ValueBuffer == NULL || a->ValueLength == 0) {
                *VariableValueU = L"";
                *VariableValueLength = sizeof( UNICODE_NULL );
                return TRUE;
            }

            a->ValueLengthU = a->ValueLength * sizeof( WCHAR );
            Status = RtlMultiByteToUnicodeN( a->ValueBufferU,
                                             a->ValueLengthU,
                                             &Index,
                                             a->ValueBuffer,
                                             a->ValueLength
                                           );


            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %.*s failed (%08x)\n",
                          a->ValueLength, a->ValueBuffer, Status
                        ));
                return FALSE;
            }

            Index = Index / sizeof( WCHAR );
            a->ValueBufferU[ Index ] = UNICODE_NULL;    // Null terminate converted value
        } else {
            Index = a->ValueLengthU / sizeof( WCHAR );
        }

        *VariableValueU = a->ValueBufferU;
        *VariableValueLength = (Index + 1) * sizeof( WCHAR );
        return TRUE;
    }

    return FALSE;
}


NTSTATUS
BaseDllAppendNullToResultBuffer(
                               IN PINIFILE_PARAMETERS a
                               )
{
    return BaseDllAppendBufferToResultBuffer( a,
                                              NULL,
                                              NULL,
                                              0,
                                              TRUE
                                            );
}

NTSTATUS
BaseDllAppendStringToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOLEAN IncludeNull
                                 )
{
    if (ARGUMENT_PRESENT( String )) {
        if (ARGUMENT_PRESENT( StringU )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            return BaseDllAppendBufferToResultBuffer( a,
                                                      String->Buffer,
                                                      NULL,
                                                      String->Length,
                                                      IncludeNull
                                                    );
        }
    } else
        if (ARGUMENT_PRESENT( StringU )) {
        if (ARGUMENT_PRESENT( String )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            return BaseDllAppendBufferToResultBuffer( a,
                                                      NULL,
                                                      StringU->Buffer,
                                                      StringU->Length / sizeof( WCHAR ),
                                                      IncludeNull
                                                    );
        }
    } else {
        return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS
BaseDllAppendBufferToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PBYTE Buffer OPTIONAL,
                                 IN PWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOLEAN IncludeNull
                                 )
{
    NTSTATUS Status, OverflowStatus;
    ULONG Index;

    OverflowStatus = STATUS_SUCCESS;
    if (ARGUMENT_PRESENT( Buffer )) {
        if (ARGUMENT_PRESENT( BufferU )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            ULONG CharsMbcs = Chars;
            //
            // In this point, Chars does not contains proper value for Unicode.
            // because. Chars was computed based on DBCS string length,
            // This is correct, sources string is DBCS, then
            // if the source is not DBCS. we just adjust it here.
            //
            if (a->Unicode) {
                Status = RtlMultiByteToUnicodeSize(&Chars,Buffer,Chars);
                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: AnsiToUnicodeSize of %.*s failed (%08x)\n", Chars, Buffer, Status ));
                    return Status;
                }
                Chars /= sizeof(WCHAR);
            }
            if (a->ResultChars + Chars >= a->ResultMaxChars) {
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = a->ResultMaxChars - a->ResultChars;
                if (Chars) {
                    Chars -= 1;
                }
            }

            if (Chars) {
                if (a->Unicode) {
                    Status = RtlMultiByteToUnicodeN( a->ResultBufferU + a->ResultChars,
                                                     Chars * sizeof( WCHAR ),
                                                     &Index,
                                                     Buffer,
                                                     CharsMbcs
                                                   );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: AnsiToUnicode of %.*s failed (%08x)\n", Chars, Buffer, Status ));
                        return Status;
                    }
                } else {
                    memcpy( a->ResultBuffer + a->ResultChars, Buffer, Chars );
                }

                a->ResultChars += Chars;
            }
        }
    } else
        if (ARGUMENT_PRESENT( BufferU )) {
        if (ARGUMENT_PRESENT( Buffer )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            ULONG CharsUnicode = Chars;
            //
            // In this point, Chars does not contains proper value for DBCS.
            // because. Chars was computed by just devide Unicode string length
            // by two. This is correct, sources string is Unicode, then
            // if the source is not Unicode. we just adjust it here.
            //
            if (!(a->Unicode)) {
                Status = RtlUnicodeToMultiByteSize(&Chars,BufferU,Chars * sizeof(WCHAR));
                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: UnicodeToAnsiSize of %.*ws failed (%08x)\n", Chars, BufferU, Status ));
                    return Status;
                }
            }
            if (a->ResultChars + Chars >= a->ResultMaxChars) {
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = a->ResultMaxChars - a->ResultChars;
                if (Chars) {
                    Chars -= 1;
                }
            }

            if (Chars) {
                if (a->Unicode) {
                    memcpy( a->ResultBufferU + a->ResultChars, BufferU, Chars * sizeof( WCHAR ) );
                } else {
                    Status = RtlUnicodeToMultiByteN( a->ResultBuffer + a->ResultChars,
                                                     Chars,
                                                     &Index,
                                                     BufferU,
                                                     CharsUnicode * sizeof( WCHAR )
                                                   );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: UnicodeToAnsi of %.*ws failed (%08x)\n", Chars, BufferU, Status ));
                        return Status;
                    }
                }

                a->ResultChars += Chars;
            }
        }
    }

    if (IncludeNull) {
        if (a->ResultChars + 1 >= a->ResultMaxChars) {
            return STATUS_BUFFER_OVERFLOW;
        }

        if (a->Unicode) {
            a->ResultBufferU[ a->ResultChars ] = UNICODE_NULL;
        } else {
            a->ResultBuffer[ a->ResultChars ] = '\0';
        }

        a->ResultChars += 1;
    }

    return OverflowStatus;
}


ULONG
BaseDllIniFileNameLength(
                        IN BOOLEAN Unicode,
                        IN PVOID *Name
                        )
{
    if (Unicode) {
        PWSTR p;

        p = *Name;
        while (*p == L' ') {
            p++;
        }
        *Name = p;
        while (*p != UNICODE_NULL) {
            p++;
        }

        if (p > (PWSTR)*Name) {
            while (*--p == L' ') {
            }
            p++;
        }

        return (ULONG)(p - (PWSTR)*Name);
    } else {
        PCH p;

        p = *Name;
        while (*p == ' ') {
            p++;
        }
        *Name = p;
        while (*p != '\0') {
            p++;
        }

        if (p > (PCH)*Name) {
            while (*--p == ' ') {
            }
            p++;
        }

        return (ULONG)(p - (PCH)*Name);
    }
}



NTSTATUS
BaseDllFindIniFileNameMapping(
                             IN PUNICODE_STRING FileName,
                             IN PUNICODE_STRING BaseFileName,
                             OUT PINIFILE_MAPPING_FILENAME *ReturnedFileNameMapping
                             )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_FILENAME FileNameMapping;
    UNICODE_STRING WinIniString;
    WCHAR TermSrvWindowsPath[MAX_PATH+1];
    UNICODE_STRING TermsrvWindowsDir;


    Status = STATUS_OBJECT_NAME_NOT_FOUND;
    RtlInitUnicodeString(&WinIniString, L"win.ini");

    //
    // Only look in mapping if
    //   Unqualified name was specified OR
    //   Path specified exactly matches the name of the Windows directory OR
    //   Filename is not win.ini (special hack for Windows Sound System, which
    //      expects GetPrivateProfileString on C:\SNDSYS\WIN.INI to return the
    //      data from the file, not the registry)
    //

    if (gpTermsrvGetWindowsDirectoryW) {

        if (gpTermsrvGetWindowsDirectoryW (TermSrvWindowsPath,MAX_PATH)) {

            RtlInitUnicodeString(&TermsrvWindowsDir,TermSrvWindowsPath);

        } else {

            RtlInitUnicodeString(&TermsrvWindowsDir,L"");

        }
    }


    if ((FileName->Buffer == BaseFileName->Buffer) ||
        RtlPrefixUnicodeString( &BaseWindowsDirectory, FileName, TRUE ) ||
        (!RtlEqualUnicodeString( BaseFileName, &WinIniString, TRUE )) ||
        // Also check for in per user's windows directory
        (IsTerminalServer() && RtlPrefixUnicodeString( &TermsrvWindowsDir, FileName, TRUE ))) {

        FileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->FileNames;
        while (FileNameMapping != NULL) {

            BASE_READ_REMOTE_STR_TEMP(TempStr);

            if (RtlEqualUnicodeString( BaseFileName,
                                       BASE_READ_REMOTE_STR(FileNameMapping->Name, TempStr),
                                       TRUE )) {
                Status = STATUS_SUCCESS;
                break;
            }

            FileNameMapping = (PINIFILE_MAPPING_FILENAME)FileNameMapping->Next;
        }

        if (FileNameMapping == NULL) {
            FileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->DefaultFileNameMapping;
        }

        *ReturnedFileNameMapping = FileNameMapping;
    } else {
        *ReturnedFileNameMapping = NULL;
    }

    return Status;
}


NTSTATUS
BaseDllOpenMappingTarget(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping,
                        IN PUNICODE_STRING ApplicationName OPTIONAL,
                        IN BOOLEAN WriteAccess,
                        OUT PHANDLE Key
                        );

PINIFILE_MAPPING_APPNAME
BaseDllFindAppNameMapping(
                         IN PINIFILE_MAPPING_FILENAME FileNameMapping,
                         IN PUNICODE_STRING ApplicationName
                         );

PINIFILE_MAPPING_VARNAME
BaseDllFindVarNameMapping(
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PUNICODE_STRING VariableName
                         );

NTSTATUS
BaseDllReadApplicationNames(
                           IN PINIFILE_PARAMETERS a
                           );

NTSTATUS
BaseDllCheckKeyNotEmpty(
                       IN HANDLE Key,
                       IN PUNICODE_STRING SubKeyName
                       );

NTSTATUS
BaseDllReadVariableNames(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping
                        );

NTSTATUS
BaseDllReadVariableValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        );

NTSTATUS
BaseDllReadApplicationVariables(
                               IN PINIFILE_PARAMETERS a,
                               IN PINIFILE_MAPPING_APPNAME AppNameMapping
                               );

NTSTATUS
BaseDllDeleteApplicationVariables(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                 );

NTSTATUS
BaseDllWriteApplicationVariables(
                                IN PINIFILE_PARAMETERS a,
                                IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                );

NTSTATUS
BaseDllWriteVariableValue(
                         IN PINIFILE_PARAMETERS a,
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                         IN PUNICODE_STRING VariableName OPTIONAL
                         );

NTSTATUS
BaseDllReadWriteIniFileViaMapping(
                                 IN PINIFILE_PARAMETERS a
                                 )
{
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    PUNICODE_STRING ApplicationNameU;

    if (a->Operation == FlushProfiles) {
        return STATUS_SUCCESS;
    } else
        if (a->Operation == ReadSectionNames) {
        return BaseDllReadApplicationNames( a );
    } else
        if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    AppNameMapping = BaseDllFindAppNameMapping( a->IniFileNameMapping, ApplicationNameU );
    if (AppNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else
        if (a->Operation == ReadKeyValue) {
        return BaseDllReadVariableValue( a, AppNameMapping, NULL, NULL );
    } else
        if (a->Operation == ReadKeyNames) {
        return BaseDllReadVariableNames( a, AppNameMapping );
    } else
        if (a->Operation == ReadSection) {
        return BaseDllReadApplicationVariables( a, AppNameMapping );
    } else
        if (a->Operation == WriteKeyValue || a->Operation == DeleteKey) {
        return BaseDllWriteVariableValue( a, AppNameMapping, NULL, NULL );
    } else
        if (a->Operation == WriteSection || a->Operation == DeleteSection) {
        return BaseDllWriteApplicationVariables( a, AppNameMapping );
    }

    return STATUS_INVALID_PARAMETER;
}

VOID
BaseDllFlushRegistryCache( VOID )
{
    RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);

    BaseDllRegistryCache.MappingTarget = NULL;
    BaseDllRegistryCache.MappingFlags = 0;

    if (BaseDllRegistryCache.RegistryPath.Buffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, BaseDllRegistryCache.RegistryPath.Buffer );
        RtlZeroMemory( &BaseDllRegistryCache.RegistryPath,
                       sizeof( BaseDllRegistryCache.RegistryPath )
                     );
    }

    if (BaseDllRegistryCache.RegistryKey != INVALID_HANDLE_VALUE) {
        NtClose( BaseDllRegistryCache.RegistryKey );
        BaseDllRegistryCache.RegistryKey = INVALID_HANDLE_VALUE;
    }

    RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);

    return;
}

NTSTATUS
BaseDllOpenMappingTarget(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping,
                        IN PUNICODE_STRING ApplicationName OPTIONAL,
                        IN BOOLEAN WriteAccess,
                        OUT PHANDLE Key
                        )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_TARGET MappingTarget;
    ULONG MappingFlags;
    BOOLEAN AppendApplicationName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG CreateDisposition;
    PUNICODE_STRING RegistryPathPrefix;
    UNICODE_STRING RegistryPath;
    KEY_BASIC_INFORMATION KeyBasicInfo;
    ULONG ResultLength;
    ULONG n;
    BOOLEAN OperationRetried = FALSE;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    *Key = INVALID_HANDLE_VALUE;
    MappingTarget = (PINIFILE_MAPPING_TARGET)VarNameMapping->MappingTarget;
    MappingFlags = VarNameMapping->MappingFlags & (INIFILE_MAPPING_APPEND_BASE_NAME |
                                                   INIFILE_MAPPING_APPEND_APPLICATION_NAME |
                                                   INIFILE_MAPPING_SOFTWARE_RELATIVE |
                                                   INIFILE_MAPPING_USER_RELATIVE
                                                  );
    if (MappingTarget == NULL || MappingTarget->RegistryPath.Length == 0) {
        return STATUS_SUCCESS;
    }

    if (ARGUMENT_PRESENT( ApplicationName ) &&
        (MappingFlags & INIFILE_MAPPING_APPEND_APPLICATION_NAME)
       ) {
        AppendApplicationName = TRUE;
    } else {
        AppendApplicationName = FALSE;
    }

    RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);

    if (MappingFlags & INIFILE_MAPPING_USER_RELATIVE) {
        if (!BaseRunningInServerProcess && BaseDllIniUserKeyPath.Length == 0) {
            OpenProfileUserMapping();
        }

        if (BaseDllIniUserKeyPath.Length == 0) {
            KdPrint(( "BASE: Attempt to access user profile specific portion of .INI file.\n" ));
            KdPrint(( "      when there is no current user defined.\n" ));
            KdPrint(( "      Path: %wZ\n",
                      &MappingTarget->RegistryPath
                    ));
            RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
            return STATUS_ACCESS_DENIED;
        }

        RegistryPathPrefix = &BaseDllIniUserKeyPath;
    } else
        if (MappingFlags & INIFILE_MAPPING_SOFTWARE_RELATIVE) {
        RegistryPathPrefix = &BaseDllIniSoftwareKeyPath;
    } else {
        RegistryPathPrefix = NULL;
    }

    if (RegistryPathPrefix != NULL) {
        n = RegistryPathPrefix->Length + sizeof( WCHAR );
    } else {
        n = 0;
    }

    n += sizeof( WCHAR ) + MappingTarget->RegistryPath.Length;
    if (MappingFlags & INIFILE_MAPPING_APPEND_BASE_NAME) {
        n += sizeof( WCHAR ) + a->BaseFileName.Length;
    }

    if (AppendApplicationName) {
        n += sizeof( WCHAR ) + ApplicationName->Length;
    }
    n += sizeof( UNICODE_NULL );

    RegistryPath.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, n );
    if (RegistryPath.Buffer == NULL) {

        KdPrint(( "BASE: Unable to allocate registry path buffer of %u bytes\n", n ));
        RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
        return STATUS_NO_MEMORY;
    }
    RegistryPath.Length = 0;
    RegistryPath.MaximumLength = (USHORT)n;

    if (RegistryPathPrefix != NULL) {
        RtlAppendUnicodeStringToString( &RegistryPath, RegistryPathPrefix );
        RtlAppendUnicodeToString( &RegistryPath, L"\\" );
    }

    RtlAppendUnicodeStringToString( &RegistryPath,
                                    BASE_READ_REMOTE_STR(MappingTarget->RegistryPath, TempStr)
                                  );

    if (MappingFlags & INIFILE_MAPPING_APPEND_BASE_NAME) {
        RtlAppendUnicodeToString( &RegistryPath, L"\\" );
        RtlAppendUnicodeStringToString( &RegistryPath, &a->BaseFileName );
    }
    if (AppendApplicationName) {
        RtlAppendUnicodeToString( &RegistryPath, L"\\" );
        RtlAppendUnicodeStringToString( &RegistryPath, ApplicationName );
    }

    if (BaseDllRegistryCache.RegistryKey != INVALID_HANDLE_VALUE &&
        BaseDllRegistryCache.MappingTarget == MappingTarget &&
        BaseDllRegistryCache.MappingFlags == MappingFlags &&
        BaseDllRegistryCache.WriteAccess == WriteAccess &&
        RtlEqualUnicodeString( &BaseDllRegistryCache.RegistryPath, &RegistryPath, TRUE )
       ) {
        Status = NtQueryKey( BaseDllRegistryCache.RegistryKey,
                             KeyBasicInformation,
                             &KeyBasicInfo,
                             sizeof( KeyBasicInfo ),
                             &ResultLength
                           );
        if (Status != STATUS_KEY_DELETED) {
            RtlFreeHeap( RtlProcessHeap(), 0, RegistryPath.Buffer );
            *Key = BaseDllRegistryCache.RegistryKey;
            RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
            return STATUS_SUCCESS;
        }
    }
    RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
    BaseDllFlushRegistryCache();

    InitializeObjectAttributes( &ObjectAttributes,
                                &RegistryPath,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                NULL,
                                NULL
                              );

    if (WriteAccess) {
        repeatoperation:

        Status = NtCreateKey( Key,
                              STANDARD_RIGHTS_WRITE |
                              KEY_QUERY_VALUE |
                              KEY_ENUMERATE_SUB_KEYS |
                              KEY_SET_VALUE |
                              KEY_CREATE_SUB_KEY,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              &CreateDisposition
                            );
        //
        // There are cases where dorks delete the virtual ini file in the
        // registry. To handle this, if we get object path not found, attempt
        // to create the containing key and then repeat the operation
        //

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND && OperationRetried == FALSE ) {

            NTSTATUS RetryStatus;
            OBJECT_ATTRIBUTES RetryObjectAttributes;
            ULONG RetryCreateDisposition;
            UNICODE_STRING RetryRegistryPath;
            HANDLE RetryKey;

            RetryRegistryPath = RegistryPath;
            while ( RetryRegistryPath.Buffer[RetryRegistryPath.Length>>1] != (WCHAR)'\\' ) {
                RetryRegistryPath.Length -= sizeof(WCHAR);
            }

            InitializeObjectAttributes( &RetryObjectAttributes,
                                        &RetryRegistryPath,
                                        OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                        NULL,
                                        NULL
                                      );
            RetryStatus = NtCreateKey( &RetryKey,
                                       STANDARD_RIGHTS_WRITE |
                                       KEY_QUERY_VALUE |
                                       KEY_ENUMERATE_SUB_KEYS |
                                       KEY_SET_VALUE |
                                       KEY_CREATE_SUB_KEY,
                                       &RetryObjectAttributes,
                                       0,
                                       NULL,
                                       0,
                                       &RetryCreateDisposition
                                     );
            if ( NT_SUCCESS(RetryStatus) ) {
                NtClose(RetryKey);
                OperationRetried = TRUE;
                goto repeatoperation;
            }
        }
    } else {
        Status = NtOpenKey( Key,
                            GENERIC_READ,
                            &ObjectAttributes
                          );
    }


    if (NT_SUCCESS( Status )) {
#if DBG
        if (BaseDllDumpIniCalls) {
            KdPrint(( "BASEDLL: Opened %wZ\n", &RegistryPath ));
        }
#endif

        RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);
        BaseDllRegistryCache.MappingTarget = MappingTarget;
        BaseDllRegistryCache.MappingFlags = MappingFlags;
        BaseDllRegistryCache.WriteAccess = WriteAccess;
        BaseDllRegistryCache.RegistryPath = RegistryPath;
        BaseDllRegistryCache.RegistryKey = *Key;
        RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
    } else {
#if DBG
        if (BaseDllDumpIniCalls || WriteAccess || Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            DbgPrint( "BASEDLL: Failed to open %wZ for %s - Status == %lx\n",
                      &RegistryPath,
                      WriteAccess ? "write" : "read",
                      Status
                    );
        }
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, RegistryPath.Buffer );
    }

    return Status;
}


PINIFILE_MAPPING_APPNAME
BaseDllFindAppNameMapping(
                         IN PINIFILE_MAPPING_FILENAME FileNameMapping,
                         IN PUNICODE_STRING ApplicationName
                         )
{
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->ApplicationNames;
    while (AppNameMapping != NULL) {

        if (RtlEqualUnicodeString( BASE_READ_REMOTE_STR(AppNameMapping->Name, TempStr),
                                   ApplicationName,
                                   TRUE )) {
            return AppNameMapping;
        }

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)AppNameMapping->Next;
    }

    return (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;
}


PINIFILE_MAPPING_VARNAME
BaseDllFindVarNameMapping(
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PUNICODE_STRING VariableName
                         )
{

    PINIFILE_MAPPING_VARNAME VarNameMapping;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {

        if (RtlEqualUnicodeString( BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr),
                                   VariableName,
                                   TRUE )) {
            return VarNameMapping;
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    return (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
}


NTSTATUS
BaseDllReadApplicationNames(
                           IN PINIFILE_PARAMETERS a
                           )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    HANDLE Key;
    WCHAR Buffer[ 256 ];
    PKEY_BASIC_INFORMATION KeyInformation;
    ULONG SubKeyIndex;
    ULONG ResultLength;
    UNICODE_STRING SubKeyName;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    AppNameMapping = (PINIFILE_MAPPING_APPNAME)a->IniFileNameMapping->ApplicationNames;
    while (AppNameMapping != NULL) {

        Status = BaseDllAppendStringToResultBuffer( a,
                                                    NULL,
                                                    BASE_READ_REMOTE_STR(AppNameMapping->Name,TempStr),
                                                    TRUE
                                                  );

        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)AppNameMapping->Next;
    }

    AppNameMapping = (PINIFILE_MAPPING_APPNAME)a->IniFileNameMapping->DefaultAppNameMapping;
    if (AppNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping,
                                       NULL,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        Status = NtEnumerateKey( Key,
                                 SubKeyIndex,
                                 KeyBasicInformation,
                                 KeyInformation,
                                 sizeof( Buffer ),
                                 &ResultLength
                               );

        if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        }

        if (NT_SUCCESS( Status )) {
            SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
            SubKeyName.Length = (USHORT)KeyInformation->NameLength;
            SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;
            Status = BaseDllCheckKeyNotEmpty( Key,
                                              &SubKeyName
                                            );

            if (NT_SUCCESS( Status ) ) {
                Status = BaseDllAppendStringToResultBuffer( a, NULL, &SubKeyName, TRUE );
            } else
                if (Status != STATUS_NO_MORE_ENTRIES) {
                break;
            } else {
                Status = STATUS_SUCCESS;
            }
        }

        if (!NT_SUCCESS( Status )) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllCheckKeyNotEmpty(
                       IN HANDLE Key,
                       IN PUNICODE_STRING SubKeyName
                       )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SubKey;
    KEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    InitializeObjectAttributes( &ObjectAttributes,
                                SubKeyName,
                                OBJ_CASE_INSENSITIVE,
                                Key,
                                NULL
                              );
    Status = NtOpenKey( &SubKey,
                        GENERIC_READ,
                        &ObjectAttributes
                      );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    Status = NtEnumerateValueKey( SubKey,
                                  0,
                                  KeyValueBasicInformation,
                                  &KeyValueInformation,
                                  sizeof( KeyValueInformation ),
                                  &ResultLength
                                );


    if (Status == STATUS_BUFFER_OVERFLOW) {
        Status = STATUS_SUCCESS;
    }

    NtClose( SubKey );

    return Status;
}

NTSTATUS
BaseDllReadVariableNames(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping
                        )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    PUNICODE_STRING ApplicationNameU;
    WCHAR Buffer[ 256 ];
    PKEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ValueIndex;
    ULONG ResultLength;
    UNICODE_STRING VariableName;
    HANDLE Key;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {

        Status = BaseDllAppendStringToResultBuffer( a,
                                                    NULL,
                                                    BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr),
                                                    TRUE
                                                  );

        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = NtEnumerateValueKey( Key,
                                      ValueIndex,
                                      KeyValueBasicInformation,
                                      KeyValueInformation,
                                      sizeof( Buffer ),
                                      &ResultLength
                                    );
        if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        } else
            if (!NT_SUCCESS( Status )) {
            return Status;
        }

        VariableName.Buffer = KeyValueInformation->Name;
        VariableName.Length = (USHORT)KeyValueInformation->NameLength;
        VariableName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
        Status = BaseDllAppendStringToResultBuffer( a, NULL, &VariableName, TRUE );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllReadVariableValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        )
{
    NTSTATUS Status;
    PUNICODE_STRING ApplicationNameU;
    KEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    PKEY_VALUE_PARTIAL_INFORMATION p;
    ULONG ResultLength;
    UNICODE_STRING Value;
    BOOLEAN OutputVariableName;
    UNICODE_STRING EqualSign;
    PWSTR s;
    HANDLE Key;

    if (ARGUMENT_PRESENT( VariableName )) {
        RtlInitUnicodeString( &EqualSign, L"=" );
        OutputVariableName = TRUE;
    } else {
        if (!BaseDllGetVariableName( a, NULL, &VariableName )) {
            return STATUS_INVALID_PARAMETER;
        }

        OutputVariableName = FALSE;
    }

    if (!ARGUMENT_PRESENT( VarNameMapping )) {
        VarNameMapping = BaseDllFindVarNameMapping( AppNameMapping, VariableName );
    }

    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    Status = NtQueryValueKey( Key,
                              VariableName,
                              KeyValuePartialInformation,
                              &KeyValueInformation,
                              sizeof( KeyValueInformation ),
                              &ResultLength
                            );
    if (!NT_SUCCESS( Status )) {
        if (Status != STATUS_BUFFER_OVERFLOW) {
            return Status;
        }

        p = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), ResultLength );
        if (p == NULL) {
            return STATUS_NO_MEMORY;
        }

        Status = NtQueryValueKey( Key,
                                  VariableName,
                                  KeyValuePartialInformation,
                                  p,
                                  ResultLength,
                                  &ResultLength
                                );
    } else {
        p = &KeyValueInformation;
    }

    if (NT_SUCCESS( Status )) {
        if (p->Type == REG_SZ) {
            if (OutputVariableName) {
                Status = BaseDllAppendStringToResultBuffer( a, NULL, VariableName, FALSE );
                if (NT_SUCCESS( Status )) {
                    Status = BaseDllAppendStringToResultBuffer( a, NULL, &EqualSign, FALSE );
                }
            }

            if (NT_SUCCESS( Status )) {
                Value.Buffer = (PWSTR)&p->Data[ 0 ];
                if (p->DataLength < sizeof( UNICODE_NULL )) {
                    Value.Length = 0;
                } else {
                    Value.Length = (USHORT)(p->DataLength - sizeof( UNICODE_NULL ));
                }
                Value.MaximumLength = (USHORT)(p->DataLength);
                s = (PWSTR)Value.Buffer;
                if (a->Operation == ReadKeyValue &&
                    Value.Length >= (2 * sizeof( WCHAR )) &&
                    (s[ 0 ] == s[ (Value.Length - sizeof( WCHAR )) / sizeof( WCHAR ) ]) &&
                    (s[ 0 ] == L'"' || s[ 0 ] == L'\'')
                   ) {
                    Value.Buffer += 1;
                    Value.Length -= (2 * sizeof( WCHAR ));
                    Value.MaximumLength -= (2 * sizeof( WCHAR ));
                }

                Status = BaseDllAppendStringToResultBuffer( a, NULL, &Value, TRUE );
            }
        } else {
            KdPrint(( "BASE: Registry value %wZ not REG_SZ type (%u)\n", VariableName, p->Type ));
            Status = STATUS_OBJECT_TYPE_MISMATCH;
        }
    }


    if (p != &KeyValueInformation) {
        RtlFreeHeap( RtlProcessHeap(), 0, p );
    }

    return Status;
}


NTSTATUS
BaseDllReadApplicationVariables(
                               IN PINIFILE_PARAMETERS a,
                               IN PINIFILE_MAPPING_APPNAME AppNameMapping
                               )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    PUNICODE_STRING ApplicationNameU;
    WCHAR Buffer[ 256 ];
    PKEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ValueIndex;
    ULONG ResultLength;
    UNICODE_STRING VariableName;
    HANDLE Key;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {
        if (VarNameMapping->Name.Length != 0) {

            Status = BaseDllReadVariableValue( a,
                                               AppNameMapping,
                                               VarNameMapping,
                                               BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr)
                                             );

            if (!NT_SUCCESS( Status )) {
                if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
                    Status == STATUS_OBJECT_TYPE_MISMATCH
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    return Status;
                }
            }
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = NtEnumerateValueKey( Key,
                                      ValueIndex,
                                      KeyValueBasicInformation,
                                      KeyValueInformation,
                                      sizeof( Buffer ),
                                      &ResultLength
                                    );
        if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        } else
            if (!NT_SUCCESS( Status )) {
            return Status;
        }

        VariableName.Buffer = KeyValueInformation->Name;
        VariableName.Length = (USHORT)KeyValueInformation->NameLength;
        VariableName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
        Status = BaseDllReadVariableValue( a, AppNameMapping, NULL, &VariableName );

        if (!NT_SUCCESS( Status ) &&
            Status != STATUS_OBJECT_NAME_NOT_FOUND &&
            Status != STATUS_OBJECT_TYPE_MISMATCH
           ) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllDeleteApplicationVariables(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                 )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    WCHAR Buffer[ 256 ];
    HANDLE Key;
    PKEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    PUNICODE_STRING ApplicationNameU;
    UNICODE_STRING VariableName;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {
        if (VarNameMapping->Name.Length != 0) {

            Status = BaseDllWriteVariableValue( a,
                                                AppNameMapping,
                                                VarNameMapping,
                                                BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr)
                                              );

            if (!NT_SUCCESS( Status )) {
                if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                    return Status;
                }
            }
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       TRUE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    do {
        //
        // Enumerate the 0th key.  Since we are deleting as we go
        // this will always be a new key until we are out of entries.
        //
        Status = NtEnumerateValueKey( Key,
                                      0,
                                      KeyValueBasicInformation,
                                      KeyValueInformation,
                                      sizeof( Buffer ),
                                      &ResultLength
                                    );

        if (NT_SUCCESS( Status )) {
    
            VariableName.Buffer = KeyValueInformation->Name;
            VariableName.Length = (USHORT)KeyValueInformation->NameLength;
            VariableName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
            Status = NtDeleteValueKey( Key,
                                       &VariableName
                                     );
            //
            // If we couldn't find VariableName, then somebody must be deleting
            // at the same time we are and beat us to it, so we just ignore the error.
            //
    
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                Status = STATUS_SUCCESS;
            }
        }

    } while (NT_SUCCESS( Status ));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    //
    // We can't delete key, as if there are handles open to it,
    // future attempts to recreate it will fail.
    //
    // Status = NtDeleteKey( Key );
    //

    BaseDllFlushRegistryCache();

    return Status;
}


NTSTATUS
BaseDllWriteApplicationVariables(
                                IN PINIFILE_PARAMETERS a,
                                IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                )
{
    NTSTATUS Status;
    ULONG n;
    PVOID SaveValueBuffer, NewValueBuffer, CurrentValueBuffer, CurrentVariableStart, FreeBuffer;
    ULONG SaveValueLength, NewValueLength, CurrentValueLength, CurrentVariableLength;

    if (a->Operation == DeleteSection) {
        return BaseDllDeleteApplicationVariables( a, AppNameMapping );
    }

    if (a->ValueBuffer != NULL && a->ValueLength != 0) {
        SaveValueBuffer = a->ValueBuffer;
        SaveValueLength = a->ValueLength;
    } else
        if (a->ValueBufferU != NULL && a->ValueLengthU != 0) {
        SaveValueBuffer = a->ValueBufferU;
        SaveValueLength = a->ValueLengthU;
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    NewValueBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), SaveValueLength );
    if (NewValueBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    FreeBuffer = NULL;
    try {
        RtlMoveMemory( NewValueBuffer, SaveValueBuffer, NewValueLength = SaveValueLength );
        CurrentValueBuffer = NewValueBuffer;
        CurrentValueLength = NewValueLength;
        NewValueLength = 0;
        while (CurrentValueLength) {
            if (a->Unicode) {
                PWSTR s, s1;

                s = CurrentValueBuffer;
                n = CurrentValueLength / sizeof( WCHAR );
                while (n && *s != UNICODE_NULL && *s <= L' ') {
                    n--;
                    s++;
                }
                if (!n || *s == UNICODE_NULL) {

                    break;
                }

                CurrentVariableStart = s;
                a->VariableNameU.Buffer = s;
                while (n && *s != L'=') {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                s1 = s++;
                n--;
                while (s1 > a->VariableNameU.Buffer) {
                    if (s1[-1] > L' ') {
                        break;
                    }
                    s1 -= 1;
                }
                a->VariableNameU.Length = (USHORT)((PCHAR)s1 - (PCHAR)a->VariableNameU.Buffer);
                if (a->VariableNameU.Length == 0) {
                    break;
                }
                a->VariableNameU.MaximumLength = a->VariableNameU.Length + sizeof( UNICODE_NULL );
                while (n && *s == L' ') {
                    n--;
                    s++;
                }

                a->ValueBufferU = s;
                while (n && *s != UNICODE_NULL) {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                a->ValueLengthU = (USHORT)((PCHAR)s - (PCHAR)a->ValueBufferU);
                n--;
                s++;
                CurrentVariableLength = (ULONG)((PCHAR)s - (PCHAR)CurrentVariableStart);
                CurrentValueBuffer = s;
                CurrentValueLength = n * sizeof( WCHAR );
            } else {
                PBYTE s, s1;

                s = CurrentValueBuffer;
                n = CurrentValueLength;
                while (n && *s != '\0' && *s <= ' ') {
                    n--;
                    s++;
                }
                if (!n || *s == '\0') {

                    break;
                }

                CurrentVariableStart = s;
                a->VariableName.Buffer = s;
                while (n && *s != '=') {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                s1 = s++;
                n--;
                while (s1 > a->VariableName.Buffer) {
                    if (s1[-1] > ' ') {
                        break;
                    }
                    s1 -= 1;
                }
                a->VariableName.Length = (USHORT)(s1 - a->VariableName.Buffer);
                if (a->VariableName.Length == 0) {
                    break;
                }
                a->VariableName.MaximumLength = a->VariableName.Length + 1;
                while (n && *s == ' ') {
                    n--;
                    s++;
                }

                a->ValueBuffer = s;
                while (n && *s != '\0') {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                a->ValueLength = (USHORT)(s - a->ValueBuffer);
                n--;
                s++;
                CurrentVariableLength = (ULONG)(s - (PCHAR)CurrentVariableStart);
                CurrentValueBuffer = s;
                CurrentValueLength = n;

                a->VariableNameU.MaximumLength = a->VariableName.MaximumLength * sizeof( WCHAR );
                a->VariableNameU.Length = 0;
                FreeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                              MAKE_TAG( TMP_TAG ),
                                              a->VariableNameU.MaximumLength +
                                              ((a->ValueLength+1) * sizeof( WCHAR ))
                                            );
                if (FreeBuffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                a->VariableNameU.Buffer = FreeBuffer;
                a->ValueBufferU = (PWSTR)((PCHAR)FreeBuffer + a->VariableNameU.MaximumLength );
            }

            Status = BaseDllWriteVariableValue( a, AppNameMapping, NULL, NULL );
            if (FreeBuffer != NULL) {
                RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
                FreeBuffer = NULL;
                RtlInitUnicodeString( &a->VariableNameU, NULL );
                a->ValueBufferU = NULL;
                a->ValueLengthU = 0;
            }

            if (!NT_SUCCESS( Status )) {
                if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                    break;
                } else {
                    RtlMoveMemory( (PCHAR)NewValueBuffer + NewValueLength,
                                   CurrentVariableStart,
                                   CurrentVariableLength
                                 );
                    NewValueLength += CurrentVariableLength;
                    Status = STATUS_SUCCESS;
                }
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
    }

    if (NewValueLength) {
        a->ValueBufferAllocated = TRUE;
        if (a->Unicode) {
            a->ValueBufferU = NewValueBuffer;
            a->ValueLengthU = NewValueLength;
        } else {
            a->ValueBuffer = NewValueBuffer;
            a->ValueLength = NewValueLength;
        }
    } else {
        RtlFreeHeap( RtlProcessHeap(), 0, NewValueBuffer );
    }

    return Status;
}


NTSTATUS
BaseDllWriteVariableValue(
                         IN PINIFILE_PARAMETERS a,
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                         IN PUNICODE_STRING VariableName OPTIONAL
                         )
{
    NTSTATUS Status;
    PUNICODE_STRING ApplicationNameU;
    PWSTR VariableValueU;
    ULONG VariableValueLength;
    HANDLE Key;
    KEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    if (!ARGUMENT_PRESENT( VariableName )) {
        if (!BaseDllGetVariableName( a, NULL, &VariableName )) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (!ARGUMENT_PRESENT( VarNameMapping )) {
        VarNameMapping = BaseDllFindVarNameMapping( AppNameMapping, VariableName );
    }

    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       TRUE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    Status = NtQueryValueKey( Key,
                              VariableName,
                              KeyValueBasicInformation,
                              &KeyValueInformation,
                              sizeof( KeyValueInformation ),
                              &ResultLength
                            );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (KeyValueInformation.Type != REG_SZ) {
            return STATUS_OBJECT_TYPE_MISMATCH;
        }
    }

    if (a->Operation == WriteKeyValue || a->Operation == WriteSection) {
        if (!BaseDllGetVariableValue( a, NULL, &VariableValueU, &VariableValueLength )) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = NtSetValueKey( Key,
                                    VariableName,
                                    0,
                                    REG_SZ,
                                    VariableValueU,
                                    VariableValueLength
                                  );
        }
    } else {
        Status = NtDeleteValueKey( Key,
                                   VariableName
                                 );
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
    }

    if (NT_SUCCESS( Status ) && (VarNameMapping->MappingFlags & INIFILE_MAPPING_WRITE_TO_INIFILE_TOO)) {
#if 0
        DbgPrint( "BASEDLL: WriteToProfileToo for [%wZ] %wZ . %wZ\n",
                  &a->FileName,
                  ApplicationNameU,
                  VariableName
                );
#endif
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        return Status;
    }
}



NTSTATUS
BaseDllReadSectionNames(
                       IN PINIFILE_PARAMETERS a
                       );

NTSTATUS
BaseDllReadKeywordNames(
                       IN PINIFILE_PARAMETERS a
                       );

NTSTATUS
BaseDllReadKeywordValue(
                       IN PINIFILE_PARAMETERS a
                       );

NTSTATUS
BaseDllReadSection(
                  IN PINIFILE_PARAMETERS a
                  );

NTSTATUS
BaseDllWriteSection(
                   IN PINIFILE_PARAMETERS a
                   );

NTSTATUS
BaseDllWriteKeywordValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        );


#define BYTE_ORDER_MARK           0xFEFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE

NTSTATUS
BaseDllReadWriteIniFileOnDisk(
                             IN PINIFILE_PARAMETERS a
                             )
{
    NTSTATUS Status;
    ULONG PartialResultChars;

    if (!a->WriteOperation) {
        PartialResultChars = a->ResultChars;
    }

    Status = BaseDllOpenIniFileOnDisk( a );
    if (NT_SUCCESS( Status )) {
        try {
            a->TextEnd = (PCHAR)a->IniFile->BaseAddress + a->IniFile->EndOfFile;
            a->TextCurrent = a->IniFile->BaseAddress;
            if (a->IniFile->UnicodeFile &&
                ((*(PWCHAR)a->TextCurrent == BYTE_ORDER_MARK) ||
                 (*(PWCHAR)a->TextCurrent == REVERSE_BYTE_ORDER_MARK)))
            {
                // Skip past the BOM.
                ((PWCHAR)a->TextCurrent)++;
            }

            if (a->Operation == ReadSectionNames) {
                Status = BaseDllReadSectionNames( a );
            } else
                if (a->Operation == ReadKeyValue) {
                Status = BaseDllReadKeywordValue( a );
            } else
                if (a->Operation == ReadKeyNames) {
                Status = BaseDllReadKeywordNames( a );
            } else
                if (a->Operation == ReadSection) {
                Status = BaseDllReadSection( a );
            } else
                if (a->Operation == WriteKeyValue || a->Operation == DeleteKey) {
                Status = BaseDllWriteKeywordValue( a, NULL );
            } else
                if (a->Operation == WriteSection || a->Operation == DeleteSection) {
                Status = BaseDllWriteSection( a );
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        finally {
            NTSTATUS CloseStatus;
            CloseStatus = BaseDllCloseIniFileOnDisk( a );
            if (NT_SUCCESS( Status )) {
                Status = CloseStatus;
            }
        }
    }

    if (IsTerminalServer()) {
        // The entry they were looking for wasn't found, see if we need to sync
        // up the ini file
        if (!NT_SUCCESS(Status) && ((a->Operation == ReadSectionNames) ||
                                    (a->Operation == ReadKeyValue) ||
                                    (a->Operation == ReadKeyNames) ||
                                    (a->Operation == ReadSection))) {

            // Sync up the ini file (if necessary), if we updated it, retry the
            // original request
            if (TermsrvSyncUserIniFile(a)) {
                BaseDllReadWriteIniFileOnDisk(a);
            }
        } else if (NT_SUCCESS(Status) && ((a->Operation == WriteKeyValue) ||
                                          (a->Operation == DeleteKey) ||
                                          (a->Operation == WriteSection) ||
                                          (a->Operation == DeleteSection)) &&
                                          TermsrvAppInstallMode()) {
            // Update log of installed files
            if (gpTermsrvLogInstallIniFile) {
                gpTermsrvLogInstallIniFile(&a->NtFileName);
            }
        }
    }


    if (Status == STATUS_OBJECT_NAME_NOT_FOUND &&
        !a->WriteOperation &&
        PartialResultChars != 0
       ) {
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
BaseDllOpenIniFileOnDisk(
                        IN PINIFILE_PARAMETERS a
                        )
{
    NTSTATUS Status;
    UNICODE_STRING FullFileName;
    ULONG n;
    PWSTR FilePart;
    PINIFILE_CACHE IniFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset, Length;

    a->NtFileName.Length = 0;
    if ((a->FileName.Length > sizeof( WCHAR ) &&
         a->FileName.Buffer[ 1 ] == L':'
        ) ||
        (a->FileName.Length != 0 &&
         wcscspn( a->FileName.Buffer, L"\\/" ) != (a->FileName.Length / sizeof( WCHAR ))
        )
       ) {
        n = GetFullPathNameW( a->FileName.Buffer,
                              a->NtFileName.MaximumLength / sizeof( WCHAR ),
                              a->NtFileName.Buffer,
                              &FilePart
                            );
        if (n > a->NtFileName.MaximumLength) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            a->NtFileName.Length = (USHORT)(n * sizeof( WCHAR ));
            Status = STATUS_SUCCESS;
        }

        /*
         * If the base windows directory was specified,
         * redirect to user's directory
         */
        if (gpTermsrvConvertSysRootToUserDir) {
            gpTermsrvConvertSysRootToUserDir( &a->NtFileName, &BaseWindowsDirectory );
        }

    } else {
        //
        // get user based ini file
        //
        if (!gpTermsrvBuildIniFileName ||
             !(NT_SUCCESS(Status = gpTermsrvBuildIniFileName( &a->NtFileName, &a->BaseFileName )))) {

            RtlCopyUnicodeString( &a->NtFileName,
                                  &BaseWindowsDirectory
                                );
            Status = RtlAppendUnicodeToString( &a->NtFileName,
                                               L"\\"
                                             );
            if (NT_SUCCESS( Status )) {
                Status = RtlAppendUnicodeStringToString( &a->NtFileName,
                                                         &a->BaseFileName
                                                       );
            }
        }
    }

    IniFile = NULL;
    if (NT_SUCCESS( Status )) {
        if (RtlDosPathNameToNtPathName_U( a->NtFileName.Buffer,
                                          &FullFileName,
                                          &FilePart,
                                          NULL
                                        )
           ) {
            RtlCopyUnicodeString( &a->NtFileName, &FullFileName );
            RtlFreeUnicodeString( &FullFileName );

            IniFile = RtlAllocateHeap( RtlProcessHeap(),
                                       MAKE_TAG( INI_TAG ) | HEAP_ZERO_MEMORY,
                                       sizeof( *IniFile ) + a->NtFileName.MaximumLength
                                     );
            if (IniFile == NULL) {
                return STATUS_NO_MEMORY;
            }
            IniFile->NtFileName.Buffer = (PWSTR)(IniFile + 1);
            IniFile->NtFileName.MaximumLength = a->NtFileName.MaximumLength;
            RtlCopyUnicodeString( &IniFile->NtFileName, &a->NtFileName );
            IniFile->FileMapping = a->IniFileNameMapping;
            IniFile->WriteAccess = a->WriteOperation;

            if (gpTermsrvCORIniFile) {
                /*
                 * We call a function who handles copy on reference INI files
                 * before attempting the open.
                 */


                gpTermsrvCORIniFile( &IniFile->NtFileName );

            }


            InitializeObjectAttributes( &ObjectAttributes,
                                        &IniFile->NtFileName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );
            if (IniFile->WriteAccess) {
                Status = NtCreateFile( &IniFile->FileHandle,
                                       SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                       &ObjectAttributes,
                                       &IoStatusBlock,
                                       0,
                                       FILE_ATTRIBUTE_NORMAL,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                       FILE_OPEN_IF,
                                       FILE_SYNCHRONOUS_IO_NONALERT |
                                       FILE_NON_DIRECTORY_FILE,
                                       NULL,
                                       0
                                     );
            } else {
                Status = NtOpenFile( &IniFile->FileHandle,
                                     SYNCHRONIZE | GENERIC_READ,
                                     &ObjectAttributes,
                                     &IoStatusBlock,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                     FILE_SYNCHRONOUS_IO_NONALERT |
                                     FILE_NON_DIRECTORY_FILE
                                   );
            }

#if DBG
            if (!NT_SUCCESS( Status )) {
                if (BaseDllDumpIniCalls) {
                    KdPrint(( "BASEDLL: Unable to open %wZ - Status == %x\n", &a->NtFileName, Status ));
                }
            }
#endif // DBG
        } else {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
    }

    if (NT_SUCCESS( Status )) {
        IniFile->LockedFile = FALSE;
        ByteOffset.QuadPart = 0;
        Length.QuadPart = -1;
        Status = NtLockFile( IniFile->FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             &ByteOffset,
                             &Length,
                             LockFileKey,
                             FALSE,
                             IniFile->WriteAccess
                           );
        if (!NT_SUCCESS( Status )) {
            if (Status == STATUS_NOT_SUPPORTED) {
                //
                // Go naked on downlevel servers since they can't do anything useful
                // to help.
                //

                Status = STATUS_SUCCESS;
            }
        } else {
            IniFile->LockedFile = TRUE;
        }

        if (NT_SUCCESS( Status )) {
            Status = NtQueryInformationFile( IniFile->FileHandle,
                                             &IoStatusBlock,
                                             &IniFile->StandardInformation,
                                             sizeof( IniFile->StandardInformation ),
                                             FileStandardInformation
                                           );
            if (Status == STATUS_BUFFER_OVERFLOW) {
                Status = STATUS_SUCCESS;
            } else
                if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: Unable to QueryInformation for %wZ - Status == %x\n", &a->NtFileName, Status ));
            }
        }
    }

    if (!NT_SUCCESS( Status )) {
#if DBG
        if (BaseDllDumpIniCalls) {
            KdPrint(( "BASEDLL: Open of %wZ failed - Status == %x\n",
                      &IniFile->NtFileName,
                      Status
                    ));
        }
#endif // DBG

        if (IniFile != NULL) {
            if (IniFile->LockedFile) {
                ByteOffset.QuadPart = 0;
                Length.QuadPart = -1;
                NtUnlockFile( IniFile->FileHandle,
                              &IoStatusBlock,
                              &ByteOffset,
                              &Length,
                              LockFileKey
                            );
            }

            NtClose( IniFile->FileHandle );
            RtlFreeHeap( RtlProcessHeap(), 0, IniFile );
        }

        return Status;
    }

    IniFile->EndOfFile = IniFile->StandardInformation.EndOfFile.LowPart;
    IniFile->CommitSize = IniFile->EndOfFile + (4 * (IniFile->UnicodeFile ? sizeof( WCHAR ) : 1));
    IniFile->RegionSize = IniFile->CommitSize + 0x100000; // Room for 256KB of growth
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      &IniFile->BaseAddress,
                                      0,
                                      &IniFile->RegionSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
    if (NT_SUCCESS( Status )) {
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &IniFile->BaseAddress,
                                          0,
                                          &IniFile->CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (NT_SUCCESS( Status )) {
            Status = NtReadFile( IniFile->FileHandle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 IniFile->BaseAddress,
                                 IniFile->EndOfFile,
                                 NULL,
                                 &LockFileKey
                               );
            if (NT_SUCCESS( Status ) && IoStatusBlock.Information != IniFile->EndOfFile) {
                Status = STATUS_END_OF_FILE;
            }
        }
    }

    if (NT_SUCCESS( Status )) {
        // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
        INT iResult = ~0x0;
        IniFile->UpdateOffset = 0xFFFFFFFF;
        IniFile->UpdateEndOffset = 0;
        IniFile->UnicodeFile = RtlIsTextUnicode( IniFile->BaseAddress, IniFile->EndOfFile, &iResult );
        if (IniFile->UnicodeFile) {
            PWSTR Src;

            Src = (PWSTR)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            while (Src > (PWSTR)IniFile->BaseAddress && Src[ -1 ] <= L' ') {
                if (Src[-1] == L'\r' || Src[-1] == L'\n') {
                    break;
                }

                IniFile->EndOfFile -= sizeof( WCHAR );
                Src -= 1;
            }

            Src = (PWSTR)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            if (Src > (PWSTR)IniFile->BaseAddress) {
                if (Src[-1] != L'\n') {
                    *Src++ = L'\r';
                    *Src++ = L'\n';
                    IniFile->UpdateOffset = IniFile->EndOfFile;
                    IniFile->UpdateEndOffset = IniFile->UpdateOffset + 2 * sizeof( WCHAR );
                    IniFile->EndOfFile = IniFile->UpdateEndOffset;
                }
            }
        } else {
            PBYTE Src;

            Src = (PBYTE)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            while (Src > (PBYTE)IniFile->BaseAddress && Src[ -1 ] <= ' ') {
                if (Src[-1] == '\r' || Src[-1] == '\n') {
                    break;
                }

                IniFile->EndOfFile -= 1;
                Src -= 1;
            }

            Src = (PBYTE)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            if (Src > (PBYTE)IniFile->BaseAddress) {
                if (Src[-1] != '\n') {
                    *Src++ = '\r';
                    *Src++ = '\n';
                    IniFile->UpdateOffset = IniFile->EndOfFile;
                    IniFile->UpdateEndOffset = IniFile->UpdateOffset + 2;
                    IniFile->EndOfFile = IniFile->UpdateEndOffset;
                }
            }
        }

        a->IniFile = IniFile;
    } else {
        KdPrint(( "BASEDLL: Read of %wZ failed - Status == %x\n",
                  &IniFile->NtFileName,
                  Status
                ));

        if (IniFile->LockedFile) {
            ByteOffset.QuadPart = 0;
            Length.QuadPart = -1;
            NtUnlockFile( IniFile->FileHandle,
                          &IoStatusBlock,
                          &ByteOffset,
                          &Length,
                          LockFileKey
                        );
        }

        NtClose( IniFile->FileHandle );

        RtlFreeHeap( RtlProcessHeap(), 0, IniFile );
    }

    return Status;
}


NTSTATUS
BaseDllCloseIniFileOnDisk(
                         IN PINIFILE_PARAMETERS a
                         )
{
    PINIFILE_CACHE IniFile;
    NTSTATUS Status;
    NTSTATUS CloseStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG UpdateLength;
    LARGE_INTEGER ByteOffset, Length;

    Status = STATUS_SUCCESS;
    IniFile = a->IniFile;
    if (IniFile != NULL) {
        ASSERT( IniFile->FileHandle != NULL );
        if (IniFile->BaseAddress != NULL) {
            if (IniFile->UpdateOffset != 0xFFFFFFFF && IniFile->WriteAccess) {
                ByteOffset.HighPart = 0;
                ByteOffset.LowPart = IniFile->UpdateOffset;
                UpdateLength = IniFile->UpdateEndOffset - IniFile->UpdateOffset;
                Status = NtWriteFile( IniFile->FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      (PCHAR)(IniFile->BaseAddress) + IniFile->UpdateOffset,
                                      UpdateLength,
                                      &ByteOffset,
                                      &LockFileKey
                                    );
                if (NT_SUCCESS( Status )) {
                    if (IoStatusBlock.Information != UpdateLength) {
                        Status = STATUS_DISK_FULL;
                    } else {
                        Length.QuadPart = IniFile->EndOfFile;
                        Status = NtSetInformationFile( IniFile->FileHandle,
                                                       &IoStatusBlock,
                                                       &Length,
                                                       sizeof( Length ),
                                                       FileEndOfFileInformation
                                                     );
                    }
                }

                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: Unable to write changes for %wZ to disk - Status == %x\n",
                              &IniFile->NtFileName,
                              Status
                            ));
                }
            }

            NtFreeVirtualMemory( NtCurrentProcess(),
                                 &IniFile->BaseAddress,
                                 &IniFile->RegionSize,
                                 MEM_RELEASE
                               );
            IniFile->BaseAddress = NULL;
            IniFile->CommitSize = 0;
            IniFile->RegionSize = 0;
        }

        if (IniFile->LockedFile) {
            ByteOffset.QuadPart = 0;
            Length.QuadPart = -1;
            NtUnlockFile( IniFile->FileHandle,
                          &IoStatusBlock,
                          &ByteOffset,
                          &Length,
                          HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)
                        );
        }

        CloseStatus = NtClose( IniFile->FileHandle );
        if (NT_SUCCESS( Status )) {
            Status = CloseStatus;
        }
        IniFile->FileHandle = NULL;

        RtlFreeHeap( RtlProcessHeap(), 0, IniFile );
    }

    return Status;
}


#define STOP_AT_SECTION 1
#define STOP_AT_KEYWORD 2
#define STOP_AT_NONSECTION 3

NTSTATUS
BaseDllFindSection(
                  IN PINIFILE_PARAMETERS a
                  );

NTSTATUS
BaseDllFindKeyword(
                  IN PINIFILE_PARAMETERS a
                  );

NTSTATUS
BaseDllAdvanceTextPointer(
                         IN PINIFILE_PARAMETERS a,
                         IN ULONG StopAt
                         );

NTSTATUS
BaseDllReadSectionNames(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;
    while (NT_SUCCESS( Status )) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_SECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiSectionName,
                                                        a->UnicodeSectionName,
                                                        TRUE
                                                      );
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllReadKeywordNames(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    while (NT_SUCCESS( Status )) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_KEYWORD );
        if (Status == STATUS_MORE_ENTRIES) {
            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiKeywordName,
                                                        a->UnicodeKeywordName,
                                                        TRUE
                                                      );
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllReadKeywordValue(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = BaseDllFindKeyword( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src;

        Src = (PWSTR)a->UnicodeKeywordValue->Buffer;
        while (*Src <= L' ' && a->UnicodeKeywordValue->Length) {
            Src += 1;
            a->UnicodeKeywordValue->Buffer = Src;
            a->UnicodeKeywordValue->Length -= sizeof( WCHAR );
            a->UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
        }

        if (a->UnicodeKeywordValue->Length >= (2 * sizeof( WCHAR )) &&
            (Src[ 0 ] == Src[ (a->UnicodeKeywordValue->Length - sizeof( WCHAR )) / sizeof( WCHAR ) ]) &&
            (Src[ 0 ] == L'"' || Src[ 0 ] == L'\'')
           ) {
            a->UnicodeKeywordValue->Buffer += 1;
            a->UnicodeKeywordValue->Length -= (2 * sizeof( WCHAR ));
            a->UnicodeKeywordValue->MaximumLength -= (2 * sizeof( WCHAR ));
        }
    } else {
        PBYTE Src;

        Src = (PBYTE)a->AnsiKeywordValue->Buffer;
        while (*Src <= ' ' && a->AnsiKeywordValue->Length) {
            Src += 1;
            a->AnsiKeywordValue->Buffer = Src;
            a->AnsiKeywordValue->Length -= sizeof( UCHAR );
            a->AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
        }

        if (a->AnsiKeywordValue->Length >= (2 * sizeof( UCHAR )) &&
            (Src[ 0 ] == Src[ (a->AnsiKeywordValue->Length - sizeof( UCHAR )) / sizeof( UCHAR ) ]) &&
            (Src[ 0 ] == '"' || Src[ 0 ] == '\'')
           ) {
            a->AnsiKeywordValue->Buffer += 1;
            a->AnsiKeywordValue->Length -= (2 * sizeof( UCHAR ));
            a->AnsiKeywordValue->MaximumLength -= (2 * sizeof( UCHAR ));
        }
    }

    return BaseDllAppendStringToResultBuffer( a,
                                              a->AnsiKeywordValue,
                                              a->UnicodeKeywordValue,
                                              TRUE
                                            );
}


NTSTATUS
BaseDllReadSection(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_NONSECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            if (a->AnsiKeywordName || a->UnicodeKeywordName) {
                Status = BaseDllAppendStringToResultBuffer( a,
                                                            a->AnsiKeywordName,
                                                            a->UnicodeKeywordName,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }

                Status = BaseDllAppendBufferToResultBuffer( a,
                                                            a->Unicode ? NULL : "=",
                                                            a->Unicode ? L"=" : NULL,
                                                            1,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }
            }

            if (a->IniFile->UnicodeFile) {
                PWSTR Src;

                Src = (PWSTR)a->UnicodeKeywordValue->Buffer;
                while (*Src <= L' ' && a->UnicodeKeywordValue->Length) {
                    Src += 1;
                    a->UnicodeKeywordValue->Buffer = Src;
                    a->UnicodeKeywordValue->Length -= sizeof( WCHAR );
                    a->UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
                }
            } else {
                PBYTE Src;

                Src = (PBYTE)a->AnsiKeywordValue->Buffer;
                while (*Src <= ' ' && a->AnsiKeywordValue->Length) {
                    Src += 1;
                    a->AnsiKeywordValue->Buffer = Src;
                    a->AnsiKeywordValue->Length -= sizeof( UCHAR );
                    a->AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
                }
            }

            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiKeywordValue,
                                                        a->UnicodeKeywordValue,
                                                        TRUE
                                                      );
            if (!NT_SUCCESS( Status )) {
                return Status;
            }
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllModifyMappedFile(
                       IN PINIFILE_PARAMETERS a,
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       );


NTSTATUS
BaseDllWriteSection(
                   IN PINIFILE_PARAMETERS a
                   )
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    PVOID InsertBuffer;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    PBYTE AnsiKeywordValue, s;
    PWSTR UnicodeKeywordValue, w;
    ULONG ValueLength, SizeToRemove;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteSection) {
            return STATUS_SUCCESS;
        }

        AddressInFile = a->TextEnd;
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        } else {
            if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
        SizeToRemove = 0;
    } else {
        if (a->Operation == DeleteSection) {
            AddressInFile = a->TextStart;
        } else {
            AddressInFile = a->TextCurrent;
        }
        while (TRUE) {
            //
            // For delete operations need to iterate all lines in section,
            // not just those that have an = on them. Otherwise sections like
            // [foo]
            // a
            // b = c
            // d
            //
            // don't get deleted properly.
            //
            Status = BaseDllAdvanceTextPointer(
                                              a,
                                              (a->Operation == DeleteSection) ? STOP_AT_NONSECTION : STOP_AT_KEYWORD
                                              );

            if (Status == STATUS_MORE_ENTRIES) {
            } else
                if (Status == STATUS_NO_MORE_ENTRIES) {
                SizeToRemove = (ULONG)((PCHAR)a->TextCurrent - (PCHAR)AddressInFile);
                break;
            } else {
                return Status;
            }
        }

        InsertSectionName = FALSE;
    }

    if (a->Operation == DeleteSection) {
        InsertBuffer = NULL;
    } else {
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetVariableValue( a, NULL, &UnicodeKeywordValue, &ValueLength )) {
                return STATUS_INVALID_PARAMETER;
            }
            ValueLength -= sizeof( WCHAR );

            //
            // Add in size of value, + \r\n for each line
            //

            w = UnicodeKeywordValue;
            InsertAmount += ValueLength;
            while (*w) {
                while (*w++) {
                }
                InsertAmount += (2-1) * sizeof( WCHAR );    // Subtract out NULL byte already in ValueLength
            }
        } else {
            if (!BaseDllGetVariableValue( a, &AnsiKeywordValue, NULL, &ValueLength )) {
                return STATUS_INVALID_PARAMETER;
            }
            ValueLength -= sizeof( UCHAR );

            //
            // Add in size of value, + \r\n for each line
            //

            s = AnsiKeywordValue;
            InsertAmount += ValueLength;
            while (*s) {
                while (*s++) {
                }
                InsertAmount += 2 - 1;      // Subtract out NULL byte already in ValueLength
            }
        }

        InsertBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), InsertAmount + sizeof( UNICODE_NULL ) );
        if (InsertBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        if (a->IniFile->UnicodeFile) {
            PWSTR Src, Dst;

            Dst = InsertBuffer;
            if (InsertSectionName) {
                *Dst++ = L'[';
                Src = UnicodeSectionName->Buffer;
                n = UnicodeSectionName->Length / sizeof( WCHAR );
                while (n--) {
                    *Dst++ = *Src++;
                }
                *Dst++ = L']';
                *Dst++ = L'\r';
                *Dst++ = L'\n';
            }

            Src = UnicodeKeywordValue;
            while (*Src) {
                while (*Dst = *Src++) {
                    Dst += 1;
                }

                *Dst++ = L'\r';
                *Dst++ = L'\n';
            }
        } else {
            PBYTE Src, Dst;

            Dst = InsertBuffer;
            if (InsertSectionName) {
                *Dst++ = '[';
                Src = AnsiSectionName->Buffer;
                n = AnsiSectionName->Length;
                while (n--) {
                    *Dst++ = *Src++;
                }
                *Dst++ = ']';
                *Dst++ = '\r';
                *Dst++ = '\n';
            }

            Src = AnsiKeywordValue;
            while (*Src) {
                while (*Dst = *Src++) {
                    Dst += 1;
                }

                *Dst++ = '\r';
                *Dst++ = '\n';
            }
        }
    }

    Status = BaseDllModifyMappedFile( a,
                                      AddressInFile,
                                      SizeToRemove,
                                      InsertBuffer,
                                      InsertAmount
                                    );
    RtlFreeHeap( RtlProcessHeap(), 0, InsertBuffer );
    return Status;
}

NTSTATUS
BaseDllCalculateDeleteLength(
                            IN PINIFILE_PARAMETERS a
                            )
{
    ULONG DeleteLength;

    if (a->IniFile->UnicodeFile) {
        DeleteLength = (ULONG)((PCHAR)a->TextCurrent -
                               (PCHAR)a->UnicodeKeywordName->Buffer);
    } else {
        DeleteLength = (ULONG)((PCHAR)a->TextCurrent -
                               a->AnsiKeywordName->Buffer);
    }

    return DeleteLength;
}

NTSTATUS
BaseDllWriteKeywordValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        )
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    BOOLEAN InsertKeywordName;
    PVOID InsertBuffer;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PBYTE AnsiKeywordValue;
    PWSTR UnicodeKeywordValue;
    ULONG ValueLength;
    ULONG DeleteLength;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteKey) {
            return STATUS_SUCCESS;
        }

        AddressInFile = a->TextEnd;
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        } else {
            if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
    } else {
        InsertSectionName = FALSE;
        Status = BaseDllFindKeyword( a );
    }

    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteKey) {
            return STATUS_SUCCESS;
        }

        if (!InsertSectionName) {
            AddressInFile = a->TextCurrent;
        }

        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetVariableName( a, NULL, &UnicodeKeywordName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeKeywordName->Length;
        } else {
            if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiKeywordName->Length;
        }

        InsertKeywordName = TRUE;
    } else {
        if (a->IniFile->UnicodeFile) {
            if (a->Operation == DeleteKey) {
                DeleteLength = BaseDllCalculateDeleteLength( a );
                return BaseDllModifyMappedFile( a,
                                                a->UnicodeKeywordName->Buffer,
                                                DeleteLength,
                                                NULL,
                                                0
                                              );
            } else {
                AddressInFile = a->UnicodeKeywordValue->Buffer;
            }
        } else {
            if (a->Operation == DeleteKey) {
                DeleteLength = BaseDllCalculateDeleteLength( a );
                return BaseDllModifyMappedFile( a,
                                                a->AnsiKeywordName->Buffer,
                                                DeleteLength,
                                                NULL,
                                                0
                                              );
            } else {
                AddressInFile = a->AnsiKeywordValue->Buffer;
            }
        }
        InsertKeywordName = FALSE;
    }

    if (a->IniFile->UnicodeFile) {
        if (!BaseDllGetVariableValue( a, NULL, &UnicodeKeywordValue, &ValueLength )) {
            return STATUS_INVALID_PARAMETER;
        }
        ValueLength -= sizeof( WCHAR );

        if (InsertAmount == 0) {
            return BaseDllModifyMappedFile( a,
                                            a->UnicodeKeywordValue->Buffer,
                                            a->UnicodeKeywordValue->Length,
                                            UnicodeKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    } else {
        if (!BaseDllGetVariableValue( a, &AnsiKeywordValue, NULL, &ValueLength )) {
            return STATUS_INVALID_PARAMETER;
        }
        ValueLength -= sizeof( UCHAR );

        if (InsertAmount == 0) {
            return BaseDllModifyMappedFile( a,
                                            a->AnsiKeywordValue->Buffer,
                                            a->AnsiKeywordValue->Length,
                                            AnsiKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    }

    InsertBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), InsertAmount  + sizeof( UNICODE_NULL ) );
    if (InsertBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src, Dst;

        Dst = InsertBuffer;
        if (InsertSectionName) {
            *Dst++ = L'[';
            Src = UnicodeSectionName->Buffer;
            n = UnicodeSectionName->Length / sizeof( WCHAR );
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = L']';
            *Dst++ = L'\r';
            *Dst++ = L'\n';
        }

        if (InsertKeywordName) {
            Src = UnicodeKeywordName->Buffer;
            n = UnicodeKeywordName->Length / sizeof( WCHAR );
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = L'=';
        }

        Src = UnicodeKeywordValue;
        n = ValueLength / sizeof( WCHAR );
        while (n--) {
            *Dst++ = *Src++;
        }

        if (InsertKeywordName) {
            *Dst++ = L'\r';
            *Dst++ = L'\n';
        }
    } else {
        PBYTE Src, Dst;

        Dst = InsertBuffer;
        if (InsertSectionName) {
            *Dst++ = '[';
            Src = AnsiSectionName->Buffer;
            n = AnsiSectionName->Length;
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = ']';
            *Dst++ = '\r';
            *Dst++ = '\n';
        }

        if (InsertKeywordName) {
            Src = AnsiKeywordName->Buffer;
            n = AnsiKeywordName->Length;
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = '=';
        }

        Src = AnsiKeywordValue;
        n = ValueLength;
        while (n--) {
            *Dst++ = *Src++;
        }

        if (InsertKeywordName) {
            *Dst++ = '\r';
            *Dst++ = '\n';
        }
    }

    Status = BaseDllModifyMappedFile( a,
                                      AddressInFile,
                                      0,
                                      InsertBuffer,
                                      InsertAmount
                                    );
    RtlFreeHeap( RtlProcessHeap(), 0, InsertBuffer );
    return Status;
}


NTSTATUS
BaseDllFindSection(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    BOOL FreeAnsiBuffer;

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_SECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            FreeAnsiBuffer = FALSE;
            if (a->AnsiSectionName) {
                // Ansi ini file -- get the ansi parm
                if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                // Unicode ini file
                if (a->Unicode) {
                    // Unicode parm - we just need the unicode section name...
                    if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                        return STATUS_INVALID_PARAMETER;
                    }
                } else {
                    // ansi parm - convert the unicode section name to ansi
                    if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL ))
                        return STATUS_INVALID_PARAMETER;

                    a->AnsiSectionName = &a->SectionName;
                    Status = RtlUnicodeStringToAnsiString( a->AnsiSectionName,
                                                           a->UnicodeSectionName,
                                                           TRUE
                                                         );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", a->UnicodeSectionName, Status ));
                        return Status;
                    }

                    FreeAnsiBuffer = TRUE;
                }
            }

            if (a->AnsiSectionName == NULL && a->Unicode) {
                if (RtlEqualUnicodeString( UnicodeSectionName,
                                           a->UnicodeSectionName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiSectionName, a->AnsiSectionName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (FreeAnsiBuffer) {
                RtlFreeAnsiString( a->AnsiSectionName );
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS
BaseDllFindKeyword(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeKeywordName;
    BOOL FreeAnsiBuffer;

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_KEYWORD );
        if (Status == STATUS_MORE_ENTRIES) {
            FreeAnsiBuffer = FALSE;

            // Here's the deal.  We don't want to compare in Unicode
            // unless both the ini and the input parm are Unicode,
            // because we want to avoid the round-trip problem (we
            // lose data when we convert Unicode -> Ansi (on disk) ->
            // Unicode; since we don't get back the original Unicode
            // string, lookups of previously stored data fail -- bug
            // 426754).  So if both are Unicode, great! -- use Unicode.
            // Otherwise, use ansi for everything.

            if (a->AnsiKeywordName) {
                // Ansi ini file -- get the ansi parm
                if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                // Unicode ini
                if (a->Unicode) {
                    // Unicode parm - great, get the Unicode parm.
                    if (!BaseDllGetVariableName( a, NULL, &UnicodeKeywordName )) {
                        return STATUS_INVALID_PARAMETER;
                    }
                } else {
                    // Ansi parm - convert the unicode ini keyword to ansi.
                    if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                        return STATUS_INVALID_PARAMETER;
                    }

                    a->AnsiKeywordName = &a->KeywordName;
                    Status = RtlUnicodeStringToAnsiString( a->AnsiKeywordName,
                                                           a->UnicodeKeywordName,
                                                           TRUE
                                                         );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", a->UnicodeKeywordName, Status ));
                        return Status;
                    }

                    FreeAnsiBuffer = TRUE;
                }
            }

            if (a->AnsiKeywordName == NULL && a->Unicode) {
                if (RtlEqualUnicodeString( UnicodeKeywordName,
                                           a->UnicodeKeywordName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiKeywordName, a->AnsiKeywordName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (FreeAnsiBuffer) {
                RtlFreeAnsiString( a->AnsiKeywordName );
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS
BaseDllAdvanceTextPointer(
                         IN PINIFILE_PARAMETERS a,
                         IN ULONG StopAt
                         )
{
    BOOLEAN AllowNoEquals;

    if (StopAt == STOP_AT_NONSECTION) {
        StopAt = STOP_AT_KEYWORD;
        AllowNoEquals = TRUE;
    } else {
        AllowNoEquals = FALSE;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src, EndOfLine, EqualSign, EndOfFile;
        PWSTR Name, EndOfName, Value, EndOfValue;

#define INI_TEXT(quote) L##quote

        Src = a->TextCurrent;
        EndOfFile = a->TextEnd;
        while (Src < EndOfFile) {
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' ')) {
                Src++;
            }

            if (Src >= EndOfFile) {
                a->TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            a->TextStart = Src;
            while (EndOfLine < EndOfFile) {
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('=')) {
                    EqualSign = ++EndOfLine;
                } else
                    if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n')) {
                    if (*EndOfLine == INI_TEXT('\r')) {
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                } else {
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';')) {
                if (*Src == INI_TEXT('[')) {
                    Name = Src + 1;
                    while (Name < EndOfLine && *Name <= INI_TEXT(' ')) {
                        Name++;
                    }
                    EndOfName = Name;
                    while (EndOfName < EndOfLine && *EndOfName != INI_TEXT(']')) {
                        EndOfName++;
                    }

                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                        EndOfName--;
                    }
                    a->SectionNameU.Buffer = Name;
                    a->SectionNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    a->SectionNameU.MaximumLength = a->SectionNameU.Length;
                    a->AnsiSectionName = NULL;
                    a->UnicodeSectionName = &a->SectionNameU;
                    if (StopAt == STOP_AT_SECTION) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    } else
                        if (StopAt == STOP_AT_KEYWORD) {
                        return STATUS_NO_MORE_ENTRIES;
                    }
                } else
                    if (AllowNoEquals || (EqualSign != NULL) ) {

                    if (EqualSign != NULL) {
                        Name = Src;
                        EndOfName = EqualSign - 1;
                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                            EndOfName--;
                        }

                        a->KeywordNameU.Buffer = Name;
                        a->KeywordNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        a->KeywordNameU.MaximumLength = a->KeywordNameU.Length;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = &a->KeywordNameU;

                        Value = EqualSign;
                    } else {
                        Value = Src;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' ')) {
                        EndOfValue--;
                    }
                    a->KeywordValueU.Buffer = Value;
                    a->KeywordValueU.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    a->KeywordValueU.MaximumLength = a->KeywordValueU.Length;
                    a->AnsiKeywordValue = NULL;
                    a->UnicodeKeywordValue = &a->KeywordValueU;
                    if (StopAt == STOP_AT_KEYWORD) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    } else {
        PBYTE Src, EndOfLine, EqualSign, EndOfFile;
        PBYTE Name, EndOfName, Value, EndOfValue;

#undef INI_TEXT
#define INI_TEXT(quote) quote

        Src = a->TextCurrent;
        EndOfFile = a->TextEnd;
        while (Src < EndOfFile) {
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' ')) {
                Src++;
            }

            if (Src >= EndOfFile) {
                a->TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            a->TextStart = Src;
            while (EndOfLine < EndOfFile) {
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('=')) {
                    EqualSign = ++EndOfLine;
                } else
                    if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n')) {
                    if (*EndOfLine == INI_TEXT('\r')) {
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                } else {
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';')) {
                if (*Src == INI_TEXT('[')) {
                    Name = Src + 1;
                    while (Name < EndOfLine && *Name <= INI_TEXT(' ')) {
                        Name++;
                    }
                    EndOfName = Name;
                    while (EndOfName < EndOfLine) {
                        if (*EndOfName == INI_TEXT(']')) {
                            break;
                        }
                        if (IsDBCSLeadByte(*EndOfName)) {
                            EndOfName++;
                        }
                        EndOfName++;
                    }
                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                        EndOfName--;
                    }
                    a->SectionName.Buffer = Name;
                    a->SectionName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    a->SectionName.MaximumLength = a->SectionName.Length;
                    a->AnsiSectionName = &a->SectionName;
                    a->UnicodeSectionName = NULL;
                    if (StopAt == STOP_AT_SECTION) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    } else
                        if (StopAt == STOP_AT_KEYWORD) {
                        return STATUS_NO_MORE_ENTRIES;
                    }
                } else
                    if (AllowNoEquals || (EqualSign != NULL)) {

                    if (EqualSign != NULL) {
                        Name = Src;
                        EndOfName = EqualSign - 1;
                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                            EndOfName--;
                        }

                        a->KeywordName.Buffer = Name;
                        a->KeywordName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        a->KeywordName.MaximumLength = a->KeywordName.Length;
                        a->AnsiKeywordName = &a->KeywordName;
                        a->UnicodeKeywordName = NULL;

                        Value = EqualSign;
                    } else {
                        Value = Src;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' ')) {
                        EndOfValue--;
                    }
                    a->KeywordValue.Buffer = Value;
                    a->KeywordValue.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    a->KeywordValue.MaximumLength = a->KeywordValue.Length;
                    a->AnsiKeywordValue = &a->KeywordValue;
                    a->UnicodeKeywordValue = NULL;
                    if (StopAt == STOP_AT_KEYWORD) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    }

    return STATUS_NO_MORE_ENTRIES;
}


NTSTATUS
BaseDllModifyMappedFile(
                       IN PINIFILE_PARAMETERS a,
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       )
{
    NTSTATUS Status;
    ULONG NewEndOfFile, UpdateOffset, UpdateLength;

    NewEndOfFile = a->IniFile->EndOfFile - SizeToRemove + InsertAmount;
    if (NewEndOfFile > a->IniFile->CommitSize) {
        if (NewEndOfFile > a->IniFile->RegionSize) {
            return STATUS_BUFFER_OVERFLOW;
        }

        a->IniFile->CommitSize = NewEndOfFile;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &a->IniFile->BaseAddress,
                                          0,
                                          &a->IniFile->CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "BASEDLL: Unable to allocate memory to grow %wZ - Status == %x\n",
                      &a->IniFile->NtFileName,
                      Status
                    ));

            return Status;
        }

        a->IniFile->EndOfFile = NewEndOfFile;
    }

    UpdateOffset = (ULONG)((PCHAR)AddressInFile - (PCHAR)(a->IniFile->BaseAddress)),
                   UpdateLength = (ULONG)((PCHAR)a->TextEnd - (PCHAR)AddressInFile) + InsertAmount - SizeToRemove;
    //
    // Are we deleting more than we are inserting?
    //
    if (SizeToRemove > InsertAmount) {
        //
        // Yes copy over insert string.
        //
        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );

        //
        // Delete remaining text after insertion string by moving it
        // up
        //

        RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount,
                       (PCHAR)AddressInFile + SizeToRemove,
                       UpdateLength - InsertAmount
                     );
    } else
        if (InsertAmount > 0) {
        //
        // Are we deleting less than we are inserting?
        //
        if (SizeToRemove < InsertAmount) {
            //
            // Move text down to make room for insertion
            //

            RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount - SizeToRemove,
                           (PCHAR)AddressInFile,
                           UpdateLength - InsertAmount + SizeToRemove
                         );
        } else {
            //
            // Deleting and inserting same amount, update just that text as
            // no shifting was done.
            //

            UpdateLength = InsertAmount;
        }

        //
        // Copy over insert string
        //

        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );
    } else {
        //
        // Nothing to change, as InsertAmount and SizeToRemove are zero
        //
        return STATUS_SUCCESS;
    }

    if (a->IniFile->EndOfFile != NewEndOfFile) {
        a->IniFile->EndOfFile = NewEndOfFile;
    }

    if (UpdateOffset < a->IniFile->UpdateOffset) {
        a->IniFile->UpdateOffset = UpdateOffset;
    }

    if ((UpdateOffset + UpdateLength) > a->IniFile->UpdateEndOffset) {
        a->IniFile->UpdateEndOffset = UpdateOffset + UpdateLength;
    }

    return STATUS_SUCCESS;
}

#if DBG

VOID
BaseDllDumpIniFileMappings(
                          PINIFILE_MAPPING IniFileMapping
                          );

VOID
BaseDllPrintMappingTarget(
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping
                         );

VOID
BaseDllDumpIniFileMappings(
                          PINIFILE_MAPPING IniFileMapping
                          )
{
    PINIFILE_MAPPING_FILENAME FileNameMapping;
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    PINIFILE_MAPPING_VARNAME VarNameMapping;

    DbgPrint( "IniFileMapping\n" );
    FileNameMapping = (PINIFILE_MAPPING_FILENAME)IniFileMapping->DefaultFileNameMapping;
    if (FileNameMapping != NULL) {
        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;
        VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
        DbgPrint( "    " );
        BaseDllPrintMappingTarget( VarNameMapping );
    }

    FileNameMapping = (PINIFILE_MAPPING_FILENAME)IniFileMapping->FileNames;
    while (FileNameMapping) {
        BASE_READ_REMOTE_STR_TEMP(TempStr);

        DbgPrint( "    %wZ\n",
                  BASE_READ_REMOTE_STR(FileNameMapping->Name,TempStr)
                );

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;
        if (AppNameMapping != NULL) {
            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
            DbgPrint( "        " );
            BaseDllPrintMappingTarget( VarNameMapping );
        }

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->ApplicationNames;
        while (AppNameMapping) {
            BASE_READ_REMOTE_STR_TEMP(TempStr);

            DbgPrint( "        %wZ\n",
                      BASE_READ_REMOTE_STR(AppNameMapping->Name,TempStr)
                    );

            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
            if (VarNameMapping != NULL) {
                DbgPrint( "            " );
                BaseDllPrintMappingTarget( VarNameMapping );
            }

            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
            while (VarNameMapping) {
                BASE_READ_REMOTE_STR_TEMP(TempStr);

                DbgPrint( "            %wZ ",
                          BASE_READ_REMOTE_STR(VarNameMapping->Name, TempStr) );

                BaseDllPrintMappingTarget( VarNameMapping );
                VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
            }

            AppNameMapping = (PINIFILE_MAPPING_APPNAME)AppNameMapping->Next;
        }

        FileNameMapping = (PINIFILE_MAPPING_FILENAME)FileNameMapping->Next;
    }

    return;
}


VOID
BaseDllPrintMappingTarget(
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping
                         )
{
    DbgPrint( "= " );

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_WRITE_TO_INIFILE_TOO) {
        DbgPrint( "!" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_INIT_FROM_INIFILE) {
        DbgPrint( "#" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_READ_FROM_REGISTRY_ONLY) {
        DbgPrint( "@" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_USER_RELATIVE) {
        DbgPrint( "USR:" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_SOFTWARE_RELATIVE) {
        DbgPrint( "SYS:" );
    }

    if (VarNameMapping->MappingTarget) {
        BASE_READ_REMOTE_STR_TEMP(TempStr);

        DbgPrint( "%wZ",
                  BASE_READ_REMOTE_STR((((PINIFILE_MAPPING_TARGET)(VarNameMapping->MappingTarget))->RegistryPath), TempStr)
                );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_APPEND_BASE_NAME) {
        DbgPrint( " (Append Base Name)" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_APPEND_APPLICATION_NAME) {
        DbgPrint( " (Append App Name)" );
    }

    DbgPrint( "\n" );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\filefind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filefind.c

Abstract:

    This module implements Win32 FindFirst/FindNext

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"

VOID
WINAPI
BasepIoCompletion(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );

VOID
WINAPI
BasepIoCompletionSimple(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );

#define FIND_BUFFER_SIZE 4096

PFINDFILE_HANDLE
BasepInitializeFindFileHandle(
    IN HANDLE DirectoryHandle
    )
{
    PFINDFILE_HANDLE FindFileHandle;

    FindFileHandle = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( FIND_TAG ), sizeof(*FindFileHandle));
    if ( FindFileHandle ) {
        FindFileHandle->DirectoryHandle = DirectoryHandle;
        FindFileHandle->FindBufferBase = NULL;
        FindFileHandle->FindBufferNext = NULL;
        FindFileHandle->FindBufferLength = 0;
        FindFileHandle->FindBufferValidLength = 0;
        if ( !NT_SUCCESS(RtlInitializeCriticalSection(&FindFileHandle->FindBufferLock)) ){
            RtlFreeHeap(RtlProcessHeap(), 0,FindFileHandle);
            FindFileHandle = NULL;
            }
        }
    return FindFileHandle;
}

HANDLE
APIENTRY
FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    ANSI thunk to FindFirstFileW

--*/

{
    HANDLE ReturnValue;
    PUNICODE_STRING Unicode;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;
    ANSI_STRING AnsiString;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return INVALID_HANDLE_VALUE;
    }
        
    ReturnValue = FindFirstFileExW(
                    (LPCWSTR)Unicode->Buffer,
                    FindExInfoStandard,
                    &FindFileData,
                    FindExSearchNameMatch,
                    NULL,
                    0
                    );

    if ( ReturnValue == INVALID_HANDLE_VALUE ) {
        return ReturnValue;
    }

    RtlCopyMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG_PTR)&FindFileData.cFileName[0] - (ULONG_PTR)&FindFileData
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileData->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileData->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        FindClose(ReturnValue);
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }
    return ReturnValue;
}

HANDLE
APIENTRY
FindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFile.

    This API is provided to open a find file handle and return
    information about the first file whose name match the specified
    pattern.  Once established, the find file handle can be used to
    search for other files that match the same pattern.  When the find
    file handle is no longer needed, it should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Eh), and OS/2's
    DosFindFirst.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file:

        WIN32_FIND_DATA Structure:

        DWORD dwFileAttributes - Returns the file attributes of the found
            file.

        FILETIME ftCreationTime - Returns the time that the file was created.
            A value of 0,0 specifies that the file system containing the
            file does not support this time field.

        FILETIME ftLastAccessTime - Returns the time that the file was last
            accessed.  A value of 0,0 specifies that the file system
            containing the file does not support this time field.

        FILETIME ftLastWriteTime - Returns the time that the file was last
            written.  A file systems support this time field.

        DWORD nFileSizeHigh - Returns the high order 32 bits of the
            file's size.

        DWORD nFileSizeLow - Returns the low order 32-bits of the file's
            size in bytes.

        UCHAR cFileName[MAX_PATH] - Returns the null terminated name of
            the file.

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FindFirstFileExW(
                lpFileName,
                FindExInfoStandard,
                lpFindFileData,
                FindExSearchNameMatch,
                NULL,
                0
                );
}



BOOL
APIENTRY
FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    ANSI thunk to FindFileDataW

--*/

{

    BOOL ReturnValue;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;

    ReturnValue = FindNextFileW(hFindFile,&FindFileData);
    if ( !ReturnValue ) {
        return ReturnValue;
    }
    RtlCopyMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG_PTR)&FindFileData.cFileName[0] - (ULONG_PTR)&FindFileData
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileData->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileData->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return ReturnValue;
}

BOOL
APIENTRY
FindNextFileW(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    Once a successful call has been made to FindFirstFile, subsequent
    matching files can be located using FindNextFile.

    This API is used to continue a file search from a previous call to
    FindFirstFile.  This API returns successfully with the next file
    that matches the search pattern established in the original
    FindFirstFile call.  If no file match can be found NO_MORE_FILES is
    returned.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Fh), and OS/2's
    DosFindNext.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    hFindFile - Supplies a find file handle returned in a previous call
        to FindFirstFile.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFINDFILE_HANDLE FindFileHandle;
    BOOL ReturnValue;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;

    if ( hFindFile == BASE_FIND_FIRST_DEVICE_HANDLE ) {
        BaseSetLastNTError(STATUS_NO_MORE_FILES);
        return FALSE;
    }

    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    ReturnValue = TRUE;
    FindFileHandle = (PFINDFILE_HANDLE)hFindFile;
    RtlEnterCriticalSection(&FindFileHandle->FindBufferLock);
    try {

        //
        // If we haven't called find next yet, then
        // allocate the find buffer.
        //

        if ( !FindFileHandle->FindBufferBase ) {
            FindFileHandle->FindBufferBase = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( FIND_TAG ), FIND_BUFFER_SIZE);
            if (FindFileHandle->FindBufferBase) {
                FindFileHandle->FindBufferNext = FindFileHandle->FindBufferBase;
                FindFileHandle->FindBufferLength = FIND_BUFFER_SIZE;
                FindFileHandle->FindBufferValidLength = 0;
            } else {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                ReturnValue = FALSE;
                goto leavefinally;
            }
        }

        //
        // Test to see if there is no data in the find file buffer
        //

        DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)FindFileHandle->FindBufferNext;
        if ( FindFileHandle->FindBufferBase == (PVOID)DirectoryInfo ) {

            Status = NtQueryDirectoryFile(
                        FindFileHandle->DirectoryHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        DirectoryInfo,
                        FindFileHandle->FindBufferLength,
                        FileBothDirectoryInformation,
                        FALSE,
                        NULL,
                        FALSE
                        );

            //
            //  ***** Do a kludge hack fix for now *****
            //
            //  Forget about the last, partial, entry.
            //

            if ( Status == STATUS_BUFFER_OVERFLOW ) {

                PULONG Ptr;
                PULONG PriorPtr;

                Ptr = (PULONG)DirectoryInfo;
                PriorPtr = NULL;

                while ( *Ptr != 0 ) {

                    PriorPtr = Ptr;
                    Ptr += (*Ptr / sizeof(ULONG));
                }

                if (PriorPtr != NULL) {
                    *PriorPtr = 0;
                }
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = FALSE;
                goto leavefinally;
            }
        }

        if ( DirectoryInfo->NextEntryOffset ) {
            FindFileHandle->FindBufferNext = (PVOID)(
                (PUCHAR)DirectoryInfo + DirectoryInfo->NextEntryOffset);
        } else {
            FindFileHandle->FindBufferNext = FindFileHandle->FindBufferBase;
        }

        //
        // Attributes are composed of the attributes returned by NT.
        //

        lpFindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
        lpFindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
        lpFindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
        lpFindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
        lpFindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
        lpFindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

        RtlCopyMemory( lpFindFileData->cFileName,
                       DirectoryInfo->FileName,
                       DirectoryInfo->FileNameLength );

        lpFindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

        RtlCopyMemory( lpFindFileData->cAlternateFileName,
                       DirectoryInfo->ShortName,
                       DirectoryInfo->ShortNameLength );

        lpFindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

        //
        // For NTFS reparse points we return the reparse point data tag in dwReserved0.
        //

        if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
            lpFindFileData->dwReserved0 = DirectoryInfo->EaSize;
        }

leavefinally:;
    } finally{
        RtlLeaveCriticalSection(&FindFileHandle->FindBufferLock);
    }
    return ReturnValue;
}

BOOL
FindClose(
    HANDLE hFindFile
    )

/*++

Routine Description:

    A find file context created by FindFirstFile can be closed using
    FindClose.

    This API is used to inform the system that a find file handle
    created by FindFirstFile is no longer needed.  On systems that
    maintain internal state for each find file context, this API informs
    the system that this state no longer needs to be maintained.

    Once this call has been made, the hFindFile may not be used in a
    subsequent call to either FindNextFile or FindClose.

    This API has no DOS counterpart, but is similar to OS/2's
    DosFindClose.

Arguments:

    hFindFile - Supplies a find file handle returned in a previous call
        to FindFirstFile that is no longer needed.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PFINDFILE_HANDLE FindFileHandle;
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;

    if ( hFindFile == BASE_FIND_FIRST_DEVICE_HANDLE ) {
        return TRUE;
        }

    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }

    try {

        FindFileHandle = (PFINDFILE_HANDLE)hFindFile;
        RtlEnterCriticalSection(&FindFileHandle->FindBufferLock);
        DirectoryHandle = FindFileHandle->DirectoryHandle;
        FindBufferBase = FindFileHandle->FindBufferBase;
        FindFileHandle->DirectoryHandle = INVALID_HANDLE_VALUE;
        FindFileHandle->FindBufferBase = NULL;
        RtlLeaveCriticalSection(&FindFileHandle->FindBufferLock);

        Status = NtClose(DirectoryHandle);
        if ( NT_SUCCESS(Status) ) {
            if (FindBufferBase) {
                RtlFreeHeap(RtlProcessHeap(), 0,FindBufferBase);
                }
            RtlDeleteCriticalSection(&FindFileHandle->FindBufferLock);
            RtlFreeHeap(RtlProcessHeap(), 0,FindFileHandle);
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        BaseSetLastNTError(GetExceptionCode());
        return FALSE;
        }
    return FALSE;
}

HANDLE
WINAPI
FindFirstFileExA(
    LPCSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    )
{
    HANDLE ReturnValue;
    PUNICODE_STRING Unicode;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;
    LPWIN32_FIND_DATAA lpFindFileDataA;
    ANSI_STRING AnsiString;

    //
    // this code assumes that only FindExInfoStandard is supperted by ExW version
    // when more info levels are added, the W->A translation code needs to be modified
    //

    lpFindFileDataA = (LPWIN32_FIND_DATAA)lpFindFileData;
    
    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return INVALID_HANDLE_VALUE;
    }
        
    ReturnValue = FindFirstFileExW(
                    (LPCWSTR)Unicode->Buffer,
                    fInfoLevelId,
                    (LPVOID)&FindFileData,
                    fSearchOp,
                    lpSearchFilter,
                    dwAdditionalFlags
                    );

    if ( ReturnValue == INVALID_HANDLE_VALUE ) {
        return ReturnValue;
    }

    RtlCopyMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG_PTR)&FindFileData.cFileName[0] - (ULONG_PTR)&FindFileData
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileDataA->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileDataA->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        FindClose(ReturnValue);
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }
    return ReturnValue;

}

HANDLE
WINAPI
FindFirstFileExW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFileEx.

    This API is provided to open a find file handle and return
    information about the first file whose name matchs the specified
    pattern.  If the fSearchOp is FindExSearchNameMatch, then that is
    the extent of the filtering, and lpSearchFilter MUST be NULL.
    Otherwise, additional subfiltering is done depending on this value.

        FindExSearchLimitToDirectories - If this search op is specified,
            then lpSearchFilter MUST be NULL.  For each file that
            matches the specified filename, and that is a directory, and
            entry for that file is returned.

            If the underlying file/io system does not support this type
            of filtering, the API will fail with ERROR_NOT_SUPPORTED,
            and the application will have to perform its own filtering
            by calling this API with FindExSearchNameMatch.

        FindExSearchLimitToDevices - If this search op is specified, the
            lpFileName MUST be *, and FIND_FIRST_EX_CASE_SENSITIVE
            must NOT be specified.  Only device names are returned.
            Device names are generally accessible through
            \\.\name-of-device naming.

    The data returned by this API is dependent on the fInfoLevelId.

        FindExInfoStandard - The lpFindFileData pointer is the standard
            LPWIN32_FIND_DATA structure.

        At this time, no other information levels are supported


    Once established, the find file handle can be used to search for
    other files that match the same pattern with the same filtering
    being performed.  When the find file handle is no longer needed, it
    should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFileEx.

    This API is a complete superset of existing FindFirstFile. FindFirstFile
    could be coded as the following macro:

#define FindFirstFile(a,b)
    FindFirstFileEx((a),FindExInfoStandard,(b),FindExSearchNameMatch,NULL,0);


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    fInfoLevelId - Supplies the info level of the returned data.

    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

    fSearchOp - Specified the type of filtering to perform above and
        beyond simple wildcard matching.

    lpSearchFilter - If the specified fSearchOp needs structured search
        information, this pointer points to the search criteria.  At
        this point in time, both search ops do not require extended
        search information, so this pointer is NULL.

    dwAdditionalFlags - Supplies additional flag values that control the
        search.  A flag value of FIND_FIRST_EX_CASE_SENSITIVE can be
        used to cause case sensitive searches to occur.  The default is
        case insensitive.

Return Value:

    Not -1 - Returns a find first handle that can be used in a
        subsequent call to FindNextFileEx or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

#define FIND_FIRST_EX_INVALID_FLAGS (~FIND_FIRST_EX_CASE_SENSITIVE)
    HANDLE hFindFile;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR Names[MAX_PATH];
        } Buffer;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING UnicodeInput;
    PFINDFILE_HANDLE FindFileHandle;
    BOOLEAN EndsInDot;
    LPWIN32_FIND_DATAW FindFileData;
    BOOLEAN StrippedTrailingSlash;

    //
    // check parameters
    //

    if ( fInfoLevelId >= FindExInfoMaxInfoLevel ||
         fSearchOp >= FindExSearchLimitToDevices ||
        dwAdditionalFlags & FIND_FIRST_EX_INVALID_FLAGS ) {
        SetLastError(fSearchOp == FindExSearchLimitToDevices ? ERROR_NOT_SUPPORTED : ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    FindFileData = (LPWIN32_FIND_DATAW)lpFindFileData;

    RtlInitUnicodeString(&UnicodeInput,lpFileName);

    //
    // Bogus code to workaround ~* problem
    //

    if ( UnicodeInput.Length && UnicodeInput.Buffer[(UnicodeInput.Length>>1)-1] == (WCHAR)'.' ) {
        EndsInDot = TRUE;
    } else {
        EndsInDot = FALSE;
    }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &PathName,
                            &FileName.Buffer,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }

    FreeBuffer = PathName.Buffer;

    //
    //  If there is a a file portion of this name, determine the length
    //  of the name for a subsequent call to NtQueryDirectoryFile.
    //

    if (FileName.Buffer) {
        FileName.Length =
            PathName.Length - (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
    } else {
        FileName.Length = 0;
    }

    FileName.MaximumLength = FileName.Length;
    if ( RelativeName.RelativeName.Length &&
         RelativeName.RelativeName.Buffer != FileName.Buffer ) {

        if (FileName.Buffer) {
            PathName.Length = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)RelativeName.RelativeName.Buffer);
            PathName.MaximumLength = PathName.Length;
            PathName.Buffer = RelativeName.RelativeName.Buffer;
        }

    } else {
        RelativeName.ContainingDirectory = NULL;

        if (FileName.Buffer) {
            PathName.Length = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
            PathName.MaximumLength = PathName.Length;
        }
    }
    if ( (PathName.Length>>1) >= 2 &&
         PathName.Buffer[(PathName.Length>>1)-2] != L':' &&
         PathName.Buffer[(PathName.Length>>1)-1] != L'\\'   ) {

        PathName.Length -= sizeof(UNICODE_NULL);
        StrippedTrailingSlash = TRUE;
    } else {
        StrippedTrailingSlash = FALSE;
    }

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        (dwAdditionalFlags & FIND_FIRST_EX_CASE_SENSITIVE) ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(
                &hFindFile,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( (Status == STATUS_INVALID_PARAMETER ||
          Status == STATUS_NOT_A_DIRECTORY) && StrippedTrailingSlash ) {
        //
        // open of a pnp style path failed, so try putting back the trailing slash
        //
        PathName.Length += sizeof(UNICODE_NULL);
        Status = NtOpenFile(
                    &hFindFile,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );
        PathName.Length -= sizeof(UNICODE_NULL);
    }

    if ( !NT_SUCCESS(Status) ) {
        ULONG DeviceNameData;
        UNICODE_STRING DeviceName;

        RtlReleaseRelativeName(&RelativeName);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

        //
        // The full path does not refer to a directory. This could
        // be a device. Check for a device name.
        //

        if ( DeviceNameData = RtlIsDosDeviceName_U(UnicodeInput.Buffer) ) {
            DeviceName.Length = (USHORT)(DeviceNameData & 0xffff);
            DeviceName.MaximumLength = (USHORT)(DeviceNameData & 0xffff);
            DeviceName.Buffer = (PWSTR)
                ((PUCHAR)UnicodeInput.Buffer + (DeviceNameData >> 16));
            return BaseFindFirstDevice(&DeviceName,FindFileData);
        }

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
        if ( Status == STATUS_OBJECT_TYPE_MISMATCH ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Get an entry
    //

    //
    // If there is no file part, but we are not looking at a device,
    // then bail.
    //

    if ( !FileName.Length ) {
        RtlReleaseRelativeName(&RelativeName);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        NtClose(hFindFile);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }

    DirectoryInfo = &Buffer.DirInfo;

    //
    //  Special case *.* to * since it is so common.  Otherwise transmogrify
    //  the input name according to the following rules:
    //
    //  - Change all ? to DOS_QM
    //  - Change all . followed by ? or * to DOS_DOT
    //  - Change all * followed by a . into DOS_STAR
    //
    //  These transmogrifications are all done in place.
    //

    if ( (FileName.Length == 6) &&
         (RtlCompareMemory(FileName.Buffer, L"*.*", 6) == 6) ) {

        FileName.Length = 2;

    } else {

        ULONG Index;
        WCHAR *NameChar;

        for ( Index = 0, NameChar = FileName.Buffer;
              Index < FileName.Length/sizeof(WCHAR);
              Index += 1, NameChar += 1) {

            if (Index && (*NameChar == L'.') && (*(NameChar - 1) == L'*')) {

                *(NameChar - 1) = DOS_STAR;
            }

            if ((*NameChar == L'?') || (*NameChar == L'*')) {

                if (*NameChar == L'?') { *NameChar = DOS_QM; }

                if (Index && *(NameChar-1) == L'.') { *(NameChar-1) = DOS_DOT; }
            }
        }

        if (EndsInDot && *(NameChar - 1) == L'*') { *(NameChar-1) = DOS_STAR; }
    }

    Status = NtQueryDirectoryFile(
                hFindFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                DirectoryInfo,
                sizeof(Buffer),
                FileBothDirectoryInformation,
                TRUE,
                &FileName,
                FALSE
                );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        NtClose(hFindFile);
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Attributes are composed of the attributes returned by NT.
    //

    FindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
    FindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
    FindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
    FindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
    FindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
    FindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

    RtlCopyMemory( FindFileData->cFileName,
                   DirectoryInfo->FileName,
                   DirectoryInfo->FileNameLength );

    FindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

    RtlCopyMemory( FindFileData->cAlternateFileName,
                   DirectoryInfo->ShortName,
                   DirectoryInfo->ShortNameLength );

    FindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

    //
    // For NTFS reparse points we return the reparse point data tag in dwReserved0.
    //

    if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
        FindFileData->dwReserved0 = DirectoryInfo->EaSize;
    }

    FindFileHandle = BasepInitializeFindFileHandle(hFindFile);
    if ( !FindFileHandle ) {
        NtClose(hFindFile);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
    }

    return (HANDLE)FindFileHandle;

}

HANDLE
BaseFindFirstDevice(
    PCUNICODE_STRING FileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    This function is called when find first file encounters a device
    name. This function returns a successful psuedo file handle and
    fills in the find file data with all zeros and the devic name.

Arguments:

    FileName - Supplies the device name of the file to find.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    Always returns a static find file handle value of
    BASE_FIND_FIRST_DEVICE_HANDLE

--*/

{
    RtlZeroMemory(lpFindFileData,sizeof(*lpFindFileData));
    lpFindFileData->dwFileAttributes = FILE_ATTRIBUTE_ARCHIVE;
    RtlMoveMemory(
        lpFindFileData->cFileName,
        FileName->Buffer,
        (FileName->MaximumLength < sizeof(lpFindFileData->cFileName)
         ? FileName->MaximumLength
         : sizeof(lpFindFileData->cFileName))
        );
    lpFindFileData->cFileName[MAX_PATH - 1] = UNICODE_NULL;
    return BASE_FIND_FIRST_DEVICE_HANDLE;
}

HANDLE
APIENTRY
FindFirstChangeNotificationA(
    LPCSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )

/*++

Routine Description:

    ANSI thunk to FindFirstChangeNotificationW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpPathName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( FindFirstChangeNotificationW(
                (LPCWSTR)Unicode->Buffer,
                bWatchSubtree,
                dwNotifyFilter
                )
            );
}

//
// this is a hack... darrylh, please remove when NT supports null
// buffers to change notify
//

char staticchangebuff[sizeof(FILE_NOTIFY_INFORMATION) + 16];
IO_STATUS_BLOCK staticIoStatusBlock;

HANDLE
APIENTRY
FindFirstChangeNotificationW(
    LPCWSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )

/*++

Routine Description:

    This API is used to create a change notification handle and to set
    up the initial change notification filter conditions.

    If successful, this API returns a waitable notification handle.  A
    wait on a notification handle is successful when a change matching
    the filter conditions occurs in the directory or subtree being
    watched.

    Once a change notification object is created and the initial filter
    conditions are set, the appropriate directory or subtree is
    monitored by the system for changes that match the specified filter
    conditions.  When one of these changes occurs, a change notification
    wait is satisfied.  If a change occurs without an outstanding change
    notification request, it is remembered by the system and will
    satisfy the next change notification wait.

    Note that this means that after a call to
    FindFirstChangeNotification is made, the application should wait on
    the notification handle before making another call to
    FindNextChangeNotification.

Arguments:

    lpPathName - Supplies the pathname of the directory to be watched.
        This path must specify the pathname of a directory.

    bWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the directory tree rooted at the specified
        directory.  A value of FALSE causes the system to monitor only
        the specified directory.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a change notification
        wait.

        FILE_NOTIFY_CHANGE_FILENAME - Any file name changes that occur
            in a directory or subtree being watched will satisfy a
            change notification wait.  This includes renames, creations,
            and deletes.

        FILE_NOTIFY_CHANGE_DIRNAME - Any directory name changes that occur
            in a directory or subtree being watched will satisfy a
            change notification wait.  This includes directory creations
            and deletions.

        FILE_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a directory or subtree being watched will satisfy a
            change notification wait.

        FILE_NOTIFY_CHANGE_SIZE - Any file size changes that occur in a
            directory or subtree being watched will satisfy a change
            notification wait.  File sizes only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.

        FILE_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a directory or subtree being watched will satisfy a
            change notification wait.  Last write time change only cause
            a change when the on disk structure is updated.  For systems
            with extensive caching this may only occur when the system
            cache is sufficiently flushed.

        FILE_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a directory or subtree being watched will
            satisfy a change notification wait.

Return Value:

    Not -1 - Returns a find change notification handle.  The handle is a
        waitable handle.  A wait is satisfied when one of the filter
        conditions occur in a directory or subtree being monitored.  The
        handle may also be used in a subsequent call to
        FindNextChangeNotify and in FindCloseChangeNotify.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpPathName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    //
    // call change notify
    //

    Status = NtNotifyChangeDirectoryFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &staticIoStatusBlock,
                staticchangebuff,   // should be NULL
                sizeof(staticchangebuff),
                dwNotifyFilter,
                (BOOLEAN)bWatchSubtree
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        NtClose(Handle);
        Handle = INVALID_HANDLE_VALUE;
        }
    return Handle;
}

BOOL
APIENTRY
FindNextChangeNotification(
    HANDLE hChangeHandle
    )

/*++

Routine Description:

    This API is used to request that a change notification handle
    be signaled the next time the system dectects an appropriate
    change.

    If a change occurs prior to this call that would otherwise satisfy
    a change request, it is remembered by the system and will satisfy
    this request.

    Once a successful change notification request has been made, the
    application should wait on the change notification handle to
    pick up the change.

    If an application calls this API with a change request outstanding,

        .
        .
        FindNextChangeNotification(h);
        FindNextChangeNotification(h);
        WaitForSingleObject(h,-1);
        .
        .
    it may miss a change notification.

Arguments:

    hChangeHandle - Supplies a change notification handle created
        using FindFirstChangeNotification.

Return Value:

    TRUE - The change notification request was registered. A wait on the
        change handle should be issued to pick up the change notification.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOL ReturnValue;

    ReturnValue = TRUE;
    //
    // call change notify
    //

    Status = NtNotifyChangeDirectoryFile(
                hChangeHandle,
                NULL,
                NULL,
                NULL,
                &staticIoStatusBlock,
                staticchangebuff,           // should be NULL
                sizeof(staticchangebuff),
                FILE_NOTIFY_CHANGE_NAME,    // not needed bug workaround
                TRUE                        // not needed bug workaround
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }
    return ReturnValue;
}




BOOL
APIENTRY
FindCloseChangeNotification(
    HANDLE hChangeHandle
    )

/*++

Routine Description:

    This API is used close a change notification handle and to tell the
    system to stop monitoring changes on the notification handle.

Arguments:

    hChangeHandle - Supplies a change notification handle created
        using FindFirstChangeNotification.

Return Value:

    TRUE - The change notification handle was closed.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return CloseHandle(hChangeHandle);
}

BOOL
WINAPI
ReadDirectoryChangesW(
    HANDLE hDirectory,
    LPVOID lpBuffer,
    DWORD nBufferLength,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    This rountine allows you to read changes that occur in a directory
    or a tree rooted at the specified directory.  It is similar to the
    FindxxxChangeNotification family of APIs, but this API can return
    structured data describing the changes occuring within a directory.

    This API requires the caller to pass in an open directory handle to
    the directory that is to be read.  The handle must be opened with
    FILE_LIST_DIRECTORY acces.  GENERIC_READ includes this and may also
    be used.  The directory may be opened for overlapped access.  This
    technique should be used whenever you call this API asynchronously
    (by specifying and lpOverlapped value).  Opening a directory in
    Win32 is easy.  Use CreateFile, pass in the name of a directory, and
    make sure you specify FILE_FLAG_BACKUP_SEMANTICS.  This will allow
    you to open a directory.  This technique will not force a directory
    to be opened.  It simply allows you to open a directory.  Calling
    this API with a handle to a regular file will fail.

    The following code fragment illustrates how to open a directory using
    CreateFile.

        hDir = CreateFile(
                    DirName,
                    FILE_LIST_DIRECTORY,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS | (fASync ? FILE_FLAG_OVERLAPPED : 0),
                    NULL
                    );

    This API returns it's data in a structured format. The structure is defined by
    the FILE_NOTIFY_INFORMATION structure.

        typedef struct _FILE_NOTIFY_INFORMATION {
            DWORD NextEntryOffset;
            DWORD Action;
            DWORD FileNameLength;
            WCHAR FileName[1];
        } FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;

    The lpBuffer/nBufferLength parameters are used to describe the
    callers buffer to the system.  This API fills in the buffer either
    syncronously or asynchronously depending on how the directory is
    opened and the presence of the lpOverlapped parameter.

    Upon successful I/O completion, a formated buffer, and number of
    bytes transfered into the buffer is available to the caller.  If the
    number of bytes transfered is 0, this means that the system was
    unable to provide detailed information on all of the changes that
    occured in the directory or tree.  The application should manually
    compute this information by enumerating the directory or tree.
    Otherwise, structured data is returned to the caller.

    Each record contains:

        NextEntryOffest - This is the number of bytes to be skipped to get
            to the next record. A value of 0 indicates that this is the last
            record.

        Action - This is used to describe the type of change that occured:

            FILE_ACTION_ADDED - The file was added to the directory

            FILE_ACTION_REMOVED - The file was removed from the
                directory

            FILE_ACTION_MODIFIED - The file was modified (time change,
                attribute change...)

            FILE_ACTION_RENAMED_OLD_NAME - The file was renamed and this
                is the old name.

            FILE_ACTION_RENAMED_NEW_NAME - The file was renamed and this
                is the new name.

        FileNameLength - This is the length in bytes of the file name portion
            of this record. Note that the file name is NOT null terminated. This
            length does not include a trailing NULL.

        FileName - This variable length portion of the recorn contains a file name
            relative to the directory handle. The name is in the UNICODE character
            format and is NOT NULL terminated.

    The caller of this API can specify a filter that describes to sort
    of changes that should trigger a read completion on thie directory.
    The first call to this API on a directory establishes the filter to
    be used for that call and all subsequent calls.

    The caller can also tell the system to watch for changes in the
    directory, or the entire subtree under the directory.  Again, the
    first call to this API establishes this condition.

    This call can complete either synchronously or asynchronously.

    For synchronous completion, the directory should be opened without
    the FILE_FLAG_OVERLAPPED flag.  The I/O will complete when the
    callers buffer either fills up or overflows.  When this condition
    occurs, the caller may parse the returned buffer.  If the
    *lpBytesReturned value is 0, this means that the buffer was too
    small to hold all of the changes, and the caller will have to
    manually enumerate the directory or tree.

    For asynchronous completion, the directory should be opened with the
    FILE_FLAG_OVERLAPPED flag, and an lpOverlapped parameter must be
    specified.  I/O completion is returned to the caller via
    GetOverlappedResult(), GetQueuedCompletionStatus(), or via an I/O
    completion callback.

    To receive notification via GetOverlappedResult(), DO NOT specify an
    lpCompletionRoutine.  Set the hEvent field of the overlapped
    structure to an hEvent unique to this I/O operation. Pick up your I/O completion
    using GetOverlappedResult().

    To receive notification via GetQueuedCompletionSTatus(), DO NOT
    specify an lpCompletionRoutine.  Associate the directory handle with
    a completion port using CreateIoCompletionPort().  Pick up your I/O
    completion using GetQueuedCompletionStatus().  To disable a
    completion packet from being used on an associated directory, set
    the low order bit of the hEvent in the lpOverlapped structure and
    use GetOverlappedResult().

    To receive notification via an I/O completion callback, DO NOT
    associate the directory with a completion port.  Specify an
    lpCompletionRoutine.  This function will be called whenever an
    outstanding I/O completes while you are in an alertable wait.  If an
    I/O completes, but you are not waiting, the I/O notification stays
    pending and will occur when you wait.  Only the thread that issues
    the I/O is notified. The hEvent field of the overlapped structure is not
    used by the system and may be used by the caller.

Arguments:

    hDirectory - SUpplies an open handle to a directory to be watched.
        The directory must be opened with FILE_LIST_DIRECTORY access.

    lpBuffer - Supplies the address of a buffer that will be used to return the
        results of the read. The format of this buffer is described above.

    nBufferLength - Supplies the length of the buffer.

    bWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the directory tree rooted at the specified
        directory.  A value of FALSE causes the system to monitor only
        the specified directory.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a read.

        FILE_NOTIFY_CHANGE_FILENAME - Any file name changes that occur
            in a directory or subtree being watched will satisfy a read.
            This includes renames, creations, and deletes.

        FILE_NOTIFY_CHANGE_DIRNAME - Any directory name changes that
            occur in a directory or subtree being watched will satisfy a
            read.  This includes directory creations and deletions.

        FILE_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a directory or subtree being watched will satisfy a
            read.

        FILE_NOTIFY_CHANGE_SIZE - Any file size changes that occur in a
            directory or subtree being watched will satisfy a read.
            File sizes only cause a change when the on disk structure is
            updated.  For systems with extensive caching this may only
            occur when the system cache is sufficiently flushed.

        FILE_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a directory or subtree being watched will satisfy a
            read.  Last write time change only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.


        FILE_NOTIFY_CHANGE_LAST_ACCESS - Any last access time changes that
            occur in a directory or subtree being watched will satisfy a
            read.  Last access time change only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.


        FILE_NOTIFY_CHANGE_CREATION - Any creation time changes that
            occur in a directory or subtree being watched will satisfy a
            read.  Last creation time change only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.

        FILE_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a directory or subtree being watched will
            satisfy a read.

    lpBytesReturned - For synchronous calls, this returns the number of
        bytes transfered into the buffer.  A successful call coupled
        with a value of 0 means that the buffer was too small, and the
        caller must manually enumerate the directory/tree.  For
        asynchronous calls, this value is undefined.  The system does
        not attempt to store anything here.  The caller must use an
        asynchronous notification technique to pick up I/O completion
        and number of bytes transfered.

    lpOverlapped - Supplies an overlapped structure to be used in
        conjunction with asynchronous I/O completion notification.  The
        offset fields of this structure are not used.  Using this on a
        directory that was not opened with FILE_FLAG_OVERLAPPED is
        undefined.


    lpCompletionRoutine - Supplies the address of a completion routine
        that is called when this I/O completes, AND the thread that
        issues the I/O enters an alertable wait.  The threads wait will
        be interrupted with a return code of WAIT_IO_COMPLETION, and
        this I/O completion routine will be called.  The routine is
        passed the error code of the operation, the number of bytes
        transfered, and the address of the lpOverlapped structure used
        in the call.  An error will occur if this parameter is specified
        on a directory handle that is associated with a completion port.

Return Value:

    TRUE - For synchronous calls, the operation succeeded.
        lpBytesReturned is the number of bytes transferred into your
        buffer.  A value of 0 means that your buffer was too small to
        hold all of the changes that occured and that you need to
        enumerate the directory yourself to see the changes.  For
        asyncronous calls, the operation was queued successfully.
        Results will be delivered using asynch I/O notification
        (GetOverlappedResult(), GetQueuedCompletionStatus(), or your
        completion callback routine).

    FALSE - An error occured. GetLastError() can be used to obtain detailed
        error status.

--*/

{
    NTSTATUS Status;
    BOOL ReturnValue;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Event;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;

    ReturnValue = TRUE;

    if ( ARGUMENT_PRESENT(lpOverlapped) ) {

        if ( ARGUMENT_PRESENT(lpCompletionRoutine) ) {

            //
            // completion is via APC routine
            //

            Event = NULL;

            Status = BasepAllocateActivationContextActivationBlock(
                BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK |
                BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT,
                lpCompletionRoutine,
                lpOverlapped,
                &ActivationBlock);
            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                return FALSE;
            }

            if (ActivationBlock != NULL) {
                ApcRoutine = &BasepIoCompletion;
                ApcContext = (PVOID) ActivationBlock;
            } else {
                ApcRoutine = &BasepIoCompletionSimple;
                ApcContext = lpCompletionRoutine;
            }
        } else {
            //
            // completion is via completion port or get overlapped result
            //

            Event = lpOverlapped->hEvent;
            ApcRoutine = NULL;
            ApcContext = (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped;
        }

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtNotifyChangeDirectoryFile(
                    hDirectory,
                    Event,
                    ApcRoutine,
                    ApcContext,
                    (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                    lpBuffer,
                    nBufferLength,
                    dwNotifyFilter,
                    (BOOLEAN)bWatchSubtree
                    );

        //
        // Anything other than an error means that I/O completion will
        // occur and caller only gets return data via completion mechanism
        //

        if ( NT_ERROR(Status) ) {
            if (ActivationBlock != NULL)
                BasepFreeActivationContextActivationBlock(ActivationBlock);

            BaseSetLastNTError(Status);
            ReturnValue = FALSE;
            }
        }
    else {
        Status = NtNotifyChangeDirectoryFile(
                    hDirectory,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    lpBuffer,
                    nBufferLength,
                    dwNotifyFilter,
                    (BOOLEAN)bWatchSubtree
                    );
        if ( Status == STATUS_PENDING) {

            //
            // Operation must complete before return & IoStatusBlock destroyed
            //

            Status = NtWaitForSingleObject( hDirectory, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }
        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)IoStatusBlock.Information;
            }
        else {
            BaseSetLastNTError(Status);
            ReturnValue = FALSE;
            }
        }

    return ReturnValue;

}

HANDLE
WINAPI
FindFirstStreamW(
    LPCWSTR lpFileName,
    STREAM_INFO_LEVELS InfoLevel,
    LPVOID lpFindStreamData,
    DWORD dwFlags
    )
/*++

Routine Description:

    This routine starts the enumeration of a file for substreams. All files contain
    a default data stream. On ntfs they can also contain named data streams.  Note:
    for fat we'll return unimplemented.  
    
    We'll return a standard FINDFILE_HANDLE with the real data embedded in the back of it.

Arguments:

    lpFileName - Supplies the file name of the file to enumerate streams in
    
    InfoLevel - Currently only FindStreamInfoStandard is supported 
    
    lpFindStreamData -  Buffer than returns back info the first stream dependent on the infolevel
    
        for FindStreamInfoStandard
        
        typedef struct _WIN32_FIND_STREAM_DATA {
            
            LARGE_INTEGER StreamSize;                  <---  the stream size
            WCHAR cStreamName[MAX_PATH + 36];          <---  stream name - there is enough space here
                                                             for 2 colons an attribute type name and a stream name and a null
        
        } WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA; 
    
    
    dwFlags -  Reserved for future use must be 0 for now
    

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    BYTE * Buffer = NULL;
    INT BufferSize = sizeof( FILE_STREAM_INFORMATION ); //  arbitrary starting point
    INT Index = 0;
    PFILE_STREAM_INFORMATION StreamInfo;
    HANDLE File = NULL;
    OBJECT_ATTRIBUTES Oa;
    UNICODE_STRING FileName;
    PFINDFILE_HANDLE FindFileHandle = NULL;
    PWIN32_FIND_STREAM_DATA FindStreamData = (PWIN32_FIND_STREAM_DATA)lpFindStreamData; 

    //
    //  Validate the parameters
    //  

    if (InfoLevel != FindStreamInfoStandard) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return INVALID_HANDLE_VALUE;
    }

    //
    //  Open the file specified
    //  

    RtlDosPathNameToNtPathName_U( lpFileName, &FileName, NULL, NULL );
    InitializeObjectAttributes( &Oa, &FileName, OBJ_CASE_INSENSITIVE, NULL, NULL );
    
    try {

        Status = NtCreateFile( &File,
                               FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                               &Oa,
                               &Iosb,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                               NULL,
                               0 );

        if (STATUS_SUCCESS != Status) {
            leave;
        }


        FindFileHandle = BasepInitializeFindFileHandle( File );
        if (!FindFileHandle) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        //
        //  The file handle now belongs the the  filefind handle
        //  

        File = NULL;

        //
        //  Figure out how large to really make the buffer
        //  

        do {

            if (Buffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
            }
            Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, BufferSize );
            if (!Buffer) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }

            Status = NtQueryInformationFile( FindFileHandle->DirectoryHandle, &Iosb, Buffer, BufferSize, FileStreamInformation );
            BufferSize *=2;

        } while (STATUS_BUFFER_OVERFLOW == Status);

        if (STATUS_SUCCESS != Status) {
            leave;
        }

        //
        //  Check if there are no results
        //  

        if (Iosb.Information == 0) {

            Status = STATUS_END_OF_FILE;
            leave;
        }

        //
        //  Setup the filefind handle we're going to return and null out the buffer
        //  which we've given ownership to the handle for
        // 

        FindFileHandle->FindBufferBase = Buffer;
        FindFileHandle->FindBufferLength = (ULONG)Iosb.Information;
        FindFileHandle->FindBufferValidLength = (ULONG)Iosb.Information;

        Buffer = NULL;
        
        //
        //  Transfer the first result into the output buffer
        //  Note if there is not enough space in the cStreamName field we'll just AV
        //  the string size is bounded by max attribute name (255) + 2 colons + 36 chars for the type and a null == 291
        // 
        //

        StreamInfo = (PFILE_STREAM_INFORMATION)FindFileHandle->FindBufferBase;

        FindStreamData->StreamSize.QuadPart = StreamInfo->StreamSize.QuadPart;
        RtlCopyMemory( FindStreamData->cStreamName, StreamInfo->StreamName, StreamInfo->StreamNameLength );
        FindStreamData->cStreamName[StreamInfo->StreamNameLength / sizeof( WCHAR )] = L'\0';

        if (StreamInfo->NextEntryOffset > 0) {
            FindFileHandle->FindBufferNext = (PCHAR)FindFileHandle->FindBufferBase + StreamInfo->NextEntryOffset;
        } else {
            FindFileHandle->FindBufferNext = (PCHAR)FindFileHandle->FindBufferBase + Iosb.Information;
        }

    } finally {

        //
        //  Always cleanup the allocated nt name. On failure also cleanup handles 
        //  and any allocations
        //

        if (FileName.Length) {
            RtlFreeHeap( RtlProcessHeap(), 0, FileName.Buffer );
        }

        if (STATUS_SUCCESS != Status) {
            BaseSetLastNTError( Status );

            if (File != NULL) {
                NtClose( File );
            }
            if (Buffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
            }
            if (FindFileHandle) {
                FindClose( FindFileHandle );
            }
            FindFileHandle = (PFINDFILE_HANDLE)INVALID_HANDLE_VALUE;
        } 
    }

    return FindFileHandle;
}

BOOL
APIENTRY
FindNextStreamW(
    HANDLE hFindStream,
    LPVOID lpFindStreamData
    )
/*++

Routine Description:

    Once a successful call has been made to FindFirstStream, subsequent
    matching files can be located using FindNextStream.

    This API is used to continue a file search from a previous call to
    FindFirstStream.  This API returns successfully with the next stream
    If no file match can be found HANDLE_EOF is returned.
    
Arguments:

    hFindStream  - handle obtained previously from FindFirstStreamW
    
    lpFindStreamData - appropriate buffer to contain next stream data

Return Value:

    TRUE if more to enumerate
    
    
--*/
{
    PFINDFILE_HANDLE FindFileHandle = (PFINDFILE_HANDLE)hFindStream;
    PWIN32_FIND_STREAM_DATA FindStreamData = (PWIN32_FIND_STREAM_DATA)lpFindStreamData; 
    PFILE_STREAM_INFORMATION StreamInfo;

    //
    //  Check to see if there is anymore data to return
    //  

    if (FindFileHandle->FindBufferNext == (PCHAR)FindFileHandle->FindBufferBase + FindFileHandle->FindBufferLength) {

        BaseSetLastNTError( STATUS_END_OF_FILE );
        return FALSE;
    }

    //
    //  Transfer the next result into the output buffer
    //  Note if there is not enough space in the cStreamName field we'll just AV
    //  the string size is bounded by max attribute name (255) + 2 colons + 32 chars for the type == 292
    // 
    //

    StreamInfo = (PFILE_STREAM_INFORMATION)FindFileHandle->FindBufferNext;

    FindStreamData->StreamSize.QuadPart = StreamInfo->StreamSize.QuadPart;
    RtlCopyMemory( FindStreamData->cStreamName, StreamInfo->StreamName, StreamInfo->StreamNameLength );
    FindStreamData->cStreamName[StreamInfo->StreamNameLength / sizeof( WCHAR )] = L'\0';

    if (StreamInfo->NextEntryOffset > 0) {
        FindFileHandle->FindBufferNext = (PCHAR)FindFileHandle->FindBufferNext + StreamInfo->NextEntryOffset;
    } else {
        FindFileHandle->FindBufferNext = (PCHAR)FindFileHandle->FindBufferBase + FindFileHandle->FindBufferLength;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\dosdev.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dosdev.c

Abstract:

    This file contains the implementation of the DefineDosDevice API

Author:

    Steve Wood (stevewo) 13-Dec-1992

Revision History:

--*/

#include "basedll.h"

#define USHORT_MAX      ((USHORT)(-1))
#define DWORD_MAX       ((DWORD)(-1))
#define CH_COUNT_MAX    ( DWORD_MAX / sizeof( WCHAR ) ) 

BOOL
WINAPI
DefineDosDeviceA(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPCSTR lpTargetPath
    )
{
    NTSTATUS Status;
    BOOL Result;
    ANSI_STRING AnsiString;
    PUNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
    PCWSTR lpDeviceNameW;
    PCWSTR lpTargetPathW;

    RtlInitAnsiString( &AnsiString, lpDeviceName );
    DeviceName = &NtCurrentTeb()->StaticUnicodeString;
    Status = RtlAnsiStringToUnicodeString( DeviceName, &AnsiString, FALSE );
    if (!NT_SUCCESS( Status )) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError( ERROR_FILENAME_EXCED_RANGE );
            }
        else {
            BaseSetLastNTError( Status );
            }
        return FALSE;
        }
    else {
        lpDeviceNameW = DeviceName->Buffer;
        }

    if (ARGUMENT_PRESENT( lpTargetPath )) {
        RtlInitAnsiString( &AnsiString, lpTargetPath );
        Status = RtlAnsiStringToUnicodeString( &TargetPath, &AnsiString, TRUE );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            return FALSE;
            }
        else {
            lpTargetPathW = TargetPath.Buffer;
            }
        }
    else {
        lpTargetPathW = NULL;
        }

    Result = DefineDosDeviceW( dwFlags,
                               lpDeviceNameW,
                               lpTargetPathW
                             );

    if (lpTargetPathW != NULL) {
        RtlFreeUnicodeString( &TargetPath );
        }

    return Result;
}


typedef
long
(WINAPI *PBROADCASTSYSTEMMESSAGEW)( DWORD, LPDWORD, UINT, WPARAM, LPARAM );



BOOL
WINAPI
DefineDosDeviceW(
    DWORD dwFlags,
    PCWSTR lpDeviceName,
    PCWSTR lpTargetPath
    )

/*++

Routine Description:

    This function provides the capability to define new DOS device names or
    redefine or delete existing DOS device names.  DOS Device names are stored
    as symbolic links in the NT object name space.  The code that converts
    a DOS path into a corresponding NT path uses these symbolic links to
    handle mapping of DOS devices and drive letters.  This API provides a
    mechanism for a Win32 Application to modify the symbolic links used
    to implement the DOS Device namespace.  Use the QueryDosDevice API
    to query the current mapping for a DOS device name.

Arguments:

    dwFlags - Supplies additional flags that control the creation
        of the DOS device.

        dwFlags Flags:

        DDD_PUSH_POP_DEFINITION - If lpTargetPath is not NULL, then push
            the new target path in front of any existing target path.
            If lpTargetPath is NULL, then delete the existing target path
            and pop the most recent one pushed.  If nothing left to pop
            then the device name will be deleted.

        DDD_RAW_TARGET_PATH - Do not convert the lpTargetPath string from
            a DOS path to an NT path, but take it as is.

    lpDeviceName - Points to the DOS device name being defined, redefined or deleted.
        It must NOT have a trailing colon unless it is a drive letter being defined,
        redefined or deleted.

    lpTargetPath - Points to the DOS path that will implement this device.  If the
        ADD_RAW_TARGET_PATH flag is specified, then this parameter points to an
        NT path string.  If this parameter is NULL, then the device name is being
        deleted or restored if the ADD_PUSH_POP_DEFINITION flag is specified.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_DEFINEDOSDEVICE_MSG a = (PBASE_DEFINEDOSDEVICE_MSG)&m.u.DefineDosDeviceApi;
    PCSR_CAPTURE_HEADER p;
    ULONG PointerCount, n;
#endif
    UNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
    DWORD iDrive;
    DEV_BROADCAST_VOLUME dbv;
    DWORD dwRec = BSM_APPLICATIONS;
    BOOLEAN LuidDevMapsEnabled = BaseStaticServerData->LUIDDeviceMapsEnabled;

#if defined(BUILD_WOW6432)
    NTSTATUS Status;
#endif

    if (dwFlags & ~(DDD_RAW_TARGET_PATH |
                    DDD_REMOVE_DEFINITION |
                    DDD_EXACT_MATCH_ON_REMOVE |
                    DDD_NO_BROADCAST_SYSTEM |
                    DDD_LUID_BROADCAST_DRIVE
                   ) ||
        ((dwFlags & DDD_EXACT_MATCH_ON_REMOVE) &&
         (!(dwFlags & DDD_REMOVE_DEFINITION))
        ) ||
        ((!ARGUMENT_PRESENT( lpTargetPath )) &&
         (!(dwFlags & (DDD_REMOVE_DEFINITION | DDD_LUID_BROADCAST_DRIVE)))
        ) ||
        ((dwFlags & DDD_LUID_BROADCAST_DRIVE) &&
         ((!ARGUMENT_PRESENT( lpDeviceName )) ||
          ARGUMENT_PRESENT( lpTargetPath ) ||
          (dwFlags & (DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE | DDD_NO_BROADCAST_SYSTEM)) ||
          (LuidDevMapsEnabled == FALSE)
         )
        )
       ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    RtlInitUnicodeString( &DeviceName, lpDeviceName );
#if !defined(BUILD_WOW6432)
    PointerCount = 1;
    n = DeviceName.MaximumLength;
#endif
    if (ARGUMENT_PRESENT( lpTargetPath )) {
        if (!(dwFlags & DDD_RAW_TARGET_PATH)) {
            if (!RtlDosPathNameToNtPathName_U( lpTargetPath,
                                               &TargetPath,
                                               NULL,
                                               NULL
                                             )
               ) {
                BaseSetLastNTError( STATUS_OBJECT_NAME_INVALID );
                return FALSE;
                }
            }
        else {
            RtlInitUnicodeString( &TargetPath, lpTargetPath );
            }
#if !defined(BUILD_WOW6432)
        PointerCount += 1;
        n += TargetPath.MaximumLength;
#endif
        }
    else {
        RtlInitUnicodeString( &TargetPath, NULL );
        }

#if defined(BUILD_WOW6432)    
    Status = CsrBasepDefineDosDevice(dwFlags, &DeviceName, &TargetPath); 

    if (TargetPath.Length != 0 && !(dwFlags & DDD_RAW_TARGET_PATH)) {
        RtlFreeUnicodeString( &TargetPath );
    }
#else
    p = CsrAllocateCaptureBuffer( PointerCount, n );
    if (p == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    a->Flags = dwFlags;
    a->DeviceName.MaximumLength =
        (USHORT)CsrAllocateMessagePointer( p,
                                           DeviceName.MaximumLength,
                                           (PVOID *)&a->DeviceName.Buffer
                                         );
    RtlUpcaseUnicodeString( &a->DeviceName, &DeviceName, FALSE );
    if (TargetPath.Length != 0) {
        a->TargetPath.MaximumLength =
            (USHORT)CsrAllocateMessagePointer( p,
                                               TargetPath.MaximumLength,
                                               (PVOID *)&a->TargetPath.Buffer
                                             );
        RtlCopyUnicodeString( &a->TargetPath, &TargetPath );
        if (!(dwFlags & DDD_RAW_TARGET_PATH)) {
            RtlFreeUnicodeString( &TargetPath );
            }
        }
    else {
        RtlInitUnicodeString( &a->TargetPath, NULL );
        }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         p,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepDefineDosDevice
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( p );
#endif

#if defined(BUILD_WOW6432)
    if (NT_SUCCESS( Status )) {
#else
    if (NT_SUCCESS( (NTSTATUS)m.ReturnValue )) {
#endif
        HMODULE hUser32Dll;
        PBROADCASTSYSTEMMESSAGEW pBroadCastSystemMessageW;


        if (!(dwFlags & DDD_NO_BROADCAST_SYSTEM) &&
            DeviceName.Length == (2 * sizeof( WCHAR )) &&
            DeviceName.Buffer[ 1 ] == L':' &&
            (iDrive = RtlUpcaseUnicodeChar( DeviceName.Buffer[ 0 ] ) - L'A') < 26 &&
            LuidDevMapsEnabled == FALSE
           ) {
            dbv.dbcv_size       = sizeof( dbv );
            dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;
            dbv.dbcv_reserved   = 0;
            dbv.dbcv_unitmask   = (1 << iDrive);
            dbv.dbcv_flags      = DBTF_NET;

            hUser32Dll = LoadLibraryW( L"USER32.DLL" );

            if (hUser32Dll != NULL) {
                pBroadCastSystemMessageW = (PBROADCASTSYSTEMMESSAGEW)
                    GetProcAddress( hUser32Dll, "BroadcastSystemMessageW" );

                // broadcast to all windows!
                if (pBroadCastSystemMessageW != NULL) {
                    (*pBroadCastSystemMessageW)( BSF_FORCEIFHUNG |
                                                    BSF_NOHANG |
                                                    BSF_NOTIMEOUTIFNOTHUNG,
                                                 &dwRec,
                                                 WM_DEVICECHANGE,
                                                  (WPARAM)((dwFlags & DDD_REMOVE_DEFINITION) ?
                                                                    DBT_DEVICEREMOVECOMPLETE :
                                                                    DBT_DEVICEARRIVAL
                                                         ),
                                                 (LPARAM)(DEV_BROADCAST_HDR *)&dbv
                                               );
                    }
                }
                FreeLibrary (hUser32Dll);
            }

        return TRUE;
        }
    else {
#if defined(BUILD_WOW6432)
        BaseSetLastNTError( Status );
#else
        BaseSetLastNTError( (NTSTATUS)m.ReturnValue );
#endif
        return FALSE;
        }
}

NTSTATUS
IsGlobalDeviceMap(
    IN HANDLE hDirObject,
    OUT PBOOLEAN pbGlobalDeviceMap
    )

/*++

Routine Description:

    Determine whether a directory object is the global device map

Arguments:

    hDirObject - Supplies a handle to the directory object.

    pbGlobalDeviceMap - Points to a variable that will receive the result of
                        "Is this directory object the global device map?"
                        TRUE - directory object is the global device map
                        FALSE - directory object is not the global device map

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors,
                     the result in pbGlobalDeviceMap is only valid for this
                     status code

    STATUS_INVALID_PARAMETER - pbGlobalDeviceMap or hDirObject is NULL

    STATUS_NO_MEMORY - could not allocate memory to read the directory object's
                       name

    STATUS_INFO_LENGTH_MISMATCH - did not allocate enough memory for the
                                  directory object's name

    STATUS_UNSUCCESSFUL - an unexpected error encountered

--*/
{
    UNICODE_STRING ObjectName;
    UNICODE_STRING GlobalDeviceMapName;
    PWSTR NameBuffer = NULL;
    ULONG ReturnedLength;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if( ( pbGlobalDeviceMap == NULL ) || ( hDirObject == NULL ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    try {
        ObjectName.Length = 0;
        ObjectName.MaximumLength = 0;
        ObjectName.Buffer = NULL;
        ReturnedLength = 0;

        //
        // Determine the length of the directory object's name
        //
        Status = NtQueryObject( hDirObject,
                                ObjectNameInformation,
                                (PVOID) &ObjectName,
                                0,
                                &ReturnedLength
                              );

        if( !NT_SUCCESS( Status ) && (Status != STATUS_INFO_LENGTH_MISMATCH) ) {
            leave;
        }

        //
        // allocate memory for the directory object's name
        //
        NameBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                      MAKE_TAG( TMP_TAG ),
                                      ReturnedLength
                                    );

        if( NameBuffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            leave;
        }

        //
        // get the full name of the directory object
        //
        Status = NtQueryObject( hDirObject,
                                ObjectNameInformation,
                                NameBuffer,
                                ReturnedLength,
                                &ReturnedLength
                              );

        if( !NT_SUCCESS( Status )) {
            leave;
        }

        RtlInitUnicodeString ( &GlobalDeviceMapName, L"\\GLOBAL??" );

        //
        // Check if the directory object is the global device map
        //
        *pbGlobalDeviceMap = RtlEqualUnicodeString( &GlobalDeviceMapName,
                                                    (PUNICODE_STRING)NameBuffer,
                                                    FALSE);

        Status = STATUS_SUCCESS;
    }
    finally {
        if( NameBuffer != NULL ) {
            RtlFreeHeap( RtlProcessHeap(), 0, NameBuffer );
            NameBuffer = NULL;
        }
    }
    return ( Status );
}

DWORD
FindSymbolicLinkEntry(
    IN PWSTR lpKey,
    IN PWSTR lpBuffer,
    IN ULONG nElements,
    OUT PBOOLEAN pbResult
    )
/*++

Routine Description:

    Determine whether a symbolic link's name exists in a buffer of symbolic
    link names.

Arguments:

    lpKey - Points to the symbolic link's name to search for

    lpBuffer - contains symbolic link names, where names are separated by a
                UNICODE_NULL

    nElements - the number of name elements to search

    pbResult - Points to a variable that will receive the result of
                        "Does symbolic link name exist in the buffer?"
                        TRUE - symbolic link name found in the buffer
                        FALSE - symbolic link name not found in the buffer

Return Value:

    NO_ERROR - operations successful, did not encounter any errors,
                     the result in pbResult is only valid for this status code

    ERROR_INVALID_PARAMETER - lpKey, lpBuffer, or pbResult is a NULL pointer

--*/
{
    ULONG i = 0;

    //
    // Check for invalid parameters
    //
    if( (lpKey == NULL) || (lpBuffer == NULL) || (pbResult == NULL) ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Assume the symbolic link's name is not in the buffer
    //
    *pbResult = FALSE;

    //
    // Search for the number of names specified
    //
    while( i < nElements ) {
        if( !wcscmp( lpKey, lpBuffer ) ) {
            //
            // Found the name, can stop searching & pass back the result
            //
            *pbResult = TRUE;
            break;
        }

        i++;

        //
        // Get the next name
        //
        while (*lpBuffer++);
    }
    return( NO_ERROR );
}

DWORD
WINAPI
QueryDosDeviceA(
    LPCSTR lpDeviceName,
    LPSTR lpTargetPath,
    DWORD ucchMax
    )
{
    NTSTATUS Status;
    DWORD Result;
    ANSI_STRING AnsiString;
    PUNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
    PCWSTR lpDeviceNameW;
    PWSTR lpTargetPathW;

    if (ARGUMENT_PRESENT( lpDeviceName )) {
        RtlInitAnsiString( &AnsiString, lpDeviceName );
        DeviceName = &NtCurrentTeb()->StaticUnicodeString;
        Status = RtlAnsiStringToUnicodeString( DeviceName, &AnsiString, FALSE );
        if (!NT_SUCCESS( Status )) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError( ERROR_FILENAME_EXCED_RANGE );
                }
            else {
                BaseSetLastNTError( Status );
                }
            return FALSE;
            }
        else {
            lpDeviceNameW = DeviceName->Buffer;
            }
        }
    else {
        lpDeviceNameW = NULL;
        }

    lpTargetPathW = RtlAllocateHeap( RtlProcessHeap(),
                                     MAKE_TAG( TMP_TAG ),
                                     ucchMax * sizeof( WCHAR )
                                   );
    if (lpTargetPathW == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    Result = QueryDosDeviceW( lpDeviceNameW,
                              lpTargetPathW,
                              ucchMax
                            );

    if (Result != 0) {
        TargetPath.Buffer = lpTargetPathW;
        TargetPath.Length = (USHORT)(Result * sizeof( WCHAR ));
        TargetPath.MaximumLength = (USHORT)(TargetPath.Length + 1);

        AnsiString.Buffer = lpTargetPath;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = (USHORT)ucchMax;

        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &TargetPath,
                                               FALSE
                                             );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Result = 0;
            }
        }

    RtlFreeHeap( RtlProcessHeap(), 0, lpTargetPathW );
    return Result;
}


DWORD
WINAPI
QueryDosDeviceW(
    PCWSTR lpDeviceName,
    PWSTR lpTargetPath,
    DWORD ucchMax
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle = NULL;
    HANDLE LinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN RestartScan;
    UCHAR DirInfoBuffer[ 512 ];
    CLONG Count = 0;
    ULONG Context = 0;
    ULONG ReturnedLength;
    DWORD ucchName, ucchReturned;
    BOOLEAN ScanGlobalDeviceMap = FALSE;
    ULONG nElements = 0;
    BOOLEAN DuplicateEntry;
    PWSTR lpBuffer = lpTargetPath;
    DWORD Result, BufferSize;

    RtlInitUnicodeString( &UnicodeString, L"\\??" );

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return 0;
    }

    ucchReturned = 0;
    try {
        if (ARGUMENT_PRESENT( lpDeviceName )) {
            RtlInitUnicodeString( &UnicodeString, lpDeviceName );
            InitializeObjectAttributes( &Attributes,
                                        &UnicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        DirectoryHandle,
                                        NULL
                                      );
            Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &Attributes
                                             );
            if (NT_SUCCESS( Status )) {
                UnicodeString.Buffer = lpTargetPath;
                UnicodeString.Length = 0;

                //
                // Check for possible overflow of a DWORD
                //
                if (ucchMax > CH_COUNT_MAX) {
                    BufferSize = DWORD_MAX;
                } else {
                    BufferSize = ucchMax * sizeof( WCHAR );
                }

                //
                // Check for possible overflow of a USHORT
                //
                if (BufferSize > (DWORD)(USHORT_MAX)) {
                    UnicodeString.MaximumLength = USHORT_MAX;
                } else {
                    UnicodeString.MaximumLength = (USHORT)(BufferSize);
                }

                ReturnedLength = 0;
                Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                    &UnicodeString,
                                                    &ReturnedLength
                                                  );
                NtClose( LinkHandle );
                if (NT_SUCCESS( Status )) {
                    ucchReturned = ReturnedLength / sizeof( WCHAR );

                    if ( ( (ucchReturned == 0) ||
                           ( (ucchReturned > 0) &&
                             (lpTargetPath[ ucchReturned - 1 ] != UNICODE_NULL)
                           )
                         ) &&
                         (ucchReturned < ucchMax)
                       ) {

                        lpTargetPath[ ucchReturned ] = UNICODE_NULL;
                        ucchReturned++;
                    }

                    if (ucchReturned < ucchMax) {
                        lpTargetPath[ ucchReturned++ ] = UNICODE_NULL;
                    } else {
                        ucchReturned = 0;
                        Status = STATUS_BUFFER_TOO_SMALL;
                    }
                }
            }
        } else {
            //
            // Dump all the symbolic links in the device map's directory
            // With LUID device maps enabled, we must search two directories
            // because the LUID device map is transparent on top of the
            // global device map
            //

            if (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) {
                BOOLEAN GlobalDeviceMap = TRUE;

                //
                // Determine if directory is the global directory
                //
                Status = IsGlobalDeviceMap( DirectoryHandle,
                                            &GlobalDeviceMap );

                //
                // if !global, set second directory search flag
                //
                if( (NT_SUCCESS( Status )) &&
                    (GlobalDeviceMap == FALSE) ) {
                    ScanGlobalDeviceMap = TRUE;
                }
            }

            nElements = 0;
            RestartScan = TRUE;
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer[0];
            while (TRUE) {
                Status = NtQueryDirectoryObject( DirectoryHandle,
                                                 (PVOID)DirInfo,
                                                 sizeof( DirInfoBuffer ),
                                                 TRUE,
                                                 RestartScan,
                                                 &Context,
                                                 &ReturnedLength
                                               );

                //
                //  Check the status of the operation.
                //

                if (!NT_SUCCESS( Status )) {
                    if (Status == STATUS_NO_MORE_ENTRIES) {
                        Status = STATUS_SUCCESS;
                    }

                    break;
                }

                if (!wcscmp( DirInfo->TypeName.Buffer, L"SymbolicLink" )) {
                    ucchName = DirInfo->Name.Length / sizeof( WCHAR );
                    if ((ucchReturned + ucchName + 1 + 1) > ucchMax) {
                        ucchReturned = 0;
                        Status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    RtlCopyMemory( lpTargetPath,
                                   DirInfo->Name.Buffer,
         