((*prCrackedNames)[2].pFormattedName,
                       pTmpDN->StringName,
                       cb - sizeof(WCHAR));
                continue;
            }
        }
    }
}

VOID
ListGlobalCatalogServers(
    THSTATE     *pTHS,
    DWORD       *pcNamesOut,
    CrackedName **prCrackedNames
    )
{
    SEARCHARG   searchArg;
    SEARCHRES   searchRes;
    ENTINFSEL   selection;
    DWORD       options = NTDSDSA_OPT_IS_GC;
    ATTRTYP     objClass = CLASS_NTDS_DSA;
    FILTER      filter[4];
    ENTINFLIST  *pEIL;
    ULONG       len, i, cBytes;
    DSNAME      *px;
    UCHAR       *pVal;
    ULONG       rdnLen;
    ATTRTYP     rdnType;
    WCHAR       rdnVal[MAX_RDN_SIZE];

    CLASSCACHE  *pCC = NULL;
    DSNAME      *tmpDSName = NULL;

    Assert(VALID_THSTATE(pTHS));

    *pcNamesOut = 0;
    *prCrackedNames = NULL;

    // This API is primarily for netlogon to determine which DCs are configured
    // as GCs and which sites they are in.  However, any client which knows
    // the private format values in ntdsapip.h can call it.  The result is
    // packaged as an array of CrackedName with pFormattedName holding the
    // RDN of the site and pDnsDomain holding the dnsHostName of the GC.

    // First find all NTDS-DSA objects which are configured as global catalogs.
    // We do this as a deep search under the Sites container with a filter of
    // (objectClass == NTDS-DSA) && (invocationID present) && (option bit set).
    // We don't need to use objectCategory as invocationID is indexed and is
    // expected to be the most discriminating index referenced.
    //
    // Next note that the hierarchy of objects is:
    //      Sites - Some Site - Servers - Some Server - NTDS-DSA
    // So for each NTDS-DSA object returned by the search, we trim its DN
    // by 1 to get the Server object and read its dnsHostName.  Then we trim
    // the Server DN by 2 to get the Site object and get its RDN.

    // Define search selection.
    memset(&selection, 0, sizeof(selection));
    selection.attSel = EN_ATTSET_LIST;
    selection.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    // Define search filter.
    memset(filter, 0, sizeof(filter));

    if (!(pCC = SCGetClassById(pTHS, objClass))) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_ATT_NOT_DEF_IN_SCHEMA, objClass); 
        return;
    }

    tmpDSName = (DSNAME*)THAlloc(pCC->pDefaultObjCategory->structLen);
    if (!tmpDSName) {
        SetSysErrorEx(ENOMEM, ERROR_NOT_ENOUGH_MEMORY, pCC->pDefaultObjCategory->structLen);
        return;
    }

    memcpy(tmpDSName, 
           pCC->pDefaultObjCategory, 
           pCC->pDefaultObjCategory->structLen);


    // Test for object category.
    filter[3].choice = FILTER_CHOICE_ITEM;
    filter[3].FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter[3].FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    filter[3].FilterTypes.Item.FilTypes.ava.Value.valLen = tmpDSName->structLen;
    filter[3].FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR)tmpDSName;

    // Test for GC bit set.
    filter[2].pNextFilter = &filter[3];
    filter[2].choice = FILTER_CHOICE_ITEM;
    filter[2].FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
    filter[2].FilterTypes.Item.FilTypes.ava.type = ATT_OPTIONS;
    filter[2].FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(DWORD);
    filter[2].FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) &options;

    // Test for presence of invocation ID.
    filter[1].pNextFilter = &filter[2];
    filter[1].choice = FILTER_CHOICE_ITEM;
    filter[1].FilterTypes.Item.choice = FI_CHOICE_PRESENT;
    filter[1].FilterTypes.Item.FilTypes.ava.type = ATT_INVOCATION_ID;

    // Define AND filter.
    filter[0].choice = FILTER_CHOICE_AND;
    filter[0].FilterTypes.And.count = 3;
    filter[0].FilterTypes.And.pFirstFilter = &filter[1];

    // Define various other search arguments.
    memset(&searchArg, 0, sizeof(searchArg));
    InitCommarg(&searchArg.CommArg);
    SetCrackSearchLimits(&searchArg.CommArg);
    searchArg.pObject = gAnchor.pConfigDN;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.pFilter = &filter[0];
    memset(&searchRes, 0, sizeof(searchRes));

    // Find matching objects.
    SearchBody(pTHS, &searchArg, &searchRes, 0);

    if ( pTHS->errCode || (0 == searchRes.count) )
    {
        return;
    }

    // Pre-allocate as though every item in the search result were
    // going to be returned to the caller.

    cBytes = searchRes.count * sizeof(CrackedName);
    *prCrackedNames = (CrackedName *) THAllocEx(pTHS, cBytes);

    for ( pEIL = &searchRes.FirstEntInf, i = 0;
          pEIL && (i < searchRes.count);
          pEIL = pEIL->pNextEntInf, i++ )
    {
        // Strip off one component to get Server name.

        px = (DSNAME *) THAllocEx(pTHS, pEIL->Entinf.pName->structLen);
        len = 0;
        pVal = NULL;

        if (    // Strip one piece off NTDS-DSA to get Server DN.
                !TrimDSNameBy(pEIL->Entinf.pName, 1, px)
                // Position at Server object.
             && !DBFindDSName(pTHS->pDB, px)
                // check LC right on the parent
             && IsObjVisibleBySecurity(pTHS, TRUE)
                // Read dnsHostName off Server object.
             && !GetAttSecure(pTHS, ATT_DNS_HOST_NAME, px, &len, &pVal)
                // Strip three pieces off NTDS-DSA to get Site DN.
             && !TrimDSNameBy(pEIL->Entinf.pName, 3, px)
                // Get RDN value
             && !GetRDNInfo(pTHS, px, rdnVal, &rdnLen, &rdnType) )
        {
            // Re-use px buffer for RDN.  We know it will fit as the RDN
            // is guaranteed to be smaller than the DSNAME it came from.
            (*prCrackedNames)[*pcNamesOut].pFormattedName = (WCHAR *) px;
            memcpy((*prCrackedNames)[*pcNamesOut].pFormattedName, rdnVal,
                   rdnLen * sizeof(WCHAR));
            (*prCrackedNames)[*pcNamesOut].pFormattedName[rdnLen] = L'\0';

            // Re-use pEIL->Entinf.pName buffer for DNS host name.
            if ( (len + sizeof(WCHAR)) < pEIL->Entinf.pName->structLen )
            {
                (*prCrackedNames)[*pcNamesOut].pDnsDomain = (WCHAR *)
                    pEIL->Entinf.pName;
            }
            else
            {
                (*prCrackedNames)[*pcNamesOut].pDnsDomain = (WCHAR *)
                    THReAllocEx(pTHS, pEIL->Entinf.pName, len + sizeof(WCHAR));
            }
            memcpy((*prCrackedNames)[*pcNamesOut].pDnsDomain, pVal, len);
            len /= sizeof(WCHAR);
            (*prCrackedNames)[*pcNamesOut].pDnsDomain[len] = L'\0';

            // If we got to here, all is well.
            (*prCrackedNames)[*pcNamesOut].status = DS_NAME_NO_ERROR;
            (*pcNamesOut) += 1;
        }
        else
        {
            THFreeEx(pTHS, px);
            THFreeEx(pTHS, pEIL->Entinf.pName);
            if ( pVal ) THFreeEx(pTHS, pVal);
        }
    }

    if (tmpDSName) {
        THFreeEx (pTHS, tmpDSName);
    }
}

VOID
ListCrackNames(
    DWORD       dwFlags,
    ULONG       codePage,
    ULONG       localeId,
    DWORD       formatOffered,
    DWORD       formatDesired,
    DWORD       cNames,
    WCHAR       **rpNames,
    DWORD       *pcNamesOut,
    CrackedName **prCrackedNames
    )

/*++

Routine Description:

    Cracks a bunch of names from one format to another.  See external
    prototype and definitions in ntdsapi.h

Arguments:

    dwFlags - flags as defined in ntdsapi.h

    codePage - code page of client.

    localeId - local ID of client.

    formatOffered - identifies DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input name count.

    rpNames - arry of input name WCHAR pointers.

    pcNamesOut - output name count.

    prCrackedNames - pointer to out array of DS_NAME_RESULTW structs.

Return Value:

    None - individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/
{
    THSTATE *pTHS=pTHStls;
    DSNAME  *pNC;
    DWORD   cb;
    DWORD   cc;

    Assert(formatOffered >= DS_NAME_FORMAT_PRIVATE_BEGIN);

    *pcNamesOut = 0;
    *prCrackedNames = NULL;

    switch ( formatOffered )
    {
    case DS_LIST_ROLES:

        ListRoles(pcNamesOut, prCrackedNames);
        break;

    case DS_LIST_SITES:

        ListSites(pTHS, pcNamesOut, prCrackedNames);
        break;

    case DS_LIST_SERVERS_IN_SITE:

        if ( (1 == cNames) && rpNames[0] )
        {
            ListServersInSite(pTHS, rpNames[0], pcNamesOut, prCrackedNames);
        }

        break;

    case DS_LIST_DOMAINS:

        ListDomainsByCrossRef(pTHS, pcNamesOut, prCrackedNames, TRUE);
        break;

    case DS_LIST_NCS:

        ListDomainsByCrossRef(pTHS, pcNamesOut, prCrackedNames, FALSE);
        break;

    case DS_LIST_DOMAINS_IN_SITE:

        if ( (1 == cNames) && rpNames[0] )
        {
            ListDomainsInSite(pTHS, rpNames[0], pcNamesOut, prCrackedNames);
        }

        break;

    case DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE:

        if ( (2 == cNames) && rpNames[0] && rpNames[1] )
        {
            cc = wcslen(rpNames[0]);
            cb = DSNameSizeFromLen(cc);
            pNC = (DSNAME *) THAllocEx(pTHS, cb);
            pNC->structLen = cb;
            pNC->NameLen = cc;
            memcpy(pNC->StringName, rpNames[0], cc * sizeof(WCHAR));

            ListServersForNcInSite( pTHS,
                                    pNC,            // NC
                                    rpNames[1],     // site
                                    pcNamesOut,
                                    prCrackedNames);
        }

        break;

    case DS_LIST_SERVERS_WITH_DCS_IN_SITE:

        if ( (1 == cNames) && (rpNames[0]) )
        {
            // We know every DC holds the config NC, so asking for servers
            // where there exists a child NTDS-DSA which holds the config NC
            // nets us all servers with DCs as well.

            pNC = gAnchor.pConfigDN;

            ListServersForNcInSite( pTHS,
                                    pNC,            // NC
                                    rpNames[0],     // site
                                    pcNamesOut,
                                    prCrackedNames);
        }

        break;

    case DS_LIST_INFO_FOR_SERVER:

        if ( (1 == cNames) && rpNames[0] )
        {
            ListInfoForServer(pTHS,rpNames[0], pcNamesOut, prCrackedNames);
        }

        break;

    case DS_LIST_GLOBAL_CATALOG_SERVERS:

        ListGlobalCatalogServers(pTHS, pcNamesOut, prCrackedNames);
        break;
    }
}

// names for fake guids
CHAR PROPSET_DEFAULT_NAME[] = "Default property set";
int  PROPSET_DEFAULT_NAME_LEN = sizeof(PROPSET_DEFAULT_NAME)-1;
CHAR RIGHT_DS_DUMP_DATABASE_NAME[] = "Dump database";
int  RIGHT_DS_DUMP_DATABASE_NAME_LEN = sizeof(RIGHT_DS_DUMP_DATABASE_NAME)-1;

VOID
SchemaGuidCrackNames(
    DWORD       dwFlags,
    ULONG       codePage,
    ULONG       localeId,
    DWORD       formatOffered,
    DWORD       formatDesired,
    DWORD       cNames,
    WCHAR       **rpNames,
    DWORD       *pcNamesOut,
    CrackedName **prCrackedNames
    )

/*++

  Routine Description:

    Maps a GUID which represents a schema element to a name.
    Caller must have a valid THSTATE and DBPOS so that we can
    search the control rights container.

  Parameters:

    dwFlags - flags as defined in ntdsapi.h

    codePage - code page of client.

    localeId - local ID of client.

    formatOffered - identifies DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input name count.

    rpNames - arry of input name WCHAR pointers.

    pcNamesOut - output name count.

    prCrackedNames - pointer to out array of DS_NAME_RESULTW structs.

  Return Values:

    None.

--*/

{
    THSTATE     *pTHS = pTHStls;

    DECLARESCHEMAPTR

    DWORD       i, iName;
    ATTCACHE    *pAC;
    CLASSCACHE  *pCC;
    int         cChar, cChar1;
    CHAR        *pUTF8;
    int         cUTF8;
    DWORD       *pGuidType;
    PWCHAR      *ppName;
    DWORD       cBytes;
    GUID        testGuid;
    AVA         ava[2];
    ATTR        selectionAttr[2];
    ATTRBLOCK   selection;
    SEARCHRES   searchRes;
    DWORD       dwErr;
    ATTRBLOCK   *pAB;
    CLASSCACHE  *pCCCat;
    ATTCACHE    ac;
    CLASSCACHE  cc;
    PDSNAME     pDsName;
    SYNTAX_INTEGER it;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));

    pDsName = THAllocEx(pTHS, DSNameSizeFromLen(0));
    pDsName->structLen = DSNameSizeFromLen(0);
    
    Assert(DS_MAP_SCHEMA_GUID == formatOffered);
    *pcNamesOut = 0;
    cBytes = cNames * sizeof(CrackedName);
    *prCrackedNames = (CrackedName *) THAllocEx(pTHS, cBytes);

    if (    !(pCCCat = SCGetClassById(pTHS, CLASS_CONTROL_ACCESS_RIGHT))
         || !pCCCat->pDefaultObjCategory )
    {
        return;
    }

    for ( i = 0; i < cNames; i++ )
    {
        (*prCrackedNames)[i].status = DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND;
        (*pcNamesOut)++;
    }

    for ( iName = 0; iName < cNames; iName++ )
    {
        if ( !IsStringGuid(rpNames[iName], &testGuid) )
        {
            continue;
        }

        pUTF8 = NULL;
        cUTF8 = 0;
        pGuidType = &(*prCrackedNames)[iName].status;
        ppName = &(*prCrackedNames)[iName].pFormattedName;

        
        // Expect attributes to be the most common lookup, so do that first.

        memcpy(&ac.propGuid, &testGuid, sizeof(GUID));

        pAC = SCGetAttByPropGuid(pTHS,&ac);

        if (pAC){
            memcpy(&(pDsName->Guid),&pAC->objectGuid,sizeof(GUID));
            if ( !DBFindGuid(pTHS->pDB, pDsName)
                 && IsObjVisibleBySecurity(pTHS,TRUE) ) {
                pUTF8 = pAC->name;
                cUTF8 = pAC->nameLen;
                *pGuidType = DS_NAME_ERROR_SCHEMA_GUID_ATTR;
                goto ConvertFromUTF8;
            }
        }
        
        // try the fake predefined guids
        if (memcmp(&testGuid, &PROPSET_GUID_DEFAULT, sizeof(GUID)) == 0) {
            pUTF8 = PROPSET_DEFAULT_NAME;
            cUTF8 = PROPSET_DEFAULT_NAME_LEN;
            *pGuidType = DS_NAME_ERROR_SCHEMA_GUID_ATTR_SET;
            goto ConvertFromUTF8;
        }
        if (memcmp(&testGuid, &RIGHT_DS_DUMP_DATABASE, sizeof(GUID)) == 0) {
            pUTF8 = RIGHT_DS_DUMP_DATABASE_NAME;
            cUTF8 = RIGHT_DS_DUMP_DATABASE_NAME_LEN;
            *pGuidType = DS_NAME_ERROR_SCHEMA_GUID_CONTROL_RIGHT;
            goto ConvertFromUTF8;
        }


        // Next try class case.
        memcpy(&cc.propGuid,&testGuid, sizeof(GUID));
        
        pCC = SCGetClassByPropGuid(pTHS,&cc);
        
        if (pCC) {
            // make sure the caller has right to read the 
            // schema object
            memcpy(&(pDsName->Guid),&pCC->objectGuid,sizeof(GUID));
            if (!DBFindGuid(pTHS->pDB, pDsName)
                && IsObjVisibleBySecurity(pTHS,TRUE) ) {
                pUTF8 = pCC->name;
                cUTF8 = pCC->nameLen;
                *pGuidType = DS_NAME_ERROR_SCHEMA_GUID_CLASS;
                goto ConvertFromUTF8;
            }
        }

        goto FindControlRight;

ConvertFromUTF8:

        Assert(pUTF8 && cUTF8);
        cChar = MultiByteToWideChar(CP_UTF8, 0, pUTF8, cUTF8, NULL, 0);
        Assert(cChar);
        *ppName = (WCHAR *) THAllocEx(pTHS, (cChar + 1) * sizeof(WCHAR));
        (*ppName)[cChar] = L'\0';
        cChar1 = MultiByteToWideChar(CP_UTF8, 0, pUTF8, cUTF8, *ppName, cChar);
        Assert((cChar == cChar1) && !(*ppName)[cChar]);
        continue;

FindControlRight:

        // Guid was not an attribute, attribute set, or a class.
        // Or it was an attribute set and we want the corresponding right.
        // Try to find a matching control right in the config container.
        // Note that Rights-Guid property is a UNICODE, string-ized GUID
        // without the leading and trailing '{' and '}' characters.

        ava[0].type = ATT_OBJECT_CATEGORY;
        ava[0].Value.valLen = pCCCat->pDefaultObjCategory->structLen;
        ava[0].Value.pVal = (UCHAR *) pCCCat->pDefaultObjCategory;
        ava[1].type = ATT_RIGHTS_GUID;
        ava[1].Value.valLen = (GuidLen - 2) * sizeof(WCHAR);
        ava[1].Value.pVal = (UCHAR *) &rpNames[iName][1];
        selectionAttr[0].attrTyp = ATT_DISPLAY_NAME;
        selectionAttr[0].AttrVal.valCount = 0;
        selectionAttr[0].AttrVal.pAVal = NULL;
        selectionAttr[1].attrTyp = ATT_VALID_ACCESSES;
        selectionAttr[1].AttrVal.valCount = 0;
        selectionAttr[1].AttrVal.pAVal = NULL;
        selection.attrCount = 2;
        selection.pAttr = selectionAttr;

        // Could be more efficient with a one level search in the
        // Extended-Rights container itself.  But we don't have its
        // name and don't want to hard code it here ...

        dwErr = SearchHelper(   gAnchor.pConfigDN,
                                SE_CHOICE_WHOLE_SUBTREE,
                                2,
                                ava,
                                &selection,
                                &searchRes);

        // Return nothing on error, if guid was not found, or if none or more
        // than one matching GUID was found.  We assume that mis-identifying
        // a control right is worse than claiming we can't map it.

        if ( dwErr || (1 != searchRes.count) )
        {
            Assert(dwErr == pTHS->errCode);
            THClearErrors();
            continue;
        }

               
       // Assign name if we got one.

        pAB = &searchRes.FirstEntInf.Entinf.AttrBlock;
        
        for( i=0; i<pAB->attrCount;i++){
            if ((ATT_DISPLAY_NAME == pAB->pAttr[i].attrTyp)
                 && (1 == pAB->pAttr[i].AttrVal.valCount)
                 && (NULL != pAB->pAttr[i].AttrVal.pAVal)
                 && (0 != pAB->pAttr[i].AttrVal.pAVal->valLen)
                 && (NULL != pAB->pAttr[i].AttrVal.pAVal->pVal) )
            {
                *ppName = (WCHAR *) THAllocEx(pTHS,
                                                pAB->pAttr[i].AttrVal.pAVal->valLen
                                              + sizeof(WCHAR));
                memcpy(*ppName,
                       pAB->pAttr[i].AttrVal.pAVal->pVal,
                       pAB->pAttr[i].AttrVal.pAVal->valLen);
                (*ppName)[pAB->pAttr[i].AttrVal.pAVal->valLen / sizeof(WCHAR)] = 0;
            }
            else if ((ATT_VALID_ACCESSES == pAB->pAttr[i].attrTyp)
                 && (1 == pAB->pAttr[i].AttrVal.valCount)
                 && (NULL != pAB->pAttr[i].AttrVal.pAVal)
                 && (0 != pAB->pAttr[i].AttrVal.pAVal->valLen)
                 && (NULL != pAB->pAttr[i].AttrVal.pAVal->pVal) ) {
             
                Assert(sizeof(SYNTAX_INTEGER)==pAB->pAttr[i].AttrVal.pAVal->valLen);

                it = *(SYNTAX_INTEGER*)(pAB->pAttr[i].AttrVal.pAVal->pVal);
             
                if (( (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP) == 
                         (it & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))) {
                    
                    *pGuidType = DS_NAME_ERROR_SCHEMA_GUID_ATTR_SET;
                }
                else if (it & (ACTRL_DS_CONTROL_ACCESS | ACTRL_DS_SELF) ){
                    
                    *pGuidType = DS_NAME_ERROR_SCHEMA_GUID_CONTROL_RIGHT;
                }
            }
        }

        if (*pGuidType==DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND) {
            *ppName = NULL;
        }
    }
    THFreeEx(pTHS,pDsName);
}

BOOL
IsStringGuid(
    WCHAR       *pwszGuid,
    GUID        *pGuid
    )

/*++

  Routine Description:

    Parses a string GUID of the form "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

  Parameters:

    pwszGuid - String version of the GUID to parse.

    pGuid - Filled with binary GUID on successful return.

  Return Values:

    TRUE if a valid string GUID and successfully converted.
    FALSE otherwise.

--*/
{
    int     i;
    WCHAR   c;
    DWORD   b0, b1, b2, b3, b4, b5, b6, b7;

    // Perform syntactic check.  Guid must look like the GuidFormat string
    // above where 'x' represents an alpha-numeric character.

    i = wcslen(pwszGuid);

    if ( GuidLen != i )
    {
        return(FALSE);
    }

    while ( --i > 0 )
    {
        c = pwszGuid[i];

        if ( L'x' == GuidFormat[i] )
        {
            // Corresponding pName character must be in 0-9, a-f, or A-F.

            if ( !( ((c >= L'0') && (c <= L'9')) ||
                    ((c >= L'a') && (c <= L'f')) ||
                    ((c >= L'A') && (c <= L'F')) ) )
            {
                return(FALSE);
            }
        }
        else
        {
            // Corresponding pName character must match GuidFormat exactly.

            if ( GuidFormat[i] != c )
            {
                return(FALSE);
            }
        }
    }

    // Name is a string-ized GUID.  Make a GUID out of it.  Format string
    // only has support for long (l) and short (h) values, so we need to
    // use extra variables for byte fields.


    i = swscanf(
            pwszGuid,
            L"{%08x-%04hx-%04hx-%02x%02x-%02x%02x%02x%02x%02x%02x}",
            &pGuid->Data1, &pGuid->Data2, &pGuid->Data3,
            &b0, &b1, &b2, &b3, &b4, &b5, &b6, &b7);

    Assert(11 == i);
    Assert(    (b0 <= 0xff) && (b1 <= 0xff) && (b2 <= 0xff) && (b3 <= 0xff)
            && (b4 <= 0xff) && (b5 <= 0xff) && (b6 <= 0xff) && (b7 <= 0xff) );

    pGuid->Data4[0] = (UCHAR) b0;
    pGuid->Data4[1] = (UCHAR) b1;
    pGuid->Data4[2] = (UCHAR) b2;
    pGuid->Data4[3] = (UCHAR) b3;
    pGuid->Data4[4] = (UCHAR) b4;
    pGuid->Data4[5] = (UCHAR) b5;
    pGuid->Data4[6] = (UCHAR) b6;
    pGuid->Data4[7] = (UCHAR) b7;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\dominfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dominfo.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements the domain information routines for mapping
    between the DNS, downlevel and DN versions of a domain name.  They 
    often search the Configuration\Partitions container which may not 
    perform well.  This could be optimized in the future by caching the
    ATT_DNS_ROOT, ATT_NETBIOS_NAME and ATT_NC_NAME properties on Cross-Ref
    objects in the gAnchor CR cache and scanning the in-memory structures. 
    
Author:

    Dave Straube (davestr) 8/26/96

Revision History:

    Dave Straube (davestr) 1/21/97
        Modifications to handle multiple domains and Partitions container.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // DSNAME manipulation routines
#include <dsatools.h>                   // Memory, etc.
#include <objids.h>                     // ATT_* definitions
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <filtypes.h>                   // filter types
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dsexcept.h>                   // exception handlers
#include <debug.h>                      // Assert()
#include <anchor.h>                     // DSA_ANCHOR, etc.
#include <dominfo.h>                    // this module's prototypes
#include <ntlsa.h>                      // LSA prototypes & definitions
#include <drameta.h>                   
#include <cracknam.h>

#include <fileno.h>
#define FILENO FILENO_DOMINFO

#define OFFSET(s,m) ((size_t)((BYTE*)&(((s*)0)->m)-(BYTE*)0))

#define DEBSUB "DOMINFO:"

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// NormalizeDnsName()                                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
NormalizeDnsName(
    IN  WCHAR   *pDnsName
    )

/*++

Routine Description:

    Most of the DNS names we deal with in name cracking are absolute
    DNS names - i.e. they have components all the way to the root of
    the DNS name space.  Officially such DNS names should end with a 
    ".".  But in practice, people rarely append the "." character.
    However, we have the dilemma that ATT_DNS_ROOT properties and
    names presented for cracking may or may not have the "." appended.
    This routine "normalizes" a DNS name by stripping the trailing "."
    if it exists.  Note that normalizing the other way, i.e. adding
    the "." if it isn't there is considerable more complex as it would
    require re-allocating with the proper allocator, etc.

    ATT_DNS_ROOT properties may optionally contain colon-delimited
    port numbers at the end.  These get stripped off as well.
    
Arguments:

    pDnsName - pointer to DNS name to normalize.

Return Value:

    None.

--*/
{
    DWORD   len;
    WCHAR   *p;

    if ( NULL != pDnsName )
    {
        if ( p = wcschr(pDnsName, L':') )
        {
            *p = L'\0';
        }

        len = wcslen(pDnsName);

        if ( (len > 0) && (L'.' == pDnsName[len-1]) )
        {
            pDnsName[len-1] = L'\0';
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// ExtractDnsReferral()                                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
ExtractDnsReferral(
    IN  WCHAR   **ppDnsDomain
    )

/*++

Routine Description:

    Extracts a DNS domain referral from the THSTATE and returns it in
    WCHAR, NULL terminated, thread state allocated storage.
    
Arguments:

    ppDnsDomain - Pointer to buffer pointer which is allocated/filled
        on success.
        
Return Value:

    0 on success, !0 otherwise.

--*/

{
    THSTATE         *pTHS=pTHStls;
    UNICODE_STRING  *pstr;
    ULONG           cBytes;

    // Catch logic errors in checked builds.
    Assert(referralError == pTHStls->errCode);

    if ( referralError == pTHStls->errCode )
    {
        // Referral info in THSTATE holds (best) DNS domain we know of
        // for this FQDN.  There may be more than one referral address,
        // but we use only the first one.

        pstr = &pTHStls->pErrInfo->RefErr.Refer.pDAL->Address;

        // pstr now points to a UNICODE_STRING whose length field is bytes.
        // Expect something useful in the DnsName.

        if ( pstr->Length > 0 )
        {
            // Re-alloc with terminating NULL character.  Recall that
            // THAllocEx zeros memory for us.

            cBytes = pstr->Length + sizeof(WCHAR);
            *ppDnsDomain = (WCHAR *) THAllocEx(pTHS, cBytes);
            memcpy(*ppDnsDomain, pstr->Buffer, pstr->Length);
            NormalizeDnsName(*ppDnsDomain);

            return(0);
        }
    }

    return(1);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// ValidatePrefixMatchedDnsName()                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

BOOL
ValidatePrefixMatchedDnsName(
    WCHAR   *pDnsNameToMatch,
    ATTR    *pDnsNameFound
    )
/*++

  Routine Description:

    Because ATT_DNS_ROOT properties on Cross-Ref objects can have port
    information appended (eg: "foo.bar.com:234") we must perform a
    prefix match when searching by DNS name.  This routine verifies
    that there is an exact match.  Without this extra verification,
    ntdev would match ntdev.foobar, ntdev.microsoft.com, ntdevxxx, etc.

    On the other hand, the user may have provided a netbios name.
    Allow that comparison, too.

  Parameters:

    pDnsNameToMatch - Pointer to NULL terminated DNS name being sought.

    pDnsNameFound - Pointer to ATTR of ATT_DNS_ROOT property matched
        by core search.

  Return Values:

    TRUE if the input arguments match
    FALSE otherwise

--*/
{
    THSTATE *pTHS = pTHStls;
    WCHAR   *pTmpMatch;
    WCHAR   *pTmpFound;
    DWORD   cBytes;
    DWORD   ccMatch;
    DWORD   ccFound;
    DWORD   result;

    Assert(   ATT_DNS_ROOT == pDnsNameFound->attrTyp
           || ATT_NETBIOS_NAME == pDnsNameFound->attrTyp);
    Assert(pDnsNameToMatch && wcslen(pDnsNameToMatch));

    if (    (   ATT_DNS_ROOT != pDnsNameFound->attrTyp
             && ATT_NETBIOS_NAME != pDnsNameFound->attrTyp)
         || !pDnsNameFound->AttrVal.valCount
         || !pDnsNameFound->AttrVal.pAVal
         || !pDnsNameFound->AttrVal.pAVal->valLen
         || !pDnsNameFound->AttrVal.pAVal->pVal )
    {
        return(FALSE);
    }

    ccMatch = wcslen(pDnsNameToMatch);
    cBytes = sizeof(WCHAR) * (ccMatch + 1);
    pTmpMatch = (WCHAR *) THAllocEx(pTHS,cBytes);
    memcpy(pTmpMatch, pDnsNameToMatch, cBytes);
    NormalizeDnsName(pTmpMatch);
    cBytes = sizeof(WCHAR) + pDnsNameFound->AttrVal.pAVal->valLen;
    pTmpFound = (WCHAR *) THAllocEx(pTHS,cBytes);
    memcpy(pTmpFound, 
           pDnsNameFound->AttrVal.pAVal->pVal, 
           pDnsNameFound->AttrVal.pAVal->valLen);
    pTmpFound[(cBytes / sizeof(WCHAR)) - 1] = L'\0';
    NormalizeDnsName(pTmpFound);
    ccFound = wcslen(pTmpFound);
    result = CompareStringW(DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            pTmpMatch, ccMatch,
                            pTmpFound, ccFound);
    THFreeEx(pTHS,pTmpMatch);
    THFreeEx(pTHS,pTmpFound);
    return(2 == result);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// PositionAtCrossRefObject()                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
PositionAtCrossRefObject(
    IN  DSNAME      *pNC,
    IN  DWORD       dwRequiredFlags
    )

/*++

Routine Description:

    Moves the current database position to the CrossRef object for
    the desired naming context.  Assumes all NCs, regardless of whether 
    master or read only are also in the gAnchor CR cache.
    
Arguments:

    pNC - Pointer to DSNAME of a naming context whose corresponding Cross-Ref
        object we wish to read.

    dwRequiredFlags - Bits which must be set in the ATT_SYSTEM_FLAGS of
        the matching Cross-Ref object.
        
Return Value:

    0 on success, !0 otherwise.

--*/

{
    DWORD           dwErr = DIRERR_NO_CROSSREF_FOR_NC;
    CROSS_REF      *pCR;
    COMMARG         CommArg;

    InitCommarg(&CommArg);
    SetCrackSearchLimits(&CommArg);

    pCR = FindExactCrossRef(pNC, &CommArg);

    if ( pCR && (dwRequiredFlags == (pCR->flags & dwRequiredFlags)) )
    {
        __try 
        {
            dwErr = DBFindDSName(pTHStls->pDB, pCR->pObj);
        }
        __except (HandleMostExceptions(GetExceptionCode())) 
        {
            dwErr = DIRERR_OBJ_NOT_FOUND;
        }
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// ReadCrossRefProperty()                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
ReadCrossRefPropertySecure(
    IN  DSNAME      *pNC,
    IN  ATTRTYP     attr,
    IN  DWORD       dwRequiredFlags,
    OUT WCHAR       **ppAttrVal
    )

/*++

Routine Description:

    Reads a property off a Cross-Ref object given the name of the NC the 
    Cross-Ref object refers to.  Assumes all NCs, regardless of whether
    master or read only are also in the gAnchor CR cache.
    
Arguments:

    pNC - Pointer to DSNAME of a naming context whose corresponding Cross-Ref
        object we wish to read.
        
    attr - ATTRTYP of attr to read.

    dwRequiredFlags - Bits which must be set in the ATT_SYSTEM_FLAGS of
        the matching Cross-Ref object.
    
    ppAttrVal - Pointer to pointer to THAlloc allocated return value.

Return Value:

    0 on success, !0 otherwise.

--*/

{
    THSTATE         *pTHS=pTHStls;
    DWORD           dwErr;
    ULONG           cbAttr;
    WCHAR           *pbAttr;
    ATTCACHE        *pAC;

    // We only handle ATT_NETBIOS_NAME and ATT_DNS_ROOT which are 
    // UNICODE strings.  Thus no data conversion required.

    Assert((ATT_NETBIOS_NAME == attr) || (ATT_DNS_ROOT == attr));
    Assert((pAC = SCGetAttById(pTHS, attr)) && (SYNTAX_UNICODE_TYPE == pAC->syntax));

    if ( (dwErr = PositionAtCrossRefObject(pNC, dwRequiredFlags)) )
        return(dwErr);

    // We're now positioned at the Cross-Ref object whose NC-Name 
    // property is pNC.  Read the desired attribute.

    dwErr = DBGetAttVal(
                pTHStls->pDB,
                1,                      // get 1 value
                attr,
                0,                      // allocate return data
                0,                      // supplied buffer size
                &cbAttr,                // output data size
                (UCHAR **) &pbAttr);

    if ( (0 != dwErr) || (0 == cbAttr) )
        return(1);

    Assert(0 == (cbAttr % sizeof(WCHAR)));

    // pbAttr is missing NULL terminator.  Allocate room for it
    // and copy data.

    *ppAttrVal = (WCHAR *) THAllocEx(pTHS, cbAttr + sizeof(WCHAR));

    if ( NULL == *ppAttrVal )
        return(1);

    memcpy(*ppAttrVal, pbAttr, cbAttr);
    (*ppAttrVal)[cbAttr / sizeof(WCHAR)] = L'\0';

    if ( ATT_DNS_ROOT == attr )
        NormalizeDnsName(*ppAttrVal);

    return(0);
}

DWORD
ReadCrossRefPropertyNonSecure(
    IN  DSNAME      *pNC,
    IN  ATTRTYP     attr,
    IN  DWORD       dwRequiredFlags,
    OUT WCHAR       **ppAttrVal
    )

/*++

    Same as ReadCrossRefPropertySecure with the exception that we use
    cached data from the cross ref list and don't perform security checks.

--*/

{
    THSTATE     *pTHS = pTHStls;
    CROSS_REF   *pCR;
    COMMARG     CommArg;
    ULONG       cbAttr;
    ATTCACHE    *pAC;
    WCHAR       *pwszTmp;

    // We only handle ATT_NETBIOS_NAME and ATT_DNS_ROOT which are 
    // UNICODE strings.  Thus no data conversion required.

    Assert(    (ATT_NETBIOS_NAME == attr) 
            || (ATT_DNS_ROOT == attr));
    Assert(    (pAC = SCGetAttById(pTHS, attr)) 
            && (SYNTAX_UNICODE_TYPE == pAC->syntax));

    InitCommarg(&CommArg);
    SetCrackSearchLimits(&CommArg);

    pCR = FindExactCrossRef(pNC, &CommArg);

    if (    pCR 
         && (dwRequiredFlags == (pCR->flags & dwRequiredFlags))
         && (    ((ATT_NETBIOS_NAME == attr) && pCR->NetbiosName)
              || ((ATT_DNS_ROOT == attr) && pCR->DnsName)) )
    {
        pwszTmp =  ( ATT_NETBIOS_NAME == attr ) 
                                        ? pCR->NetbiosName
                                        : pCR->DnsName;
        if ( pwszTmp[0] )
        {
            cbAttr = sizeof(WCHAR) * (wcslen(pwszTmp) + 1);
            *ppAttrVal = (WCHAR *) THAllocEx(pTHS, cbAttr);
            memcpy(*ppAttrVal, pwszTmp, cbAttr);
            if ( ATT_DNS_ROOT == attr )
                NormalizeDnsName(*ppAttrVal);
            return(0);
        }
    }

    return(DIRERR_NO_CROSSREF_FOR_NC);
}


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// InitializeDomainInformation()                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
InitializeDomainInformation(
    )

/*++

Routine Description:

    Initializes the ATT_NETBIOS_NAME property for this DC's domain 
    Cross-Ref object if required.  Assumes product 1 configuration
    of only one domain per DC - i.e. gAnchor.pDomainDN.
    
    This is required so that one can simple authenticate via LDAP.
    Consider the case where some key configuration data is hosed
    and the admin wants to connect with some lowest common denominator
    LDAP client and fix it up.  LDAP simple authentication needs to
    map the admin's DN to a downlevel domain name + SAM account name
    combination like redmond\davestr.  This will only work if the
    Cross-Ref object in the Partitions container corresponding to
    gAnchor.pDomainDN has the correct ATT_NETBIOS_NAME property on it.
    
    In the ideal world we would also patch up the ATT_DNS_ROOT property.
    But it is only required in order to crack other forms of names and
    generate correct referrals.  I.e. not mandatory for base level
    system operation.

Arguments:

    None.

Return Value:

    0 on success, !0 otherwise.  Returns 0 if globals we're dependent
    on are not initialized.

--*/

{
    THSTATE                     *pTHS=pTHStls;
    WCHAR                       *pLsaDomainName = NULL;
    WCHAR                       *pNetbiosName = NULL;
    DWORD                       dwErr = 0;
    DWORD                       dwExcept = 0;
    unsigned                    cBytes;
    OBJECT_ATTRIBUTES           policy;
    HANDLE                      hPolicy;
    NTSTATUS                    status;
    POLICY_PRIMARY_DOMAIN_INFO  *pDomainInfo;
    ATTCACHE                    *pAC;
    BOOL                        fDsaSave = pTHS->fDSA;

    Assert(NULL != pTHS);

    DBOpen2(TRUE, &pTHS->pDB);
    pTHS->fDSA = TRUE;

    __try
    {
        //
        // This code should only execute when running as a normal ds.
        // There are three scenarios in which this function is called 
        // where it should do nothing.
        //
        // 1) mkdit.exe and mkhdr.exe; DsaIsInstalling() covers this case
        // 2) Called from InitDsaInfo() from DoInitialize() when we are 
        //    installing.  In this case the configDN is NULL
        // 3) Called from InitDsaInfo() from DsaReset().  In this case we 
        //    know we are installing and DsaIsInstalling() returns TRUE.
        //
        if ( NULL == gAnchor.pConfigDN      ||
             DsaIsInstalling()              ||
             !gfRunningInsideLsa )
        {
            // We're not installed yet.

            dwErr = 0;
            leave;
        }

        // Now get the current ATT_NETBIOS_NAME property off our domain's 
        // Cross-Ref object in the Partitions container.

        pNetbiosName = NULL;

        // the DS is the authorative source for the NETBIOSNAME
        //
        if ( ReadCrossRefProperty(gAnchor.pDomainDN, 
                                  ATT_NETBIOS_NAME, 
                                  (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                  &pNetbiosName) == 0) {

            dwErr = 0;
            leave;

        }

        // we failed reading the NETBIOSNAME
        // Assume LSA is authoritive with regards to our downlevel
        // domain name.  So ask what our downlevel name is.

        DPRINT (0, "Failed reading NETBIOSName from the DS. Getting it from LSA\n");

        memset(&policy, 0, sizeof(policy));

        status = LsaOpenPolicy(
                        NULL,
                        &policy,
                        POLICY_VIEW_LOCAL_INFORMATION,
                        &hPolicy);

        if ( NT_SUCCESS(status) )
        {
            status = LsaQueryInformationPolicy(
                                        hPolicy,
                                        PolicyPrimaryDomainInformation,
                                        (VOID **) &pDomainInfo);

            if ( NT_SUCCESS(status) )
            {
                // Copy the downlevel domain name.

                cBytes = sizeof(WCHAR) * (pDomainInfo->Name.Length + 1);
                pLsaDomainName = (WCHAR *) THAllocEx(pTHS, cBytes);

                wcsncpy(
                    pLsaDomainName,
                    pDomainInfo->Name.Buffer,
                    pDomainInfo->Name.Length);
                    pLsaDomainName[pDomainInfo->Name.Length] = L'\0';

                LsaFreeMemory(pDomainInfo);
            }

            LsaClose(hPolicy);
        }

        if ( !NT_SUCCESS(status) )
        {
            dwErr = status;
            LogUnhandledErrorAnonymous(dwErr);
            leave;
        }


        // Netbios domain name needs fixing up - position at Cross-Ref object.

        dwErr = PositionAtCrossRefObject(
                                gAnchor.pDomainDN, 
                                (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN));
        if ( 0 == dwErr )
        {
            if (pAC = SCGetAttById(pTHS, ATT_NETBIOS_NAME))
            {
                if ( NULL != pNetbiosName )
                {
                    // Remove old value.

                    dwErr = DBRemAttVal_AC(
                                    pTHS->pDB,
                                    pAC,
                                    wcslen(pNetbiosName) * sizeof(WCHAR),
                                    pNetbiosName);
                }

                if ( 0 == dwErr )
                {
                    // Add new value.

                    if ( 0 == (dwErr = DBAddAttVal_AC(
                                    pTHS->pDB,
                                    pAC,
                                    wcslen(pLsaDomainName) * sizeof(WCHAR),
                                    pLsaDomainName)) )
                    {
                        // Update the database.

                        dwErr = DBRepl(pTHS->pDB, FALSE, 0, 
                                        NULL, META_STANDARD_PROCESSING);
                    }
                }
            }
        }

        THFreeEx(pTHS, pLsaDomainName);

        if ( 0 != dwErr )
        {
            LogUnhandledErrorAnonymous(dwErr);
            leave;
        }
    }
    __except (HandleMostExceptions(GetExceptionCode()))
    {
        dwExcept = GetExceptionCode();
        if (!dwErr) {
            dwErr = DB_ERR_EXCEPTION;
        }
    }
    
    if (pNetbiosName) {
        THFreeEx (pTHS, pNetbiosName);
    }

    pTHS->fDSA = fDsaSave;
    DBClose(pTHS->pDB, 0 == dwErr);

    if ( 0 != dwExcept )
    {
        return(dwExcept);
    }

    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DnsDomainFromDSName()                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DnsDomainFromDSName(
    IN  DSNAME  *pDSName,
    OUT WCHAR   **ppDnsDomain
)

/*++

Routine Description:

    Maps a DSName for an object to the DNS name of the owning domain.

Arguments:

    pDSName - pointer to DSName whose DNS domain is desired.
    
    ppDnsDomain - pointer to pointer which receives the domain name.

Return Value:

    0 on success, !0 otherwise.

--*/

{
    COMMARG     commarg;
    CROSS_REF   *pCR;

    InitCommarg(&commarg);
    SetCrackSearchLimits(&commarg);

    // We hold the object, but in which NC?  It could be any NC in 
    // the enterprise if we're a GC.  So use FindBestCrossRef which
    // will do a maximal match for us.
    pCR = FindBestCrossRef(pDSName, &commarg);
    if ( NULL == pCR ) {
        return (1);
    }

    // If SECURE_DOMAIN_NAMES is defined
    //     THEN read dit to enforce security
    //     ELSE search in-memory list of cross refs
    return ReadCrossRefProperty(pCR->pNC, 
                                ATT_DNS_ROOT, 
                                FLAG_CR_NTDS_NC,
                                ppDnsDomain);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DnsDomainFromFqdnObject()                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

DWORD
DnsDomainFromFqdnObject(
    IN  WCHAR   *pFqdnObject,
    OUT ULONG   *pDNT,
    OUT WCHAR   **ppDnsDomain
)

/*++

Routine Description:

    Maps a 1779 DN for an object to the DNS name of the owning domain.

Arguments:

    pFqdnObject - pointer to DN of object whose DNS domain is desired.
    
    pDNT - pointer to DNT which receives the DNT of the object if it
        it exists on this machine.  0 otherwise.

    ppDnsDomain - pointer to pointer which receives the domain name.

Return Value:

    0 on success, !0 otherwise.

--*/

{
    THSTATE     *pTHS=pTHStls;
    COMMARG     commarg;
    COMMRES     commres;
    ULONG       structLen;
    ULONG       nameLen;
    DSNAME      *pDSNAME;
    RESOBJ      *pResObj;
    DWORD       dwErr = 1;

    *pDNT = 0;

    // Perform name resolution.  If found, then name is in a naming context
    // we host.  If not found, then referral error info should identify
    // the (best) domain we know of where the object can be found.

    nameLen = wcslen(pFqdnObject);
    structLen = DSNameSizeFromLen(nameLen);
    pDSNAME = (DSNAME *) THAllocEx(pTHS, structLen);
    memset(pDSNAME, 0, structLen);
    pDSNAME->structLen = structLen;
    pDSNAME->NameLen = nameLen;
    wcscpy(pDSNAME->StringName, pFqdnObject);
    InitCommarg(&commarg);
    SetCrackSearchLimits(&commarg);

    DoNameRes(pTHS, 0, pDSNAME, &commarg, &commres, &pResObj);

    switch ( pTHS->errCode )
    {
    case 0:

        // We hold the object, but in which NC?  It could be any NC in 
        // the enterprise if we're a GC.  So use FindBestCrossRef which
        // will do a maximal match for us.

        *pDNT = pTHS->pDB->DNT;

        dwErr = DnsDomainFromDSName(pDSNAME, ppDnsDomain);
        break;

    case referralError:

        dwErr = ExtractDnsReferral(ppDnsDomain);
        break;

    default:
    
        break;
    }

    THFreeEx(pTHS, pDSNAME);
    return(dwErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// FqdnNcFromDnsNc()                                                    //  
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef SECURE_DOMAIN_NAMES

// This function FqdnDomainFromDnsDomainSecure() is not by default compiled,
// and it's sibling non-secure FqdnDomainFromDnsDomainNonSecure() is
// used instead.  However, in Whistler we realized that this function isn't
// what is really intended when translating from Canonical and FQDN names.
// So I converted this function (FqdnDomainFromDnsDomainNonSecure()) to
// FqdnNcFromDnsNcNonSecure(), and I didn't bother to modify the Secure version.
// If anyone decides to use the secure versions of this functions (not sure 
// why one would or would not need to), then someone should make a secure 
// version of the new function FqdnNcFromDnsNcNonSecure() function.
#error Someone must make the secure version of FqdnNcFromDnsNcNonSecure() here.

DWORD
FqdnDomainFromDnsDomainSecure(
    IN  WCHAR   *pDnsDomain,
    OUT DSNAME  **ppFqdnDomain
)

/*++

Routine Description:

    Maps a DNS domain name to the corresponding domain DN.

Arguments:

    pDnsDomain - pointer to DNS domain name.

    ppFqdnDomain - pointer to pointer which receives the domain DSNAME.

Return Value:

    0 on success, !0 otherwise.

--*/

{   
    THSTATE         *pTHS=pTHStls;
    FILTER          filter;
    SUBSTRING       substring;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    DSNAME          *pDSName;
    DWORD           cBytes;
    ATTR            attrResult[3];
    ATTCACHE        *pAC;
    WCHAR           *pTmpDnsDomain;
    DWORD           i;
    ULONG           cFound;
    ENTINFLIST      *pEntInfList;
    unsigned        cParts;
    unsigned        cLeastParts;
    DSNAME          *pBestName;

    // Search the partitions container for any Cross-Ref object whose
    // ATT_DNS_ROOT matches the desired DNS domain.  Then read/return
    // the ATT_NC_NAME property.

    *ppFqdnDomain = NULL;

    if ( NULL == gAnchor.pPartitionsDN )
        return(1);

    Assert((pAC = SCGetAttById(pTHS, ATT_DNS_ROOT)) && 
           (fATTINDEX & pAC->fSearchFlags));

    // Search for the normalized/relative DNS name first, and if this fails
    // try again with the absolute DNS name.

    pTmpDnsDomain = (WCHAR *) THAllocEx(pTHS, 
                                    sizeof(WCHAR) * (wcslen(pDnsDomain) + 2));
    wcscpy(pTmpDnsDomain, pDnsDomain);
    NormalizeDnsName(pTmpDnsDomain);

    for ( i = 0; i <= 1; i++ )
    {
        if ( 1 == i )
            wcscat(pTmpDnsDomain, L".");

        // Need to do substring search so as to get hits on DNS names
        // with optional port information appended.

        memset(&substring, 0, sizeof(substring));
        substring.type = ATT_DNS_ROOT;
        substring.initialProvided = TRUE;
        substring.InitialVal.valLen = sizeof(WCHAR) * wcslen(pTmpDnsDomain);
        substring.InitialVal.pVal = (UCHAR *) pTmpDnsDomain;
        substring.AnyVal.count = 0;
        substring.finalProvided = FALSE;

        memset(&filter, 0, sizeof(filter));
        filter.choice = FILTER_CHOICE_ITEM;
        filter.FilterTypes.Item.choice = FI_CHOICE_SUBSTRING;
        filter.FilterTypes.Item.FilTypes.pSubstring = &substring;

        memset(&searchArg, 0, sizeof(SEARCHARG));
        InitCommarg(&searchArg.CommArg);
        SetCrackSearchLimits(&searchArg.CommArg);
        // Each Cross-Ref object should have a unique ATT_DNS_ROOT value 
        // meaning we can set a search limit of 1.  However, the Schema, 
        // Configuration and root domain NC all have the same ATT_DNS_ROOT 
        // value - thus we really need to set the search limit to 3.  
        // However, there could be some misguided virtual containers or 
        // temporary duplicates due to domain rename/move.  So go unlimited.
        searchArg.CommArg.ulSizeLimit = -1;
 
        attrResult[0].attrTyp = ATT_NC_NAME;
        attrResult[0].AttrVal.valCount = 0;
        attrResult[0].AttrVal.pAVal = NULL;
        attrResult[1].attrTyp = ATT_SYSTEM_FLAGS;
        attrResult[1].AttrVal.valCount = 0;
        attrResult[1].AttrVal.pAVal = NULL;
        attrResult[2].attrTyp = ATT_DNS_ROOT;
        attrResult[2].AttrVal.valCount = 0;
        attrResult[2].AttrVal.pAVal = NULL;
 
        entInfSel.attSel = EN_ATTSET_LIST;
        entInfSel.AttrTypBlock.attrCount = 3;
        entInfSel.AttrTypBlock.pAttr = attrResult;
        entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
     
        searchArg.pObject = gAnchor.pPartitionsDN;
        searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
        searchArg.bOneNC = FALSE; // optimization due to prior CHOICE
        searchArg.pFilter = &filter;
        searchArg.searchAliases = FALSE;
        searchArg.pSelection = &entInfSel;
 
        if ( 0 == i )
            pSearchRes = (SEARCHRES *) alloca(sizeof(SEARCHRES));
        memset(pSearchRes, 0, sizeof(SEARCHRES));
        pSearchRes->CommRes.aliasDeref = FALSE;
        pSearchRes->PagedResult.pRestart = NULL;
    
        SearchBody(pTHS, &searchArg, pSearchRes,0);

        if ( pSearchRes->count > 0 )
        {
            // Pick the FQDN with the least components as this will give
            // the domain DN in the Schema, Configuration and root domain
            // NC cases.

            pEntInfList = &pSearchRes->FirstEntInf;
            cLeastParts = 0xffff;
            pBestName = NULL;

#define cbVal0 (pEntInfList->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen)
#define cbVal1 (pEntInfList->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].valLen)
#define pVal0  (pEntInfList->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal)
#define pVal1  (pEntInfList->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal)

            for ( cFound = 0; cFound < pSearchRes->count; cFound++ )
            {
                if (    (3 == pEntInfList->Entinf.AttrBlock.attrCount)
                     && (pVal0 && pVal1 && cbVal0 && cbVal1)
                     && (FLAG_CR_NTDS_NC & (* ((LONG *) pVal1)))
                     && (cbVal0 > sizeof(DSNAME))
                     // Found value is a DSNAME, see if it is better 
                     // than any previous ones.
                     && (0 == CountNameParts((DSNAME *) pVal0, &cParts))
                     && (cParts < cLeastParts) 
                     && ValidatePrefixMatchedDnsName(
                            pTmpDnsDomain,
                            &pEntInfList->Entinf.AttrBlock.pAttr[2]) )
                {
                    cLeastParts = cParts;
                    pBestName = (DSNAME *) pVal0;
                }

                pEntInfList = pEntInfList->pNextEntInf;
            }

            if ( NULL != pBestName )
            {
                THFreeEx(pTHS, pTmpDnsDomain);
                *ppFqdnDomain = pBestName;
                return(0);
            }
        }
    }

    THFreeEx(pTHS, pTmpDnsDomain);
    return(1);
}

#else

DWORD
FqdnNcFromDnsNcNonSecure(
    IN  WCHAR   *pDnsDomain,
    IN  ULONG   crFlags,
    OUT DSNAME  **ppFqdnDomain
)

/*++
    
    Similar to FqdnDomainFromDnsDomainSecure with the exception that we use
    cached data from the cross ref list, don't perform security checks, and
    we allow arguments to specify that we're looking for a Domain NC or for
    a Non-Domain NC.

--*/

{   
    THSTATE         *pTHS = pTHStls;
    CROSS_REF       *pCR;
    DWORD           cChar;
    WCHAR           *pwszTmp;

    pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                        crFlags,
                                        pDnsDomain);

    if ( !pCR )
    {
        cChar = wcslen(pDnsDomain);
        if (0==cChar) {
            return 1;
        }
        pwszTmp = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * (cChar + 2));
        memcpy(pwszTmp, pDnsDomain, cChar * sizeof(WCHAR));

        if ( L'.' == pwszTmp[cChar - 1] )
        {
            // String had trailing '.' - try without.
            pwszTmp[cChar - 1] = L'\0';
        }
        else
        {
            // String had no trailing '.' - try with one.
            pwszTmp[cChar] = L'.';
        }

        pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                            crFlags,
                                            pwszTmp);
        THFreeEx(pTHS, pwszTmp);
    }
            
    if ( pCR && pCR->pNC )
    {
        *ppFqdnDomain = (DSNAME *) THAllocEx(pTHS, pCR->pNC->structLen);
        memcpy(*ppFqdnDomain, pCR->pNC, pCR->pNC->structLen);
        return(0);
    }

    return(1);
}

DWORD
FqdnNcFromDnsNcOrAliasNonSecure(
    IN  WCHAR   *pDnsDomain,
    IN  ULONG   crFlags,
    OUT DSNAME  **ppFqdnDomain
)

/*++
    
    Similar to FqdnDomainFromNCSecure with the exception that we check
    if the given pDnsDomain matches the msds-dnsRootAlias of an NC.
--*/

{   
    THSTATE         *pTHS = pTHStls;
    CROSS_REF       *pCR;
    DWORD           cChar;
    WCHAR           *pwszTmp;

    pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                        crFlags,
                                        pDnsDomain);
    
    if (!pCR) {
        pCR = FindExactCrossRefForAltNcName(ATT_MS_DS_DNSROOTALIAS,
                                            crFlags,
                                            pDnsDomain);
    }

    if ( !pCR )
    {
        cChar = wcslen(pDnsDomain);
        if (0==cChar) {
            return 1;
        }
        pwszTmp = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * (cChar + 2));
        memcpy(pwszTmp, pDnsDomain, cChar * sizeof(WCHAR));

        if ( L'.' == pwszTmp[cChar - 1] )
        {
            // String had trailing '.' - try without.
            pwszTmp[cChar - 1] = L'\0';
        }
        else
        {
            // String had no trailing '.' - try with one.
            pwszTmp[cChar] = L'.';
        }

        pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                            crFlags,
                                            pwszTmp);

        if (!pCR) {
            pCR = FindExactCrossRefForAltNcName(ATT_MS_DS_DNSROOTALIAS,
                                                crFlags,
                                                pwszTmp);
        }
        THFreeEx(pTHS,pwszTmp);
     
    }
            
    if ( pCR && pCR->pNC )
    {
        *ppFqdnDomain = (DSNAME *) THAllocEx(pTHS, pCR->pNC->structLen);
        memcpy(*ppFqdnDomain, pCR->pNC, pCR->pNC->structLen);
        return(0);
    }

    return(1);
}



#endif

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DownlevelDomainFromDnsDomain()                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef SECURE_DOMAIN_NAMES

DWORD
DownlevelDomainFromDnsDomainSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain
)

/*++

Routine Description:

    Maps a DNS domain name to the corresponding downlevel domain name.

Arguments:

    pDnsDomain - pointer to DNS domain name to map.

    ppDownlevelDomain - pointer to pointer which is to receive the downlevel
        domain name.

Return Value:

    0 on success, !0 otherwise.

--*/

{
    FILTER          filter;
    SUBSTRING       substring;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    DSNAME          *pDSName;
    DWORD           cBytes;
    ATTR            attrResult[3];
    ATTCACHE        *pAC;
    WCHAR           *pTmpDnsDomain;
    DWORD           i;
    ULONG           cFound;
    ENTINFLIST      *pEntInfList;

    // Search the partitions container for any Cross-Ref object whose
    // ATT_DNS_ROOT matches the desired DNS domain.  Then read/return
    // the ATT_NETBIOS_NAME property.

    if ( NULL == gAnchor.pPartitionsDN )
        return(1);

    Assert((pAC = SCGetAttById(pTHS, ATT_DNS_ROOT)) && 
           (fATTINDEX & pAC->fSearchFlags));

    // Search for the normalized/relative DNS name first, and if this fails
    // try again with the absolute DNS name.

    pTmpDnsDomain = (WCHAR *) THAllocEx(pTHS,
                                sizeof(WCHAR) * (wcslen(pDnsDomain) + 2));
    wcscpy(pTmpDnsDomain, pDnsDomain);
    NormalizeDnsName(pTmpDnsDomain);

    for ( i = 0; i <= 1; i++ )
    {
        if ( 1 == i )
            wcscat(pTmpDnsDomain, L".");

        // Need to do substring search so as to get hits on DNS names
        // with optional port information appended.

        memset(&substring, 0, sizeof(substring));
        substring.type = ATT_DNS_ROOT;
        substring.initialProvided = TRUE;
        substring.InitialVal.valLen = sizeof(WCHAR) * wcslen(pTmpDnsDomain);
        substring.InitialVal.pVal = (UCHAR *) pTmpDnsDomain;
        substring.AnyVal.count = 0;
        substring.finalProvided = FALSE;

        memset(&filter, 0, sizeof(filter));
        filter.choice = FILTER_CHOICE_ITEM;
        filter.FilterTypes.Item.choice = FI_CHOICE_SUBSTRING;
        filter.FilterTypes.Item.FilTypes.pSubstring = &substring;

        memset(&searchArg, 0, sizeof(SEARCHARG));
        InitCommarg(&searchArg.CommArg);
        SetCrackSearchLimits(&searchArg.CommArg);
        // Each Cross-Ref object should have a unique ATT_DNS_ROOT value 
        // meaning we can set a search limit of 1.  However, the Schema, 
        // Configuration and root domain NC all have the same ATT_DNS_ROOT 
        // value - thus we really need to set the search limit to 3.  
        // However, there could be some misguided virtual containers or 
        // temporary duplicates due to domain rename/move.  So go unlimited.
        searchArg.CommArg.ulSizeLimit = -1;

        attrResult[0].attrTyp = ATT_NETBIOS_NAME;
        attrResult[0].AttrVal.valCount = 0;
        attrResult[0].AttrVal.pAVal = NULL;
        attrResult[1].attrTyp = ATT_SYSTEM_FLAGS;
        attrResult[1].AttrVal.valCount = 0;
        attrResult[1].AttrVal.pAVal = NULL;
        attrResult[2].attrTyp = ATT_DNS_ROOT;
        attrResult[2].AttrVal.valCount = 0;
        attrResult[2].AttrVal.pAVal = NULL;

        entInfSel.attSel = EN_ATTSET_LIST;
        entInfSel.AttrTypBlock.attrCount = 3;
        entInfSel.AttrTypBlock.pAttr = attrResult;
        entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
 
        searchArg.pObject = gAnchor.pPartitionsDN;
        searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
        searchArg.bOneNC = FALSE; // optimization due to prior CHOICE
        searchArg.pFilter = &filter;
        searchArg.searchAliases = FALSE;
        searchArg.pSelection = &entInfSel;
 
        if ( 0 == i )
            pSearchRes = (SEARCHRES *) alloca(sizeof(SEARCHRES));
        memset(pSearchRes, 0, sizeof(SEARCHRES));
        pSearchRes->CommRes.aliasDeref = FALSE;
        pSearchRes->PagedResult.pRestart = NULL;
        
        SearchBody(pTHS, &searchArg, pSearchRes,0);

        if ( pSearchRes->count > 0 )
        {
            // Return the first Cross-Ref which matched the ATT_DNS_ROOT
            // and has an ATT_NETBIOS_NAME property.

            pEntInfList = &pSearchRes->FirstEntInf;
    
#define cbVal0 (pEntInfList->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen)
#define cbVal1 (pEntInfList->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].valLen)
#define pVal0  (pEntInfList->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal)
#define pVal1  (pEntInfList->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal)

            for ( cFound = 0; cFound < pSearchRes->count; cFound++ )
            {
                if (    (3 == pEntInfList->Entinf.AttrBlock.attrCount)
                     && (pVal0 && pVal1 && cbVal0 && cbVal1)
                     && (FLAG_CR_NTDS_NC & (* ((LONG *) pVal1)))
                     && ValidatePrefixMatchedDnsName(
                            pTmpDnsDomain,
                            &pEntInfList->Entinf.AttrBlock.pAttr[2]) )
                {
                    // Reallocate with NULL terminator.
            
                    *ppDownlevelDomain = 
                            (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) + cbVal0);
            
                    memcpy(*ppDownlevelDomain, pVal0, cbVal0);
                    (*ppDownlevelDomain)[cbVal0/sizeof(WCHAR)] = L'\0';
            
                    THFreeEx(pTHS, pTmpDnsDomain);
                    return(0);
                }

                pEntInfList = pEntInfList->pNextEntInf;
            }

            // Perhaps the user provided a netbios name. Check for the netbios
            // name AFTER checking all of the DNS options to avoid problems with
            // overlapping DNS and netbios names. Especially since the caller
            // was supposed to provide a dns name to begin with.

            pEntInfList = &pSearchRes->FirstEntInf;
            for ( cFound = 0; cFound < pSearchRes->count; cFound++ )
            {
                if (    (3 == pEntInfList->Entinf.AttrBlock.attrCount)
                     && (pVal0 && pVal1 && cbVal0 && cbVal1)
                     && (FLAG_CR_NTDS_NC & (* ((LONG *) pVal1)))
                     && ValidatePrefixMatchedDnsName(
                            pTmpDnsDomain,
                            &pEntInfList->Entinf.AttrBlock.pAttr[0]) )
                {
                    // Reallocate with NULL terminator.
            
                    *ppDownlevelDomain = 
                            (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) + cbVal0);
            
                    memcpy(*ppDownlevelDomain, pVal0, cbVal0);
                    (*ppDownlevelDomain)[cbVal0/sizeof(WCHAR)] = L'\0';
            
                    THFreeEx(pTHS, pTmpDnsDomain);
                    return(0);
                }

                pEntInfList = pEntInfList->pNextEntInf;
            }
        }
    }

    THFreeEx(pTHS, pTmpDnsDomain);
    return(1);
}

#else

DWORD
DownlevelDomainFromDnsDomainNonSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain
)

/*++

    Same as DownlevelDomainFromDnsDomainSecure with the exception that we use
    cached data from the cross ref list and don't perform security checks.

--*/

{
    CROSS_REF       *pCR;
    DWORD           cChar;
    WCHAR           *pwszTmp;

    pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT, 
                                        (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                        pDnsDomain);

    if ( !pCR )
    {
        cChar = wcslen(pDnsDomain);
        if (0==cChar) {
            return 1;
        }
        pwszTmp = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * (cChar + 2));
        memcpy(pwszTmp, pDnsDomain, cChar * sizeof(WCHAR));

        if ( L'.' == pwszTmp[cChar - 1] )
        {
            // String had trailing '.' - try without.
            pwszTmp[cChar - 1] = L'\0';
        }
        else
        {
            // String had no trailing '.' - try with one.
            pwszTmp[cChar] = L'.';
        }

        pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                            (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                            pwszTmp);
        THFreeEx(pTHS, pwszTmp);
    }

    // Perhaps the user provided a netbios name. Check for the netbios
    // name AFTER checking all of the DNS options to avoid problems with
    // overlapping DNS and netbios names. Especially since the caller
    // was supposed to provide a dns name to begin with.
    if ( !pCR )
    {
        pCR = FindExactCrossRefForAltNcName(ATT_NETBIOS_NAME,
                                            (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                            pDnsDomain);
    }
            
    // Found it and it has a netbios name
    if ( pCR && pCR->NetbiosName )
    {
        cChar = wcslen(pCR->NetbiosName) + 1;
        *ppDownlevelDomain = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * cChar);
        memcpy(*ppDownlevelDomain, pCR->NetbiosName, sizeof(WCHAR) * cChar);
        return(0);
    }

    return(1);
}


DWORD
DownlevelDomainFromDnsDomainOrAliasNonSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain
)

/*++

    Same as DownlevelDomainFromDnsDomainNoSecure with the exception that we try 
    to matches the given pDnsDomain against the msds-dnsrootalias of the NCs.
--*/

{
    CROSS_REF       *pCR;
    DWORD           cChar;
    WCHAR           *pwszTmp;
        
    pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                        (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                        pDnsDomain);
    if (!pCR) {
        pCR = FindExactCrossRefForAltNcName(ATT_MS_DS_DNSROOTALIAS, 
                                            (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                            pDnsDomain);
    }
    
    if ( !pCR )
    {
        cChar = wcslen(pDnsDomain);
        if (0==cChar) {
            return 1;
        }
        pwszTmp = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * (cChar + 2));
        memcpy(pwszTmp, pDnsDomain, cChar * sizeof(WCHAR));

        if ( L'.' == pwszTmp[cChar - 1] )
        {
            // String had trailing '.' - try without.
            pwszTmp[cChar - 1] = L'\0';
        }
        else
        {
            // String had no trailing '.' - try with one.
            pwszTmp[cChar] = L'.';
        }
               
        pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                            (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                            pwszTmp);
        if (!pCR) {
            pCR = FindExactCrossRefForAltNcName(ATT_MS_DS_DNSROOTALIAS,
                                                (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                                pwszTmp);
        }

        THFreeEx(pTHS, pwszTmp);
        
    }
        
    // Perhaps the user provided a netbios name. Check for the netbios
    // name AFTER checking all of the DNS options to avoid problems with
    // overlapping DNS and netbios names. Especially since the caller
    // was supposed to provide a dns name to begin with.
    if ( !pCR )
    {
        pCR = FindExactCrossRefForAltNcName(ATT_NETBIOS_NAME,
                                            (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                            pDnsDomain);
    }
            
    // Found it and it has a netbios name
    if ( pCR && pCR->NetbiosName )
    {
        cChar = wcslen(pCR->NetbiosName) + 1;
        *ppDownlevelDomain = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * cChar);
        memcpy(*ppDownlevelDomain, pCR->NetbiosName, sizeof(WCHAR) * cChar);
        return(0);
    }

    return(1);
}

#endif



//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DnsDomainFromDownlevelDomain()                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef SECURE_DOMAIN_NAMES

DWORD
DnsDomainFromDownlevelDomainSecure(
    IN  WCHAR   *pDownlevelDomain,
    OUT WCHAR   **ppDnsDomain
)

/*++

Routine Description:

    Maps a downlevel domain name to the corresponding DNS domain name,

Arguments:

    pDownlevelDomain - pointer to downlevel domain name to map.

    ppDnsDomain - pointer to pointer which is to receive DNS domain name.

Return Value:

    0 on success, !0 otherwise.

--*/

{
    THSTATE         *pTHS=pTHStls;
    FILTER          filter;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    DSNAME          *pDSName;
    DWORD           cBytes;
    ATTRVAL         attrValFilter;
    ATTR            attrFilter;
    ATTR            attrResult;
    ULONG           cbVal;
    UCHAR           *pVal;
    ATTCACHE        *pAC;

    // Search the partitions container for any Cross-Ref object whose
    // ATT_NETBIOS_NAME matches the desired downleve name.  Then read/return
    // the ATT_DNS_ROOT property.

    if ( NULL == gAnchor.pPartitionsDN )
        return(1);

    Assert((pAC = SCGetAttById(pTHS, ATT_NETBIOS_NAME)) && 
           (fATTINDEX & pAC->fSearchFlags));

    attrValFilter.valLen = sizeof(WCHAR) * wcslen(pDownlevelDomain);
    attrValFilter.pVal = (UCHAR *) pDownlevelDomain;
    attrFilter.attrTyp = ATT_NETBIOS_NAME;
    attrFilter.AttrVal.valCount = 1;
    attrFilter.AttrVal.pAVal = &attrValFilter;
 
    memset(&filter, 0, sizeof(filter));
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter.FilterTypes.Item.FilTypes.ava.type = ATT_NETBIOS_NAME;     
    filter.FilterTypes.Item.FilTypes.ava.Value = attrValFilter;
 
    memset(&searchArg, 0, sizeof(SEARCHARG));
    InitCommarg(&searchArg.CommArg);
    SetCrackSearchLimits(&searchArg.CommArg);
    // Downlevel domain names are unique, thus only look for one.
    searchArg.CommArg.ulSizeLimit = 1;
 
    attrResult.attrTyp = ATT_DNS_ROOT;
    attrResult.AttrVal.valCount = 0;
    attrResult.AttrVal.pAVal = NULL;
 
    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.AttrTypBlock.attrCount = 1;
    entInfSel.AttrTypBlock.pAttr = &attrResult;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
 
    searchArg.pObject = gAnchor.pPartitionsDN;
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = FALSE; // optimization due to prior CHOICE
    searchArg.pFilter = &filter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entInfSel;
 
    pSearchRes = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;
    pSearchRes->PagedResult.pRestart = NULL;
    
    SearchBody(pTHS, &searchArg, pSearchRes,0);
 
    if ( (1 == pSearchRes->count) &&
         (1 == pSearchRes->FirstEntInf.Entinf.AttrBlock.attrCount) )
    {
        cbVal = pSearchRes->FirstEntInf.Entinf.
                        AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;
        pVal = pSearchRes->FirstEntInf.Entinf.
                        AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;

        if ( cbVal > 0 )
        {
            // Reallocate with NULL terminator.

            *ppDnsDomain = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) + cbVal);

            if (NULL == *ppDnsDomain )
            {
                return(1);
            }

            memcpy(*ppDnsDomain, pVal, cbVal);
            (*ppDnsDomain)[cbVal/sizeof(WCHAR)] = L'\0';
            NormalizeDnsName(*ppDnsDomain);

            return(0);
        }
    }

    return(1);
}

#else

DWORD
DnsDomainFromDownlevelDomainNonSecure(
    IN  WCHAR   *pDownlevelDomain,
    OUT WCHAR   **ppDnsDomain
)

/*++

    Same as DnsDomainFromDownlevelDomainSecure with the exception that we use
    cached data from the cross ref list and don't perform security checks.
--*/

{
    THSTATE         *pTHS = pTHStls;
    CROSS_REF       *pCR;
    DWORD           cChar;
    WCHAR           *pwszTmp;

    pCR = FindExactCrossRefForAltNcName(ATT_NETBIOS_NAME,
                                        (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                        pDownlevelDomain);

    if ( pCR && pCR->DnsName )
    {
        cChar = wcslen(pCR->DnsName) + 1;
        *ppDnsDomain = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * cChar);
        memcpy(*ppDnsDomain, pCR->DnsName, sizeof(WCHAR) * cChar);
        NormalizeDnsName(*ppDnsDomain);
        return(0);
    }

    return(1);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\dsamain.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dsamain.c
//
//--------------------------------------------------------------------------

/*
 *      DSAMAIN.C
 *      This is the main program of the Directory service. It can run
 *      as either an interactive application or a DLL to be loaded by SAM/LSA.
 *
 *      If the DS is run interactively, DsaMain is called as a
 *      subroutine when StartServiceCtrlDispatcher times out. It is
 *      stopped by the ctrl/c handler.
 *
 *      When run as a DLL, the function DsInitialize is used to start the
 *      DSA. It calls DoInitialize which does the initialization. In this
 *      mode, the initialization of RPC, ATQ, and LDAP is done in another
 *      thread that waits until end-point mapper (RPCSS) is started.
 */

#include <NTDSpch.h>
#pragma  hdrstop

#include "ntdsctr.h"            /* perfmon support */
#include <sddlp.h>              // String SD to SD conversion
#include <process.h>

// Core DSA headers.
#include <ntdsa.h>
#include <dsjet.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <dbopen.h>             // The header for opening database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <drs.h>                // DRS_MSG_*
#include <ntdskcc.h>            // KCC interface

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

//perfmon header
#include <loadperf.h>

// Assorted DSA headers.
#include <sdprop.h>             // Security Descriptor Propagator header
#include <hiertab.h>
#include <heurist.h>
#include "objids.h"             // Defines for selected classes and atts
#include "anchor.h"
#include "dsexcept.h"
#include "dsconfig.h"
#include "dstaskq.h"            /* task queue stuff */
#include "ldapagnt.h"           /* ldap server */
#include "mappings.h"           /* gfDoSamChecks */
#include <ntverp.h>             /* define SLM version */
#include "debug.h"              // standard debugging header
#include "drserr.h"
#include "dsutil.h"
#include <netevent.h>
#include <dominfo.h>
#include <sync.h>
#include "gcverify.h"           // for gdwFindGcOffsiteFailbackTime
// DB layer based password encryption
#include <wxlpc.h>
#include <pek.h>

#define DEBSUB "DSAMAIN:"       // define the subsystem for debugging

// DRA headers
#include "drsuapi.h"
#include "drautil.h"
#include "drancrep.h"
#include "drasch.h"
#include "draasync.h"
#include "drarpc.h"

#include <ntdsbcli.h>
#include <ntdsbsrv.h>
#include <nlwrap.h>             // I_NetLogon* wrappers
#include <dsgetdc.h>            // for DS_DS_FLAG

#include <secedit.h>            // for Sce* functions (see SetDefaultFolderSecurity)
#include <aclapi.h>             // for SetNamedSecurityInfo (see SetDefaultFolderSecurity)

#include <fileno.h>
#define  FILENO FILENO_DSAMAIN

#define TASK_COMPLETION_TIMEOUT (15*60*1000) /* 15 minutes in milliseconds */
#define KCC_COMPLETION_TIMEOUT  (60*1000)    /* 1 minute in milliseconds */
#define TWO_MINS 120
#define FIVE_MINS 300
#define FIFTEEN_MINS 900        /* 15 mins in seconds */
#define THIRTY_MINS  1800         /* 30 mins in seconds */
#define SIXTY_MINS 3600           /* 60 mins in seconds */
#define TICKS_PER_SECOND 1000   /* 1 second in ticks */

// Dynamically referenced exports from ntdsbsrv.dll.
ERR_GET_NEW_INVOCATION_ID         FnErrGetNewInvocationId       = NULL;
ERR_GET_BACKUP_USN                FnErrGetBackupUsn             = NULL;

HANDLE hsemDRAGetChg;

extern CRITICAL_SECTION csMapiHierarchyUpdate;
extern DWORD gcMaxHeapMemoryAllocForTHSTATE;

// Global from dblayer.c
extern DWORD gcMaxTicksAllowedForTransaction;
extern BOOL gFirstTimeThrough;
extern DNList *pAddListHead;
extern CRITICAL_SECTION csUncUsn;
extern CRITICAL_SECTION csSessions;
extern CRITICAL_SECTION csDNReadLevel1List;
extern CRITICAL_SECTION csDNReadLevel2List;
extern CRITICAL_SECTION csDNReadGlobalCache;
extern CRITICAL_SECTION csHiddenDBPOS;

// Global from mapspn.c
extern CRITICAL_SECTION csSpnMappings;

// Global from dbinit.c
extern JET_INSTANCE jetInstance;

// Global from scache.c
extern int iSCstage;
extern SCHEMAPTR *CurrSchemaPtr;
extern CRITICAL_SECTION csJetColumnUpdate;
extern CRITICAL_SECTION csSchemaCacheUpdate;
extern CRITICAL_SECTION csOrderClassCacheAtts;

//from dbconstr.c
extern CRITICAL_SECTION csDitContentRulesUpdate;

// Global from drasch.c
extern CRITICAL_SECTION csGCDListProcessed;

// Global from groupcch.c
extern CRITICAL_SECTION csGroupTypeCacheRequests;
HANDLE hevGTC_OKToInsertInTaskQueue;

// Global from fpoclean.c
extern PAGED_RESULT gFPOCleanupPagedResult;

// Global from draserv.c
extern DWORD gEnableXForest;

// Global from drsuapi.c
extern CRITICAL_SECTION gcsDrsRpcServerCtxList;
extern CRITICAL_SECTION gcsDrsRpcFreeHandleList;

// global from log.cxx
extern CRITICAL_SECTION csLoggingUpdate;

// Globals for keeping track of ds_waits.
extern CRITICAL_SECTION csDirNotifyQueue;
extern HANDLE hevDirNotifyQueue;

// globals for registering or not registering NDNC SPNs
extern DWORD gfWriteNdncSpns;

// The time the DSA started, specifically DsaSetIsRunning() has been called
DSTIME gtimeDSAStarted = 0;

// This is the maximum number of concurrent threads that we permit to call
// DRA_Getncchanges at the same time.
ULONG gulMaxDRAGetChgThrds = 0;

// Garbage collection parameters
ULONG gulTombstoneLifetimeSecs = 0; // Days before logically deleted object
                    // is gone

ULONG gulGCPeriodSecs = DEFAULT_GARB_COLLECT_PERIOD * HOURS_IN_SECS;

BOOL gfRunningInsideLsa = TRUE;     // inicates that we are running inside LSA
volatile BOOL fAssertLoop = TRUE;   /* Do we hang on asserts? */

// Global restore flag
BOOL gfRestoring = FALSE;
DWORD gdwrestvalue;

// Flag that indicates that synchronization for writable partitions
// have been tried.  Note the difference from:
// gfInitSyncsFinished - all init syncs write+read are done
// gfDsaIsWritable - whether ds flag is currently toggled
// gAnchor.fAmGC - gc promotion is complete
BOOL gfIsSynchronized = FALSE;

NTSTATUS gDelayedStartupReturn = STATUS_INTERNAL_ERROR;

// Global boolean, have we inited our critical sections?
BOOL gbCriticalSectionsInitialized = FALSE;

// Has the task scheduler been started?
BOOL gfTaskSchedulerInitialized = FALSE;

// Global, constant security descriptor to put on objects we find that have no
// security descriptors
PSECURITY_DESCRIPTOR pNoSDFoundSD = NULL;
DWORD                cbNoSDFoundSD = 0;
// Owner = System
// PGroup = System
// DACL = Empty
// SACL = Empty
#define DEFAULT_NO_SD_FOUND_SD L"O:SYG:SYD:S:"

// Dynamic Object (entryTTL) Globals
//
// Delete expired dynamic objects (entryTTL == 0) every N secs
// or at the next expiration time plus M secs, whichever is less.
// Initialized by GetDSARegistryParameters()
ULONG gulDeleteExpiredEntryTTLSecs;
ULONG gulDeleteNextExpiredEntryTTLSecs;

// Schema FSMO Lease Globals
//
// the schema fsmo cannot be transferred for a few seconds after
// it has been transfered or after a schema change (excluding
// replicated changes). This allows a schema admin to actually
// accomplish a schema change after transferring the fsmo rather
// than having it pulled away by a competing schema admin who also
// wants to make schema changes.
ULONG gulSchemaFsmoLeaseSecs;
ULONG gulSchemaFsmoLeaseMaxSecs;

extern DWORD gulAllowWriteCaching;

// State Flags
BOOL gUpdatesEnabled = FALSE;
BOOL gFirstCacheLoadAfterBoot = FALSE;

// Should we disable all background tasks?  Set by heuristic flag only
// for performance testing.
BOOL gfDisableBackgroundTasks = FALSE;

typedef enum
{
    ePhaseInstall,  //During install
    ePhaseRunning
}INITPHASE;

INITPHASE dsaInitPhase=ePhaseRunning;

typedef enum
{
    eMultiUserMode,
    eSingleUserMode
} DSAMODE;
DSAMODE dsaUserMode = eMultiUserMode;

THSTATE *pdsaSingleUserThread = NULL;

typedef enum
{
    eWireInstall,   //default
    eMediaInstall
}DATASOURCE;

DATASOURCE DataSource=eWireInstall;

// a global template DSNAME of the root
DSNAME *gpRootDN;

// global to store root domain SID for use in SD conversion APIs
// The private version of these APIs that we use,
// (ConvertStringSDtoSDRootDomain), takes in the root domain sid
// as a parameter to use to resolve root-domain relative groups like
// EA and SA in test SDs. If the Sid passed in is null, it resolves to
// a default behavior in which EA is replaced by DA and SA is resolved
// relative to the current domain's sid (SA is used only during building
// the schema, which is done only once during root domain install, so
// the group is resolved correctly)

PSID gpRootDomainSid = NULL;
PSID gpDomainAdminSid = NULL;
PSID gpSchemaAdminSid = NULL;
PSID gpEnterpriseAdminSid = NULL;
PSID gpBuiltinAdminSid = NULL;
PSID gpAuthUserSid = NULL;

// Global structure indicating extensions supported for the DRS interface.
DRS_EXTENSIONS_INT LocalDRSExtensions = {
    sizeof(DRS_EXTENSIONS_INT) - sizeof(DWORD),
    ((1 << DRS_EXT_BASE)
        | (1 << DRS_EXT_ASYNCREPL)
        | (1 << DRS_EXT_REMOVEAPI)
        | (1 << DRS_EXT_MOVEREQ_V2)
        | (1 << DRS_EXT_GETCHG_COMPRESS)
        | (1 << DRS_EXT_DCINFO_V1)
        | (1 << DRS_EXT_STRONG_ENCRYPTION)
        | (1 << DRS_EXT_ADDENTRY_V2)
        | (1 << DRS_EXT_KCC_EXECUTE)
     // DRS_EXT_LINKED_VALUE_REPLICATION is enabled dynamically later
        | (1 << DRS_EXT_DCINFO_V2)
        | (1 << DRS_EXT_DCINFO_VFFFFFFFF)
        | (1 << DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD)
        | (1 << DRS_EXT_CRYPTO_BIND)
        | (1 << DRS_EXT_GET_REPL_INFO)
        | (1 << DRS_EXT_TRANSITIVE_MEMBERSHIP)
        | (1 << DRS_EXT_ADD_SID_HISTORY)
        | (1 << DRS_EXT_POST_BETA3)
        | (1 << DRS_EXT_RESTORE_USN_OPTIMIZATION)
        | (1 << DRS_EXT_GETCHGREQ_V5)
        | (1 << DRS_EXT_GETMEMBERSHIPS2)
        | (1 << DRS_EXT_GETCHGREQ_V6)
        | (1 << DRS_EXT_NONDOMAIN_NCS)
        | (1 << DRS_EXT_GETCHGREQ_V8)
        | (1 << DRS_EXT_GETCHGREPLY_V5)
        | (1 << DRS_EXT_GETCHGREPLY_V6)
          // This next bit really adds the ability to understand:
          //    DRS_EXT_ADDENTRYREPLY_V3
          //    DRS_EXT_GETCHGREPLY_V7
          //    DRS_EXT_VERIFY_OBJECT
        | (1 << DRS_EXT_WHISTLER_BETA3)
        | (1 << DRS_EXT_XPRESS_COMPRESSION)
    ),
    // NOTE: Be careful -- if you add extension #32, you will need to extend the
    // DRS_EXTENSIONS_INT structure to include another Flags field (and
    // corresponding logic in IS_DRS_EXT_SUPPORTED(), etc.).
    {0}, // site guid, filled in later
    0,   // pid (used only by NTDSAPI clients)
    0    // replication epoch, filled in later
};

// Set when we're shutting down the DS (set immediately prior to the event
// hServDoneEvent).
volatile SHUTDOWN eServiceShutdown = eRunning;

// These are constants used to calculate replication sizes off memory.
// Memory size in bytes to packet size in bytes ratio.
#define MEMSIZE_TO_PACKETSIZE_RATIO (100i64)
// The packet size in bytes to packet size in objects ratio
#define BYTES_TO_OBJECT_RATIO   (10000)
// These are the 4 are the acual replication packet sizes in bytes & objs.
//   Packet bytes constrained to: 1MB < bytes_per_repl_packet < 10MB
//   and for mail based rep it  : 1MB
#define MAX_MAX_PACKET_BYTES    (10*1024*1024)
#define MAX_ASYNC_PACKET_BYTES  (1*1024*1024)
//   Packet objects constrained to: 104 < objects_per_packet < 1048
#define MAX_MAX_PACKET_OBJECTS  (1000)

#if DBG
// string for debug or retail
#define FLAVOR_STR "(Debug)"
#else
#define FLAVOR_STR ""
#endif

#if DBG
extern BARRIER gbarRpcTest;
#endif

static int Install(
    IN int argc,
    IN char *argv[],
    IN THSTATE *pTHS,
    IN PDS_INSTALL_PARAM   InstallInParams  OPTIONAL
    );
static char far * UnInstall(void);
void __cdecl sighandler(int sig);
void init_signals(void);
void GetDRARegistryParameters(void);
void GetDSARegistryParameters(void);
void __cdecl DSLoadDynamicRegParams();
void GetExchangeParameters(void);
void GetHeuristics(void);
ULONG GetRegistryOrDefault(char *pKey, ULONG uldefault, ULONG ulMultiplier);
void DeleteTree(LPTSTR pszPath);
NTSTATUS DsWaitUntilDelayedStartupIsDone();
void DsaTriggerShutdown(BOOL fSingleUserMode);
int  MapSpnInitialize(THSTATE *pTHS);
DWORD InitializeDomainAdminSid();
BOOL VerifyDSBehaviorVersion(THSTATE *pTHS);
DWORD
UpgradeDsa(
    THSTATE     *pTHS,
    LONG        lOldDsaVer,
    LONG        lNewDsaVer
    );
VOID CheckSetDefaultFolderSecurity();

volatile ULONG ulcActiveReplicationThreads = 0;

CRITICAL_SECTION    csServerContexts;
CRITICAL_SECTION    csRidFsmo;
DWORD  dwTSindex = INVALID_TS_INDEX;
extern CRITICAL_SECTION csNotifyList;

//from dsatools.c

#ifdef CACHE_UUID
extern CRITICAL_SECTION csUuidCache;
#endif
extern CRITICAL_SECTION csThstateMap;
extern BOOL gbThstateMapEnabled;
extern CRITICAL_SECTION csHeapFailureLogging;

// Dummy variable for some perfmon variables
ULONG DummyPerf = 0;

extern HANDLE hmtxSyncLock;
extern HANDLE hmtxAsyncThread;
extern CRITICAL_SECTION csAsyncThreadStart;
extern CRITICAL_SECTION csAOList;
extern CRITICAL_SECTION csLastReplicaMTX;
extern CRITICAL_SECTION csNCSyncData;
extern CRITICAL_SECTION gcsFindGC;
extern CRITICAL_SECTION csIndexCreation;
extern HANDLE hevEntriesInAOList;
extern HANDLE hevEntriesInList;
extern HANDLE hevDRASetup;
extern HANDLE evSchema;  // Lazy schema reload
extern HANDLE evUpdNow;  // reload schema now
extern HANDLE evUpdRepl; // synchronize schema reload and replication threads (SCReplReloadCache())
volatile unsigned long * pcBrowse;
volatile unsigned long * pcSDProps;
volatile unsigned long * pcSDEvents;
volatile unsigned long * pcLDAPClients;
volatile unsigned long * pcLDAPActive;
volatile unsigned long * pcLDAPSearchPerSec;
volatile unsigned long * pcLDAPWritePerSec;
volatile unsigned long * pcRepl;
volatile unsigned long * pcThread;
volatile unsigned long * pcABClient;
volatile unsigned long * pcPendSync;
volatile unsigned long * pcRemRepUpd;
volatile unsigned long * pcDRAObjShipped;
volatile unsigned long * pcDRAPropShipped;
volatile unsigned long * pcDRASyncRequestMade;
volatile unsigned long * pcDRASyncRequestSuccessful;
volatile unsigned long * pcDRASyncRequestFailedSchemaMismatch;
volatile unsigned long * pcDRASyncObjReceived;
volatile unsigned long * pcDRASyncPropUpdated;
volatile unsigned long * pcDRASyncPropSame;
volatile unsigned long * pcMonListSize;
volatile unsigned long * pcNotifyQSize;
volatile unsigned long * pcLDAPUDPClientOpsPerSecond;
volatile unsigned long * pcSearchSubOperations;
volatile unsigned long * pcNameCacheHit;
volatile unsigned long * pcNameCacheTry;
volatile unsigned long * pcHighestUsnIssuedLo;
volatile unsigned long * pcHighestUsnIssuedHi;
volatile unsigned long * pcHighestUsnCommittedLo;
volatile unsigned long * pcHighestUsnCommittedHi;
volatile unsigned long * pcSAMWrites;
volatile unsigned long * pcDRAWrites;
volatile unsigned long * pcLDAPWrites;
volatile unsigned long * pcLSAWrites;
volatile unsigned long * pcKCCWrites;
volatile unsigned long * pcNSPIWrites;
volatile unsigned long * pcOtherWrites;
volatile unsigned long * pcNTDSAPIWrites;
volatile unsigned long * pcTotalWrites;
volatile unsigned long * pcSAMSearches;
volatile unsigned long * pcDRASearches;
volatile unsigned long * pcLDAPSearches;
volatile unsigned long * pcLSASearches;
volatile unsigned long * pcKCCSearches;
volatile unsigned long * pcNSPISearches;
volatile unsigned long * pcOtherSearches;
volatile unsigned long * pcNTDSAPISearches;
volatile unsigned long * pcTotalSearches;
volatile unsigned long * pcSAMReads;
volatile unsigned long * pcDRAReads;
volatile unsigned long * pcLSAReads;
volatile unsigned long * pcKCCReads;
volatile unsigned long * pcNSPIReads;
volatile unsigned long * pcOtherReads;
volatile unsigned long * pcNTDSAPIReads;
volatile unsigned long * pcTotalReads;
volatile unsigned long * pcLDAPBinds;
volatile unsigned long * pcLDAPBindTime;
volatile unsigned long * pcCreateMachineSuccessful;
volatile unsigned long * pcCreateMachineTries;
volatile unsigned long * pcCreateUserSuccessful;
volatile unsigned long * pcCreateUserTries;
volatile unsigned long * pcPasswordChanges;
volatile unsigned long * pcMembershipChanges;
volatile unsigned long * pcQueryDisplays;
volatile unsigned long * pcEnumerations;
volatile unsigned long * pcMemberEvalTransitive;
volatile unsigned long * pcMemberEvalNonTransitive;
volatile unsigned long * pcMemberEvalResource;
volatile unsigned long * pcMemberEvalUniversal;
volatile unsigned long * pcMemberEvalAccount;
volatile unsigned long * pcMemberEvalAsGC;
volatile unsigned long * pcAsRequests;
volatile unsigned long * pcTgsRequests;
volatile unsigned long * pcKerberosAuthentications;
volatile unsigned long * pcMsvAuthentications;
volatile unsigned long * pcDRASyncFullRemaining;
volatile unsigned long * pcDRAInBytesTotal;
volatile unsigned long * pcDRAInBytesTotalRate;
volatile unsigned long * pcDRAInBytesNotComp;
volatile unsigned long * pcDRAInBytesNotCompRate;
volatile unsigned long * pcDRAInBytesCompPre;
volatile unsigned long * pcDRAInBytesCompPreRate;
volatile unsigned long * pcDRAInBytesCompPost;
volatile unsigned long * pcDRAInBytesCompPostRate;
volatile unsigned long * pcDRAOutBytesTotal;
volatile unsigned long * pcDRAOutBytesTotalRate;
volatile unsigned long * pcDRAOutBytesNotComp;
volatile unsigned long * pcDRAOutBytesNotCompRate;
volatile unsigned long * pcDRAOutBytesCompPre;
volatile unsigned long * pcDRAOutBytesCompPreRate;
volatile unsigned long * pcDRAOutBytesCompPost;
volatile unsigned long * pcDRAOutBytesCompPostRate;
volatile unsigned long * pcDsClientBind;
volatile unsigned long * pcDsServerBind;
volatile unsigned long * pcDsClientNameTranslate;
volatile unsigned long * pcDsServerNameTranslate;
volatile unsigned long * pcSDPropRuntimeQueue;
volatile unsigned long * pcSDPropWaitTime;
volatile unsigned long * pcDRAInProps;
volatile unsigned long * pcDRAInValues;
volatile unsigned long * pcDRAInDNValues;
volatile unsigned long * pcDRAInObjsFiltered;
volatile unsigned long * pcDRAOutObjsFiltered;
volatile unsigned long * pcDRAOutValues;
volatile unsigned long * pcDRAOutDNValues;
volatile unsigned long * pcNspiANR;
volatile unsigned long * pcNspiPropertyReads;
volatile unsigned long * pcNspiObjectSearch;
volatile unsigned long * pcNspiObjectMatches;
volatile unsigned long * pcNspiProxyLookup;
volatile unsigned long * pcAtqThreadsTotal;
volatile unsigned long * pcAtqThreadsLDAP;
volatile unsigned long * pcAtqThreadsOther;
volatile unsigned long * pcLdapNewConnsPerSec;
volatile unsigned long * pcLdapClosedConnsPerSec;
volatile unsigned long * pcLdapSSLConnsPerSec;
volatile unsigned long * pcDRAReplQueueOps;
volatile unsigned long * pcDRATdsInGetChngs;
volatile unsigned long * pcDRATdsInGetChngsWSem;
volatile unsigned long * pcDRARemReplUpdLnk;
volatile unsigned long * pcDRARemReplUpdTot;
volatile unsigned long * pcSAMAcctGroupLatency;
volatile unsigned long * pcSAMResGroupLatency;


// Mapping of DSSTAT_* to counter variables
//
// In process components outside the DS core can update DS performance
// counters by calling UpdateDSPerfStats() export in NTDSA.DLL.  This map
// table provides efficient mapping of counter contants used by these
// external components to actual counter variables.

volatile unsigned long * StatTypeMapTable[ DSSTAT_COUNT ];

// Thread handles
HANDLE  hStartupThread = NULL;
HANDLE  hDirNotifyThread = NULL;
extern HANDLE  hReplNotifyThread;
extern HANDLE hAsyncSchemaUpdateThread;
extern HANDLE hAsyncThread;
HANDLE  hMailReceiveThread = NULL;

HANDLE  hevIndexRebuildUI   = NULL;
HANDLE  hevDelayedStartupDone;
HANDLE  hevInitSyncsCompleted;

extern BOOL fAsyncThreadExists, fAsyncThreadAlive;

extern DWORD SetDittoGC();

extern BOOL isDitFromGC(IN  PDS_INSTALL_PARAM   InstallInParams  OPTIONAL,
                            OUT PDS_INSTALL_RESULT  InstallOutParams OPTIONAL);

extern ULONG InstallBaseNTDS(IN  PDS_INSTALL_PARAM   InstallInParams  OPTIONAL,
                                 OUT PDS_INSTALL_RESULT  InstallOutParams OPTIONAL);

extern void
RebuildAnchor(void * pv,
              void ** ppvNext,
              DWORD * pcSecsUntilNextIteration );



//
// Boolean to indicate if DS is running as exe
//

BOOL    gfRunningAsExe = FALSE;

//
// Boolean to indicate if DS is running as mkdit.exe (constructing the
// boot dit (aka ship dit, initial dit) winnt\system32\ntds.dit.
//
// mkdit.exe manages the schema cache on its own. This boolean is used
// to disable schema cache updates by the mainline code.
//
BOOL    gfRunningAsMkdit = FALSE;

// Boolean to indicate if linked value replication feature is enabled

BOOL gfLinkedValueReplication = FALSE;

// Strict replication consistency mode
BOOL gfStrictReplicationConsistency = FALSE;
BOOL gfStrictScheduleWindow = FALSE;

#define DS_SERVICE_CONTROL_WAIT_TIMEOUT ((DWORD) 10000)

int
DsaMain(int argc, char *argv[]);

void
DsaStop(BOOL fSingleUserMode);

NTSTATUS
DoInitialize(int argc, char * argv[], unsigned fInitAdvice,
                 IN  PDS_INSTALL_PARAM   InstallInParams  OPTIONAL,
                 OUT PDS_INSTALL_RESULT  InstallOutParams OPTIONAL);

ULONG DsaInitializeTrace(VOID);

void
DoShutdown(BOOL fDoDelayedShutdown, BOOL fShutdownUrgently, BOOL fPartialShutdown);

void PerfInit(void);
BOOL gbPerfCountersInitialized = FALSE;

// If we fail to load the NTDS performance counters, how often do we retry (sec)?
#define PERFCTR_RELOAD_INTERVAL (15*60)

int
DsaReset(void);

BOOL
FUpdateBackupExclusionKey();

HANDLE                  hServDoneEvent = NULL;

//---------------------------------------------------------------------------
// Flag to indicate Dsa is reset to running state after install, so that we can
// detect this and not do certain tasks, like async thread creations, even if
// Dsa appears to be running

BOOL gResetAfterInstall = FALSE;
BOOLEAN __fastcall DsaIsInstalling()
{
    // cover both mkdit and install cases
    return (dsaInitPhase != ePhaseRunning);
}

BOOLEAN __fastcall DsaIsRunning()
{
    return (dsaInitPhase == ePhaseRunning);
}

void
DsaSetIsInstalling()
{
    dsaInitPhase = ePhaseInstall;
}

void
DsaSetIsRunning()
{
    dsaInitPhase = ePhaseRunning;
}


BOOLEAN DsaIsInstallingFromMedia()
{
    return (DataSource == eMediaInstall);
}

void
DsaSetIsInstallingFromMedia()
{
    DataSource = eMediaInstall;
}

// This function is used to tell Netlogon when this DC is fully installed.
// The DC is not fully installed until the first full sync ever completes
// Note that this assumes there is only one writable NC to be synced.  When
// there are more in the future we should revisit this.

BOOL
DsIsBeingBackSynced()
{
    return !gfIsSynchronized;
}



//
//  DsaSetSingleUserMode
//
//  Description:
//
//      Set the DS into the "SigleUserMode"
//      In SingleUserMode, the DS is running, but only accepts calls from
//      a specific thread, the one that invoked the single user mode.
//
//  Arguments:
//
//
//  Return Value:
//      TRUE if succeeded, FALSE otherwise
//
BOOL DsaSetSingleUserMode()
{
    THSTATE    *pTHS=pTHStls;
    Assert (pdsaSingleUserThread == NULL);
    Assert (pTHS->fSingleUserModeThread == FALSE);

    if (InterlockedCompareExchangePointer(&pdsaSingleUserThread, pTHS, NULL) != NULL) {
        // someone beat us here
        return FALSE;
    }

    DPRINT (0, "Going into Single User Mode\n");

    dsaUserMode = eSingleUserMode;

    // TODO: remove only if
    if (gfRunningInsideLsa) {

        // Tell clients to go away and workers to quit
        DsaTriggerShutdown(TRUE);

        // stop taskq, repl threads, async threads
        DsaStop(TRUE);

        // stop propagator.
        // make it start so it will detect that we are going in single user mode
        // and will shutdown. wait for it to shutdown for 2 mins
        SetEvent (hevSDPropagatorStart);
        SetEvent (hevSDPropagationEvent);

        // wait for propagator to die
        WaitForSingleObject (hevSDPropagatorDead, 120 * 1000);
    }

    pTHS->fSingleUserModeThread = TRUE;

    return TRUE;
}

//
//  DsaIsSingleUserMode
//
//  Description:
//
//      Get whether the DS is in singleUserMode
//
//  Arguments:
//
//
//  Return Value:
//      TRUE if in singleUserMode, FALSE otherwise
//
BOOL __fastcall DsaIsSingleUserMode (void)
{
    return (dsaUserMode == eSingleUserMode);
}

//
//  DsaSetMultiUserMode
//
//  Description:
//
//      Go back to multiuser mode. This will not restart all the services
//      that the SetSignleUserMode stopped.
//
//  Arguments:
//
//
//  Return Value:
//      None
//
void DsaSetMultiUserMode()
{
    // TODO: remove function. only for dev purposes
    THSTATE    *pTHS=pTHStls;
    Assert (pdsaSingleUserThread == pTHS);
    Assert (pTHS->fSingleUserModeThread);

    Assert (!gfRunningInsideLsa);

    dsaUserMode = eMultiUserMode;
    pdsaSingleUserThread = NULL;
    pTHS->fSingleUserModeThread = FALSE;
}




// We are called here when the writable partitions have been synced.  Readable
// partitions may be still in progress, and gc promotion may not have happened
// yet.  When we set the writability flag, we cause netlogon to advertise us to
// ldap clients *seeking a non-gc port*.  We advertise even though readonly data is
// no finished syncing on the assumption that these clients want writable data,
// since they weren't seeking a gc.
void
DsaSetIsSynchronized(BOOL f)
{
    // This global must be set first before SetDsaWritability will take effect
    gfIsSynchronized = f;

    if (f) {
        // Initial state of gfDsaWritability is false in dsatools.c
        // CliffV writes: You should not set the NTDS_DELAYED_STARTUP_COMPLETED_EVENT
        // until you've set the DS_DS_FLAG.

        if ( gfRunningInsideLsa )
        {
            SetDsaWritability( TRUE, ERROR_SUCCESS );
        }

        DPRINT(0, "Writeable partitions synced: Netlogon can now advertise this DC.\n" );

        SetEvent(hevInitSyncsCompleted);

        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DSA_UP_TO_DATE,
                 NULL, NULL, NULL );
    } else {
        // This path not used
        // One set, NETLOGON expects these never to be retracted
        Assert( FALSE );
        DPRINT(0, "Netlogon can no longer advertise this DC.\n" );
        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DSA_NOT_ADVERTISE_DC,
                 NULL, NULL, NULL );
    }
}

DWORD
UpgradeDsRegistry(void)
/*++

    Upgrades the registry for .NET Forest Mode.
    
// FUTURE-2002/08/12-BrettSh - Many code improvements could be made to make this a
// very generic function to handle all types of registry values, etc ... 
                                                   
--*/
{
    HKEY                            hkMachine = NULL;
    HKEY                            hk = NULL;
    DWORD                           dwRet;
    DWORD                           dwType;
    DWORD                           dwSize = sizeof(DWORD);
    DWORD                           dwResult;
    ULONG                           i;
    struct {
        WCHAR * szValue;
        DWORD   dwOld;
        DWORD   dwNew;
    } argTable [] = {
        { MAKE_WIDE(DRA_NOTIFY_START_PAUSE),        WIN2K_DEFAULT_DRA_START_PAUSE,      DEFAULT_DRA_START_PAUSE },
        { MAKE_WIDE(DRA_NOTIFY_INTERDSA_PAUSE),     WIN2K_DEFAULT_DRA_INTERDSA_PAUSE,   DEFAULT_DRA_INTERDSA_PAUSE },
        { NULL, 0 } // Stopper entry.
    };

    __try{

        dwRet = RegConnectRegistryW(NULL, HKEY_LOCAL_MACHINE, &hkMachine);
        if(dwRet != ERROR_SUCCESS){

            // This is an actual problem, return error.
            LogUnhandledError(dwRet);
            __leave;

        }

        dwRet = RegOpenKeyW(hkMachine, MAKE_WIDE(DSA_CONFIG_SECTION), &hk);
        if(dwRet != ERROR_SUCCESS){

            // BUGBUG: this is probably an OK thing, unless the machine is a DC,
            // if this code is for sure running on a DC, then this is an error, 
            // and we should return(dwRet); instead of ERROR_SUCCESS below.
            LogUnhandledError(dwRet);
            __leave;

        }

        for (i = 0; argTable[i].szValue; i++) {

            dwRet = RegQueryValueExW(hk, argTable[i].szValue, NULL,
                                    &dwType, (LPBYTE) &dwResult, &dwSize);
            if(dwRet == ERROR_SUCCESS 
               && dwType == REG_DWORD ){

                if (dwResult == argTable[i].dwOld) {
                    // The Registry value exists, and is the Win2k Default value,
                    // so now delete this registry value.

                    dwRet = RegDeleteValueW(hk, argTable[i].szValue );
                    if(dwRet != ERROR_SUCCESS){

                        // This is not OK, we should be able to delete (write) this
                        // registry value.
                        LogEvent8(DS_EVENT_CAT_REPLICATION, 
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_WFM_REG_UPGRADE_CRIT_FAILURE,
                                  szInsertWC(MAKE_WIDE(DSA_CONFIG_SECTION)), 
                                  szInsertWC(argTable[i].szValue),
                                  szInsertInt(dwResult),
                                  szInsertInt(argTable[i].dwNew),
                                  szInsertHex(dwRet), 
                                  szInsertWin32Msg(dwRet), NULL, NULL);
                        continue;
                    }
                } else {
                    LogEvent8(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_WFM_REG_UPGRADE_NON_DEFAULT_FAILURE,
                              szInsertWC(MAKE_WIDE(DSA_CONFIG_SECTION)), 
                              szInsertWC(argTable[i].szValue),          
                              szInsertInt(dwResult),
                              szInsertInt(argTable[i].dwNew), NULL, NULL, NULL, NULL);
                    continue;
                }


            } else {
                // There was some kind of error, but this is OK because an administrator
                // may have removed or changed the value, continue on ...
                if (dwRet != ERROR_FILE_NOT_FOUND) {
                    LogEvent8(DS_EVENT_CAT_REPLICATION, 
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_WFM_REG_UPGRADE_CRIT_FAILURE,
                              MAKE_WIDE(DSA_CONFIG_SECTION), 
                              szInsertWC(argTable[i].szValue), 
                              szInsertWC(L" "),
                              szInsertInt(argTable[i].dwNew),
                              szInsertHex(dwRet), 
                              szInsertWin32Msg(dwRet), NULL, NULL);
                    continue;
                }
            }
        }
    } __finally {
        if(hkMachine) { RegCloseKey(hkMachine); }
        if(hk) { RegCloseKey(hk); }
   }
    
   return(ERROR_SUCCESS);
}


void
DsaEnableLinkedValueReplication(
    THSTATE *pTHS OPTIONAL,
    BOOL fFirstTime
    )

/*++

Routine Description:

    Enable the linked value replication feature.

    This is called under three circumstances:
    1. The user has requested this feature be enabled
    2. This system has learned through replication that other systems
       in the enterprise have enabled this feature
    3. We are rebooting and this feature was previously enabled

Arguments:

    pTHS OPTIONAL - threadstate
    fFirstTime - True for the first two cases

Return Value:

    None

--*/

{
    LONG oldValue;

    if (pTHS) {
        pTHS->fLinkedValueReplication = TRUE;
    }

    // Write TRUE into the synchronization variable
    // No need to do InterlockedCompareExchange, since we use
    // a boolean variable here.
    oldValue = InterlockedExchange(
        &gfLinkedValueReplication,       // Destination
        TRUE                             // Exchange
        );

    // If already initialized, no need to enable again
    if (oldValue == TRUE) {
        return;
    }

    gAnchor.pLocalDRSExtensions->dwFlags |=
        (1 << DRS_EXT_LINKED_VALUE_REPLICATION);

    if (fFirstTime) {
#if DBG
        // Debug hook to remember old LVR state
        SetConfigParam( LINKED_VALUE_REPLICATION_KEY, REG_DWORD,
                        &gfLinkedValueReplication, sizeof( BOOL ) );
#endif

        UpgradeDsRegistry();

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_LVR_ENABLED,
                 NULL, NULL, NULL);

        DPRINT( 0, "This DC supports linked value replication.\n" );

    }

} /* DsaEnableLinkedValueReplication */

// SD to put on events we create:
// Everyone read & syncronize access, local system all access.
#define DEFAULT_EVENT_SD L"D:(A;;0x80100000;;;WD)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)"


BOOLEAN
DsWaitForSamService(
    VOID
    )
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:


Return Value:

    TRUE : if the SAM service is successfully starts.

    FALSE : if the SAM service can't start.

--*/
{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    PSECURITY_DESCRIPTOR pSD;
    DWORD cbSD;

    //
    // open SAM event
    //

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                DEFAULT_EVENT_SD,
                SDDL_REVISION_1,
                &pSD,
                &cbSD)) {
        return FALSE;
    }

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, pSD );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );

    if ( !NT_SUCCESS(Status)) {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                //
                // second change, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status)) {

            //
            // could not make the event handle
            //

            KdPrint(("DsWaitForSamService couldn't make the event handle : "
                "%lx\n", Status));

            LocalFree(pSD);

            return( FALSE );
        }
    }
    
    LocalFree(pSD);

    //
    // Loop waiting.
    //

    for (;;) {
        WaitStatus = WaitForSingleObject( EventHandle,
                                          5*1000 );  // 5 Seconds

        if ( WaitStatus == WAIT_TIMEOUT ) {
            KdPrint(("DsWaitForSamService 5-second timeout (Rewaiting)\n" ));
            continue;

        } else if ( WaitStatus == WAIT_OBJECT_0 ) {
            break;

        } else {
            KdPrint(("DsWaitForSamService: error %ld %ld\n",
                     GetLastError(),
                     WaitStatus ));
            (VOID) NtClose( EventHandle );
            return FALSE;
        }
    }

    (VOID) NtClose( EventHandle );
    return TRUE;

} // DsWaitForSamService


NTSTATUS
__stdcall
DsaDelayedStartupHandler(
    PVOID StartupParam
    )

/*++

Routine Description:

    This routine delays the initialization of certain parts of the DS until
    enough of the system is running. DS initialization occurs during system
    boot time. The DS needs to register RPC interfaces and endpoints, for
    example, but should only attempt this after RPCSS has been started.

    This routine should only be executed from a thread, invoked from the
    mainline DsInitialize routine. This thread waits on RPCSS, but could be
    augmented to wait on other system services in the future.

    Other aspects of DS initialization may need to be delayed in the future,
    hence, calls to those routines should be added to this routine.

    This routine has developed to hold, in general, not only parts of the
    DS that need to be initialized later on, but parts that do not need
    to be started during the first time initialization of the dit.

Arguments:

    StartupParam - Pointer, currently unused but required by the thread-
        creation call.

Return Value:

    This routine returns an unsigned value, zero for successful completion,
    otherwise a non-zero error code.

    // BUG: Need to define meaningful error codes for this routine.

--*/

{
    DWORD    err;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    ulThreadId = 0;
    THSTATE *pTHS = NULL;

    __try
    {
        pTHS = InitTHSTATE(CALLERTYPE_INTERNAL );
        if ( NULL == pTHS ) {
            KdPrint(("DS: InitTHSTATE failed\n"));
            LogAndAlertUnhandledError(1);
            return(STATUS_INTERNAL_ERROR);
        }

        // Start the SD propagator thread.
        if(!_beginthreadex(NULL,
                           0,
                           SecurityDescriptorPropagationMain,
                           NULL,
                           0,
                           &ulThreadId)) {

            // Could not create the main thread.
            LogAndAlertUnhandledError(1);
            NtStatus = STATUS_INTERNAL_ERROR;
            __leave;
        }

        // Start task scheduler. There might be some tasks already in the queue.
        StartTaskScheduler();

        // The try-except block is used to handle all but two exceptions,
        // access violations (historical from Exchange code) and break-
        // points.

        if (FALSE == DsaWaitUntilServiceIsRunning("rpcss"))
        {
            KdPrint(("DS: DsaWaitUntilServiceIsRunning returned FALSE\n"));
            LogUnhandledError( ERROR_SERVICE_REQUEST_TIMEOUT );
            gDelayedStartupReturn = STATUS_INTERNAL_ERROR;
            SetEvent(hevDelayedStartupDone);
            NtStatus = STATUS_INTERNAL_ERROR;
            __leave;
        }

        KdPrint(("DS: RPC initialization completed\n"));


        //
        // Wait for afd to be installed. We need afd for to startup winsock.
        //

        if (FALSE == DsaWaitUntilServiceIsRunning("afd"))
        {
            KdPrint(("DS: DsaWaitUntilServiceIsRunning for the afd service returned FALSE\n"));
            LogUnhandledError( ERROR_SERVICE_REQUEST_TIMEOUT );
            // Oh well, try to initialize anyway
        }

        //
        // Wait for dns to initialize. This fixes a problem were we come up before dns
        // is ready to resolve addresses.
        // Don't wait during setup because dnscache is not allowed to autostart during setup
        //

        if (!IsSetupRunning()) {
            if (FALSE == DsaWaitUntilServiceIsRunning("dnscache"))
            {
                KdPrint(("DS: DsaWaitUntilServiceIsRunning for the dnscache service returned FALSE\n"));
                LogUnhandledError( ERROR_SERVICE_REQUEST_TIMEOUT );
                // Oh well, try to initialize anyway
            }
        }

        //
        // Wait for sam to initialize. This is to fix a problem where LDAP does
        // an acquireCredentialsHandle before the machine account has been initialized
        // by SAM
        //

        if ( !DsWaitForSamService( ) ) {
            KdPrint(("DS: DsWaitForSamService failed\n"));
            LogUnhandledError( ERROR_SERVICE_REQUEST_TIMEOUT );
        }

        // Subsequent failures after this point shouldn't necessarily
        // force an error return, since the system can run with limited
        // functionality, and the DS will be locally available to this
        // DC, giving the administrator a chance to correct things.

        // LDAP server/agent - requires Atq to run, but TCP isn't always available
        //  during setup so don't bother starting LDAP in that case.

        if (!IsSetupRunning()) {
            NtStatus = DoLdapInitialize();

            if (!NT_SUCCESS(NtStatus)) {
                LogUnhandledError(NtStatus);
                NtStatus = STATUS_SUCCESS;

                //
                //  Allow system to boot. Might be able to fix the problem if we
                //  continue.
                //
            }
        } else {
            DPRINT(0, "NOT STARTING LDAP since this is setup time.\n");
        }

        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_STARTED,
                 szInsertSz(VER_PRODUCTVERSION_STR),
                 szInsertSz(FLAVOR_STR),
                 0);


        // Setting of NETLOGON Service bits is done in SetSynchronized

        //
        // Load the lsa dll
        //
        if ( gfRunningInsideLsa ) {

            NtStatus = InitializeLsaNotificationCallback( );

            if ( !NT_SUCCESS( NtStatus ) ) {

                KdPrint(("DS: Failed to initialize Lsa callback: 0x%lx\n", NtStatus ));
                LogUnhandledError(NtStatus);
                __leave;
            }
        }

/*      DaveStr - 4/2/99 - Don't wait on KDC any more.  This has been tested
        by ChandanS.  The idea is that when we are backsyncing and such, we
        should use an external KDC, not the local one.  JeffParh and security
        folks can provide details.

        if (FALSE == DsaWaitUntilServiceIsRunning("KDC"))
        {
            NTSTATUS    StatusToLog = STATUS_INTERNAL_ERROR;

            KdPrint(("DS: DsaWaitUntilServiceIsRunning for KDC returned FALSE\n"));
            //
            // Log the error and allow the system to boot.
            // Administrators might be able to fix the problem
            // after booting the system.
            //

            LogUnhandledError( StatusToLog );
            NtStatus = STATUS_SUCCESS;
        }
*/

        // Replication initialization
        if (err = InitDRA( pTHS )) {
            KdPrint(("DRA Initialize failed\n"));
            LogAndAlertUnhandledError(err);
            NtStatus = STATUS_INTERNAL_ERROR;
            DsaExcept(DSA_EXCEPTION, STATUS_INTERNAL_ERROR,  0);
        }

        // Start RPC after InitDRA because incoming calls depend on the
        // replication data structures being set up

        KdPrint(("DS: Registering endpoints and interfaces with RPCSS\n"));

        // Get the EXCHANGE parameters. They describe whether we start NSPI or not
        GetExchangeParameters();

    if (!IsSetupRunning()) {
        // Initialize RPC name-service parameters and protocols.

        MSRPC_Init();

        // Initialize the DRA and DSA RPC. The DRA is always started,
        // however the DSA RPC interface is not presented until after
        // the DIT has been initialized.

        StartDraRpc();
        StartNspiRpc();

            //
            // Check whether the dsaop interface should be started and start
            // it if so.
            //
            InsertInTaskQueue(TQ_CacheScriptOptype,
                              NULL,
                              0);

            // Register the RPC endpoints with the RPCSS, and start the RPC
        // server.

        MSRPC_Install(gfRunningInsideLsa);
    } else {
        DPRINT(0,"Not starting up DRA interface since a setup is in progress!\n");
    }

        // KCC should start after DRA initialization because some of the
        // operations performed by the KCC, such as ReplicaAdd, expect certain
        // global structures to be initialized.
        if ( gfRunningInsideLsa )
        {
            // Start the KCC.

            __try
            {
                NtStatus = KccInitialize();
            }
            __except( HandleAllExceptions(GetExceptionCode()) )
            {
                NtStatus = GetExceptionCode();
            }

            if ( !NT_SUCCESS( NtStatus ) )
            {
                KdPrint(("DS: KccInitialize returned 0x%08X!\n", NtStatus));
                Assert(!"KCC startup failed -- mismatched ntdskcc.dll/ntdsa.dll?");
                LogUnhandledError(NtStatus);
                NtStatus = STATUS_SUCCESS;
                __leave;
            }
        }
        else {
            DPRINT (0, "Skipping Initialization of KCC......\n");
        }

#if DBG

        // So we can tell when the DS server is up and running.
        // Kept simple enough that we don't get complaints.
        Beep(440, 1000);
        DPRINT(0,"DS Server initialized, waiting for clients...\n");

#endif

        // The task queue may not be running if we arent running normallly.  In
        // those cases, we shouldn't insert anything.  This code path should
        // only be called if DsaIsRunning, so rather than using a run-time if,
        // compile in a debug only check.
        Assert(DsaIsRunning());

        if (!gfDisableBackgroundTasks) {
            BOOL fNeedToUpdateHiddenFlags = FALSE;
            // The tasks in this branch are housekeeping work that is not
            // vital for the short term operation of the DS, but which
            // might interfere with performance measurements by springing
            // up unexpectedly.  These are all recurring tasks, so not
            // scheduling them now should prevent them from ever running.

            // schedule FPO cleanup to start in 30 minutes.
            memset(&gFPOCleanupPagedResult, 0, sizeof(PAGED_RESULT));
            InsertInTaskQueue(TQ_FPOCleanup, NULL, THIRTY_MINS);

            // schedule garbage collection to start in 15 minutes.
            InsertInTaskQueue(TQ_GarbageCollection, NULL, FIFTEEN_MINS);

            // schedule replication latency checks
            InsertInTaskQueue(TQ_CheckReplLatency, NULL, SIXTY_MINS);

            // schedule garbage collection for dynamic objects (entryTTL)
            // to start in 15 minutes.
            InsertInTaskQueue(TQ_DeleteExpiredEntryTTLMain, NULL, FIFTEEN_MINS);

            // schedule partial replica purging task
            InsertInTaskQueue(TQ_PurgePartialReplica,
                              NULL,
                              PARTIAL_REPLICA_PURGE_CHECK_INTERVAL_SECS);

            // schedule Stale Phantom Cleanup daemon to start in half an hour.
            InsertInTaskQueue(TQ_StalePhantomCleanup,
                              (void*)((DWORD_PTR) PHANTOM_CHECK_FOR_FSMO),
                              THIRTY_MINS);

            // schedule Link cleanup to start in 30 minutes.
            // This is the recurring task, so pass TRUE as the param.
            InsertInTaskQueue(TQ_LinkCleanup, (PVOID)TRUE, THIRTY_MINS);

            // schedule Quota table rebuild if necessary
            //
            if ( !gAnchor.fQuotaTableReady )
                {
                InsertInTaskQueue( TQ_RebuildQuotaTable, NULL, TWO_MINS );
                }

            if (gdbFlags[DBFLAGS_SD_CONVERSION_REQUIRED] == '1') {
                // SD table was not present -- must be upgrading an existing old-style DIT.
                // Enqueue forced SD propagation from root to rewrite SDs in the new format.
                DPRINT(0, "Old-style DIT: enqueueing forced SD propagation for the whole tree\n");
                err = SDPEnqueueTreeFixUp(pTHS, ROOTTAG, SD_PROP_FLAG_FORCEUPDATE);
                if (err == 0) {
                    // successfully enqueued SD update op. Reset flag
                    gdbFlags[DBFLAGS_SD_CONVERSION_REQUIRED] = '0';
                    fNeedToUpdateHiddenFlags = TRUE;
                }
            }
            if (gdbFlags[DBFLAGS_ROOT_GUID_UPDATED] != '1') {
                // need to update root GUID
                err = DBUpdateRootGuid(pTHS);
                if (err == 0) {
                    // successfully updated root guid.
                    gdbFlags[DBFLAGS_ROOT_GUID_UPDATED] = '1';
                    fNeedToUpdateHiddenFlags = TRUE;
                }
            }
            if (fNeedToUpdateHiddenFlags) {
                DBUpdateHiddenFlags();
            }
        }

        if (gfRunningInsideLsa) {
            // schedule writing of server info (SPN, etc.) to start in 45
            // seconds.
            InsertInTaskQueue(TQ_WriteServerInfo,
                              (void*)((DWORD_PTR) SERVINFO_PERIODIC),
                              45);

        }

        // schedule HierarchyTable construction
        if(gfDoingABRef) {
            InsertInTaskQueue(TQ_BuildHierarchyTable,
                              (void*)((DWORD_PTR) HIERARCHY_PERIODIC_TASK),
                              gulHierRecalcPause);
        }

        // schedule the behaviorVersionUpdate thread to start in 1 minute.
        InsertInTaskQueue(TQ_BehaviorVersionUpdate, NULL, 60);

        // schedule checkpointing for NT4 replication  in fifteen minutes
        InsertInTaskQueue(TQ_NT4ReplicationCheckpoint, NULL, FIFTEEN_MINS);

        // schedule protection of admin groups in fifteen minutes.
        InsertInTaskQueue(TQ_ProtectAdminGroups,NULL,FIFTEEN_MINS);

        // schedule group caching task
        InsertInTaskQueue(TQ_RefreshUserMemberships,NULL,FIFTEEN_MINS);

        // schedule ancestors index size estimation in 5 minutes.
        InsertInTaskQueue(TQ_CountAncestorsIndexSize,NULL,FIVE_MINS);

        // schedule ValidateDsaDomain to start immediately.
        InsertInTaskQueue(TQ_ValidateDsaDomain, NULL, 0);

        // check if we need to update NTFS security on NTDS folders
        CheckSetDefaultFolderSecurity();

        gDelayedStartupReturn = STATUS_SUCCESS;

    }
    __except (HandleMostExceptions(GetExceptionCode()))
    {
        gDelayedStartupReturn = STATUS_INTERNAL_ERROR;
    }

    SetEvent(hevDelayedStartupDone);

    free_thread_state();  // in case we still have one

    // This routine has been observed to hang indefinitely, but fortunately
    // it doesn't require a thread state, so we can destroy our state before
    // calling it, which will let us shut down cleanly when the unthinkable
    // happens again.
    DsaInitializeTrace( );

    return(NtStatus);
} // DsaDelayedStartupHandler


void
DsaWaitShutdown(
    IN BOOLEAN fPartialShutdown
    )

/*++

Routine Description:

    This routine is responsible for cleaning up the services and interfaces
    started by DsaDelayedStartupHandler.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus;
    int i;
    DWORD err;
    HANDLE ah[10];
#if DBG
    char * aNames[10];
#endif

    //
    // First wait until the delayed startup thread has finished
    //
    NtStatus = DsWaitUntilDelayedStartupIsDone();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrint(("DS: DsWaitUntilDelayedStartupIsDone failed, error 0x%08X!\n", NtStatus));
    }

    // Wait for LDAP server/agent to close down

    WaitLdapStop();

    DPRINT(0,"Shutting down RPC...\n");

    MSRPC_Uninstall( !fPartialShutdown );

    // wait for all RPC calls to complete

    // MSRPC_WaitForCompletion is not returning in the shutdown environment.

    // Need to find out why this routine is taking longer than 1 - 4 minutes
    // to return during system shutdown. MSRPC_Uninstall (above) calls
    // RpcMgmtStopServerListening, which will shutdown the RPC server,
    // implying that remaining active RPCs are outstanding, hence the
    // wait. It is possible that the outstanding RPC (stack indicates
    // RpcBindingFree) is waiting on LPC (NtReplyWaitReceivePort) which
    // may have been shut down at this point (of system shutdown)?

    // DonH.  We're having too many problems with junk
    // going on with lingering RPC threads touching data structures that
    // we free during shutdown, so we've got to try this one again in order
    // to reliably get the RPC threads all gone.

    DPRINT(0,"RPC uninstall done, waiting for RPC completion\n");

    // MSRPC_WaitForCompletion();
    // DPRINT(0,"RPC shutdown complete\n");
    DPRINT(0, "RpcMgmtWaitServerListen hangs, so we're skipping it\n");

    // Shut down the KCC.
    if ( gfRunningInsideLsa ) {
        __try {
            NtStatus = KccUnInitializeWait( KCC_COMPLETION_TIMEOUT );
        }
        __except( HandleAllExceptions(GetExceptionCode()) ) {
            NtStatus = GetExceptionCode() ;
        }

        if ( !NT_SUCCESS( NtStatus ) ) {
            KdPrint(("DS: KCC shutdown failed, error 0x%08X!\n", NtStatus));
            Assert( !"KCC shutdown failed!" );
        }
    }

#if DBG
#define TrackShutdown(x) if (x) { ah[i] = x; aNames[i] = #x ; i++;}
#else
#define TrackShutdown(x) if (x) { ah[i] = x; i++;}
#endif
    // Wait (briefly) for all the worker threads to end.  Some threads are,
    // unfortunately, waited on elsewhere.  Here would have been a good spot.
    i = 0;
    TrackShutdown(hDirNotifyThread);
    TrackShutdown(hReplNotifyThread);
    TrackShutdown(hAsyncSchemaUpdateThread);
    TrackShutdown(hevSDPropagatorDead);
    TrackShutdown(hMailReceiveThread);

    DPRINT(0, "Waiting for all internal worker threads to halt\n");
    err = WaitForMultipleObjects(i,
                                 ah,
                                 TRUE,
                                 5 * 1000);

    if (err == WAIT_TIMEOUT) {
        NTSTATUS status;
        THREAD_BASIC_INFORMATION tbi;
        BOOL fBreak = FALSE;

        DPRINT(0, "Not all worker threads exited! Hoping for the best...\n");
#if DBG
        for ( ; i>0; i--) {
            status = NtQueryInformationThread(ah[i-1],
                                              ThreadBasicInformation,
                                              &tbi,
                                              sizeof(tbi),
                                              NULL);
            if (NT_SUCCESS(status) && (tbi.ExitStatus == STATUS_PENDING)) {
                DPRINT2(0,
                        "Thread 0x%x ('%s') is still running\n",
                        tbi.ClientId.UniqueThread,
                        aNames[i-1]);
                // Bug 28251 -- If ISM is running, we know the mail receive
                // thread won't return, as the thread is blocked in LRPC to
                // ISMSERV and there's no way to cancel an LRPC.
                fBreak |= (ah[i-1] != hMailReceiveThread);
            }
        }
#ifdef INCLUDE_UNIT_TESTS
        // We don't want this going off in public builds just yet...
        if (fBreak) {
            DebugBreak();
        }
#endif
#endif
    }
    else if (err == WAIT_FAILED) {
        err = GetLastError();
        DPRINT1(0, "Wait for worker threads failed with error 0x%x\n", err);
#ifdef INCLUDE_UNIT_TESTS
        // We don't want this going off in public builds just yet...
        DebugBreak();
#endif
    }
    else {
        // Success.  Had to happen sometime.
        DPRINT(0, "Worker threads exited successfully\n");
    }

    DPRINT(0, "Waiting for in-process, ex-module clients to leave\n");
    err = WaitForSingleObject(hevDBLayerClear, 5000);
    if (err == WAIT_TIMEOUT) {
        // Some thread is still out there with an open DBPOS,
        // or at least the DBlayer thinks so.
        DPRINT(0, "In-process client threads failed to exit\n");
        if (IsDebuggerPresent()) {
            // We've never figured out anything when ntsd isn't running
            // and all we've got is kd, so don't bother to break in
            // that situation.
            DebugBreak();
        }
    }
    else {
        DPRINT(0, "All client database access completed\n");
    }
}
#undef TrackShutdown

void
DsaInitGlobals(
    void
)

/*++

Routine Description:

    This routine is a post-facto attempt to initialize all relevant
    globals variables in ntdsa.dll to what they are defined statically.
    Currently it only resets the values found in the taskqueue (none, the
    module is self-contained), the dblayer, the schema cache, and the general
    state of the system (ie runnning, shutdown, etc).  It does not attempt
    to reset the state of interface modules as they should only be started
    when the ds is fully operational, at which shutdown means operating
    system shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{

    // from dsamain.c
    DsaSetIsRunning();
    gtimeDSAStarted = DBTime();
    eServiceShutdown = eRunning;
    gbFsmoGiveaway = FALSE;
    gResetAfterInstall = FALSE;
    gpRootDomainSid = NULL;
    gfTaskSchedulerInitialized = FALSE;

    // from the schema cache module
    iSCstage = 0;

    // from the dblayer module
    pAddListHead = NULL;
    gFirstTimeThrough = TRUE;

    // the ubiquitous gAnchor
    memset(&gAnchor, 0, sizeof(DSA_ANCHOR));
    gAnchor.pLocalDRSExtensions = &LocalDRSExtensions;
    gAnchor.pLocalDRSExtensions->pid = _getpid();

    // The MAPI hierarchy table
    HierarchyTable=NULL;

    // The inital sync mechanism
    gpNCSDFirst = NULL;
    gulNCUnsynced = 0;
    gulNCUnsyncedWrite = 0;
    gulNCUnsyncedReadOnly = 0;
    gfInitSyncsFinished = FALSE;

    //set Datasource to Wire (used in Install From Media)
    DataSource = eWireInstall;

}

NTSTATUS
DsInitialize(
        ULONG ulFlags,
        IN  PDS_INSTALL_PARAM   InstallInParams  OPTIONAL,
        OUT PDS_INSTALL_RESULT  InstallOutParams OPTIONAL
    )

/*++

Routine Description:

    This routine is the initialization routine for the DS when it is run as
    a DLL (i.e. ntdsa.dll) and not as a service or stand-alone executable. This
    routine must be called before calling other DS routines (XDS, LDAP, etc.).

    Global flags are set to indicate to the rest of the code base whether
    the DSA is running as a DLL or as a service. The main initialization
    subroutine, DoInitialize, is called to setup the basic DS data structures.

    A helper thread is also started to handle the initialization of any
    component that requires other system services to be started first. The
    most notable is RPCSS, which must start before the DS RPC endpoints are
    registered.

Arguments:

    ulFlags - flags to control the operation of the DS; for example, sam
              loopback

Return Value:

    This routine returns STATUS_SUCCESS or DsInitialize error codes.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG ulThreadId = 0;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    unsigned fInstall;
    int argc = 2;
    char *argv[] = {"lsass.exe", "-noconsole"};

    gfDoSamChecks = ( ulFlags & DSINIT_SAMLOOP_BACK  ? TRUE : FALSE );
    fInstall = ( ulFlags & DSINIT_FIRSTTIME  ? TRUE : FALSE );

    gfRunningAsExe = FALSE;

    // Do the common Initialization that is required to set up the DSA, DRA,
    // and Jet. When running as a DLL, DoInitialize does not attempt to set
    // up any RPC, ATQ, or LDAP components. Instead, these are handled by
    // the below thread.

    __try {

        NtStatus = DoInitialize(argc, argv, fInstall, InstallInParams, InstallOutParams);

        if (NT_SUCCESS(NtStatus) && !DsaIsInstalling() && !gResetAfterInstall) {


            // If DoInitialize fails, SAM initialization will fail, leading to
            // LSA's initialization failure. If this occurs, SCM will not be
            // able to start RPCSS, hence any attempt to register endpoints in
            // the DsaDelayedStartupHandler thread will wait forever.
            // Consequently, return the error so that SAM and LSA can bail out.

            hStartupThread = (HANDLE) _beginthreadex(NULL,
                                                     0,
                                                     DsaDelayedStartupHandler,
                                                     NULL,
                                                     0,
                                                     &ulThreadId);

            if (hStartupThread == NULL) {
                // Could not create the main thread.

                DoShutdown(FALSE, FALSE, FALSE);
                NtStatus = STATUS_UNSUCCESSFUL;

            }


        }


    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        NtStatus = STATUS_UNSUCCESSFUL;
    }

    return(NtStatus);
}


// This function may be called to notify the DS that shut down is imminent.
// Any shut down work that can be started ahead of time will be initiated on
// worker threads.  The goal is to make the call to DsUninitialize complete
// faster.
//
// NOTE:  once this call is made, ordinary use of the DS may be adversely
// affected

NTSTATUS
DsPrepareUninitialize(
    VOID
    )
{
    BOOL fDestroyTHS = FALSE;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    // get a thread state, if one wasn't provided

    if (!THQuery()) {
        fDestroyTHS = TRUE;
        if (THCreate(CALLERTYPE_INTERNAL)) {
            return STATUS_UNSUCCESSFUL;
        }
    }

    __try {

        // tell the database that we are going to shut down soon

        DBPrepareEnd();

    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
            NtStatus = STATUS_UNSUCCESSFUL;
    }

    // cleanup

    if (fDestroyTHS) {
        THDestroy();
    }
    return NtStatus;
}


// This function is called to shut down the DS.
// It is assumed that this is called from a point
// where Server Listening has already been stopped

NTSTATUS
DsUninitialize(
    BOOL fExternalOnly
    )
{
    ULONG  dwException, ulErrorCode, dsid;
    PVOID dwEA;
    BOOL  StartupThreadCleanup = TRUE;
    NTSTATUS status = STATUS_SUCCESS;

    // Check if DsInitialize succeeded
    if (hStartupThread == NULL)
        StartupThreadCleanup = FALSE;

    __try {

        switch ( eServiceShutdown )
        {

            case eRunning:

                // Set the event telling everyone we want to shut down
                eServiceShutdown= eRemovingClients;
                gUpdatesEnabled = FALSE;
                SetEvent(hServDoneEvent);

                // Tell clients to go away and workers to quit
                DsaTriggerShutdown(FALSE);

                DsaStop(FALSE);

                // Wait for clients and workers to finish up and leave
                DoShutdown(StartupThreadCleanup, FALSE, fExternalOnly);

                if ( fExternalOnly )
                {
                    //
                    // This is all we have to do
                    //
                    leave;
                }


            case eRemovingClients:


                // Close down JET and secure the database
                eServiceShutdown = eSecuringDatabase;
                DBEnd();


            case eSecuringDatabase:


                // Free up any resources.  Not really needed unless we're going
                // to get restarted without a process restart.
                eServiceShutdown = eFreeingResources;

                
                // Now that we know we have no clients that 
                // may require some access checking, we can
                // release global Authz RM handles
                ReleaseAuthzResourceManager();

            case eFreeingResources:

                eServiceShutdown = eStopped;
                LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_NORMAL_SHUTDOWN,
                         NULL,
                         NULL,
                         NULL);

                DEBUGTERM();
                KdPrint(("DS: DoShutdown returned, waiting for thread termination\n"));

                // BUG: DsUninitialize may not finish before winlogon shuts
                // down.

                // Wait till shut down is complete. Since this code is executed
                // during system shutdown, it should wait at most a
                // minute. NOTE: winlogon.exe by default will only wait 20
                // seconds, which is shorter than this time-out of one
                // minute. The registry can be tweeked so that winlogon waits
                // for one minute.

                if (hStartupThread) {
                    WaitForSingleObject(hStartupThread, (1000 * 60));
                }

                // Close the thread handle
                CloseHandle(hServDoneEvent);
                hServDoneEvent = NULL;

                //
                // End of shutdown
                //
                break;

            default:

                Assert( dsaUserMode == eSingleUserMode || !"Bad switch statement" );

        }

    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {

        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

//
// This function is called to change the DS boot option
// ( system boot, floppy boot, or boot password ).
//
NTSTATUS
DsChangeBootOptions(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    dwException;
    PVOID    dwEA;
    ULONG    ulErrorCode,dsid;

    __try
    {
        NtStatus = PEKChangeBootOption(
                    BootOption,
                    Flags,
                    NewKey,
                    cbNewKey
                    );
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
            NtStatus = STATUS_UNSUCCESSFUL;
    }

    return(NtStatus);
}

//
// This function is called to get current value of
// the boot option.
//

WX_AUTH_TYPE
DsGetBootOptions(VOID)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    dwException;
    PVOID    dwEA;
    ULONG    ulErrorCode,dsid;
    WX_AUTH_TYPE BootOption;

    __try
    {
        BootOption = PEKGetBootOptions();
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
            BootOption = WxNone;
    }

    return BootOption;
}

// Entry point function when the DS is started as an Exe.
// This does work of the old main function in the DS. The main function
// has now been moved to another file, which just calls this function
// when the DS is being stared as an Exe.

int __cdecl DsaExeStartRoutine(int argc, char *argv[])
{
    BOOL fInitializeSucceeded = FALSE;
    BOOL fDelayedInitSucceeded = FALSE;
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG  ulThreadId;
    VOID *pOutBuf = NULL;

    // we are running inside the DSAMAIN.EXE console app,
    // not as part of the LSA
    gfRunningInsideLsa = FALSE;
    gfRunningAsExe =TRUE;

    DPRINT (0, "Running as an EXE\n");

    __try { /* finally */
      __try { /* except */

          // Do the common initialization
          Status = DoInitialize(argc, argv, 0, NULL, NULL);
          if (Status != STATUS_SUCCESS) {
              __leave;
          }

          // Our database is initialized at this point
          fInitializeSucceeded = TRUE;

          //
          // The delayed interface startup thread is started here since
          // DsaMain is only called when the directory service is run
          // as a process and the interface cleanup is done by the process
          // shutdown. Not to mention that we don't want the interfaces
          // started during the install phase of the ds.
          //
          hStartupThread = (HANDLE) _beginthreadex(NULL,
                                                   0,
                                                   DsaDelayedStartupHandler,
                                                   NULL,
                                                   0,
                                                   &ulThreadId);

          if (hStartupThread == NULL) {
              // Could not create the interface thread.
              Status = STATUS_UNSUCCESSFUL;
          }
          fDelayedInitSucceeded = TRUE;

          /* Ask NT to free our startup memory usage */
          SetProcessWorkingSetSize(GetCurrentProcess(), (DWORD)-1, (DWORD)-1);

#if DBG
          if (fProfiling){
              getchar();
          }
          else {
#endif
          // Uncomment the following to force garbage collection
          // upon dsamain.exe startup - good for testing purposes!
          /*
          InitTHSTATE(&pOutBuf, CALLERTYPE_INTERNAL);
          Garb_Collect(0x7fffffff);
          free_thread_state();
          */

          // wait for event to be signalled
          WaitForSingleObject(hServDoneEvent, INFINITE);
#if DBG
          }
#endif

      }
      __except (HandleMostExceptions(GetExceptionCode())) {
          ;
      }

    }
    __finally {
        DsUninitialize(FALSE);
        // Shut down if we successfully initialized in the first place
        //if (fInitializeSucceeded) {
        //    DsaTriggerShutdown();
        //    DsaStop();
        //    DoShutdown(fDelayedInitSucceeded, FALSE, FALSE);
        //}
    }

    return Status;

} /* DsaExeStartRoutine */

void
DsaTriggerShutdown(BOOL fSingleUserMode)
/*++
 *   This routine pokes and prods at various portions of the DSA to start
 *   a shutdown, which really means stopping activity.  Nothing called by
 *   this routine should wait for activity to cease, just trigger the
 *   shutdown activity.  Another routine (below) will wait to ensure that
 *   the everything has stopped.
 *
 *   if  fSingleUserMode is set, we only trigger the shutdown of interfaces
 *   we don't shutdown the database
 */
{
    Assert( eRemovingClients == eServiceShutdown || fSingleUserMode);

    if (eStopped == eServiceShutdown) {
        // we have already stopped running
        return;
    }

    // Trigger various threads to terminate
    if ( gfRunningInsideLsa ) {
        KccUnInitializeTrigger();
    }

    ShutdownTaskSchedulerTrigger();

    TriggerLdapStop();

    // Abandon all outbound RPC calls
    RpcCancelAll();

    // Cause the DBlayer to prepare for shutdown
    if (!fSingleUserMode) {
        DBQuiesce();
    }

}

// This does the common shutdown handling
// Its job is to tell the service control manager
// that we are about to shut down, shut down JET and then declare
// as having shut down
void
DoShutdown(BOOL fDoDelayedShutdown, BOOL fShutdownUrgently, BOOL fPartialShutdown)
{
    NTSTATUS NtStatus;

    // If urgent shutdown is requested bring down the process immediately
    if (fShutdownUrgently && !gfRunningInsideLsa)
        exit(1);

    fAssertLoop = FALSE;

    //
    // Stop doing Lsa notification
    //
    if ( gfRunningInsideLsa ) {

        UnInitializeLsaNotificationCallback();

    }

    if (fDoDelayedShutdown) {
        DsaWaitShutdown( (BOOLEAN) fPartialShutdown );
    }

}

// This function updates the NTBACKUP exclusion key so that it doesn't
// backup/restore the NTDS specific directories as part of filesystem B/R.
BOOL
FUpdateBackupExclusionKey()
{
    char szDBPath[MAX_PATH];
    char szLogPath[MAX_PATH];
    char szNTDSExclusionList[2 * MAX_PATH + 1]; // reg_multi_sz => null-terminated strings terminated by two nulls at the end
    char *szTemp;
    ULONG cb = 0;
    HKEY hkey = NULL;

    // get the db file with full path
    if (GetConfigParam(FILEPATH_KEY, szDBPath, sizeof(szDBPath)))
    {
        // Unable to get the DSA DB path - log event & bailout
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(FILEPATH_KEY),
            NULL,
            NULL);

        return FALSE;
    }

    // get the log file path
    if (GetConfigParam(LOGPATH_KEY, szLogPath, sizeof(szLogPath)))
    {
        // Unable to get the DSA DB path - log event & bailout
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(LOGPATH_KEY),
            NULL,
            NULL);

        return FALSE;
    }

    // szDBPath will contain database file name with full path;
    // truncate the "ntds.dit" at the end and replace it with a wildcard
    // example: c:\winnt\ntds\ntds.dit => c:\winnt\ntds\*
    szTemp = strrchr(szDBPath, '\\');
    if (szTemp == NULL || *(szTemp+1) == '\0')
    {
        // either no backslash, or it is the last char. Either way, the path is bad.
        return FALSE;
    }

    strcpy(szTemp, "*");

    // Append wildcard to szLogPath
    // example: d:\winnt\ntdslog => d:\winnt\ntdslog\*
    // Find the last char in the szLogPath
    szTemp = szLogPath + strlen(szLogPath) - 1;
    if (szTemp < szLogPath) {
        // szLogPath is empty??? This is no good.
        return FALSE;
    }
    if (*szTemp == '\\')
    {
        // the path ends with a backslash
        strcpy(szTemp+1, "*");
    }
    else
    {
        // the path does not end with a backslash
        strcpy(szTemp+1, "\\*");
    }

    // copy the DB path with wildcard extension to the exclusion list
    szTemp = szNTDSExclusionList;

    cb = (ULONG) strlen(szDBPath) + 1;
    strcpy(szTemp, szDBPath);

    // point szTemp to the byte after the terminating null on the exclusion list
    szTemp += cb;

    if (_stricmp(szDBPath, szLogPath))
    {
        // DBPath and LogPath are different; append logpath also to the exclusion list
        ULONG cbLogPath = (ULONG) strlen(szLogPath) + 1;

        strcpy(szTemp, szLogPath);

        cb += cbLogPath;

        // point szTemp to the byte after the terminating null
        szTemp += cbLogPath;
    }

    // multi-sz needs two-null terminations at the end of strings. add the second null;
    *szTemp = '\0';
    cb++;

    // open the backup exclusion key in the registry
    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE, BACKUP_EXCLUSION_SECTION, 0, KEY_ALL_ACCESS, &hkey))
    {
        // unable to open the global filebackup key
        return FALSE;
    }

    if (ERROR_SUCCESS != RegSetValueExA(hkey, NTDS_BACKUP_EXCLUSION_KEY, 0, REG_MULTI_SZ, szNTDSExclusionList, cb))
    {
        // unable to set NTDS Backup Exclusion registry value
        RegCloseKey(hkey);
        return FALSE;
    }

    // close the backup exclusion key
    RegCloseKey(hkey);

    // successfully updated the backup exclusion key
    return TRUE;
}

// Put all of our crit sec initialization, event creation, etc, in one
// routine so that it can be invoked from things like mkdit which link
// to ntdsa but don't go through normal initialization.
void DsInitializeCritSecs()
{

    SECURITY_ATTRIBUTES             saEventSecurity;
    INT                             iRet;
    BOOL                            fCritsec = TRUE;

    saEventSecurity.lpSecurityDescriptor = NULL;
    // Setting security up for events.
    iRet = ConvertStringSecurityDescriptorToSecurityDescriptorW(
        DEFAULT_EVENT_SD,
        SDDL_REVISION_1,
        &saEventSecurity.lpSecurityDescriptor,
        &saEventSecurity.nLength);

    if(!iRet){
        // This shouldn't ever fail, unless we're under memory preassure ... and if
        // we're under memory preassure at this point in boot, then this DC probably
        // should probably be shot, and put out of it's misery.
        gbCriticalSectionsInitialized = FALSE;
        DPRINT1(0, "ConvertStringSecurityDescriptorToSecurityDescriptorW() failed with %d\n", GetLastError());
        Assert(!"ConvertStringSecurityDescriptorToSecurityDescriptorW() failed ... should be out of memory error!");
        return;
    }
    Assert(saEventSecurity.lpSecurityDescriptor && saEventSecurity.nLength);

    saEventSecurity.bInheritHandle = FALSE;

    __try {
        // This mutex is not shared with any other process, so there is no need
        // to name it. Also, an unnamed sync object can not get hijacked.
        hmtxAsyncThread = CreateMutex(NULL, FALSE, NULL);

        InitializeCriticalSection(&csNotifyList);
        SyncCreateRWLock(&rwlDirNotify);
        InitializeCriticalSection(&csSpnMappings);
        InitializeCriticalSection(&csDirNotifyQueue);
        InitializeCriticalSection(&csServerContexts);
        fCritsec = fCritsec
            && InitializeCriticalSectionAndSpinCount(&gAnchor.CSUpdate, 4000);
    #ifdef CACHE_UUID
        InitializeCriticalSection(&csUuidCache);
    #endif

        hmtxSyncLock = CreateMutex(NULL, FALSE, NULL);
        InitializeCriticalSection(&csSDP_AddGate);
        InitializeCriticalSection(&csAsyncThreadStart);
        InitializeCriticalSection(&csAOList);
        InitializeCriticalSection(&csLastReplicaMTX);
        InitializeCriticalSection(&csNCSyncData);
        InitializeCriticalSection(&gcsFindGC);
        InitializeCriticalSection(&csUncUsn);
        fCritsec = fCritsec
            && InitializeCriticalSectionAndSpinCount(&csDNReadLevel1List, 4000);
        fCritsec = fCritsec
            && InitializeCriticalSectionAndSpinCount(&csDNReadLevel2List, 4000);
        InitializeCriticalSection(&csDNReadGlobalCache);
        SyncCreateBinaryLock(&blDNReadInvalidateData);
        InitializeCriticalSection(&csSessions);
        InitializeCriticalSection(&csJetColumnUpdate);
        InitializeCriticalSection(&csSchemaCacheUpdate);
        InitializeCriticalSection(&csDitContentRulesUpdate);
        InitializeCriticalSection(&csOrderClassCacheAtts);
        InitializeCriticalSection(&csNoOfSchChangeUpdate);
        InitializeCriticalSection(&csMapiHierarchyUpdate);
        InitializeCriticalSection(&csGCDListProcessed);
        InitializeCriticalSection(&csGroupTypeCacheRequests);
        fCritsec = fCritsec
            && InitializeCriticalSectionAndSpinCount(&csThstateMap, 4000);
        InitializeCriticalSection(&csDsaWritable);
        InitializeCriticalSection(&csHiddenDBPOS);
        InitializeCriticalSection(&csRidFsmo);
        InitializeCriticalSection(&gcsDrsuapiClientCtxList);
        InitializeCriticalSection(&gcsDrsRpcServerCtxList);
        InitializeCriticalSection(&gcsDrsRpcFreeHandleList);
        InitializeCriticalSection(&gcsDrsAsyncRpcListLock);
        InitializeListHead(&gDrsAsyncRpcList);
        InitializeCriticalSection(&csHeapFailureLogging);
        fCritsec = fCritsec
            && InitializeCriticalSectionAndSpinCount(&csLoggingUpdate, 4000);
        InitializeCriticalSection(&csGCState);
        InitializeCriticalSection(&csIndexCreation);

        Assert(fCritsec);

        #if DBG
        BarrierInit(&gbarRpcTest,
                    2,  // num threads
                    1   // timeout
                    );
        #endif

#if DBG
        gbThstateMapEnabled = TRUE;
#else
        gbThstateMapEnabled = IsDebuggerPresent();
#endif

        hevGTC_OKToInsertInTaskQueue = CreateEvent(NULL, TRUE, TRUE, NULL);
        hevSDP_OKToRead       = CreateEvent(NULL, TRUE,  TRUE,  NULL);
        hevSDP_OKToWrite      = CreateEvent(NULL, TRUE,  TRUE,  NULL);
        hevSDPropagatorStart  = CreateEvent(NULL, TRUE,  FALSE, NULL);
        hevSDPropagatorDead   = CreateEvent(NULL, TRUE,  TRUE,  NULL);
        hevSDPropagationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hevEntriesInAOList    = CreateEvent(NULL, TRUE,  FALSE, NULL);
        hevEntriesInList      = CreateEvent(NULL, FALSE, FALSE, NULL);
        hevDRASetup           = CreateEvent(NULL, TRUE,  FALSE, NULL);

        // This event is used to let Winlogon put up UI, so that the screen
        // isn't just blank during the potentially hours long index rebuild.
        //
        hevIndexRebuildUI = CreateEvent(&saEventSecurity, TRUE, FALSE, "NTDS.IndexRecreateEvent");

        hevDelayedStartupDone = CreateEvent(&saEventSecurity, TRUE,  FALSE,
                                            NTDS_DELAYED_STARTUP_COMPLETED_EVENT);
        Assert(hevDelayedStartupDone != NULL);

        hServDoneEvent        = CreateEvent(NULL, TRUE,  FALSE, NULL);
        hevDirNotifyQueue     = CreateEvent(NULL, FALSE, FALSE, NULL);
        hevDBLayerClear       = CreateEvent(NULL, TRUE,  FALSE, NULL);
        hevInitSyncsCompleted = CreateEvent(&saEventSecurity, TRUE,  FALSE,
                                            DS_SYNCED_EVENT_NAME);
        Assert(hevInitSyncsCompleted != NULL);

        // schema reload thread
        evSchema  = CreateEvent(NULL, FALSE, FALSE, NULL);
        evUpdNow  = CreateEvent(NULL, FALSE, FALSE, NULL);
        evUpdRepl = CreateEvent(NULL, TRUE, TRUE, NULL);

        // Test all things which return NULL on failure.  ADD YOURS HERE!

        if (    !hmtxAsyncThread
             || !hmtxSyncLock
             || !hevGTC_OKToInsertInTaskQueue
             || !hevSDP_OKToRead
             || !hevSDP_OKToWrite
             || !hevSDPropagatorStart
             || !hevSDPropagatorDead
             || !hevSDPropagationEvent
             || !hevEntriesInAOList
             || !hevEntriesInList
             || !hevDRASetup
             || !hevIndexRebuildUI
             || !hevDelayedStartupDone
             || !hServDoneEvent
             || !hevDirNotifyQueue
             || !hevDBLayerClear
             || !hevInitSyncsCompleted
             || !evSchema
             || !evUpdNow
             || !evUpdRepl
             || !fCritsec ) {
            gbCriticalSectionsInitialized = FALSE;
            __leave;
        }

        // Let anyone who cares know that we've inited critical sections.
        gbCriticalSectionsInitialized = TRUE;
    }
    __except (HandleAllExceptions(GetExceptionCode())) {
        gbCriticalSectionsInitialized = FALSE;
    }

    if(saEventSecurity.lpSecurityDescriptor != NULL){
        LocalFree(saEventSecurity.lpSecurityDescriptor);
    }
}


//
// This function initializes the thread heap cache
//

BOOL DsInitHeapCacheManagement()
{

    SYSTEM_INFO sysInfo;
    const size_t cbAlign = 256;
    const size_t cbPLSAlign = ((sizeof(PLS) + cbAlign - 1) / cbAlign) * cbAlign;
    size_t iPLS;

    //get the number of CPUs
    GetSystemInfo(&sysInfo);

    Assert(sysInfo.dwNumberOfProcessors>0);

    gcProcessor = (sysInfo.dwNumberOfProcessors>0)?sysInfo.dwNumberOfProcessors:1;

    // allocate PLS
    if (!(grgPLS[0] = VirtualAlloc(NULL, gcProcessor * cbPLSAlign, MEM_COMMIT, PAGE_READWRITE))) {
        Assert(!"Allocation failure.\n");
        return FALSE;
    }

    for (iPLS = 1; iPLS < gcProcessor; iPLS++) {
        grgPLS[iPLS] = (PPLS)((BYTE*)grgPLS[0] + cbPLSAlign * iPLS);
    }

    // init each PLS
    for (iPLS = 0; iPLS < gcProcessor; iPLS++) {

        grgPLS[iPLS]->heapcache.index = HEAP_CACHE_SIZE_PER_CPU;
        if (!InitializeCriticalSectionAndSpinCount(&grgPLS[iPLS]->heapcache.csLock, 4000)) {
            Assert(!"Allocation failure.\n");
            return FALSE;
        }

        SyncCreateRWLock(&grgPLS[iPLS]->rwlGlobalDNReadCache);
        SyncCreateRWLock(&grgPLS[iPLS]->rwlSchemaPtrUpdate);

    }

    return TRUE;
}



    //
    // verify if the behavior version of the binary is compatible
    // with the behavior versions of dsa, domainDNS, and crossrefContainter
    // objects
    //

BOOL VerifyDSBehaviorVersion(THSTATE * pTHS)
{

    DWORD err;

    PVOID dwEA;
    ULONG dwException, ulErrorCode, dsid;
    BOOL fDSASave;

    DBPOS *pDB, *pDBSave;

    LONG lDsaVersion;

    DPRINT(2, "VerifyDSBehaviorVersion entered.\n");

    Assert(    gAnchor.DomainBehaviorVersion >= 0
            && gAnchor.ForestBehaviorVersion >= 0 );

    if (   gAnchor.DomainBehaviorVersion > DS_BEHAVIOR_VERSION_CURRENT
        || gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_VERSION_MIN
        || gAnchor.ForestBehaviorVersion > DS_BEHAVIOR_VERSION_CURRENT
        || gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_VERSION_MIN ) {

        DPRINT(2,"VerifyDSBehaviorVersion: domain/forest incompatible.\n");

        LogEvent8(DS_EVENT_CAT_STARTUP_SHUTDOWN,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_FAILED_VERSION_CHECK,
                  szInsertInt(gAnchor.DomainBehaviorVersion),
                  szInsertInt(gAnchor.ForestBehaviorVersion),
                  szInsertInt(DS_BEHAVIOR_VERSION_CURRENT),
                  szInsertInt(DS_BEHAVIOR_VERSION_MIN),
                  NULL,
                  NULL,
                  NULL,
                  NULL );


        return FALSE;

    }

    //get the ms-DS-Behavior-Version of the nTDSDSA object
    __try {
        DBOpen(&pDB);
        __try {
            err = DBFindDSName(pDB, gAnchor.pDSADN);
            if (err) {
                __leave;
            }
            err = DBGetSingleValue( pDB,
                                    ATT_MS_DS_BEHAVIOR_VERSION,
                                    &lDsaVersion,
                                    sizeof(lDsaVersion),
                                    NULL );
            if (err) {
                if (DB_ERR_NO_VALUE == err ) {
                    lDsaVersion = 0;
                    err = 0;
                }
                else {
                    __leave;
                }
            }

        }
        __finally {
            DBClose(pDB, !err && !AbnormalTermination());
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwEA,
                              &ulErrorCode,
                              &dsid)) {
        DoLogUnhandledError(dsid, ulErrorCode, TRUE);
        err = ulErrorCode;
    }
    if (err) {
        DPRINT(2, "VerifyDSBehaviorVersion: failed to get v_dsa.\n");

        LogEvent( DS_EVENT_CAT_STARTUP_SHUTDOWN,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_UNABLE_TO_CHECK_VERSION,
                  szInsertWin32ErrCode(err),
                  szInsertDN(gAnchor.pDSADN),
                  szInsertWin32Msg(err) );

        return  FALSE;
    }

    if ( lDsaVersion > DS_BEHAVIOR_VERSION_CURRENT ) {

        DPRINT(2,"VerifyDSBehaviorVersion: v_dsa incompatible.\n");

        LogEvent( DS_EVENT_CAT_STARTUP_SHUTDOWN,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_HIGHER_DSA_VERSION,
                  szInsertInt(lDsaVersion),
                  szInsertInt(DS_BEHAVIOR_VERSION_CURRENT),
                  NULL );

        return FALSE;

    }

    if ( lDsaVersion < DS_BEHAVIOR_VERSION_CURRENT ) {
        //UPDATE dsa version

        MODIFYARG   ModifyArg;
        ATTRVAL     BehaviorVersionVal;

        LONG lNewVersion = DS_BEHAVIOR_VERSION_CURRENT;

        fDSASave = pTHS->fDSA;
        pDBSave = pTHS->pDB;

        pTHS->fDSA = TRUE;

        __try {
            pTHS->pDB = NULL;
            DBOpen(&(pTHS->pDB));
            __try {
                memset(&ModifyArg,0,sizeof(MODIFYARG));
                ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
                ModifyArg.FirstMod.AttrInf.attrTyp = ATT_MS_DS_BEHAVIOR_VERSION;
                ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
                ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &BehaviorVersionVal;
                BehaviorVersionVal.valLen = sizeof(lNewVersion);
                BehaviorVersionVal.pVal = (UCHAR * FAR) &lNewVersion;
                InitCommarg(&(ModifyArg.CommArg));
                ModifyArg.pObject = gAnchor.pDSADN;
                ModifyArg.count = 1;

                if (err = DBFindDSName(pTHS->pDB,ModifyArg.pObject)){
                   __leave;
                }
                ModifyArg.pResObj = CreateResObj(pTHS->pDB, ModifyArg.pObject);

                err = LocalModify(pTHS,&ModifyArg);

                //
                // Upgrade Actions:
                // We had just upgraded our DSA to a new version, so
                // now is the time to do all upgrade related actions
                // Note that we're doing it within the same transaction
                // so that if we fail, the version upgrade fails as well.
                //
                if ( !err ) {
                    err = UpgradeDsa( pTHS, lDsaVersion,lNewVersion);
                }

            }
            __finally {
                DBClose(pTHS->pDB, !err && !AbnormalTermination());
            }
        }
        __except(GetExceptionData(GetExceptionInformation(),
                                  &dwException,
                                  &dwEA,
                                  &ulErrorCode,
                                  &dsid)) {
            DoLogUnhandledError(dsid, ulErrorCode, TRUE);
            err = ulErrorCode;
        }


        pTHS->fDSA = fDSASave;
        pTHS->pDB  = pDBSave;

        if (err) {

            DPRINT(2,"VerifyDSBehaviorVersion: unable to update v_dsa.\n");

            LogEvent( DS_EVENT_CAT_STARTUP_SHUTDOWN,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_UNABLE_TO_UPDATE_VERSION,
                      szInsertWin32ErrCode(err),
                      szInsertWin32Msg(err),
                      NULL );

            return FALSE;
        }
        else {

            LogEvent( DS_EVENT_CAT_STARTUP_SHUTDOWN,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DSA_VERSION_UPDATED,
                      szInsertInt(lDsaVersion),
                      szInsertInt(lNewVersion),
                      NULL );

        }

    }

    DPRINT(2,"VerifyDSBehaviorVersion exits successfully.\n");

    return TRUE;          //succeed

}

// DoInitialize does the initialization work common to both DS as
// a service and as a DLL


NTSTATUS
DoInitialize(int argc, char * argv[], unsigned fInitAdvice,
                 IN  PDS_INSTALL_PARAM   InstallInParams  OPTIONAL,
                 OUT PDS_INSTALL_RESULT  InstallOutParams OPTIONAL)
{
    BOOL fShutdownUrgently = FALSE;
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    ULONG ulThreadId = 0;
    HANDLE threadhandle;
    HANDLE hevLogging;
    HANDLE hevLoadParameters;
    SPAREFN_INFO  TaskSchInfo[2];
    HMODULE hModule = NULL;
    ERR_RECOVER_AFTER_RESTORE FnErrRecoverAfterRestore = NULL;
    BOOL eventlogInitFailed = FALSE;
    BOOL wasGC = FALSE;
    DITSTATE dstate = eMaxDit;
    DWORD dwException, ulErrorCode, dsid;
    PVOID dwEA;


    // Prompt the user for debug input (DBG build only)

    DEBUGINIT(argc, argv, "ntdsa");

// Allow caller to skip security when running as an exe
#if DBG && INCLUDE_UNIT_TESTS
{
    int i;
    extern DWORD dwSkipSecurity;
    if (gfRunningAsExe) for (i = 0; i < argc; ++i) {
        if (0 == _stricmp(argv[i], "-nosec")) {
            dwSkipSecurity = TRUE;
        }
    }
}
#endif DBG && INCLUDE_UNIT_TESTS

    // UNCOMMENT TO FORCE DEBUGGING ON FOR TESTING PURPOSES
    // EDIT THE LEVEL AND SUBSYSTEMS FOR YOUR PRIVATE BUILD
    // REMEMBER TO DISABLE BEFORE CHECKIN!
#if 0
#if DBG
    DebugInfo.severity = 1;
    strcpy( DebugInfo.DebSubSystems,
            "DBINDEX:MDINIDSA:DRAGTCHG:DRANCREP:" );
#endif
#endif

    DsaInitGlobals();

    DsInitializeCritSecs();
    if (!gbCriticalSectionsInitialized) {
        return STATUS_UNSUCCESSFUL;
    }

    if (!DsInitHeapCacheManagement()){
        return STATUS_UNSUCCESSFUL;
    }

    dwTSindex = TlsAlloc();

    if(fInitAdvice) {
        // We're running under DCPromo.
        DsaSetIsInstalling();
            
        if (InstallInParams->pIfmSystemInfo != NULL) {
            DsaSetIsInstallingFromMedia();
        }

    }
    else {
        // Assume this is a regular instantiation
        DsaSetIsRunning();
    }

    __try { /* except */

        THSTATE *pTHS = NULL;
        int err;

        //
        // If the event log service has been configured to start automatically
        // then wait for it to start so we can log our initialization
        // sequence. Otherwise, continue.
        //

        if (   (NULL == (hevLogging = LoadEventTable()))
            || (ERROR_SUCCESS != InitializeEventLogging()) ) {

            //
            // Probably shouldn't run if we can't configure event logging.
            // This is not the same as the event log not being started yet.
            // Log an event to the system log later when the eventlog service
            // is running.
            //

            eventlogInitFailed = TRUE;
            DPRINT(0, "Failed to initalize event log registry entries\n");
        }

        if (FALSE == DsaWaitUntilServiceIsRunning("EventLog"))
        {
            //
            // The event service is either not configured to run or
            // errored out upon startup.  This is a non-fatal error
            // so continue
            //
            DPRINT(0, "EventLog service wait failed - continuing anyway.\n");
        } else {
            DPRINT(1, "EventLog service wait succeeded.\n");
        }

        //
        // If InitializeEventlog failed, log that fact here and bail.
        //
        //

        if ( eventlogInitFailed ) {
            LogSystemEvent(
                 EVENT_ServiceNoEventLog,
                 szInsertSz("Active Directory"),
                 NULL,
                 NULL);

            Status = STATUS_EVENTLOG_FILE_CORRUPT;
            _leave;
        }

        // Set up the process token to allow us to make access checks in an
        // AuditAndAlarm fashion.
        {
            TOKEN_PRIVILEGES EnableSeSecurity;
            TOKEN_PRIVILEGES Previous;
            DWORD PreviousSize;
            HANDLE ProcessTokenHandle;

            err = 0;

            if(!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                    &ProcessTokenHandle)) {
                err = GetLastError();
            }
            else {
                EnableSeSecurity.PrivilegeCount = 1;
                EnableSeSecurity.Privileges[0].Luid.LowPart =
                    SE_AUDIT_PRIVILEGE;
                EnableSeSecurity.Privileges[0].Luid.HighPart = 0;
                EnableSeSecurity.Privileges[0].Attributes =
                    SE_PRIVILEGE_ENABLED;
                PreviousSize = sizeof(Previous);

                if ( !AdjustTokenPrivileges(ProcessTokenHandle,
                                            FALSE, // Don't disable all
                                            &EnableSeSecurity,
                                            sizeof(EnableSeSecurity),
                                            &Previous,
                                            &PreviousSize ) ) {
                    err = GetLastError();
                }

                CloseHandle(ProcessTokenHandle);
            }

            if(err) {
                LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_AUDIT_PRIVILEGE_FAILED,
                         szInsertUL(err),
                         NULL,
                         0);
                err = 0;
            }

        }

        // initialize global Authz RM handles
        err = InitializeAuthzResourceManager();
        if (err) {
            Status = STATUS_NO_MEMORY;
            __leave;
        }

        GetHeuristics();

        // set the global variables _timezone and _daylight to be
        // in Zulu time.
        _daylight = 0;
        _timezone = 0;

        // Set up NULL NT4SID.

        memset (&gNullNT4SID, 0, sizeof(NT4SID));

        // Set up template DSNAME
        gpRootDN = malloc(sizeof(DSNAME)+2);

        if ( !gpRootDN ) {
            MemoryPanic(sizeof(DSNAME)+2);
            Status = STATUS_NO_MEMORY;
            __leave;
        }
        memset(gpRootDN, 0, sizeof(DSNAME)+2);
        gpRootDN->structLen = DSNameSizeFromLen(0);

        DBSetDatabaseSystemParameters(&jetInstance, fInitAdvice);

        // Create the thread state before we call the DBlayer.

        pTHS = create_thread_state();
        if (!pTHS) {
            MemoryPanic(sizeof(THSTATE));
            Status = STATUS_NO_MEMORY;
            fShutdownUrgently = TRUE;
            goto Leave;
        }
        // Set flag for calls to core.
        pTHS->CallerType = CALLERTYPE_INTERNAL;


        // Mark the thread state with the fact that we are not here on behalf of
        // a client.
        pTHS->fDSA = TRUE;


        /* do whatever is needed to recover a restored database before
         * initializing the data base
         */
        // load ntdsbsrv.dll dynamically
        if (!(hModule = (HMODULE) LoadLibrary(NTDSBACKUPDLL))) {
            err = GetLastError();
            DPRINT(0, "Unable to Load ntdsbsrv.dll\n");
        }

        if (!err) {
            // Get pointers to the relevant functions exported from ntdsbsrv.dll.
            FnErrRecoverAfterRestore =
                (ERR_RECOVER_AFTER_RESTORE)
                    GetProcAddress(hModule, ERR_RECOVER_AFTER_RESTORE_FN);

            if (FnErrRecoverAfterRestore == NULL) {
                err = GetLastError();
                DPRINT1(0, "Error %x getting ErrRecoverAfterRestore fn pointer from ntdsbsrv.dll\n", err);
            }

            if (0 == err) {
                FnErrGetNewInvocationId =
                    (ERR_GET_NEW_INVOCATION_ID)
                        GetProcAddress(hModule, GET_NEW_INVOCATION_ID_FN);

                if (FnErrGetNewInvocationId == NULL) {
                    err = GetLastError();
                    DPRINT1(0, "Error %x getting ErrGetNewInvocationId fn pointer from ntdsbsrv.dll\n", err);
                }
            }

            if (0 == err) {
                FnErrGetBackupUsn =
                    (ERR_GET_BACKUP_USN)
                        GetProcAddress(hModule, GET_BACKUP_USN_FN);

                if (FnErrGetBackupUsn == NULL) {
                    err = GetLastError();
                    DPRINT1(0, "Error %x getting ErrGetBackupUsn fn pointer from ntdsbsrv.dll\n", err);
                }
            }

        }

        if (err) {
            LogAndAlertEvent(
                    DS_EVENT_CAT_BACKUP,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_PREPARE_RESTORE_FAILED,
                    szInsertWin32ErrCode( err ),
                    szInsertHex( err ),
                    szInsertWin32Msg( err ) );
        } else {
            DPRINT(0, "About to call into RecoverAfterRestore\n");

            __try
            {
                err = FnErrRecoverAfterRestore(TEXT(DSA_CONFIG_ROOT),
                                               g_szBackupAnnotation,
                                               FALSE);
            }
            __except( HandleAllExceptions(GetExceptionCode()) )
            {
                err = GetExceptionCode();
            }
        }

        if ( err != 0 ) {

            WCHAR ReturnString[32];

            DPRINT1(0, "Yikes! RecoverAfterRestore returned %d\n", err);

            //  Note: DIRLOG_RECOVER_RESTORED_FAILED event message
            //  should have been logged by ErrRecoverAfterRestore()

            Status = STATUS_RECOVERY_FAILURE;

             memset( ReturnString, 0, sizeof( ReturnString ) );
            _itow( err, ReturnString, 10 );

            SetInstallErrorMessage( ERROR_RECOVERY_FAILURE,
                                    DIRMSG_INSTALL_FAILED_TO_INIT_JET,
                                    ReturnString,
                                    NULL,
                                    NULL,
                                    NULL );

            fShutdownUrgently = TRUE;
            goto Leave;
        }
        DPRINT(1, "RecoverAfterRestore returned happily\n");

        /* Make sure CurrSchemaPtr is NULL, so that the schema
         * cache will be loaded correctly later on in the call to
         * LoadSchemaInfo. (Put in to fix bug 149955)
         */

         CurrSchemaPtr = NULL;

        /* Initialize the database, but only once.
         * Note that after this point we should not call exit(), but
         * rather branch down to the end of the block, so that
         * proper database shutdown code can be run.
         */
        DPRINT(0, "About to call into DBInit\n");
        if (err = DBInit()) {


            DWORD WinError;

            WCHAR ReturnString[32];

            DPRINT1(0, "Bad return %d from DBInit.. exit\n", err);
            LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DBINIT_FAILED,
                     szInsertInt(err),
                     0,
                     0);
            //
            // In this case, "err" is a return value from jet - let's try to
            // get some information from it.
            //
            switch (err) {
                case JET_errFileNotFound:
                    Status = STATUS_NO_SUCH_FILE;
                    break;
                case JET_errDiskFull:
                case JET_errLogWriteFail:
                case JET_errLogDiskFull:
                    Status = STATUS_DISK_FULL;
                    break;
                case JET_errPermissionDenied:
                    Status = STATUS_ACCESS_DENIED;
                    break;

                case JET_errOutOfMemory:
                    Status = STATUS_NO_MEMORY;
                    break;

                default:
                    Status = STATUS_UNSUCCESSFUL;
            }

            if ( Status == STATUS_UNSUCCESSFUL ) {
                WinError = ERROR_DS_NOT_INSTALLED;
            } else {
                WinError = RtlNtStatusToDosError( Status );
            }

            memset( ReturnString, 0, sizeof( ReturnString ) );
            _itow( err, ReturnString, 10 );

            SetInstallErrorMessage( WinError,
                                    DIRMSG_INSTALL_FAILED_TO_INIT_JET,
                                    ReturnString,
                                    NULL,
                                    NULL,
                                    NULL );
            goto Leave;
        }
        DPRINT1(0, "DBInit returned 0x%x\n", err);

        // Initialize this thread so it can access the database.

        if (err = DBInitThread(pTHS))
        {
            DPRINT(0, "Bad return from DBInitThread..exit\n");
            LogAndAlertUnhandledError(err);
            Status = STATUS_NO_MEMORY;
            goto Leave;
        }

        // Grab dit state so we know we're not in a bad DitState ...
        if (err = DBGetHiddenState(&dstate)) {
            DPRINT1(0, "Bad return %d from DBGetHiddenState..exit\n", err);
            LogAndAlertUnhandledError(err);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
        }
        Assert(dstate != eMaxDit);
        if (dstate == eIfmDit) {
            // Critical badness happened during last IFM ...
            Assert(!"Critical IFM failure on previous dcpromo!?!");
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CRITICAL_IFM_FAILURE_DIT_STATE,
                     NULL, NULL, NULL);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
        }
        if (DsaIsInstallingFromMedia()) {
            // Lock the IFM attempt into the DIT, so that a failure after we 
            // restored this DB, doesn't allow us to think we're the same DC
            // as the DC this DB was backed up from.
            Assert(dstate == eRunningDit || // Legacy Backup Source
                   dstate == eBackedupDit); // Snapshot Backup Source
            err = DBSetHiddenState(eIfmDit);
            if (err) {
                LogAndAlertUnhandledError(err);
                Status = STATUS_UNSUCCESSFUL;
                goto Leave;
            }
        }

        if (!FUpdateBackupExclusionKey())
        {
            DPRINT(0, "Unable to update the backupexclusion key\n");

            // we can't block the system from booting just for this.
            // so, continue with the rest of the initialization
        }

        // Get DRA, hierarchytable registry paramters
        GetDRARegistryParameters();

        // Get Search Threshold Parameters and Ldap encryption policy
        SetLoadParametersCallback ((LoadParametersCallbackFn)DSLoadDynamicRegParams);
        if ( (NULL == (hevLoadParameters  = LoadParametersTable() ) ) ) {

            DPRINT(0, "Failed to initalize loading parameter registry entries\n");
        }

        // Get DSA registry parameters
        GetDSARegistryParameters();

        // Create semaphore that controls maximum number of threads
        // in DRA get changes call.
        if (!(hsemDRAGetChg = CreateSemaphore (NULL, gulMaxDRAGetChgThrds,
                           gulMaxDRAGetChgThrds, NULL))) {
            err = GetLastError();
            LogAndAlertUnhandledError(err);
            Status = STATUS_NO_MEMORY;
            goto Leave;
        }

        // We get the DitState early so we can tell if we have a snapshot
        // backed up DIT, that was auto recovered by DBInit()
        dstate = eMaxDit;
        if (err = DBGetHiddenState(&dstate)) {
            DPRINT1(0, "Bad return %d from DBGetHiddenState..exit\n", err);
            LogAndAlertUnhandledError(err);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
        }

        // Determine if we have been restored from backup.
        if (!(GetConfigParam(DSA_RESTORED_DB_KEY, &gdwrestvalue,
                 sizeof(gdwrestvalue))) ||
            dstate == eBackedupDit ||
            dstate == eRestoredPhaseI ||
            dstate == eIfmDit) {
            gfRestoring = TRUE;
        }

        // Initialize and start task scheduler thread
        TaskSchInfo[0].hevSpare = hevLogging;
        TaskSchInfo[0].pfSpare  = (PSPAREFN)LoadEventTable;
        TaskSchInfo[1].hevSpare = hevLoadParameters;
        TaskSchInfo[1].pfSpare  = (PSPAREFN)LoadParametersTable;

        // Create thread in suspended state. It will be waken up in
        // DsaDelayedStartupHandler. This ensures we don't get write
        // conflicts caused by TQ tasks during startup.
        if (!InitTaskScheduler(2, TaskSchInfo, FALSE)) {
            err = ERROR_DS_INIT_FAILURE;
            LogAndAlertUnhandledError(err);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
        }
        gfTaskSchedulerInitialized = TRUE;

        // only register signal handlers interactively
        if (!gfRunningInsideLsa)
            init_signals();

        PerfInit();

        // initialize the DRA's binding handle cache
        DRSClientCacheInit();

        DPRINT(1,"Installing the MD server\n");

        // Set global to indicate first cache load after boot
        gFirstCacheLoadAfterBoot = TRUE;
        __try { // except
            if (err = Install(argc, argv, pTHS, InstallInParams))
            {
                DPRINT (1,"Problem starting service (Install() failed). Exiting\n");
                LogAndAlertEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                                 0,
                                 DIRLOG_START_FAILED,
                                 NULL,
                                 NULL,
                                 NULL);
                Status = STATUS_UNSUCCESSFUL;
            }
        } __except(GetExceptionData(GetExceptionInformation(),
                                    &dwException,
                                    &dwEA,
                                    &ulErrorCode,
                                    &dsid)) {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            // Unfortunately, we have a win32 error status at this time
            // but this function returns a NtStatus. The partial solution
            // is the same as the partial solution used after the call
            // to DBInit() above, i.e., convert a few likely win32 codes
            // into NtStatus codes and all others into STATUS_UNSUCCESSFUL.
            err = Win32ErrorFromPTHS(pTHS);
            Assert(err);
            switch (err) {
                case ERROR_FILE_NOT_FOUND:
                    Status = STATUS_NO_SUCH_FILE;
                    break;
                case ERROR_DISK_FULL:
                    Status = STATUS_DISK_FULL;
                    break;
                case ERROR_ACCESS_DENIED:
                    Status = STATUS_ACCESS_DENIED;
                    break;
                case ERROR_OUTOFMEMORY:
                    Status = STATUS_NO_MEMORY;
                    break;

                default:
                    Status = STATUS_UNSUCCESSFUL;
            }
        }
        if (err) {
            goto Leave;
        }

        Assert(!gfRestoring); // Should've been cleared by Install()->HandleRestore()

        // schema cache has been loaded
        gFirstCacheLoadAfterBoot = FALSE;


        // Initialize domain admin SID for use in SetDomainAdminsAsDefaultOwner
        // and GetPlaceholderNCSD.

        if ( err = InitializeDomainAdminSid() ) {
            LogUnhandledError(err);
            DPRINT1(0, "InitializeDomainAdminSid error %X.\n", err);
            Status = STATUS_UNSUCCESSFUL;
            _leave;
        }

        // Make the default SD to put on objects the SD propagator finds that
        // have no SD.
        // Do it after calling Install() so that the root domain sid
        // is loaded in the global gpRootDomainSid

        if (!ConvertStringSDToSDRootDomainW(
                        gpRootDomainSid,
                        DEFAULT_NO_SD_FOUND_SD,
                        SDDL_REVISION_1,
                        &pNoSDFoundSD,
                        &cbNoSDFoundSD)) {
            err = GetLastError();
            LogUnhandledError(err);
            DPRINT1(0, "Default SD for No SD Found case not initialized, error %X.\n", err);
            Status = STATUS_UNSUCCESSFUL;
            _leave;
        }


        //if the DS is running, verify if the ds version is compatible
        if (DsaIsRunning() && !gResetAfterInstall){
            if (!VerifyDSBehaviorVersion(pTHS)){
                DPRINT(0, "DS behavior version incompatible.\n" );
                Status = STATUS_DS_VERSION_CHECK_FAILURE;
                _leave;
            }
        }

        // NOTE: if some data needs to be upgraded, and it can be done
        // asynchronously (after DS has started), then the good place to
        // do it is DsaDelayedStartupHandler. Remember however, that it
        // does not get executed when !DsaIsRunning() or gResetAfterInstall
        // is TRUE.

       /*
        * Load the Hierarchy Table from Disk.  If it isn't there, or
        * if it seems to be corrupt, grovel through the DIT and
        * create a hierarchy.
        */
        if (err = InitHierarchy())
        {
            DPRINT(0, "Bad return from InitHierarchy..exit\n");
            LogAndAlertUnhandledError(err);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
        }

        //
        // We Need to verify the system is Installed and if not then Install it
        //
        dstate = eMaxDit; // call it paranoia
        // Need to re-fetch the hidden state because Install()->HandleRestore()
        // could've updated the state.
        if (err = DBGetHiddenState(&dstate)) {
            DPRINT1(0, "Bad return %d from DBGetHiddenState..exit\n", err);
            LogAndAlertUnhandledError(err);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
        }
        switch (dstate) {
        
        case eInitialDit:
            Assert(DsaIsRunning());
            Assert(gfRunningAsMkdit);
            DPRINT1(0, "eInitialDit - Bad State %d ..exit\n", dstate);
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BAD_DIT_STATE,
                     szInsertInt(dstate),
                     NULL, NULL);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
            break;
            

        case eRealInstalledDit:

            if (dstate == eRealInstalledDit) {
                DPRINT(0, "**** INSTALLED DIT: CONTINUING .. ****\n");
            }
            // FUTURE-2002/08/08-BrettSh If it's ever needed someone could
            // do things in this branch that would only be done on the
            // first reboot after dcpromo.  

            // Fall through and
            //
            //      Goto the final Running state
            //
                
        case eInstalledDit: // This is an old deprecated state.

            // Don't add any code here ... not even for upgrades.

            if (dstate == eInstalledDit) {
                DPRINT(0, "**** INSTALLED DIT (deprecated): CONTINUING .. ****\n");
            }
            
            if (err = DBSetHiddenState(eRunningDit)) {
                DPRINT1(0, "Bad return %d from DBSetHiddenState..exit\n", err);
                LogAndAlertUnhandledError(err);
                Status = STATUS_UNSUCCESSFUL;
                goto Leave;
            }
            
            // fall through to regular running state

        case eRunningDit:

            Assert(DsaIsRunning());

            if (dstate == eRunningDit) {
                DPRINT(0, "**** RUNNING DIT: CONTINUING .. ****\n");
            }

            //
            // Initialize the PEK system from the domain object
            //
            Status = PEKInitialize(gAnchor.pDomainDN,
                                   DS_PEK_READ_KEYSET,
                                   NULL,
                                   0
                                   );
            if (!NT_SUCCESS(Status)) {
                goto Leave;
            }

            break;


        case eIfmDit:
            //
            // FUTURE-2002/08/08-BrettSh - If you wanted to do somethings during
            // IFM before the regular install continues, you could do it here.

            DPRINT(0, "**** IFM DIT: INSTALLING .... ****\n");

            // fall through to regular install ...

        case eBootDit:
            
            if (dstate == eBootDit) {
                DPRINT(0, "BOOT DIT: INSTALLING .... \n");
            }

            //
            // Initialize the PEK system. We are about to perform an
            // install at this moment so request the NEW_PEK set flag
            // Also our gAnchor is not yet set at this point. So pass
            // a NULL for the object name. Later ( after the DsaReset
            // we will specify the object when we do the Save Changes).
            //

            if ( !DsaIsInstallingFromMedia() ) {

                Status = PEKInitialize(NULL, DS_PEK_GENERATE_NEW_KEYSET, NULL, 0 );
                if (!NT_SUCCESS(Status)) {
                    goto Leave;
                }
            } else {
                Assert(dstate == eIfmDit);
            }

            Assert(DsaIsInstalling() && fInitAdvice); // should be synomous, but we'll check both.

            if ( DsaIsInstallingFromMedia() ) {
                wasGC = isDitFromGC(InstallInParams,
                                    InstallOutParams);
            }

            Status = InstallBaseNTDS(InstallInParams,InstallOutParams);
            if (!NT_SUCCESS(Status)) {
                DPRINT1(0, "**** Bad Return 0x%x From InstallBaseNTDS\n", Status);
                if ( STATUS_CONNECTION_REFUSED == Status ) {
                 LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CANNOT_REPLICATE_CGSH,
                         NULL,
                         NULL,
                         0);
                } else {
                    LogAndAlertUnhandledError(Status);
                };
                    
                DBSetHiddenState(eErrorDit);
                goto Leave;
            }

            if (err = DBSetHiddenState(eRealInstalledDit)) {
                DPRINT1(0, "Bad return %d from DBSetHiddenState..exit\n", err);
                LogAndAlertUnhandledError(err);
                Status = STATUS_UNSUCCESSFUL;
                goto Leave;
            }
            DPRINT(0, "**** NTDS Install Successful .. Restart NTDS ****\n");

            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_STARTED,
                     szInsertSz(VER_PRODUCTVERSION_STR),
                     szInsertSz(FLAVOR_STR),
                     0);

            if (err =  DsaReset()) {
                DPRINT1(0, "**** Bad Return %d From DsaReset\n", err);
                LogAndAlertUnhandledError(err);
                DBSetHiddenState(eErrorDit);
                Status = STATUS_UNSUCCESSFUL;
                goto Leave;
            }

            // now that we're done futzing with the install dit,
            // rebuild the quota table
            //
            if ( !DsaIsInstallingFromMedia()
                && ( err = DBInitQuotaTable() ) ) {
                DPRINT1(0, "**** Bad Return %d From DBInitQuotaTable\n", err);
                LogAndAlertUnhandledError(err);
                DBSetHiddenState(eErrorDit);
                Status = STATUS_UNSUCCESSFUL;
                goto Leave;
            }

            if ( wasGC == TRUE ) {
                err = SetDittoGC();
                if (err != ERROR_SUCCESS) {
                    DPRINT1(0, "Dit could not be set to be GC: %d\n", err);
                }
            }


            if ( !DsaIsInstallingFromMedia() ) {


                //
                // At this point the Domain Object is guarenteed to exist
                // and the gAnchor is also guarenteed to be set. Therefore
                // perform a PekSaveChanges passing in the object name
                //

                Status = PEKSaveChanges(gAnchor.pDomainDN);
                if (!NT_SUCCESS(Status)) {
                    goto Leave;
                }
            }

            break;
            
        case eBackedupDit:
        case eRestoredPhaseI:
        case eMaxDit:
            Assert(!"This means that restore or dstate read didn't happen correctly?  Huh");
        case eErrorDit:
        default:
            Assert(dstate == eErrorDit); // default would be an error.
            Assert(DsaIsRunning());
            DPRINT1(0, "DIT in Bad State %d, exiting\n", dstate);
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BAD_DIT_STATE,
                     szInsertInt(dstate),
                     NULL, NULL);
            Status = STATUS_UNSUCCESSFUL;
            goto Leave;
            break;

        }

        // initialize locale support
        InitLocaleSupport (pTHS);

        /* Set our return Value to Success */
        Status = STATUS_SUCCESS;

        //
        // Start async threads in the running case
        // Note that Dsa may appear to be running due to
        // a call to DsaReset after install, so check
        // gResetAfterInstall flag also
        //

        if ( DsaIsRunning() && !gResetAfterInstall) {

            // schema recache thread
            threadhandle = (HANDLE)_beginthreadex(NULL,
                                                  0,
                                                  SCSchemaUpdateThread,
                                                  NULL,
                                                  0,
                                                  &ulThreadId);

            if (threadhandle==NULL) {
                DPRINT1(0,
                        "Failed to Create SchemaUpdateThread. Error %d\n",
                        err=GetLastError());
            }
            else {
                // Save the handle. Do not close, since then the handle
                // will be lost. We will close the handle when we exit the
                // schema update thread on a service shutdown

                hAsyncSchemaUpdateThread = threadhandle;

                // Thread created successfully. Queue a
                // schema cache update to reload the schema cache
                // and complete expensive operations such as
                // creating and deleting indexes out-of-band.
                // These operations were specifically excluded
                // from the first cache load (See DO_CLEANUP)
                SCSignalSchemaUpdateLazy();
            }

            // DirNotify thread
            hDirNotifyThread = (HANDLE) _beginthreadex(NULL,
                                                       0,
                                                       DirNotifyThread,
                                                       NULL,
                                                       0,
                                                       &ulThreadId);

            if (hDirNotifyThread == NULL) {
                DPRINT1(0,
                        "Failed to create DirNotify Thread. Error %d\n",
                        err=GetLastError());
            }

        }
        Leave:
            ;

    }
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwEA,
                              &ulErrorCode,
                              &dsid)) {
        DPRINT3(0, "Unhandled exception %x in DoInitialize: err=%d, dsid=%x\n", dwException, ulErrorCode, dsid);
        LogAndAlertUnhandledErrorDSID(ulErrorCode, dsid);

        Status = STATUS_NONCONTINUABLE_EXCEPTION;
    }

    /* We're done acting as a client thread, so trash our THSTATE */
    free_thread_state();

    if (Status != STATUS_SUCCESS || eServiceShutdown)
    {
        eServiceShutdown= eRemovingClients;
        gUpdatesEnabled = FALSE;
        SetEvent(hServDoneEvent);
        DsaTriggerShutdown(FALSE);
        DsaStop(FALSE);
        DoShutdown(FALSE, fShutdownUrgently, FALSE);
        eServiceShutdown = eSecuringDatabase;
        DBEnd();
    }

    return Status;
} // DoInitialize



/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/
int Install(
    IN int argc,
    IN char *argv[],
    IN THSTATE *pTHS,
    IN PDS_INSTALL_PARAM   InstallInParams  OPTIONAL
    ){
    int err;
/* Install the directory by opening the communications port and spawning
   a number of servicing threads.

   Return Value:
      0 on success
      non-0 on error ( 1 for SCCacheSchemaInit failure, 2 for InitDsaInfo
                       failure, 3 for LoadSchemaInfo failure, 4 for
                       initializedomaininfo error )
*/

    BOOL tempDITval;
    void * pDummy = NULL;
    DWORD dummyDelay;

    /* start the schema download */

    // Set the UpdateDITStructure to allow creation of columns for
    //  attribute schema objects

    tempDITval = pTHS->UpdateDITStructure;
    pTHS->UpdateDITStructure = TRUE;

    // Preload a portion of the schema cache so that some
    // objects and their attributes can be read from the
    // dit. Later, LoadSchemaInfo completes the load.
    if ( SCCacheSchemaInit() ) {
        // Don't free pTHS->CurrSchemaPtr or CurrSchemaPtr
        // Leave them around for debugging
        DPRINT(0,"Failed to initialize schema cache\n");
        LogAndAlertEvent(DS_EVENT_CAT_STARTUP_SHUTDOWN,
                         0,
                         DIRLOG_SCHEMA_NOT_LOADED,
                         NULL,
                         NULL,
                         NULL);
        return 1;
    }


    /* Initialize the DSA knowledge information */


    if (err = InitDSAInfo()){
        LogUnhandledError(err);

        DPRINT1(0,"Failed to locate and load DSA knowledge, error %d\n",err);
        return 2;
    }

    // Load the root domain SID in the global gpRootDomainSid
    // for use in SD conversions during schema load

    LoadRootDomainSid();


    // Load the schema into memory.  If this operation fails, the DSA will
    // only support query operations.

    // But before this, up the max time we allow a transaction to be open.
    // That check is meant to catch erring client threads, not threads we
    // trust. The schema cache load during boot may take a long time if
    // it needs to create certain large indices (for ex., the first boot
    // after NT upgrade, when Jet invalidates all unicode indices)

    gcMaxTicksAllowedForTransaction = 120 * 60 * 60 * 1000L; // 2 hours

    if (LoadSchemaInfo(pTHS)){
        DPRINT(0,"Failed to load the schema cache\n");
        LogAndAlertEvent(DS_EVENT_CAT_STARTUP_SHUTDOWN,
        0,
        DIRLOG_SCHEMA_NOT_LOADED,
        NULL,
        NULL,
        NULL);

        return 3;
    }

    // Rebuild Anchor. 
    dummyDelay = TASKQ_DONT_RESCHEDULE;
    RebuildAnchor(NULL, &pDummy, &dummyDelay);
    if (dummyDelay != TASKQ_DONT_RESCHEDULE) {
        // RebuildAnchor failed. Reschedule as requested.
        InsertInTaskQueue(TQ_RebuildAnchor, NULL, dummyDelay);

        // REVIEW: can we do this? or is it fatal if we
        // could not rebuild it?
    }

    if (err = InitializeDomainInformation()) {
        LogUnhandledError(err);
        DPRINT(0,"Domain info not initialized\n");
        return 4;
    }

    if (err = MapSpnInitialize(pTHS)) {
        LogUnhandledError(err);
        DPRINT(0, "SPN mappings not initialized\n");
        return 5;
    }

    // reset the max transaction time to its previously defined value
    gcMaxTicksAllowedForTransaction = MAX_TRANSACTION_TIME;

    // Handle restored DS (give DS a new repl identity if needed)
    HandleRestore( InstallInParams );

    // restore UpdateDITStructure
    // [ArobindG]: I am pretty sure this is not necessary, just
    // did this just in case
    pTHS->UpdateDITStructure = tempDITval;

    return(0);

}/*Install*/

//
// Stop the DSA by posting the event waited on by the main thread. This
// is  called either by DsUnitialize or by the CTRL/C handler
//
// In general this routine should cleanup any resources init'ed
// in DoInitialize()
//

void
DsaStop(BOOL fSingleUserMode)
{
    ULONG ulSecondsWaited = 0;
    ULONG ulSecondsToWait = 180;
    HANDLE lphObjects[2];

    DPRINT(0,"Shutting down task queue...\n");

    if ( !ShutdownTaskSchedulerWait( TASK_COMPLETION_TIMEOUT ) )
    {
        DPRINT(0, "WARNING: Task queue shutdown failed!\n");
    }
    else
    {
        DPRINT(0, "Task queue shutdown complete\n");
    }
    gfTaskSchedulerInitialized = FALSE;

    // wait for replication threads to exit
    while (ulcActiveReplicationThreads
           && (ulSecondsWaited < ulSecondsToWait)) {
        ulSecondsWaited++;
        RpcCancelAll(); // in case any threads have just registered...
        Sleep(1000);
    }

    if (ulSecondsWaited >= ulSecondsToWait) {
        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
         DS_EVENT_SEV_BASIC,
         DIRLOG_EXIT_WITH_ACTIVE_THREADS,
         NULL,
         NULL,
         NULL);
    }

    // clean up the DRA's binding handle cache
    DRSClientCacheUninit();

    if (hAsyncThread) {
        /* Wait for the replicator async thread to die */
        lphObjects[0]= hAsyncThread;
        lphObjects[1]= hmtxAsyncThread;
        Assert(hmtxAsyncThread);

        if(WaitForMultipleObjects(2,lphObjects,FALSE,3*1000) == WAIT_TIMEOUT) {
            /* We didn't get the events after 3s.  Oh, well, just keep
             * going.
             */
            LogUnhandledError(WAIT_TIMEOUT);
        }
    }

    if (hReplNotifyThread) {
        // we've got a ReplNotifyThread
        // Wake it up to let it quit
        SetEvent(hevEntriesInList);
        // Wait for it to die
        if(WaitForSingleObject(hReplNotifyThread,60*1000) == WAIT_TIMEOUT) {
            /* We didn't get the events after 1 minute.  Oh, well, just keep
             * going.
             */
            LogUnhandledError(WAIT_TIMEOUT);
        }
    }

    /* At this point, either we have the async thread mutex, or
     * the async thread is dead and will not be restarted because
     * we're shutting down, but we have at least done our best.
     * Clean up the mutex in case the DS is restarted w/o reboot
     * like might be the case on an aborted/restarted dcpromo.
     */

    if ( hmtxAsyncThread ) {
        CloseHandle(hmtxAsyncThread);
        hmtxAsyncThread = NULL;
    }
    if ( hAsyncThread ) {
        CloseHandle(hAsyncThread);
        hAsyncThread = NULL;
        fAsyncThreadAlive = FALSE;
        fAsyncThreadExists = FALSE;
    }

    return;
}


void __cdecl sighandler(int sig)
{
    DPRINT(0,"Signal received, shutting down now...\n");
    // signal WaitForLoggingChangesOrShutdown  to shutdown
    SetEvent(hServDoneEvent);
}

void init_signals(void)
{
    signal(SIGBREAK, sighandler);
    signal(SIGINT, sighandler);
}
/* end of init_signals */


//
// Routines to inform clients when delayed startup thread is done.
//

//
// This routine is exported to clients of the dll.  If the startup
// has not finished within a minute, something is wrong. Typically
// this function is called after DsInitialize().
//
NTSTATUS
DsWaitUntilDelayedStartupIsDone(void)
{
    DWORD Error;

    Error = WaitForSingleObject(hevDelayedStartupDone, 60 * 1000);

    if (Error == WAIT_OBJECT_0) {
        //
        // The event was set, return the error
        //
        return gDelayedStartupReturn;

    } else {
        //
        // The wait timed out
        //
        return STATUS_WAIT_0;
    }

}


//
// main routine for garbage collection. called by the task scheduler
// It creates its own DB context and destroys it before exit.
//

void
GarbageCollectionMain(void *pv, void **ppvNext, DWORD *pcSecsUntilNextIteration)
{
    ULONG   NextPeriod = gulGCPeriodSecs;
    PVOID dwEA;
    ULONG dwException, ulErrorCode, dsid;

    __try
    {

// Test support (see mdctrl.c)
#if DBG
    {
        extern BOOL fGarbageCollectionIsDisabled;
        if (fGarbageCollectionIsDisabled) {
            DPRINT( 1, "Garbage Collector disabled; returning.\n");
            __leave;
        }
    }
#endif DBG

        // garbage collect various types of objects
        GarbageCollection(&NextPeriod);

        // Log search performance for the past period.
        SearchPerformanceLogging ();

        /*
         * Why is this here?  Well, the C runtime heap is built for speed,
         * not longevity, and in fact it goes so far as to allocate new
         * virtual space with every allocation, not bothering to re-use
         * previously freed address space.  A call to heapmin will return
         * freed blocks to the OS and hopefully keep us from leaking
         * virtual space to badly.
         */
        _heapmin();
    }
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwEA,
                              &ulErrorCode,
                              &dsid)) {
        DoLogUnhandledError(dsid, ulErrorCode, FALSE);
    }
    
    // reschedule the next garbage collection
    *ppvNext = NULL;
    *pcSecsUntilNextIteration = NextPeriod;

    (void) pv;  //unused
}


//
// Garbage collect dynamic objects whose entryTTL has expired.
// Called out of a scheduled task or, in chk'ed builds, on demand
// via an operational attribute (DynamicObjectControl).
//
// caller is responsible for initializing *pulNextSecs
//
// Returns
//  0 = all expired objects were processed
//  1 = there may be more objects to process
//  *pulNextSecs is set to the number of seconds until the next
//  object expires or is left untouched if there are no expiring
//  objects.
//

DWORD
DeleteExpiredEntryTTL(
    IN OUT ULONG *pulNextSecs
    )
{
    ULONG   ulSuccessCount = 0;
    ULONG   ulFailureCount = 0;

    DPRINT(1, "DeleteExpiredEntryTTL starting\n");

    // delete expired dynamic objects (entryTTL == 0)
    Garb_Collect_EntryTTL(DBTime(),
                          &ulSuccessCount,
                          &ulFailureCount,
                          pulNextSecs);

    DPRINT3(1, "DeleteExpiredEntryTTL returning (%d, %d, %d).\n",
            ulSuccessCount, ulFailureCount, *pulNextSecs);

    //  0 = all expired objects were processed
    //  1 = there may be more objects to process. Processing stopped
    //      because the limit, MAX_DUMPSTER_SIZE, on the number of
    //      objects to process was hit. If this function is being called
    //      out of a scheduled task then the task will be rescheduled to
    //      run after other tasks have been given a chance to run.
    return (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) ? 0 : 1;
}


//
// main routine for garbage collecting dynamic objects whose entryTTL has
// expired. Called by the task scheduler or, in chk'ed builds,
// on demand via an operational attribute (DynamicObjectControl).
//

void
DeleteExpiredEntryTTLMain(void *pv, void **ppvNext, DWORD *pcSecsUntilNextIteration)
{
    ULONG ulNextSecs = 0;
    ULONG ulNextPeriod = gulDeleteExpiredEntryTTLSecs;

    __try {

// Test support (see mdctrl.c)
#if DBG
    {
        extern BOOL fDeleteExpiredEntryTTLIsDisabled;
        if (fDeleteExpiredEntryTTLIsDisabled) {
            DPRINT(1, "DeleteExpiredEntryTTLMain; returning.\n");
            __leave;
        }
    }
#endif DBG

        //  0 = all expired objects were processed
        //  1 = there may be more objects to process. Processing stopped because
        //      the limit, MAX_DUMPSTER_SIZE, on the number of objects to
        //      process was hit. Reschedule this task to run after other
        //      tasks have been given a chance to run.
        if (DeleteExpiredEntryTTL(&ulNextSecs)) {
            ulNextPeriod = 0;
        } else if (ulNextSecs) {
            // An object will expire in the next ulNextSecs seconds.
            // Add in a hysterisis value. If the resultant value is
            // less than the standard interval, use it. Otherwise use
            // the standard interval.
            ulNextPeriod = ulNextSecs + gulDeleteNextExpiredEntryTTLSecs;
            if (ulNextPeriod > gulDeleteExpiredEntryTTLSecs) {
                ulNextPeriod = gulDeleteExpiredEntryTTLSecs;
            }
        }
    } __finally {
        // reschedule the next garbage collection
        *ppvNext = NULL;
        *pcSecsUntilNextIteration = ulNextPeriod;
    }

    (void) pv;  //unused
}


DWORD
ReloadPerformanceCounters(void)
/*++

Routine Description:

    This routine sets up the performance counters for the ds

    See instructions for adding new counters in perfdsa\datadsa.h

Parameters:


Return Values:

    0 if succesful; winerror otherwise

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD IgnoreError;
    WCHAR IniFilePath[2*MAX_PATH];
    WCHAR SystemDirectory[MAX_PATH+1];
    DWORD PerfCounterVersion = 0;

    //
    // Get version in registry.  If non-existent, use zero
    //
    GetConfigParam( PERF_COUNTER_VERSION, &PerfCounterVersion,sizeof( DWORD));

    // If version is not up to date, unload counters and update version
    if (PerfCounterVersion == NTDS_PERFORMANCE_COUNTER_VERSION) {
        return ERROR_SUCCESS;
    }

    //
    // If counters previously loaded, unload first
    //
    if (PerfCounterVersion != 0) {
        __try {
            WinError = (DWORD)UnloadPerfCounterTextStringsW( L"unlodctr NTDS", TRUE );
        }
        __except(HandleAllExceptions(GetExceptionCode())) {
            WinError = RtlNtStatusToDosError( GetExceptionCode() );
        }

        if (WinError == ERROR_SUCCESS) {
            DPRINT1(0, "Unloaded old NTDS performance counters version %d.\n",
                    PerfCounterVersion);
        } else {
            DPRINT2(0, "Failed to unload old NTDS performance counters version %d, error %d.\n",
                    PerfCounterVersion, WinError);

            LogEvent8WithData(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_PERFMON_COUNTER_UNREG_FAILED,
                              szInsertWin32Msg(WinError),
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(WinError),
                              &WinError);
        }
    }

    //
    // If unload was successful or not, try loading the new counters.
    //

    if (!GetSystemDirectoryW(SystemDirectory,
                            sizeof(SystemDirectory)/sizeof(SystemDirectory[0])))
    {
        return GetLastError();
    }
    wcscpy(IniFilePath, L"lodctr ");
    wcscat(IniFilePath, SystemDirectory);
    wcscat(IniFilePath, L"\\ntdsctrs.ini");

    __try {
        WinError = (DWORD)LoadPerfCounterTextStringsW( IniFilePath, TRUE );
    }
    __except(HandleAllExceptions(GetExceptionCode())) {
        WinError = RtlNtStatusToDosError( GetExceptionCode() );
    }

    if (ERROR_SUCCESS == WinError) {
        PerfCounterVersion = NTDS_PERFORMANCE_COUNTER_VERSION;
        SetConfigParam(PERF_COUNTER_VERSION, REG_DWORD,
                       &PerfCounterVersion, sizeof(DWORD));

        DPRINT1(0, "Loaded NTDS performance counters version %d.\n",
                PerfCounterVersion);
    }
    else {
        DPRINT2(0, "Failed to load NTDS performance counters version %d, error %d.\n",
                NTDS_PERFORMANCE_COUNTER_VERSION, WinError);

        LogEvent8WithData(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_PERFMON_COUNTER_REG_FAILED,
                          szInsertWin32Msg(WinError),
                          szInsertUL(PERFCTR_RELOAD_INTERVAL/60),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(WinError),
                          &WinError);
    }

    return WinError;
}

void
TQ_ReloadPerformanceCounters(
    IN  VOID *  pvParam,
    OUT VOID ** ppvNextParam,
    OUT DWORD * pcSecsUntilNextRun
    )
{
    if (ReloadPerformanceCounters()) {
        // Failed; reschedule.
        *pcSecsUntilNextRun = PERFCTR_RELOAD_INTERVAL;
    }
    else {
        // Success -- we're done.
        *pcSecsUntilNextRun = TASKQ_DONT_RESCHEDULE;

        // We failed in the past; inform admin of our progress.
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_PERFMON_COUNTER_REG_SUCCESS,
                 NULL,
                 NULL,
                 NULL);
    }
}

size_t cbPerfCounterData = 0;
unsigned long DummyCounter;
/** PerfInit
 *
 *  Initialize PerfMon extension support.  This consists of allocating a
 *  block of shared memory and initializing a bunch of global pointers to
 *  point into the block.
 *
 *    See instructions for adding new counters in perfdsa\datadsa.h
 */
void PerfInit()
{
    HANDLE hMappedObject;
    unsigned long * pCounterBlock = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_ATTRIBUTES SA;
    int err = 0;
    DWORD cbSD;

    //
    // The security PMs, after several iterations, have decreed that this
    // file mapping should be protected with LocalSystem - all access;
    // Authenticated Users - read access.  See RAID 302861 & 410577 for history
    //
    // O:SYG:SYD:(A;;RPWPCRCCDCLCLOLORCWOWDSDDTDTSW;;;SY)(A;;RPLCLORC;;;AU)
    //

    if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                    "O:SYG:SYD:(A;;RPWPCRCCDCLCLOLORCWOWDSDDTDTSW;;;SY)(A;;RPLCLORC;;;AU)",
                    SDDL_REVISION_1,
                    &pSD,
                    &cbSD) ) {

        LogUnhandledError(GetLastError());

    } else {

        /*
         *  create named section for the performance data
         */

        SA.nLength = cbSD;
        SA.bInheritHandle = FALSE;
        SA.lpSecurityDescriptor = pSD;

        // only use the SD if we are running in LSA. Otherwise use the default security on the file.
        hMappedObject = CreateFileMapping(INVALID_HANDLE_VALUE,
                          gfRunningInsideLsa ? &SA : NULL,
                          PAGE_READWRITE,
                          0,
                          DSA_PERF_SHARED_PAGE_SIZE,
                          DSA_PERF_COUNTER_BLOCK);

        LocalFree(pSD);

        if (hMappedObject && GetLastError() == ERROR_ALREADY_EXISTS) {
            // there might be a possibility that this object
            // is already created, something that should never happen.
            // in that case, we will not use perf counters.

            CloseHandle(hMappedObject);
            hMappedObject = NULL;

            LogUnhandledError(ERROR_ALREADY_EXISTS);
        }
        else if (hMappedObject) {
            /* Mapped object created okay
             *
             * map the section and assign the counter block pointer
             * to this section of memory
             */
            pCounterBlock = (unsigned long *) MapViewOfFile(hMappedObject,
                                                            FILE_MAP_ALL_ACCESS,
                                                            0,
                                                            0,
                                                            0);
            if (pCounterBlock == NULL) {
                LogUnhandledError(GetLastError());
                /* Failed to Map View of file */
            }
        }
    }

    // TODO: this code assumes that all counters are sizeof LONG.  The pointer
    // should be built from a base using the NUM_xxx offsets in datadsa.h

    if (pCounterBlock) {
        pcBrowse = pCounterBlock                             + COUNTER_OFFSET(BROWSE);
        pcRepl = pCounterBlock                               + COUNTER_OFFSET(REPL);
        pcThread = pCounterBlock                             + COUNTER_OFFSET(THREAD);
        pcABClient = pCounterBlock                           + COUNTER_OFFSET(ABCLIENT);
        pcPendSync = pCounterBlock                           + COUNTER_OFFSET(PENDSYNC);
        pcRemRepUpd = pCounterBlock                          + COUNTER_OFFSET(REMREPUPD);
        pcSDProps = pCounterBlock                            + COUNTER_OFFSET(SDPROPS);
        pcSDEvents = pCounterBlock                           + COUNTER_OFFSET(SDEVENTS);
        pcLDAPClients = pCounterBlock                        + COUNTER_OFFSET(LDAPCLIENTS);
        pcLDAPActive = pCounterBlock                         + COUNTER_OFFSET(LDAPACTIVE);
        pcLDAPWritePerSec = pCounterBlock                    + COUNTER_OFFSET(LDAPWRITE);
        pcLDAPSearchPerSec = pCounterBlock                   + COUNTER_OFFSET(LDAPSEARCH);
        pcDRAObjShipped = pCounterBlock                      + COUNTER_OFFSET(DRAOBJSHIPPED);
        pcDRAPropShipped = pCounterBlock                     + COUNTER_OFFSET(DRAPROPSHIPPED);
        pcDRASyncRequestMade = pCounterBlock                 + COUNTER_OFFSET(DRASYNCREQUESTMADE);
        pcDRASyncRequestSuccessful = pCounterBlock           + COUNTER_OFFSET(DRASYNCREQUESTSUCCESSFUL);
        pcDRASyncRequestFailedSchemaMismatch = pCounterBlock + COUNTER_OFFSET(DRASYNCREQUESTFAILEDSCHEMAMISMATCH);
        pcDRASyncObjReceived = pCounterBlock                 + COUNTER_OFFSET(DRASYNCOBJRECEIVED);
        pcDRASyncPropUpdated = pCounterBlock                 + COUNTER_OFFSET(DRASYNCPROPUPDATED);
        pcDRASyncPropSame = pCounterBlock                    + COUNTER_OFFSET(DRASYNCPROPSAME);
        pcMonListSize = pCounterBlock                        + COUNTER_OFFSET(MONLIST);
        pcNotifyQSize = pCounterBlock                        + COUNTER_OFFSET(NOTIFYQ);
        pcLDAPUDPClientOpsPerSecond = pCounterBlock          + COUNTER_OFFSET(LDAPUDPCLIENTS);
        pcSearchSubOperations = pCounterBlock                + COUNTER_OFFSET(SUBSEARCHOPS);
        pcNameCacheHit = pCounterBlock                       + COUNTER_OFFSET(NAMECACHEHIT);
        pcNameCacheTry = pCounterBlock                       + COUNTER_OFFSET(NAMECACHETRY);
        pcHighestUsnIssuedLo = pCounterBlock                 + COUNTER_OFFSET(HIGHESTUSNISSUEDLO);
        pcHighestUsnIssuedHi = pCounterBlock                 + COUNTER_OFFSET(HIGHESTUSNISSUEDHI);
        pcHighestUsnCommittedLo = pCounterBlock              + COUNTER_OFFSET(HIGHESTUSNCOMMITTEDLO);
        pcHighestUsnCommittedHi = pCounterBlock              + COUNTER_OFFSET(HIGHESTUSNCOMMITTEDHI);
        pcSAMWrites = pCounterBlock                          + COUNTER_OFFSET(SAMWRITES);
        pcDRAWrites = pCounterBlock                          + COUNTER_OFFSET(DRAWRITES);
        pcLDAPWrites = pCounterBlock                         + COUNTER_OFFSET(LDAPWRITES);
        pcLSAWrites = pCounterBlock                          + COUNTER_OFFSET(LSAWRITES);
        pcKCCWrites = pCounterBlock                          + COUNTER_OFFSET(KCCWRITES);
        pcNSPIWrites = pCounterBlock                         + COUNTER_OFFSET(NSPIWRITES);
        pcOtherWrites = pCounterBlock                        + COUNTER_OFFSET(OTHERWRITES);
        pcNTDSAPIWrites = pCounterBlock                        + COUNTER_OFFSET(NTDSAPIWRITES);
        pcTotalWrites = pCounterBlock                        + COUNTER_OFFSET(TOTALWRITES);
        pcSAMSearches = pCounterBlock                        + COUNTER_OFFSET(SAMSEARCHES);
        pcDRASearches = pCounterBlock                        + COUNTER_OFFSET(DRASEARCHES);
        pcLDAPSearches = pCounterBlock                       + COUNTER_OFFSET(LDAPSEARCHES);
        pcLSASearches = pCounterBlock                        + COUNTER_OFFSET(LSASEARCHES);
        pcKCCSearches = pCounterBlock                        + COUNTER_OFFSET(KCCSEARCHES);
        pcNSPISearches = pCounterBlock                       + COUNTER_OFFSET(NSPISEARCHES);
        pcOtherSearches = pCounterBlock                      + COUNTER_OFFSET(OTHERSEARCHES);
        pcNTDSAPISearches = pCounterBlock                      + COUNTER_OFFSET(NTDSAPISEARCHES);
        pcTotalSearches = pCounterBlock                      + COUNTER_OFFSET(TOTALSEARCHES);
        pcSAMReads = pCounterBlock                           + COUNTER_OFFSET(SAMREADS);
        pcDRAReads = pCounterBlock                           + COUNTER_OFFSET(DRAREADS);
        pcLSAReads = pCounterBlock                           + COUNTER_OFFSET(LSAREADS);
        pcKCCReads = pCounterBlock                           + COUNTER_OFFSET(KCCREADS);
        pcNSPIReads = pCounterBlock                          + COUNTER_OFFSET(NSPIREADS);
        pcOtherReads = pCounterBlock                         + COUNTER_OFFSET(OTHERREADS);
        pcNTDSAPIReads = pCounterBlock                       + COUNTER_OFFSET(NTDSAPIREADS);
        pcTotalReads = pCounterBlock                         + COUNTER_OFFSET(TOTALREADS);
        pcLDAPBinds = pCounterBlock                          + COUNTER_OFFSET(LDAPBINDSUCCESSFUL);
        pcLDAPBindTime = pCounterBlock                       + COUNTER_OFFSET(LDAPBINDTIME);
        pcCreateMachineSuccessful = pCounterBlock            + COUNTER_OFFSET(CREATEMACHINESUCCESSFUL);
        pcCreateMachineTries = pCounterBlock                 + COUNTER_OFFSET(CREATEMACHINETRIES);
        pcCreateUserSuccessful = pCounterBlock               + COUNTER_OFFSET(CREATEUSERSUCCESSFUL);
        pcCreateUserTries = pCounterBlock                    + COUNTER_OFFSET(CREATEUSERTRIES);
        pcPasswordChanges = pCounterBlock                    + COUNTER_OFFSET(PASSWORDCHANGES);
        pcMembershipChanges = pCounterBlock                  + COUNTER_OFFSET(MEMBERSHIPCHANGES);
        pcQueryDisplays = pCounterBlock                      + COUNTER_OFFSET(QUERYDISPLAYS);
        pcEnumerations = pCounterBlock                       + COUNTER_OFFSET(ENUMERATIONS);
        pcMemberEvalTransitive = pCounterBlock               + COUNTER_OFFSET(MEMBEREVALTRANSITIVE);
        pcMemberEvalNonTransitive = pCounterBlock            + COUNTER_OFFSET(MEMBEREVALNONTRANSITIVE);
        pcMemberEvalResource = pCounterBlock                 + COUNTER_OFFSET(MEMBEREVALRESOURCE);
        pcMemberEvalUniversal = pCounterBlock                + COUNTER_OFFSET(MEMBEREVALUNIVERSAL);
        pcMemberEvalAccount = pCounterBlock                  + COUNTER_OFFSET(MEMBEREVALACCOUNT);
        pcMemberEvalAsGC = pCounterBlock                     + COUNTER_OFFSET(MEMBEREVALASGC);
        pcAsRequests = pCounterBlock                         + COUNTER_OFFSET(ASREQUESTS);
        pcTgsRequests = pCounterBlock                        + COUNTER_OFFSET(TGSREQUESTS);
        pcKerberosAuthentications = pCounterBlock            + COUNTER_OFFSET(KERBEROSAUTHENTICATIONS);
        pcMsvAuthentications = pCounterBlock                 + COUNTER_OFFSET(MSVAUTHENTICATIONS);
        pcDRASyncFullRemaining = pCounterBlock               + COUNTER_OFFSET(DRASYNCFULLREM);
        pcDRAInBytesTotalRate     = pCounterBlock            + COUNTER_OFFSET(DRA_IN_BYTES_TOTAL_RATE);
        pcDRAInBytesNotCompRate   = pCounterBlock            + COUNTER_OFFSET(DRA_IN_BYTES_NOT_COMP_RATE);
        pcDRAInBytesCompPreRate   = pCounterBlock            + COUNTER_OFFSET(DRA_IN_BYTES_COMP_PRE_RATE);
        pcDRAInBytesCompPostRate  = pCounterBlock            + COUNTER_OFFSET(DRA_IN_BYTES_COMP_POST_RATE);
        pcDRAOutBytesTotalRate    = pCounterBlock            + COUNTER_OFFSET(DRA_OUT_BYTES_TOTAL_RATE);
        pcDRAOutBytesNotCompRate  = pCounterBlock            + COUNTER_OFFSET(DRA_OUT_BYTES_NOT_COMP_RATE);
        pcDRAOutBytesCompPreRate  = pCounterBlock            + COUNTER_OFFSET(DRA_OUT_BYTES_COMP_PRE_RATE);
        pcDRAOutBytesCompPostRate = pCounterBlock            + COUNTER_OFFSET(DRA_OUT_BYTES_COMP_POST_RATE);
        pcDsClientBind          = pCounterBlock              + COUNTER_OFFSET(DS_CLIENT_BIND);
        pcDsServerBind          = pCounterBlock              + COUNTER_OFFSET(DS_SERVER_BIND);
        pcDsClientNameTranslate = pCounterBlock              + COUNTER_OFFSET(DS_CLIENT_NAME_XLATE);
        pcDsServerNameTranslate = pCounterBlock              + COUNTER_OFFSET(DS_SERVER_NAME_XLATE);
        pcSDPropRuntimeQueue = pCounterBlock                 + COUNTER_OFFSET(SDPROP_RUNTIME_QUEUE);
        pcSDPropWaitTime = pCounterBlock                     + COUNTER_OFFSET(SDPROP_WAIT_TIME);
        pcDRAInProps          = pCounterBlock                + COUNTER_OFFSET(DRA_IN_PROPS);
        pcDRAInValues         = pCounterBlock                + COUNTER_OFFSET(DRA_IN_VALUES);
        pcDRAInDNValues       = pCounterBlock                + COUNTER_OFFSET(DRA_IN_DN_VALUES);
        pcDRAInObjsFiltered   = pCounterBlock                + COUNTER_OFFSET(DRA_IN_OBJS_FILTERED);
        pcDRAOutObjsFiltered  = pCounterBlock                + COUNTER_OFFSET(DRA_OUT_OBJS_FILTERED);
        pcDRAOutValues        = pCounterBlock                + COUNTER_OFFSET(DRA_OUT_VALUES);
        pcDRAOutDNValues      = pCounterBlock                + COUNTER_OFFSET(DRA_OUT_DN_VALUES);
        pcNspiANR             = pCounterBlock                + COUNTER_OFFSET(NSPI_ANR);
        pcNspiPropertyReads   = pCounterBlock                + COUNTER_OFFSET(NSPI_PROPERTY_READS);
        pcNspiObjectSearch    = pCounterBlock                + COUNTER_OFFSET(NSPI_OBJECT_SEARCH);
        pcNspiObjectMatches   = pCounterBlock                + COUNTER_OFFSET(NSPI_OBJECT_MATCHES);
        pcNspiProxyLookup     = pCounterBlock                + COUNTER_OFFSET(NSPI_PROXY_LOOKUP);
        pcAtqThreadsTotal     = pCounterBlock                + COUNTER_OFFSET(ATQ_THREADS_TOTAL);
        pcAtqThreadsLDAP      = pCounterBlock                + COUNTER_OFFSET(ATQ_THREADS_LDAP);
        pcAtqThreadsOther     = pCounterBlock                + COUNTER_OFFSET(ATQ_THREADS_OTHER);
        pcDRAInBytesTotal     = pCounterBlock                + COUNTER_OFFSET(DRA_IN_BYTES_TOTAL);
        pcDRAInBytesNotComp   = pCounterBlock                + COUNTER_OFFSET(DRA_IN_BYTES_NOT_COMP);
        pcDRAInBytesCompPre   = pCounterBlock                + COUNTER_OFFSET(DRA_IN_BYTES_COMP_PRE);
        pcDRAInBytesCompPost  = pCounterBlock                + COUNTER_OFFSET(DRA_IN_BYTES_COMP_POST);
        pcDRAOutBytesTotal    = pCounterBlock                + COUNTER_OFFSET(DRA_OUT_BYTES_TOTAL);
        pcDRAOutBytesNotComp  = pCounterBlock                + COUNTER_OFFSET(DRA_OUT_BYTES_NOT_COMP);
        pcDRAOutBytesCompPre  = pCounterBlock                + COUNTER_OFFSET(DRA_OUT_BYTES_COMP_PRE);
        pcDRAOutBytesCompPost = pCounterBlock                + COUNTER_OFFSET(DRA_OUT_BYTES_COMP_POST);
        pcLdapNewConnsPerSec  = pCounterBlock                + COUNTER_OFFSET(LDAP_NEW_CONNS_PER_SEC);
        pcLdapClosedConnsPerSec = pCounterBlock              + COUNTER_OFFSET(LDAP_CLS_CONNS_PER_SEC);
        pcLdapSSLConnsPerSec  = pCounterBlock                + COUNTER_OFFSET(LDAP_SSL_CONNS_PER_SEC);
        pcDRAReplQueueOps     = pCounterBlock                + COUNTER_OFFSET(DRA_REPL_QUEUE_OPS);
        pcDRATdsInGetChngs    = pCounterBlock                + COUNTER_OFFSET(DRA_TDS_IN_GETCHNGS);
        pcDRATdsInGetChngsWSem= pCounterBlock                + COUNTER_OFFSET(DRA_TDS_IN_GETCHNGS_W_SEM);
        pcDRARemReplUpdLnk    = pCounterBlock                + COUNTER_OFFSET(DRA_REM_REPL_UPD_LNK);
        pcDRARemReplUpdTot    = pCounterBlock                + COUNTER_OFFSET(DRA_REM_REPL_UPD_TOT);
        pcSAMAcctGroupLatency = pCounterBlock                + COUNTER_OFFSET(SAM_ACCT_GROUP_LATENCY);
        pcSAMResGroupLatency  = pCounterBlock                + COUNTER_OFFSET(SAM_RES_GROUP_LATENCY);

        cbPerfCounterData = ((DSA_LAST_COUNTER_INDEX/2 + 1) * sizeof(unsigned long));
        cbPerfCounterData = ((cbPerfCounterData + cbPerfCounterDataAlign - 1) / cbPerfCounterDataAlign) * cbPerfCounterDataAlign;

        //  we should run out of room when DSA_LAST_COUNTER_INDEX exceeds 510
        Assert(cbPerfCounterData * MAXIMUM_PROCESSORS <= DSA_PERF_SHARED_PAGE_SIZE);

        memset(pCounterBlock, 0, DSA_PERF_SHARED_PAGE_SIZE);
    }
    else {
        DPRINT(0, "Setting all counters to dummy counters.\n");
        pcBrowse = pcRepl = pcThread =
          pcABClient = pcPendSync =
          pcRemRepUpd = pcSDProps = pcSDEvents = pcLDAPClients = pcLDAPActive =
          pcLDAPSearchPerSec = pcLDAPWritePerSec =
          pcDRAObjShipped = pcDRAPropShipped = pcDRASyncRequestMade =
          pcDRASyncRequestSuccessful = pcDRASyncRequestFailedSchemaMismatch =
          pcDRASyncObjReceived = pcDRASyncPropUpdated = pcDRASyncPropSame =
          pcMonListSize = pcNotifyQSize = pcLDAPUDPClientOpsPerSecond =
          pcSearchSubOperations = pcNameCacheHit = pcNameCacheTry =
          pcHighestUsnIssuedLo = pcHighestUsnIssuedHi =
          pcHighestUsnCommittedLo = pcHighestUsnCommittedHi =
          pcSAMWrites = pcDRAWrites = pcLDAPWrites = pcLSAWrites =
          pcKCCWrites = pcNSPIWrites = pcOtherWrites =
          pcNTDSAPIWrites = pcTotalWrites =
          pcSAMSearches = pcDRASearches = pcLDAPSearches = pcLSASearches =
          pcKCCSearches = pcNSPISearches = pcOtherSearches =
          pcNTDSAPISearches = pcTotalSearches =
          pcSAMReads = pcDRAReads = pcLSAReads =
          pcKCCReads = pcNSPIReads = pcOtherReads = pcNTDSAPIReads = pcTotalReads =
          pcLDAPBinds = pcLDAPBindTime =
          pcCreateMachineSuccessful = pcCreateMachineTries =
          pcCreateUserSuccessful =
          pcCreateUserTries = pcPasswordChanges = pcMembershipChanges =
          pcQueryDisplays = pcEnumerations =
          pcMemberEvalTransitive = pcMemberEvalNonTransitive =
          pcMemberEvalResource = pcMemberEvalUniversal = pcMemberEvalAccount =
          pcMemberEvalAsGC = pcAsRequests = pcTgsRequests =
          pcKerberosAuthentications =
          pcMsvAuthentications = pcDRASyncFullRemaining = pcDRAInBytesTotalRate =
          pcDRAInBytesNotCompRate  = pcDRAInBytesCompPreRate = pcDRAInBytesCompPostRate =
          pcDRAOutBytesTotalRate = pcDRAOutBytesNotCompRate = pcDRAOutBytesCompPreRate =
          pcDRAOutBytesCompPostRate  = pcDsClientBind = pcDsServerBind =
          pcDsClientNameTranslate = pcDsServerNameTranslate =
          pcSDPropRuntimeQueue =  pcSDPropWaitTime =
          pcDRAInProps = pcDRAInValues = pcDRAInDNValues = pcDRAInObjsFiltered =
          pcDRAOutObjsFiltered = pcDRAOutValues = pcDRAOutDNValues =
          pcNspiANR = pcNspiPropertyReads = pcNspiObjectSearch = pcNspiObjectMatches =
          pcNspiProxyLookup = pcAtqThreadsTotal = pcAtqThreadsLDAP = pcAtqThreadsOther =
          pcDRAInBytesTotal = pcDRAInBytesNotComp  = pcDRAInBytesCompPre =
          pcDRAInBytesCompPost = pcDRAOutBytesTotal = pcDRAOutBytesNotComp =
          pcDRAOutBytesCompPre = pcDRAOutBytesCompPost = pcLdapNewConnsPerSec =
          pcLdapClosedConnsPerSec = pcLdapSSLConnsPerSec =
          pcDRAReplQueueOps = pcDRATdsInGetChngs = pcDRATdsInGetChngsWSem =
          pcDRARemReplUpdLnk = pcDRARemReplUpdTot =
          pcSAMAcctGroupLatency = pcSAMResGroupLatency = 
                &DummyCounter;

          cbPerfCounterData = 0;
    }

    // Fill in DSSTAT_* to counter variable mapping table

    StatTypeMapTable[ DSSTAT_CREATEMACHINETRIES ] = pcCreateMachineTries;
    StatTypeMapTable[ DSSTAT_CREATEMACHINESUCCESSFUL ] = pcCreateMachineSuccessful;
    StatTypeMapTable[ DSSTAT_CREATEUSERTRIES ] = pcCreateUserTries;
    StatTypeMapTable[ DSSTAT_CREATEUSERSUCCESSFUL ] = pcCreateUserSuccessful;
    StatTypeMapTable[ DSSTAT_PASSWORDCHANGES] = pcPasswordChanges;
    StatTypeMapTable[ DSSTAT_MEMBERSHIPCHANGES ] = pcMembershipChanges;
    StatTypeMapTable[ DSSTAT_QUERYDISPLAYS ] = pcQueryDisplays;
    StatTypeMapTable[ DSSTAT_ENUMERATIONS ] = pcEnumerations;
    StatTypeMapTable[ DSSTAT_ASREQUESTS ] = pcAsRequests;
    StatTypeMapTable[ DSSTAT_TGSREQUESTS ] = pcTgsRequests;
    StatTypeMapTable[ DSSTAT_KERBEROSLOGONS ] = pcKerberosAuthentications;
    StatTypeMapTable[ DSSTAT_MSVLOGONS ] = pcMsvAuthentications;
    StatTypeMapTable[ DSSTAT_ATQTHREADSTOTAL ] = pcAtqThreadsTotal;
    StatTypeMapTable[ DSSTAT_ATQTHREADSLDAP ] = pcAtqThreadsLDAP;
    StatTypeMapTable[ DSSTAT_ATQTHREADSOTHER ] = pcAtqThreadsOther;
    StatTypeMapTable[ DSSTAT_ACCTGROUPLATENCY ] = pcSAMAcctGroupLatency;
    StatTypeMapTable[ DSSTAT_RESGROUPLATENCY ] = pcSAMResGroupLatency;

    // Reload the perfmon counter. Done here to ensure NTDS counter gets
    // reloaded after an upgrade. If the counter is
    // already loaded, this is a no-op

    err = ReloadPerformanceCounters();
    if (err) {
        DPRINT(0, "Problem loading NTDS perfmon counter\n");
        InsertInTaskQueue(TQ_ReloadPerformanceCounters,
                          NULL,
                          PERFCTR_RELOAD_INTERVAL);
    }
    else {
        gbPerfCountersInitialized = TRUE;
        DPRINT(0, "NTDS Perfmon Counters loaded\n");
    }
}

VOID
UpdateDSPerfStats(
    IN DWORD            dwStat,
    IN DWORD            dwOperation,
    IN DWORD            dwChange
)
/*++

Routine Description:

    Updates a given DS performance counter.  Called by components outside the
    DS core but inside the process (like SAM)

Parameters:

    dwStat - Statistic to update.  Use a DSSTAT_ constant to specify stat.
    dwOperation - What to do to statistic
                  FLAG_COUNTER_INCREMENT - increment the value - INC()
                  FLAG_COUNTER_DECREMENT - decrement the value - DEC()
                  FLAG_COUNTER_SET - set the value directly - ISET()
    dwChange - Specifies value to set if dwOperation == FLAG_COUNTER_SET

Return Values:

    None

--*/
{
    if (!gbPerfCountersInitialized) {
        DPRINT3(0, "Premature call to %s perf counter %u by/to %u."
                " The caller should be ashamed.\n",
                (dwOperation == FLAG_COUNTER_INCREMENT ? "inc" :
                 (dwOperation == FLAG_COUNTER_DECREMENT ? "dec" : "set")),
                dwStat,
                dwChange);
        Assert(!"SAM/LSA called DSA prior to DSA initialization");
        return;
    }

    if (dwStat >= DSSTAT_COUNT) {
        // UpdateDSPerfStats is exported. Without this check, internal callers
        // can modify any DWORD in our address space.
        Assert(!"Invalid UpdateDSPerfStats call, dwStat is out of bounds");
        return;
    }

    switch ( dwOperation ) {

      case FLAG_COUNTER_INCREMENT:
        INC( StatTypeMapTable[ dwStat ] );
        break;

      case FLAG_COUNTER_DECREMENT:
        DEC( StatTypeMapTable[ dwStat ] );
        break;

      case FLAG_COUNTER_SET:
        ISET( StatTypeMapTable[ dwStat ], dwChange );
        break;

      default:
        Assert( FALSE );
    } // switch()
}

/** GetDRARegistryParameters
 *
 *  Get DRA parameters from registry
 *  If parameters are unavailable or invalid, use defaults.
 *  We get all these parameters here so that we can check consistency
 *  between them.
 */
void GetDRARegistryParameters()
{
    THSTATE    *pTHS=pTHStls;
    BOOL       fWasPreviouslyLVR;
    struct {
        LPSTR   pszValueName;
        ULONG   ulDefault;
        ULONG   ulMultiplier;
        ULONG * pulValue;
    } rgValues[] = {

        {DRA_NOTIFY_START_PAUSE,      INVALID_REPL_NOTIFY_VALUE,           SECS_IN_SECS, &giDCFirstDsaNotifyOverride},
        {DRA_NOTIFY_INTERDSA_PAUSE,   INVALID_REPL_NOTIFY_VALUE,           SECS_IN_SECS, &giDCSubsequentDsaNotifyOverride},
        {DRA_INTRA_PACKET_OBJS,       0,                                   1,            &gcMaxIntraSiteObjects},
        {DRA_INTRA_PACKET_BYTES,      0,                                   1,            &gcMaxIntraSiteBytes},
        {DRA_INTER_PACKET_OBJS,       0,                                   1,            &gcMaxInterSiteObjects},
        {DRA_INTER_PACKET_BYTES,      0,                                   1,            &gcMaxInterSiteBytes},
        {DRA_ASYNC_INTER_PACKET_OBJS, 0,                                   1,            &gcMaxAsyncInterSiteObjects},
        {DRA_ASYNC_INTER_PACKET_BYTES,0,                                   1,            &gcMaxAsyncInterSiteBytes},
        {HIERARCHY_PERIOD_KEY,        DEFAULT_HIERARCHY_PERIOD,            MINS_IN_SECS, &gulHierRecalcPause},
        {DRA_MAX_GETCHGTHRDS,         0,                                   1,            &gulMaxDRAGetChgThrds},
        {DRA_AOQ_LIMIT,               DEFAULT_DRA_AOQ_LIMIT,               1,            &gulAOQAggressionLimit},
        {DRA_THREAD_OP_PRI_THRESHOLD, DEFAULT_DRA_THREAD_OP_PRI_THRESHOLD, 1,            &gulDraThreadOpPriThreshold},
        {DRA_CTX_LIFETIME_INTRA,      DEFAULT_DRA_CTX_LIFETIME_INTRA,      SECS_IN_SECS, &gulDrsCtxHandleLifetimeIntrasite},
        {DRA_CTX_LIFETIME_INTER,      DEFAULT_DRA_CTX_LIFETIME_INTER,      SECS_IN_SECS, &gulDrsCtxHandleLifetimeIntersite},
        {DRA_CTX_EXPIRY_CHK_INTERVAL, DEFAULT_DRA_CTX_EXPIRY_CHK_INTERVAL, SECS_IN_SECS, &gulDrsCtxHandleExpiryCheckInterval},
        {DRSRPC_BIND_TIMEOUT,         DEFAULT_DRSRPC_BIND_TIMEOUT,         1,            &gulDrsRpcBindTimeoutInMins},
        {DRSRPC_REPLICATION_TIMEOUT,  DEFAULT_DRSRPC_REPLICATION_TIMEOUT,  1,            &gulDrsRpcReplicationTimeoutInMins},
        {DRSRPC_GCLOOKUP_TIMEOUT,     DEFAULT_DRSRPC_GCLOOKUP_TIMEOUT,     1,            &gulDrsRpcGcLookupTimeoutInMins},
        {DRSRPC_MOVEOBJECT_TIMEOUT,   DEFAULT_DRSRPC_MOVEOBJECT_TIMEOUT,   1,            &gulDrsRpcMoveObjectTimeoutInMins},
        {DRSRPC_NT4CHANGELOG_TIMEOUT, DEFAULT_DRSRPC_NT4CHANGELOG_TIMEOUT, 1,            &gulDrsRpcNT4ChangeLogTimeoutInMins},
   {DRSRPC_OBJECTEXISTENCE_TIMEOUT,    DEFAULT_DRSRPC_OBJECTEXISTENCE_TIMEOUT,  1,            &gulDrsRpcObjectExistenceTimeoutInMins},
   {DRSRPC_GETREPLINFO_TIMEOUT,        DEFAULT_DRSRPC_GETREPLINFO_TIMEOUT,      1,            &gulDrsRpcGetReplInfoTimeoutInMins},
        {DRA_MAX_WAIT_FOR_SDP_LOCK,   DEFAULT_DRA_MAX_WAIT_FOR_SDP_LOCK,   1,            &gcMaxTicksToGetSDPLock},
        {DRA_MAX_WAIT_MAIL_SEND_MSG,  DEFAULT_DRA_MAX_WAIT_MAIL_SEND_MSG,  1,            &gcMaxTicksMailSendMsg},
        {DRA_MAX_WAIT_SLOW_REPL_WARN, DEFAULT_DRA_MAX_WAIT_SLOW_REPL_WARN, 1,            &gcMaxMinsSlowReplWarning},
        {DRA_THREAD_PRI_HIGH,         DEFAULT_DRA_THREAD_PRI_HIGH,         1,            (ULONG *) &gnDraThreadPriHigh},
        {DRA_THREAD_PRI_LOW,          DEFAULT_DRA_THREAD_PRI_LOW,          1,            (ULONG *) &gnDraThreadPriLow},
        {GC_PROMOTION_COMPLETE,       0,                                   1,            &gfWasPreviouslyPromotedGC},
        {LINKED_VALUE_REPLICATION_KEY, 0,                                   1,           &fWasPreviouslyLVR},
        {DRA_REPL_QUEUE_CHECK_TIME,   DEFAULT_DRA_REPL_QUEUE_CHECK_TIME,   MINS_IN_SECS, &gulReplQueueCheckTime},
        {DRA_REPL_COMPRESSION_LEVEL,  DEFAULT_DRA_REPL_COMPRESSION_LEVEL,  1,            &gulDraCompressionLevel},
        {DRA_REPL_COMPRESSION_ALG,  DEFAULT_DRA_REPL_COMPRESSION_ALG,  1,            &gulDraCompressionAlg},
        {DSA_THREAD_STATE_HEAP_LIMIT, DEFAULT_THREAD_STATE_HEAP_LIMIT,     1,            &gcMaxHeapMemoryAllocForTHSTATE},
    };

    DWORD i;
    MEMORYSTATUSEX sMemoryStats;
    const DWORDLONG ullReplVeryLittleMemory = DRA_MAX_GETCHGREQ_BYTES_MIN * MEMSIZE_TO_PACKETSIZE_RATIO;
    const DWORDLONG ullReplWholeLotaMemory = MAX_MAX_PACKET_BYTES * MEMSIZE_TO_PACKETSIZE_RATIO;
    ULONG ulMemBasedObjects = DRA_MAX_GETCHGREQ_OBJS_MIN;
    ULONG ulMemBasedBytes = DRA_MAX_GETCHGREQ_BYTES_MIN;
    DWORD dwRet = NO_ERROR;

    // Get the registry parameters.
    for (i = 0; i < ARRAY_SIZE(rgValues); i++) {
        *rgValues[i].pulValue = GetRegistryOrDefault(rgValues[i].pszValueName,
                                                     rgValues[i].ulDefault,
                                                     rgValues[i].ulMultiplier);
    }

#if DBG
    // Debug hook to enable LVR
    if (fWasPreviouslyLVR) {
        DsaEnableLinkedValueReplication( pTHS, FALSE );
    }
#endif

    // Overiding various registry settings or defaults in the rgValues struct

    if ((gnDraThreadPriLow < DRA_THREAD_PRI_LOW_MIN)
        || (gnDraThreadPriLow > DRA_THREAD_PRI_LOW_MAX)) {
        gnDraThreadPriLow = DEFAULT_DRA_THREAD_PRI_LOW;
    }

    if ((gnDraThreadPriHigh < DRA_THREAD_PRI_HIGH_MIN)
        || (gnDraThreadPriHigh < gnDraThreadPriLow)
        || (gnDraThreadPriHigh > DRA_THREAD_PRI_HIGH_MAX)) {
        gnDraThreadPriHigh = DEFAULT_DRA_THREAD_PRI_HIGH;
    }

    // Determine whether the user set the IntraSite Obj/Byte packet sizes
    // Get total RAM for calculation of packet sizes.
    // by default: set the packet size to minimum at top of function.
    sMemoryStats.dwLength = sizeof(sMemoryStats);
    if(GlobalMemoryStatusEx (&sMemoryStats) == 0){
        dwRet = GetLastError();
        DPRINT1(0, "GlobalMemoryStatusEx returned %ul\n", dwRet);
    } else {
        // calculate packet size based on memory size.
        if(sMemoryStats.ullTotalPhys > ullReplVeryLittleMemory){
            // We have enough memory to calculate packet size off physical RAM
            if(sMemoryStats.ullTotalPhys < ullReplWholeLotaMemory){
                // We don't have too much memory to calculate packet size off physical RAM.
                // set the packet sizes based on physical memory.
                ulMemBasedBytes = (ULONG) (sMemoryStats.ullTotalPhys / MEMSIZE_TO_PACKETSIZE_RATIO);
                ulMemBasedObjects = ulMemBasedBytes / BYTES_TO_OBJECT_RATIO;
            } else {
                // too much RAM to calculate the packet size off RAM,
                // set the packet sizes to maximum
                ulMemBasedObjects = MAX_MAX_PACKET_OBJECTS;
                ulMemBasedBytes = MAX_MAX_PACKET_BYTES;
            } // end if/else a whole lota memory
        } // end if very little memory
    } // end if/else getting mem stats failed.

    // Code.Improvement I think the object limit is for how many objects the machines the processor
    //  will want to process.  For now we are assuming that memory corresponds to processor ability,
    //  which is a tenous exception, but most often the case.

    // RPC based intra site and response max packet size
    if (gcMaxIntraSiteObjects == 0) { gcMaxIntraSiteObjects = ulMemBasedObjects; }
    if (gcMaxIntraSiteBytes == 0) { gcMaxIntraSiteBytes = ulMemBasedBytes; }
    // Code.Improvement to have these variables be determined from the connection object, and
    //   be attached to how much is likely to not clog up the site link.  Maybe not?
    // RPC based inter site request size
    if (gcMaxInterSiteObjects == 0) { gcMaxInterSiteObjects = ulMemBasedObjects; }
    if (gcMaxInterSiteBytes == 0) { gcMaxInterSiteBytes = ulMemBasedBytes; }
    // Mail Based inter site request size
    if (gcMaxAsyncInterSiteObjects == 0) { gcMaxAsyncInterSiteObjects = ulMemBasedObjects; }
    if (gcMaxAsyncInterSiteBytes == 0) { gcMaxAsyncInterSiteBytes = MAX_ASYNC_PACKET_BYTES; } // Needs
                      // to be extra limited because of most mail servers can't handle 10 MB messages.

    // gulMaxDRAGetChgThrds controls the maximum number of threads that can
    // do outbound replication at the same time. If user set number of threads in
    // registry to zero or the registry value is not set, we set the number
    // of threads to be twice the number of processors. Note that LSASS might
    // not actually be able to use all processors if processor affinity has been set.
    if (gulMaxDRAGetChgThrds == 0) {
        Assert( GetProcessorCount()>=1 );
        gulMaxDRAGetChgThrds = 2 * GetProcessorCount();
    }

}

/** GetDSARegistryParameters
 *
 *  Get DSA parameters from registry
 *  If parameters are unavailable or invalid, use defaults.
 *  We get all these parameters here so that we can check consistency
 *  between them.
 */
void GetDSARegistryParameters()
{
    THSTATE    *pTHS=pTHStls;
    DWORD       i;
    struct {
        LPSTR   pszValueName;
        ULONG   ulDefault;
        ULONG   ulMultiplier;
        ULONG * pulValue;
    } rgValues[] = {

        // UNDOCUMENTED REGISTRY VALUES
        //
        // Delete expired dynamic objects (entryTTL == 0) every N secs
        // or at the next expiration time plus M secs, whichever is less.
        {DSA_DELETE_EXPIRED_ENTRYTTL_SECS, DEFAULT_DELETE_EXPIRED_ENTRYTTL_SECS, 1, &gulDeleteExpiredEntryTTLSecs},
        {DSA_DELETE_NEXT_EXPIRED_ENTRYTTL_SECS, DEFAULT_DELETE_NEXT_EXPIRED_ENTRYTTL_SECS, 1, &gulDeleteNextExpiredEntryTTLSecs},

        // UNDOCUMENTED REGISTRY VALUES
        //
        // the schema fsmo cannot be transferred for a few seconds after
        // it has been transfered or after a schema change (excluding
        // replicated or system changes). This gives the schema admin a
        // chance to change the schema before having the fsmo pulled away
        // by a competing schema admin who also wants to make schema
        // changes.
        {DSA_SCHEMA_FSMO_LEASE_SECS, DEFAULT_SCHEMA_FSMO_LEASE_SECS, 1, &gulSchemaFsmoLeaseSecs},
        {DSA_SCHEMA_FSMO_LEASE_MAX_SECS, DEFAULT_SCHEMA_FSMO_LEASE_MAX_SECS, 1, &gulSchemaFsmoLeaseMaxSecs},

        // UNDOCUMENTED REGISTRY VALUES
        //
        // I just know at some point someone will ask to be able to NOT
        // register the SPNs for an NDNC.  Also this will allow test to
        // push NDNCs past the 800/1200 value limit to create thousands
        // of NDNCs on a single DC, instead of just 800/1200.  Though,
        // we only support 100 NCs per DC, we should test beyond this.
        {DSA_REGISTER_NDNC_SPNS,            TRUE,                              1,   &gfWriteNdncSpns},

    };

    // Get the registry parameters.
    for (i = 0; i < ARRAY_SIZE(rgValues); i++) {
        *rgValues[i].pulValue = GetRegistryOrDefault(rgValues[i].pszValueName,
                                                     rgValues[i].ulDefault,
                                                     rgValues[i].ulMultiplier);
    }

    // A value of 0 seconds is not allowed
    if (!gulDeleteExpiredEntryTTLSecs) {
        gulDeleteExpiredEntryTTLSecs = DEFAULT_DELETE_EXPIRED_ENTRYTTL_SECS;
    }
    if (!gulDeleteNextExpiredEntryTTLSecs) {
        gulDeleteNextExpiredEntryTTLSecs = DEFAULT_DELETE_NEXT_EXPIRED_ENTRYTTL_SECS;
    }

    // Make the user go through some pain to lease the fsmo for very long
    // times. Leasing the fsmo for long times is not recommended because
    // it ties the fsmo to a single point of failure and to a single point
    // of administration.
    if (gulSchemaFsmoLeaseSecs > gulSchemaFsmoLeaseMaxSecs) {
        gulSchemaFsmoLeaseSecs = gulSchemaFsmoLeaseMaxSecs;
    }

    // get "System\\CurrentControlSet\\lsa\\EnableXForest" key
    // if this flag is set, the cross-forest authorization & authentication feature
    // is enabled even the forest is not in Whistler mode
    {
        // the initial value of gEnableXForest is 0

        DWORD dwValue, dwSize = sizeof(DWORD);
        HKEY  hk;

        if ( !RegOpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Lsa", &hk)) {
            if (ERROR_SUCCESS == RegQueryValueEx(hk, "EnableXforest", NULL, NULL, (LPBYTE)&dwValue, &dwSize)) {
                gEnableXForest = dwValue;
            }
            RegCloseKey(hk);
        }
        DPRINT1(1, "Cross-forest Authentication/Authorization is %s by registry key.\n", gEnableXForest?"enabled":"not enabled");

    }
}

#ifdef DBG

// jet failure injection params from dbjetex.c. See this file for description.
extern BOOL  gfInjectJetFailures;
extern DWORD gdwInjectJetWriteConflictRate;
extern DWORD gdwInjectJetOutOfVersionStoreRate;
extern DWORD gdwInjectJetLogWriteFailureRate;
extern DWORD gdwInjectJetOutOfMemoryRate;
extern DWORD gdwInjectJetShutdownRate;
#define INJECT_JET_FAILURES_KEY                     "Inject JET failures"
#define INJECT_WRITE_CONFLICT_RATE_KEY              "Inject JET write conflict rate"
#define INJECT_OUT_OF_VERSION_STORE_RATE_KEY        "Inject JET out of version store rate"
#define INJECT_LOG_WRITE_FAILURE_RATE_KEY           "Inject JET log write failure rate"
#define INJECT_OUT_OF_MEMORY_RATE_KEY               "Inject JET out of memory rate"
#define INJECT_SHUTDOWN_RATE_KEY                    "Inject JET shutdown rate"

#endif


// Get dynamic parameters from regisrty
//
void __cdecl DSLoadDynamicRegParams()
{
    DWORD dwForceRediscoveryWindow, dwForceWaitExpired,
          dwHonorFailureWindow, dwDcInvalidationPeriod;

    struct {
        LPSTR   pszValueName;
        ULONG   ulDefault;
        ULONG   ulMultiplier;
        ULONG * pulValue;
    } rgValues[] = {
        {DB_EXPENSIVE_SEARCH_THRESHOLD, DEFAULT_DB_EXPENSIVE_SEARCH_THRESHOLD, 1,        &gcSearchExpensiveThreshold},
        {DB_INEFFICIENT_SEARCH_THRESHOLD, DEFAULT_DB_INEFFICIENT_SEARCH_THRESHOLD, 1,    &gcSearchInefficientThreshold},
        {DB_INTERSECT_THRESHOLD, DEFAULT_DB_INTERSECT_THRESHOLD, 1, &gulMaxRecordsWithoutIntersection},
        {DB_INTERSECT_RATIO, DEFAULT_DB_INTERSECT_RATIO, 1, &gulIntersectExpenseRatio},
        {LDAP_INTEGRITY_POLICY_KEY, 0, 1, &gulLdapIntegrityPolicy},

        // GCverify time parameters
        {GCVERIFY_FORCE_REDISCOVERY_WINDOW_KEY,     DEFAULT_GCVERIFY_FORCE_REDISCOVERY_WINDOW,      1, &dwForceRediscoveryWindow},
        {GCVERIFY_FORCE_WAIT_EXPIRED_KEY,           DEFAULT_GCVERIFY_FORCE_WAIT_EXPIRED,            1, &dwForceWaitExpired},
        {GCVERIFY_HONOR_FAILURE_WINDOW_KEY,         DEFAULT_GCVERIFY_HONOR_FAILURE_WINDOW,          1, &dwHonorFailureWindow},
        {GCVERIFY_FINDGC_OFFSITE_FAILBACK_TIME_KEY, DEFAULT_GCVERIFY_FINDGC_OFFSITE_FAILBACK_TIME,  1, &gdwFindGcOffsiteFailbackTime},
        {GCVERIFY_DC_INVALIDATION_PERIOD_KEY,       DEFAULT_GCVERIFY_DC_INVALIDATION_PERIOD,        1, &dwDcInvalidationPeriod},

        // others
        {DSA_UNLOCK_SYSTEM_SUBTREE,                 0,                                              1, &gulUnlockSystemSubtree},
        {DRA_STRICT_REPLICATION_CONSISTENCY,                 0,                                              1, &gfStrictReplicationConsistency},
        {DRA_STRICT_SCHEDULE_WINDOW,                 0,                                              1, &gfStrictScheduleWindow},

#ifdef DBG
        {INJECT_JET_FAILURES_KEY,                   0,                                              1, &gfInjectJetFailures},
        {INJECT_WRITE_CONFLICT_RATE_KEY,            8,                                              1, &gdwInjectJetWriteConflictRate},
        {INJECT_OUT_OF_VERSION_STORE_RATE_KEY,      0,                                              1, &gdwInjectJetOutOfVersionStoreRate},
        {INJECT_LOG_WRITE_FAILURE_RATE_KEY,         0,                                              1, &gdwInjectJetLogWriteFailureRate},
        {INJECT_OUT_OF_MEMORY_RATE_KEY,             0,                                              1, &gdwInjectJetOutOfMemoryRate},
        {INJECT_SHUTDOWN_RATE_KEY,                  0,                                              1, &gdwInjectJetShutdownRate},
#endif
    };

    DWORD i;

    DPRINT (0, "Loading dynamic registry parameters\n");

    // Get the registry parameters.
    for (i = 0; i < ARRAY_SIZE(rgValues); i++) {
        *rgValues[i].pulValue = GetRegistryOrDefault(rgValues[i].pszValueName,
                                                     rgValues[i].ulDefault,
                                                     rgValues[i].ulMultiplier);
    }

    // fix the search thresholds if supplied with wrong values
    if (gcSearchExpensiveThreshold == 0) { gcSearchExpensiveThreshold = DEFAULT_DB_EXPENSIVE_SEARCH_THRESHOLD;}
    if (gcSearchInefficientThreshold == 0) { gcSearchInefficientThreshold = DEFAULT_DB_INEFFICIENT_SEARCH_THRESHOLD;}
    if (gulMaxRecordsWithoutIntersection == 0) {gulMaxRecordsWithoutIntersection = DEFAULT_DB_INTERSECT_THRESHOLD;}
    if (gulIntersectExpenseRatio == 0) { gulIntersectExpenseRatio = DEFAULT_DB_INTERSECT_RATIO; }

    // check gcverify params
    if (dwForceRediscoveryWindow == 0) { dwForceRediscoveryWindow = DEFAULT_GCVERIFY_FORCE_REDISCOVERY_WINDOW; }
    if (dwForceWaitExpired == 0) { dwForceWaitExpired = DEFAULT_GCVERIFY_FORCE_WAIT_EXPIRED; }
    if (dwHonorFailureWindow == 0) { dwHonorFailureWindow = DEFAULT_GCVERIFY_HONOR_FAILURE_WINDOW; }
    if (gdwFindGcOffsiteFailbackTime == 0) { gdwFindGcOffsiteFailbackTime = DEFAULT_GCVERIFY_FINDGC_OFFSITE_FAILBACK_TIME; }
    // DC invalidation period can be zero (essentially disabling the DC invalidation list -- i.e. the old functionality)

    // store gcverify params
    gliForceRediscoveryWindow.QuadPart = (LONGLONG)dwForceRediscoveryWindow * 10000000;
    gliForceWaitExpired.QuadPart = (LONGLONG)dwForceWaitExpired * 10000000;
    gliHonorFailureWindow.QuadPart = (LONGLONG)dwHonorFailureWindow * 10000000;
    gliDcInvalidationPeriod.QuadPart = (LONGLONG)dwDcInvalidationPeriod * 10000000;
}

ULONG GetRegistryOrDefault(char *pKey, ULONG uldefault, ULONG ulMultiplier)
{
    DWORD dwRegistryValue;

    if (GetConfigParam(pKey, &dwRegistryValue, sizeof(dwRegistryValue))) {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
                 szInsertSz(pKey),
                 szInsertUL(uldefault),
                 NULL);
        dwRegistryValue = uldefault;
    }
    return (dwRegistryValue * ulMultiplier);
}

void
GetExchangeParameters(void)
/*++

Routine Description:

    Read a bunch of Exchange parameters from the registry.  Use defaults if the
    keys are not found.

Parameters:

    None

Return Values:

    None.

--*/
{
    DBPOS *     pDB = NULL;
    int         err;
    DWORD       dwOptions;
    THSTATE    *pTHS=pTHStls;
    BOOL        fLoadMapi;

    // we start the NSPI interface either because registry setting says so
    // or because we are a GC. By now, we know whether we are a GC or NOT.
    // NOTE that if we are not a GC and become a GC later, we will NOT start
    // the NSPI interface unless we are rebooted.


    DBOpen( &pDB );
    err = DIRERR_INTERNAL_FAILURE;

    __try
    {
        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        if ( 0 != DBFindDSName( pDB, gAnchor.pDSADN ) )
        {
            LogEvent(
                DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_DSA_OBJ,
                NULL,
                NULL,
                NULL
                );

            err = DIRERR_CANT_FIND_DSA_OBJ;
        }
        else
        {
            if (0 != DBGetSingleValue(
                        pDB,
                        ATT_OPTIONS,
                        &dwOptions,
                        sizeof( dwOptions ),
                        NULL
                        )
                )
            {
                // alright -- no options set
                dwOptions = 0;
            }

            // success
            err = 0;
        }
    }
    __finally
    {
         DBClose( pDB, FALSE );
    }

    // we had an error, so assume that we are not a GC
    if (err != 0) {
        dwOptions = 0;
    }

    // Should we even turn on the MAPI interface?
    fLoadMapi = (dwOptions & NTDSDSA_OPT_IS_GC) && gAnchor.pExchangeDN;

    // See if the registry overrides the default behaviour in fLoadMapi
    gbLoadMapi = GetRegistryOrDefault(
            MAPI_ON_KEY,
            fLoadMapi, // so we are a GC (or will become one near soon)
            1);

    return;
}

void
GetHeuristics(void)
{
    /* Get the heuristics key.  This returns no params because we really
     * dont care if it fails.
     */
    char caHeuristics[128];

    /* fill array with "default behavior" character */
    memset(caHeuristics, '0', sizeof(caHeuristics));

    // check if the setup is running before we check if the registry key exists
    if (IsSetupRunning()) {
        gfDisableBackgroundTasks = TRUE;
    }

    if (GetConfigParam(DSA_HEURISTICS, caHeuristics, sizeof(caHeuristics))) {
        return;
    }

    if ( '1' == caHeuristics[AllowWriteCaching] ) {
        gulAllowWriteCaching = 1;
    }

    if ( '1' == caHeuristics[ValidateSDHeuristic] )
        gulValidateSDs = 1;

    /* Use of the mail-compression heuristic is obsolete */

    //disable background tasks if the key is set
    //or if system setup is in progress
    if ( '1' == caHeuristics[SuppressBackgroundTasksHeuristic] ) {
        gfDisableBackgroundTasks = TRUE;
    }

    if ( '1' == caHeuristics[BypassLimitsChecks] ) {
        DisableLdapLimitsChecks( );
    }

    if ( '1' == caHeuristics[IgnoreBadDefaultSD] ) {
        gulIgnoreBadDefaultSD = 1;
    }

    if ( '1' == caHeuristics[SuppressCircularLogging] ) {
        gulCircularLogging = FALSE;
    }

    if ( '1' == caHeuristics[ReturnErrOnGCSearchesWithNonGCAtts]) {
        gulGCAttErrorsEnabled = 1;
    }

    if ( '1' == caHeuristics[DecoupleDefragFromGarbageCollection]) {
        gulDecoupleDefragFromGarbageCollection = 1;
    }
}


int
DsaReset(void)
/*++

Routine Description:

    This routine resets global structures based on the DSA object and schema
    objects.

    The following structures are adjusted

    gAnchor
    DNReadCache, which is a field in the DSA_ANCHOR structure
    SchemaCache

Return Value:

    0 for success; !0 otherwise

--*/
{
    int err = 0;
    WCHAR *pMachineDNName = NULL;
    DWORD  cbMachineDNName = 0;
    DSNAME *newDsa;
    int NameLen;
    void * pDummy = NULL;
    DWORD dummyDelay;

    //
    // Determine the DN of the new NTDS-DSA object
    //
    err = GetConfigParamAllocW(MAKE_WIDE(MACHINEDNNAME),
                         &pMachineDNName,
                         &cbMachineDNName);
    if (err) {
        return err;
    }
    NameLen = wcslen(pMachineDNName);

    newDsa = malloc(DSNameSizeFromLen(NameLen+1));
    if (!newDsa) {
        return !0;
    }
    RtlZeroMemory(newDsa, DSNameSizeFromLen(NameLen+1));

    wcscpy( newDsa->StringName, pMachineDNName );

    free(pMachineDNName);

    newDsa->StringName[NameLen] = L'\0';
    // The must be NameLen non-NULL characters in the string
    newDsa->NameLen = NameLen;

    newDsa->structLen = DSNameSizeFromLen(NameLen);

    //
    // Replace the DSA name and reset the Anchor fields
    //

    err = LocalRenameDSA(pTHStls, newDsa);

    // Done with this string
    free(newDsa);

    if (err) {
        return err;
    }

    // Rebuild Anchor.
    dummyDelay = TASKQ_DONT_RESCHEDULE;
    RebuildAnchor(NULL, &pDummy, &dummyDelay);
    if (dummyDelay != TASKQ_DONT_RESCHEDULE) {
        // The task failed for some reason. Reschedule as requested.
        InsertInTaskQueue(TQ_RebuildAnchor, NULL, dummyDelay);
        // REVIEW: should we fail instead?
    }

    //
    // Re-load the schema cache
    //
    iSCstage=0;
    pTHStls->UpdateDITStructure=TRUE;
    err = LoadSchemaInfo(pTHStls);
    if (err) {
        return err;
    }

    DsaSetIsRunning();
    gResetAfterInstall = TRUE;
    return err;

}


VOID
DsaDisableUpdates(
    VOID
    )
/*++

Routine Description:

    This routine is provided for the demotion operation so while the server is
    being demoted, the ds will not accept any updates.

Arguments:

    None

Return Value:

    None.
--*/
{
    Assert( gUpdatesEnabled == TRUE );
    gUpdatesEnabled = FALSE;
}

VOID
DsaEnableUpdates(
    VOID
    )
/*++

Routine Description:

    This routine is provided for the demotion operation so while the server is
    being demoted, the ds will will start accepting updates again.

Arguments:

    None

Return Value:

    None.
--*/
{
    Assert( gUpdatesEnabled == FALSE );
    gUpdatesEnabled = TRUE;
    gbFsmoGiveaway = FALSE; // Enable this DC to accept FSMO transfers again.
}

BOOL
DllMain(
        HINSTANCE hinstDll,
        DWORD dwReason,
        LPVOID pvReserved
        )
/*++

Routine Description:

    This routine is invoked when interesting things happen to the dll.
    Why is it here? To make sure that no threads exit with un-freed
    THSTATEs.

Arguments:

        hinstDll - an instance handle for the DLL.
        dwReason - The reason the routine was called.
        pvReserved - Unused, unless dwReason is DLL_PROCESS_DETACH.

Return Value:

   TRUE

--*/
{
    BOOL fReturn;

    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
      case DLL_THREAD_ATTACH:
      case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
#if DBG
        // These THSTATE leakage asserts have not fired for quite a while.
        // We make this check debug only.
        if (dwTSindex == INVALID_TS_INDEX) {
            // we have not initialized yet, skip thstate checks
            break;
        }
        Assert(pTHStls == NULL); /* We should have freed our thread state */
        // PERFORMANCE - This check causes us to have to have a thread detach
        // routine, which is not free, and would ideally be avoided.  However,
        // the asserts have occasionally gone off (due to bugs elsewhere),
        // and so we're leaving this code in place until we gain more
        // confidence that we'll be safe.
        /* And we shouldn't have any others saved */
        if (!THVerifyCount(0)) {
            Assert(!"THSTATEs leaked");
            CleanUpThreadStateLeakage();
        }
        //PERFORMANCE - end of code to remove before ship
#endif
        break;

      default:
        break;
    }
    return(TRUE);
}


//
// Check the garbage collection parameters and run garbage collection
//

void
GarbageCollection(ULONG *pNextPeriod)
{
    THSTATE *pTHS = pTHStls;
    int     iErr;
    DWORD   dbErr;
    ULONG   ulTombstoneLifetimeDays;
    ULONG   ulGCPeriodHours;
    DSTIME  Time;

    // set defaults
    ulTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
    ulGCPeriodHours         = DEFAULT_GARB_COLLECT_PERIOD;

    iErr = SyncTransSet( SYNC_READ_ONLY );

    if ( 0 == iErr )
    {
        __try
        {
            ULONG   ulValue;

            // seek to enterprise-wide DS config object
            if (gAnchor.pDsSvcConfigDN) {
                dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDsSvcConfigDN );
            }
            else {
                dbErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( 0 == dbErr )
            {
                // Read the garbage collection period and tombstone lifetime from
                // the config object. If either is absent, use defaults.

                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_TOMBSTONE_LIFETIME,
                            &ulValue,
                            sizeof( ulValue ),
                            NULL
                            );
                if ( 0 == dbErr )
                {
                    ulTombstoneLifetimeDays = ulValue;
                }

                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_GARBAGE_COLL_PERIOD,
                            &ulValue,
                            sizeof( ulValue ),
                            NULL
                            );
                if ( 0 == dbErr )
                {
                    ulGCPeriodHours = ulValue;
                }



                // check that the GC period is less that a week
                //
                // this is needed because taskq does not allow rescheduling of
                // jobs with period >= 47 days
                // because we don't want to overflow the arithmetic, (32bit),
                // we stop at 7 days (we can go up to 15)
                //
                if (ulGCPeriodHours > WEEK_IN_HOURS) {
                        LogAndAlertEvent( DS_EVENT_CAT_GARBAGE_COLLECTION,
                                          DS_EVENT_SEV_BASIC,
                                          DIRLOG_GC_CONFIG_PERIOD_TOOLONG,
                                          szInsertUL(ulGCPeriodHours),
                                          szInsertUL(WEEK_IN_HOURS),
                                          szInsertUL(WEEK_IN_HOURS) );

                        DPRINT1 (0, "Garbage Collection Period too long: %d hours\n", ulGCPeriodHours);

                        // set it to one week
                        ulGCPeriodHours = WEEK_IN_HOURS;
                }

                // Check that tombstone lifetime is not too short
                // and that tombstone lifetime is at least three
                // times as long as garbage collection period.

                if (    ( ulTombstoneLifetimeDays < DRA_TOMBSTONE_LIFE_MIN )
                     || (   ulTombstoneLifetimeDays * DAYS_IN_SECS
                          < ( 3 * ulGCPeriodHours * HOURS_IN_SECS )
                        )
                   )
                {
                    LogAndAlertEvent( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                                      DS_EVENT_SEV_BASIC,
                                      DIRLOG_DRA_CONFIG_MISMATCH,
                                      NULL,
                                      NULL,
                                      NULL );

                    // set defaults
                    ulTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
                    ulGCPeriodHours         = DEFAULT_GARB_COLLECT_PERIOD;
                }

            }
        }
        __finally
        {
            SyncTransEnd( pTHS, TRUE );
        }
    }

    // update global config parameters
    gulTombstoneLifetimeSecs = ulTombstoneLifetimeDays * DAYS_IN_SECS;
    gulGCPeriodSecs          = ulGCPeriodHours         * HOURS_IN_SECS;


    Time = DBTime() - gulTombstoneLifetimeSecs;

    if ( Garb_Collect( Time ) ) {
        DPRINT( 1, "Warning: Garbage collection did not succeed.  Rescheduling at half normal delay.\n" );
        *pNextPeriod = 0;
    } else {
        *pNextPeriod = gulGCPeriodSecs;
    }
}


DWORD
UpgradeDsa(
    THSTATE     *pTHS,
    LONG        lOldDsaVer,
    LONG        lNewDsaVer
    )
/*++

Routine Description:

    Perform DSA Upgrade operations based upon Dsa version upgrade.

    This function is called within the same transaction as the version upgrade
    write. Failure to conduct the operation will result w/ the entire write
    failing. Thus be careful when you decide to fail this.

Arguments:

    pTHS - Thread state
    lOldDsaVer - Old DSA version prior to upgrade
    lNewDsaVer - New DSA version that's going to get commited


Return Value:
    Error in WIN32 error space
    ** Warning: Error may fail DSA installation **

Remarks:
    Assumes pTHS->pDB is on the ntdsDsa object

--*/
{

    DWORD dwErr = ERROR_SUCCESS;

    Assert(pTHS->JetCache.transLevel > 0);
    Assert(CheckCurrency(gAnchor.pDSADN));

    //
    // Call various modules upgrade entry points
    // (currently DRA only)
    //
    dwErr = DraUpgrade(pTHS, lOldDsaVer, lNewDsaVer);

    return dwErr;
}

DWORD SetFolderSecurity(PCHAR szFolder, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
// Routine description:
//   Set security on a file system folder
//
// Parameters:
//   szFolder -- folder path
//   si       -- which parts of SD to apply (only DACL and SACL can be applied)
//   pSD      -- the security descriptor
//
// Return value:
//   error value
//
{
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD dwErr = 0;
    BOOL fPresent, fDefaulted;
    SECURITY_DESCRIPTOR_CONTROL sdControl;
    DWORD dwRevision;

    si &= DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION;
    if (si == 0) {
        // nothing to set
        return 0;
    }

    // grab the SD control
    if (!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision)) {
        dwErr = GetLastError();
        DPRINT1(0, "GetSecurityDescriptorControl() failed. Error %d\n", dwErr);
        return dwErr;
    }

    if (si & DACL_SECURITY_INFORMATION) {
        if (!GetSecurityDescriptorDacl(pSD, &fPresent, &pDacl, &fDefaulted)) {
            dwErr = GetLastError();
            DPRINT1(0, "GetSecurityDescriptorDacl() failed. Error %d\n", dwErr);
            return dwErr;
        }
        if (sdControl & SE_DACL_PROTECTED) {
            // need to protect DACL
            si |= PROTECTED_DACL_SECURITY_INFORMATION;
        }
        if ((sdControl & SE_DACL_AUTO_INHERIT_REQ) || (sdControl & SE_DACL_AUTO_INHERITED)) {
            // need to unprotect DACL
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        }
    }
    if (si & SACL_SECURITY_INFORMATION) {
        if (!GetSecurityDescriptorSacl(pSD, &fPresent, &pSacl, &fDefaulted)) {
            dwErr = GetLastError();
            DPRINT1(0, "GetSecurityDescriptorSacl() failed. Error %d\n", dwErr);
            return dwErr;
        }
        if (sdControl & SE_SACL_PROTECTED) {
            // need to protect SACL
            si |= PROTECTED_SACL_SECURITY_INFORMATION;
        }
        if ((sdControl & SE_SACL_AUTO_INHERIT_REQ) || (sdControl & SE_SACL_AUTO_INHERITED)) {
            // need to unprotect SACL
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
        }
    }
    dwErr = SetNamedSecurityInfo(szFolder, SE_FILE_OBJECT, si, NULL, NULL, pDacl, pSacl);
    if (dwErr) {
        DPRINT1(0, "SetNamedSecurityInfo() failed. Error %d\n", dwErr);
    }
    return dwErr;
}

DWORD
SceStatusToDosError(
    IN SCESTATUS SceStatus
    )
// converts SCESTATUS error code to dos error defined in winerror.h
// code stolen from \ds\security\services\scerpc\fileshr\util.cpp
{
    switch(SceStatus) {

    case SCESTATUS_SUCCESS:
        return(NO_ERROR);

    case SCESTATUS_OTHER_ERROR:
        return(ERROR_EXTENDED_ERROR);

    case SCESTATUS_INVALID_PARAMETER:
        return(ERROR_INVALID_PARAMETER);

    case SCESTATUS_RECORD_NOT_FOUND:
        return(ERROR_NO_MORE_ITEMS);

    case SCESTATUS_INVALID_DATA:
        return(ERROR_INVALID_DATA);

    case SCESTATUS_OBJECT_EXIST:
        return(ERROR_FILE_EXISTS);

    case SCESTATUS_BUFFER_TOO_SMALL:
        return(ERROR_INSUFFICIENT_BUFFER);

    case SCESTATUS_PROFILE_NOT_FOUND:
        return(ERROR_FILE_NOT_FOUND);

    case SCESTATUS_BAD_FORMAT:
        return(ERROR_BAD_FORMAT);

    case SCESTATUS_NOT_ENOUGH_RESOURCE:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case SCESTATUS_ACCESS_DENIED:
        return(ERROR_ACCESS_DENIED);

    case SCESTATUS_CANT_DELETE:
        return(ERROR_CURRENT_DIRECTORY);

    case SCESTATUS_PREFIX_OVERFLOW:
        return(ERROR_BUFFER_OVERFLOW);

    case SCESTATUS_ALREADY_RUNNING:
        return(ERROR_SERVICE_ALREADY_RUNNING);

    case SCESTATUS_SERVICE_NOT_SUPPORT:
        return(ERROR_NOT_SUPPORTED);

    default:
        return(ERROR_EXTENDED_ERROR);
    }
}

// DC default security template
#define SECURITY_TEMPLATE L"\\inf\\defltdc.inf"
#define SECURITY_TEMPLATE_LEN (sizeof(SECURITY_TEMPLATE)/sizeof(WCHAR))
// keys in the template
#define DSDIT_KEY L"%DSDIT%"
#define DSLOG_KEY L"%DSLOG%"

DWORD SetDefaultFolderSecurity()
//  Routine Description:
//
//    Set the default security on the DS folder paths.
//    Load the default security template %windir%\inf\defltdc.inf and grab the SDs from there.
//    We only set security on DB and log paths. If DB==log, then log security wins (according
//    to the comment in the template file).
//
//  Return:
//    error value
//
{
    CHAR szDataPath[MAX_PATH+1];
    CHAR szLogPath[MAX_PATH+1];
    WCHAR szTemplatePath[MAX_PATH+1];
    PCHAR pLastSlash;
    PSCE_PROFILE_INFO spi = NULL;
    PVOID hProfile = NULL;
    DWORD dwErr = 0;
    DWORD i;
    DWORD dsID = 0;
    PSCE_OBJECT_SECURITY pDSDITSecurity = NULL, pDSLOGSecurity = NULL;

    DPRINT(0, "Setting default security on NTDS folders...\n");

    // get the db file with full path
    if (dwErr = GetConfigParam(FILEPATH_KEY, szDataPath, sizeof(szDataPath)))
    {
        dsID = DSID(FILENO, __LINE__);
        // Unable to get the DSA DB path - log event & bailout
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(FILEPATH_KEY),
            NULL,
            NULL);

        goto finish;
    }

    // get the log file path
    if (dwErr = GetConfigParam(LOGPATH_KEY, szLogPath, sizeof(szLogPath)))
    {
        dsID = DSID(FILENO, __LINE__);

        // Unable to get the DSA DB path - log event & bailout
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(LOGPATH_KEY),
            NULL,
            NULL);

        goto finish;
    }

    // convert DB file path to a folder path
    pLastSlash = strrchr(szDataPath, '\\');
    if (pLastSlash != NULL) {
        *pLastSlash = '\0';
    }

    // read the security template
    if (GetWindowsDirectoryW(szTemplatePath, sizeof(szTemplatePath)/sizeof(WCHAR)) == 0) {
        dwErr = GetLastError();
        dsID = DSID(FILENO, __LINE__);
        DPRINT1(0, "GetWindowsDirectoryW() returned 0x%h\n", dwErr);
        goto finish;
    }
    // make sure we have enough space in the path
    if (wcslen(szTemplatePath) + SECURITY_TEMPLATE_LEN >= sizeof(szTemplatePath)/sizeof(WCHAR)) {
        dwErr = ERROR_BUFFER_OVERFLOW;
        DPRINT(0, "Template path is too long\n");
        goto finish;
    }
    wcscat(szTemplatePath, SECURITY_TEMPLATE);

    if (dwErr = SceOpenProfile(szTemplatePath, SCE_INF_FORMAT, &hProfile)) {
        dwErr = SceStatusToDosError(dwErr);
        dsID = DSID(FILENO, __LINE__);
        DPRINT1(0, "Unable to open security template: SceOpenProfile() returned %d\n", dwErr);
        goto finish;
    }

    if (dwErr = SceGetSecurityProfileInfo(hProfile, SCE_ENGINE_SCP, AREA_FILE_SECURITY, &spi, NULL)) {
        dwErr = SceStatusToDosError(dwErr);
        dsID = DSID(FILENO, __LINE__);
        DPRINT1(0, "Unable to read security template: SceGetSecurityProfileInfo() returned error %d\n", dwErr);
        goto finish;
    }

    // now, find the security descriptors in the loaded info
    for (i = 0; i < spi->pFiles.pAllNodes->Count; i++) {
        PSCE_OBJECT_SECURITY pObjSecurity = spi->pFiles.pAllNodes->pObjectArray[i];
        if (_wcsicmp(pObjSecurity->Name, DSDIT_KEY) == 0) {
            pDSDITSecurity = pObjSecurity;
        }
        else if (_wcsicmp(pObjSecurity->Name, DSLOG_KEY) == 0) {
            pDSLOGSecurity = pObjSecurity;
        }
    }
    if (pDSDITSecurity == NULL || pDSLOGSecurity == NULL) {
        // We did not find the required entries. Log an error
        dwErr = ERROR_INVALID_DATA;
        dsID = DSID(FILENO, __LINE__);
        DPRINT2(0, "Invalid security template: one or both %S and %S are not present\n", DSDIT_KEY, DSLOG_KEY);
        goto finish;
    }

    // Update the SD on the Log folder first.
    if (dwErr = SetFolderSecurity(szLogPath, pDSLOGSecurity->SeInfo, pDSLOGSecurity->pSecurityDescriptor)) {
        dsID = DSID(FILENO, __LINE__);
        goto finish;
    }

    // if data path is different form log path, then try to update it too
    if (_stricmp(szLogPath, szDataPath) != 0) {
        if (dwErr = SetFolderSecurity(szDataPath, pDSDITSecurity->SeInfo, pDSDITSecurity->pSecurityDescriptor)) {
            dsID = DSID(FILENO, __LINE__);
            goto finish;
        }
    }

finish:
    if (dwErr == 0) {
        DPRINT(0, "Default security on NTDS folders was set successfully.\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DSA_SET_DEFAULT_NTFS_SECURITY_SUCCESS,
                 NULL,
                 NULL,
                 NULL);
    }
    else {
        DPRINT(0, "Failed to set default security on NTDS folders.\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DSA_SET_DEFAULT_NTFS_SECURITY_FAILURE,
                 szInsertInt(dwErr),
                 szInsertWin32Msg(dwErr),
                 szInsertHex(dsID));
    }

    if (spi) {
        SceFreeProfileMemory(spi);
    }

    if (hProfile) {
        SceCloseProfile(&hProfile);
    }

    return dwErr;
}

VOID CheckSetDefaultFolderSecurity()
//  Routine Description:
//
//    If the "Update folder security" reg flag is set, then run SetDefaultFolderSecurity and
//    remove the flag.
//    Otherwize the flag was not set, just return.
//
{
    DWORD dwValue = 0;
    DWORD dwErr;

    if (GetConfigParam(DSA_UPDATE_FOLDER_SECURITY, &dwValue, sizeof(dwValue))) {
        // value is apparently not there
        return;
    }

    if (dwValue == 1) {
        // the flag is set. Set the security
        dwErr = SetDefaultFolderSecurity();
        // We will ignore the return value and clear the flag anyway.
        // If there was some problem, then there will be an error logged
        // and the user can run ntdsutil to set this flag again.
    }

    // delete the value
    DeleteConfigParam(DSA_UPDATE_FOLDER_SECURITY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\dsatools.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dsatools.c
//
//--------------------------------------------------------------------------

/*

Description:
    Ancillary functions for the DSA. Includes memory management
    functions.

*/

#include <NTDSpch.h>
#pragma  hdrstop
#include <dsconfig.h>

// Core DSA headers.
#include <dbghelp.h>
#include <ntdsa.h>
#include <dsjet.h>      /* for error codes */
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dstaskq.h>
#include <dstrace.h>
#include <msrpc.h>
// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include "dsexcept.h"
#include "debug.h"                      // standard debugging header
#include "mappings.h"
#include "ntdsctr.h"                    // perf counters
#include "pek.h"                        // PEK* routines
#include "drserr.h"

#include <nlwrap.h>                     // I_NetLogon wrappers

#define DEBSUB "DSATOOLS:"              // define the subsystem for debugging

// DRA headers
#include "drautil.h"
#include "draasync.h"

// SAM headers
#include "samsrvp.h"                    // SampUseDsData

#include "debug.h"

#include <fileno.h>
#define  FILENO FILENO_DSATOOLS

#define InZone(pz, pm) (((PUCHAR)(pm) >= (pz)->Base) && ((PUCHAR)(pm) < (pz)->Cur))

extern BOOL gbCriticalSectionsInitialized;

//
// client ID
//

DWORD gClientID = 1;

// Globals for keeping track of ds_waits.
ULONG ulMaxWaits = 0;
ULONG ulCurrentWaits = 0;

// The maximum time (in msec) that a thread state should be allowed to be open
// during normal operation.           
DWORD gcMaxTicksAllowedForTHSTATE = 12 * 60 * 60 * 1000L; // 12 hours.
// The maximum amount of bytes that a thread state should be allowed to have 
// allocated in it's heap.
DWORD gcMaxHeapMemoryAllocForTHSTATE = DEFAULT_THREAD_STATE_HEAP_LIMIT;

// A global variable that indicates whether we think the DS is writable
// at the moment (i.e., if JET seems ok, and is not out of disk space)
// Initially not writable, until called during SetIsSynchronized.
BOOL gfDsaWritable = FALSE;
CRITICAL_SECTION csDsaWritable;

//
// Global for max temp table size
//

DWORD   g_MaxTempTableSize = DEFAULT_LDAP_MAX_TEMP_TABLE;

NT4SID gNullNT4SID;

// Global usn vector indicating the NC should be synced from scratch.

USN_VECTOR gusnvecFromScratch = { 0, 0, 0 };

// Global usn vector indicating the NC should be synced from max USNs
// (i.e., don't send any objects).

USN_VECTOR gusnvecFromMax = { MAXLONGLONG, MAXLONGLONG, MAXLONGLONG };


#define NUM_DNT_HASH_TABLE_ENTRIES  ( 256 )
#define DNT_HASH_TABLE_SIZE         (    NUM_DNT_HASH_TABLE_ENTRIES \
                                      * sizeof( DNT_HASH_ENTRY )    \
                                    )
#define DNT_HASH( dnt )             ( dnt % NUM_DNT_HASH_TABLE_ENTRIES )


#ifdef CACHE_UUID

// This is the structure where we cache UUIDs against names so that we
// can report names as well as numbers.

typedef struct _Uuid_Cache_entry
{
    UUID Uuid;
    struct _Uuid_Cache_entry *pCENext;
    char DSAName[1];
} UUID_CACHE_ENTRY;


// This is the head of the linked list of entries

UUID_CACHE_ENTRY *gUuidCacheHead = NULL;

// Guard critical section

CRITICAL_SECTION csUuidCache;

#endif

#ifndef MACROTHSTATE
__declspec(thread) THSTATE *pTHStls=NULL;
#endif

//
// This function is called in here temporaririly till the
// notification mechanism is enabled.
//
VOID
SampInvalidateAllSamDomains(VOID);


BOOL
GetWellKnownDNT (
        DBPOS   *pDB,
        GUID *pGuid,
        DWORD *pDNT
        )
/*++
  Description:
      Look through the well known objects attribute of the current object
      looking for the GUID passed in.  If it's found, return the DNT of the
      object associated with it, and return TRUE.

      If we can't find the guid for some reason, return FALSE.
--*/
{
    unsigned err=0;
    DWORD iVal;
    ATTCACHE *pAC = SCGetAttById(pDB->pTHS, ATT_WELL_KNOWN_OBJECTS);
    INTERNAL_SYNTAX_DISTNAME_STRING *pVal=NULL;
    DWORD   cbAllocated=0, cbUsed=0;

    *pDNT = INVALIDDNT;

    Assert(pAC);

    iVal = 0;
    while ( !err ) {
        iVal++;
        cbUsed = 0;

        //
        // PREFIX: PREFIX complains that pAC hasn't been checked to
        // make sure that it is not NULL.  This is not a bug.  Since
        // a predefined constant was passed to SCGetAttById, pAC will
        // never be NULL.
        //
        err = DBGetAttVal_AC(pDB,
                             iVal,
                             pAC,
                             DBGETATTVAL_fINTERNAL,
                             cbAllocated,
                             &cbUsed,
                             (UCHAR **) &pVal);

        cbAllocated = max(cbAllocated, cbUsed);

        if(!err &&
           !memcmp(pGuid,
                   pVal->data.byteVal,
                   sizeof(GUID)) ) {
            *pDNT = pVal->tag;
            THFreeEx(pDB->pTHS, pVal);
            return TRUE;
        }
    }
    if(pVal) {
        THFreeEx(pDB->pTHS, pVal);
    }

    return FALSE;

}


BOOL
GetWellKnownDN (
        DBPOS   *pDB,
        GUID *pGuid,
        DSNAME **ppDN
        )
/*++
  Description:
      Look through the well known objects attribute of the current object
      looking for the GUID passed in.  If it's found, return the DN of the
      object associated with it, and return TRUE.

      If we can't find the guid for some reason, return FALSE.
--*/
{
    unsigned err=0;
    SYNTAX_DISTNAME_BINARY * pDNB = NULL;
    ULONG iVal = 0, valLen;
    ATTCACHE *pAC = SCGetAttById(pDB->pTHS, ATT_WELL_KNOWN_OBJECTS);
    Assert(pAC);
    
    __try{
        do {
        iVal++;

        //
        // PREFIX: PREFIX complains that pAC hasn't been checked to
        // make sure that it is not NULL.  This is not a bug.  Since
        // a predefined constant was passed to SCGetAttById, pAC will
        // never be NULL.
        //
        err = DBGetAttVal_AC(pDB,
                             iVal,
                             pAC,
                             0,
                             0,
                             &valLen,
                             (UCHAR**)&pDNB);

        if (err) {
            // no more values.
            break;
        }
        if (PAYLOAD_LEN_FROM_STRUCTLEN(DATAPTR(pDNB)->structLen) == sizeof(GUID) && 
            memcmp(pGuid, DATAPTR(pDNB)->byteVal, sizeof(GUID)) == 0) 
        {
            // got it!
            break;
        }

        THFreeEx(pTHStls, pDNB);
        pDNB = NULL;

        } while (TRUE);
    
    } __finally {
    
        if (!err) {
            *ppDN = NAMEPTR(pDNB);
        } else {
            THFreeEx(pTHStls, pDNB);
    
        }
    }
    
    return !err;
    
}


VOID
InitCommarg(COMMARG *pCommArg)
/*++
  Description:
  
      Initialize a COMMARG structure 
      
--*/
{
    // Initialize to zero in case either COMMARG gets extended
    // or we forgot something below.
    memset(pCommArg, 0, sizeof(COMMARG));

    //
    // Comment out the ones we set to zero or FALSE since we
    // have already zeroed out the structure.
    //

    pCommArg->Opstate.nameRes = OP_NAMERES_NOT_STARTED;
    //pCommArg->Opstate.nextRDN = 0;
    //pCommArg->aliasRDN = 0;
    //pCommArg->pReserved = NULL;
    //pCommArg->PagedResult.fPresent = FALSE;
    //pCommArg->PagedResult.pRestart = NULL;
    pCommArg->ulSizeLimit = (ULONG) -1;
    pCommArg->fForwardSeek = TRUE;
    //pCommArg->Delta = 0;
    pCommArg->MaxTempTableSize = g_MaxTempTableSize;
    //pCommArg->SortAttr = 0;
    pCommArg->SortType = SORT_NEVER;
    //pCommArg->StartTick = 0;
    //pCommArg->DeltaTick = 0;
    //pCommArg->fFindSidWithinNc = FALSE;
    //pCommArg->Svccntl.makeDeletionsAvail = FALSE;
    //pCommArg->Svccntl.fUnicodeSupport = FALSE;
    //pCommArg->Svccntl.fStringNames = FALSE;
    pCommArg->Svccntl.chainingProhibited = TRUE;
    //pCommArg->Svccntl.preferChaining = FALSE;
    pCommArg->Svccntl.DerefAliasFlag = DA_BASE;
    //pCommArg->Svccntl.dontUseCopy = FALSE;
    pCommArg->Svccntl.fMaintainSelOrder = TRUE;
    //pCommArg->Svccntl.fDontOptimizeSel = FALSE;
    //pCommArg->Svccntl.fSDFlagsNonDefault = FALSE;
    //pCommArg->Svccntl.localScope = FALSE;
    //pCommArg->Svccntl.fPermissiveModify = FALSE;
    pCommArg->Svccntl.SecurityDescriptorFlags =
        (SACL_SECURITY_INFORMATION  |
         OWNER_SECURITY_INFORMATION |
         GROUP_SECURITY_INFORMATION |
         DACL_SECURITY_INFORMATION    );
    //pCommArg->Svccntl.fUrgentReplication = FALSE;
    //pCommArg->Svccntl.fAuthoritativeModify = FALSE;
}


VOID
SetCommArgDefaults(
    IN DWORD MaxTempTableSize
    )
{
    g_MaxTempTableSize = MaxTempTableSize;

} // SetCommArgDefaults




// =====================================================================
//
//     Heap Related Functions / Variables
//
// =====================================================================

DWORD dwHeapFailureLastLogTime = 0;
const DWORD dwHeapFailureMinLogGap = 5 * 60 * 1000; // five minutes
DWORD dwHeapFailures = 0;
CRITICAL_SECTION csHeapFailureLogging;
BOOL bHeapFailureLogEnqueued = FALSE;

// The following defines the tags attached to a THSTATE.
// THSTATE_TAG_IN_USE indicates the THSTATE is being used
// by a thread; THSTATE_TAG_IN_CACHE when the THSTATE is in cache.
// The tag is a LONGLONG(8 bytes), and is stored right before the THSTATE.
#define THSTATE_TAG_IN_USE        0x0045544154534854
// equivalent to "THSTATE"

#define THSTATE_TAG_IN_CACHE      0x0065746174736874
// equivalent to "thstate"

#define MAX_ALLOCS 128
#define MAX_TRY 3

#if DBG
static char ZoneFill[]="DeadZone";
#endif

PPLS grgPLS[MAXIMUM_PROCESSORS];
size_t gcProcessor;

#if DBG
unsigned gcHeapCreates = 0;
unsigned gcHeapDestroys = 0;
unsigned gcHeapGrabs = 0;
unsigned gcHeapRecycles = 0;
#define DBGINC(x) ++x
#else
#define DBGINC(x)
#endif



// the following are used for tracing THSTATE allocations 
//
#ifdef USE_THALLOC_TRACE

#define THALLOC_LOG_SIZE          1024
#define THALLOC_LOG_NUM_MEM_STACK    8

typedef struct _ALLOC_INFO {
    DWORD       dsid;
    DWORD       size;
    ULONG_PTR   Stack[THALLOC_LOG_NUM_MEM_STACK];
} ALLOC_INFO;

// record max of 8 reallocs
#define MAX_REALLOCS 8

typedef struct _ALLOC_ENTRY
{
    PVOID      pMem;
    ALLOC_INFO aiAlloc;
    ALLOC_INFO aiReallocs[MAX_REALLOCS];
    DWORD      cReallocs;
    ALLOC_INFO aiFree;
} ALLOC_ENTRY;

typedef struct _ThAllocDebugHeapLogBlock
{
    struct _ThAllocDebugHeapLogBlock *pPrevious;
    
    DWORD cnt;
    ALLOC_ENTRY info[THALLOC_LOG_SIZE];
} ThAllocDebugHeapLogBlock;

DWORD          gfUseTHAllocTrace = 0;           // ORed flags for ThAlloc tracing. see below for values
THSTATE      * gpTHAllocTraceThread = NULL;     // the thread that we want to monitor (if we monitor)

// these FLAGS are used for THAlloc tracing
#define FLAG_THALLOC_TRACE_TRACK_LEAKS 0x1    // track memory leaks
#define FLAG_THALLOC_TRACE_LOG_ALL     0x2    // track ALL allocations in a log. cannot be used with track leaks
#define FLAG_THALLOC_TRACE_BOUNDARIES  0x4    // insert data around allocation so as to check during de-allocation
#define FLAG_THALLOC_TRACE_STACK       0x8    // take stack traces too
#define FLAG_THALLOC_TRACE_USETHREAD  0x10    // track only thread pointed by gpTHAllocTraceThread

HANDLE  hDbgProcessHandle = 0;
CHAR    DbgSearchPath[MAX_PATH+1];


VOID
DbgStackInit(
    VOID
    )
/*++
Routine Description:
    Initialize anything necessary to get a stack trace

Arguments:
    None.

Return Value:
    None.
--*/
{

    hDbgProcessHandle = GetCurrentProcess();

    //
    // Initialize the symbol subsystem
    //
    if (!SymInitialize(hDbgProcessHandle, NULL, FALSE)) {
        DPRINT1(0, "Could not initialize symbol subsystem (imagehlp) (error 0x%x)\n" ,GetLastError());
        hDbgProcessHandle = 0;

        return;
    }

    //
    // Load our symbols
    //
    if (!SymLoadModule(hDbgProcessHandle, NULL, "ntdsa.dll", "ntdsa", 0, 0)) {
        DPRINT1(0, "Could not load symbols for ntdsa.dll (error 0x%x)\n", GetLastError());
    
        hDbgProcessHandle = 0;

        return;
    }

    //
    // Search path
    //
    if (!SymGetSearchPath(hDbgProcessHandle, DbgSearchPath, MAX_PATH)) {
        DPRINT1(0, "Can't get search path (error 0x%x)\n", GetLastError());
    
        hDbgProcessHandle = 0;

    } else {
        DPRINT1(0, "Symbol search path is %s\n", DbgSearchPath);
    }

    SymSetOptions(SYMOPT_LOAD_LINES);
}


extern BOOL gfIsConsoleApp;
#define DoPrint(str) { DbgPrint(str); if (gfIsConsoleApp) printf(str); }
#define DoPrint1(str,a1) { DbgPrint(str,a1); if (gfIsConsoleApp) printf(str,a1); }
#define DoPrint2(str,a1,a2) { DbgPrint(str,a1,a2); if (gfIsConsoleApp) printf(str,a1,a2); }

VOID
DbgSymbolPrint(
    IN ULONG_PTR    Addr
    )
/*++
Routine Description:
    Print a symbol

Arguments:
    Addr

Return Value:
    None.
--*/
{
    ULONG_PTR Displacement = 0;

    struct MyMymbol {
        IMAGEHLP_SYMBOL Symbol;
        char Path[MAX_PATH];
    } MySymbol;
    IMAGEHLP_LINE line;
    PCHAR pFile;
    CHAR func[100], fileStr[100];

    try {
        ZeroMemory(&MySymbol, sizeof(MySymbol));
        MySymbol.Symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        MySymbol.Symbol.MaxNameLength = MAX_PATH;
        line.SizeOfStruct = sizeof(line);

        if (!SymGetSymFromAddr(hDbgProcessHandle, Addr, &Displacement, &MySymbol.Symbol)) {
            DoPrint2("  0x%08x: Unknown Symbol (error 0x%x)\n", Addr, GetLastError());
            __leave;
        }
        sprintf(func, "%s+0x%x", &MySymbol.Symbol.Name, Displacement);
        if (SymGetLineFromAddr(hDbgProcessHandle, Addr, &Displacement, &line)) {
            #define DS_BASE_FOLDER "ds\\ds\\src\\ntdsa\\"
            // find base folder
            pFile = strstr(line.FileName, DS_BASE_FOLDER);
            if (pFile) {
                pFile += sizeof(DS_BASE_FOLDER)-1;
            }
            else {
                pFile = line.FileName;
            }
            sprintf(fileStr, "%s:%d", pFile, line.LineNumber);
        }
        else {
            strcpy(fileStr, "");
        }
        DoPrint2("  %-48s %s\n", func, fileStr);

    } except (HandleAllExceptions(GetExceptionCode())) {
        DoPrint2("  0x%08x: Unknown Symbol (error 0x%x)\n", Addr, GetExceptionCode());
    }
}

VOID
DbgStackTrace(
    IN THSTATE     *pTHS,
    IN PULONG_PTR   Stack,
    IN ULONG        Depth,
    IN LONG         Skip
    )
/*++
Routine Description:
    Trace the stack back up to Depth frames. The current frame is included.

Arguments:
    Stack   - Saves the "return PC" from each frame
    Depth   - Only this many frames

Return Value:
    None.
--*/
{
    HANDLE      ThreadToken;
    ULONG       WStatus;
    STACKFRAME  Frame;
    ULONG       i = 0;
    CONTEXT     Context;
    ULONG       FrameAddr;

    static      int StackTraceCount = 50;

    *Stack = 0;

    if (!hDbgProcessHandle) {
        return;
    }

    //
    // I don't know how to generate a stack for an alpha, yet. So, just
    // to get into the build, disable the stack trace on alphas.
    //
#if ALPHA
    return;
#elif IA64

    //
    // Need stack dump init for IA64.
    //

    return;

#else

    //
    // init
    //

    ZeroMemory(&Context, sizeof(Context));

    // no need to close this handle
    ThreadToken = GetCurrentThread();


    try { try {
        Context.ContextFlags = CONTEXT_FULL;
        if (!GetThreadContext(ThreadToken, &Context)) {
            DPRINT1(0, "Can't get context (error 0x%x)\n", GetLastError());
        }

        //
        // let's start clean
        //
        ZeroMemory(&Frame, sizeof(STACKFRAME));

        //
        // from  nt\private\windows\screg\winreg\server\stkwalk.c
        //
        Frame.AddrPC.Segment = 0;
        Frame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
        Frame.AddrFrame.Offset = Context.Ebp;
        Frame.AddrFrame.Mode = AddrModeFlat;

        Frame.AddrStack.Offset = Context.Esp;
        Frame.AddrStack.Mode = AddrModeFlat;

        Frame.AddrPC.Offset = (DWORD)Context.Eip;
#elif defined(_M_MRX000)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#elif defined(_M_ALPHA)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#endif



#if 0
        //
        // setup the program counter
        //
        Frame.AddrPC.Mode = AddrModeFlat;
        Frame.AddrPC.Segment = (WORD)Context.SegCs;
        Frame.AddrPC.Offset = (ULONG)Context.Eip;

        //
        // setup the frame pointer
        //
        Frame.AddrFrame.Mode = AddrModeFlat;
        Frame.AddrFrame.Segment = (WORD)Context.SegSs;
        Frame.AddrFrame.Offset = (ULONG)Context.Ebp;

        //
        // setup the stack pointer
        //
        Frame.AddrStack.Mode = AddrModeFlat;
        Frame.AddrStack.Segment = (WORD)Context.SegSs;
        Frame.AddrStack.Offset = (ULONG)Context.Esp;

#endif

        for (i = 0; i < (Depth - 1 + Skip); ++i) {
            if (!StackWalk(
                IMAGE_FILE_MACHINE_I386,  // DWORD                          MachineType
                hDbgProcessHandle,        // HANDLE                         hProcess
                ThreadToken,              // HANDLE                         hThread
                &Frame,                   // LPSTACKFRAME                   StackFrame
                NULL, //(PVOID)&Context,          // PVOID                          ContextRecord
                NULL,                     // PREAD_PROCESS_MEMORY_ROUTINE   ReadMemoryRoutine
                SymFunctionTableAccess,   // PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine
                SymGetModuleBase,         // PGET_MODULE_BASE_ROUTINE       GetModuleBaseRoutine
                NULL)) {                  // PTRANSLATE_ADDRESS_ROUTINE     TranslateAddress

                WStatus = GetLastError();

                //DPRINT1_WS(0, "++ Can't get stack address for level %d;", i, WStatus);
                break;
            }
            if (StackTraceCount-- > 0) {
                DPRINT1(5, "++ Frame.AddrReturn.Offset: %08x \n", Frame.AddrReturn.Offset);
                // DbgSymbolPrint(Frame.AddrReturn.Offset);
                //DPRINT1(5, "++ Frame.AddrPC.Offset: %08x \n", Frame.AddrPC.Offset);
                //DbgSymbolPrint(Frame.AddrPC.Offset);
            }

            *Stack = Frame.AddrReturn.Offset;
            
            if (Skip == 0) {
                Stack++;
                *Stack=0;
            }
            else {
                Skip--;
            }
            //
            // Base of stack?
            //
            if (!Frame.AddrReturn.Offset) {
                break;
            }
        }
    } except (HandleAllExceptions(GetExceptionCode())) {
        /* FALL THROUGH */
    } } finally {
      ;
    }
    return;
#endif 
}

void printStack(ULONG_PTR* pStack) {
    DWORD j;
    for (j = 0; *pStack && j < THALLOC_LOG_NUM_MEM_STACK; pStack++, j++) {
        DbgSymbolPrint(*pStack);
    }
}


void
ThAllocTraceRecycleHeap (THSTATE *pTHS)
{
    if (gfUseTHAllocTrace) {

        if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_USETHREAD) {
            if (gpTHAllocTraceThread != pTHS) {
                goto exit;
            }
        }

        EnterCriticalSection(&csHeapFailureLogging);
        __try {

            // maybe we should log to a file.
            ThAllocDebugHeapLogBlock *pHeapLog = (ThAllocDebugHeapLogBlock *) pTHS->pDebugHeapLog;
            DWORD index, i;
            PULONG_PTR pStack;

            DoPrint("\n==============================================================================\n");
            DoPrint1("Memory alloc tracking for THSTATE 0x%8x\n\n", pTHS);

            while (pHeapLog) {
                for (index = 0; index < pHeapLog->cnt; index++) {
                    if (pHeapLog->info[index].aiFree.dsid == 0 || (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_TRACK_LEAKS) == 0) {
                        if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
                            DoPrint1("Allocated %d bytes\n", pHeapLog->info[index].aiAlloc.size);
                            printStack(pHeapLog->info[index].aiAlloc.Stack);
                        }
                        else {
                            DoPrint2("A %8d DSID %8x, ", pHeapLog->info[index].aiAlloc.size, pHeapLog->info[index].aiAlloc.dsid);
                        }
                        for (i = 0; i < min(pHeapLog->info[index].cReallocs, MAX_REALLOCS); i++) {
                            if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
                                DoPrint1("Reallocated %d bytes\n", pHeapLog->info[index].aiReallocs[i].size);
                                printStack(pHeapLog->info[index].aiReallocs[i].Stack);
                            }
                            else {
                                DoPrint2("R %d DSID %x, ", pHeapLog->info[index].aiReallocs[i].size, pHeapLog->info[index].aiReallocs[i].dsid);
                            }
                        }
                        if (pHeapLog->info[index].cReallocs > MAX_REALLOCS) {
                            DoPrint1("(%d more Rs)", pHeapLog->info[index].cReallocs - MAX_REALLOCS);
                            if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
                                DoPrint1("%d more reallocs\n", pHeapLog->info[index].cReallocs - MAX_REALLOCS);
                            }
                            else {
                                DoPrint1("%d more Rs, ", pHeapLog->info[index].cReallocs - MAX_REALLOCS);
                            }
                                
                        }
                        if (pHeapLog->info[index].aiFree.dsid == 0) {
                            DoPrint("*** LEAKED ***\n");
                        }
                        else {
                            if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
                                DoPrint("Freed\n");
                                printStack(pHeapLog->info[index].aiFree.Stack);
                            }
                            else {
                                DoPrint1("F @%8x\n", pHeapLog->info[index].aiFree.dsid);
                            }
                        }
                        if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
                            DoPrint("------------------------------------------------------------------------------\n");
                        }
                    }
                }
                pHeapLog = pHeapLog->pPrevious;
            }
        }
        __finally {
            LeaveCriticalSection(&csHeapFailureLogging);
        }

    }

exit:
    if (pTHS->hDebugMemHeap) {
        RtlDestroyHeap(pTHS->hDebugMemHeap);
        pTHS->hDebugMemHeap = NULL;
    }

    if (pTHS->hDebugMemHeapOrg) {
        pTHS->hDebugMemHeap = pTHS->hDebugMemHeapOrg;
        pTHS->hDebugMemHeapOrg = NULL;
    }
}

//
// Log the particular allocation, either by appending at the end of the list 
// or reusing an empty spot.
//
ALLOC_ENTRY* ThAllocTraceAdd (THSTATE *pTHS)
{
    DWORD index;
    ThAllocDebugHeapLogBlock *pHeapLog = (ThAllocDebugHeapLogBlock *) pTHS->pDebugHeapLog;
    
    if (!pTHS->hDebugMemHeap) {
        return NULL;
    }

    // create a heap log if none is available
    if (!pHeapLog) {
        pHeapLog = RtlAllocateHeap(pTHS->hDebugMemHeap, HEAP_ZERO_MEMORY, (unsigned)sizeof (ThAllocDebugHeapLogBlock));
        if (!pHeapLog) {
            DPRINT (0, "Failed to allocate mem in the debug heap\n");
            return NULL;
        }
        pTHS->pDebugHeapLog = (PVOID) pHeapLog;
    }

    // check to see whether we can resuse freed spots
    if (!(gfUseTHAllocTrace & FLAG_THALLOC_TRACE_LOG_ALL)) {
        while (pHeapLog) {
            for (index = pHeapLog->cnt-1; index >= 0; index--) {
                if (pHeapLog->info[index].aiFree.dsid != 0) {
                    memset(&pHeapLog->info[index], 0, sizeof(ALLOC_ENTRY));
                    return &pHeapLog->info[index];
                }
            }
            pHeapLog = pHeapLog->pPrevious;
        }

        // did not find anything, reset to the last log block
        pHeapLog = (ThAllocDebugHeapLogBlock *) pTHS->pDebugHeapLog;
    }

    if (pHeapLog->cnt == THALLOC_LOG_SIZE) {
        // we reached the limit for the current one. allocate a new one and
        // link them together
        ThAllocDebugHeapLogBlock *pNewHeapLog;

        pNewHeapLog = RtlAllocateHeap(pTHS->hDebugMemHeap, HEAP_ZERO_MEMORY, (unsigned)sizeof (ThAllocDebugHeapLogBlock));
        if (!pNewHeapLog) {
            DPRINT (0, "Failed to allocate mem in the debug heap\n");
            return NULL;
        }

        pNewHeapLog->pPrevious = pHeapLog;
        pHeapLog = pNewHeapLog;
        pTHS->pDebugHeapLog = (PVOID) pHeapLog;
    }

    index = pHeapLog->cnt++;
    return &pHeapLog->info[index];
}


//
// Find an old allocation 
//
ALLOC_ENTRY* ThAllocTraceFind (THSTATE *pTHS, VOID *pMem)
{
    int index;
    ThAllocDebugHeapLogBlock *pHeapLog = (ThAllocDebugHeapLogBlock *) pTHS->pDebugHeapLog;
    
    while (pHeapLog) {
        for (index = pHeapLog->cnt - 1; index >= 0; index--) {
            if (pHeapLog->info[index].pMem == pMem) {
                return &pHeapLog->info[index];
            }
        }
        pHeapLog = pHeapLog->pPrevious;
    }

    return NULL;
}

//
// Trace Allocations
//
ALLOC_ENTRY* ThAllocTraceAlloc (THSTATE *pTHS, void *pMem, DWORD size, DWORD dsid)
{
    ALLOC_ENTRY* result = NULL;
    if (!gfUseTHAllocTrace || ((gfUseTHAllocTrace & FLAG_THALLOC_TRACE_USETHREAD) && gpTHAllocTraceThread != pTHS)) {
        return NULL;
    }
    
    result = ThAllocTraceAdd(pTHS);
    if (result == NULL) {
        return NULL;
    }
    result->cReallocs = 0;
    result->aiAlloc.dsid = dsid;
    result->aiAlloc.size = size;
    result->pMem = pMem;
    result->aiFree.dsid = 0;
    
    if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
        DbgStackTrace (pTHS, result->aiAlloc.Stack, THALLOC_LOG_NUM_MEM_STACK, 3);
    }
    else {
        result->aiAlloc.Stack[0] = 0;
    }
    
    return result;
}

//
// Trace Reallocations
//
ALLOC_ENTRY* ThAllocTraceREAlloc (THSTATE *pTHS, void *pMem, void *oldMem, DWORD size, DWORD dsid)
{
    ALLOC_ENTRY* result = NULL;
    if (!gfUseTHAllocTrace || ((gfUseTHAllocTrace & FLAG_THALLOC_TRACE_USETHREAD) && gpTHAllocTraceThread != pTHS)) {
        return NULL;
    }
    
    result = ThAllocTraceFind(pTHS, oldMem);
    if (result == NULL) {
        Assert(!"Realloc: alloc info not found");
        return NULL;
    }

    result->pMem = pMem;
    if (result->cReallocs < MAX_REALLOCS) {
        // only record MAX_REALLOCS entries
        result->aiReallocs[result->cReallocs].dsid = dsid;
        result->aiReallocs[result->cReallocs].size = size;
        
        if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
            DbgStackTrace (pTHS, result->aiReallocs[result->cReallocs].Stack, THALLOC_LOG_NUM_MEM_STACK, 3);
        }
        else {
            result->aiReallocs[result->cReallocs].Stack[0] = 0;
        }
    }
    result->cReallocs++;
    return result;
}

//
// Trace De-allocations
//
ALLOC_ENTRY* ThAllocTraceFree (THSTATE *pTHS, void *pMem, DWORD dsid)
{
    ALLOC_ENTRY* result = NULL;
    if (!gfUseTHAllocTrace || ((gfUseTHAllocTrace & FLAG_THALLOC_TRACE_USETHREAD) && gpTHAllocTraceThread != pTHS)) {
        return NULL;
    }
    
    result = ThAllocTraceFind(pTHS, pMem);
    if (result == NULL) {
        Assert(!"Free: alloc info not found");
        return NULL;
    }
    result->aiFree.dsid = dsid;
    if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) {
        DbgStackTrace (pTHS, result->aiFree.Stack, THALLOC_LOG_NUM_MEM_STACK, 3);
    }
    else {
        result->aiFree.Stack[0] = 0;
    }
    
    return result;
}

void ThAllocTraceGrabHeap(THSTATE *pTHS, BOOL use_mark)
{
    // we allocate a special heap only if we are tracking down individual allocations
    //
    if (!gfUseTHAllocTrace || 
        !(gfUseTHAllocTrace & (FLAG_THALLOC_TRACE_TRACK_LEAKS | FLAG_THALLOC_TRACE_LOG_ALL))) {
        return;
    }
    // Init stack tracing 
    if ((gfUseTHAllocTrace & FLAG_THALLOC_TRACE_STACK) && (!hDbgProcessHandle)) {
        DbgStackInit();
    }
    
    if (use_mark) {
        pTHS->hDebugMemHeapOrg = pTHS->hDebugMemHeap;
        pTHS->hDebugMemHeap = NULL;
    }

    if (pTHS->hDebugMemHeap) {
        return;
    }

    pTHS->hDebugMemHeap = RtlCreateHeap((HEAP_NO_SERIALIZE
                                    | HEAP_GROWABLE
                                    | HEAP_ZERO_MEMORY
                                    | HEAP_CLASS_1),
                                      0,
                                      1L*1024*1024,   // 1M reserved
                                      32L*1024,       // 32K commit
                                      0,
                                      0);
}


#else


// no ops of the above functions

    #define ThAllocTraceGrabHeap(x1,x2)
    
    #define ThAllocTraceRecycleHeap(x)
    
    #define ThAllocTraceAlloc(x1, x2, x3, x4)

    #define ThAllocTraceREAlloc(x1,x2,x3,x4,x5)
    
    #define ThAllocTraceFree(x1,x2, x3)
    
#endif //USE_THALLOC_TRACE


void
DeferredHeapLogEvent(
        IN void *  pvParam,
        OUT void ** ppvParamNextIteration,
        OUT DWORD * pcSecsUntilNextIteration)
/*++ DeferredHeapLogEvent
 *
 * Routine description:
 *     This routine is to be invoked by the task queue to log heap creation
 *     summary information.
 *
 *     All heap creation failure logging data is protected by a critical section
 *     It is believed (and hoped!) that this will not be highly contended on.
 */
{
    DWORD dwNow = GetTickCount();
    DWORD dwLogTimeDelta;

    // Don't run again.  We will be one-time scheduled again as needed.
    *ppvParamNextIteration = NULL;
    *pcSecsUntilNextIteration = TASKQ_DONT_RESCHEDULE;

    EnterCriticalSection(&csHeapFailureLogging);
    __try {
        dwLogTimeDelta = dwNow - dwHeapFailureLastLogTime;

        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_HEAP_CREATE_FAILED,
                 szInsertUL(dwHeapFailures),
                 szInsertUL(dwLogTimeDelta / (60 * 1000)),
                 NULL);

        dwHeapFailureLastLogTime = dwNow;
        dwHeapFailures = 0;
        bHeapFailureLogEnqueued = FALSE;
    }
    __finally {
        bHeapFailureLogEnqueued = FALSE;
        LeaveCriticalSection(&csHeapFailureLogging);
    }
}


void
LogHeapCreateFailure(void)
/*++ LogHeapCreateFailure
 *
 * Routine description:
 *     This function is to be called when a heap creation operation fails.
 *     We have received complaints in the past that this tends to happen
 *     in great unpleasant flurries, which swamp the event log.  Thus, rather
 *     than log immediately, we tally up failures and log only a summary.
 *     This routine adjusts any relevant aggregate counters and makes sure that
 *     an event is enqueued which will actually log the summary.
 *
 *     All heap creation failure logging data is protected by a critical section
 *     It is believed (and hoped!) that this will not be highly contended on.
 *
 --*/
{
    EnterCriticalSection(&csHeapFailureLogging);
    __try {
        ++dwHeapFailures;

        if (!bHeapFailureLogEnqueued) {
            InsertInTaskQueue(DeferredHeapLogEvent,
                              NULL,
                              dwHeapFailureMinLogGap);
            bHeapFailureLogEnqueued = TRUE;
        }

    }
    __finally {
        LeaveCriticalSection(&csHeapFailureLogging);
    }
}

void 
RecycleHeap(THSTATE *pTHS)
/*++ RecycleHeap
 *
 * This routines cleans out a (heap,THSTATE,Zone) triple (if convenient)
 * and places it into a cache.  If the cache is full, or the heap is excessively
 * dirty, or Zone is not properly allocated, the triple is destroyed.
 *
 * INPUT:
 *   pTHS->hHeap - handle of heap to recycle
 *   pTHS->Zone.base - the starting address of the zone
 *   pTHS and pTHS->pSpareTHS - the THSTATE to clean. If pTHS->pSpareTHS is non-null,
 *      then clean it; otherwise, clean pTHS.
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   none
 */
{
    HANDLE hHeap = pTHS->hHeap;
    THSTATE * pTHStoFree;
    NTSTATUS status;
    PUCHAR pZone = pTHS->Zone.Base;
    size_t ibSessionCache, cbSessionCache;
    size_t ibDNReadCache, cbDNReadCache;
    size_t ib, cb;
    BYTE* pb;

    DBGINC(gcHeapRecycles);
    Assert(hHeap);

    ThAllocTraceRecycleHeap (pTHS);

    //if pSpareTHS is non-null, it means this is called by TH_free_to_mark
    //so pSpareTHS is the THSTATE to clean up
    //otherwise, this is called by free_thread_state, clean pTHS
    pTHStoFree =(pTHS->pSpareTHS)?pTHS->pSpareTHS:pTHS;

#if DBG
    Assert(VALID_THSTATE(pTHS));
    Assert(THSTATE_TAG_IN_USE==*(LONGLONG*)((BYTE*)pTHStoFree-sizeof(LONGLONG)));
#endif

    if (pZone == NULL) {
        // the zone was not allocated any memory,
        // don't bother saving this one.
        goto cleanup;
    }

    //Let's clear the heap and try to put it back to the heapcache
    {
        RTL_HEAP_WALK_ENTRY entry;
        void * apv[MAX_ALLOCS];
        unsigned i, j;
        ULONG iCpu, counter;

        if (pTHS->cAllocs > MAX_ALLOCS) {
            goto cleanup;
        }

        // Now we need to walk the heap and identify the blocks to free
        entry.DataAddress = NULL;
        i = 0;
        while(NT_SUCCESS(status = RtlWalkHeap(hHeap, &entry))) {
            if (entry.Flags & RTL_HEAP_BUSY) {
                apv[i] = entry.DataAddress;
                i++;
                if (i >= MAX_ALLOCS) {
                    // Uh, oh. We've found more blocks in this heap than
                    // we thought were there, and more than we have room
                    // to keep track of.  Let's kill this heap and be done
                    // with it.
                    goto cleanup;
                }
            }
        }

        // If RtlWalkHeap detects a corruption in the heap, it will return
        // STATUS_INVALID_PARAMETER or STATUS_INVALID_ADDRESS.  Any of these
        // two status indicates problems with the source code.
        Assert(    status != STATUS_INVALID_PARAMETER
                && status != STATUS_INVALID_ADDRESS   );


        // Any non-success status other than STATUS_NO_MORE_ENTRIES indicates
        // some problems with RtlWalkHeap, so only put the heap back to the cache
        // when the status is STATUS_NO_MORE_ENTRIES.

        if ( status == STATUS_NO_MORE_ENTRIES ) {
            // Ok, apv[0..(i-1)] are now full of the pointers we need to free,
            // so spin through the array freeing them.
            for (j=0; j<i; j++) {
                RtlFreeHeap(hHeap, 0, apv[j]);
            }

            #if DBG
                // check the validity of the heap to be recycled, so as to catch
                // bad recycled heaps
                Assert (RtlValidateHeap (hHeap, HEAP_NO_SERIALIZE, NULL));
            #endif

            //zero the used part of Zone
            memset(pZone, 0, pTHS->Zone.Cur-pTHS->Zone.Base);

            //zero the THSTATE except for the session cache and DN Read Cache
            ibSessionCache = offsetof(THSTATE, JetCache);
            cbSessionCache = sizeof(pTHStoFree->JetCache);
            ibDNReadCache = offsetof(THSTATE, LocalDNReadCache);
            cbDNReadCache = sizeof(pTHStoFree->LocalDNReadCache);
            ib = 0;
            cb = sizeof(THSTATE);
            pb = (BYTE*)pTHStoFree;
            if (ibSessionCache < ibDNReadCache) {
                memset(pb + ib, 0, ibSessionCache - ib);
                ib = ibSessionCache + cbSessionCache;
                memset(pb + ib, 0, ibDNReadCache - ib);
                ib = ibDNReadCache + cbDNReadCache;
                memset(pb + ib, 0, cb - ib);
            } else {
                memset(pb + ib, 0, ibDNReadCache - ib);
                ib = ibDNReadCache + cbDNReadCache;
                memset(pb + ib, 0, ibSessionCache - ib);
                ib = ibSessionCache + cbSessionCache;
                memset(pb + ib, 0, cb - ib);
            }

            #if DBG
            //change the tag
            *((LONGLONG*)((BYTE*)pTHStoFree-sizeof(LONGLONG))) = THSTATE_TAG_IN_CACHE;
            #endif

            counter = 0;

            iCpu = GetProcessor();

            while (    counter < MAX_TRY
                    && counter < GetProcessorCount()
                    && hHeap )
            {
                const PPLS ppls = GetSpecificPLS(iCpu);
                
                if (!counter || ppls->heapcache.index != 0) {
                    EnterCriticalSection(&ppls->heapcache.csLock);
                    if (ppls->heapcache.index != 0) {
                        // insert the heap as the MRU entry when on our own
                        // cache and as the LRU entry when on someone else's
                        --ppls->heapcache.index;
                        if (!counter) {
                            ppls->heapcache.slots[ppls->heapcache.index].hHeap = hHeap;
                            ppls->heapcache.slots[ppls->heapcache.index].pTHS = pTHStoFree;
                            ppls->heapcache.slots[ppls->heapcache.index].pZone = pZone;
                        } else {
                            memmove(&ppls->heapcache.slots[ppls->heapcache.index],
                                    &ppls->heapcache.slots[ppls->heapcache.index + 1],
                                    sizeof(HMEM) * (HEAP_CACHE_SIZE_PER_CPU - 1 - ppls->heapcache.index));
                            ppls->heapcache.slots[HEAP_CACHE_SIZE_PER_CPU - 1].hHeap = hHeap;
                            ppls->heapcache.slots[HEAP_CACHE_SIZE_PER_CPU - 1].pTHS = pTHStoFree;
                            ppls->heapcache.slots[HEAP_CACHE_SIZE_PER_CPU - 1].pZone = pZone;
                        }
                        hHeap = 0;
                    }
                    LeaveCriticalSection(&ppls->heapcache.csLock);
                }
                counter++;
                iCpu = (iCpu+1)%GetProcessorCount();
            }

        }

        if (hHeap) {
            // If we still have the heap handle it's because the cache filled
            // up while we were cleaning this heap.  Or because we didn't get
            // any useful results while walking the heap.  In either case,
            // destroy it.
            goto cleanup;

        }
    }
    //successfully put the triple into the cache, now return
    return;

cleanup:
   //come here only when the heap/THSTATE/ZONE triple need to be destroyed
   RtlDestroyHeap(hHeap);
   if (pZone) {
       VirtualFree(pZone, 0, MEM_RELEASE);
   }
   DBDestroyThread(pTHStoFree);
   //clear the THSTATE to help detect double frees
    ibSessionCache = offsetof(THSTATE, JetCache);
    cbSessionCache = sizeof(pTHStoFree->JetCache);
    ibDNReadCache = offsetof(THSTATE, LocalDNReadCache);
    cbDNReadCache = sizeof(pTHStoFree->LocalDNReadCache);
    ib = 0;
    cb = sizeof(THSTATE);
    pb = (BYTE*)pTHStoFree;
    if (ibSessionCache < ibDNReadCache) {
        memset(pb + ib, 0, ibSessionCache - ib);
        ib = ibSessionCache + cbSessionCache;
        memset(pb + ib, 0, ibDNReadCache - ib);
        ib = ibDNReadCache + cbDNReadCache;
        memset(pb + ib, 0, cb - ib);
    } else {
        memset(pb + ib, 0, ibDNReadCache - ib);
        ib = ibDNReadCache + cbDNReadCache;
        memset(pb + ib, 0, ibSessionCache - ib);
        ib = ibSessionCache + cbSessionCache;
        memset(pb + ib, 0, cb - ib);
    }
#if DBG
   free((BYTE*)pTHStoFree-sizeof(LONGLONG));
#else
   free(pTHStoFree);
#endif

   DBGINC(gcHeapDestroys);
}

HMEM 
GrabHeap(void)
/*++ GrabHeap
 *
 * This routine grabs a triple of (heap, THSTATE, zone) from the heap cache, if one exists.
 * If no cached triple is available then a new one is created.
 *
 * INPUT:
 *   none
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   HMEM, HMEM.hHeap==0 if it fails to allocate either heap or THSTATE.
 */
{
    DWORD err;
    HMEM hMem;
    ULONG iCpu, counter = 0;

    hMem.hHeap = 0;

    DBGINC(gcHeapGrabs);

    Assert(GetProcessorCount());

    iCpu = GetProcessor();

    while (   counter < GetProcessorCount()
           && counter < MAX_TRY
           && !hMem.hHeap  )
    {
        const PPLS ppls = GetSpecificPLS(iCpu);
        
        if( !counter || HEAP_CACHE_SIZE_PER_CPU != ppls->heapcache.index )
        // for the current ideal CPU, we don't check before entering CR;
        // Before we enter the crtical section of other cpu's cache, we check if
        // there is something available.
        {
            EnterCriticalSection(&ppls->heapcache.csLock);

#if DBG
            if (!counter) {
                //increment the cGrapHeap counter for the CPU
                ppls->heapcache.cGrabHeap++;
            }
#endif

            if (ppls->heapcache.index != HEAP_CACHE_SIZE_PER_CPU) {
                // grab a heap from the MRU entry when on our own cache and
                // from the LRU entry when on someone else's
                if (!counter) {
                    hMem = ppls->heapcache.slots[ppls->heapcache.index];
                    memset(&ppls->heapcache.slots[ppls->heapcache.index], 0, sizeof(HMEM));  //to be safe
                } else {
                    hMem = ppls->heapcache.slots[HEAP_CACHE_SIZE_PER_CPU - 1];
                    memmove(&ppls->heapcache.slots[ppls->heapcache.index + 1],
                            &ppls->heapcache.slots[ppls->heapcache.index],
                            sizeof(HMEM) * (HEAP_CACHE_SIZE_PER_CPU - 1 - ppls->heapcache.index));
                    memset(&ppls->heapcache.slots[ppls->heapcache.index], 0, sizeof(HMEM));  //to be safe
                }
                ++ppls->heapcache.index;
            }
            LeaveCriticalSection(&ppls->heapcache.csLock);
        }
        iCpu = (iCpu+1) % GetProcessorCount();
        counter++;
    }

#if DBG
    Assert(   !hMem.hHeap
           || (    hMem.pTHS
                && THSTATE_TAG_IN_CACHE==*((LONGLONG*)((BYTE*)hMem.pTHS-sizeof(LONGLONG)))
                && hMem.pZone ) );
#endif

    if (!hMem.hHeap) {
         // Cache was empty, so let's create a new one.
        hMem.hHeap = RtlCreateHeap((HEAP_NO_SERIALIZE
                                    | HEAP_GROWABLE
                                    | HEAP_ZERO_MEMORY
                                    | HEAP_CLASS_1),
                                   0,
                                   1L*1024*1024, // 1M reserved
                                   32L*1024,     // 32k committed
                                   0,
                                   0);
        DBGINC(gcHeapCreates);

        if (!hMem.hHeap) {
            DPRINT(0, "RtlCreateHeap failed\n");
            LogHeapCreateFailure();
            return hMem;
        }

        //allocate thread state
#if DBG
    {
        BYTE * pRaw = malloc(sizeof(THSTATE)+sizeof(LONGLONG));
        if (pRaw) {
            hMem.pTHS = (THSTATE*)(pRaw+sizeof(LONGLONG));
        }
        else {
            hMem.pTHS = NULL;
        }
     }
#else
        hMem.pTHS = malloc(sizeof(THSTATE));
#endif

        if (hMem.pTHS){
            //zero the THSTATE
            memset(hMem.pTHS, 0, sizeof(THSTATE));
        }
        else{
            DPRINT(0,
                   "malloc failed, can't create thread state\n" );
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_MALLOC_FAILURE,
                     szInsertUL( sizeof(THSTATE) ),
                     szInsertHex( DSID(FILENO, __LINE__) ),
                     NULL);
            Assert(FALSE);
            RtlDestroyHeap(hMem.hHeap);
            hMem.hHeap = 0;            //indicate that GrapHeap fails
            return hMem;
        }

        //allocate space for zone
        //the caller should verify if the allocation succeeds
        hMem.pZone = (PUCHAR) VirtualAlloc(NULL, ZONETOTALSIZE, MEM_COMMIT, PAGE_READWRITE);

     }
#if DBG
    //set the tag of THSTATE to in use
    *((LONGLONG*)((BYTE*)hMem.pTHS-sizeof(LONGLONG))) = THSTATE_TAG_IN_USE;
#endif

    //successful return
    return hMem;
}


/*
 * What follows is an attempt to make it easier to find THSTATEs while
 * debugging.  Especially on RISC machines where stack traces are sometimes
 * hard to come by, we need a way to find the thread state for random threads
 * stuck in the debugger.  This table keeps an array of <thread id, thstate>
 * pairs, where at any time the first gcThstateMapCur entries are valid, and
 * all others should be empty.
 *
 * DonH, 1/27/98, I needed this in one too many free build, so I've turned
 * it on semi-conditionally.  The code is always present, even in free builds,
 * but it isn't always run, depending on the setting of the gbThstateMapEnabled
 * variable.  On CHK builds this is always set to TRUE.  On free builds, it's
 * set to true if and only if there is a user mode debugger attached to our
 * process at startup.  If you attach with a debugger later, you can always
 * adjust the variable manually.
 */

CRITICAL_SECTION csThstateMap;
BOOL gbThstateMapEnabled;

#if 1

typedef struct _THREAD_STATE_MAP {
    DWORD   tid;
    THSTATE *pTHS;
} THREAD_STATE_MAP;

#define THREAD_MAP_SIZE 512
DWORD gcThstateMapCur = 0;

THREAD_STATE_MAP gaThstateMap[THREAD_MAP_SIZE];

void MapThreadState(THSTATE *pTHS)
{
    DWORD tid;
    DWORD i;
    DWORD cTid;

    if (!gbThstateMapEnabled) {
        return;
    }

    tid = GetCurrentThreadId();
    cTid = 0;

    EnterCriticalSection(&csThstateMap);

#if DBG
    // Some sanity checks to find THSTATE leaks and improper usage.
    for ( i = 0; i < gcThstateMapCur; i++ ) {
        // THSTATE should not exist in the thread map yet.
        Assert(pTHS != gaThstateMap[i].pTHS);

        if ( tid == gaThstateMap[i].tid ) {
            cTid++;
        }
    }
    // Thread should not exist more than twice.  I.e. Allow
    // only single nesting of THSave/.../THRestore activity,
    // plus one extra one for SAM's duplicate SID checking.
    // DaveStr - 11/3/98 - Plus one more for SPN cracking now
    // that we use SPN mutual auth for replication.
    Assert(cTid <= 3);
#endif

    if (gcThstateMapCur < THREAD_MAP_SIZE) {
        gaThstateMap[gcThstateMapCur].tid = tid;
        gaThstateMap[gcThstateMapCur].pTHS = pTHS;
        ++gcThstateMapCur;
    }
    LeaveCriticalSection(&csThstateMap);
}

void UnMapThreadState(THSTATE *pTHS)
{
    DWORD i;
    DWORD tid;

    if (!gbThstateMapEnabled) {
        return;
    }
    tid = GetCurrentThreadId();

    EnterCriticalSection(&csThstateMap);
    for (i=0; i<gcThstateMapCur; i++) {
        if (gaThstateMap[i].tid == tid &&
            gaThstateMap[i].pTHS == pTHS) {
            --gcThstateMapCur;
            if (i < (gcThstateMapCur)) {
                gaThstateMap[i] = gaThstateMap[gcThstateMapCur];
            }
            gaThstateMap[gcThstateMapCur].tid = 0;
            gaThstateMap[gcThstateMapCur].pTHS = NULL;
            break;
        }
    }
    LeaveCriticalSection(&csThstateMap);
}

void CleanUpThreadStateLeakage()
// This routine is designed as a last chance attempt to avoid leaking thread
// states.  It should only be called by thread-detach logic, and will destroy
// every thread state associated with this thread.  Don't call it in error.
{
    THSTATE *pTHSlocal;
    DWORD i;
    DWORD tid;

    if (!gbThstateMapEnabled) {
        return;
    }

    tid = GetCurrentThreadId();

    do {
        pTHSlocal = NULL;
        if (gbCriticalSectionsInitialized) {
            EnterCriticalSection(&csThstateMap);
        }
        for ( i = 0; i < gcThstateMapCur; i++ ) {
            if ( tid == gaThstateMap[i].tid ) {
                pTHSlocal =  gaThstateMap[i].pTHS;
                break;
            }
        }
        if (gbCriticalSectionsInitialized) {
            LeaveCriticalSection(&csThstateMap);
        }

        if (pTHSlocal) {
            // make it official
            TlsSetValue(dwTSindex, pTHSlocal);

            // and dump it
            free_thread_state();
        }
    } while (pTHSlocal);
}

#define MAP_THREAD(pTHS) MapThreadState(pTHS)
#define UNMAP_THREAD(pTHS) UnMapThreadState(pTHS)

#else

#define MAP_THREAD(pTHS)
#define UNMAP_THREAD(pTHS)

#endif


/*

create_thread_state

Sets up the thread state structure. Each thread that uses the
DB layer or uses the DSA memory allocation routines needs to have
an associated thread state strcuture.

Typically, this routine is called right after a new thread is created.

*/

THSTATE * create_thread_state( void )
{
    THSTATE*  pTHS;
    HMEM      hMem;
    UUID *    pCurrInvocationID;

    // we are not allowing any more thread state creations when in single user mode
    if (DsaIsSingleUserMode()) {
        return NULL;
    }

    /*
     * Make sure that we're not doing this twice per thread.
     */
    pTHS = TlsGetValue(dwTSindex);

#ifndef MACROTHSTATE
    Assert(pTHS == pTHStls);
#endif

    if ( pTHS != NULL ) {
        DPRINT(0, "create_thread_state called on active thread!\n");
        return( pTHS );
    }

    /*
     * Create a heap that will contain all of this thread's transaction
     * memory, including the THSTATE.
     * If the alloc fails, just return NULL and hope for the best.
     */
    hMem = GrabHeap();
    if (!hMem.hHeap ) {
        //fail to allocate either heap or THSTATE
        return 0;
    }
    /*
     * Initialize the THSTATE, and make the TLS point to it.
     */
    Assert(hMem.pTHS);

    pTHS = hMem.pTHS;

    pTHS->hHeap = hMem.hHeap;
    if (!TlsSetValue(dwTSindex, pTHS)) {
        // failed to set the TLS value for the thread
        // we should fail, since all the references to pTHStls will fail
        RecycleHeap(pTHS);
        return 0;
    }
    pTHS->hThread = INVALID_HANDLE_VALUE;

    ThAllocTraceGrabHeap (pTHS, FALSE);

    
    pTHS->cAllocs = 0;
#if DBG
    pTHS->Size = sizeof(THSTATE);
#endif

    pTHS->dwLcid = DS_DEFAULT_LOCALE;
    pTHS->fDefaultLcid = TRUE;

    GetSystemTimeAsFileTime(&pTHS->TimeCreated);

    pTHS->ulTickCreated = GetTickCount();

    // initialize authz context with NULL. It will get created on demand
    pTHS->pAuthzCC = NULL;
    // audit info is also created on demand
    pTHS->hAuthzAuditInfo = NULL;

    // Note that local var pCurrInvocationID is used for atomicity.
    pCurrInvocationID = gAnchor.pCurrInvocationID;
    if (NULL == pCurrInvocationID) {
        // In startup, before real invocation ID has been read.
        pTHS->InvocationID = gNullUuid;
    } else {
        // Normal operation.
        pTHS->InvocationID = *pCurrInvocationID;
    }

#ifndef MACROTHSTATE
    pTHStls=pTHS;
#endif

    // Pick up the pointer to the current schema cache
    SCRefreshSchemaPtr(pTHS);

    
    /*
     * Initialize the heap zone
     */
    pTHS->Zone.Base = hMem.pZone;
    if (pTHS->Zone.Base) {
        pTHS->Zone.Cur = pTHS->Zone.Base;
        pTHS->Zone.Full = FALSE;
    }
    else {
        // Grim.  We can't alloc the zone, so I don't hold out much hope.
        // We'll stick values in the zone to make sure that no one ever
        // tries to take memory out of it.
        DPRINT1(0, "LocalAlloc of %d bytes failed, can't create zone\n",
                ZONETOTALSIZE);
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_MALLOC_FAILURE,
                 szInsertUL( ZONETOTALSIZE ),
                 szInsertHex( DSID(FILENO, __LINE__) ),
                 NULL);
        //pTHS->Zone.Base = 0;
        pTHS->Zone.Cur = (void *)1;
        pTHS->Zone.Full = TRUE;
    }

    
    MAP_THREAD(pTHS);

    // CALLERTYPE_NONE needs to be zero - make sure no one changed the def.
    Assert(pTHS->CallerType == CALLERTYPE_NONE);

    return( pTHS );
}

// This routine is called by the notify routines at completion of
// an RPC call.

void free_thread_state( void )
{
    THSTATE *pTHS = pTHStls;

    if (!pTHS) {
        return;
    }

    __try {
        DPRINT3(2, "freeing thread 0x%x, allocs = 0x%x, size = 0x%x\n",
                pTHS,
                pTHS->cAllocs,
                pTHS->Size);

        if ( INVALID_HANDLE_VALUE != pTHS->hThread ) {
            CloseHandle(pTHS->hThread);
        }

        // An impersonation state would imply someone forgot to revert
        // after impersonating a client.
        Assert(ImpersonateNone == pTHS->impState);

        // People need to clean this out.  Later, the MAPI head is going to
        // leave this set and we will delete the security context if it is here,
        // so we need to verify before we do that that no one is leaving this
        // here, assuming it will be ignored.
        Assert(!pTHS->phSecurityContext);

        // See ImpersonateSecBufferDesc for why we need to delete the
        // delegated context handle here.
        if ( pTHS->pCtxtHandle ) {
            DeleteSecurityContext(pTHS->pCtxtHandle);
            THFreeEx(pTHS, pTHS->pCtxtHandle);
        }

        // set AuthzContext to NULL (this will dereference and 
        // possibly destroy the existing one)
        AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
        // free authz audit info (if allocated)
        if (pTHS->hAuthzAuditInfo) {
            AuthzFreeAuditEvent(pTHS->hAuthzAuditInfo);
            pTHS->hAuthzAuditInfo = NULL;
        }
        
        // Free and zero out RPC session encryption keys if present.
        PEKClearSessionKeys(pTHS);

        // decrement schema pointer ref count

        // pTHS->CurrSchemaPtr may be null since many threads are craeted
        // during boot time before the schema cache is loaded

        // Also, we decrement the ref count, but don't cleanup here if it is 0.
        // This is done since the SchemaPtr may already be queued in the task
        // queue, and cleaning up here requires cleaning up the task q too.
        // Instead, we just let the cleaning up be done next time the task
        // is rescheduled. All Schema Ptr unloads are queued at least once
        // for one minute to allow for proper cleaning

        if (pTHS->CurrSchemaPtr) {
            InterlockedDecrement(&(((SCHEMAPTR *) (pTHS->CurrSchemaPtr))->RefCount));
        }

        // By the time we're destroying the thread state, we should NOT have
        // a database still open.  If we were to do so then we'd leak version
        // store wildly (as we used to do occasionally).  If either of these
        // asserts go off then a leak has reemerged and must be fixed.
        Assert(NULL==pTHS->pDB);
        Assert(0==pTHS->opendbcount);

        __try
        {
            DBCloseThread(pTHS);
        }
        __except(HandleMostExceptions(GetExceptionCode()))
        {
        }

        if (pTHS->ViewSecurityCache) {
           THFreeEx (pTHS, pTHS->ViewSecurityCache);
        }


        Assert(pTHS->hHeapOrg == 0);
        Assert(pTHS->pSpareTHS == NULL );

        UNMAP_THREAD(pTHS);

        RecycleHeap(pTHS);
        TlsSetValue(dwTSindex, 0);
#ifndef MACROTHSTATE
        pTHStls=NULL;
#endif
    }
    __finally {
        // This is here to catch a potential problem with blowing up somewhere
        // in the code above.
        Assert(!pTHStls);
        TlsSetValue(dwTSindex, 0);
#ifndef MACROTHSTATE
        pTHStls=NULL;
#endif
    }

}

/*
 * Create a second heap, saving the original, and direct all new allocations
 * to the new heap
 */
VOID TH_mark(THSTATE *pTHS)
{
    HMEM      hMem;

    if (pTHS->hHeapOrg == 0) {
        Assert(pTHS->hHeap != 0);
        Assert(pTHS->pSpareTHS == NULL );

        hMem = GrabHeap();
        if(!hMem.hHeap) {
            // Failed to get a heap for the mark. Raise an exception.  Note
            // that in this case, we have not munged the original heap.  The
            // THSTATE looks just like we hadn't called TH_mark
            RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                           DSID(FILENO, __LINE__),
                           DS_EVENT_SEV_MINIMAL);
        }

        pTHS->pSpareTHS = hMem.pTHS;

        pTHS->hHeapOrg = pTHS->hHeap;

        pTHS->hHeap = hMem.hHeap;

        Assert(pTHS->hHeap != NULL);

        ThAllocTraceGrabHeap (pTHS, TRUE);

        pTHS->cAllocsOrg = pTHS->cAllocs;
        pTHS->cAllocs = 0;
        pTHS->ZoneOrg = pTHS->Zone;
        /*
         * Initialize the heap zone
         */
        pTHS->Zone.Base = hMem.pZone;
        if (pTHS->Zone.Base) {
            pTHS->Zone.Cur = pTHS->Zone.Base;
            pTHS->Zone.Full = FALSE;
        }
        else {
            // Grim.  We can't alloc the zone, so I don't hold out much hope.
            // We'll stick values in the zone to make sure that no one ever
            // tries to take memory out of it.
            DPRINT1(0, "VirutalAlloc of %d bytes failed, can't create zone\n",
                    ZONETOTALSIZE);
            pTHS->Zone.Base = 0;
            pTHS->Zone.Cur = (void *)1;
            pTHS->Zone.Full = TRUE;
        }
#if DBG
        pTHS->SizeOrg = pTHS->Size;
        pTHS->Size = 0;
#endif
    }
    else {
        DPRINT(0, "TH_mark called twice without free!\n");
    }
}

/*
 * Destroy the second heap (created in TH_mark), reverting to the
 * original.
 */
VOID TH_free_to_mark(THSTATE *pTHS)
{

    if (pTHS->hHeapOrg == 0) {
        DPRINT(0, "TH_free_to_mark called without mark!\n");
    }
    else {

        Assert(pTHS->hHeap != 0);
        Assert(pTHS->pSpareTHS != NULL );

        // Meta data is cached in an allocation from the normal (not "org")
        // heap.  Don't orphan it by nuking the normal heap prematurely.
        // Callers should invoke DBCancelRec() if needed before invoking
        // TH_free_to_mark.
        Assert((NULL == pTHS->pDB) || !pTHS->pDB->fIsMetaDataCached);

        RecycleHeap(pTHS);

        pTHS->pSpareTHS = NULL;
        pTHS->hHeap = pTHS->hHeapOrg;
        pTHS->hHeapOrg = 0;
        pTHS->cAllocs = pTHS->cAllocsOrg;
        pTHS->cAllocsOrg = 0;
        pTHS->Zone = pTHS->ZoneOrg;
        memset(&pTHS->ZoneOrg, 0, sizeof(MEMZONE));

#if DBG
        pTHS->Size = pTHS->SizeOrg;
        pTHS->SizeOrg = 0;
#endif
    }
}

/*

_InitTHSTATE_()


Initialize the primary thread data structure. This must be the first
thing done in  every transaction API handler.

Returns a pointer to the THSTATE structure associated with this thread.
Returns NULL if there was an error.

Possible errors:
There was a problem determining the ID of the current theard.
No entry was found in the tabel that corresponds to the current thread ID.


Upon entry the DSA API code (after RPC dispatch), only the DBInitialized
and memory management members (memCount, maxMemEntries, pMem) will be
valid.

*/


THSTATE* _InitTHSTATE_( DWORD CallerType, DWORD dsid )
{
    THSTATE*    pTHS;
    DWORD       err;
    BOOL        fCreatedTHS = FALSE;

    DPRINT(2,"InitTHSTATE entered\n");


    Assert( IsCallerTypeValid( CallerType ) );

    pTHS = pTHStls;

    // If get_thread_state returns NULL, it's probably because this is
    // a new thread. So create a state for it

    if ( pTHS == NULL ) {

        pTHS = create_thread_state();
        fCreatedTHS = TRUE;
    }
    else
    {
        // Thread state pre-existed.  This can occur in 4 cases:
        //
        // 1) Legitimate case - midl_user_allocate called create_thread_state
        //    during unmarshalling of inbound arguments.  pTHS->CallerType
        //    should be CALLERTYPE_NONE.
        // 2) Illegitimate case - Some thread leaked its thread state.
        //    pTHS->CallyerType identifies culprit.
        // 3) Illegitimate case - Some thread is calling InitTHSTATE more
        //    than once.  pTHS->CallyerType identifies culprit.
        // 4) Sort of legitimate case - KCC and DRA have been coded to re-init
        //    thread states regularly.  Since we added this originally to
        //    catch inter-process, ex-ntdsa clients, we'll let those 2 through.
        //    Similar argument for CALLERTYPE_INTERNAL -- InitDRA() is called
        //    by DsaDelayedStartupHandler(), which originates its own thread
        //    state, and InitDRA() indirectly calls subfunctions (such as
        //    DirReplicaSynchronize()) which can be called w/o a thread state.

        Assert(    (CALLERTYPE_NONE == pTHS->CallerType)
                || (CALLERTYPE_DRA == pTHS->CallerType)
                || (CALLERTYPE_INTERNAL == pTHS->CallerType)
                || (CALLERTYPE_KCC == pTHS->CallerType) );  

        // It may have been a while since this THSTATE was created, so get
        // fresh new copies of various global information.
        THRefresh();
    }

    if (pTHS == NULL) {
        return pTHS;                    // out of memory?
    }

    // dsidOrigin always reflects most recent caller of InitTHSTATE on a thread.
    pTHS->dsidOrigin = dsid;

    /* NULL out the fields that should be nulled at API initialization
    time.
    */
    THClearErrors();

    if (err = DBInitThread( pTHS ) ) {
        /* Error from DBInitThread(). */
        DPRINT1(0,"InitTHSTATE failed; Error %u from DBInitThread\n", err);
        if (fCreatedTHS) {
            free_thread_state();
        }

        return NULL;
    }

    // Mark this thread as not being the DRA. If it is, caller will set the
    // flag correctly.

    pTHS->fDRA = FALSE;
    pTHS->CallerType = CallerType;

    //
    // Initialize WMI event trace header
    //

    if ( pTHS->TraceHeader == NULL ) {
        pTHS->TraceHeader = THAlloc(sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD));
    }

    if ( pTHS->TraceHeader != NULL) {

        PWNODE_HEADER wnode = (PWNODE_HEADER)pTHS->TraceHeader;
        ZeroMemory(pTHS->TraceHeader, sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD));

        wnode->Flags = WNODE_FLAG_USE_GUID_PTR | // Use a guid ptr instead of copying
                       WNODE_FLAG_USE_MOF_PTR  | // Data is not contiguous to header
                       WNODE_FLAG_TRACED_GUID;
    }

    // Initialize per-thread view of forest version
    pTHS->fLinkedValueReplication = (gfLinkedValueReplication != 0);

    Assert(VALID_THSTATE(pTHS));

    return pTHS ;

}   /*InitTHSTATE*/

ULONG
THCreate( DWORD CallerType )
//
//  Create thread state.  Exported to in-process, out-of-module clients
//  (e.g., the KCC).  Doesn't object if we already have a THSTATE.
//
//  Returns 0 on success.
//
{
    THSTATE *   pTHS;

    if (eServiceShutdown > eRemovingClients) {
        return 1;       /* Don't we have any real error codes? */
    }
    if (pTHStls) {
        return 0;               /* already have one */
    }

    __try {
        pTHS = InitTHSTATE(CallerType );
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        pTHS = NULL;
    }

    return ( NULL == pTHS );
}

ULONG
THDestroy()
//
//  Destroy thread state.  Exported to in-process, out-of-module clients
//  (e.g., the KCC).  Doesn't object if we don't have a THSTATE.
//
//  Returns 0 on success.
//
{
    free_thread_state();

    return 0;
}

BOOL
THQuery()
//
// Returns TRUE if a THSTATE exists for this thread, and FALSE if not.
// Intended for use by out-of-module callers who cannot simply test pTHStls.
//
{
    return (pTHStls ? TRUE : FALSE);
}

VOID
THClearErrors()
//
//  Clear any thread state persisted errors.
//
{
    THSTATE *pTHS = pTHStls;

    if ( NULL != pTHS ) {
        pTHS->errCode = 0;
        pTHS->pErrInfo = NULL;
    }
}

BOOL
THVerifyCount(unsigned count)
// Verifies that count thread states are mapped to this thread.
{
    DWORD tid = GetCurrentThreadId();
    unsigned cTid = 0;
    DWORD i;

    if (!gbThstateMapEnabled) {
        // We can't tell, but let's not blow any asserts falsely.
        return TRUE;
    }

    if (gbCriticalSectionsInitialized) {
        EnterCriticalSection(&csThstateMap);
    }
    for ( i = 0; i < gcThstateMapCur; i++ ) {
        if ( tid == gaThstateMap[i].tid ) {
            cTid++;
        }
    }
    if (gbCriticalSectionsInitialized) {
        LeaveCriticalSection(&csThstateMap);
    }

    return (cTid == count);
}

VOID
THRefresh()
//
//  Refresh the thread-state with any global state info that may have changed
//  (which implies we may be holding pointers that are scheduled to be
//  delayed-freed).
//
{
    THSTATE * pTHS = pTHStls;

    Assert(NULL != pTHS);

    // Pick up the pointer to the current schema cache
    SCRefreshSchemaPtr(pTHS);

    // ...and we're good to go.
    GetSystemTimeAsFileTime(&pTHS->TimeCreated);
    pTHS->ulTickCreated = GetTickCount();
}

#if DBG
DWORD BlockHistogram[32];

//
// Track the sizes of allocations taking place
//
void TrackBlockSize(DWORD size)
{
    unsigned i = 0;

    while (size) {
        ++i;
        size = size >> 1;
    }

    Assert(i < 32);

    ++BlockHistogram[i];
}
#else
#define TrackBlockSize(x)
#endif


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* These functions are used to dynamically allocate memory on a transaction
   basis.  In other words, to allocate memory that belongs to a single
   thread and a single invocation of an API.  The model is that
   THAlloc is called to allocate some transaction memory.

*/

__inline void * APIENTRY 
THAllocAux(THSTATE *pTHS, 
           DWORD size, 
           BOOL fUseHeapOrg
#ifdef USE_THALLOC_TRACE
           ,DWORD dsid
#endif
    )
{
    MEMZONE *pZone;
    register void * pMem;
    HANDLE hHeap;
    ULONG *pcAllocs;
#if DBG
    ULONG *pSize;
#endif
#ifdef USE_THALLOC_TRACE
    DWORD origSize;
#endif


    DPRINT(3, "THAllocAux entered\n");

    Assert(pTHS->hHeap != 0);
    Assert(pTHS->Zone.Cur != 0);

    if (!fUseHeapOrg || !pTHS->hHeapOrg) {
        hHeap = pTHS->hHeap;
        pcAllocs = &pTHS->cAllocs;
        pZone = &pTHS->Zone;
#if DBG
        pSize = &pTHS->Size;
#endif
    }
    else {
        hHeap = pTHS->hHeapOrg;
        pcAllocs = &pTHS->cAllocsOrg;
        pZone = &pTHS->ZoneOrg;
#if DBG
        pSize = &pTHS->SizeOrg;
#endif
    }

#ifdef USE_THALLOC_TRACE
    origSize = size;
    if (gfUseTHAllocTrace & FLAG_THALLOC_TRACE_BOUNDARIES) {
        // adjust size for header / trailer
        // this will change the zone behaviour, but it is ok
        size = (((origSize + 7) >> 3) << 3) + 16;
    }

#endif

    if(   size
       && (size <= ZONEBLOCKSIZE)
       && (!pZone->Full)) {
        // We can satisfy the alloc from the Zone
        pMem = pZone->Cur;
        pZone->Cur += ZONEBLOCKSIZE;
        if (pZone->Cur >= (pZone->Base + ZONETOTALSIZE)) {
            pZone->Full = TRUE;
        }
    }
    else {
        pMem = RtlAllocateHeap(hHeap, HEAP_ZERO_MEMORY, (unsigned)size);

        Assert(((ULONGLONG)pMem & 0x7) == 0);      // must be 8-byte aligned
        // We don't count Zone allocations
        (*pcAllocs)++;
#if DBG
        if (pMem)
          *pSize += (ULONG)RtlSizeHeap(hHeap, 0, pMem);
#endif
    }

    ThAllocTraceAlloc (pTHS, pMem, origSize, dsid);
    
    TrackBlockSize(size);

    return(pMem);
}

__inline void *
THReAllocAux(THSTATE *pTHS,
             void * memory,
             DWORD  size,
             BOOL   fUseHeapOrg
#ifdef USE_THALLOC_TRACE
             ,DWORD dsid
#endif
             )
{
    register void * pMem;
    HANDLE hHeap;
    MEMZONE *pZone;
#if DBG
    ULONG *pSize;
#endif

    DPRINT(3, "THReAllocAux entered\n");

    Assert(pTHS->hHeap != 0);

    if (!fUseHeapOrg || !pTHS->hHeapOrg) {
        hHeap = pTHS->hHeap;
        pZone = &pTHS->Zone;
#if DBG
        pSize = &pTHS->Size;
#endif
    }
    else {
        hHeap = pTHS->hHeapOrg;
        pZone = &pTHS->ZoneOrg;
#if DBG
        pSize = &pTHS->SizeOrg;
#endif
    }

    if (InZone(pZone,memory)) {
        // We're re-allocing a zone block
        if (size <= ZONEBLOCKSIZE) {
            // the block is still small enough to stay in place
            return memory;
        }
        else {
            // We have to convert this into a real heap allocation.  Alloc
            // a block and copy everything over.
            pMem = THAllocAux(pTHS, 
                              size, 
                              fUseHeapOrg
#ifdef USE_THALLOC_TRACE
                              ,dsid
#endif                              
                              );

            if (pMem) {
                memcpy(pMem, memory, ZONEBLOCKSIZE);
            }
        }
    }
    else {
#if DBG
        DWORD dwOldBlockSize;
#endif

        Assert(IsAllocatedFrom(hHeap, memory));
#if DBG
        dwOldBlockSize = (ULONG)RtlSizeHeap(hHeap, 0, memory);
#endif
        
        pMem = RtlReAllocateHeap(hHeap,
                                 HEAP_ZERO_MEMORY,
                                 memory,
                                 size);

        Assert(((ULONGLONG)pMem & 0x7) == 0);      // must be 8-byte aligned
#if DBG
        if(pMem) {
            Assert(dwOldBlockSize <= *pSize);
            *pSize -= dwOldBlockSize;
            *pSize += (ULONG)RtlSizeHeap(hHeap, 0, pMem);
        }
#endif
    
        ThAllocTraceREAlloc (pTHS, pMem, memory, size, dsid);
    }

    return(pMem);
}

#ifdef USE_THALLOC_TRACE
void * APIENTRY THAllocOrgDbg(THSTATE *pTHS, DWORD size, DWORD dsid)
{
    return  THAllocAux(pTHS, size, TRUE, dsid);
}
#else
void * APIENTRY THAllocOrg(THSTATE *pTHS, DWORD size)
{
    return THAllocAux(pTHS, size, TRUE);
}
#endif

/*
THFree - the corresponding free routine
*/
#ifdef USE_THALLOC_TRACE
VOID THFreeEx_(THSTATE *pTHS, VOID *buff, DWORD dsid)
#else
VOID THFreeEx(THSTATE *pTHS, VOID *buff)
#endif
{
    if (!buff) {
        /*
         * Why the if?  Because we've found people freeing null pointers,
         * which both HeapValidate and HeapFree seem to accept without
         * complaint, but which cause HeapSize to AV.
         */
        return;
    }

    ThAllocTraceFree (pTHS, buff, dsid);

    if (InZone(&pTHS->Zone, buff)) {
        // zone allocs are one-shots, we can't re-use them.
#if DBG
        memcpy(buff, ZoneFill, ZONEBLOCKSIZE);
#endif
        return;
    }
    else {
        // It's a real heap block, so free it.
        Assert(RtlValidateHeap(pTHS->hHeap, 0, buff));

        pTHS->cAllocs--;
#if DBG
        pTHS->Size -= (ULONG)RtlSizeHeap(pTHS->hHeap, 0, buff);
#endif
        RtlFreeHeap(pTHS->hHeap, 0, buff);
    }
}

/*
THFreeOrg - free allocation made by a call to THAllocOrgEx().
*/

#ifdef USE_THALLOC_TRACE
VOID THFreeOrg_(THSTATE *pTHS, VOID *buff, DWORD dsid)
#else
VOID THFreeOrg(THSTATE *pTHS, VOID *buff)
#endif
{
    HANDLE hHeap;
    ULONG *pcAllocs;
    MEMZONE * pZone;
#if DBG
    ULONG *pSize;
#endif

    if (buff) {

        ThAllocTraceFree (pTHS, buff, dsid);

        if (!pTHS->hHeapOrg) {
            hHeap = pTHS->hHeap;
            pcAllocs = &pTHS->cAllocs;
            pZone = &pTHS->Zone;
#if DBG
            pSize = &pTHS->Size;
#endif
        }
        else {
            hHeap = pTHS->hHeapOrg;
            pcAllocs = &pTHS->cAllocsOrg;
            pZone = &pTHS->ZoneOrg;
#if DBG
            pSize = &pTHS->SizeOrg;
#endif
        }

        if (InZone(pZone, buff)) {
            // zone allocs are one-shots, we can't re-use them.
#if DBG
            memcpy(buff, ZoneFill, ZONEBLOCKSIZE);
#endif
            return;
        }
        else {
            // It's a real heap block, so free it.
            Assert(RtlValidateHeap(hHeap, 0, buff));
            (*pcAllocs)--;
#if DBG
            Assert( (ULONG)RtlSizeHeap(hHeap, 0, buff) <= *pSize );
            *pSize -= (ULONG)RtlSizeHeap(hHeap, 0, buff);
#endif
            RtlFreeHeap(hHeap, 0, buff);
        }
    }
}


void* __RPC_USER
MIDL_user_allocate(
        size_t bytes
        )
/*++

Routine Description:

    Memory allocator for rpc.  Allocates a block of memory from the heap in the
    thread state.

Arguments:

    bytes - the number of bytes requested.

Return Value:

    A pointer to the memory allocated or NULL.

--*/
{
    void *pv;
    THSTATE *pTHS=pTHStls;

    if ( pTHS == NULL ) {
        
        if ( !gRpcListening ) {
            // We are not even listening to the rpc calls!
            // No need to continue, let's fail.
            DPRINT(0,"MIDL_user_allocate is called before ntdsa.dll is ready to handle RPC calls!\n");
            return 0;
        }
        
        DPRINT(1,"Ack! MIDL_user_allocate called without thread state!\n");
        create_thread_state();
        /* Note that we have to re-test the global pTHStls, not a local copy */
        pTHS = pTHStls;
        if (pTHS == NULL) {
            // We've got no memory left, so fail the alloc
            return 0;
        }
    }

    pv = THAllocAux(pTHS, 
                    bytes, 
                    FALSE
#ifdef USE_THALLOC_TRACE
                    ,DSID(FILENO, __LINE__)
#endif                    
                    );

    return(pv);
}


BOOL  gbEnableMIDL_user_free = FALSE;

void __RPC_USER
MIDL_user_free(
        void* memory
        )
/*++

Routine Description:

    Memory de-allocator for rpc.  Deallocates a block of memory from the heap
    in the thread state.  Actually it can't right now, because someone is
    passing pointers to structures in the schema cache to DRA RPC calls, and
    RPC walks those structures and calls MIDL_user_free on all of them, but
    an attempt to free schema cache entries via THFree would fail.

Arguments:

    memory - pointer to the memory to be freed.

Return Value:

    None.

--*/
{
#ifdef DBG

if (gbEnableMIDL_user_free) {
    THSTATE *pTHS=pTHStls;

    if (IsDebuggerPresent()) {
        if ( pTHS == NULL ) {
            DPRINT(0,"Ack! MIDL_user_free called without thread state!\n");
        }
        else {
            if (InZone(&pTHS->Zone, memory)) {
                THFreeEx (pTHS, memory);
            }
            else if (IsAllocatedFrom (pTHS->hHeap, memory)) {
                THFreeEx (pTHS, memory);
            }
            else {
                DPRINT1 (0, "Freeing memory not allocated in this thread: %x\n", memory);
                //Assert (!"Freeing memory not allocated in this thread. This is inglorable");
            }
        }
    }
}
#endif
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* These functions are used to dynamically allocate memory on a transaction
   basis.  In other words, to allocate memory that belongs to a single
   thread and a single invocation of an API.  The model is that
   THAlloc is called to allocate some transaction memory. The extension
   to this version of THAlloc is that we throw an exception if something
   goes wrong.

*/

void * APIENTRY THAllocException(THSTATE *pTHS,
                                 DWORD size,
                                 BOOL fUseHeapOrg,
                                 DWORD ulId)
{
    void * pMem;

    pMem = THAllocAux(pTHS, 
                      size, 
                      fUseHeapOrg
#ifdef USE_THALLOC_TRACE
                      ,ulId
#endif
                      );
    if (!pMem)
        RaiseDsaExcept(DSA_MEM_EXCEPTION,0 ,0, ulId, DS_EVENT_SEV_MINIMAL);

    return(pMem);
}

// The realloc function to go with the preceding alloc function

void * APIENTRY THReAllocException(THSTATE *pTHS,
                                   void * memory,
                                   DWORD size,
                                   BOOL fUseHeapOrg,
                                   DWORD ulId)
{
    register void * pMem;

    pMem = THReAllocAux(pTHS, 
                        memory, 
                        size, 
                        fUseHeapOrg
#ifdef USE_THALLOC_TRACE
                        ,ulId
#endif
                        );
    if (!pMem)
        RaiseDsaExcept(DSA_MEM_EXCEPTION,0 ,0, ulId, DS_EVENT_SEV_MINIMAL);

    return(pMem);
}


#ifdef USE_THALLOC_TRACE
void* THAllocNoEx_(THSTATE* pTHS, DWORD size, DWORD ulId)
{
    return THAllocAux(pTHS, size, FALSE, ulId);
}

void* THReAllocNoEx_(THSTATE* pTHS, void* memory, DWORD size, DWORD ulId)
{
    return THReAllocAux(pTHS, memory, size, FALSE, ulId);
}

void THFreeNoEx_(THSTATE* pTHS, void* buff, DWORD ulId)
{
    THFreeEx_(pTHS, buff, ulId);
}

void* THReAllocOrg_(THSTATE* pTHS, void* memory, DWORD size, DWORD ulId)
{
    return THReAllocAux(pTHS, memory, size, TRUE, ulId);
}
#else
void* THAllocNoEx(THSTATE* pTHS, DWORD size)
{
    return THAllocAux(pTHS, size, FALSE);
}

void* THReAllocNoEx(THSTATE* pTHS, void* memory, DWORD size)
{
    return THReAllocAux(pTHS, memory, size, FALSE);
}

void THFreeNoEx(THSTATE* pTHS, void* buff)
{
    THFreeEx(pTHS, buff);
}

void* THReAllocOrg(THSTATE* pTHS, void* memory, DWORD size)
{
    return THReAllocAux(pTHS, memory, size, TRUE);
}
#endif


PVOID
THSave()

/*++

Description:

    Returns the current thread state value and clears the thread state.
    This routine is intended for use by LSA when it is optimizing
    in-process AcceptSecurityContext calls.  Prior to optimization,
    a head calling AcceptSecurityContext (eg: LDAP head on a BIND) would
    LPC to LSA who is in fact in the same process.  A new thread in LSA
    would make SAM calls and everything was fine.  The LSA optimization
    is to not LPC and call directly in process.  The difference is that
    SAM calls occur on the same thread and that the thread state is valid
    but there is no DB open yet.  All the SAM loopback logic assumes that
    loopback originates from within the Dir* layer, thus a DB is open, and
    thus existence of a thread state is a valid and sufficient loopback
    indicator.  Rather than change all this logic, and rather than have
    either the heads or LSA start opening/closing DBs and mucking with the
    thread state directly, LSA will use this call so that SAM thinks this
    is a new, RPC-based thread.  In this case, SAM will create/destruct a
    thread state and open/close the DB as required.  LSA will restore the
    saved thread state upon return via THRestore.

Arguments:

    None.

Return Value:

    Pointer representing the saved thread state.

--*/

{
    if ( INVALID_TS_INDEX != dwTSindex )
    {
        PVOID pv = TlsGetValue(dwTSindex);
        TlsSetValue(dwTSindex, 0);
#ifndef MACROTHSTATE
        pTHStls = NULL;
#endif
        return(pv);
    }

    return(NULL);
}

VOID
THRestore(
    PVOID pv)

/*++

Description:

    Counterpart to THSave - see above.

Arguments:

    pv - Value of saved thread state pointer.

Return Value:

    None.

--*/

{
    if ( INVALID_TS_INDEX != dwTSindex )
    {
        Assert(NULL == pTHStls);
        TlsSetValue(dwTSindex, pv);
#ifndef MACROTHSTATE
        pTHStls = (THSTATE *) pv;
#endif
    }
}


#if DBG
BOOL IsValidTHSTATE(THSTATE * pTHS, ULONG ulTickNow)
{
    Assert(pTHS && ((void*)pTHS>(void*)sizeof(LONGLONG)));
    Assert(pTHS->hHeap);
    Assert(THSTATE_TAG_IN_USE==*((LONGLONG*)((BYTE*)pTHS-sizeof(LONGLONG))));

    // No matter who you are you shouldn't have too much heap allocated.
    Assert( ((pTHS->Size + pTHS->SizeOrg) < gcMaxHeapMemoryAllocForTHSTATE)
            && "This thread state has way too much heap allocated for normal"
               "operation.  Please contact DSDev.");

    // We only want to check the checks following this if we are in the
    // running state, i.e. not during install.
    if (!DsaIsRunning()) {
        return(1);
    }

    if (!pTHS->fIsValidLongRunningTask) {
        Assert((ulTickNow - pTHS->ulTickCreated < gcMaxTicksAllowedForTHSTATE)
               && "This thread state has been open for longer than it should "
                  "have been under normal operation.  "
                  "Please contact DSDev.");
    }

    // NTRAID#NTRAID-668987-2002/07/22-rrandall: added to catch a strange AV
    // earlier.
    Assert((0 == pTHS->errCode) || (NULL == pTHS->pErrInfo) ||
           (NULL == pTHS->Zone.Base) || (NULL == pTHS->Zone.Cur) ||
           ((((PUCHAR)NULL+pTHS->errCode) != pTHS->Zone.Base) &&
            ((PUCHAR)pTHS->pErrInfo != pTHS->Zone.Cur)));

    return 1;
}
#endif

//
// Loopback calls need to insure a certain ordering between acquisition
// of the SAM lock and transaction begin.  So we define a macro which
// captures in the THSTATE whether a caller owned the SAM write lock
// when starting a multi-call sequence via TRANSACT_BEGIN_DONT_END.
//

#define SET_SAM_LOCK_TRACKING(pTHS)                                 \
    if ( TRANSACT_BEGIN_DONT_END == pTHS->transControl )            \
    {                                                               \
        pTHS->fBeginDontEndHoldsSamLock = pTHS->fSamWriteLockHeld;  \
    }

//
// Set read-only sync point.  If thread originated in SAM, then
// sync point has already been set.   Thread state must already
// exist in all cases.
//

void
SYNC_TRANS_READ(void)
{
    THSTATE *pTHS = pTHStls;

    Assert(NULL != pTHS);
    // SAM should not be doing DirTransactControl transactioning.
    Assert(pTHS->fSAM ? TRANSACT_BEGIN_END == pTHS->transControl : TRUE);

    if ( !pTHS->fSAM &&
         (TRANSACT_DONT_BEGIN_END != pTHS->transControl) &&
         (TRANSACT_DONT_BEGIN_DONT_END != pTHS->transControl) )
    {
        SyncTransSet(SYNC_READ_ONLY);
    }

    Assert(pTHS->pDB);

    SET_SAM_LOCK_TRACKING(pTHS);
}

//
// Set write sync point.  If thread originated in SAM, then
// sync point has already been set.  Thread state must already
// exist in all cases.
//

void
SYNC_TRANS_WRITE(void)
{
    THSTATE *pTHS = pTHStls;

    Assert(NULL != pTHS);
    // SAM should not be doing DirTransactControl transactioning.
    Assert(pTHS->fSAM ? TRANSACT_BEGIN_END == pTHS->transControl : TRUE);

    if ( !pTHS->fSAM &&
         (TRANSACT_DONT_BEGIN_END != pTHS->transControl) &&
         (TRANSACT_DONT_BEGIN_DONT_END != pTHS->transControl) )
    {
        SyncTransSet(SYNC_WRITE);
    }

    Assert(pTHS->pDB);

    SET_SAM_LOCK_TRACKING(pTHS);
}

//
// This routine is used to clean up all thread resources before returning.
// This is used on the main transaction function to clean up before returning.
// It may however be called in a lower routine without ill effects.
// It is a mostly a no-op for threads originating in SAM as they control
// transactioning themselves.
//

void
_CLEAN_BEFORE_RETURN(
    DWORD   err,
    BOOL    fAbnormalTermination)
{
    THSTATE *pTHS = pTHStls;

    Assert(NULL != pTHS);
    Assert(pTHS->pDB);

    if (( 0 != err ) || (fAbnormalTermination))
    {
        DBCancelRec( pTHS->pDB );
    }

    if ( !pTHS->fSAM
         && ((TRANSACT_BEGIN_END == pTHS->transControl)
             || (TRANSACT_DONT_BEGIN_END == pTHS->transControl)
            )
       )
    {
        __try
        {
            // Nuke the GC verification Cache
            pTHS->GCVerifyCache = NULL;

            // If we looped back, we should have gone through the loopback
            // merge path. Therefore assert that pSamLoopback is indeed NULL
            // The only excuse for not having cleaned up pSamLoopback is
            // if we errored out in the loopback code

            Assert((0!=pTHS->errCode) || (NULL==pTHS->pSamLoopback));

            CleanReturn(pTHS, err, fAbnormalTermination);

        }
        __finally
        {
            if ( pTHS->fSamWriteLockHeld ) {

                //
                // If our top level transaction is not being commited then
                // if it were a looped back operation ( ie SAM write lock
                // held ) then invalidate the SAM domain cache before releasing
                // the lock. This is because SAM operations performed in this
                // transaction may have updated the cache, with data which we
                // are not commiting
                //
                if (( 0 != err ) || (fAbnormalTermination))
                {
                    SampInvalidateDomainCache();
                }

                pTHS->fSamWriteLockHeld = FALSE;
                SampReleaseWriteLock(
                        (BOOLEAN) (( 0 == err ) && !fAbnormalTermination));

            }

            //
            // Remind SAM of changes committed in this routine, so SAM can
            // tell clients about those changes (eg tell the PDC about password
            // changes)
            //
            SampProcessLoopbackTasks();

        }
    }
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Set a transaction as either read or write (exclusive) or write but allow
   reads.

   Identify the type of transaction, initialize a cache flag that indicates
   that the catalog cache hasn't been updated, indicate that a schema
   handle has not yet been obtained, indicate that syncpoint has been
   set and if this is an update transaction, we start a syncpoint with CTREE.

*/

extern int APIENTRY SyncTransSet(USHORT transType)
{
    THSTATE *pTHS = pTHStls;
    DWORD err;

    pTHS->transType            = transType;
    pTHS->errCode              = 0;

    DBOpen(&(pTHS->pDB));
    pTHS->fSyncSet             = TRUE;  /*A sync point is set   */

    return 0;

}/*SyncTransSet*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

/* Return schema handle, commit or roll all DB actions in both the database
   and the memory catalog.  unlock the transaction.  For now we have a CRUDE
   scheme for rolling the memory catalog.  We simply empty the cache and
   reload.  This is acceptable for now...but we could definitely do better!

   NOTE that we don't roll back the cached knowledge information (references)
   or the cached shema.  This is because these caches are  never updated
   until we know that we have a sucessful transaction.  This is not true
   for the catalog. The present design updates the catalog as part of update
   validation and may need to be rolled back if a schema problem occurs.
*/

extern int APIENTRY CleanReturn(THSTATE *pTHS, DWORD dwError, BOOL fAbnormalTerm)
{
    BOOL fCommit;

    DPRINT1(2,"CleanReturn entered <%u>\n",dwError);

    fCommit = ((dwError == 0) && !fAbnormalTerm);

    if (pTHS->pDB == NULL){
        DPRINT(0,"Zero pDB in CleanReturn\n");
        LogUnhandledError(0);
        Assert(FALSE);
    }

    SyncTransEnd(pTHS, fCommit);

    return (dwError);

}/*CleanReturn*/

extern VOID APIENTRY
SyncTransEnd(THSTATE *pTHS, BOOL fCommit)
{
    __try
    {
        if (!pTHS->fSyncSet){
            DPRINT(2,"No sync point set so just return\n");
            Assert(!(pTHS->pSamNotificationHead || pTHS->pSamNotificationTail));
            Assert(!(pTHS->pSamAuditNotificationHead || pTHS->pSamAuditNotificationTail));
            __leave;
        }

        /* Clear locks, commit or rollback any updates to both mem and DB*/

        switch (pTHS->transType){

          case SYNC_READ_ONLY:
            /* This is a read only transaction*/
            break;

          case SYNC_WRITE:
            /* This is an update transaction with a write (exclusive) lock*/
            break;

          default:
            // Shouldn't get to here

            DPRINT(0,"Unrecognized trans type in SyncTransEnd\n");
            LogUnhandledError(pTHS->transType);
            Assert(FALSE);
            break;

        }/*switch*/

        Assert(pTHS->pDB);

        // Because it's easier and quicker for JET to do a commit
        // rather than a rollback for read transactions that succeeded,
        // we commit both reads and writes that succeeded. We rollback
        // reads that failed (as well as writes) just to be careful.

        DBClose(pTHS->pDB, fCommit);

        //
        // Log any audit events for SAM objects associated with this transaction.
        // 
        
        if ((pTHS->pSamAuditNotificationHead) && (fCommit)){
            //
            // Only success audits are supported at this time.
            //
            
            SampProcessAuditNotifications(pTHS->pSamAuditNotificationHead);
        }

        //
        // The Transaction is Now Committed. We must notify LSA,
        // SAM and Netlogon of changes, that were committed in
        // the last transaction. The below name SampProcessReplicatedInChanges
        // is really a misnomer. It was true that this was originally used
        // only for processing replicated in changes, but today this is used
        // for both originating and replicated in changes.
        //

        if ((pTHS->pSamNotificationHead) && (fCommit)){
            SampProcessReplicatedInChanges(pTHS->pSamNotificationHead);
        }
        

    }__finally
    {
        pTHS->pSamAuditNotificationHead = NULL;
        pTHS->pSamAuditNotificationTail = NULL;
        pTHS->pSamNotificationHead = NULL;
        pTHS->pSamNotificationTail = NULL;
        pTHS->fAccessChecksCompleted = FALSE;
        pTHS->fSyncSet = FALSE;            /* A sync point is not set */
    }

}/*SyncTransEnd*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*Determines if an object is of class alias by checking the class attribute
  values for for the predefined class of alias.  A Class that inherits class
  alias is still an alias.
*/

BOOL APIENTRY IsAlias(DBPOS *pDB)
{

    // We don't support aliases, so it's a good bet that this object isn't one.
    return FALSE;

}/*IsAlias*/

/***********************************************************************
 *
 * Given a string DN, return a distname.  Return value is nonzero on success,
 * or 0 if something went wrong. Allocate the memory here.
 *
 ***********************************************************************/
DWORD StringDNtoDSName(char *szDN, DSNAME **ppDistname)
{
    THSTATE *pTHS=pTHStls;
    ULONG cb = strlen(szDN);

    DSNAME * pDN = THAllocEx(pTHS, DSNameSizeFromLen(cb));

    MultiByteToWideChar(CP_TELETEX,
                        0,
                        szDN,
                        cb,
                        pDN->StringName,
                        cb);
    pDN->NameLen = cb;
    pDN->structLen = DSNameSizeFromLen(cb);

    *ppDistname = pDN;

    return 1;
}

// Return TRUE if the ptr to the NT4SID is NULL, or the NT4SID is all zeroes

BOOL fNullNT4SID (NT4SID *pSid)
{
    if (!pSid) {
        return TRUE;
    }

    if (memcmp (pSid, &fNullNT4SID, sizeof (NT4SID))) {
        return FALSE;
    }
    return TRUE;
}

#ifdef CACHE_UUID

// FindUuid
//
// Searches cache for uuid, returns ptr to name if found, NULL if not.

char * FindUuid (UUID *pUuid)
{
    UUID_CACHE_ENTRY *pCETemp;

    EnterCriticalSection (&csUuidCache);
    pCETemp = gUuidCacheHead;
    while (pCETemp) {
        if (!memcmp (&pCETemp->Uuid, pUuid, sizeof (UUID))) {
            LeaveCriticalSection(&csUuidCache);
            return pCETemp->DSAName;
        }
        pCETemp = pCETemp->pCENext;
    }
    LeaveCriticalSection(&csUuidCache);
    return NULL;
}

// AddUuidCacheEntry
//
// This function adds a cache entry to the linked list of cache entries

void AddUuidCacheEntry (UUID_CACHE_ENTRY *pCacheEntry)
{
    UUID_CACHE_ENTRY **ppCETemp;

    EnterCriticalSection (&csUuidCache);
    ppCETemp = &gUuidCacheHead;
    while (*ppCETemp) {
        ppCETemp = &((*ppCETemp)->pCENext);
    }
    *ppCETemp = pCacheEntry;
    LeaveCriticalSection(&csUuidCache);
}

// CacheUuid
//
// This function adds a uuid cache entry to the list if that uuid is not
// already entered.

void CacheUuid (UUID *pUuid, char * pDSAName)
{
    UUID_CACHE_ENTRY *pCacheEntry;

    if (fNullUuid (pUuid)) {
        return;
    }

    if (!FindUuid (pUuid)) {
        pCacheEntry = malloc (sizeof (UUID_CACHE_ENTRY) + strlen(pDSAName));
        if (pCacheEntry) {
            strcpy (pCacheEntry->DSAName, pDSAName);
            memcpy (&pCacheEntry->Uuid, pUuid, sizeof(UUID));
            pCacheEntry->pCENext = NULL;
            AddUuidCacheEntry (pCacheEntry);
        } else {
       DRA_EXCEPT (DRAERR_OutOfMem, 0);
   }
    }
}
#endif

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function gets the DISTNAME from the current object, converts it
   to a string format and returns a pointer to the string.  The output
   string is allocated in transaction space and is automatically freed.  If
   the Distname can't be retrieved from the DB, an error string is returned
   instead.
*/

UCHAR * GetExtDN(THSTATE *pTHS, DBPOS *pDB){

    char   errBuff[128];
    DSNAME *pDN = NULL;
    ULONG  len, err;
    UCHAR *pString;

    DPRINT(1, "GetExtDN entered\n");

    if (err = DBGetAttVal(pDB,
                          1,
                          ATT_OBJ_DIST_NAME,
                          0,
                          0,
                          &len, (UCHAR **)&pDN)){

        DPRINT2(1,"Error %d retrieving the DN attribute of DNT 0x%x\n",
                err, pDB->DNT);
        sprintf(errBuff, "Error %d retrieving the DN attribute of DNT 0x%x",
                err, pDB->DNT);
        len = strlen(errBuff);
        pString = THAllocEx(pTHS, len+1);
        memcpy(pString, errBuff, len+1);
        return pString;
    }

    pString = MakeDNPrintable(pDN);
    THFreeEx(pTHS, pDN);
    return pString;

}/* GetExtDN */

DSNAME * GetExtDSName(DBPOS *pDB){

    ULONG  len;
    DSNAME *pDN;

    if (DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME,
                    0,
                    0,
                    &len, (UCHAR **)&pDN)){

        DPRINT(1,"Couldn't retrieve the DN attribute\n");
        return NULL;
    }

    return pDN;

}/* GetExtDSName */

int APIENTRY
FindAliveDSName(DBPOS FAR *pDB, DSNAME *pDN)
{
    BOOL   Deleted;

    DPRINT1(1, "FindAliveDSName(%ws) entered\n",pDN->StringName);

    switch (DBFindDSName(pDB, pDN)){

      case 0:

        if (!DBGetSingleValue(pDB, ATT_IS_DELETED, &Deleted, sizeof(Deleted),
                              NULL) &&
            Deleted ) {
            return FIND_ALIVE_OBJ_DELETED;
        }
        else{

            return FIND_ALIVE_FOUND;
        }

      case DIRERR_OBJ_NOT_FOUND:
      case DIRERR_NOT_AN_OBJECT:

        return FIND_ALIVE_NOTFOUND;

      case DIRERR_BAD_NAME_SYNTAX:
      case DIRERR_NAME_TOO_MANY_PARTS:
      case DIRERR_NAME_TOO_LONG:
      case DIRERR_NAME_VALUE_TOO_LONG:
      case DIRERR_NAME_UNPARSEABLE:
      case DIRERR_NAME_TYPE_UNKNOWN:

        return FIND_ALIVE_BADNAME;

      default:

        return FIND_ALIVE_SYSERR;

    }  /*switch*/

}/*FindAlive*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function takes a string in the clients code page and converts it
   to a unicode string.
*/
wchar_t  *UnicodeStringFromString8(UINT CodePage, char *szA, LONG cbA)
{
    THSTATE *pTHS=pTHStls;
    DWORD cb = 0;
    wchar_t *szW;

    cb = MultiByteToWideChar(CodePage,          // code page
                             0,                 // flags
                             szA,               // multi byte string
                             cbA,               // mb string size in chars
                             NULL,              // unicode string
                             0);                // unicode string size in chars

    szW = (wchar_t *) THAllocEx(pTHS, (cb+1) * sizeof(wchar_t));

    MultiByteToWideChar(CodePage,           // code page
                        0,                  // flags
                        szA,                // multi byte string
                        cbA,                // mb string size in chars
                        szW,                // unicode string
                        cb);                // unicode string size in chars

    szW[cb] = 0;            // null terminate

    return szW;
} /* UnicodeStringFromString8 */


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function takes a unicode string allocates memory and converts it to
   the client's code page
*/
char  *
String8FromUnicodeString(
        BOOL bThrowException,
        UINT CodePage,
        wchar_t *szU,
        LONG cbU,
        LPLONG pCb,
        LPBOOL pfUsedDefChar)
{
    THSTATE *pTHS=pTHStls;
    DWORD cb, cb2;
    char *sz8;

    if (pfUsedDefChar && ((CP_UTF8 == CodePage) || (CP_UTF7 == CodePage))) {
        //
        // The default char parameter of WideCharToMultiByte
        // must be NULL if the code page is either UTF-8 or UTF-7.
        //
        pfUsedDefChar = NULL;
    }

    cb = WideCharToMultiByte((UINT) (CodePage),    // code page
            0L,                                    // flags
            szU,                                   // unicode string
            cbU,                                   // sizeof string in chars
            NULL,                                  // string 8
            0,                                     // sizeof(string 8) in bytes
            NULL,                                  // default char
            NULL);                                 // used default char

    if(bThrowException) {
        sz8 = (char *) THAllocEx(pTHS, cb+1);
    }
    else {
        sz8 = (char *) THAlloc(cb+1);
        if(!sz8) {
            return NULL;
        }
    }

    cb2 = WideCharToMultiByte((UINT) (CodePage),        // code page
             0L,                                        // flags
             szU,                                       // unicode string
             cbU,                                       // sizeof string in chars
             sz8,                                       // string 8
             cb,                                        // sizeof(string 8) in bytes
             NULL,                                      // default char
             pfUsedDefChar);                            // used default char

    Assert(cb == cb2);
    if (0 == cb2) {
        DPRINT2(0, "String8FromUnicodeString: conversion to code page %d failed with %d\n",
                CodePage, GetLastError());
        if (bThrowException) {
            DsaExcept(DSA_EXCEPTION, GetLastError(), 0);
        } else {
            THFree(sz8);
            return NULL;
        }
    }

    sz8[cb] = '\0';            // null terminate

    if(pCb)
        *pCb=cb;

    return sz8;
} /*String8FromUnicodeString*/

//
// Takes a WCHAR string and returns its LCMapped string
// cchLen is the number of characters of the passed in string
// this is used to calculate an initial size for the output string
// cchLen can be zero.
//
// The result is calculated by mapping
// the passed string using LCMapString to a string value.
// The flags for the mapping are: DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY
// The result hashkey can be compared using strcmp.
//
// returns:
//      NULL on failure
//      The LCMapString value of the string passed in. It is stored in ThAlloced
//      memory and the client has to take care of freeing it.
//
CHAR *DSStrToMappedStr (THSTATE *pTHS, const WCHAR *pStr, int cchLen)
{
    // the paradox with LCMapString is that it returns a char *
    // when asking for LCMAP_SORTKEY
    ULONG mappedLen;
    CHAR *pMappedStr;

    if (cchLen == 0) {
        cchLen = wcslen (pStr);
    }

    mappedLen = LCMapStringW(DS_DEFAULT_LOCALE,
                             (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                             pStr,
                             cchLen,
                             NULL,
                             0);
    // succedded
    if (mappedLen) {
        pMappedStr = (CHAR *) THAllocEx (pTHS, mappedLen);

        if (!LCMapStringW(DS_DEFAULT_LOCALE,
                         (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                         pStr,
                         cchLen,
                         (WCHAR *)pMappedStr,
                         mappedLen)) {

            DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
            THFreeEx (pTHS, pMappedStr);
            pMappedStr = NULL;
        }

    }
    else {
        DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
        pMappedStr = NULL;
    }

    return pMappedStr;
}

CHAR *DSStrToMappedStrExternal (const WCHAR *pStr, int cchLen)
{
    THSTATE *pTHS = pTHStls;

    return DSStrToMappedStr (pTHS, pStr, cchLen);
}

//
// Takes a DSNAME and returns its its LCMapped version
//
// the LCMapped version is calculated by concatenating all the components of
// the DSNAME together into a new WCHAR string and then mapping this
// using LCMapString to a string value.
// The flags for the mapping are: DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY
// The result hashkey can be compared using strcmp.
//
// Example:
//    given a DSNAME of: Cn=Users,DC=ntdev,DC=microsoft,DC=com
//    the result will be the LcMapString of: commicrosoftntdevusers
//
// returns:
//      NULL on failure
//      The LCMapString value of the string passed in. It is stored in ThAlloced
//      memory and the client has to take care of freeing
//
CHAR* DSNAMEToMappedStr(THSTATE *pTHS, const DSNAME *pDN)
{
    unsigned count;

    WCHAR rdn[MAX_RDN_SIZE];
    ULONG rdnlen;
    ULONG len;
    WCHAR *pKey, *pQVal;
    unsigned ccKey, ccQVal;
    int i;
    WCHAR *buffer, *p;
    CHAR *pMappedStr;

    if (0 == pDN->NameLen) {
        p = buffer = (WCHAR *) THAllocEx (pTHS, sizeof (WCHAR));
        *buffer = 0;
        goto calcHash;
    }

    if (CountNameParts(pDN, &count)) {
        return NULL;
    }

    p = buffer = (WCHAR *) THAllocEx (pTHS, (pDN->NameLen+1) * sizeof (WCHAR));

    len = pDN->NameLen;

    for (i=count; i>0; i--) {
        if (GetTopNameComponent(pDN->StringName,
                            len,
                            (const WCHAR **)&pKey,
                            &ccKey,
                            (const WCHAR **)&pQVal,
                            &ccQVal)) {

            THFreeEx (pTHS, buffer);
            return NULL;
        }

        len = (ULONG)(pKey - pDN->StringName);
        rdnlen = UnquoteRDNValue(pQVal, ccQVal, rdn);

        if (rdnlen) {
            memcpy (p, rdn, rdnlen * sizeof (WCHAR));
            p += rdnlen;
        }
    }

calcHash:

    pMappedStr = DSStrToMappedStr (pTHS, buffer, 0);

    THFreeEx (pTHS, buffer);

    return pMappedStr;
}

CHAR* DSNAMEToMappedStrExternal (const DSNAME *pDN)
{
    THSTATE *pTHS = pTHStls;

    return DSNAMEToMappedStr (pTHS, pDN);
}


//
// helper function which takes a DSNAME and returns its hashkey
//
DWORD DSNAMEToHashKey(THSTATE *pTHS, const DSNAME *pDN)
{
    DWORD hashKey = 0;
    CHAR *pMappedStr = DSNAMEToMappedStr (pTHS, pDN);

    if (pMappedStr) {
        hashKey = DSHashString (pMappedStr, hashKey);

        THFreeEx (pTHS, pMappedStr);
    }

    return hashKey;
}

DWORD DSNAMEToHashKeyExternal (const DSNAME *pDN)
{
    THSTATE *pTHS = pTHStls;

    return DSNAMEToHashKey (pTHS, pDN);
}

#if DBG
    // use these global variables to monitor the usage of the
    // hash function and see if we get a lot of misses.
    ULONG gulStrHashKeyTotalInputSize = 0;
    ULONG gulStrHashKeyTotalOutputSize = 0;
    ULONG gulStrHashKeyCalls = 0;
    ULONG gulStrHashKeyMisses = 0;
#endif

//
// helper function which takes a WCHAR and returns its hashkey
// cchLen is the lenght of the string, if known, otherwise zero
//
DWORD DSStrToHashKey(THSTATE *pTHS, const WCHAR *pStr, int cchLen)
{
    ULONG mappedLen;
    CHAR *pMappedStr = NULL;
    CHAR localMappedStr[4*MAX_RDN_SIZE];
    BOOL useLocal = TRUE;
    DWORD hashKey = 0;

    if (!pStr) {
        return hashKey;
    }

    if (cchLen == 0) {
        cchLen = wcslen (pStr);
    }

#if DBG
    gulStrHashKeyCalls++;
    gulStrHashKeyTotalInputSize += cchLen;
#endif

    // start by using our local buffer todo the transalation
    //
    mappedLen = LCMapStringW(DS_DEFAULT_LOCALE,
                             (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                             pStr,
                             cchLen,
                             (WCHAR *)localMappedStr,
                             sizeof (localMappedStr));

    // was the buffer big enough to store the result ?
    //
    if (!mappedLen) {
#if DBG
        gulStrHashKeyMisses++;
#endif

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            mappedLen = LCMapStringW(DS_DEFAULT_LOCALE,
                                     (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                                     pStr,
                                     cchLen,
                                     NULL,
                                     0);

            // succedded
            if (mappedLen) {
                pMappedStr = (CHAR *) THAllocEx (pTHS, mappedLen);
                useLocal = FALSE;

                if (!LCMapStringW(DS_DEFAULT_LOCALE,
                                 (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                                 pStr,
                                 cchLen,
                                 (WCHAR *)pMappedStr,
                                 mappedLen)) {

                    DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
                    THFreeEx (pTHS, pMappedStr);
                    pMappedStr = NULL;
                }

            }
            else {
                DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
                pMappedStr = NULL;
            }
        }
    }
    else {
        Assert ( mappedLen < sizeof (localMappedStr) );
        pMappedStr = localMappedStr;
    }

#if DBG
    gulStrHashKeyTotalOutputSize += mappedLen;
#endif

    // ok, we have a string, so hash it
    if (pMappedStr) {
        hashKey = DSHashString ((char *)pMappedStr, hashKey);
    }

    if (!useLocal && pMappedStr) {
        THFreeEx (pTHS, pMappedStr);
    }

    return hashKey;
}

DWORD DSStrToHashKeyExternal(const WCHAR *pStr, int cchLen)
{
    THSTATE *pTHS = pTHStls;

    return DSStrToHashKey (pTHS, pStr, cchLen);
}

/*******************************
*
* This routine takes a pointer to a buffer.  The buffer
* is an array of DWORDS, where the first element is the
* count of the rest of the DWORDS in the buffer, and the
* rest of the DWORDS are pointers to free.
*
* This routine is called from the Event Queue and is a
* way of deferring deallocation of memory that might be
* in use.
*
*********************************/

void
DelayedFreeMemory(
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
    //
    // buffer is a pointer to a DWORD_PTR array. First entry is the number
    // of buffers to be freed.
    //

    PDWORD_PTR pBuf = (PDWORD_PTR)buffer;
    DWORD index, Count = (DWORD)pBuf[0];

    for(index=1; index <= Count; index++)
    {
        __try {
                free((void *) pBuf[index]);
        }
        __except(HandleMostExceptions(GetExceptionCode()))
        {
            LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_DELAYED_FREE_FAILED,
                0,0,0);
        }
    }

    __try {
        free(buffer);
    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {
        LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_DELAYED_FREE_FAILED,
            0,0,0);
    };

    (void) ppvNext;     // unused -- task will not be rescheduled
    (void) pcSecsUntilNextIteration; // unused -- task will not be rescheduled
}

void
DelayedFreeMemoryEx(
        DWORD_PTR *pointerArray,
        DWORD timeDelay
        )
{
#if defined(DBG)
    // check the pointers that are delayed-freed right away
    // so that we don't get an AV one hour later
    DWORD i, count;
    Assert(IsValidReadPointer((PVOID)pointerArray, sizeof(DWORD)));
    count = (DWORD)pointerArray[0];
    for (i = 1; i <= count; i++) {
        // NULLs can be free'd no problem
        Assert(!pointerArray[i] || IsValidReadPointer((PVOID)pointerArray[i], 1));
    }
#endif
    // [Colinbr] DelayedFree was changed to free immediately based on the feedback
    // that schema cache rebuilds during install would lead to enourmous amounts of
    // memory being wasted. 
    if(DsaIsRunning()) {
        InsertInTaskQueue(TQ_DelayedFreeMemory, pointerArray, timeDelay);
    }
    else {
        DelayedFreeMemory(pointerArray, NULL, NULL);
    }
}

/*++

Routine Description:

    Checks to see if the attribute is one that we don't allow clients to set.
    We  discriminate based on attribute id. Also, we don't allow
    adding backlink attributes

Arguments:

    pAC - the attcache of the attribute to check.

Return Values:

    TRUE means the attribute is reserved and should not be added.

--*/
BOOL
SysAddReservedAtt (
        ATTCACHE *pAC
        )
{
    THSTATE *pTHS = pTHStls;

    switch (pAC->id) {
    /* first case: attributes no one may add */
      case ATT_OBJ_DIST_NAME:
      case ATT_SUB_REFS:
      case ATT_USN_LAST_OBJ_REM:
      case ATT_USN_DSA_LAST_OBJ_REMOVED:
        return TRUE;
        break;

    /* second case: attributes that the DRA may replicate in */
      case ATT_WHEN_CREATED:
      case ATT_USN_CREATED:
      case ATT_REPL_PROPERTY_META_DATA:
        return (!(pTHS->fDRA));
        break;

    /* third case: attributes that only the DSA itself may add, but  */
    /*             that may replicate in as well                     */
      case ATT_IS_DELETED:
      case ATT_INSTANCE_TYPE:
      case ATT_PROXIED_OBJECT_NAME:
        return (!(pTHS->fDRA || pTHS->fDSA));

      default:
        return FALSE;
    }

}/*SysAddReservedAtt*/


/*++ MakeDNPrintable
 *
 * Takes a DSNAME and returns a Teletex string DN for it, allocated
 * in the thread heap.  Just uses whatever the stringname in the DSNAME is.
 *
 */
UCHAR * MakeDNPrintable(DSNAME *pDN)
{
    UCHAR *pString;

    pString = String8FromUnicodeString( TRUE,             // Raise exception on error
                                        CP_TELETEX,       // code page
                                        pDN->StringName,  // Unicode string
                                        pDN->NameLen,     // Unicode string length
                                        NULL,             // returned length
                                        NULL              // returned used def char
        );
    Assert( pString );

    return pString;
}


//
// MemAtoi - takes a pointer to a non null terminated string representing
// an ascii number  and a character count and returns an integer
//

int MemAtoi(BYTE *pb, ULONG cb)
{
#if (1)
    int res = 0;
    int fNeg = FALSE;

    if (*pb == '-') {
        fNeg = TRUE;
        pb++;
    }
    while (cb--) {
        res *= 10;
        res += *pb - '0';
        pb++;
    }
    return (fNeg ? -res : res);
#else
    char ach[20];
    if (cb >= 20)
        return(INT_MAX);
    memcpy(ach, pb, cb);
    ach[cb] = 0;

    return atoi(ach);
#endif
}


BOOL
fTimeFromTimeStr (
        SYNTAX_TIME *psyntax_time,
        OM_syntax syntax,
        char *pb,
        ULONG len,
        BOOL *pLocalTimeSpecified
        )
{
    SYSTEMTIME  tmConvert;
    FILETIME    fileTime;
    SYNTAX_TIME tempTime;
    ULONG       cb;
    int         sign    = 1;
    BOOL        fOK=FALSE, fStringEnd = FALSE;
    DWORD       timeDifference = 0;
    char        *pLastChar;

    (*pLocalTimeSpecified) = FALSE;

    // Intialize pLastChar to point to last character in the string
    // We will use this to keep track so that we don't reference
    // beyond the string

    pLastChar = pb + len - 1;

    // initialize
    memset(&tmConvert, 0, sizeof(SYSTEMTIME));
    *psyntax_time = 0;

    // Check if string is in UTC format or Generalized-time format.
    // Generalized-Time strings must have a "."  or "," in the 15th place
    // (4 for year, 2 for month, 2 for day, 2 for hour, 2 for minute,
    // 2 for second, then comes the . or ,).
    switch (syntax) {
    case OM_S_UTC_TIME_STRING:
        if ( (len >= 15) && ((pb[14] == '.') || (pb[14] == ',')) ) {
           // this is a Generalized-time string format,
           // Change syntax so that it will be parsed accordingly
           syntax = OM_S_GENERALISED_TIME_STRING;
        }
        break;
    case OM_S_GENERALISED_TIME_STRING:
        if ( (len < 15) || ((pb[14] != '.') && (pb[14] != ',')) ) {
           // cannot be a Generalized-time string.
           syntax = OM_S_UTC_TIME_STRING;
        }
        break;
    default:
        Assert((syntax == OM_S_GENERALISED_TIME_STRING) ||
               (syntax == OM_S_UTC_TIME_STRING));
    }

    // Set up and convert all time fields

    // UTC or Generalized, there must be at least 10 characters
    // in the string (year, month, day, hour, minute, at least 2 for
    // each)

    if (len < 10) {
       // cannot be a valid string. return fOK, already intialized
       // to FALSE
       DPRINT(1,"Length of time string supplied is less than 10\n");
       return fOK;
    }

    // year field
    switch (syntax) {
    case OM_S_GENERALISED_TIME_STRING:  // 4 digit year
        cb=4;
        tmConvert.wYear = (USHORT)MemAtoi(pb, cb) ;
        pb += cb;
        break;

    case OM_S_UTC_TIME_STRING:          // 2 digit year
        cb=2;
        tmConvert.wYear = (USHORT)MemAtoi(pb, cb);
        pb += cb;

        if (tmConvert.wYear < 50)  {   // years before 50
            tmConvert.wYear += 2000;   // are next century
        }
        else {
            tmConvert.wYear += 1900;
        }

        break;

    default:
        Assert((syntax == OM_S_GENERALISED_TIME_STRING) ||
               (syntax == OM_S_UTC_TIME_STRING));
    }

    // month field
    tmConvert.wMonth = (USHORT)MemAtoi(pb, (cb=2));
    pb += cb;

    // day of month field
    tmConvert.wDay = (USHORT)MemAtoi(pb, (cb=2));
    pb += cb;

    // hours
    tmConvert.wHour = (USHORT)MemAtoi(pb, (cb=2));
    pb += cb;

    // We had at least 10 characters, so we were guaranteed upto
    // the hour without going off the end of the string (Max 4 for year,
    // 2 each for month, day and hour). But from now
    // on we need to check if we have enough characters left in the string
    // before derefing the pointer pb

    // we will be using the next two chars (pointed to by pb
    // and pb+1) for minute

    if ( (pb+1) > pLastChar) {
       // not enough characters in string
       DPRINT(1,"Not enough characters for minutes\n");
       return fOK;
    }

    // minutes
    tmConvert.wMinute = (USHORT)MemAtoi(pb, (cb=2));
    pb += cb;

    // Must be at least one more character (seconds etc. for generalized-time,
    // 'Z' or a +/- differential for UTC-time)

    if (pb > pLastChar) {
       // not enough chars in string
       DPRINT(1,"Not enough characters for second/differential\n");
       return fOK;
    }

    //  Seconds are required on GENERALISED_TIME_STRING and optional on UTC time
    if ((syntax==OM_S_GENERALISED_TIME_STRING) ||
        ((*pb >= '0') && (*pb <= '9'))            ) {

        // must have at least two chars for second
        if ( (pb+1) > pLastChar) {
          // not enough characters in string
          DPRINT(1,"Not enough characters for seconds\n");
          return fOK;
        }
        tmConvert.wSecond = (USHORT)MemAtoi(pb, (cb=2));
        pb += cb;
    }
    else {
        tmConvert.wSecond =0;
    }

    // Ignore the fractional-seconds part of GENERALISED_TIME_STRING
    if (syntax==OM_S_GENERALISED_TIME_STRING) {
        // skip the .
        pb += 1;
        // skip until end of string, or until Z or a diferential is reached
        while ( (pb <= pLastChar) && ((*pb) != 'Z')
                      && ((*pb) != '+') && ((*pb) != '-') ) {
            pb++;
        }
    }

    if (pb > pLastChar) {
        // we are past the seconds etc. and there are no more chars
        // left in the string.
        // For generalized-time string, this is ok and means time is local.
        // However, we cannot allow that since we may have DCs in different
        // time zones and unless we have some clue about which time zone
        // the user wanted, we cannot convert to universal (converting to
        // the current DCs time zone is dabgerous, since many apps connects
        // the user to "some" DC, not a particular DC. However, set a special
        // code so that ldap head can return unwilling-to-perform rather
        // than invalid syntax.
        // For UTC-time, where the Z or +/- differential is mandatory

        if (syntax==OM_S_GENERALISED_TIME_STRING) {
             (*pLocalTimeSpecified) = TRUE;
             return fOK;
        }
        else {
           // invalid string
           DPRINT(1,"No Z or +/- differential for UTC-time\n");
           return fOK;
        }
    }


    // If still characters left in string, treat the possible
    // differential, if any

    if (!fStringEnd) {
        switch (*pb++) {

          case '+':
            // local time is ahead of universal time, we will need to
            // subtract to get to universal time
            sign = -1;
            // now fall through to read
          case '-':     // local time is behind universal, so we will add
            // Must have at least 4 more chars in string
            // starting at pb

            if ( (pb+3) > pLastChar) {
                // not enough characters in string
                DPRINT(1,"Not enough characters for differential\n");
                return fOK;
            }

            // hours (convert to seconds)
            timeDifference = (MemAtoi(pb, (cb=2))* 3600);
            pb += cb;

            // minutes (convert to seconds)
            timeDifference  += (MemAtoi(pb, (cb=2)) * 60);
            pb += cb;
            break;


          case 'Z':               // no differential
            break;
          default:
            // something else? Nothing else is allowed
            return fOK;
            break;
        }
    }

    if (SystemTimeToFileTime(&tmConvert, &fileTime)) {
    
        *psyntax_time = (DSTIME) fileTime.dwLowDateTime;
        tempTime = (DSTIME) fileTime.dwHighDateTime;
        *psyntax_time |= (tempTime << 32);
        // this is 100ns blocks since 1601. Now convert to
        // seconds
        *psyntax_time = *psyntax_time/(10*1000*1000L);
        fOK = TRUE;
    }
    else {
        DPRINT1(0, "SystemTimeToFileTime conversion failed %d\n", GetLastError());
    }

    if(fOK && timeDifference) {

        // add/subtract the time difference
        switch (sign) {
        case 1:
            // We assume that adding in a timeDifference will never overflow
            // (since generalised time strings allow for only 4 year digits, our
            // maximum date is December 31, 9999 at 23:59.  Our maximum
            // difference is 99 hours and 99 minutes.  So, it won't wrap)
            *psyntax_time += timeDifference;
            break;
        case -1:
            if(*psyntax_time < timeDifference) {
                // differential took us back before the beginning of the world.
                fOK = FALSE;
            }
            else {
                *psyntax_time -= timeDifference;
            }
            break;
        default:
            fOK = FALSE;
        }
    }

    return fOK;

}

// Exception filtering - handling routine for the main core dsa routines
void
HandleDirExceptions(DWORD dwException,
                    ULONG ulErrorCode,
                    DWORD dsid)
{
    switch(dwException) {

        case DSA_DB_EXCEPTION:
            switch ((JET_ERR) ulErrorCode) {

                case JET_errWriteConflict:
                case JET_errKeyDuplicate:
                    DoSetSvcError(SV_PROBLEM_BUSY,
                                  ERROR_DS_BUSY,
                                  ulErrorCode,
                                  dsid);
                    break;

                case JET_errVersionStoreOutOfMemory:
                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_OUT_OF_VERSION_STORE,
                             szInsertHex(dsid),
                             NULL,
                             NULL);
                    // fall through to set the error

                case JET_errRecordTooBig:
                case JET_errRecordTooBigForBackwardCompatibility:
                    DoSetSvcError(SV_PROBLEM_ADMIN_LIMIT_EXCEEDED,
                                  DS_ERR_ADMIN_LIMIT_EXCEEDED,
                                  ulErrorCode,
                                  dsid);
                    break;

                case JET_errLogWriteFail:
                case JET_errDiskFull:
                case JET_errLogDiskFull:
                    DoSetSysError(ENOSPC,
                                  ERROR_DISK_FULL,
                                  ulErrorCode,
                                  dsid);
                    break;

                case JET_errOutOfMemory:
                    // use ENOMEM problem code so that DoSetSysError
                    // does not attempt to alloc a buffer for error info.
                    DoSetSysError(ENOMEM,
                                  ERROR_NOT_ENOUGH_MEMORY,
                                  ulErrorCode,
                                  dsid);
                    break;

                default:
                    DoSetSvcError(SV_PROBLEM_DIR_ERROR,
                                  DIRERR_UNKNOWN_ERROR,
                                  ulErrorCode,
                                  dsid);
                    break;
            }
            break;

        case DSA_EXCEPTION:
            DoSetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                          DIRERR_UNKNOWN_ERROR,
                          ulErrorCode,
                          dsid);
            break;

        case STATUS_NO_MEMORY:
        case DSA_MEM_EXCEPTION:
            DoSetSysError(ENOMEM,
                          ERROR_NOT_ENOUGH_MEMORY,
                          ulErrorCode,
                          dsid);
            break;

        default:
            DoSetSvcError(SV_PROBLEM_UNAVAILABLE,
                          ERROR_DS_UNAVAILABLE,
                          dwException,
                          dsid);
            break;
    }
}

DWORD
dsGetClientID(
        )
{
    DWORD clientID;

    clientID = InterlockedExchangeAdd((PLONG)&gClientID,1);
    return clientID;
}

// Helper routine so in-process clients can perform
// multi-object transactions.

VOID
DirTransactControl(
    DirTransactionOption option)
{
    THSTATE *pTHS = pTHStls;

    // Must have a valid thread state.
    Assert(VALID_THSTATE(pTHS));

    // SAM does its own transaction control.  We don't assert
    // on pTHS->fSamWriteLockHeld as it is legitimate for a
    // DirTransactControl caller to acquire the SAM lock.  Indeed,
    // it is REQUIRED if one of the Dir* calls within the transaction
    // will cause loop back through SAM.  See AcquireSamLockIfNecessary
    // in draserv.c for an example of how to check for this condition
    // and asserts in SampBeginLoopbackTransactioning in loopback.c.
    Assert(!pTHS->fSAM);
    Assert(!pTHS->fSamDoCommit);
    Assert(!pTHS->pSamLoopback);

    switch ( option )
    {
    case TRANSACT_BEGIN_END:
    case TRANSACT_BEGIN_DONT_END:

        Assert(!pTHS->pDB);
        Assert(0 == pTHS->transactionlevel);

        pTHS->transControl = option;
        return;

    case TRANSACT_DONT_BEGIN_END:
    case TRANSACT_DONT_BEGIN_DONT_END:

        Assert(pTHS->pDB);
        Assert(pTHS->transactionlevel > 0);

        pTHS->transControl = option;
        return;

    default:

        Assert(!"Invalid DirTransactControl value!");
        break;
    }
}

DWORD  ActiveContainerList[ACTIVE_CONTAINER_LIST_ID_MAX] = {
    0
};

DWORD
RegisterActiveContainerByDNT(
        ULONG DNT,
        DWORD ID
        )
/*++

  Register the special container (e.g. the schema container).

  DNT - DNT of the object
  ID  - ID to register the object as.

  return
    0 if all went well, error code otherwise.

--*/
{
    if(ID <= 0 || ID > ACTIVE_CONTAINER_LIST_ID_MAX) {
        // Hey, we don't do this one!
        return ERROR_INVALID_DATA;
    }
    ActiveContainerList[ID - 1] = DNT;
    return 0;
}


DWORD
RegisterActiveContainer(
        DSNAME *pDN,
        DWORD   ID
        )
/*++

  Register the DN of special containers (e.g. the schema container).

  pDN - DSName of the object
  ID  - ID to register the object as.

  return
    0 if all went well, error code otherwise.

--*/
{
    DWORD DNT = 0;
    DWORD err = DB_ERR_EXCEPTION;
    DBPOS *pDBTmp;

    if(!ID || ID > ACTIVE_CONTAINER_LIST_ID_MAX) {
        // Hey, we don't do this one!
        return ERROR_INVALID_DATA;
    }

    // OK, get the DNT of the container
    // Note: we open a transaction here because we are often at transaction
    // level 0 when we get here and DBFindDSName uses the DNRead cache.  DNRead
    // cache uses should be done inside a transaction.
    DBOpen(&pDBTmp);
    __try {
        // PREFIX: dereferencing uninitialized pointer 'pDBTmp'
        //         DBOpen returns non-NULL pDBTmp or throws an exception
        if  (err = DBFindDSName (pDBTmp, pDN)) {
            LogUnhandledError(err);
        }
        else {
            DNT = pDBTmp->DNT;
        }
    }
    __finally
    {
        DBClose (pDBTmp, (err == 0));
    }

    if(!err) {
        ActiveContainerList[ID - 1] = DNT;
    }

    return err;
}

void
CheckActiveContainer(
        DWORD PDNT,
        DWORD *pID
        )
/*++

  Check to see if the parent of the specified object is one of the special
  containers.

  PDNT - DNT of the object's parent
  pID  - ID to of the special container it is in. 0 means it's not in a special
         container.

  return
    0 if all went well, error code otherwise.

--*/
{
    DWORD  i;

    for(i=0; i < ACTIVE_CONTAINER_LIST_ID_MAX; i++ ) {
        if(PDNT == ActiveContainerList[i]) {
            // Found it.
            *pID = i + 1;
            return;
        }
    }

    // never found it.
    *pID = 0;
    return;
}

DWORD
PreProcessActiveContainer (
        THSTATE    *pTHS,
        DWORD      callType,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        DWORD      ID
        )
/*++

  Do appropriate pre-call processing based on the ID, pCC, pDN, and call type.

  callType - identifier of where we were called from (add, mod, moddn, del)
  pDN -  DSName of the object
  pCC - ClassCache pointer to the class of pDN
  pID  - ID to of the special container it is in. 0 means it's not in a special
         container.

  return
    0 if all went well, error code otherwise.

--*/
{

    switch (ID) {
      case ACTIVE_CONTAINER_SCHEMA:
        // First, make sure we're on the right server
        if (CheckRoleOwnership(pTHS,
                               gAnchor.pDMD,
                               pDN)) {
            // Nothing else matters.
            break;
        }

        // First, see if it is a true schema update.
        switch(pCC->ClassId) {
          case CLASS_ATTRIBUTE_SCHEMA:
            // Yep, it's a new/modified attribute.
            switch (callType) {
              case ACTIVE_CONTAINER_FROM_ADD:
                pTHS->SchemaUpdate=eSchemaAttAdd;
                break;

              case ACTIVE_CONTAINER_FROM_MOD:
                pTHS->SchemaUpdate=eSchemaAttMod;
                break;

              case ACTIVE_CONTAINER_FROM_DEL:
                pTHS->SchemaUpdate=eSchemaAttDel;
                break;

              default:
                pTHS->SchemaUpdate = eNotSchemaOp;
                break;
            }
            break;
          case CLASS_CLASS_SCHEMA:
            // Yep, it's a new/modified class.
            switch (callType) {
              case ACTIVE_CONTAINER_FROM_ADD:
                pTHS->SchemaUpdate=eSchemaClsAdd;
                break;

              case ACTIVE_CONTAINER_FROM_MOD:
                pTHS->SchemaUpdate=eSchemaClsMod;
                break;

              case ACTIVE_CONTAINER_FROM_DEL:
                pTHS->SchemaUpdate=eSchemaClsDel;
                break;

              default:
                pTHS->SchemaUpdate = eNotSchemaOp;
                break;
            }
            break;
          case CLASS_SUBSCHEMA:
            // allow add. Only DSA is allowed to create since this
            // is a system-only class.  Treat as a non-schema op, since we don't
            // do the validation etc. We only create one object of this class
            // (aggregate),  during install. This object is protected
            // against rename by sytemFlags, and no modifies are allowed
            // on this for normal users (checked in LocalModify)
            pTHS->SchemaUpdate = eNotSchemaOp;
            break;

          default:
            // No other class is allowed to be created (and hence
            // have instances modified) under the schema container.
            // (Allow fDSA, fDRA, install, and our special hook, just
            // in case we need to do this later for our use)
            if (   !pTHS->fDSA
                && !pTHS->fDRA
                && !DsaIsInstalling()
                && !gAnchor.fSchemaUpgradeInProgress) {
               return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                  ERROR_DS_CANT_CREATE_UNDER_SCHEMA);
            }
            // for others, set the correct schemaUpdate type.
            pTHS->SchemaUpdate = eNotSchemaOp;
            break;
        }

        if (pTHS->SchemaUpdate != eNotSchemaOp &&
            !SCCanUpdateSchema(pTHS)) {
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_SCHEMA_UPDATE_DISALLOWED);
        }

        // We also need to make sure that you aren't adding the "aggregate"
        // object.
        // [ArobindG, 3/9/98] We will allow creation if the
        // allow-system-only-change flag is set in the registry so that
        // later when we actually
        // create this class and add the aggregate object as a real object
        // under the schema container, we can make that change to a running
        // DC.

        if((callType == ACTIVE_CONTAINER_FROM_ADD) &&
           (NameMatched(pDN, gAnchor.pLDAPDMD) &&
              (!gAnchor.fSchemaUpgradeInProgress && !pTHS->fDRA) )       ) {
            // Hey! We're unwilling to perform this operation!  The LDAPDMD
            // must never be allowed to be created or else the LDAP head will
            // fail to deal with the schema discovery.
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               DIRERR_CANT_ADD_SYSTEM_ONLY);
        }
        break;

      case ACTIVE_CONTAINER_SITES:
        pTHS->fNlSiteObjNotify = TRUE;
        break;

      case ACTIVE_CONTAINER_SUBNETS:
        pTHS->fNlSubnetNotify = TRUE;
        break;

      case ACTIVE_CONTAINER_PARTITIONS:
        CheckRoleOwnership(pTHS,
                           gAnchor.pPartitionsDN,
                           pDN);
        if (callType == ACTIVE_CONTAINER_FROM_DEL) {
            ValidateCRDeletion(pTHS,
                               pDN);
        }
        break;

    case ACTIVE_CONTAINER_OUR_SITE:
        if (pCC->ClassId == CLASS_NTDS_SITE_SETTINGS) {
            pTHS->fAnchorInvalidated = TRUE;
        }
        break;

      default:
        // Hey! This isn't an active container!
        break;
    }

    return pTHS->errCode;
}

/*++ ErrorOnShutdown
 *
 * This routine checks to see if the DSA is shutting down and if so it
 * sets an error code and forcibly closes any transaction than may have
 * been open, even if the caller had a DONT_END transaction state set.
 * When it's quitting time, we really want to quit.  The one exception,
 * as in much of the DSA's transaction logic, is SAM loopback calls.  If
 * we are in a loopback (indicated by fSamWritelockHeld) then we just
 * set the error code, and ignore the transaction, confident that someone
 * up the stack will clean up appropriately.
 */
ULONG ErrorOnShutdown(void)
{
    THSTATE *pTHS = pTHStls;

    if (!eServiceShutdown) {
        return 0;
    }

    SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN);

    if (pTHS->pDB && !pTHS->fSamWriteLockHeld && !pTHS->fSAM) {
        /*
         * We have an open transaction, and it isn't SAM's.  Roll it back.
         */
        Assert((TRANSACT_DONT_BEGIN_END != pTHS->transControl) &&
               (TRANSACT_DONT_BEGIN_DONT_END != pTHS->transControl));
        SyncTransEnd(pTHS, FALSE);
    }

    return pTHS->errCode;
}

BOOLEAN
FindNcForSid(
    IN PSID pSid,
    OUT PDSNAME * NcName
    )
/*++

  Routine Description

    Given a SID, this routine walks the gAnchorList to find the
    naming context head that is the authoritative domain for the
    Sid.

  Parameters:

        pSid  -- The Sid of the object
        NcName -- The DS Name of the NC

  Return Values

        TRUE  -- The DS Name was found
        FALSE -- The DS Name was not found
--*/
{
    THSTATE *pTHS = pTHStls;
    BOOLEAN Found = FALSE;
    CROSS_REF_LIST * pCRL;

    // Walk the gAnchor structure and obtain the NC.

    for (pCRL=gAnchor.pCRL;pCRL!=NULL;pCRL=pCRL->pNextCR)
    {
        if (pCRL->CR.pNC->SidLen>0)
        {
            // Test For Domain Sid
            if (RtlEqualSid(pSid,&(pCRL->CR.pNC->Sid)))
            {
                *NcName = pCRL->CR.pNC;
                Found = TRUE;
                break;
            }
            else
            {
                PSID    pAccountSid;

                // Test For Account Sid
                pAccountSid = THAllocEx(pTHS,RtlLengthSid(pSid));
                memcpy(pAccountSid,pSid,RtlLengthSid(pSid));
                (*RtlSubAuthorityCountSid(pAccountSid))--;
                if (RtlEqualSid(pAccountSid,&(pCRL->CR.pNC->Sid)))
                {
                    *NcName = pCRL->CR.pNC;
                    Found = TRUE;
                    THFreeEx(pTHS,pAccountSid);
                    break;
                }
                THFreeEx(pTHS,pAccountSid);
            }
        }
    }

    return Found;
}


DSA_CALLBACK_STATUS_TYPE gpfnInstallCallBack = 0;
DSA_CALLBACK_ERROR_TYPE  gpfnInstallErrorCallBack = 0;
DSA_CALLBACK_CANCEL_TYPE gpfnInstallCancelOk = 0;
HANDLE                   gClientToken = NULL;

VOID
DsaSetInstallCallback(
    DSA_CALLBACK_STATUS_TYPE pfnUpdateStatus,
    DSA_CALLBACK_ERROR_TYPE  pfnErrorStatus,
    DSA_CALLBACK_CANCEL_TYPE pfnInstallCancelOk,
    HANDLE                   ClientToken
    )
{
    gpfnInstallCallBack = pfnUpdateStatus;
    gpfnInstallErrorCallBack = pfnErrorStatus;
    gpfnInstallCancelOk = pfnInstallCancelOk;
    gClientToken = ClientToken;
}

VOID
SetInstallStatusMessage (
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4, OPTIONAL
    IN  WCHAR *Insert5  OPTIONAL
    )
/*++

Routine Description

    This routine calls the calling client's call to update our status.

Parameters

    MessageId : the message to retrieve

    Insert*   : strings to insert, if any

Return Values

    None.

--*/
{
    static HMODULE ResourceDll = NULL;

    WCHAR   *DefaultMessageString = L"Preparing the directory service";
    WCHAR   *MessageString = NULL;
    WCHAR   *InsertArray[6];
    ULONG    Length;

    //
    // Set up the insert array
    //
    InsertArray[0] = Insert1;
    InsertArray[1] = Insert2;
    InsertArray[2] = Insert3;
    InsertArray[3] = Insert4;
    InsertArray[4] = Insert5;
    InsertArray[5] = NULL;    // This is the sentinel

    if ( !ResourceDll )
    {
        ResourceDll = (HMODULE) LoadLibraryW( L"ntdsmsg.dll" );
    }

    if ( ResourceDll )
    {
        DWORD  WinError = ERROR_SUCCESS;
        BOOL   fSuccess = FALSE;

        fSuccess = ImpersonateLoggedOnUser(gClientToken);
        if (!fSuccess) {
            DPRINT1( 1, "Failed to Impersonate Logged On User for FromatMessage: %ul\n", GetLastError() );
        }


        Length = (USHORT) FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        MessageId,
                                        0,       // Use caller's language
                                        (LPWSTR)&MessageString,
                                        0,       // routine should allocate
                                        (va_list*)&(InsertArray[0])
                                        );
        if ( MessageString )
        {
            // Messages from a message file have a cr and lf appended
            // to the end
            MessageString[Length-2] = '\0';
        }

        if (fSuccess) {
            if (!RevertToSelf()) {
                DPRINT1( 1, "Failed to Revert To Self: %ul\n", GetLastError() );
            }
        }


    }

    if ( !MessageString )
    {
        DPRINT1( 0, "No message string found for id 0x%x\n", MessageId );

        MessageString = DefaultMessageString;

    }

    if ( gpfnInstallCallBack )
    {
        gpfnInstallCallBack( MessageString );
    }

    if ( MessageString != DefaultMessageString )
    {
        LocalFree( MessageString );
    }

}

VOID
SetInstallErrorMessage (
    IN  DWORD  WinError,
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4  OPTIONAL
    )
/*++

Routine Description

    This routine calls the calling client's call to update our status.

Parameters

    MessageId : the message to retrieve

    OpDone    : flags indicating what operation have been done, and hence have
                to be undone

    Insert*   : strings to insert, if any

Return Values

    None.

--*/
{
    static HMODULE ResourceDll = NULL;

    WCHAR   *DefaultMessageString = L"Failed to initialize the directory service";
    WCHAR   *MessageString = NULL;
    WCHAR   *InsertArray[5];
    ULONG    Length;

    //
    // Set up the insert array
    //
    InsertArray[0] = Insert1;
    InsertArray[1] = Insert2;
    InsertArray[2] = Insert3;
    InsertArray[3] = Insert4;
    InsertArray[4] = NULL;    // This is the sentinel

    if ( !ResourceDll )
    {
        ResourceDll = (HMODULE) LoadLibraryW( L"ntdsmsg.dll" );
    }

    if ( ResourceDll )
    {
        BOOL   fSuccess = FALSE;

        fSuccess = ImpersonateLoggedOnUser(gClientToken);
        if (!fSuccess) {
            DPRINT1( 1, "Failed to Impersonate Logged On User for FromatMessage: %ul\n", GetLastError() );
        }

        Length = (USHORT) FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        MessageId,
                                        0,       // Use caller's language
                                        (LPWSTR)&MessageString,
                                        0,       // routine should allocate
                                        (va_list*)&(InsertArray[0])
                                        );
        if ( MessageString )
        {
            // Messages from a message file have a cr and lf appended
            // to the end
            MessageString[Length-2] = '\0';
        }

        if (fSuccess) {
            if (!RevertToSelf()) {
                DPRINT1( 1, "Failed to Revert To Self: %ul\n", GetLastError() );
            }
        }


    }

    if ( !MessageString )
    {
        DPRINT1( 0, "No message string found for id 0x%x\n", MessageId );

        MessageString = DefaultMessageString;

    }

    if ( gpfnInstallErrorCallBack )
    {
        gpfnInstallErrorCallBack( MessageString,
                                  WinError );
    }

    if ( MessageString != DefaultMessageString )
    {
        LocalFree( MessageString );
    }

}

DWORD
DirErrorToWinError(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    )
/*++

Routine Description

    This routine extracts the win error code from the dir structures

Parameters

    DirError : the code returned from DirXxx api

    CommonResult :  the common result structure returned from DirXxx api

Return Values

    A value from the winerror space.

--*/
{

    DWORD WinError = DS_ERR_INTERNAL_FAILURE;

    Assert( CommonResult );

    if ( ( NULL == CommonResult->pErrInfo )
      && ( 0    != DirError ) )
    {
        // Not enough memory to allocate an error buffer

        return ERROR_NOT_ENOUGH_MEMORY;
    }


    switch ( DirError )
    {
        case 0:

            WinError = ERROR_SUCCESS;
            break;

        case attributeError:

            WinError = CommonResult->pErrInfo->AtrErr.FirstProblem.intprob.extendedErr;
            break;

        case nameError:

            WinError = CommonResult->pErrInfo->NamErr.extendedErr;
            break;

        case referralError:

            //
            // This is a tricky one - presumably any server side code
            // calling this function does not expect a referral back
            // so assume the object does not exist locally.  Thus any code
            // wishing to act on referrals should not use this function
            //
            WinError = DS_ERR_OBJ_NOT_FOUND;
            break;

        case securityError:

            // All security error's map to access denied
            WinError = CommonResult->pErrInfo->SecErr.extendedErr;
            break;

        case serviceError:

            WinError = CommonResult->pErrInfo->SvcErr.extendedErr;
            break;

        case updError:

            WinError = CommonResult->pErrInfo->UpdErr.extendedErr;
            break;

        case systemError:

            WinError = CommonResult->pErrInfo->SysErr.extendedErr;
            break;

        default:

            NOTHING;
            break;
    }


    return WinError;

}

NTSTATUS
DirErrorToNtStatus(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    )
/*++

Routine Description

    This routine translates dir return codes to ntstatus

Parameters

    DirError : the code returned from DirXxx api

    CommonResult :  the common result structure returned from DirXxx api

Return Values

    A value from the ntstatus space.

--*/
{

    NTSTATUS  NtStatus;
    USHORT    Problem;
    MessageId ExtendedError;
    NTSTATUS  DefaultErrorCode = STATUS_INTERNAL_ERROR;

    Assert( CommonResult );

    if ( ( NULL == CommonResult->pErrInfo )
      && ( 0    != DirError ) )
    {
        //
        // Return an error code.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now try to do a realistic mapping of errors.
    //

    switch ( DirError )
    {
        case 0L:
            NtStatus = STATUS_SUCCESS;
            break;

        case attributeError:

            Problem = CommonResult->pErrInfo->AtrErr.FirstProblem.intprob.problem;
            switch ( Problem )
            {
            case PR_PROBLEM_NO_ATTRIBUTE_OR_VAL:

                NtStatus = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
                break;

            case PR_PROBLEM_INVALID_ATT_SYNTAX:

                NtStatus = STATUS_DS_INVALID_ATTRIBUTE_SYNTAX;
                break;

            case PR_PROBLEM_UNDEFINED_ATT_TYPE:

                NtStatus = STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED;
                break;

            case PR_PROBLEM_ATT_OR_VALUE_EXISTS:

                NtStatus = STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS;
                break;

            case PR_PROBLEM_CONSTRAINT_ATT_TYPE:
                NtStatus = STATUS_DS_OBJ_CLASS_VIOLATION;
                break;

            case PR_PROBLEM_WRONG_MATCH_OPER:
            default:

                NtStatus = DefaultErrorCode;
                break;
            }
            break;

        case nameError:

            Problem = CommonResult->pErrInfo->NamErr.problem;
            switch(Problem)
            {
            case NA_PROBLEM_NO_OBJECT:
                NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
                break;

            case NA_PROBLEM_BAD_ATT_SYNTAX:
            case NA_PROBLEM_ALIAS_NOT_ALLOWED:
            case NA_PROBLEM_NAMING_VIOLATION:
            case NA_PROBLEM_BAD_NAME:
                NtStatus = STATUS_OBJECT_NAME_INVALID;
                break;
            default:
                NtStatus = DefaultErrorCode;
                break;
            }
            break;

        case referralError:
            // SAM should theoretically get no referrals.
            // However much of SAM code always positions by
            // Sid and the DS name resolution logic will give
            // back a referral error on non GC servers. So
            // really the referrals that SAM recieves are due
            // the object name not being found.

            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            break;

        case securityError:
            // All security error's map to access denied
            NtStatus = STATUS_ACCESS_DENIED;
            break;

        case serviceError:
            Problem = CommonResult->pErrInfo->SvcErr.problem;
            ExtendedError =  CommonResult->pErrInfo->SvcErr.extendedErr;
            switch(Problem)
            {
            case SV_PROBLEM_BUSY:
                NtStatus = STATUS_DS_BUSY;
                break;
            case SV_PROBLEM_UNAVAILABLE:
                NtStatus = STATUS_DS_UNAVAILABLE;
                break;
            case SV_PROBLEM_ADMIN_LIMIT_EXCEEDED:
                NtStatus = STATUS_DS_ADMIN_LIMIT_EXCEEDED;
                break;
            case SV_PROBLEM_DIR_ERROR:

                switch (ExtendedError) {
                case DIRERR_MISSING_SUPREF:
                    //
                    // An attempt to create a referral failed
                    //
                    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
                    break;

                default:
                    NtStatus = DefaultErrorCode;
                    break;

                }
                break;
            default:
                NtStatus = DefaultErrorCode;
                break;
            }
            break;

        case updError:
            Problem = CommonResult->pErrInfo->UpdErr.problem;
            switch(Problem)
            {
            case UP_PROBLEM_NAME_VIOLATION:
                   NtStatus = STATUS_OBJECT_NAME_INVALID;
                   break;
            case UP_PROBLEM_OBJ_CLASS_VIOLATION:
                   NtStatus = STATUS_DS_OBJ_CLASS_VIOLATION;
                   break;
            case UP_PROBLEM_CANT_ON_NON_LEAF:
                   NtStatus = STATUS_DS_CANT_ON_NON_LEAF;
                   break;
            case UP_PROBLEM_CANT_ON_RDN:
                   NtStatus = STATUS_DS_CANT_ON_RDN;
                   break;
            case UP_PROBLEM_ENTRY_EXISTS:
                    NtStatus = STATUS_USER_EXISTS;
                    break;
            case UP_PROBLEM_AFFECTS_MULT_DSAS:
                    NtStatus = DefaultErrorCode;
                    break;
            case UP_PROBLEM_CANT_MOD_OBJ_CLASS:
                    NtStatus = STATUS_DS_CANT_MOD_OBJ_CLASS;
                    break;
            default:
                NtStatus = DefaultErrorCode;
                break;
            }
            break;
        case systemError:
            Problem = CommonResult->pErrInfo->SysErr.problem;
            switch(Problem)
            {
            case ENOMEM:
                NtStatus = STATUS_NO_MEMORY;
                break;
            case EPERM:
                NtStatus = STATUS_ACCESS_DENIED;
                break;
            case EBUSY:
                NtStatus = STATUS_DS_BUSY;
                break;
            case ENOSPC:
                NtStatus = STATUS_DISK_FULL;
                break;
            default:
                NtStatus = DefaultErrorCode;
                break;
            }
            break;

        default:
            NtStatus = DefaultErrorCode;
            break;
    }
    return NtStatus;
}

/*++ SetDsaWritability
 *
 * NetLogon needs to know if the DS is healthy or not, so that it can avoid
 * advertising this server if we'll be unable to service logons.  The current
 * logic is that we'll declare ourselves to be unhealthy (i.e., unwritable)
 * if any Jet operation fails with an "out of disk space"-like error, and that
 * we will declare ourselves healthy again whenever any Jet update actually
 * succeeds.  NetLogon does not want lots of redundant notifications, so we
 * serialize all updates through this one routine, which only makes the call
 * if the desired new state is truly different than the existing state, and
 * guards against two calls being made simultaneously.
 *
 * CliffV writes:
 * I do the same thing with the DS_DS_FLAG that I do with the DS_GC_FLAG. The DS
 * should tell me to set the DS_DS_FLAG whenever it is willing to have folks call
 * its LDAP interface.
 * I don't differentiate between writable and not. So, you should only set the
 * DS_DS_FLAG bit when you're able to do both reads and writes.
 * You can toggle DS_DS_FLAG whenever you want.
 *
 * INPUT:
 *   fNewState - TRUE implies DS is healthy and writable, FALSE that the
 *               DS is unhealthy and that update attempts are unlikely to
 *               succeed.
 */
void
SetDsaWritability(BOOL fNewState,
                  DWORD err)
{
    BOOL fChangedState = FALSE;

    // This code is not effective until we are synchronized
    if (!gfIsSynchronized) {
        return;
    }

    EnterCriticalSection(&csDsaWritable);
    __try {
        if (gfDsaWritable != fNewState) {
            __try {
                dsI_NetLogonSetServiceBits(DS_DS_FLAG,
                                         fNewState ? DS_DS_FLAG : 0);
                gfDsaWritable = fNewState;
                fChangedState = TRUE;
            }
            __except(HandleAllExceptions(GetExceptionCode())) {
                ;
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csDsaWritable);
    }

    if (fChangedState) {
        if (fNewState) {
            // DS is now writable..
            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL ,
                     DS_EVENT_SEV_ALWAYS ,
                     DIRLOG_RESTARTED_NETLOGON,
                     NULL,
                     NULL,
                     NULL);
        }
        else {
            // DS is not writable
            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL ,
                     DS_EVENT_SEV_ALWAYS ,
                     DIRLOG_STOPPED_NETLOGON,
                     szInsertInt(err),
                     szInsertWin32Msg(err),
                     NULL);
        }
    }
}

ULONG
Win32ErrorFromPTHS(THSTATE *pTHS
    )
{
    Assert(VALID_THSTATE(pTHS));

    switch ( pTHS->errCode )
    {
    case 0:
        return(ERROR_SUCCESS);
    case attributeError:
        return(pTHS->pErrInfo->AtrErr.FirstProblem.intprob.extendedErr);
    case nameError:
        return(pTHS->pErrInfo->NamErr.extendedErr);
    case referralError:
        return(pTHS->pErrInfo->RefErr.extendedErr);
    case securityError:
        return(pTHS->pErrInfo->SecErr.extendedErr);
    case serviceError:
        return(pTHS->pErrInfo->SvcErr.extendedErr);
    case updError:
        return(pTHS->pErrInfo->UpdErr.extendedErr);
    case systemError:
        return(pTHS->pErrInfo->SysErr.extendedErr);
    default:
        Assert(!"Unknown error type");
    }

    return(DIRERR_GENERIC_ERROR);
}
           
DWORD
GetErrInfoExtData(
    DWORD     errCode,
    DIRERR *  pErrInfo
    )
// Usually used with:
// #define  GetTHErrorExtData(pTHS)    GetErrInfoExtData(pTHS->errCode, pTHS->pErrInfo)
{
    Assert(errCode == 0 || pErrInfo != NULL);

    switch(errCode){
    case 0:
        return(0);
    case attributeError:
        // Just return the first attribute error info ...
        return(pErrInfo->AtrErr.FirstProblem.intprob.extendedData);
    case nameError:
        return(pErrInfo->NamErr.extendedData);
    case referralError:
        return(pErrInfo->RefErr.extendedData);
    case securityError:
        return(pErrInfo->SecErr.extendedData);
    case serviceError:
        return(pErrInfo->SvcErr.extendedData);
    case updError:
        return(pErrInfo->UpdErr.extendedData);
    case systemError:
        return(pErrInfo->SysErr.extendedData);
    default:
        Assert(!"New error type someone update GetTHErrorExtData() and others ...");
        return(0);

    }
}

DWORD
GetErrInfoDSID(
    DWORD     errCode,
    DIRERR *  pErrInfo
    )
// Usually used with:
//#define  GetTHErrorDSID(pTHS)       GetErrInfoDSID(pTHS->errCode, pTHS->pErrInfo)
{
    Assert(errCode == 0 || pErrInfo != NULL);

    switch(errCode){
    case 0:
        return(0);
    case attributeError:
        // Just return the first attribute error info ...
        return(pErrInfo->AtrErr.FirstProblem.intprob.dsid);
    case nameError:
        return(pErrInfo->NamErr.dsid);
    case referralError:
        return(pErrInfo->RefErr.dsid);
    case securityError:
        return(pErrInfo->SecErr.dsid);
    case serviceError:
        return(pErrInfo->SvcErr.dsid);
    case updError:
        return(pErrInfo->UpdErr.dsid);
    case systemError:
        return(pErrInfo->SysErr.dsid);
    default:
        Assert(!"New error type someone update GetTHErrorDSID() and others ...");
        return(0);
    }
}


USHORT
GetErrInfoProblem(
    DWORD     errCode,
    DIRERR *  pErrInfo
    )
// Usually used with:
// #define  GetTHErrorProblem(pTHS)    GetErrInfoProblem(pTHS->errCode, pTHS->pErrInfo)
{
    switch ( errCode ) {
    case 0L:
        return(0);
    case attributeError:
        return(pErrInfo->AtrErr.FirstProblem.intprob.problem);
    case nameError:
        return(pErrInfo->NamErr.problem);
    case referralError:
        return(0);
    case securityError:
        return(pErrInfo->SecErr.problem);
    case serviceError:
        return(pErrInfo->SvcErr.problem);
    case updError:
        return(pErrInfo->UpdErr.problem);
    case systemError:
        return(pErrInfo->SysErr.problem);
    default:
        Assert(!"New error type someone update GetTHErrorDSID() and others ...");
        return(0);
    }
}




void __fastcall
INC_SEARCHES_BY_CALLERTYPE(
    CALLERTYPE  type
    )
{
    switch ( type ) {
        case CALLERTYPE_NONE:
            // CALLERTYPE_NONE happens legitimately only during install or boot.
            Assert(!gUpdatesEnabled || (!DsaIsRunning()));
            break;
        case CALLERTYPE_SAM:        PERFINC(pcSAMSearches);     break;
        case CALLERTYPE_DRA:        PERFINC(pcDRASearches);     break;
        case CALLERTYPE_LDAP:       PERFINC(pcLDAPSearches);    break;
        case CALLERTYPE_LSA:        PERFINC(pcLSASearches);     break;
        case CALLERTYPE_KCC:        PERFINC(pcKCCSearches);     break;
        case CALLERTYPE_NSPI:       PERFINC(pcNSPISearches);    break;
        case CALLERTYPE_INTERNAL:   PERFINC(pcOtherSearches);   break;
        case CALLERTYPE_NTDSAPI:   PERFINC(pcNTDSAPISearches);   break;
        default:
            // Trap new/unknown CALLERTYPEs.
            Assert(!"Unknown CALLERTYPE");
            break;
    }
}

void __fastcall
INC_READS_BY_CALLERTYPE(
    CALLERTYPE  type
    )
{
    switch ( type ) {
        case CALLERTYPE_NONE:
            // CALLERTYPE_NONE happens legitimately only during install or boot.
            Assert(!gUpdatesEnabled || (!DsaIsRunning()));
            break;
        case CALLERTYPE_SAM:        PERFINC(pcSAMReads);     break;
        case CALLERTYPE_DRA:        PERFINC(pcDRAReads);     break;
        case CALLERTYPE_LSA:        PERFINC(pcLSAReads);     break;
        case CALLERTYPE_KCC:        PERFINC(pcKCCReads);     break;
        case CALLERTYPE_NSPI:       PERFINC(pcNSPIReads);    break;
        case CALLERTYPE_LDAP:
        case CALLERTYPE_INTERNAL:   PERFINC(pcOtherReads);   break;
    case CALLERTYPE_NTDSAPI:   PERFINC(pcNTDSAPIReads);   break;
        default:
            // Trap new/unknown CALLERTYPEs.
            Assert(!"Unknown CALLERTYPE");
            break;
    }
}

void __fastcall
INC_WRITES_BY_CALLERTYPE(
    CALLERTYPE  type
    )
{
    switch ( type ) {
        case CALLERTYPE_NONE:
            // CALLERTYPE_NONE happens legitimately only during install or boot.
            Assert(!gUpdatesEnabled || (!DsaIsRunning()));
            break;
        case CALLERTYPE_SAM:        PERFINC(pcSAMWrites);     break;
        case CALLERTYPE_DRA:        PERFINC(pcDRAWrites);     break;
        case CALLERTYPE_LDAP:       PERFINC(pcLDAPWrites);    break;
        case CALLERTYPE_LSA:        PERFINC(pcLSAWrites);     break;
        case CALLERTYPE_KCC:        PERFINC(pcKCCWrites);     break;
        case CALLERTYPE_NSPI:       PERFINC(pcNSPIWrites);    break;
        case CALLERTYPE_INTERNAL:   PERFINC(pcOtherWrites);   break;
    case CALLERTYPE_NTDSAPI:    PERFINC(pcNTDSAPIWrites); break;
        default:
            // Trap new/unknown CALLERTYPEs.
            Assert(!"Unknown CALLERTYPE");
            break;
    }
}


DNT_HASH_ENTRY *
dntHashTableAllocate(
    THSTATE *pTHS
    )

/*++

Routine Description:

    Allocate a new hash table

Arguments:

    pTHS -

Return Value:

    DNT_HASH_ENTRY * -

--*/

{
    return THAllocEx(pTHS, DNT_HASH_TABLE_SIZE );
} /* dntHashTableAllocate */


BOOL
dntHashTablePresent(
    DNT_HASH_ENTRY *pDntHashTable,
    DWORD dnt,
    LPDWORD pdwData OPTIONAL
    )

/*++

Routine Description:

   Determine if a DNT is present in the table

Arguments:

    pDntHashTable -
    dnt -

Return Value:

    BOOL -

--*/

{
    DNT_HASH_ENTRY *pEntry;

    for ( pEntry = &pDntHashTable[ DNT_HASH( dnt ) ];
          NULL != pEntry;
          pEntry = pEntry->pNext
        )
    {
        if ( dnt == pEntry->dnt )
        {
            // Object is already present
            if (pdwData) {
                *pdwData = pEntry->dwData;
            }
            return TRUE;
        }
    }

    return FALSE;
} /* dntHashTablePresent */


VOID
dntHashTableInsert(
    THSTATE *pTHS,
    DNT_HASH_ENTRY *pDntHashTable,
    DWORD dnt,
    DWORD dwData
    )

/*++

Routine Description:

    Add a DNT to the table

Arguments:

    pTHS -
    pDntHashTable -
    dnt -

Return Value:

    None

--*/

{
    DNT_HASH_ENTRY *pEntry, *pNewEntry;

    pEntry = &pDntHashTable[ DNT_HASH( dnt ) ];

    if ( 0 == pEntry->dnt )
    {
        // First entry at each index is allocated for us and is empty;
        // use it.
        Assert( NULL == pEntry->pNext );
        pEntry->dnt = dnt;
        pEntry->dwData = dwData;
    }
    else
    {
        // Allocate new entry and wedge it between the first and second
        // (if any).
        pNewEntry = THAllocEx(pTHS, sizeof( *pNewEntry ) );
        pNewEntry->dnt = dnt;
        pNewEntry->dwData = dwData;
        pNewEntry->pNext = pEntry->pNext;
        pEntry->pNext = pNewEntry;
    }
} /* dntHashTableInsert */


VOID
DsUuidCreate(
    GUID *pGUID
    )

/*++

Routine Description:

    Create a uuid in the caller-supplied buffer. Caller is responsible
    for insuring the buffer is large enough.

Arguments:

    pGUID - filled in with a guid

Return Value:

    None.

--*/

{
    DWORD   dwErr;
    dwErr = UuidCreate(pGUID);
    if (dwErr) {
        LogUnhandledError(dwErr);
    }
} // DsUuidCreate


VOID
DsUuidToStringW(
    IN  GUID   *pGuid,
    OUT PWCHAR *ppszGuid
    )

/*++

Routine Description:

    Convert guid into a string

Arguments:

    pGuid - guid to convert
    ppszGuid - set to the address of the string'ized guid
               (free with RpcStringFreeW(ppszGuid)).

Return Value:

    ppszGuid is set to the address of a the sting'ized guid.
    Free with RpcStringFreeW(ppszGuid)).

--*/

{
    RPC_STATUS  rpcStatus;

    rpcStatus = UuidToStringW(pGuid, ppszGuid);
    if (RPC_S_OK != rpcStatus) {
        Assert(RPC_S_OUT_OF_MEMORY == rpcStatus);
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0,
                       DSID(FILENO, __LINE__),
                       DS_EVENT_SEV_MINIMAL);
    }
} // DsUuidToStringW


DWORD
GetBehaviorVersion(
    IN OUT  DBPOS       *pDB,
    IN      DSNAME      *dsObj,
    OUT     PDWORD      pdwBehavior)
/*++

Routine Description:

    Reads & return the behavior version of the given object

Arguments:

    pDB -- DB position to set (note side effect: moving currency)
    dsObj -- object to seek to.
    pdwBehavior -- returned value.


Return Value:
    ulErr - whether read attempt succeeded
    pdwBehavior is set only upon successful read

Remark:
    Note side effect: moving currency.
    If needed in the future we should expand this function to allow
    localized seek (i.e. open & use local dbpos).

--*/
{
    ULONG ulErr;

    Assert(pdwBehavior);

    *pdwBehavior = 0;

    // seek to object
    ulErr = DBFindDSName(pDB, dsObj);
    if (ulErr) {
        // not found
        return(ulErr);
    }

    // read it off & evaluate.
    ulErr = DBGetSingleValue(
                pDB,
                ATT_MS_DS_BEHAVIOR_VERSION,
                pdwBehavior,
                sizeof(DWORD),
                NULL);

    if (ulErr) {
        // convert to winerror space.
        ulErr = ERROR_DS_DRA_INTERNAL_ERROR;
    }
    return ulErr;
}



PDSNAME
GetConfigDsName(
    IN  PWCHAR  wszParam
    )
/*++

Routine Description:

    Reads the registry DS config section, allocates room for a DsName value
    & fills it in with the read value.

Arguments:

    wszParam -- Relative Config param name (such as ROOTDOMAINDNNAME_W)

Return Value:
    Success: The allocated (via THAllocEx) DSNAME value
    Error: NULL.

Remarks:
    Caller must THFree allocated returned value

--*/
{
    DWORD   dwErr;
    LPWSTR  pStr = NULL;
    DWORD   cbStr, len, size;
    PDSNAME pDsName = NULL;

    dwErr = GetConfigParamAllocW(
                wszParam,
                &pStr,
                &cbStr );

    if (!dwErr && pStr && cbStr) {
        // get sizes
        // len is in chars w/out terminating char.
        len = (cbStr / sizeof(WCHAR)) - 1;
        Assert( len == wcslen( pStr ) );
        size = DSNameSizeFromLen( len );
        // allocate & fill in
        pDsName = (DSNAME*) THAlloc( size );
        if (pDsName) {
            // mem is zero'ed out in THAlloc
            Assert( memcmp(&gNullUuid, &pDsName->Guid, sizeof(GUID)) == 0 );
            pDsName->structLen = size;
            pDsName->NameLen = len;
            wcscpy( pDsName->StringName, pStr );
        }
        // free tmp string
        free (pStr);
    }
    else {
        // trap for leaks.
        // debugger should optimize out for free builds.
        Assert(pStr == NULL);
    }

    return pDsName;
}

#ifdef USE_THALLOC_TRACE
// THAlloc, THReAlloc and THFree are defined as functions for external callers.
// undef macros for them
#undef THAlloc
#undef THReAlloc
#undef THFree
#endif

void * APIENTRY THAlloc(DWORD size)
{
    return THAllocAux(pTHStls, 
                      size, 
                      FALSE
#ifdef USE_THALLOC_TRACE
                      ,1
#endif                      
                      );
}

// The realloc function to go with the preceding alloc function
void * APIENTRY THReAlloc(void * memory, DWORD size)
{
    return THReAllocAux(pTHStls, 
                        memory, 
                        size, 
                        FALSE
#ifdef USE_THALLOC_TRACE
                        ,1
#endif                      
                        );
}

VOID THFree( VOID *buff )
{
#ifdef USE_THALLOC_TRACE
    THFreeEx_(pTHStls, buff, 1);
#else
    THFreeEx(pTHStls, buff);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\dbdump.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbdump.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the online dbdump utility.
*/



#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <filtypes.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "hiertab.h"
#include "sdprop.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "DBDUMP:"                // define the subsystem for debugging

// headers for DumpDatabase
#include <dsjet.h>
#include <dsutil.h>
#include <dbintrnl.h>
#include <sddl.h>

#include <fileno.h>
#define  FILENO FILENO_MDCTRL

#define MAX_BYTE_DIGITS 3
#define MAX_DWORD_DIGITS 10
#define MAX_LARGE_INTEGER_DIGITS 20

#define MAX_NUM_OCTETS_PRINTED 16

// Need space for a maximum line length of 1024 + some extra space for line returns
// and other stuff.
#define DBDUMP_BUFFER_LENGTH         (1024 + 8)
// Note DBDUMP_BUFFER_LENGTH must be gt (DUMP_MULTI_VALUES_LINE_LEN + 3)
#define DUMP_MULTI_VALUES_LINE_LEN  ((LONG) 80)

#define DUMP_ERR_SUCCESS             0
#define DUMP_ERR_FORMATTING_FAILURE  1
#define DUMP_ERR_NOT_ENOUGH_BUFFER   2

// NOTE: a line return is two characters in DOS world (i.e. notepad)!
#define FILE_LINE_RETURN             "\r\n"

// Special syntax for guids because none is assigned.
// Guids are a special subcase of octet strings with
// input length equal 16 bytes.
#define SYNTAX_LAST_TYPE SYNTAX_SID_TYPE
#define SYNTAX_GUID_TYPE (SYNTAX_LAST_TYPE + 1)
#define GUID_DISPLAY_SIZE 36


typedef struct {
    char*           columnName;
    int             columnSyntax;
    JET_COLUMNID*   pColumnID;
} FIXED_COLUMN_DEF;

FIXED_COLUMN_DEF FixedColumns[] = {
    {"DNT",     SYNTAX_DISTNAME_TYPE,   &dntid     },
    {"PDNT",    SYNTAX_DISTNAME_TYPE,   &pdntid    },
    {"CNT",     SYNTAX_INTEGER_TYPE,    &cntid     },
    {"NCDNT",   SYNTAX_DISTNAME_TYPE,   &ncdntid   },
    {"OBJ",     SYNTAX_BOOLEAN_TYPE,    &objid     },
    {"DelTime", SYNTAX_TIME_TYPE,       &deltimeid },
    {"CLEAN",   SYNTAX_BOOLEAN_TYPE,    &cleanid   },
    {"RDNTyp",  SYNTAX_OBJECT_ID_TYPE,  &rdntypid  },
    {"RDN",     SYNTAX_UNICODE_TYPE,    &rdnid     },
};

#define NUM_FIXED_COLUMNS ((int)(sizeof(FixedColumns)/sizeof(FixedColumns[0])))

FIXED_COLUMN_DEF LinkColumns[] = {
    {"DNT",         SYNTAX_DISTNAME_TYPE,       &linkdntid        },
    {"Base",        SYNTAX_INTEGER_TYPE,        &linkbaseid       },
    {"BDNT",        SYNTAX_DISTNAME_TYPE,       &backlinkdntid    },
    {"DelTime",     SYNTAX_TIME_TYPE,           &linkdeltimeid    },
    {"USNChanged",  SYNTAX_I8_TYPE,             &linkusnchangedid },
    {"NCDNT",       SYNTAX_DISTNAME_TYPE,       &linkncdntid      },
    {"Data",        SYNTAX_OCTET_STRING_TYPE,   &linkdataid       },
};

#define NUM_LINK_COLUMNS ((int)(sizeof(LinkColumns)/sizeof(LinkColumns[0])))

int DefaultSyntaxWidths[] = {
    5,  // SYNTAX_UNDEFINED_TYPE
    6,  // SYNTAX_DISTNAME_TYPE
    6,  // SYNTAX_OBJECT_ID_TYPE
    20, // SYNTAX_CASE_STRING_TYPE
    20, // SYNTAX_NOCASE_STRING_TYPE
    20, // SYNTAX_PRINT_CASE_STRING_TYPE
    20, // SYNTAX_NUMERIC_STRING_TYPE
    36, // SYNTAX_DISTNAME_BINARY_TYPE
    5,  // SYNTAX_BOOLEAN_TYPE
    6,  // SYNTAX_INTEGER_TYPE
    30, // SYNTAX_OCTET_STRING_TYPE
    19, // SYNTAX_TIME_TYPE
    20, // SYNTAX_UNICODE_TYPE
    6,  // SYNTAX_ADDRESS_TYPE
    26, // SYNTAX_DISTNAME_STRING_TYPE
    30, // SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE
    12, // SYNTAX_I8_TYPE
    30, // SYNTAX_SID_TYPE
    GUID_DISPLAY_SIZE  // SYNTAX_GUID_TYPE
    };

typedef DSTIME *PDSTIME;



BOOL
DumpErrorMessageS(
    IN HANDLE HDumpFile,
    IN char *Message,
    IN char *Argument
    )
/*++

Routine Description:

    This function prints an error message into the dump file.  It formats the
    message using wsprintf, passing Argument as an argument.  This message
    should containg 1 instance of "%s" since Argument is taken as a char*.
    The message and argument should be no longer than 4K bytes.

Arguments:

    HDumpFile - Supplies a handle to the dump file.

    Message - Supplies the message to be formatted with wsprintf.

    Argument - Supplies the argument to wsprintf.

Return Value:

    TRUE  - Success
    FALSE - Error

--*/
{

    char buffer[4096];
    DWORD delta;
    BOOL succeeded;
    DWORD bytesWritten;
    DWORD bufferLen;

    if ( strlen(Message) + strlen(Argument) + 1 > 4096 ) {
        return FALSE;
    }

    SetLastError(0);
    delta = wsprintf(buffer, Message, Argument);
    if ( (delta < strlen(Message)) && (GetLastError() != 0) ) {
        DPRINT1(0, "DumpErrorMessageS: failed to format error message "
                "(Windows Error %d)\n", GetLastError());
        LogUnhandledError(GetLastError());
        return FALSE;
    }

    bufferLen = strlen(buffer);

    succeeded = WriteFile(HDumpFile, buffer, bufferLen, &bytesWritten, NULL);
    if ( (!succeeded) || (bytesWritten < bufferLen) ) {
        DPRINT1(0,
                "DumpErrorMessageS: failed to write to file "
                "(Windows Error %d)\n",
                GetLastError());
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRMSG_DBDUMP_FAILURE,
                 szInsertSz("WriteFile"),
                 szInsertInt(GetLastError()),
                 szInsertWin32Msg(GetLastError()));
        return FALSE;
}

    return TRUE;

} // DumpErrorMessageS



BOOL
DumpErrorMessageD(
    IN HANDLE HDumpFile,
    IN char *Message,
    IN DWORD Argument
    )
/*++

Routine Description:

    This function prints an error message into the dump file.  It formats the
    message using wsprintf, passing Argument as an argument.  This message
    should contain 1 instance of "%d" since Argument is taken as an integer.
    The message and argument should be no longer than 4K bytes.

Arguments:

    HDumpFile - Supplies a handle to the dump file.

    Message - Supplies the message to be formatted with wsprintf.

    Argument - Supplies the argument to wsprintf.

Return Value:

    TRUE  - Success
    FALSE - Error

--*/
{

    char buffer[4096];
    DWORD delta;
    BOOL succeeded;
    DWORD bytesWritten;
    DWORD bufferLen;
    
    if ( strlen(Message) + MAX_DWORD_DIGITS + 1 > 4096 ) {
        return FALSE;
    }
    
    SetLastError(0);
    delta = wsprintf(buffer, Message, Argument);
    if ( (delta < strlen(Message)) && (GetLastError() != 0) ) {
        DPRINT1(0, "DumpErrorMessageI: failed to format error message "
                "(Windows Error %d)\n", GetLastError());
        LogUnhandledError(GetLastError());
        return FALSE;
    }

    bufferLen = strlen(buffer);

    succeeded = WriteFile(HDumpFile, buffer, bufferLen, &bytesWritten, NULL);
    if ( (!succeeded) || (bytesWritten < bufferLen) ) {
        DPRINT1(0,
                "DumpErrorMessageI: failed to write to file "
                "(Windows Error %d)\n",
                GetLastError());
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRMSG_DBDUMP_FAILURE,
                 szInsertSz("WriteFile"),
                 szInsertInt(GetLastError()),
                 NULL);
        return FALSE;
}

    return TRUE;

} // DumpErrorMessageD



BOOL
GetColumnNames(
    IN THSTATE *PTHS,
    IN OPARG *POpArg,
    OUT char ***ColumnNames,
    OUT int *NumColumns
    )
/*++

Routine Description:

    This function parses the OPARG structure given to get the names of the
    additional columns requested.  It produces an array containing the names
    of all columns that will be output into the dump file.

Arguments:

    PTHS - pointer to thread state

    POpArg - Supplies the OPARG structure containing the request to parse.
    
    ColumnNames - Returns an array containing the column names.
    
    NumColumns - Returns the number of columns.

Return Value:

    TRUE   -  Success
    FALSE  -  Error

--*/
{

    DWORD current;
    DWORD nameStart;
    DWORD currentColumn;
    int numAdditionalColumns;
    enum {
        STATE_IN_WHITESPACE,
        STATE_IN_WORD
        } currentState;
            
    current = 0;

    // Make a quick pass through and count how many additional names have
    // been given.

    for ( currentState = STATE_IN_WHITESPACE,
              numAdditionalColumns = 0,
              current = 0;
          current < POpArg->cbBuf;
          current++ ) {

        if ( isspace(POpArg->pBuf[current]) ) {

            if ( currentState == STATE_IN_WORD ) {
                currentState = STATE_IN_WHITESPACE;
            }
            
        } else {

            if ( currentState == STATE_IN_WHITESPACE ) {
                currentState = STATE_IN_WORD;
                numAdditionalColumns++;
            }

        }
        
    }

    (*ColumnNames) = (char**) THAllocEx(PTHS, sizeof(char*) * 
                                        (numAdditionalColumns +
                                         NUM_FIXED_COLUMNS));

    // Copy in the fixed column names.

    for ( (*NumColumns) = 0;
          (*NumColumns) < NUM_FIXED_COLUMNS;
          (*NumColumns)++ ) {
        (*ColumnNames)[(*NumColumns)] = FixedColumns[(*NumColumns)].columnName;
    }
    
    // Now, get the actual names.
    
    current = 0;

    for (;;) {

        // skip leading whitespace
        while ( (current < POpArg->cbBuf) &&
                (isspace(POpArg->pBuf[current])) ) {
            current++;
        }
        
        if ( current == POpArg->cbBuf ) {
            break;
        } 

        // this is the start of an actual name
        
        nameStart = current;

        while ( (!isspace(POpArg->pBuf[current])) &&
                (current < POpArg->cbBuf) ) {
            current++;
        }

        // we've found the end of the name, so copy it into the array of
        // names

        Assert((*NumColumns) < numAdditionalColumns + NUM_FIXED_COLUMNS);
        
        (*ColumnNames)[(*NumColumns)] = 
            (char*) THAllocEx(PTHS, current - nameStart + 1);

        memcpy((*ColumnNames)[(*NumColumns)],
               &POpArg->pBuf[nameStart],
               current - nameStart);
        
        (*ColumnNames)[(*NumColumns)][current - nameStart] = '\0';

        (*NumColumns)++;

    }

    Assert((*NumColumns) == numAdditionalColumns + NUM_FIXED_COLUMNS);
    
    return TRUE;

} // GetColumnNames


BOOL
GetLinkColumnNames(
    IN THSTATE *PTHS,
    OUT char ***ColumnNames,
    OUT int *NumColumns
    )
/*++

Routine Description:

    It produces an array containing the names
    of all columns that will be output into the dump file.

Arguments:

    PTHS - pointer to thread state

    ColumnNames - Returns an array containing the column names.
    
    NumColumns - Returns the number of columns.

Return Value:

    TRUE   -  Success
    FALSE  -  Error

--*/
{

    (*ColumnNames) = (char**) THAllocEx(PTHS, sizeof(char*) * NUM_LINK_COLUMNS);

    // Copy in the fixed column names.

    for ( (*NumColumns) = 0;
          (*NumColumns) < NUM_LINK_COLUMNS;
          (*NumColumns)++ ) {
        (*ColumnNames)[(*NumColumns)] = LinkColumns[(*NumColumns)].columnName;
    }
    
    Assert((*NumColumns) == NUM_LINK_COLUMNS);
    
    return TRUE;

} // GetLinkColumnNames



BOOL
GetFixedColumnInfo(
        IN THSTATE *PTHS,
        OUT JET_RETRIEVECOLUMN *ColumnVals,
        OUT int *ColumnSyntaxes
    )
/*++

Routine Description:

    This function fills in the JET_RETRIEVECOLUMN structures and column
    syntaxes for the fixed columns in the database.  

    Should it happen that one of the fixed columns is not found then the
    corresponding entry in ColumnVals will have its error code set.  This
    will cause other procedures to then ignore it.
    
Arguments:

    PTHS - pointer to thread state

    ColumnVals - Returns the JET_RETRIEVECOLUMN structures which are suitable
                 to be passed to JetRetrieveColumns

    ColumnSyntaxes - Returns the syntax types of the fixed columns in the
                     database.

Return Value:

    TRUE   -  Success
    FALSE  -  Error

--*/
{
    
    int i;

    for ( i = 0; i < NUM_FIXED_COLUMNS; i++ ) {
        ColumnVals[i].columnid = *(FixedColumns[i].pColumnID);
        ColumnVals[i].itagSequence = 1;
        ColumnSyntaxes[i] = FixedColumns[i].columnSyntax;
        
        switch ( ColumnSyntaxes[i] ) {

            /* Unsigned Byte */
        case SYNTAX_UNDEFINED_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(BYTE));
            ColumnVals[i].cbData = sizeof(BYTE);
            break;

            /* Long */
        case SYNTAX_DISTNAME_TYPE:
        case SYNTAX_OBJECT_ID_TYPE:
        case SYNTAX_BOOLEAN_TYPE:
        case SYNTAX_INTEGER_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(DWORD));
            ColumnVals[i].cbData = sizeof(DWORD);
            break;


            /* Text */
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_ADDRESS_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, 255);
            ColumnVals[i].cbData = 255;
            break;

            /* Currency */
        case SYNTAX_TIME_TYPE:
        case SYNTAX_I8_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(LARGE_INTEGER));
            ColumnVals[i].cbData = sizeof(LARGE_INTEGER);
            break;
            
            /* Long Text */
            /* Long Binary */
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_UNICODE_TYPE:
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_DISTNAME_STRING_TYPE:
        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        case SYNTAX_SID_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, 4096);
            ColumnVals[i].cbData = 4096;
            break;

        default:
            // this should never happen
            Assert(FALSE);
            DPRINT1(0,"GetFixedColumnInfo: encountered undefined syntax %d\n",
                    ColumnSyntaxes[i]);
            LogUnhandledError(GetLastError());
            return FALSE;

        }

    }

    return TRUE;
        
} // GetFixedColumnInfo


BOOL
GetLinkColumnInfo(
    IN THSTATE *PTHS,
    OUT JET_RETRIEVECOLUMN *ColumnVals,
    OUT int *ColumnSyntaxes
    )
/*++

Routine Description:

    This function fills in the JET_RETRIEVECOLUMN structures and column
    syntaxes for the fixed columns in the database.  

    Should it happen that one of the fixed columns is not found then the
    corresponding entry in ColumnVals will have its error code set.  This
    will cause other procedures to then ignore it.
    
Arguments:

    PTHS - pointer to thread state

    ColumnVals - Returns the JET_RETRIEVECOLUMN structures which are suitable
                 to be passed to JetRetrieveColumns

    ColumnSyntaxes - Returns the syntax types of the fixed columns in the
                     database.

Return Value:

    TRUE   -  Success
    FALSE  -  Error

--*/
{
    
    int i;

    for ( i = 0; i < NUM_LINK_COLUMNS; i++ ) {
        ColumnVals[i].columnid = *(LinkColumns[i].pColumnID);

        ColumnVals[i].itagSequence = 1;

        ColumnSyntaxes[i] = LinkColumns[i].columnSyntax;
        
        switch ( ColumnSyntaxes[i] ) {

            /* Unsigned Byte */
        case SYNTAX_UNDEFINED_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(BYTE));
            ColumnVals[i].cbData = sizeof(BYTE);
            break;

            /* Long */
        case SYNTAX_DISTNAME_TYPE:
        case SYNTAX_OBJECT_ID_TYPE:
        case SYNTAX_BOOLEAN_TYPE:
        case SYNTAX_INTEGER_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(DWORD));
            ColumnVals[i].cbData = sizeof(DWORD);
            break;


            /* Text */
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_ADDRESS_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, 255);
            ColumnVals[i].cbData = 255;
            break;

            /* Currency */
        case SYNTAX_TIME_TYPE:
        case SYNTAX_I8_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(LARGE_INTEGER));
            ColumnVals[i].cbData = sizeof(LARGE_INTEGER);
            break;
            
            /* Long Text */
            /* Long Binary */
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_UNICODE_TYPE:
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_DISTNAME_STRING_TYPE:
        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        case SYNTAX_SID_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, 4096);
            ColumnVals[i].cbData = 4096;
            break;

        default:
            // this should never happen
            Assert(FALSE);
            DPRINT1(0,"GetLinkColumnInfo: encountered undefined syntax %d\n",
                    ColumnSyntaxes[i]);
            LogUnhandledError(GetLastError());
            return FALSE;

        }

    }

    return TRUE;
        
} // GetFixedColumnInfo



BOOL
GetColumnInfoByName(
    IN DBPOS *PDB, 
    IN THSTATE *PTHS,
    IN HANDLE HDumpFile,
    IN char **ColumnNames,
    OUT JET_RETRIEVECOLUMN *ColumnVals,
    OUT int *ColumnSyntaxes,
    IN int NumColumns
    )    
/*++

Routine Description:

    This function generates an array of JET_RETRIEVECOLUMN structures suitable
    to be passed to JetRetrieveColumns by filling in the entries for the
    columns requested by the user.  ColumnSyntaxes is also filled in.

    If a name is not found, then the corresponding entry in ColumnVals
    will have it's error code set.

Arguments:

    PDB - Supplies handles into the database in question.
    
    PTHS - Suppplies the thread state.

    HDumpFile - Supplies a handle of the dump file.

    ColumnNames - Supplies the array containing a list of the names of the
        columns required.
                  
    ColumnVals - Returns the array of JET_RETRIEVECOLUMN structures
    
    ColumnSyntaxes - Returns the array of column syntaxes.

    NumColumns - Supplies the number of entries in the ColumnNames array.
    
Return Value:

    TRUE - both arrays were generated successfully
    FALSE - the generation failed

--*/
{
    
    JET_COLUMNDEF columnInfo;
    ATTCACHE *attCacheEntry;
    JET_ERR error;
    int i;
    BOOL invalidColumnName = FALSE;

    // the first NUM_FIXED_COLUMNS entries are filled used by the fixed
    // columns
    
    for ( i = NUM_FIXED_COLUMNS; i < NumColumns; i++) {
        
        attCacheEntry = SCGetAttByName(PTHS,
                                       strlen(ColumnNames[i]),
                                       ColumnNames[i]);

        // We can't dump atts that don't exist, and shouldn't dump ones
        // that we regard as secret.
        if (   (attCacheEntry == NULL)
            || (DBIsHiddenData(attCacheEntry->id))) {
            DumpErrorMessageS(HDumpFile, "Error: attribute %s was not found\n",
                              ColumnNames[i]);
            DPRINT1(0, "GetColumnInfoByName: attribute %s was not found in "
                    "the schema cache\n", ColumnNames[i]);
            invalidColumnName = TRUE;
            continue;
        }
        
        ColumnSyntaxes[i] = attCacheEntry->syntax;

        // Override syntax for guid
        if ( (strstr( ColumnNames[i], "guid" ) != NULL) ||
             (strstr( ColumnNames[i], "GUID" ) != NULL) ||
             (strstr( ColumnNames[i], "Guid" ) != NULL) ) {
            ColumnSyntaxes[i] = SYNTAX_GUID_TYPE;
        }

        ColumnVals[i].columnid = attCacheEntry->jColid;
        ColumnVals[i].itagSequence = 1;

        switch ( attCacheEntry->syntax ) {

            /* Unsigned Byte */
        case SYNTAX_UNDEFINED_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(BYTE));
            ColumnVals[i].cbData = sizeof(BYTE);
            break;

            /* Long */
        case SYNTAX_DISTNAME_TYPE:
        case SYNTAX_OBJECT_ID_TYPE:
        case SYNTAX_BOOLEAN_TYPE:
        case SYNTAX_INTEGER_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(DWORD));
            ColumnVals[i].cbData = sizeof(DWORD);
            break;


            /* Text */
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_ADDRESS_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, 255);
            ColumnVals[i].cbData = 255;
            break;

            /* Currency */
        case SYNTAX_TIME_TYPE:
        case SYNTAX_I8_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(LARGE_INTEGER));
            ColumnVals[i].cbData = sizeof(LARGE_INTEGER);
            break;
            
            /* Long Text */
            /* Long Binary */
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_UNICODE_TYPE:
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_DISTNAME_STRING_TYPE:
        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        case SYNTAX_SID_TYPE:
            
            // If it has an upper limit on the number of bytes, use that.
            // Otherwise, just allocate some arbitrarily large amount.
            
            if ( attCacheEntry->rangeUpperPresent ) {
                
                ColumnVals[i].pvData = THAllocEx(PTHS,
                    attCacheEntry->rangeUpper);
                ColumnVals[i].cbData =
                    attCacheEntry->rangeUpper;
                
            } else {

                ColumnVals[i].pvData = THAllocEx(PTHS, 4096);
                ColumnVals[i].cbData = 4096;
            
            }
            break;

            /* Guid */
        case SYNTAX_GUID_TYPE:
            ColumnVals[i].pvData = THAllocEx(PTHS, sizeof(GUID));
            ColumnVals[i].cbData = sizeof(GUID);
            break;

        default:
            // this should never happen
            Assert(FALSE);
            DPRINT1(0, "GetColumnInfoByName: encountered invalid syntax %d\n",
                    attCacheEntry->syntax);
            LogUnhandledError(GetLastError());
            return FALSE;

        }

    }

    return !invalidColumnName;
    
} // GetColumnInfoByName


VOID
GrowRetrievalArray(
    IN THSTATE *PTHS,
    IN OUT JET_RETRIEVECOLUMN *ColumnVals,
    IN DWORD NumColumns
    )
/*++

Routine Description:

    This function goes through the given JET_RETRIEVECOLUMN array and grows the
    buffer for any entry whose err is set to JET_wrnColumnTruncated.  This
    function is called after an attempt to retrieve columns failed because a
    buffer was too small.

Arguments:

    PTHS - Supplies the thread state.

    ColumnVals - Supplies the retrieval array in which to grow the necessary
                 buffers.
        
    NumColumns - Supplies the number of entries in the ColumnVals array.

Return Value:

    None

--*/
{

    DWORD i;
    
    for ( i = 0; i < NumColumns; i++ ) {

        if ( ColumnVals[i].err == JET_wrnBufferTruncated ) {

            ColumnVals[i].cbData *= 2;
            ColumnVals[i].pvData = THReAllocEx(PTHS,
                                               ColumnVals[i].pvData,
                                               ColumnVals[i].cbData);
            
        }
        
    }
    
} // GrowRetrievalArray



BOOL
DumpHeader(
    IN THSTATE *PTHS,
    IN HANDLE HDumpFile,
    IN char **ColumnNames,
    IN JET_RETRIEVECOLUMN *ColumnVals,
    IN int *ColumnSyntaxes,
    IN int NumColumns,
    IN PCHAR Prefix
    )
/*++

Routine Description:

    This function dumps the header into the dump file.  This header displays
    the names of the columns which are to be dumped from the database
    records.

Arguments:

    PTHS - pointer to thread state

    HDumpFile - Supplies a handle to the file to dump into.

    ColumnNames - Supplies an array containing the names of the fixed
        columns that are always dumped.
    
    ColumnVals - Supplies other information about the columns
    
    ColumnSyntaxes - Supplies an array containing the syntaxes of the columns
        to be dumped.
                     
    NumColumns - Supplies the number of columns in the two arrays.

Return Value:

    TRUE - the dumping was successful
    FALSE - the dumping failed

--*/
{

    int i, j;
    DWORD nameLength;
    DWORD bytesWritten;
    BOOL result;
    int *currentPos;
    BOOL done;

    currentPos = (int*) THAllocEx(PTHS, NumColumns * sizeof(int));
    ZeroMemory(currentPos, NumColumns * sizeof(int));
    
    for (;;) {

        done = TRUE;

        // Write prefix first.
        WriteFile(HDumpFile,
                  Prefix,
                  strlen(Prefix),
                  &bytesWritten,
                  NULL);

        for ( i = 0; i < NumColumns; i++ ) {

            if ( ColumnNames[i][currentPos[i]] != '\0' ) {
                done = FALSE;
            }

            nameLength = strlen(&ColumnNames[i][currentPos[i]]);

            if ( nameLength > (DWORD)DefaultSyntaxWidths[ColumnSyntaxes[i]] ) {

                result = WriteFile(HDumpFile,
                                   &ColumnNames[i][currentPos[i]],
                                   DefaultSyntaxWidths[ColumnSyntaxes[i]] - 1,
                                   &bytesWritten,
                                   NULL);
                if ( (result == FALSE) ||
                     (bytesWritten <
                        (DWORD)DefaultSyntaxWidths[ColumnSyntaxes[i]] - 1) ){
                    goto error;
                }

                currentPos[i] += DefaultSyntaxWidths[ColumnSyntaxes[i]] - 1;

                result = WriteFile(HDumpFile,
                                   "-",
                                   1,
                                   &bytesWritten,
                                   NULL);
                if ( (result == FALSE) || (bytesWritten < 1) ) {
                    goto error;
                }

            } else {

                result = WriteFile(HDumpFile,
                                   &ColumnNames[i][currentPos[i]],
                                   nameLength,
                                   &bytesWritten,
                                   NULL);
                if ( (result == FALSE) || (bytesWritten < nameLength) ) {
                    goto error;
                }

                currentPos[i] += nameLength;

                for ( j = 0;
                      j < DefaultSyntaxWidths[ColumnSyntaxes[i]] -
                            (int)nameLength;
                      j++ ) {

                    result = WriteFile(HDumpFile,
                                       " ",
                                       1,
                                       &bytesWritten,
                                       NULL);
                    if ( (result == FALSE) || (bytesWritten < 1) ) {
                        goto error;
                    }

                }
                
            }

            if ( i != NumColumns - 1 ) {
                
                result = WriteFile(HDumpFile,
                                   " ",
                                   1,
                                   &bytesWritten,
                                   NULL);
                if ( (result == FALSE) || (bytesWritten < 1) ) {
                    goto error;
                }

            }

        }

        // NOTE: a line return is two characters in DOS world (i.e. notepad)!
        result = WriteFile(HDumpFile, FILE_LINE_RETURN, 
                           strlen(FILE_LINE_RETURN), &bytesWritten, NULL);
        if ( (result == FALSE) || (bytesWritten < 1) ) {
            goto error;
        }

        if ( done ) {
            break;
        }

    }

    THFreeEx(PTHS, currentPos);
    
    return TRUE;

error:

    DPRINT1(0, "DumpHeader: failed to write to file (Windows Error %d)\n",
            GetLastError());
                    
    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_ALWAYS,
             DIRMSG_DBDUMP_FAILURE,
             szInsertSz("WriteFile"),
             szInsertInt(GetLastError()),
             NULL);
            
    THFreeEx(PTHS, currentPos);

    return FALSE;

} // DumpHeader



DWORD
DumpSeparator(
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes a separator character into the given output buffer.
    The parameter Position specifies where in the InputBuffer to start
    writing and it is incremented by the number of bytes written

Arguments:

    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    if ( OutputBufferSize - (*Position) < 1 ) {
        DPRINT(2, "DumpSeparator: not enough buffer to separator\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }

    // we probably want to print out a different character than the one use
    // to indicate a null value, so I'll use a ':' character

    OutputBuffer[(*Position)] = ':';
    
    (*Position) += 1;

    return DUMP_ERR_SUCCESS;

} // DumpSeparator


DWORD
DumpStr(
    OUT PCHAR OutputBuffer,
    IN PCHAR Input,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function simply pushes the input string onto the Buffer returning
    DUMP_ERR_NOT_ENOUGH_BUFFER if necessary.

Arguments:

    OutputBuffer - Supplies the buffer in which to place the formatted output.
    Input - The string to put in the buffer
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{
    int  cSize;

    cSize = strlen(Input);

    if ( OutputBufferSize - (*Position) < (cSize + 1) ) {
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }

    memcpy(&OutputBuffer[(*Position)], Input, cSize);
    (*Position) += cSize;

    return DUMP_ERR_SUCCESS;

} // DumpString



DWORD
DumpNull(
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes a character to the given output buffer which
    indicates the fact that an attribute was null valued.  The parameter
    Position specifies where in the InputBuffer to start writing and it is
    incremented by the number of bytes written

Arguments:

    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    if ( OutputBufferSize - (*Position) < 1 ) {
        DPRINT(2, "DumpNull: not enough buffer to null value\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    OutputBuffer[(*Position)] = '-';
    
    (*Position) += 1;

    return DUMP_ERR_SUCCESS;

} // DumpNull



DWORD
DumpUnsignedChar(
    IN PBYTE InputBuffer,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    int delta;

    if ( OutputBufferSize - (*Position) < MAX_BYTE_DIGITS + 1 ) {
        DPRINT(2, "DumpUnsignedChar: not enough space in buffer to encode "
               "unsigned char\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    SetLastError(0);
    delta = wsprintf(&OutputBuffer[(*Position)],
                     "%u",
                     *InputBuffer);
    if ( (delta < 2) && (GetLastError() != 0) ) {
        DPRINT1(0, "DumpUnsignedChar: failed to format undefined output "
                "(Windows Error %d)\n",
                GetLastError());
        return DUMP_ERR_FORMATTING_FAILURE;
    }

    (*Position) += delta;

    return DUMP_ERR_SUCCESS;
                
} // DumpUnsignedChar



DWORD
DumpBoolean(
    IN PBOOL InputBuffer,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    if ( OutputBufferSize - (*Position) < 5 ) {
        DPRINT(2, "DumpBoolean: not enough space in buffer to encode "
               "boolean\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    if ( *InputBuffer == FALSE ) {
        memcpy(&OutputBuffer[(*Position)], "false", 5);
        (*Position) += 5;
    } else {
        memcpy(&OutputBuffer[(*Position)], "true", 4);
        (*Position) += 4;
    }

    return DUMP_ERR_SUCCESS;

} // DumpBoolean



DWORD
DumpInteger(
    IN PDWORD InputBuffer,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    int delta;

    if ( OutputBufferSize - (*Position) < MAX_DWORD_DIGITS + 2 ) {
        DPRINT(2, "DumpInteger: not enough space in buffer to encode "
               "integer\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    SetLastError(0);
    delta = wsprintf(&OutputBuffer[(*Position)],
                     "%i",
                     (int)*InputBuffer);
    if ( (delta < 2) && (GetLastError() != 0) ) {
        DPRINT1(0,
                "DumpInteger: failed to format integer output "
                "(Windows Error %d)\n",
                GetLastError());
        return DUMP_ERR_FORMATTING_FAILURE;
    }

    (*Position) += delta;

    return DUMP_ERR_SUCCESS;

} // DumpInteger



DWORD
DumpUnsignedInteger(
    IN PDWORD InputBuffer,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    int delta;

    if ( OutputBufferSize - (*Position) < MAX_DWORD_DIGITS + 1) {
        DPRINT(2, "DumpUnsignedInteger: not enough space in buffer to encode "
               "unsigned integer\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    SetLastError(0);
    delta = wsprintf(&OutputBuffer[(*Position)],
                     "%u",
                     (unsigned)*InputBuffer);
    if ( (delta < 2) && (GetLastError() != 0) ) {
        DPRINT1(0, "DumpUnsignedInteger: failed to format unsigned integer "
                "output (Windows Error %d)\n", GetLastError());
        return DUMP_ERR_FORMATTING_FAILURE;
    }

    (*Position) += delta;

    return DUMP_ERR_SUCCESS;

} // DumpUnsignedInteger



DWORD
DumpLargeInteger(
    IN PLARGE_INTEGER InputBuffer,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    int delta;

    if ( OutputBufferSize - (*Position) < MAX_LARGE_INTEGER_DIGITS + 1) {
        DPRINT(2, "DumpLargeInteger: not enough space in buffer to encode "
               "large integer\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    litoa(*InputBuffer, &OutputBuffer[(*Position)], 10);
    
    for ( delta = 0;
          OutputBuffer[(*Position) + delta] != '\0';
          delta++ );
                
    (*Position) += delta;

    return DUMP_ERR_SUCCESS;

} // DumpLargeInteger



DWORD
DumpString(
    IN PUCHAR InputBuffer,
    IN int InputBufferSize,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    InputBufferSize -  Supplies the number of bytes in the input buffer.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    if ( OutputBufferSize - (*Position) < InputBufferSize ) {
        DPRINT(2, "DumpString: not enough space in buffer to encode string\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }

    memcpy(&OutputBuffer[(*Position)], InputBuffer, InputBufferSize);
    
    (*Position) += InputBufferSize;

    return DUMP_ERR_SUCCESS;
                
} // DumpString



DWORD
DumpOctetString(
    IN PBYTE InputBuffer,
    IN int InputBufferSize,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    InputBufferSize -  Supplies the number of bytes in the input buffer.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    int delta;
    int i;
    
    if ( ((InputBufferSize < MAX_NUM_OCTETS_PRINTED) &&
          (OutputBufferSize - (*Position) < InputBufferSize * 3)) ||
         ((InputBufferSize >= MAX_NUM_OCTETS_PRINTED) &&
          (OutputBufferSize - (*Position) < MAX_NUM_OCTETS_PRINTED * 3)) ) {
        DPRINT(2, "DumpOctetString: not enough space in buffer to encode "
               "octet string\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }

    if ( InputBufferSize <= 0 ) {
        return DUMP_ERR_SUCCESS;
    }
    
    SetLastError(0);
    delta = wsprintf(&OutputBuffer[(*Position)],
                     "%02X",
                     InputBuffer[0]);
    if ( (delta < 4) && (GetLastError() != 0) ) {
        DPRINT1(0,
                "DumpOctetString: failed to format octet string output "
                "(Windows Error %d)\n",
                GetLastError());
        return DUMP_ERR_FORMATTING_FAILURE;
    }

    (*Position) += delta;

    // don't print out all of this thing if it is too large.  we'll have an
    // arbitrary limit of MAX_NUM_OCTETS_PRINTED octets.
    for ( i = 1;
          (i < InputBufferSize) && (i < MAX_NUM_OCTETS_PRINTED);
          i++ ) {
        SetLastError(0);
        delta = wsprintf(&OutputBuffer[(*Position)],
                          ".%02X",
                          InputBuffer[i]);
        if ( (delta < 5) && (GetLastError() != 0) ) {
            DPRINT1(0,
                    "DumpOctetString: failed to format octet string "
                    "output (Windows Error %d)\n",
                    GetLastError());
            return DUMP_ERR_FORMATTING_FAILURE;
        }

        (*Position) += delta;
    }

    // if we stopped short of printing the whole octet string, print a "..."
    // to indicate that some of the octet string is missing
    if ( i < InputBufferSize ) {

        if ( OutputBufferSize - (*Position) < 3 ) {
            DPRINT(2, "DumpOctetString: not enough space in buffer to encode "
                   "octet string\n");
            return DUMP_ERR_NOT_ENOUGH_BUFFER;
        }
    
        memcpy(&OutputBuffer[(*Position)], "...", 3);
        
        (*Position) += 3;

    }
                
    return DUMP_ERR_SUCCESS;
                
} // DumpOctetString



DWORD
DumpUnicodeString(
    IN PUCHAR InputBuffer,
    IN int InputBufferSize,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    InputBufferSize -  Supplies the number of bytes in the input buffer.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    int delta;
    
    delta = WideCharToMultiByte(CP_UTF8,
                                0,
                                (LPCWSTR)InputBuffer,
                                InputBufferSize / 2,
                                &OutputBuffer[(*Position)],
                                OutputBufferSize,
                                NULL,
                                NULL);
    if ( delta == 0 ) {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
            DPRINT(2, "DumpUnicodeString: not enough space in buffer to "
                   "encode unicode string\n");
            return DUMP_ERR_NOT_ENOUGH_BUFFER;
        } else {
            DPRINT1(0,
                    "DumpUnicodeString: failed to convert unicode string "
                    "to UTF8 (Windows Error %d)\n",
                    GetLastError());
            return DUMP_ERR_FORMATTING_FAILURE;
        }
    }

    (*Position) += delta;

    return DUMP_ERR_SUCCESS;
                
} // DumpUnicodeString



DWORD
DumpTime(
    IN PDSTIME InputBuffer,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    int delta;

    if ( OutputBufferSize - (*Position) < SZDSTIME_LEN ) {
        DPRINT(2, "DumpTime: not enough space in buffer to encode time\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    DSTimeToDisplayStringCch(*InputBuffer, &OutputBuffer[(*Position)], OutputBufferSize - *Position);
    
    for ( delta = 0;
          OutputBuffer[(*Position) + delta] != '\0';
          delta++ );
                
    (*Position) += delta;
    
    return DUMP_ERR_SUCCESS;

} // DumpTime



DWORD
DumpSid(
    IN PSID InputBuffer,
    IN int InputBufferSize,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

    This code was stolen (almost) directly from dbdump.c.
    
Arguments:

    InputBuffer - Supplies the data to be formatted.
    InputBufferSize -  Supplies the number of bytes in the input buffer.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{

    NTSTATUS result;
    WCHAR UnicodeSidText[256];
    CHAR AnsiSidText[256];
    UNICODE_STRING us;
    ANSI_STRING as;

    UnicodeSidText[0] = L'\0';
    us.Length = 0;
    us.MaximumLength = sizeof(UnicodeSidText);
    us.Buffer = UnicodeSidText;
    
    InPlaceSwapSid(InputBuffer);
    
    result = RtlConvertSidToUnicodeString(&us, InputBuffer, FALSE);
    if ( result != STATUS_SUCCESS ) {
        DPRINT(0, "DumpSid: failed to convert SID to unicode string\n");
        return DUMP_ERR_FORMATTING_FAILURE;
    }

    as.Length = 0;
    as.MaximumLength = sizeof(AnsiSidText);
    as.Buffer = AnsiSidText;
    
    result = RtlUnicodeStringToAnsiString(&as, &us, FALSE);
    if ( result != STATUS_SUCCESS ) {
        DPRINT(0, "DumpSid: failed to convert unicode string to ansi "
               "string\n");
        return DUMP_ERR_FORMATTING_FAILURE;
    }

    if ( OutputBufferSize - (*Position) < as.Length ) {
        DPRINT(2, "DumpSid: not enough space in buffer to encode SID\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }

    memcpy(&OutputBuffer[(*Position)], as.Buffer, as.Length);
    
    (*Position) += as.Length;
    
    return DUMP_ERR_SUCCESS;
    
} // DumpSid


DWORD
DumpGuid(
    IN GUID * InputBuffer,
    OUT PCHAR OutputBuffer,
    IN int OutputBufferSize,
    IN OUT int *Position
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  The parameter Position specifies where in the InputBuffer to
    start writing and it is incremented by the number of bytes written.

Arguments:

    InputBuffer - Supplies the data to be formatted.
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    Position - Supplies the position in OutputBuffer to start writing and
        returns the position at which writing stopped.

Return Value:

   DUMP_ERR_SUCCESS
   DUMP_ERR_FORMATTING_FAILURE
   DUMP_ERR_NOT_ENOUGH_BUFFER

--*/
{
    int delta;

    if ( OutputBufferSize - (*Position) < GUID_DISPLAY_SIZE ) {
        DPRINT(2, "DumpGuid: not enough space in buffer to encode GUID\n");
        return DUMP_ERR_NOT_ENOUGH_BUFFER;
    }
    
    DsUuidToStructuredStringCch( InputBuffer, &OutputBuffer[(*Position)], OutputBufferSize - *Position);
    
    for ( delta = 0;
          OutputBuffer[(*Position) + delta] != '\0';
          delta++ );

    Assert(delta == GUID_DISPLAY_SIZE);                
    (*Position) += delta;
    
    return DUMP_ERR_SUCCESS;

} // DumpGuid


BOOL
DumpColumn(
    IN      int    eValueSyntax,
    IN      void * pvData,
    IN      int    cbData,
    IN      int    cbActual,
    OUT     PCHAR  OutputBuffer,
    IN      int    OutputBufferSize,
    IN OUT  int *  piDelta
    )
/*++

Routine Description:

    This function writes the contents of InputBuffer in a formatted
    fashion.  piDelta indicates how much as changed.

Arguments:

    pvData - Supplies the data to be formatted.
    cbData - Size of data's buffer
    cbActual - As returned by the Jet* API
    OutputBuffer - Supplies the buffer in which to place the formatted output.
    OutputBufferSize - Supplies the number of bytes in the output buffer.
    piDelta - The change in bytes written to the buffer.

Return Value:

   DUMP_ERR_*

   // ISSUE-2002/05/12-BrettSh someone should investigate the useage of
   // cbData in this function.  For example see other ISSUE markers with
   // the same data-alias to see what I mean

--*/
{
    DWORD    result = DUMP_ERR_FORMATTING_FAILURE;

    Assert(*piDelta == 0);

    switch ( eValueSyntax ) {

    case SYNTAX_UNDEFINED_TYPE:

        result = DumpUnsignedChar(pvData,
                                  OutputBuffer,
                                  OutputBufferSize,
                                  piDelta);
        break;

    case SYNTAX_DISTNAME_TYPE:
    case SYNTAX_OBJECT_ID_TYPE:
    case SYNTAX_ADDRESS_TYPE:
        result = DumpUnsignedInteger(pvData,
                                     OutputBuffer,
                                     OutputBufferSize,
                                     piDelta);
        break;

    case SYNTAX_CASE_STRING_TYPE:
    case SYNTAX_NOCASE_STRING_TYPE:
    case SYNTAX_PRINT_CASE_STRING_TYPE:
    case SYNTAX_NUMERIC_STRING_TYPE:
        result = DumpString(pvData,
                            cbActual,
                            OutputBuffer,
                            OutputBufferSize,
                            piDelta);
        break;

    case SYNTAX_DISTNAME_BINARY_TYPE:
        result = DumpUnsignedInteger(pvData,
                                     OutputBuffer,
                                     OutputBufferSize,
                                     piDelta);
        if ( result ) {
            result = DumpSeparator(OutputBuffer,
                                   OutputBufferSize,
                                   piDelta);

            if ( result ) {
                // ISSUE-2002/05/12-BrettSh Seems like to me that cbData - 4
                // should be cbActual.  Someone with a understanding of this
                // code should decide if this is the case, and make this change.
                result = DumpOctetString((PBYTE)pvData + 4,
                                         cbData - 4,
                                         OutputBuffer,
                                         OutputBufferSize,
                                         piDelta);
            }
        }
        break;

    case SYNTAX_BOOLEAN_TYPE:
        result = DumpBoolean(pvData,          
                             OutputBuffer,
                             OutputBufferSize,
                             piDelta);
        break;

    case SYNTAX_INTEGER_TYPE:
        result = DumpInteger(pvData,
                             OutputBuffer,
                             OutputBufferSize,
                             piDelta);
        break;

    case SYNTAX_OCTET_STRING_TYPE:
    case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        // ISSUE-2002/05/12-BrettSh Seems like to me that cbData - 4
        // should be cbActual.  Someone with a understanding of this
        // code should decide if this is the case, and make this change.
        result = DumpOctetString(pvData,
                                 cbData,
                                 OutputBuffer,
                                 OutputBufferSize,
                                 piDelta);
        break;

    case SYNTAX_TIME_TYPE:
        result = DumpTime(pvData,
                          OutputBuffer,
                          OutputBufferSize,
                          piDelta);
        break;

    case SYNTAX_UNICODE_TYPE:
        result = DumpUnicodeString(pvData,
                                   cbActual,
                                   OutputBuffer,
                                   OutputBufferSize,
                                   piDelta);
        break;

    case SYNTAX_DISTNAME_STRING_TYPE:
        result = DumpUnsignedInteger(pvData,
                                     OutputBuffer,
                                     OutputBufferSize,
                                     piDelta);
        if ( result ) {
            result = DumpSeparator(OutputBuffer,
                                   OutputBufferSize,
                                   piDelta);
            if ( result ) {
                // ISSUE-2002/05/12-BrettSh Seems like to me that cbData - 4
                // should be cbActual.  Someone with a understanding of this
                // code should decide if this is the case, and make this change.
                result = DumpString((PBYTE)pvData + 4,
                                    cbData - 4,
                                    OutputBuffer,
                                    OutputBufferSize,
                                    piDelta);
            }
        }
        break;

    case SYNTAX_I8_TYPE:
        result = DumpLargeInteger(pvData,
                                  OutputBuffer,
                                  OutputBufferSize,
                                  piDelta);
        break;

    case SYNTAX_SID_TYPE:
        result = DumpSid(pvData,
                         cbActual,
                         OutputBuffer,
                         OutputBufferSize,
                         piDelta);
        break;

    case SYNTAX_GUID_TYPE:
        result = DumpGuid(pvData,
                          OutputBuffer,
                          OutputBufferSize,
                          piDelta);
        break;

    default:
        // this should never happen
        Assert(FALSE);
        DPRINT1(0, "DumpRecord: encountered invalid syntax %d\n",
               eValueSyntax);
        return FALSE;

    }

    return(result);
}




BOOL
DumpRecord(
    IN HANDLE HDumpFile,
    IN JET_RETRIEVECOLUMN *ColumnVals,
    IN int *ColumnSyntaxes,
    IN DWORD NumColumns,
    IN PCHAR Buffer,
    IN int BufferSize,
    IN PCHAR Prefix
    )
/*++

Routine Description:

    This function prints a line into the file given in HDumpFile displaying
    the contents of the columns given in ColumnVals;

Arguments:

    HDumpFile - Supplies a handle to the file to dump into.

    ColumnVals - Supplies an array containing the values of the columns to be
                 dumped.
                 
    ColumnSyntaxes - Supplies an array containing the syntaxes of the columns
                     to be dumped.
                     
    NumColumns - Supplies the number of columns in the two arrays.
    
    Buffer - a buffer to use for encoding the line of output
    
    BufferSize - the number of bytes in the given buffer

Return Value:

    TRUE - the dumping was successful
    FALSE - the dumping failed

--*/
{

    DWORD i, j;
    int k;
    DWORD bytesWritten;
    DWORD result = 0;         //initialized to avoid C4701 
    DWORD error;
    int position;
    int delta;
    char symbol;
    BOOL bResult;

    // All of the formatting will be done in the in-memory buffer.  There will
    // only be one call to WriteFile which will occur at the end.
    
    position = strlen(Prefix);    
    Assert(position < BufferSize); // should be always ok, buffer is 1024 and Prefix is just a tab.
    memcpy(Buffer, Prefix, (position + 1) * sizeof(CHAR)); // Used for tabs

    for ( i = 0; i < NumColumns; i++ ) {

        // Each case will set delta to the number of characters that were
        // written.  At the end, position will be moved forward by this amount.
        // This number will then be used to determine how many extra spaces
        // need to get position to the beginning of the next column.
        delta = 0;

        if ( ColumnVals[i].err == JET_wrnColumnNull ) {
                       
            result = DumpNull(&Buffer[position],
                              BufferSize - position,
                              &delta);
            
        } else if ( ColumnVals[i].err != JET_errSuccess ) {

            // below, it will display error output if result is 0
            result = 0;
            
        } else {

            result = DumpColumn( ColumnSyntaxes[i],
                                 ColumnVals[i].pvData,
                                 ColumnVals[i].cbData,
                                 ColumnVals[i].cbActual,
                                 &Buffer[position],
                                 BufferSize - position,
                                 &delta );



        }

        // Only use the output produce above if it returned a success value.
        // Otherwise, just write over it with # symbols.
        if ( result == DUMP_ERR_SUCCESS ) {
            position += delta;
            symbol = ' ';
        } else {
            symbol = '#';
        }
            
        if ( BufferSize - position <
                 DefaultSyntaxWidths[ColumnSyntaxes[i]] - delta) {
            DPRINT(2, "DumpRecord: not enough buffer for column whitespace\n");
            result = DUMP_ERR_NOT_ENOUGH_BUFFER;
            break;
        }

        for ( k = 0;
              k < DefaultSyntaxWidths[ColumnSyntaxes[i]] - delta;
              k++ ) {
            Buffer[position++] = symbol;
        }

        if ( i != NumColumns - 1 ) {

            if ( BufferSize - position < 1 ) {
                DPRINT(2, "DumpRecord: not enough buffer for column "
                       "whitespace\n");
                result = DUMP_ERR_NOT_ENOUGH_BUFFER;
                break;
            }

            Buffer[position++] = ' ';

        }

    }

    if (position >= BufferSize-3) {
        // not enough space to write CRLF
        result = DUMP_ERR_NOT_ENOUGH_BUFFER;
    }

WriteLine:
    if (result != DUMP_ERR_NOT_ENOUGH_BUFFER) {
        // NOTE: a line return is two characters in DOS world (i.e. notepad)!
        Assert(position < (BufferSize - 3));
        strcpy(&Buffer[position], FILE_LINE_RETURN);
        position += strlen(FILE_LINE_RETURN);
    }
    
    bResult = WriteFile(HDumpFile,
                        Buffer,
                        position,
                        &bytesWritten,
                        NULL);
    if ( (bResult == FALSE) || ((int)bytesWritten < position) ) {
        DPRINT1(0, "DumpRecord: failed to write to file (Windows Error %d)\n",
                GetLastError());
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRMSG_DBDUMP_FAILURE,
                 szInsertSz("WriteFile"),
                 szInsertInt(GetLastError()),
                 NULL);
        return FALSE;
    }

    if (result == DUMP_ERR_NOT_ENOUGH_BUFFER) {
        // if we ran out of space, put "..." into the buffer and write again.
        // The CRLF will get added.
        position = 0;
        memcpy(&Buffer[position], "...", 3);
        position += 3;
        result = 0;
        goto WriteLine;
    }

    return TRUE;
         
} // DumpRecord



BOOL
DumpRecordMultiValues(
    IN HANDLE HDumpFile,
    IN DBPOS *pDB,
    IN DWORD Dnt,
    IN PCHAR * ColumnNames,
    IN JET_RETRIEVECOLUMN *ColumnVals,
    IN int *ColumnSyntaxes,
    IN DWORD NumColumns,
    IN PCHAR Buffer,
    IN int BufferSize
    )
/*++

Routine Description:

    This function prints potentially several lines into the file given in 
    HDumpFile displaying the contents of all multi-value attributes requested
    in the additional columns in ColumnVals.  We do ignore syntaxes however
    that would be picked up by the DumpRecordLinks, as those would have thier
    own table, and are dealt with seperately by that function.

Output (this function responsible for the servicePrincipalName line down):
-----------------------------------------------------------------------------
1718   1439   5      -     1430   true  -                   3      -     0      BRETTSH-BABY         NtFrs-88f5d2bd-b646-11d2-a6d3-00c04fc9b232/brettsh-baby.brettsh-dump.nttest.microsoft.com
    servicePrincipalName: LDAP/BRETTSH-BABY, 
        NtFrs-88f5d2bd-b646-11d2-a6d3-00c04fc9b232/brettsh-baby.brettsh-dump.nttest.microsoft.com, 
        LDAP/brettsh-baby.brettsh-dump.nttest.microsoft.com/brettsh-dump.nttest.microsoft.com, 
        LDAP/brettsh-baby.brettsh-dump.nttest.microsoft.com, exchangeAB/BRETTSH-BABY,
-----------------------------------------------------------------------------
Output cropped.

Arguments:

    HDumpFile - Supplies a handle to the file to dump into.

    pDB - Database position
    
    Dnt - Dnt of current object
    
    ColumnVals - Supplies an array containing the values of the columns to be
                 dumped.
                 
    ColumnSyntaxes - Supplies an array containing the syntaxes of the columns
                     to be dumped.
                     
    NumColumns - Supplies the number of columns in the two arrays.
    
    Buffer - a buffer to use for encoding the line of output
    
    BufferSize - the number of bytes in the given buffer

Return Value:

    TRUE - the dumping was successful
    FALSE - the dumping failed

--*/
{
    ULONG          iCol, iVal;
    THSTATE*       pTHS = pDB->pTHS;
    
    ATTCACHE *     pAC;
    JET_RETINFO    retinfo;
    VOID *         pvData = NULL;
    BOOL           fWrapData = FALSE;
    ULONG          cbData = 0;
    ULONG          cbActual = 0;
    ULONG          bytesWritten = 0;
    DWORD          result = TRUE;
    DWORD          dwRet = 0;
    LONG           position; // Must be long
    ULONG          cDelta = 0;
    ULONG          err = JET_errSuccess;

    // We need space for a couple things, line returns, ", " seperator, 
    // padding spaces, etc
    Assert(BufferSize > (DUMP_MULTI_VALUES_LINE_LEN + 13));

    retinfo.ibLongValue = 0;
    retinfo.cbStruct = sizeof(retinfo);
    retinfo.columnidNextTagged = 0;
    // retinfo.itagSequence set in loop
    
    // This will be plenty for most purposes (fits a GUID)
    cbData = 20;
    pvData = THAllocEx(pTHS, cbData);
                                            
    // Note: we're assuming that all the fixed columns are NOT multi
    // valued.  This is currently true, but if this ever changes
    // someone might want to fix this.
    for (iCol = NUM_FIXED_COLUMNS; iCol < NumColumns; iCol++) {
        // Start at the index after the last fixed column, loop
        // will not even run once if user didn't ask for any 
        // additional columns.

        pAC = SCGetAttByName(pTHS,
                             strlen(ColumnNames[iCol]),
                             ColumnNames[iCol]);
        if (pAC && pAC->ulLinkID != 0) {
            // This is a DN Link Value, we don't dump these,
            // DumpRecordLinks() takes care of these.
            continue;
        }

        // Most commonly we will not need to execute this multi-value
        // printing code, so we'll check early if there is a 2nd value.
        retinfo.itagSequence = 2;
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                pDB->JetObjTbl,
                                ColumnVals[iCol].columnid,
                                pvData,
                                cbData,
                                &cbActual,
                                pDB->JetRetrieveBits,
                                &retinfo);
        if (err == JET_wrnColumnNull) {
            continue;
        }

        //
        // Yeah there is a 2nd value, lets get to work ...
        //

        // Code.Improvement - It be a good idea to break these inner
        // loops into thier own helper functions.  The first outer 
        // functions could print a single multi-value.  And the inner
        // functions perhaps would print a single line into the
        // buffer, as these loops do now.

        // Start at the 1st value, even though we already printed
        // out this value in DumpRecord()
        iVal = 1;

        while ( err != JET_wrnColumnNull ) {
            
            // This loop iterates printing lines of values.
            position = 0;

            // We should always have values for this begging junk
            // Tab in for values
            dwRet = DumpStr(Buffer, "    ", BufferSize, &position);
            Assert(dwRet == DUMP_ERR_SUCCESS);
            if (iVal == 1) {
                // We need a description of this attribute ...
                dwRet = DumpStr(Buffer, 
                                ColumnNames[iCol],
                                BufferSize,
                                &position);
                if (dwRet) {
                    Assert(!"This really shouldn't happen!");
                    result = FALSE;
                    goto cleanup;
                }
                // Dump a seperator for description and values, leaving
                // room for a line return at the end.
                dwRet = DumpStr(Buffer, 
                                ": ",
                                (BufferSize - position - 5),
                                &position);
                if (dwRet) {
                    Assert(!"This really shouldn't happen either!");
                    result = FALSE;
                    goto cleanup;
                }
            } else {
                // Tab in more if not the first line for this column
                dwRet = DumpStr(Buffer, "    ", BufferSize, &position);
                Assert(dwRet == DUMP_ERR_SUCCESS);
            } 

            if (fWrapData) {
                fWrapData = FALSE;

                // This is a value that didn't fit on the previous
                // sized line, so we wrap it to the beginning of the
                // next line.  If we can't write it at the beginning
                // of a line, we don't bother trying to write it
                // anymore.
                cDelta = 0;
                dwRet = DumpColumn(ColumnSyntaxes[iCol],
                                    pvData,
                                    cbData,
                                    cbActual,
                                    &Buffer[position],
                                    (BufferSize - position - 5),
                                    &cDelta);
                if ( dwRet == DUMP_ERR_SUCCESS ) {
                    position += cDelta;
                } else {
                    // If we fail on a wrapped write, then this pvData is
                    // like larger than 1024 bytes.  Too big oh well.
                    result = FALSE;
                    goto cleanup;
                }

            }

            while ( (err != JET_wrnColumnNull) && 
                    (fWrapData == FALSE) ) {

                retinfo.itagSequence = iVal;

                cbActual = 0;
                err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                pDB->JetObjTbl,
                                                ColumnVals[iCol].columnid,
                                                pvData,
                                                cbData,
                                                &cbActual,
                                                pDB->JetRetrieveBits,
                                                &retinfo);

                if (err == JET_wrnColumnNull) {
                    // end of values for this attribute, we should just fall 
                    // out the iCol loop.
                } else if (err == JET_wrnBufferTruncated) {
                    // Whoops, grow our retrieval array size, decrement
                    // iVal so we'll try this value again.
                    err = JET_errSuccess;
                    pvData = THReAllocEx(pTHS, pvData, cbActual);
                    cbData = cbActual;
                    iVal--;
                } else if (err) {
                    // Hmmm, a real error, so bail.
                    result = FALSE;
                    goto cleanup;
                } else  {

                    //
                    // Success, this is a multi-valued attribute here.
                    //

                    if (iVal > 1) {
                        // No matter what we've left space for this seperator
                        // Print ", " seperator between values.
                        dwRet = DumpStr(Buffer, 
                                        ", ", 
                                        BufferSize,
                                        &position);
                        Assert(dwRet == DUMP_ERR_SUCCESS);
                        
                    }

                    cDelta = 0;
                    dwRet = DumpColumn(ColumnSyntaxes[iCol],
                                       pvData,
                                       cbData,
                                       cbActual,
                                       &Buffer[position],
                                       // Must use one if we're already over our buffer
                                       ((DUMP_MULTI_VALUES_LINE_LEN - position) < 1) ?
                                           1 : 
                                           (DUMP_MULTI_VALUES_LINE_LEN - position),
                                       &cDelta);
                    if ( dwRet == DUMP_ERR_SUCCESS ) {
                        position += cDelta;
                    } else if (dwRet == DUMP_ERR_NOT_ENOUGH_BUFFER) {
                        // Can't print this value, not enough room so lets
                        // try printing this value again (w/o comma)
                        fWrapData = TRUE;
                    } else {
                        result = FALSE;
                        goto cleanup;
                    }

                }

                // Lets look at the next value
                iVal++;

            } // end while we have more values and we aren't over our line length limit

            // Dump a line return
            dwRet = DumpStr(Buffer,
                            FILE_LINE_RETURN,
                            BufferSize,
                            &position);
            Assert(dwRet == DUMP_ERR_SUCCESS);

            //
            // Print a line - write the buffer to the file.
            //
            dwRet = WriteFile(HDumpFile,
                               Buffer,
                               position,
                               &bytesWritten, 
                               NULL);
            if ( (!dwRet) || ((LONG) bytesWritten < position) ) {
                result = FALSE;
                goto cleanup;
            }

        } // end while (more values to print)

    } // end for each column
    
cleanup:
    
    if (pvData != NULL) {
        THFree(pvData);
        cbData = 0;
    }

    return(result);
}


BOOL
DumpRecordLinks(
    IN HANDLE hDumpFile,
    IN DBPOS *pDB,
    IN DWORD Dnt,
    IN int indexLinkDntColumn,
    IN char **linkColumnNames,
    IN JET_RETRIEVECOLUMN *linkColumnVals,
    IN int *linkColumnSyntaxes,
    IN int numLinkColumns
    )

/*++

Routine Description:

    Dump the link table entries for a particular DNT

Arguments:

    hDumpFile - Output file
    pDB - Database position
    Dnt - Dnt of current object
    indexLinkDntColumn - index of Dnt column
    LinkColumnNames - Column names
    LinkColumnVals - Array of columns to be retrieved, preallocated
    LinkColumnSyntaxes - Synatx of each column
    NumLinkColumns - Number of columns

Return Value:

    BOOL - Success or failure

--*/

{
    /* DumpRecord Variables */
    char encodingBuffer[DBDUMP_BUFFER_LENGTH];

    JET_ERR jetError;          // return value from Jet functions
    BOOL doneRetrieving;
    BOOL result;
    BOOL fDumpHeader = TRUE;
    DWORD bytesWritten;        // the number of bytes written by WriteFile

    // find first matching record
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &(Dnt),
                 sizeof(Dnt),
                 JET_bitNewKey);
    jetError = JetSeekEx(pDB->JetSessID,
                         pDB->JetLinkTbl,
                         JET_bitSeekGE);
    if ((jetError != JET_errSuccess) && (jetError != JET_wrnSeekNotEqual)) {
        // no records
        return TRUE;
    }

    while (1) {
        doneRetrieving = FALSE;
            
        while ( !doneRetrieving ) {
            
            jetError = JetRetrieveColumns(pDB->JetSessID, 
                                          pDB->JetLinkTbl, 
                                          linkColumnVals, 
                                          numLinkColumns);
            if ( jetError == JET_wrnBufferTruncated ) {

                GrowRetrievalArray(pDB->pTHS, linkColumnVals, numLinkColumns);
                    
            } else if ( (jetError == JET_errSuccess) ||
                        (jetError == JET_wrnColumnNull) ) {

                doneRetrieving = TRUE;

            } else {

                DumpErrorMessageD(hDumpFile,
                                  "Error: could not retrieve link column "
                                  "values from database (Jet Error %d)\n",
                                  jetError);
                DPRINT(0,
                       "DumpDatabase: failed to retrieve link column "
                       "values:\n");
                return FALSE;

            }
                
        }

        // See if we have moved off of this object.
        if ( *((LPDWORD)(linkColumnVals[indexLinkDntColumn].pvData)) != Dnt ) {
            // no more records
            break;
        }

        if (fDumpHeader) {
            // dump header
            result = DumpHeader(pDB->pTHS,
                                hDumpFile,
                                linkColumnNames,
                                linkColumnVals,
                                linkColumnSyntaxes,
                                numLinkColumns,
                                "    ");
            if ( result == FALSE ) {
                DPRINT(1, "DumpDatabase: failed to dump header to dump file\n");
                return result;
            }
            
            fDumpHeader = FALSE;
        }

        result = DumpRecord(hDumpFile,
                            linkColumnVals,
                            linkColumnSyntaxes,
                            numLinkColumns,
                            encodingBuffer,
                            DBDUMP_BUFFER_LENGTH,
                            "    ");
        if ( result == FALSE ) {
            DPRINT(1, "DumpDatabase: failed to write link record to dump "
                   "file\n");
            return FALSE;
        }

        if (JET_errNoCurrentRecord ==
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, JET_MoveNext, 0)) {
            // No more records.
            break;
        }
    } // while(1) ..

    if (fDumpHeader == FALSE) {
        // we have written the header
        // write a newline to separate from the next record
        // NOTE: a line return is two characters in DOS world (i.e. notepad)!
        result = WriteFile(hDumpFile, FILE_LINE_RETURN, 
                           strlen(FILE_LINE_RETURN), &bytesWritten, NULL);
        if ( (result == FALSE) || (bytesWritten < 1) ) {
            return FALSE;
        }
    }

    return TRUE;
} /* DumpRecordLinks */


DWORD
DumpAccessCheck(
    IN LPCSTR pszCaller
    )
/*++

Routine Description:

    Checks access for private, diagnostic dump routines.

Arguments:

    pszCaller - Identifies caller. Eg, dbdump,  ldapConnDump, ....

Return Value:

    0 for success. Otherwise, a win32 error and the thread's error state is set.

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    THSTATE* pTHS = pTHStls;

    /* Security Variables */
    PSECURITY_DESCRIPTOR pSD;
    DWORD cbSD;
    BOOL accessStatus;
    CLASSCACHE* pCC;

    // grant dump database CR to Builtin Admins only, audit everyone.
    // Audit success only. If we audit failures, then anyone can
    // cause a security log flood.
    if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
              L"O:SYG:SYD:(A;;CR;65ED5CB2-42FF-40a5-9AFC-B67E1539AA3C;;BA)S:(AU;SA;CR;;;WD)",
              SDDL_REVISION_1,
              &pSD,
              &cbSD) ) {
        dwErr = GetLastError();
        DPRINT2(0,
                "%s: failed to convert string descriptor "
                "(Windows Error %d)\n",
                pszCaller,
                dwErr);
        SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
        return pTHS->errCode;
    }

    __try {
        // it does not really matter which DN and pCC we pass, since the hardcoded SD does not contain 
        // SELF sid aces. Let's pass the root domain DN.
        pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);
        accessStatus = IsControlAccessGranted(pSD, gAnchor.pRootDomainDN, pCC, RIGHT_DS_DUMP_DATABASE, TRUE);
        if (!accessStatus) {
            DPRINT1(0, "%s: dbdump access denied\n", pszCaller);
            dwErr = ERROR_ACCESS_DENIED;
        }
    } __finally {
        if (pSD) {
            LocalFree(pSD);
        }
    }

    return dwErr;
}


ULONG
DumpDatabase(
    IN OPARG *pOpArg,
    OUT OPRES *pOpRes
    )
/*++

Routine Description:

    Writes much of the contents of the database into a text file.

    Error handling works as follows.  The first thing that's done is an
    access check to make sure that this user can perform a database dump.
    Any errors up to and including the access check are returned to the user
    as an error.  If the access check succeeds, then no matter what happens
    after that, the user will be sent a successful return value.  If an error
    does occur after that, the first choice is to print an error message in
    the dump file itself.  If we cannot do so (because the error that occured
    was in CreateFile or WriteFile), we write a message to the event log.
    
Arguments:

    pOpArg - pointer to an OPARG structure containing, amonst other things,
             the value that was written to the dumpDatabase attribute
    pOpRes - output (error codes and such...)

Return Value:

    An error code.

--*/
{
    
    /* File I/O Variables */
    PCHAR dumpFileName;        // name of the dump file
    int jetPathLength;         // number of chars in the jet file path
    PCHAR pTemp;               // temp variable
    HANDLE hDumpFile;          // handle of file to write into
    DWORD bytesWritten;        // the number of bytes written by WriteFile

    /* DBLayer Variables */
    DBPOS *pDB;                // struct containg tableid, databaseid, etc.
    int *columnSyntaxes;       // array containing the syntaxes of the columns
                               // represented in columnVals (below)
    int *linkColumnSyntaxes;

    /* Jet Variables */
    JET_RETRIEVECOLUMN* columnVals; // the array of column retrieval
                                    // information to be passed to
                                    // JetRetrieveColumns
    JET_RETRIEVECOLUMN* linkColumnVals;

    /* DumpRecord Variables */
    char encodingBuffer[DBDUMP_BUFFER_LENGTH];
    
    /* Error Handling Variables */
    DWORD error;               // return value from various functions
    BOOL result;               // return value from various functions
    DB_ERR dbError;            // return value from DBLayer functions
    JET_ERR jetError;          // return value from Jet functions

    /* Security Variables */
    BOOL impersonating;        // true once ImpersonateAnyClient has been
                               // called successfully

    /* Misc. Variables */
    THSTATE *pTHS = pTHStls;
    int i, j;
    int numRecordsDumped;
    BOOL doneRetrieving;
    int indexObjectDntColumn, indexLinkDntColumn;

    // The fixed columns are always displayed in any database dump.  Additional
    // columns are dumped when their names are given (in pOpArg) as the new
    // value for the dumpDatabase variable.

    // an array containing pointers to the name of each column
    char **columnNames;
    char **linkColumnNames;

    // the number of total columns
    int numColumns;
    int numLinkColumns;
    

    DPRINT(1, "DumpDatabase: started\n");

    // Initialize variables to null values.  If we go into the error handling
    // code at the bottom (labeled error), we will want to know which
    // variables need to be freed.
    impersonating = FALSE;
    pDB = NULL;
    hDumpFile = INVALID_HANDLE_VALUE;
    columnVals = NULL;
    
    __try {

        error = DumpAccessCheck("dbdump");
        if ( error != ERROR_SUCCESS ) {
            __leave;
        }

        error = ImpersonateAnyClient();
        if ( error != ERROR_SUCCESS ) {
            DPRINT1(0,
                    "DumpDatabase: failed to start impersonation "
                    "(Windows Error %d)\n",
                    GetLastError());
            SetSvcError(SV_PROBLEM_DIR_ERROR, GetLastError());
            __leave;
        }
        impersonating = TRUE;

        // find the last backslash
        pTemp = strrchr(szJetFilePath, '\\');
        if (pTemp == NULL) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_BAD_PATHNAME);
            __leave;

        }
        // find the dot after the backslash
        pTemp = strchr(pTemp, '.');
        
        if (pTemp != NULL) {
            // pTemp points to the dot.
            jetPathLength = (int)(pTemp - szJetFilePath);
        }
        else {
            // no extension, so use whole filename
            jetPathLength = strlen(szJetFilePath);
        }

        // we need 5 extra chars (".dmp" plus terminating null)
        dumpFileName = THAllocEx(pTHS, jetPathLength + 5); 
        memcpy(dumpFileName, szJetFilePath, jetPathLength);
        strcpy(dumpFileName+jetPathLength, ".dmp");

        DPRINT1(1, "DumpDatabase: dumping to file %s\n", dumpFileName);

        hDumpFile = CreateFile(dumpFileName,
                               GENERIC_WRITE,
                               0,
                               0,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
        if ( hDumpFile == INVALID_HANDLE_VALUE ) {
            UnImpersonateAnyClient();
            impersonating = FALSE;
            DPRINT1(0,
                    "DumpDatabase: failed to create file "
                    "(Windows Error %d)\n",
                    GetLastError());
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRMSG_DBDUMP_FAILURE,
                     szInsertSz("CreateFile"),
                     szInsertInt(GetLastError()),
                     NULL);
            __leave;
        }

        UnImpersonateAnyClient();
        impersonating = FALSE;
        
        DBOpen(&pDB);
        Assert(IsValidDBPOS(pDB));
        
        // Data table
        result = GetColumnNames(pTHS, pOpArg, &columnNames, &numColumns);
        if ( result == FALSE ) {
            DPRINT(1, "DumpDatabase: failed to generate requested column "
                   "names\n");
            __leave;
        }

        columnVals = (JET_RETRIEVECOLUMN*) THAllocEx(pTHS, numColumns * 
                                               sizeof(JET_RETRIEVECOLUMN));

        columnSyntaxes = (int*) THAllocEx(pTHS, numColumns * sizeof(int));
        
        ZeroMemory(columnVals, numColumns * sizeof(JET_RETRIEVECOLUMN));
        ZeroMemory(columnSyntaxes, numColumns * sizeof(int));
        
        result = GetFixedColumnInfo(pTHS,  columnVals, columnSyntaxes);
        if ( result == FALSE ) {
            DPRINT(1, "DumpDatabase: failed to get fixed column retrieval "
                   "structures\n");
            __leave;
        }
        
        result = GetColumnInfoByName(pDB,
                                     pTHS,
                                     hDumpFile,
                                     columnNames,
                                     columnVals,
                                     columnSyntaxes,
                                     numColumns);
        if ( result == FALSE ) {
            DPRINT(1, "DumpDatabase: failed to generate requested column "
                   "retrieval structures\n");
            __leave;
        }
        
        // Find the DNT columns in the array
        for( i = 0; i < numColumns; i++ ) {
            if (columnVals[i].columnid == dntid) {
                break;
            }
        }
        Assert( i < numColumns );
        indexObjectDntColumn = i;

        jetError =  JetSetCurrentIndex(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       NULL);   // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
        if ( jetError != JET_errSuccess ) {
            DumpErrorMessageD(hDumpFile,
                              "Error: could not set the current database "
                              "index (Jet Error %d)\n",
                              jetError);
            DPRINT1(0,
                    "DumpDatabase: failed to set database index "
                    "(Jet Error %d)\n",
                    jetError);
            __leave;
        }

        // Link table
        result = GetLinkColumnNames(pTHS, &linkColumnNames, &numLinkColumns);
        if ( result == FALSE ) {
            DPRINT(1, "DumpDatabase: failed to generate requested column "
                   "names\n");
            __leave;
        }

        linkColumnVals = (JET_RETRIEVECOLUMN*) THAllocEx(pTHS, numLinkColumns * 
                                               sizeof(JET_RETRIEVECOLUMN));

        linkColumnSyntaxes = (int*) THAllocEx(pTHS, numLinkColumns * sizeof(int));
        
        ZeroMemory(linkColumnVals, numLinkColumns * sizeof(JET_RETRIEVECOLUMN));
        ZeroMemory(linkColumnSyntaxes, numLinkColumns * sizeof(int));
        
        result = GetLinkColumnInfo(pTHS, linkColumnVals, linkColumnSyntaxes);
        if ( result == FALSE ) {
            DPRINT(1, "DumpDatabase: failed to get fixed column retrieval "
                   "structures\n");
            __leave;
        }

        for( i = 0; i < numLinkColumns; i++ ) {
            if (linkColumnVals[i].columnid == linkdntid) {
                break;
            }
        }
        Assert( i < numLinkColumns );
        indexLinkDntColumn = i;

        jetError =  JetSetCurrentIndex(pDB->JetSessID,
                                       pDB->JetLinkTbl,
                                       NULL);   // OPTIMISATION: pass NULL to switch to primary index (SZLINKALLINDEX)
        if ( jetError != JET_errSuccess ) {
            DumpErrorMessageD(hDumpFile,
                              "Error: could not set the current database "
                              "link index (Jet Error %d)\n",
                              jetError);
            DPRINT1(0,
                    "DumpDatabase: failed to set database link index "
                    "(Jet Error %d)\n",
                    jetError);
            __leave;
        }


        result = DumpHeader(pTHS,
                            hDumpFile,
                            columnNames,
                            columnVals,
                            columnSyntaxes,
                            numColumns,
                            "");
        if ( result == FALSE ) {
            DPRINT(1, "DumpDatabase: failed to dump header to dump file\n");
            __leave;
        }
        
        // Write an extra line return for clarity.
        WriteFile(hDumpFile,
                  FILE_LINE_RETURN,
                  strlen(FILE_LINE_RETURN),
                  &bytesWritten,
                  NULL);


        numRecordsDumped = 0;
        
        jetError = JetMove(pDB->JetSessID,
                           pDB->JetObjTbl,
                           JET_MoveFirst,
                           0);
    
        while ( jetError == JET_errSuccess ) {	

            doneRetrieving = FALSE;
            
            while ( !doneRetrieving ) {
            
                jetError = JetRetrieveColumns(pDB->JetSessID, 
                                              pDB->JetObjTbl, 
                                              columnVals, 
                                              numColumns);
                if ( jetError == JET_wrnBufferTruncated ) {

                    GrowRetrievalArray(pTHS, columnVals, numColumns);
                    
                } else if ( (jetError == JET_errSuccess) ||
                            (jetError == JET_wrnColumnNull) ) {

                    doneRetrieving = TRUE;

                } else {

                    DumpErrorMessageD(hDumpFile,
                                      "Error: could not retrieve column "
                                      "values from database (Jet Error %d)\n",
                                      jetError);
                    DPRINT(0,
                           "DumpDatabase: failed to retrieve column "
                           "values:\n");
                    __leave;

                }
                
            }

            //
            // Dump the basic columns ...
            //
            result = DumpRecord(hDumpFile,
                                columnVals,
                                columnSyntaxes,
                                numColumns,
                                encodingBuffer,
                                DBDUMP_BUFFER_LENGTH,
                                "");
            if ( result == FALSE ) {
                DPRINT(1, "DumpDatabase: failed to write record to dump "
                       "file\n");
                __leave;
            }

            numRecordsDumped++;
            
            //
            // Dump any multi-value fields we might have ...
            //
            result = DumpRecordMultiValues(hDumpFile,
                                           pDB,       
                                           *((LPDWORD)(columnVals[indexObjectDntColumn].pvData)),
                                           columnNames,
                                           columnVals,
                                           columnSyntaxes,
                                           numColumns,
                                           encodingBuffer,
                                           DBDUMP_BUFFER_LENGTH);
            if ( result == FALSE ) {
                DPRINT(1, "DumpDatabase: failed to write multi-valued attributes to dump "
                       "file\n");
                __leave;
            }


            //
            // Dump the link values if any ...
            //
            result = DumpRecordLinks(hDumpFile,
                                     pDB,
                                     *((LPDWORD)(columnVals[indexObjectDntColumn].pvData)),
                                     indexLinkDntColumn,
                                     linkColumnNames,
                                     linkColumnVals,
                                     linkColumnSyntaxes,
                                     numLinkColumns );

            if ( result == FALSE ) {
                DPRINT(1, "DumpDatabase: failed to write links to dump "
                       "file\n");
                __leave;
            }

            jetError = JetMove(pDB->JetSessID,
                               pDB->JetObjTbl,
                               JET_MoveNext,
                               0);

        } // while ( jetError == JET_errSuccess )

        if ( jetError != JET_errNoCurrentRecord ) {
            DumpErrorMessageD(hDumpFile,
                              "Error: could not move cursor to the next "
                              "record in database (Jet Error %d)\n",
                              jetError);
            DPRINT1(0, "DumpDatabase: failed to move cursor in database "
                   "(Jet Error %d)\n", jetError);
            __leave;
        }

        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRMSG_DBDUMP_SUCCESS,
                 szInsertInt(numRecordsDumped),
                 szInsertSz(dumpFileName),
                 NULL);
    
    } __finally {

        if ( pDB != NULL ) {
            // we shouldn't have modified the database,
            // so there is nothing to commit.
            error = DBClose(pDB, FALSE);
            if ( error != DB_success ) {
                DPRINT1(0, "DumpDatabase: failed to close database "
                        "(DS Error %d)\n", error);
            }
        }
        
        if ( hDumpFile != INVALID_HANDLE_VALUE ) {
            result = CloseHandle(hDumpFile);
            if ( result == FALSE ) {
                DPRINT1(0, "DumpDatabase: failed to close file handle "
                        "(Windows Error %d)\n", GetLastError());
            }
        }

        if ( impersonating ) {
            UnImpersonateAnyClient();
            impersonating = FALSE;
        }
        
    }

    DPRINT(1, "DumpDatabase: finished\n");

    return pTHS->errCode;

} // DumpDatabase
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\lhtp.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    lhtp.h

Abstract:

    This module defines the private data structures for an unsynchronized
    linear hash table (LHT).

Author:

    Andrew E. Goodsell (andygo) 01-Apr-2001

Revision History:

--*/

#ifndef _LHTP_
#define _LHTP_


//  Maintenance State Transition Table

typedef enum _LHT_STATE {
    LHT_stateNil,
    LHT_stateGrow,
    LHT_stateShrink,
    LHT_stateSplit,
    LHT_stateMerge,
    } LHT_STATE;

typedef
VOID
(*LHT_PFNSTATECOMPLETION) (
    IN      PLHT    plht
    );

typedef struct _LHT_STATE_TRANSITION {
    LHT_PFNSTATECOMPLETION      pfnStateCompletion;
    LHT_STATE                   stateNext;
} LHT_STATE_TRANSITION, *PLHT_STATE_TRANSITION;


//  Cluster

struct _LHT_CLUSTER {

    //  Next/Last Pointer
    //
    //  This pointer is overloaded to represent two pieces of data:  the number
    //  of entries in the current cluster and a pointer to the next cluster.  Here
    //  are the three modes:
    //
    //      pvNextLast = NULL
    //
    //          -  This state is only valid in the head cluster of a bucket
    //          -  There are no entries in this cluster
    //          -  There are no more clusters in this bucket
    //
    //      pvNextLast = valid pointer within current cluster
    //
    //          -  This state is only valid in the last cluster of a bucket
    //          -  The pointer points to the last entry in the bucket
    //          -  There are no more clusters in this bucket
    //
    //      pvNextLast = valid pointer outside current cluster
    //
    //          -  There are the maximum number of entries in this bucket
    //          -  The pointer points to the next cluster in the bucket

    PVOID                       pvNextLast;
    CHAR                        rgEntry[ ANYSIZE_ARRAY ];
};


//  Global State

struct _LHT {
    //  initial configuration
    
    SIZE_T                      cbEntry;
    LHT_PFNHASHKEY              pfnHashKey;
    LHT_PFNHASHENTRY            pfnHashEntry;
    LHT_PFNENTRYMATCHESKEY      pfnEntryMatchesKey;
    LHT_PFNCOPYENTRY            pfnCopyEntry;
    SIZE_T                      cLoadFactor;
    SIZE_T                      cEntryMin;
    LHT_PFNMALLOC               pfnMalloc;
    LHT_PFNFREE                 pfnFree;
    SIZE_T                      cbCacheLine;

    //  computed configuration

    SIZE_T                      cbCluster;
    SIZE_T                      cEntryCluster;
    SIZE_T                      cBucketMin;

    //  statistics
    
    SIZE_T                      cEntry;
    SIZE_T                      cOp;

    //  cluster pool

    PLHT_CLUSTER                pClusterAvail;
    PLHT_CLUSTER                pClusterReserve;
    SIZE_T                      cClusterReserve;

    //  maintenance control

    SIZE_T                      cOpSensitivity;
    SIZE_T                      cBucketPreferred;
    LHT_STATE                   stateCur;

    //  Directory Pointers
    //
    //  containment for the directory pointers these pointers control the use
    //  of the directory itself (rgrgBucket)
    //
    //  the hash table will always have a minimum of 2 buckets (0 and 1) in the
    //  directory
    //
    //  buckets are stored in dynamically allocated arrays which are pointed to
    //  by the directory.  each array is 2 times larger than the previous array
    //  (exponential growth).  for example, the Nth array (rgrgBucket[N])
    //  contains 2^N contiguous buckets
    //
    //  NOTE:  the 0th array is special in that it contains an extra element
    //  making its total 2 elements (normally, 2^0 == 1 element;  this is done
    //  for magical reasons to be explained later)
    //
    //  thus, the total number of entries for a given N is:
    //
    //           N
    //      1 + SUM 2^i  -->  1 + [ 2^(N+1) - 1 ]  -->  2^(N+1)
    //          i=0
    //
    //  we know the total number of distinct hash values is a power of 2 (it
    //  must fit into a SIZE_T).  we can represent this with 2^M where M is the
    //  number of bits in a SIZE_T.  therefore, assuming the above system of
    //  exponential growth, we know that we can store the total number of hash
    //  buckets required at any given time so long as N = M.  in other words,
    //
    //      N = # of bits in SIZE_T --> sizeof( SIZE_T ) * 8
    //
    //  therefore, we can statically allocate the array of bucket arrays and we
    //  can use LOG2 to compute the bucket address of any given hash value 
    //
    //  NOTE:  the exceptions to this rule are 0 => 0, 0 and 1 => 0, 1
    //
    //  for an explaination of cBucketMax and cBucket you should read the paper
    //  on Linear Hashing by Per Ake Larson

    SIZE_T                      cBucketMax;
    SIZE_T                      cBucket;
    CHAR*                       rgrgBucket[ sizeof( SIZE_T ) * 8 ];

#ifdef LHT_PERF

    //  performance statistics

    SIZE_T                      cOverflowClusterAlloc;
    SIZE_T                      cOverflowClusterFree;
    SIZE_T                      cBucketSplit;
    SIZE_T                      cBucketMerge;
    SIZE_T                      cDirectorySplit;
    SIZE_T                      cDirectoryMerge;
    SIZE_T                      cStateTransition;
    SIZE_T                      cPolicySelection;
    SIZE_T                      cMemoryAllocation;
    SIZE_T                      cMemoryFree;
    SIZE_T                      cbMemoryAllocated;
    SIZE_T                      cbMemoryFreed;

#endif  //  LHT_PERF
};


#endif  //  _LHTP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\linkclean.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 2000
//
//  File:       linkclean.c
//
//--------------------------------------------------------------------------

/*++                                                     

Abstract:

    This module contains routines for implementing link cleanup. 

    The mechanism for determine which objects need cleaning is a special fixed
    column called clean_col.

    Mark Brown writes:

clean_col is not replicated; there's an independent cleaner on each DC.

clean_col gets set on originating or replicated group changes that
(1) delete a group or (2) change a group's type.

clean_col gets removed when the cleaner is satisfied that all cleanup work
(there may be none) related to that object is complete, using transactions
appropriately to avoid races with another thread that may be setting clean_col.
Since the cleaner's work is performed as multiple transactions,
the cleaner is prepared for its "work assignment" to grow/shrink at
any transaction boundary.

    The link cleaner runs regardless of whether the system has enabled link-
    value replication or not. This functionality of having links removed in the
    background is useful on any system.  It does not depend on LVR functionality.

    The link cleaner is stateless is the sense that it determines its work
    from the current state of the object, not from some work order list.  This
    means that each unique action which the cleaner must perform must be
    guessable from the state of the object. Sometimes there is some ambiguity.

Friend routines:
   dbisam.c:DBSetObjectNeedsCleaning
   dbisam.c:DBGetNextRecordNeedingCleaning

Author:

    Will Lees    (wlees)   22-Mar-00

Revision History:

    22-Mar-00   Will Created 

--*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <drs.h>                        // defines the drs wire interface
#include <drsuapi.h>                    // I_DRSVerifyNames
#include <prefix.h>

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include <dsutil.h>
#include <esent.h>                      // JET_err constants
#include "taskq.h"                      // for TASKQ_DONT_RESCHEDULE

// Filter and Attribute 
#include <filtypes.h>                   // header for filter type
#include <attids.h>                     // attribuet IDs 

// Replication
#include <drameta.h>                    // ReplLookupMetaData

#include "debug.h"                      // standard debugging header
#define DEBSUB     "LINKCLEAN:"         // define the subsystem for debugging


#include <fileno.h>                     // used for THAlloEx, but I did not 
#define  FILENO FILENO_LINKCLEAN        // use it in this module


// When there is more work to do, the cleaner reschedules at the "busy"
// interval. When there is not, it uses the "not busy" interval.  When there
// is an error, it reschedules at the "failure" interval.
#if DBG
#define SECONDS_UNTIL_NEXT_ITERATION_NB  (60 * 60)  // one hour in seconds
#else
#define SECONDS_UNTIL_NEXT_ITERATION_NB  (12 * 60 * 60) // 12 hours in seconds
#endif  // DBG
#define SECONDS_UNTIL_NEXT_ITERATION_BUSY  (0)  // Resch immed at end of queue
#define SECONDS_UNTIL_NEXT_ITERATION_FAILURE  (60 * 60) // one hour in seconds

// As a ballpark figure, I observed my test machine
// remove 1000 values in 4 seconds.

// Maximum number of milliseconds we should spend in a single pass
const ULONG gulDraMaxTicksForLinkCleaner = 5 * 60 * 1000;

// This is the limit of the number of links we try to remove in one
// transation
#define LINKS_PER_TRANSACTION 1000

// This is the limit of the number of links that may be processed in a single
// pass of the cleaner.
#define LINK_LIMIT (1 * 1000 * 1000)





//////////////////////////////////////////////////////////////////
//                                                              //
//          Private routines.  Restricted to this file          //
//                                                              //
//////////////////////////////////////////////////////////////////

BOOL gfLinkCleanerIsEnabled = TRUE;

#if DBG
extern DWORD gcLinksProcessedImmediately; // debug hook
#endif

//////////////////////////////////////////////////////////////////
//                                                              //
//          Implementations                                      // 
//                                                              //
//////////////////////////////////////////////////////////////////
    

BOOL
touchObjectLinks(
    IN DBPOS *pDB,
    IN ATTCACHE *pAC,
    USN usnEarliest,
    BOOL fTouchBacklinks,
    IN ULONG ulTickToTimeOut,
    IN OUT DWORD *pcLinksProcessed
    )

/*++

Routine Description:

    Touch the links of the attribute in question.

    Some of the links may have been touched when the originating write occurred.
    We may have been restarted after only making it part way through the
    list of links.
    There may be more links than could be processed in one pass of the cleaner.

    In all these cases we need to limit ourselves to those links that have not
    been touched yet. We do this by means of a crude positioning mechanism.
    We calculate when the group type was changed. We then only process links which
    have not been updated since then.

    Note that we cannot use the object WHEN_CHANGED for this limit because it
    is set AFTER then initial set of links is touched as part of the originating
    write.  This would result in the cleaner touching them again. Also, we don't
    want other changes to the group object fooling the cleaner into thinking it
    needs to retouch links.

Arguments:

    pDB - database position
    pAC - attribute to touch. May be NULL
    usnEarliest - Links with USN's lower than this will be touched
    fTouchBacklinks - Forward links are always touched. Touch backlinks too?
    ulTickToTimeOut - tick time in future when we should stop
    pcLinksProcessed - running count

Return Value:

    BOOL - more data flag

--*/

{
    BOOL fMoreData;
    DWORD dntObject = pDB->DNT;
    DWORD err;

    Assert( pDB->pTHS->fLinkedValueReplication );

    // Touch forward links in batches
    fMoreData = TRUE;
    while ( (*pcLinksProcessed < LINK_LIMIT) &&
            (CompareTickTime(GetTickCount(), ulTickToTimeOut) < 0) &&
            fMoreData ) {

        fMoreData = DBTouchAllLinksHelp_AC(
            pDB,
            pAC,
            usnEarliest,
            FALSE, /* forward links */
            LINKS_PER_TRANSACTION,
            pcLinksProcessed
            );
        
        // Close the transaction between links so that the version
        // store does not get too large
        DBTransOut(pDB, TRUE, TRUE);
        DBTransIn(pDB);

        // Restore currency
        DBFindDNT( pDB, dntObject );
    }

    // See if we are done
    if ( (fMoreData) || (!fTouchBacklinks) ) {
        return fMoreData;
    }

    // Touch backward links in batches
    fMoreData = TRUE;
    while ( (*pcLinksProcessed < LINK_LIMIT) &&
            (CompareTickTime(GetTickCount(), ulTickToTimeOut) < 0) &&
            fMoreData ) {

        fMoreData = DBTouchAllLinksHelp_AC(
            pDB,
            pAC,
            usnEarliest,
            TRUE, /* backward links */
            LINKS_PER_TRANSACTION,
            pcLinksProcessed
            );
        
        // Close the transaction between links so that the version
        // store does not get too large
        DBTransOut(pDB, TRUE, TRUE);
        DBTransIn(pDB);

        // Restore currency
        DBFindDNT( pDB, dntObject );
    }

    return fMoreData;
} /* touchObjectLinks */


BOOL
removeDeletedObjectLinks(
    IN DBPOS *pDB,
    IN ATTCACHE *pAC,
    IN BOOL fRemoveBacklinks,
    IN ULONG ulTickToTimeOut,
    IN OUT DWORD *pcLinksProcessed
    )

/*++

Routine Description:

    Physically remove the links from a deleted object.

    Remove them in chunks in separate transactions.

    We are here because there were too many links to remove during the
    delete operation.  There are two cases of delete that we need to be
    concerned with.

    See mddel.c:SetDelAtts
    See mddel.c:Garb_Collect
    See dbisam.c:DBPhysDel
    See dbisam.c:DBAddDelIndex

    1. fGarbCollectASAP = FALSE.
       SetDelAtts was called to strip the object.
       isDeleted is set on the object
       The object appears on the SZDELTIMEINDEX
       DBPhysDel was called from the garbage collector.

       In this case forward and backward links are removed.
       This is because the object has been deleted everywhere in the
       enterprise and there should be no more references to it.

    2. fGarbCollectASAP = TRUE.
       RO NC tear-down in progress. See drancrep.c:DelRepTree.
       SetDelAtts was not called.
       isDeleted is NOT set on the object
       The object appears on the SZDELTIMEINDEX
       DBPhysDel was called from LocalRemove().

       In this case, only forward links are removed.
       This is because the object has not been deleted in the enterprise.
       This live copy on this NC is being demoted. The object may remain
       a phantom on this system to account for references to it in other
       NCs.

Arguments:

    pDB - data base position
    pAC - Attribute to remove, if any
    fRemoveBacklinks - Should we remove the backlinks
    ulTickToTimeOut - tick time in future when we should stop
    pcLinksProcessed - Count of links processed

Return Value:

    BOOL - More data flag

--*/

{
    BOOL fMoreData;
    DWORD dntObject = pDB->DNT;

    // Remove forward links in all cases
    fMoreData = TRUE;
    while ( (*pcLinksProcessed < LINK_LIMIT) &&
            (CompareTickTime(GetTickCount(), ulTickToTimeOut) < 0) &&
            fMoreData ) {

        fMoreData = DBRemoveAllLinksHelp_AC(
            pDB,
            pDB->DNT,
            pAC,
            FALSE /* forward link */,
            LINKS_PER_TRANSACTION,
            pcLinksProcessed
            );
        
        // Close the transaction between links so that the version
        // store does not get too large
        DBTransOut(pDB, TRUE, TRUE);
        DBTransIn(pDB);

        // Restore currency
        DBFindDNT( pDB, dntObject );
    }

    // See if we are done
    if ( (fMoreData) || (!fRemoveBacklinks) ) {
        return fMoreData;
    }

    // Remove backwards links if requested
    fMoreData = TRUE;
    while ( (*pcLinksProcessed < LINK_LIMIT) &&
            (CompareTickTime(GetTickCount(), ulTickToTimeOut) < 0) &&
            fMoreData ) {

        fMoreData = DBRemoveAllLinksHelp_AC(
            pDB,
            pDB->DNT,
            pAC,
            TRUE /* backward link */,
            LINKS_PER_TRANSACTION,
            pcLinksProcessed
            );

        // Close the transaction between links so that the version
        // store does not get too large
        DBTransOut(pDB, TRUE, TRUE);
        DBTransIn(pDB);

        // Restore currency
        DBFindDNT( pDB, dntObject );
    }

    return fMoreData;
} /* removeDeletedObjectLinks */


BOOL
hasPropertyMetaDataChanged(
    IN  ATTRTYP attrtyp,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVec,
    OUT USN * pusnEarliest OPTIONAL
    )

/*++

Routine Description:

    Check whether the property has ever changed, based on metadata being present.

    Whether an attribute has changed "recently" cannot be computed in a reliable way
    based on modification times because the directory is not dependent on correct
    time synchronization.

Arguments:

    attrtyp - Attribute to be checked
    pMetaDataVec - Metadata vector from object
    pusnEarliest - If the object was changed, local usn of change

Return Value:

    BOOL - 

--*/

{
    PROPERTY_META_DATA *pMetaData;
    BOOL fResult = FALSE;

    pMetaData = ReplLookupMetaData(attrtyp, pMetaDataVec, NULL);
    if (pMetaData) {
        fResult = TRUE;

        // Return local usn of change if requested
        if (pusnEarliest) {
            *pusnEarliest = pMetaData->usnProperty;
        }
    }

    return fResult;
} /* hasPropertyMetaDataChanged */


BOOL
cleanObject(
    IN DBPOS *pDB,
    IN ULONG ulTickToTimeOut,
    IN OUT DWORD *pcLinksProcessed
    )

/*++

Routine Description:

    Determine what type of cleaning is needed for this object

    The cleaner will verify that an object marked actually needs work. If not, it
    will silently unmark the object.

Arguments:

    pDB - 
    ulTickToTimeOut - Time in future when we should stop
    pcLinksProcessed - IN/OUT count incremented

Return Value:

    BOOL - More data flag

--*/

{
    DWORD err, it, cbReturned;
    BOOL fMoreData;
    DSTIME deltime;
    UCHAR objflag;
    SYNTAX_INTEGER objectClassId;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec = NULL;
    USN usnEarliest;

    // Get the obj flag
    if (err = DBGetSingleValue(pDB, FIXED_ATT_OBJ, &objflag, sizeof(objflag), NULL)) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    //
    // Work order type #1
    // Remove forward links from a phantomized object
    //

    if (!objflag) {

        // Object to be cleaned is a phantom

        // There is a potential ambiguity as to whether this phantom came from the
        // garbage collector running DbPhysDel on a deleted object, or from a readonly
        // nc tear-down.  Assuming that the link cleaner period is less than the
        // tombstone lifetime, the cleaner should see deleted objects as deleted
        // objects and handle them that way.  It should never see a user-deleted
        // object as a phantom.

        // If the object is a phantom, then the most likely cause is that the object
        // was in a readonly nc that was being torn down. Do not remove backlinks
        // since they may be hosted by objects in other NC's.

        fMoreData = removeDeletedObjectLinks( pDB,
                                              NULL /* all attributes */,
                                              FALSE, /* forward links */
                                              ulTickToTimeOut,
                                              pcLinksProcessed );

        goto cleanup;
    }

    // The object is live, either deleted or not.

    // Get the instance type and object class flag. These are always present.
    if ( (err = DBGetSingleValue(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it), NULL)) ||
         (err = DBGetSingleValue(pDB, ATT_OBJECT_CLASS, &objectClassId,
                                 sizeof(objectClassId), NULL)) ||
         (err = DBGetAttVal(pDB, 1,  ATT_REPL_PROPERTY_META_DATA,
                    0, 0, &cbReturned, (LPBYTE *) &pMetaDataVec))
        ) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    //
    // Work order type #2
    // Remove all links relating to a deleted object
    //

    // Check if object is deleted
    if (DBIsObjDeleted(pDB)) {

        DPRINT1( 1, "Cleaning object %s: a deleted object\n",
                 GetExtDN( pDB->pTHS, pDB ) );

        // Object has been deleted. Remove all references to it.

        fMoreData = removeDeletedObjectLinks( pDB,
                                              NULL /* all attributes */,
                                              TRUE, /* remove forward and backward links */
                                              ulTickToTimeOut,
                                              pcLinksProcessed );
        goto cleanup;
    }

    //
    // Work order type #3
    // 3a. A group is now universal. Causes its links to replicate out
    // 3b. A group is no longer universal. Remove forward links only
    //

    if ( (objectClassId == CLASS_GROUP) &&
         (hasPropertyMetaDataChanged( ATT_GROUP_TYPE,
                                      pMetaDataVec,
                                      &usnEarliest )) ) {
        SYNTAX_INTEGER groupType;
        ATTCACHE *pAC;

        pAC = SCGetAttById(pDB->pTHS, ATT_MEMBER);
        if (!pAC) {
            DRA_EXCEPT(DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
        }

        if ( (err = DBGetSingleValue(pDB, ATT_GROUP_TYPE, &groupType,
                                     sizeof(groupType), NULL))  ) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        if ( (groupType & GROUP_TYPE_UNIVERSAL_GROUP) &&
             (it & IT_WRITE) ) {

            // Group type is now universal in a writeable NC
            DPRINT1( 1, "Cleaning object %s: a group which recently became universal\n",
                     GetExtDN( pDB->pTHS, pDB ) );

            fMoreData = touchObjectLinks( pDB,
                                          pAC,
                                          usnEarliest,
                                          FALSE, /* only forward links */
                                          ulTickToTimeOut,
                                          pcLinksProcessed );
            goto cleanup;
        }

        if ( ((groupType & GROUP_TYPE_UNIVERSAL_GROUP) == 0) &&
             ((it & IT_WRITE) == 0) ) {

            // Group type is now non-universal in a writeable NC
            // Remove forward links in a non-replicable way
            DPRINT1( 1, "Cleaning object %s: a group which recently stopped being universal\n",
                     GetExtDN( pDB->pTHS, pDB ) );

            fMoreData = removeDeletedObjectLinks( pDB,
                                                  pAC,
                                                  FALSE /* don't remove backlinks */,
                                                  ulTickToTimeOut,
                                                  pcLinksProcessed );
            goto cleanup;
        } 
    }

    //
    // Work order type #4
    // A protected object has been revived. Touch all links, forward and backward.
    //

    // Detect a revived object. We know that since step #2 was not done, the
    // object is not deleted now.
    if (hasPropertyMetaDataChanged( ATT_IS_DELETED,
                                    pMetaDataVec,
                                    &usnEarliest )) {

        // We can conclude that the IS_DELETED attribute was present at one time
        // but has been removed, since the object is now not deleted,
        // but still has metadata.
        DPRINT1( 1, "Cleaning object %s: recently revived from the dead.\n",
                 GetExtDN( pDB->pTHS, pDB ) );

        fMoreData = touchObjectLinks( pDB,
                                      NULL /* all attributes */,
                                      usnEarliest,
                                      TRUE, /* forward and backward links */
                                      ulTickToTimeOut,
                                      pcLinksProcessed );

        goto cleanup;
    }
  
    // The object was marked for cleaning, but no work could be found.
    // This is not necessarily an error condition.
    // If a GC is rapidly demoted and promoted before the link cleaner
    // can run, some links may have been marked for cleaning which is no
    // longer necessary.

    DPRINT1( 0, "Object %s does not need cleaning.\n",
             GetExtDN( pDB->pTHS, pDB ) );

    // We've done all we can with this unknown object
    fMoreData = FALSE;

cleanup:

    // Be heap friendly
    if (NULL != pMetaDataVec) {
        THFreeEx(pDB->pTHS, pMetaDataVec);
    }

    return fMoreData;

} /* cleanObject */


BOOL
LinkCleanup(
    THSTATE *pTHS
    )

/*++

Routine Description:

   This is the worker routine for the link cleanup task

Arguments:

    pDB - database position

Return Value:

    BOOL - more work available flag
    Set pTHS->errCode and pTHS->pErrInfo

--*/

{
    DWORD err, cLinksProcessed;
    DWORD cTickStart, cTickDiff = 0, cSecDiff = 0;
    ULONG ulTickToTimeOut;
    BOOL fMoreData = FALSE;

    DPRINT( 1, "Link cleanup task start\n" );

    cTickStart = GetTickCount();
    ulTickToTimeOut = cTickStart + gulDraMaxTicksForLinkCleaner;

    DBOpen(&pTHS->pDB);
    __try {

        cLinksProcessed = 0;

        while (!DBGetNextObjectNeedingCleaning( pTHS->pDB )) {

            fMoreData = cleanObject( pTHS->pDB, ulTickToTimeOut, &cLinksProcessed );

            if (!fMoreData) {
                // Object is clean now (this will implicitly remove
                // the object from SZCLEANINDEX)
                DBSetObjectNeedsCleaning( pTHS->pDB, FALSE );

                DBTransOut(pTHS->pDB, TRUE, TRUE);
                DBTransIn(pTHS->pDB);

                // Currency is lost after this
            } else {
                // Lower layers stopped prematurely. We must be done.
                break;
            }
        }
    }
    __finally
    {
        // Commit depending on whether an exception occurred
        DBClose(pTHS->pDB, !AbnormalTermination());

        cTickDiff = GetTickCount() - cTickStart;
        cSecDiff = cTickDiff / 1000;
    }

    DPRINT2( cLinksProcessed ? 0 : 1,
             "Link cleanup task finish, %d links processed, %d secs\n",
             cLinksProcessed, cSecDiff );

    return fMoreData;
} /* LinkCleanup */

void
LinkCleanupMain(
    void *  pv, 
    void ** ppvNext, 
    DWORD * pcSecsUntilNextIteration
    )
/*++

Routine Description:

    Link Cleanup Main Function

    This is the main funcion of link cleanup. It will be scheduled by 
    Task Scheduler when the time is out. 
    
    There are two types of LinkCleanup tasks. One is the recurring task,
    which is scheduled at startup. The other one is a one-time task, which
    is triggered when we write an object which requires cleaning. The recurring 
    task will always reschedule itself in SECONDS_UNTIL_NEXT_ITERATION_NB,
    while the non-recurring task will not reschedule itself when it determines 
    there's no more work left.
    
    The recurring task is distinguished by pv == (PVOID)TRUE. It will pass this param
    value into the next iteration.
    
    The non-recurring task can be triggered synchronously from LinkCleanupControl.
    In this case, the pv is used to return data indicating whether there's more
    cleaning left to do. In this case, pv is pointing to a boolean stack variable.
    Thus, we are guaranteed it will never be confused with (PVOID)TRUE.

Parameters:

    pv - pointer to boolean to return whether there is more work 
         (for triggered tasks only).

    ppvNext - NULL (no use).

Return Values:

    None.
    Set pTHS->errCode and pTHS->pErrInfo

--*/

{
    THSTATE     *pTHS = pTHStls;
    BOOL fMoreData = TRUE;
    BOOL fRecurringTask;
    DWORD dwException;
    ULONG ulErrorCode = 0;
    ULONG dsid;
    PVOID dwEA;

    __try {

        Assert(NULL == pTHS->pDB);

        if (gfLinkCleanerIsEnabled) {
            fMoreData = LinkCleanup( pTHS );
        } else {
            DPRINT( 0, "Link Cleaner did not run because it is disabled.\n" );
            fMoreData = FALSE;
        }

        Assert(NULL == pTHS->pDB);

    } __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        DPRINT2( 0, "Exception caught inside link cleanup task, status = %d, dsid = %x\n",
                 ulErrorCode, dsid );

        // WriteConflict is a legitimate possible error. Simply let the task
        // exit quietly and it will be rescheduled.

        if ( ((int)ulErrorCode) != JET_errWriteConflict ) {
            Assert( !"Link Cleanup Task got exception" );

            LogEvent8(DS_EVENT_CAT_GARBAGE_COLLECTION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_LINK_CLEAN_END_ABNORMAL,
                      szInsertWin32ErrCode(ulErrorCode),
                      szInsertUL(dsid),
                      szInsertWin32Msg(ulErrorCode),
                      NULL, NULL, NULL, NULL, NULL );

            pTHS->errCode = ulErrorCode;
        }
    }

    fRecurringTask = pv == (PVOID)TRUE;

    if (fRecurringTask) {
        // pass the flag to the next iteration
        *ppvNext = pv;
    }
    else {
        // Return indicator to caller
        // Note that it only makes sense for the caller to read OUT parameters
        // such as this one when he is synchronized with the execution of the
        // task. Otherwise, he will not know when the parameter has been written.
        if (pv) {
            *((BOOL *) pv) = fMoreData;
        }
        *ppvNext = NULL;
    }


    if (fMoreData) {
        *pcSecsUntilNextIteration =
            ( ulErrorCode ?
              SECONDS_UNTIL_NEXT_ITERATION_FAILURE :
              SECONDS_UNTIL_NEXT_ITERATION_BUSY);
    } else {
        *pcSecsUntilNextIteration = fRecurringTask ? SECONDS_UNTIL_NEXT_ITERATION_NB : TASKQ_DONT_RESCHEDULE;
    }

    return;
}


#if DBG
DWORD
dsaEnableLinkCleaner(
    IN BOOL fEnable
    )

/*++

Routine Description:

    Method to set link cleaner enable/disable

Arguments:

    None

Return Value:

    None

--*/

{
    gfLinkCleanerIsEnabled = fEnable;
    if (fEnable) {
        gcLinksProcessedImmediately = DB_COUNT_LINKS_PROCESSED_IMMEDIATELY;
    } else {
        gcLinksProcessedImmediately = 2;
    }
    DPRINT1( 0, "Test hook: Link Cleaner is %s\n", fEnable ? "enabled" : "disabled" );
    DPRINT1( 0, "\tNumber of links processed immediately: %d\n", gcLinksProcessedImmediately );

    return ERROR_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\imperson.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       imperson.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


#define SECURITY_WIN32
#include <sspi.h>
#include <kerberos.h>
#include <samisrv2.h>
#include <ntdsa.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <dsconfig.h>
#include <mdcodes.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <debug.h>

#include <fileno.h>

#define  FILENO FILENO_IMPERSON

ULONG
AuthenticateSecBufferDesc(
    VOID    *pv
    )
/*++

  Routine Description:

    Authenticates a delegated client as identified by the offered
    SecBufferDesc and places the resulting CtxtHandle in pTHStls.
    N.B. You can only do this once per SecBufferDesc else Kerberos
    will punt you thinking you are replaying an authentication.
    However, we may ImpersonateSecurityContext and RevertSecurityContext
    on the resulting CtxtHandle as often as we wish.

  Parameters:

    pAuthData - Pointer to SecBufferDesc describing impersonated, remote
        client.  Eg: See GetRemoteAddCredentials.

  Return Values:

    0 on success, WIN32 error code otherwise.
    Sets pTHStls->pCtxtHandle on success.

--*/
{
    THSTATE                 *pTHS = pTHStls;
    SecBufferDesc           *pAuthData = (SecBufferDesc *) pv;
    CtxtHandle              *pCtxtHandle;
    SECURITY_STATUS         secErr = SEC_E_OK;
    CredHandle              hSelf;
    TimeStamp               ts;
    ULONG                   clientAttrs;
    SecBufferDesc           secBufferDesc;
    ULONG                   i;

    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->pCtxtHandle);
    Assert(0 == SEC_E_OK);

    // If we have an authz context on the thread state, we should get rid of it
    // since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);

    if ( NULL == (pCtxtHandle = THAlloc(sizeof(CtxtHandle))) )
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    secErr = AcquireCredentialsHandleA(
                            NULL,                       // pszPrincipal
                            MICROSOFT_KERBEROS_NAME_A,  // pszPackage
                            SECPKG_CRED_INBOUND,        // fCredentialUse
                            NULL,                       // pvLogonId
                            NULL,                       // pAuthData
                            NULL,                       // pGetKeyFn
                            NULL,                       // pvGetKeyArgument
                            &hSelf,                     // phCredential
                            &ts);                       // ptsExpiry

    if ( SEC_E_OK == secErr )
    {
        memset(&secBufferDesc, 0, sizeof(SecBufferDesc));
        secErr = AcceptSecurityContext(
                                &hSelf,                 // phCredential
                                NULL,                   // phContext
                                pAuthData,              // pInput,
                                ASC_REQ_ALLOCATE_MEMORY,// fContextReq
                                SECURITY_NATIVE_DREP,   // TargetDataRep
                                pCtxtHandle,            // phNewContext
                                &secBufferDesc,         // pOutput
                                &clientAttrs,           // pfContextAttr
                                &ts);                   // ptsExpiry

        // SecBufferDesc may get filled in on either error or success.
        for ( i = 0; i < secBufferDesc.cBuffers; i++ )
        {
            FreeContextBuffer(secBufferDesc.pBuffers[i].pvBuffer);
        }

        FreeCredentialsHandle(&hSelf);
    }

    if ( SEC_E_OK != secErr )
    {
        THFree(pCtxtHandle);
        pTHS->pCtxtHandle = NULL;
        return(secErr);
    }
    

    pTHS->pCtxtHandle = pCtxtHandle;
    return(SEC_E_OK);
}

ULONG
ImpersonateSecBufferDesc(
    )
/*++

  Routine Description:

    Impersonates a delegated client as identified by pTHStls->pCtxtHandle.

  Parameters:

  Return Values:

    0 on success, !0 otherwise

--*/
{
    THSTATE                 *pTHS = pTHStls;
    SECURITY_STATUS         secErr = SEC_E_OK;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->pCtxtHandle);
    Assert(0 == SEC_E_OK);

    return(secErr = ImpersonateSecurityContext(pTHS->pCtxtHandle));
}

VOID
RevertSecBufferDesc(
    )
{
    THSTATE *pTHS = pTHStls;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->pCtxtHandle);

    // If we have an authz context on the thread state, we should get rid of it
    // since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    
    RevertSecurityContext(pTHS->pCtxtHandle);
}

DWORD
ImpersonateAnyClient(void)

/*++

Routine Description:

    Impersonate the client whether they be users of the SSP package
    (e.g. LDAP) or RPC or delegation.

Arguments:

    None.

Return Value:

    A win32 error code (0 on success, !0 otherwise).

--*/

{
    CtxtHandle      *phSecurityContext;
    DWORD           error;
    NTSTATUS        status;
    THSTATE         *pTHS;

    // Do only the RPC case in case this is called by something other than
    // core DS code which doesn't have thread state.

    pTHS = pTHStls;
    if ( NULL == pTHS )
    {
        // RPC can access violate in RpcImpersonateClient if this
        // is not an RPC thread.

        __try
        {
            error = RpcImpersonateClient(NULL);
        }
        __except (HandleAllExceptions(GetExceptionCode()))
        {
            // Don't use GetExceptionCode, it's not guaranteed to be a win32
            // error
            error = ERROR_CANNOT_IMPERSONATE;
        }

        return error;
    }

    // Thread state case.  It is a logic error if you attempt to
    // impersonate while already impersonating.  We also don't expect
    // more than one kind of credentials at once either.
    Assert(VALID_THSTATE(pTHS));
    Assert(ImpersonateNone == pTHS->impState);
    Assert(!(pTHS->phSecurityContext && pTHS->pCtxtHandle));


    // If we have an authz context on the thread state, we should get rid of it
    // since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);

    // Check for SSP case.
    phSecurityContext = (CtxtHandle *) pTHS->phSecurityContext;

    if ( NULL != phSecurityContext )
    {
        if ( 0 == ImpersonateSecurityContext(phSecurityContext) )
        {
            pTHS->impState = ImpersonateSspClient;
            return(0);
        }

        return(ERROR_CANNOT_IMPERSONATE);
    }

    // Check for delegation case.

    if ( NULL != pTHS->pCtxtHandle )
    {
        if ( 0 == ImpersonateSecBufferDesc() )
        {
            pTHS->impState = ImpersonateDelegatedClient;
            return(0);
        }

        return(ERROR_CANNOT_IMPERSONATE);
    }

    // Try RPC next.

    __try
    {
        error = RpcImpersonateClient(NULL);
    }
    __except (HandleAllExceptions(GetExceptionCode()))
    {
        // Don't use GetExceptionCode, it's not guaranteed to be a win32 error
        error = ERROR_CANNOT_IMPERSONATE;
    }

    switch(error) {
    case RPC_S_OK:
        pTHS->impState = ImpersonateRpcClient;
        break;

    case RPC_S_NO_CALL_ACTIVE:
    case RPC_S_CANNOT_SUPPORT:
        status = SamIImpersonateNullSession();

        if ( NT_SUCCESS(status) ) {
            pTHS->impState = ImpersonateNullSession;
            error = 0;
        }
        else {
            error = ERROR_CANNOT_IMPERSONATE;
        }
        break;

    default:
        break;
    }

    return error;

}

VOID
UnImpersonateAnyClient(void)

/*++

Routine Description:

    Stop impersonating someone we impersonated via ImpersonateAnyClient.

Arguments:

    None.

Return Value:

    None.

--*/

{
    THSTATE *pTHS = pTHStls;
    
    // Do only the RPC case in case this is called by something other than
    // core DS code which doesn't have thread state.

    if ( NULL == pTHS )
    {
        RpcRevertToSelf();
        return;
    }

    // Thread state case.


    // If we have an authz context on the thread state, we should get rid of it
    // since we are going to change context, and don't want to reuse it.
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    
    switch ( pTHS->impState )
    {
    case ImpersonateNullSession:

        SamIRevertNullSession();
        break;

    case ImpersonateRpcClient:

        RpcRevertToSelf();
        break;

    case ImpersonateSspClient:

        RevertSecurityContext((CtxtHandle *) pTHS->phSecurityContext);
        break;

    case ImpersonateDelegatedClient:

        RevertSecBufferDesc();
        break;

    default:

        Assert(!"Invalid impersonation state");
        break;
    }

    pTHS->impState = ImpersonateNone;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\gcverify.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gcverify.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file implements routines for verifying non-local, DSNAME-valued 
    attributes against the global catalog (GC).  These routines are not
    a replacement for name resolution (DoNameRes) and are intended to
    be called outside of transaction scope.  I.e. A valid thread state
    exists, but a DBPOS doesn't.
    
    The general problem is that we wish to have references to objects which
    are off machine.  Except for a small variety of special cases (see
    VerifyDSNameAtts) we do not want to trust the DSNAME the caller has
    presented.  Specifically, we want to verify that the DSNAME represents
    an actual object in the enterprise and subsequently insure that the
    resulting phantom has the GUID, SID, whatever of the real object.
    The net result is that a phantom's name may go stale, but at least
    it will always have the right identity and a (historically) correct SID.
    
    These routines run outside of transaction scope so as not to extend
    the duration of a transaction unnecessarily.  This is based on the
    observation that finding a GC or making an RPC call to the GC may block 
    the current thread for an arbitrarily long time.

Author:

    DaveStr     13-Mar-1997

Environment:

    User Mode - Win32

Revision History:

    BrettSh     10-Oct-2000     Made changes so we could verify that
        and nCName attribute wouldn't have a conflict when creating the
        cross-ref.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

// External headers
#include <winsock2.h>           // needed for DSGetDcOpen/Next/Close
#include <dsgetdc.h>            // DSGetDcName

// NT headers
#include <ntrtl.h>              // generic table package
#include <lmcons.h>             // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>           // NetApiBufferFree()
#include <nlwrap.h>             // (ds)DsrGetDcNameEx2()

#include <windns.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <anchor.h>
#include <drsuapi.h>            // I_DRSVerifyNames
#include <gcverify.h>
#include <dominfo.h>
#include <prefix.h>
#include <cracknam.h>
#include <nsp_both.h>              // CP_WINUNICODE
#include <dstaskq.h>

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected atts
#include "debug.h"              // standard debugging header
#include "dsconfig.h"           // DEFAULT_GCVERIFY_XXX constants
#define DEBSUB "GCVERIFY:"      // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_GCVERIFY

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Definitions for stack of DSNAME pointers                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#define ARRAY_COUNT(x) ((sizeof(x))/(sizeof(x[0])))
// Rather than remote to the GC for each DSNAME which needs to be verified,
// we batch up all DSNAMEs in a stack structure which leverages the 
// SINGLE_LIST_ENTRY macros in ntrtl.h.

typedef struct StackOfPDSNAME
{
    SINGLE_LIST_ENTRY   sle;
    PDSNAME             pDSName;
} StackOfPDSNAME;

typedef struct GCVERIFY_ENTRY
{
    ENTINF *pEntInf;
    CHAR   *pDSMapped;
} GCVERIFY_ENTRY;

//
// Global from draserv.c to expose registry enabling of xforest features
// in forests prior to DS_BEHAVIOR_WIN_DOT_NET 
//
extern DWORD gEnableXForest;  

#define EMPTY_STACK { NULL, NULL }

VOID
PushDN(
    StackOfPDSNAME  *pHead, 
    StackOfPDSNAME  *pEntry)
{
    PushEntryList((SINGLE_LIST_ENTRY *) pHead,
                  (SINGLE_LIST_ENTRY *) pEntry);
}

StackOfPDSNAME *
PopDN(
    StackOfPDSNAME  *pHead) 
{
    StackOfPDSNAME  *pEntry;

    pEntry = (StackOfPDSNAME * ) 
                    PopEntryList((SINGLE_LIST_ENTRY *) pHead);
    return(pEntry);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Prototypes for local functions                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

PVOID
GCVerifyCacheAllocate(
    RTL_GENERIC_TABLE   *Table,
    CLONG               ByteSize);

VOID
GCVerifyCacheFree(
    RTL_GENERIC_TABLE   *Table,
    PVOID               Buffer);

RTL_GENERIC_COMPARE_RESULTS
GCVerifyCacheNameCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct);

RTL_GENERIC_COMPARE_RESULTS
GCVerifyCacheGuidCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct);

RTL_GENERIC_COMPARE_RESULTS
GCVerifyCacheSidCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct);

ULONG
GCVerifyDSNames(
    StackOfPDSNAME      *stack,
    COMMARG             *pCommArg);

BOOL
IsClientHintAKnownDC(
    THSTATE             *pTHS,
    PWCHAR              pVerifyHint);

BOOL isDCInvalidated(PWCHAR pDCName);

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SetGCVerifySvcError implementation                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#define SetGCVerifySvcError(dwErr) DoSetGCVerifySvcError(dwErr, DSID(FILENO, __LINE__))

ULONG
DoSetGCVerifySvcError(DWORD dwErr, DWORD dsid)
{
    static DWORD s_ulLastTickEventLogged = 0;
    const DWORD ulNoGCLogPeriod = 60*1000; // 1 minute
    DWORD ulCurrentTick = GetTickCount();
    
    DoSetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_GCVERIFY_ERROR, dwErr, dsid);

    if ((0 == s_ulLastTickEventLogged)
        || ((ulCurrentTick - s_ulLastTickEventLogged) > ulNoGCLogPeriod)) {
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GCVERIFY_ERROR,
                 szInsertHex(dsid),
                 szInsertWin32ErrCode(dwErr),
                 szInsertWin32Msg(dwErr));
        s_ulLastTickEventLogged = ulCurrentTick;
    }

    return(pTHStls->errCode);
}

ULONG
SetDCVerifySvcError(
    LPWSTR    pszServerName,
    WCHAR *   wszNcDns,
    ULONG     dwErr,
    DWORD     dsid
    )
{
    static DWORD s_ulLastTickEventLogged = 0;
    const DWORD ulNoLogPeriod = 60*1000; // 1 minute
    DWORD ulCurrentTick = GetTickCount();
    
    DoSetSvcError(SV_PROBLEM_UNAVAILABLE, 
                  ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD, 
                  dwErr, dsid);
                                     
    if ((0 == s_ulLastTickEventLogged)
        || ((ulCurrentTick - s_ulLastTickEventLogged) > ulNoLogPeriod)) {
        LogEvent8(DS_EVENT_CAT_NAME_RESOLUTION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_VERIFY_BY_CRACK_ERROR,
                  szInsertWC(wszNcDns),
                  szInsertWin32ErrCode(dwErr),
                  szInsertHex(dsid),
                  szInsertWin32Msg(dwErr),
                  szInsertWC(pszServerName),
                  NULL, NULL, NULL );
        s_ulLastTickEventLogged = ulCurrentTick;
    }
    
    return(pTHStls->errCode);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DSNAME cache implementation                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// Successfully verified names are cached in the thread state so that
// they can be referenced in VerifyDsnameAtts().  The RTL_GENERIC_TABLE
// package is used so as to avoid reinventing the wheel.  This package
// requires an allocator, deallocator, and comparator as provided below.
// Note that the cached, verified DSNAME may be "better" than the DSNAME
// provided in the call arguments as it contains a verified GUID and
// perhaps a SID.

typedef struct 
{
    RTL_GENERIC_TABLE SortedByNameTable;
    RTL_GENERIC_TABLE SortedByGuidTable;
    RTL_GENERIC_TABLE SortedBySidTable;
} GCVERIFY_CACHE;

PVOID
GCVerifyCacheAllocate(
    RTL_GENERIC_TABLE   *Table,
    CLONG               ByteSize)
{
    THSTATE *pTHS=pTHStls;
    return(THAllocEx(pTHS, ByteSize));
}

VOID
GCVerifyCacheFree(
    RTL_GENERIC_TABLE   *Table,
    PVOID               Buffer)
{
    THFree(Buffer);
}

RTL_GENERIC_COMPARE_RESULTS
GCVerifyCacheNameCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct)
{
    
    CHAR      *pDN1 = ((GCVERIFY_ENTRY *) FirstStruct)->pDSMapped;
    CHAR      *pDN2 = ((GCVERIFY_ENTRY *) SecondStruct)->pDSMapped;
    int         diff;

    if ( 0 == (diff = strcmp(pDN1, pDN2)) )
    {
        return(GenericEqual);
    }
    else if ( diff > 0 )
    {
        return(GenericGreaterThan);
    }

    return(GenericLessThan);
}

RTL_GENERIC_COMPARE_RESULTS
GCVerifyCacheGuidCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct)
{
    DSNAME      *pDN1 = ((GCVERIFY_ENTRY *) FirstStruct)->pEntInf->pName;
    DSNAME      *pDN2 = ((GCVERIFY_ENTRY *) SecondStruct)->pEntInf->pName;
    int         diff;

    diff = memcmp(&pDN1->Guid, &pDN2->Guid, sizeof(GUID)); 
    if (0==diff)
        return (GenericEqual);
    else if ( diff>0)
        return (GenericGreaterThan);
    else
        return(GenericLessThan);
}

RTL_GENERIC_COMPARE_RESULTS
GCVerifyCacheSidCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct)
{
    DSNAME      *pDN1 = ((GCVERIFY_ENTRY *) FirstStruct)->pEntInf->pName;
    DSNAME      *pDN2 = ((GCVERIFY_ENTRY *) SecondStruct)->pEntInf->pName;
    int         diff;


    Assert((pDN1->SidLen>0)&&(pDN1->SidLen==RtlLengthSid(&pDN1->Sid))
                && (RtlValidSid(&pDN1->Sid)));
    Assert((pDN2->SidLen>0)&&(pDN2->SidLen==RtlLengthSid(&pDN2->Sid))
                && (RtlValidSid(&pDN2->Sid)));
    
    

    if (RtlEqualSid(&pDN1->Sid,&pDN2->Sid))
    {
        return GenericEqual;
    }

    if (RtlLengthSid(&pDN1->Sid)<RtlLengthSid(&pDN2->Sid))
    {
        return GenericLessThan;
    }
    else if (RtlLengthSid(&pDN1->Sid) > RtlLengthSid(&pDN2->Sid))
    {
        return GenericGreaterThan;
    }
    else
    {
        diff = memcmp(&pDN1->Sid,&pDN2->Sid,RtlLengthSid(&pDN1->Sid));
    }
   
    if (0==diff)
        return (GenericEqual);
    else if ( diff>0)
        return (GenericGreaterThan);
    else
        return(GenericLessThan);
}

VOID
GCVerifyCacheAdd(
    SCHEMA_PREFIX_MAP_HANDLE hPrefixMap,
    ENTINF * pEntInf)
{
    THSTATE *pTHS = pTHStls;
    GCVERIFY_CACHE *GCVerifyCache;
    GCVERIFY_ENTRY *pGCEntry;

    //
    // The passed in EntInf should have a name
    //

    Assert(NULL!=pEntInf->pName);

    //
    // Create a new GC verify Cache if one did not exist.
    //

    if ( NULL == pTHS->GCVerifyCache )
    {
        GCVerifyCache = (GCVERIFY_CACHE *) THAllocEx(pTHS, sizeof(GCVERIFY_CACHE));

        RtlInitializeGenericTable(
                        &GCVerifyCache->SortedByNameTable,
                        GCVerifyCacheNameCompare,
                        GCVerifyCacheAllocate,
                        GCVerifyCacheFree,
                        NULL);

        RtlInitializeGenericTable(
                        &GCVerifyCache->SortedByGuidTable,
                        GCVerifyCacheGuidCompare,
                        GCVerifyCacheAllocate,
                        GCVerifyCacheFree,
                        NULL);

        RtlInitializeGenericTable(
                        &GCVerifyCache->SortedBySidTable,
                        GCVerifyCacheSidCompare,
                        GCVerifyCacheAllocate,
                        GCVerifyCacheFree,
                        NULL);

        pTHS->GCVerifyCache = (PVOID) GCVerifyCache;
    }
    else
    {
        GCVerifyCache = (GCVERIFY_CACHE *) pTHS->GCVerifyCache;
    }

    //
    // Map embedded ATTRTYPs from remote to local values.
    //

    if ((NULL!=hPrefixMap) &&
        (!PrefixMapAttrBlock(hPrefixMap, &pEntInf->AttrBlock))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_DRA_SCHEMA_MISMATCH, 0);
    }


    pGCEntry = THAllocEx (pTHS, sizeof (GCVERIFY_ENTRY));

    pGCEntry->pEntInf = pEntInf;
    pGCEntry->pDSMapped = DSNAMEToMappedStr(pTHS, pEntInf->pName);

    //
    // If the name has a string name component, insert in to
    // the SortedByNameTable
    //

    if (pEntInf->pName->NameLen>0)
    {
        RtlInsertElementGenericTable(
                        &GCVerifyCache->SortedByNameTable,
                        pGCEntry,
                        sizeof (GCVERIFY_ENTRY),
                        NULL);                  // pfNewElement
    }

    //
    // If it has a GUID component, then insert into the SortedByGuidTable
    //

    if (!fNullUuid(&pEntInf->pName->Guid))
    {
        RtlInsertElementGenericTable(
                        &GCVerifyCache->SortedByGuidTable,
                        pGCEntry,
                        sizeof (GCVERIFY_ENTRY),
                        NULL);                  // pfNewElement
    }

    //
    // If it has a SID component , then insert into the SortedBySidTable
    //

    if (pEntInf->pName->SidLen>0)
    {
        RtlInsertElementGenericTable(
                        &GCVerifyCache->SortedBySidTable,
                        pGCEntry,
                        sizeof (GCVERIFY_ENTRY),
                        NULL);                  // pfNewElement
    }
}

ENTINF *
GCVerifyCacheLookup(
    DSNAME *pDSName)
{
    GCVERIFY_CACHE * GCVerifyCache;
    RTL_GENERIC_TABLE * Table = NULL;
    ENTINF EntInf;
    THSTATE * pTHS = pTHStls;
    ENTINF         *pEntInf = NULL;
    GCVERIFY_ENTRY GCEntry, *pGCEntry;

    if ( NULL == pTHS->GCVerifyCache )
        return(NULL);

    GCVerifyCache = (GCVERIFY_CACHE *) pTHS->GCVerifyCache;

    //
    // Get the table to use for the search, prefer GUIDs above
    // everything else, then the name, and lastly the SID
    //

    if (!fNullUuid(&pDSName->Guid))
        Table = &GCVerifyCache->SortedByGuidTable;
    else if (pDSName->NameLen>0)
        Table = &GCVerifyCache->SortedByNameTable;
    else if (pDSName->SidLen>0)
        Table = &GCVerifyCache->SortedBySidTable;

    if (NULL==Table)
        return (NULL);


    EntInf.pName = pDSName;
    GCEntry.pEntInf = &EntInf;
    GCEntry.pDSMapped = DSNAMEToMappedStr(pTHS, pDSName);

    pGCEntry = RtlLookupElementGenericTable(
                        Table,
                        &GCEntry);

    if (GCEntry.pDSMapped) {
        THFreeEx (pTHS, GCEntry.pDSMapped);
    }
    if (pGCEntry) {
        pEntInf = pGCEntry->pEntInf;
    }

    return pEntInf;
}

BOOL
LocalNcFullyInstantiated(
    THSTATE *    pTHS,
    DSNAME *     pdnNC
    )
/*++

Routine Description:

    This routine will figure out if the NC specified, is fully
    instantiated, by checking if it's either coming or going.
    
    NOTE: We expect _NOT_ to be in a transaction at this point.
    
Arguments:

    wszNcDns - DNS name of the NC.

Return value:

    TRUE if it's fully instatiated, FALSE otherwise.

--*/
{
    DWORD        dwErr;
    DWORD        it = 0; // Instance Type
    BOOL         fIsFullyInstantiated = FALSE;

    Assert(!pTHS->pDB);
    
    // Start a transaction
    SYNC_TRANS_READ();   /*Identify a reader trans*/
    __try{


        dwErr = DBFindDSName(pTHS->pDB, pdnNC);

        if (dwErr) {
            DPRINT2(0,"Error %8.8X finding NC %S!! Should've found this.\n", dwErr, pdnNC->StringName);
            LooseAssert(!"Error finding NC that we just found in the catalog.",
                        GlobalKnowledgeCommitDelay);
            // Presume we don't have it, and then we'll go remotely.
            __leave;
        }

        dwErr = DBGetSingleValue(pTHS->pDB,
                                 ATT_INSTANCE_TYPE,
                                 &it,
                                 sizeof(it),
                                 NULL);

        if(dwErr){
            // If there is an error, we just presume this isn't a good NC,
            // and just return is not fully instantiated.
            Assert(!"Error getting the instanceType attribute off a found NC");
            __leave;
        } 

        // Return TRUE if the instanceType is neither coming or going.
        Assert(it & IT_NC_HEAD);
        fIsFullyInstantiated = (it & IT_NC_HEAD) && !((it & IT_NC_COMING) || (it & IT_NC_GOING));

    } __finally{

        // Exit transaction
        CLEAN_BEFORE_RETURN(dwErr);

    }

    return(fIsFullyInstantiated);
}


BOOL
LocalDnsNc(
    THSTATE *    pTHS,
    WCHAR *      wszNcDns
    )
/*++

Routine Description:

    This routine determines if the NC is locally hosted or not.

    NOTE: This program will not work with Config/Schema NCs ...

Arguments:

    wszNcDns - DNS name of the NC.

Return value:

    TRUE if found locally, false otherwise.

--*/
{
    CROSS_REF *             pCR;
    NAMING_CONTEXT_LIST *   pNCL;
    NCL_ENUMERATOR          nclEnum;

    Assert(wszNcDns);
    
    pCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT, 
                                        FLAG_CR_NTDS_NC,
                                        wszNcDns);

    if(pCR){

        // Do we hold this NC?
        NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
        NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, pCR->pNC);
        pNCL = NCLEnumeratorGetNext(&nclEnum);
        Assert(NULL == NCLEnumeratorGetNext(&nclEnum)); 

        if(pNCL == NULL){
            // We don't hold this NC as a master, check if we hold it as 
            // read-only replica.
            NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
            NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, pCR->pNC);
            pNCL = NCLEnumeratorGetNext(&nclEnum);
            Assert(NULL == NCLEnumeratorGetNext(&nclEnum)); 
        }

        if(pNCL){

            // It's not enough that we merely find that the NC head is
            // instantiated locally, we must find that the NC is reasonably
            // up to date too, i.e. that it's FULLY instantiated.  This 
            // is done by checking the instanceType attr for the IT_NC_COMING
            // or the IT_NC_GOING flags.
            return(LocalNcFullyInstantiated(pTHS, pCR->pNC));

        }

    } // End if we found a CR for the DNS name.

            
    // Else we didn't find it locally, return FALSE
    return(FALSE);
}

ULONG
VerifyByCrack(
    IN   THSTATE *            pTHS,
    IN   WCHAR *              wszNcDns,
    IN   DWORD                dwFormatOffered,
    IN   WCHAR *              wszIn,
    OUT  DWORD                dwFormatDesired,
    OUT  PDS_NAME_RESULTW *   pResults,
    IN   BOOL                 fUseDomainForSpn
    )

/*++

Description:

    Does a local or remote DsCrackName to the address specified, for
    the format specified.

Arguments:

Returns:

    0 on success, !0 otherwise.
    Sets pTHStls->errCode on error.

--*/
{
    DWORD                       i, err = 0, errRpc;
    FIND_DC_INFO                 *pDCInfo = NULL;

    DRS_MSG_CRACKREQ            CrackReq;
    DRS_MSG_CRACKREPLY          CrackReply;
    DWORD                       dwReplyVersion;
    WCHAR *                     rpNames[1];

    PVOID                       pEA;
    ULONG                       ulErr, ulDSID;
    DWORD                       dwExceptCode;

    // We should have a valid thread state but not be
    // inside a transaction.
    
    Assert(NULL != pTHS);
    Assert(NULL == pTHS->pDB);
    Assert(NULL != pResults);
    Assert(wszIn);

    // Init the out param
    *pResults = NULL;
    __try  {
    
        // Construct DRSCrackName arguments.

        memset(&CrackReq, 0, sizeof(CrackReq));
        memset(&CrackReply, 0, sizeof(CrackReply));

        CrackReq.V1.CodePage = CP_WINUNICODE;
        // Does this call make any sense for local system?
        CrackReq.V1.LocaleId = GetUserDefaultLCID();
        CrackReq.V1.dwFlags = 0;
        CrackReq.V1.formatOffered = dwFormatOffered;
        CrackReq.V1.formatDesired = dwFormatDesired;
        CrackReq.V1.cNames = 1;
        CrackReq.V1.rpNames = rpNames;
        CrackReq.V1.rpNames[0] = wszIn;

        if (LocalDnsNc(pTHS, wszNcDns)){

            //
            // Perform CrackNames locally if we have this NC
            //
            __try {
                DWORD cNamesOut, cBytes;
                CrackedName *rCrackedNames = NULL;

                // Should not have an open transaction at this point
                Assert(NULL != pTHS);
                Assert(NULL == pTHS->pDB);
                Assert(0 == pTHS->transactionlevel);

                // begin a new transaction
                DBOpen2(TRUE, &pTHS->pDB);

                CrackNames( CrackReq.V1.dwFlags,
                            CrackReq.V1.CodePage,
                            CrackReq.V1.LocaleId,
                            CrackReq.V1.formatOffered,
                            CrackReq.V1.formatDesired,
                            CrackReq.V1.cNames,
                            CrackReq.V1.rpNames,
                            &cNamesOut,
                            &rCrackedNames );


                //
                // Make a PDS_NAME_RESULT structure
                //
                *pResults = (DS_NAME_RESULTW *) THAllocEx(pTHS, sizeof(DS_NAME_RESULTW));

                if ( (cNamesOut > 0) && rCrackedNames ) {

                    // Server side MIDL_user_allocate is same as THAlloc which
                    // also zeros memory by default.
                    cBytes = cNamesOut * sizeof(DS_NAME_RESULT_ITEMW);
                    (*pResults)->rItems =
                        (DS_NAME_RESULT_ITEMW *) THAllocEx(pTHS, cBytes);

                    for ( i = 0; i < cNamesOut; i++ ) {
                        (*pResults)->rItems[i].status =
                                                    rCrackedNames[i].status;
                        (*pResults)->rItems[i].pDomain =
                                                    rCrackedNames[i].pDnsDomain;
                        (*pResults)->rItems[i].pName =
                                                    rCrackedNames[i].pFormattedName;
                    }

                    THFreeEx(pTHS, rCrackedNames);
                    (*pResults)->cItems = cNamesOut;
                } else {

                    Assert( !"Unexpected return from CrackNames" );
                    err = SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
                    _leave;

                }

            } __finally {
                // close the transaction

                DBClose(pTHS->pDB,TRUE);
                pTHS->pDB=NULL;
            }

        } else {

            //
            // The Remote CrackNames case.
            //
            
            if ( err = FindDC(0, wszNcDns, &pDCInfo) ){
                Assert(0 != pTHS->errCode);
                err = pTHS->errCode;
                _leave;
            }
            __try {

                errRpc = I_DRSCrackNames(pTHS,
                                         pDCInfo->addr,
                                         (fUseDomainForSpn) ? FIND_DC_INFO_DOMAIN_NAME(pDCInfo) : NULL,
                                         1,
                                         &CrackReq,
                                         &dwReplyVersion,
                                         &CrackReply);

                Assert(errRpc || (1 == dwReplyVersion));

                if ( errRpc ){
                    
                    // Map errors to "unavailable".  From XDS spec, "unavailable"
                    // means "some part of the directory is currently not available."
                    err =  SetDCVerifySvcError(pDCInfo->addr,
                                               wszNcDns,
                                               errRpc,
                                               DSID(FILENO, __LINE__));
                    leave;
                }

                // Return the values in the ENTINF structure
                *pResults = CrackReply.V1.pResult;

            } __finally {

                THFreeEx(pTHS, pDCInfo);

            }

        } // End if/else Local/Remote CrackNames.

    } __except (GetExceptionData(GetExceptionInformation(), 
                                 &dwExceptCode, 
                                 &pEA, 
                                 &ulErr, 
                                 &ulDSID),
                // Note the use of the comma operator above.
                HandleMostExceptions(dwExceptCode)){

          err = SetDCVerifySvcError(
              pDCInfo && pDCInfo->addr ? pDCInfo->addr : L"",
              wszNcDns, ulErr, ulDSID);

    }

    return(err);
}

ULONG
PreTransVerifyNcName(
    THSTATE *                 pTHS,
    ADDCROSSREFINFO *         pCRInfo
    )

/*++

Description:

    This routine does not so much verify the nCName value, as it does just
    enough analysis of the nCName to determine if we need to go off machine
    before the transaction starts to check the nCName.
                      
    Verify the nCName value provided against the parent.  This verification
    needs to check two things:
        A) The parent is an instantiated object (probably a NC).
        B) There is no child object of the "parent NC/object", that would
            conflict with the nCName attr value were adding.

Arguments:

    pCRInfo - This is the zero initialized CR caching structure, that
        will be used by this function to cache all interesting 
        pre-transactional/remote data (i.e. A and B above).

Returns:

    0 on success.
    On error, sets pTHStls->errCode and returns it as well.

--*/

{
    CROSS_REF *                  pCR = NULL;
    ULONG                        ulRet = ERROR_SUCCESS;
    COMMARG                      CommArg;
    DSNAME *                     pdnParentNC = NULL;
    DS_NAME_RESULTW *            pdsrDnsName = NULL;
    DS_NAME_RESULTW *            pdsrQuery = NULL;
    WCHAR *                      pwszArrStr[1];
    WCHAR                        wsRdnBuff[MAX_RDN_SIZE+1];
    ULONG                        cchRdnLen;
    ATTRTYP                      RdnType;
    WCHAR *                      wszCanonicalChildName = NULL;
    ULONG                        cchCanonicalChildName = 0;
    ULONG                        cchTemp;
    BOOL                         fUseDomainForSpn = FALSE;

    Assert(pCRInfo != NULL);

    // For the purposes of making this function, we'll pretend we've got two
    // NCs of interest the NC we're trying to create called "child" 
    // henceforward, and the immediate parent NC called "parent" henceforward.
    //
    //   parent
    //     |-----child
    //
    // What needs to happen in the typical internal AD case, is we  need to 
    // check two things, whether:
    //
    //  A) The parent is instantiated.
    //  B) There is an object of any RDN Type conflicting with the child in
    //     the parent NC.
    //
    // If we're dealing with an external to the AD CR, then we only need to 
    // know (B).
    //
    
    // ---------------------------------------------------------------
    // 
    // First we need to retrieve some information

    // We need the best enclosing cross-ref.
    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindBestCrossRef(pCRInfo->pdnNcName, &CommArg);

    if(!pCR ||
       !(pCR->flags & FLAG_CR_NTDS_NC)){
        //
        // If we're here, we've one of 3 possibilites:
        // A) No CR, means outside the current AD name space.
        // B) CR has no NTDS_NC flag, meaning it's either an external CR or,
        // C) it's an internal to the AD name space CR in the disabled state.
        //
        // Irrelevant of the case, we don't need to go off machine to 
        // later be able to verify that the nCName is valid (at least
        // within a replication interval).  
        
        // NOTE: If we wanted to ensure even better validation, we could 
        // go off machine even if there's no NTDS_NC flag, just in case
        // the flag was updated because the NC was instantiated within
        // the last replication interval.
        return(ERROR_SUCCESS);
    }

    // Note if the NTDS_NC flag is set, it could still be an internal to
    // the AD name CR in the disabled state, but since it's difficult to
    // tell this, we'll just let us go off machine anyway, because these
    // cases are rare, and only happen for auto-created CRs in domain and
    // NDNC creations.  So within about a single replication interval is
    // the timing window which we could accidentally go off machine.  And
    // since the NC head is created so shortly thereafter anyway, it's 
    // actually probably a good idea to go off machine and check. ;)  There
    // is no harm in trying.  The reason is because the only way to create
    // and CR disabled with the NTDS_NC flag set, is to do it through the
    // RemoteAddOneObjectSimply() RPC API.

    // We need the Parent's DN
    pdnParentNC = THAllocEx(pTHS, pCRInfo->pdnNcName->structLen);
    if(TrimDSNameBy(pCRInfo->pdnNcName, 1, pdnParentNC)){
        // A non zero code means that we couldn't shorten this DN by 
        // even a single AVA, which means either the DN is root or the
        // DN is syntactically garbage.  Either way, we'll error out
        // later during DN validation.
        Assert(pCRInfo->wszChildCheck == NULL &&
               fNullUuid(&pCRInfo->ParentGuid));
        return(ERROR_SUCCESS);
    }

    // We need the RDN value of the bottom RDN of the child's DN.
    ulRet = GetRDNInfo(pTHS, pCRInfo->pdnNcName, wsRdnBuff, &cchRdnLen, &RdnType);
    if(ulRet){
        // If we can't crack the RDNType out of the DN, the DN is bad, so
        // lets just give up.  Either way, we'll error out later during
        // DN validation.
        Assert(pCRInfo->wszChildCheck == NULL &&
               fNullUuid(&pCRInfo->ParentGuid));
        return(ERROR_SUCCESS);
    }

    pwszArrStr[0] = pdnParentNC->StringName;
    ulRet = DsCrackNamesW(NULL,
                      DS_NAME_FLAG_SYNTACTICAL_ONLY,
                      DS_FQDN_1779_NAME,
                      DS_CANONICAL_NAME,
                      1,
                      pwszArrStr,
                      &pdsrDnsName);
    if(ulRet ||
       pdsrDnsName == NULL ||
       pdsrDnsName->cItems != 1 ||
       pdsrDnsName->rItems == NULL ||
       pdsrDnsName->rItems[0].status != DS_NAME_NO_ERROR){
        // Something was wrong with converting the parent's DN,
        // this means something must be wrong with the child's
        // DN which the parent's DN came from ... this error
        // will be caught later.
        Assert(pCRInfo->wszChildCheck == NULL &&
               fNullUuid(&pCRInfo->ParentGuid));
        return(ERROR_SUCCESS);
    }
    Assert(pdsrDnsName->rItems[0].pDomain);
    Assert(pdsrDnsName->rItems[0].pName);
    
    __try {                  

        // 234567890123456789012345678901234567890123456789012345678901234567890
        // BUGBUG Hack to make one easy and the most important sub-case work!
        // pdsrDnsName->rItems[0].pDomain (which is just the DNS name of 
        // pdnParentNC) will either be a Domain or an NDNC.  If this parent 
        // NC is a Domain it can be used for the SPN in binding.  If this
        // parent NC is a NDNC, then it can't be used for the SPN in binding.
        //
        // If you drill down into VerifyByCrack() you'll see a call to FindDC()
        // this is the call that returns a pDCInfo structure with the wrong 
        // :domain" for the server it returned in the NDNC.  Actually, it 
        // doesn't return a domain at all it returns the NDNC DNS name itself.
        //
        // So here is a good place to determine if we've got a domain or NDNC 
        // (it's harder to determine authoritatively in VerifyByCrack()) and 
        // pass a flag to VerifyByCrack() to tell it to use the domain returned
        // by FindDC.
        //
        // So the real solution is a change to FindDC() (and possible but
        // probably not to dsDsrGetDcNameEx2()) to actually give the right
        // domain.  This can be done by taking the server that was returned
        // by FindDC, and find out which domain it actually belongs to and
        // then use that Domain.
        //
        // Note because of Texaco style naming that we can't just trim the
        // server name off the DNS name of the DC, we've got to search for the
        // server object by the DNS name returned.  Find which server object(s)
        // have an active nTDSDSA object under them.  If there is more
        // than one, assert() and return an error.  If we find only one active
        // server, determine it's domain from this object, look up the 
        // crossRef and use the dNSRoot there.
        //
        // Yes, it's a bit long and complicated, so that's why were going with
        // the hack for now.

        // Set the flag fUseDomainForSpn if the parent NC we're going to be
        // looking at for the verification is a Domain.
        if(pCR &&
           NameMatchedStringNameOnly(pdnParentNC, pCR->pNC) &&
           (pCR->flags & FLAG_CR_NTDS_DOMAIN)) {
            fUseDomainForSpn = TRUE;
        } // Otherwise we assume it's an NDNC or there is no parent at all.

        // ----------------------------------------------------------
        // 
        // First check to see if the parent NC is instantiated.
        //
        
        ulRet = VerifyByCrack(pTHS,
                              pdsrDnsName->rItems[0].pDomain,
                              DS_FQDN_1779_NAME,
                              pdnParentNC->StringName,
                              DS_UNIQUE_ID_NAME,
                              &pdsrQuery,
                              fUseDomainForSpn);

        // Use the results!!!  Put them in the cache object.
        pCRInfo->ulDsCrackParent = ulRet;
        if(!ulRet){
            pCRInfo->ulParentCheck = pdsrQuery->rItems[0].status;
            if(pdsrQuery->rItems[0].status == DS_NAME_NO_ERROR &&
               pdsrQuery->rItems[0].pName){
                if(!IsStringGuid(pdsrQuery->rItems[0].pName, &pCRInfo->ParentGuid)){
                    // This seems odd, but it really isn't, because despite the name
                    // of IsStringGuid(), it also leaves the GUID in the second
                    // parameter, so we want the GUID, and we want to assert if this
                    // function fails.  We figure since we got this GUID directly from
                    // DsCrackNames() it should definately be good.
                    Assert(!"Huh! We just got this from DsCrackNames()");
                }
            } else {
                Assert(fNullUuid(&pCRInfo->ParentGuid));
            }
        }

        THClearErrors();
        // Make sure the DS didn't decide to shutdown on us while we were gone.
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

        
        if(pdsrQuery) { 
            THFreeEx(pTHS, pdsrQuery);
            pdsrQuery = NULL;
        }

        // ----------------------------------------------------------
        // 
        // Second check to see if there is a child object that 
        // conflicts with the child NcName we're trying to add.
        //

        // We need to construct a special canonical name to ask for,
        // a child with any RDN from CrackNames.
        // Ex: 
        //   "DC=ndnc-child,DC=ndnc-parent,DC=rootdom,DC=com"
        //         becomes.
        //   "ndnc-parent.rootdom.com/child-ndnc"

        cchCanonicalChildName = wcslen(pdsrDnsName->rItems[0].pName);
        wszCanonicalChildName = THAllocEx(pTHS, 
                   ((cchCanonicalChildName + 5 + cchRdnLen) * sizeof(WCHAR)) );
        memcpy(wszCanonicalChildName, pdsrDnsName->rItems[0].pName, 
               cchCanonicalChildName * sizeof(WCHAR));
        if(wszCanonicalChildName[cchCanonicalChildName-1] != L'/'){
            wszCanonicalChildName[cchCanonicalChildName] = L'/';
            cchCanonicalChildName++;
            // Should be null terminated via THAllocEx()
        }
        memcpy(&(wszCanonicalChildName[cchCanonicalChildName]),
               wsRdnBuff,
               cchRdnLen * sizeof(WCHAR));
        
        
        // DsCrackNames on (pdnParentNC\pdnNcNameChild for DN)
        //
        // This call is to verify that there is no child with any RDNType and
        // the same name under the parent NC.

        ulRet = VerifyByCrack(pTHS,
                              pdsrDnsName->rItems[0].pDomain,
                              DS_CANONICAL_NAME,
                              wszCanonicalChildName,
                              DS_FQDN_1779_NAME,
                              &pdsrQuery,
                              fUseDomainForSpn);

        // Use the results!!!  Put them in the cache object.
        pCRInfo->ulDsCrackChild = ulRet;
        if(!ulRet){
            pCRInfo->ulChildCheck = pdsrQuery->rItems[0].status;
            if(pdsrQuery->rItems[0].status == DS_NAME_NO_ERROR &&
               pdsrQuery->rItems[0].pName){
                pCRInfo->wszChildCheck = THAllocEx(pTHS, 
                           (sizeof(WCHAR) * (1 + wcslen(pdsrQuery->rItems[0].pName))));
                wcscpy(pCRInfo->wszChildCheck, pdsrQuery->rItems[0].pName);
            } else {
                pCRInfo->wszChildCheck = NULL;
            }
        }

        THClearErrors();
        // Make sure the DS didn't decide to shutdown on us while we were gone.
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }


    } __finally {
        if(pdsrDnsName) { DsFreeNameResultW(pdsrDnsName); }
        if(pdsrQuery) { 
            THFreeEx(pTHS, pdsrQuery);
            pdsrQuery = NULL;
        }
        if(wszCanonicalChildName) { 
            THFreeEx(pTHS, wszCanonicalChildName);
        }
    }
    THFreeEx(pTHS, pdnParentNC);

    return(pTHS->errCode);
}

/*++
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Dir API name verification routines                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// The following routines are intended to be called inside the similarly
// named Dir* call, but outside the transaction scope.  They can throw
// exceptions and set pTHStls->errCode on error.  The biggest flaw with
// the current approach is that we have not performed DoNameRes on the
// base object being added/modified before verifying DSNAME-valued 
// properties against the GC.  In practice though, we expect the bulk
// of DSNAME-valued properties to NOT be off machine.  So the wasted
// verification (and time) only occurs when both the base object would
// fail DoNameRes AND there are non-local, DSNAME-valued properties.
*/
ULONG
GCVerifyDirAddEntry(
    ADDARG *pAddArg)
{
    THSTATE         *pTHS = pTHStls;
    StackOfPDSNAME  stack = EMPTY_STACK;
    ULONG           cVerify = 0;
    StackOfPDSNAME  *pEntry;
    ATTRTYP         type;
    ULONG           attr;
    ULONG           val;
    ATTR            *pAttr;
    ATTRVAL         *pAVal;
    DSNAME          *pDN;
    DSNAME          **ppDN;
    ATTCACHE        *pAC;
    DSNAME          *pParentNC = NULL;
    // Note by default if the Enabled attr isn't present, it's presumed 
    // Enabled = TRUE basically.  This is set in the variable decls above.
    BOOL            bEnabled = TRUE;
    ULONG           ulSysFlags = 0;
    GUID*           pObjGuid = NULL;
      
    Assert(NULL != pAddArg);
    Assert(NULL != pTHS);
    Assert((NULL == pTHS->GCVerifyCache)||(pTHS->fSAM)||(pTHS->fPhantomDaemon));
    Assert(NULL == pAddArg->pCRInfo);

    if ( DsaIsInstalling() )
        return(0);

    // Don't go off machine if the caller is SAM, a trusted in-process client,
    // or a multiple-operations-in-a-single-transaction situation.  Also not
    // for cross domain move.  See comments in mdmoddn.c.

    if (pTHS->fSAM || 
        pTHS->fDSA ||
        (TRANSACT_BEGIN_END != pTHS->transControl) ||
        pTHS->fCrossDomainMove) {
        return(0);
    }

    // This assert has to go here as there may be a pDB open if
    // someone is using DirTransactControl().

    Assert(NULL == pTHS->pDB);

    for ( attr = 0, pAttr = pAddArg->AttrBlock.pAttr;
          attr < pAddArg->AttrBlock.attrCount; 
          attr++, pAttr++ )
    {
        if (!(pAC = SCGetAttById(pTHS, pAttr->attrTyp)))
        {
            SetAttError(pAddArg->pObject,
                        pAttr->attrTyp,
                        PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                        DIRERR_ATT_NOT_DEF_IN_SCHEMA); 
            return(pTHS->errCode);
        }

        pAVal = pAttr->AttrVal.pAVal;

        switch (pAC->id) {
        case ATT_ENABLED:
            // Cache the Enabled attribute, because this might be a CR.
            bEnabled = *((BOOL *) pAVal[0].pVal);
            break;
        case ATT_SYSTEM_FLAGS:
            ulSysFlags = *((ULONG *) pAVal[0].pVal);
            break;
        case ATT_OBJECT_GUID:
            // user has specified a GUID for the new object. Check that this
            // GUID is not in use. Only check if it actually looks like a GUID.
            if (pAVal[0].valLen == sizeof(GUID)) {
                pObjGuid = (GUID*)pAVal[0].pVal;
            }
            break;
        }

        for ( val = 0; val < pAttr->AttrVal.valCount; val++, pAVal++ )
        {
            pDN = DSNameFromAttrVal(pAC, pAVal);

            if ( NULL != pDN )
            {

                if(pAC->id == ATT_NC_NAME){

                    // In this case, we're adding a crossRef, with an nCName
                    // attribute and we may need to do additional verification
                    // to ensure this DN can be added.  Create the pCRInfo
                    // struct.

                    // This'll be THFreeEx()'d by VerfiyNcName()
                    pAddArg->pCRInfo = THAllocEx(pTHS, sizeof(ADDCROSSREFINFO));
                    pAddArg->pCRInfo->pdnNcName = pDN;
                }

                pEntry = (StackOfPDSNAME *) THAllocEx(pTHS, sizeof(StackOfPDSNAME));
                pEntry->pDSName = pDN;
                PushDN(&stack, pEntry);
                cVerify++;
            }
        }
    }

    if (!fNullUuid(&pAddArg->pObject->Guid)) {
        // if this guid does not match the one specified in
        // the attribute list (if any), then we will fail
        // later on in LocalAdd. Right now, let's just check
        // this GUID.
        pObjGuid = &pAddArg->pObject->Guid;
    }

    if (pObjGuid) {
        // user has specified a GUID for the new object. Verify
        // the GUID-based name
        pDN = (PDSNAME)THAllocEx(pTHS, DSNameSizeFromLen(0));
        memcpy(&pDN->Guid, pObjGuid, sizeof(GUID));
        pDN->structLen = DSNameSizeFromLen(0);

        pEntry = (StackOfPDSNAME *) THAllocEx(pTHS, sizeof(StackOfPDSNAME));
        pEntry->pDSName = pDN;
        PushDN(&stack, pEntry);
        cVerify++;
    }

    if ( cVerify )
         GCVerifyDSNames(&stack, &pAddArg->CommArg);

    // This verifies the nCName attribute of a crossRef object.
    if(pAddArg->pCRInfo && !pTHS->errCode){
        pAddArg->pCRInfo->bEnabled = bEnabled;
        pAddArg->pCRInfo->ulSysFlags = ulSysFlags;
        PreTransVerifyNcName(pTHS, pAddArg->pCRInfo);
    }

    return(pTHS->errCode);
}

ULONG
GCVerifyDirModifyEntry(
    MODIFYARG   *pModifyArg)
{
    THSTATE         *pTHS = pTHStls;
    StackOfPDSNAME  stack = EMPTY_STACK;
    ULONG           cVerify = 0;
    StackOfPDSNAME  *pEntry;
    ATTRTYP         type;
    ULONG           attr;
    ULONG           val;
    ATTR            *pAttr;
    ATTRVAL         *pAVal;
    DSNAME          *pDN;
    ATTCACHE        *pAC;
    ATTRMODLIST     *pAttrMod;

    Assert(NULL != pTHS);
    Assert((NULL == pTHS->GCVerifyCache)||(pTHS->fSAM)||(pTHS->fDSA));

    if ( DsaIsInstalling() )
        return(0);

    // Don't go off machine if the caller is SAM, a trusted in-process client,
    // or a multiple-operations-in-a-single-transaction situation.

    if (pTHS->fSAM || 
        pTHS->fDSA ||
        (TRANSACT_BEGIN_END != pTHS->transControl) ) {
        return(0);
    }

    // We also don't want to verify names in the case of cross domain move.
    // But move itself should not get to here, only perhaps SAM on loopback
    // when modifying security principal properties after add on behalf of
    // cross domain move.  But in that case the pTHS->fSAM test should have 
    // kicked things out earlier.
    Assert(!pTHS->fCrossDomainMove);

    // This assert has to go here as there may be a pDB open if
    // someone is using DirTransactControl().

    Assert(NULL == pTHS->pDB);

    for ( attr = 0, pAttrMod = &pModifyArg->FirstMod;
          pAttrMod && (attr < pModifyArg->count);
          attr++, pAttrMod = pAttrMod->pNextMod )
    {
        if ( (AT_CHOICE_ADD_ATT != pAttrMod->choice) &&
             (AT_CHOICE_ADD_VALUES != pAttrMod->choice) &&
             (AT_CHOICE_REPLACE_ATT != pAttrMod->choice) )
        {
            continue;
        }

        pAttr = &pAttrMod->AttrInf;

        if (!(pAC = SCGetAttById(pTHS, pAttr->attrTyp)))
        {
            SetAttError(pModifyArg->pObject,
                        pAttr->attrTyp,
                        PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                        DIRERR_ATT_NOT_DEF_IN_SCHEMA); 
            return(pTHS->errCode);
        }

        pAVal = pAttr->AttrVal.pAVal;

        for ( val = 0; val < pAttr->AttrVal.valCount; val++, pAVal++ )
        {
            pDN = DSNameFromAttrVal(pAC, pAVal);

            if ( NULL != pDN )
            {
                pEntry = (StackOfPDSNAME *) THAllocEx(pTHS, sizeof(StackOfPDSNAME));
                pEntry->pDSName = pDN;
                PushDN(&stack, pEntry);
                cVerify++;
            }
        }
    }

    if ( cVerify )
         GCVerifyDSNames(&stack, &pModifyArg->CommArg);

    return(pTHS->errCode);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// GCVerifyDSNames - the guts of GC verification logic                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

//
// A list of attributes that we currently obtain from the
// GC when we look up an object
//

ATTRTYP RequiredAttrList[] = 
{ ATT_GROUP_TYPE,
  ATT_OBJECT_CLASS
};

ULONG
GCVerifyDSNames(
    StackOfPDSNAME  *candidateStack,
    COMMARG         *pCommArg)

/*++

Description:

    For each entry in a stack of DSNAMEs, determines whether it lives
    under a local NC or not.  If it doen't, the DSNAME is added to a
    stack of names requiring verification.  After iterating through
    all DSNAMEs in the candidate stack, the ones requiring verification
    are verified against the global catalog.

Arguments:

    candidateStack - Pointer to StackOfPDSNAME which represents all the 
        DSNAMEs referenced in a DirAddEntry or DirModifyEntry call.
        
    pCommArg - Pointer to COMMARG representing the common arguments of
        the calling DirAddEntry or DirModifyEntry call.

Returns:

    0 on success.
    On error, sets pTHStls->errCode and returns it as well.

--*/

{
    CROSS_REF                   *pCR;
    ATTRBLOCK                   *pAB;
    NAMING_CONTEXT              *pNC;
    BOOL                        fTmp;
    StackOfPDSNAME              *pEntry;
    StackOfPDSNAME              verifyStack = EMPTY_STACK;
    DWORD                       cVerify = 0;
    DWORD                       i, errRpc=0;
    // DRSVerifyNames arguments
    DRS_MSG_VERIFYREQ           VerifyReq;
    DRS_MSG_VERIFYREPLY         VerifyReply;
    DWORD                       dwReplyVersion;
    SCHEMA_PREFIX_TABLE *       pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap=NULL;
    THSTATE                     *pTHS = pTHStls;

    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    if (pCommArg->Svccntl.pGCVerifyHint &&
        (!IsClientHintAKnownDC(pTHS, pCommArg->Svccntl.pGCVerifyHint) ||
          isDCInvalidated(pCommArg->Svccntl.pGCVerifyHint))) {
        return SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_GCVERIFY_ERROR);
    }
    
    while ( (NULL != (pEntry = PopDN(candidateStack))) )
    {
        if ( pCommArg->Svccntl.pGCVerifyHint )
        {
            // See comments in ntdsa.h.  Caller is insisting we verify
            // all names at the server identified by his hint.

            goto VerifyStackAdd;
        }

        //
        // If a string name is specified , optimize going to the GC,
        // by checking whether the naming context is present locally
        //

        if (pEntry->pDSName->NameLen>0)
        {
            // All naming contexts known to the enterprise are present 
            // in gAnchor.pCRL regardless of whether we hold a copy or not.  
            // So a best match against this list should tell us whether this 
            // enterprise has any clue about the name of interest.

            pCR = FindBestCrossRef(pEntry->pDSName, pCommArg);

            if ( (NULL == pCR) || 
                 !(pCR->flags & FLAG_CR_NTDS_NC) ||
                 (pCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED)){

            }
            
            if ( (NULL == pCR) || !(pCR->flags & FLAG_CR_NTDS_NC) )
            {
                // Name isn't in any context this enterprise knows about.
                // Let VerifyDsnameAtts handle it.
                goto SkipEntry;
            }
    
            if (pCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED)
            {
                // Can't look this name up on a GC.  Let VerifyDsnameAtts either
                // verify it (if the object is local) or reject it.
                goto SkipEntry;
            }
    
            // Determine whether pDSName can be verified locally by attempting 
            // to match the Cross-Ref's ATT_NC_NAME property to a local, usable
            // naming context.
        
            if ( 0 != DSNameToBlockName(pTHS, 
                                        pCR->pNC,
                                        &pAB, 
                                        DN2BN_LOWER_CASE) )
                goto SkipEntry;
    
            // If we're willing to validate a name against the GC, then by
            // definition we're willing to use a read-only, local copy of a
            // naming context.  So temporarily whack the dontUseCopy field.
    
            fTmp = pCommArg->Svccntl.dontUseCopy;
            pCommArg->Svccntl.dontUseCopy = !gAnchor.fAmGC;
    
            pNC = FindNamingContext(pAB, pCommArg);
    
            pCommArg->Svccntl.dontUseCopy = fTmp;

            if ( (NULL != pNC) && NameMatched(pNC, pCR->pNC) )
            {
                // Name is in a naming context we have a copy of.
                // Let VerifyDsnameAtts handle it since item is local.
                goto SkipEntry;
            }
        }
        else if (!fNullUuid(&pEntry->pDSName->Guid))
        {
            //
            // A GUID is specified. In this case we can optimize going
            // to the G.C , only if we attempt a lookup locally, which
            // also is an expensive option. Also clients typically understand
            // string names and not GUIDS. So the chances of encountering a
            // GUID only name is less. Therefore, perform all lookups
            // in the G.C
            //
        }
        else if (pEntry->pDSName->SidLen>0)
        {
            //
            // Case of a Sid Only Name. Check if the domain prefix of the 
            // SID is a domain we know about
            //

            if (!FindNcForSid(&pEntry->pDSName->Sid,&pNC))
            {
                //
                // The domain prefix of this SID does not correspond to 
                // any of the domains in the enterprise. For now leave this
                // SID as is. Later on, SAM may create a foreign domain security
                // principal object for this SID.
                //

                goto SkipEntry;
            }
            else
            {
                //
                // This is a SID of an NT5 Security Prinicpal in the enterprise
                // We may again attempt to lookup the SID locally. But again
                // this involves a search which is also an expensive operation.
                // Also again Clients are likely to give string names, instead
                // of SIDS ( which I suppose they do only for NT4 Security Principals
                // So do not take the additional complexity hit, and perform the
                // lookup on the G.C
                //
            }
        }

VerifyStackAdd:
    
        // We really want to look up this name at the GC.  Put
        // it on the verifyStack.

        memset(pEntry, 0, sizeof(SINGLE_LIST_ENTRY));
        PushDN(&verifyStack, pEntry);
        cVerify++;
        continue;

SkipEntry:
        THFreeEx(pTHS, pEntry);
    }

    if ( 0 == cVerify )
        return(0);

    // Construct DRSVerifyNames arguments.

    memset(&VerifyReq, 0, sizeof(VerifyReq));
    memset(&VerifyReply, 0, sizeof(VerifyReply));

    VerifyReq.V1.dwFlags = DRS_VERIFY_DSNAMES;
    VerifyReq.V1.cNames = cVerify;
    VerifyReq.V1.rpNames = (DSNAME **) THAllocEx(pTHS, cVerify * sizeof(DSNAME*));
    VerifyReq.V1.PrefixTable = *pLocalPrefixTable;

    for ( i = 0; i < cVerify; i++ )
    {
        pEntry = PopDN(&verifyStack);
        //
        // PREFIX: PREFIX complains that we don't check the pEntry
        // for NULL here.  However, we have a precise count of 
        // the number of entries on the stack that's incremented
        // if and only if we push an entry on the stack.  Also,
        // there is an assert here.  This is not a bug.
        //
        Assert(NULL != pEntry);
        VerifyReq.V1.rpNames[i] = pEntry->pDSName;
        THFreeEx(pTHS, pEntry);
    }

    // Currently the attributes that are asked are 
    // group type and object class, along with the
    // full DSNAME of the object

    VerifyReq.V1.RequiredAttrs.attrCount = ARRAY_COUNT(RequiredAttrList);
    VerifyReq.V1.RequiredAttrs.pAttr = 
               THAllocEx(pTHS, ARRAY_COUNT(RequiredAttrList) * sizeof(ATTR));

    for (i=0;i<ARRAY_COUNT(RequiredAttrList);i++)
    {
        VerifyReq.V1.RequiredAttrs.pAttr[i].attrTyp = RequiredAttrList[i];
    }

    if (    !pCommArg->Svccntl.pGCVerifyHint
         && (gAnchor.fAmGC || gAnchor.fAmVirtualGC) )
    {
        //
        // Perform operations locally if we are the GC ourselves
        // Strictly speaking ....
        //
        // 1. For name based DSNAMES we should not even be coming in here
        //    because if we are the GC, we would find the correct NC and
        //    and find that we host the NC.
        //
        // 2. For GUID based names we always go to the GC and therefore come
        //    down this path. However no verification is required actually,
        //    since verify DS Name Atts is capable of verifying the name 
        //    locally.
        // 3. For a SID based name, we need to at the beginning find the correct
        //    object that the SID corresponds to. VerifyDSNAMES_V1 has all the
        //    logic for doing this. So we want to leverage the Same logic and 
        //    add the complete name ( including GUID and SID) to the verifyCache.

        __try
        {
         
            // Should not have an open transaction at this point
            Assert(NULL!=pTHS);
            Assert(NULL==pTHS->pDB);
            Assert(0==pTHS->transactionlevel);

            // begin a new transaction
            DBOpen2(TRUE,&pTHS->pDB);
            
            memset(&VerifyReply, 0, sizeof(DRS_MSG_VERIFYREPLY));
            
            VerifyReply.V1.rpEntInf = (ENTINF *) THAllocEx(pTHS, 
                                        VerifyReq.V1.cNames * sizeof(ENTINF));

            VerifyDSNAMEs_V1(
                pTHS,
                &VerifyReq.V1,
                &VerifyReply.V1
                );
        }
        __finally
        {
            DBClose(pTHS->pDB,TRUE);
            pTHS->pDB=NULL;
        }
    }
    else
    {
        errRpc = I_DRSVerifyNamesFindGC(pTHS,
                                        pCommArg->Svccntl.pGCVerifyHint,
                                        NULL,
                                        1,
                                        &VerifyReq,
                                        &dwReplyVersion,
                                        &VerifyReply,
                                        0);

        if ( errRpc || VerifyReply.V1.error )
        {
            // Assume that RPC errors means the GC is not available
            // or doesn't support the extension. 
            // Map both errors to "unavailable".  From XDS spec, "unavailable"
            // means "some part of the directory is currently not available."
            // Note that VerifyReply.V1.error indicates a general processing
            // error at the GC, not the failure to validate a given DSNAME.
            // Names which don't validate are represented as NULL pointers in
            // the reply.

            return(SetGCVerifySvcError(errRpc ? errRpc : VerifyReply.V1.error));
        }

        // Make sure that the DS didn't shut down while we were gone

        if (eServiceShutdown) {
            return ErrorOnShutdown();
        }

        hPrefixMap = PrefixMapOpenHandle(&VerifyReply.V1.PrefixTable,
                                     pLocalPrefixTable);

    }

    // Save verified names in the thread state.
   
    
    for ( i = 0; i < VerifyReply.V1.cNames; i++ )
    {
        if (NULL!=VerifyReply.V1.rpEntInf[i].pName)
        {
            GCVerifyCacheAdd(hPrefixMap, &VerifyReply.V1.rpEntInf[i]);
        }
        
        
    }

    if (NULL!=hPrefixMap)
    {
        PrefixMapCloseHandle(&hPrefixMap);
    }
        
    return(0);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SampVerifySids implementation                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
SampVerifySids(
    ULONG           cSid,
    PSID            *rpSid,
    DSNAME         ***prpDSName)

/*++

Description:

    Maps a set of SIDs to DSNAMEs at the GC.  SAM pledges only to 
    map those which aren't local.  I.e. - We don't need to do a
    local lookup first.  SAM is the only expected caller.

Arguments:

    cSid - Count of SIDs.

    rpSid - Array of SID pointers.  This is not thread state
        allocated memory.

    prpDSName - Address which gets address of array of validated 
        DSNAME pointers on return.  This is thread state allocated
        memory.  Null pointers in the reply indicate SIDs which
        could not be verified.

Returns:

    0 on success, !0 otherwise.
    Sets pTHStls->errCode on error.

--*/

{
    DWORD                       i, errRpc;
    WCHAR                       *NullName = L"\0";
    DWORD                       SidLen;
    // DRSVerifyNames arguments
    DRS_MSG_VERIFYREQ           VerifyReq;
    DRS_MSG_VERIFYREPLY         VerifyReply;
    DWORD                       dwReplyVersion;
    SCHEMA_PREFIX_TABLE *       pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap=NULL;
    THSTATE                     *pTHS = pTHStls;

    PVOID                       pEA;
    ULONG                       ulErr = 0, ulDSID;
    DWORD                       dwExceptCode;
    
    // SAM should have a valid thread state but not be
    // inside a transaction.

    Assert(NULL != pTHS);
    Assert(NULL == pTHS->pDB);

    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    __try
    {
        


        // Construct DRSVerifyNames arguments.

        memset(&VerifyReq, 0, sizeof(VerifyReq));
        memset(&VerifyReply, 0, sizeof(VerifyReply));

        VerifyReq.V1.dwFlags = DRS_VERIFY_SIDS;
        VerifyReq.V1.cNames = cSid;
        VerifyReq.V1.rpNames = (DSNAME **) THAllocEx(pTHS, cSid * sizeof(DSNAME*));
        VerifyReq.V1.PrefixTable = *pLocalPrefixTable;

        for ( i = 0; i < cSid; i++ )
        {
            VerifyReq.V1.rpNames[i] = 
                    (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(0));
            VerifyReq.V1.rpNames[i]->structLen = DSNameSizeFromLen(0);
            SidLen = RtlLengthSid(rpSid[i]);
            Assert(SidLen <= sizeof(NT4SID));

            if ( SidLen > sizeof(NT4SID) )
                SidLen = sizeof(NT4SID);

            memcpy(&(VerifyReq.V1.rpNames[i]->Sid), rpSid[i], SidLen);
            VerifyReq.V1.rpNames[i]->SidLen = SidLen;
        }

        // Currently the attributes that are asked are 
        // group type and object class, along with the
        // full DSNAME of the object

        VerifyReq.V1.RequiredAttrs.attrCount = ARRAY_COUNT(RequiredAttrList);
        VerifyReq.V1.RequiredAttrs.pAttr = 
               THAllocEx(pTHS, ARRAY_COUNT(RequiredAttrList) * sizeof(ATTR));

        for (i=0;i<ARRAY_COUNT(RequiredAttrList);i++)
        {
            VerifyReq.V1.RequiredAttrs.pAttr[i].attrTyp = RequiredAttrList[i];
        }


        if (gAnchor.fAmGC || gAnchor.fAmVirtualGC)
        {
            //
            // Perform operations locally if we are the GC
            //

            __try
            {
                // Should not have an open transaction at this point
                Assert(NULL!=pTHS);
                Assert(NULL==pTHS->pDB);
                Assert(0==pTHS->transactionlevel);

                // begin a new transaction
                DBOpen2(TRUE,&pTHS->pDB);

                memset(&VerifyReply, 0, sizeof(DRS_MSG_VERIFYREPLY));
                VerifyReply.V1.rpEntInf = (ENTINF *) THAllocEx(pTHS, 
                                        VerifyReq.V1.cNames * sizeof(ENTINF));
                VerifySIDs_V1(
                    pTHS,
                    &VerifyReq.V1,
                    &VerifyReply.V1);
            }
            __finally
            {
                // close the transaction

                DBClose(pTHS->pDB,TRUE);
                pTHS->pDB=NULL;
            }

        }
        else
        {
            errRpc = I_DRSVerifyNamesFindGC(pTHS,
                                            NULL,
                                            NULL,
                                            1,
                                            &VerifyReq,
                                            &dwReplyVersion,
                                            &VerifyReply,
                                            0);
            if ( errRpc || VerifyReply.V1.error )
            {
                // Assume that RPC errors means the GC is not available.
                // Map both errors to "unavailable".  From XDS spec, "unavailable"
                // means "some part of the directory is currently not available."
                // Note that VerifyReply.V1.error indicates a general processing
                // error at the GC, not the failure to validate a given DSNAME.
                // Names which don't validate are represented as NULL pointers in
                // the reply.

                return(SetGCVerifySvcError(errRpc ? errRpc : VerifyReply.V1.error));
            }

            hPrefixMap = PrefixMapOpenHandle(&VerifyReply.V1.PrefixTable,
                                         pLocalPrefixTable);

        }

     

        // Save verified names in the thread state.

        *prpDSName = THAllocEx(pTHS, VerifyReply.V1.cNames*sizeof(PDSNAME));

      
        for ( i = 0; i < VerifyReply.V1.cNames; i++ )
        {
            if (NULL!=VerifyReply.V1.rpEntInf[i].pName)
            {
                GCVerifyCacheAdd(hPrefixMap, &VerifyReply.V1.rpEntInf[i]);
            }

            // Assign return data.  Although we skipped NULLs when adding to the
            // cache, SAM wants NULLs back so no need to compress result.
            
            (*prpDSName)[i] = VerifyReply.V1.rpEntInf[i].pName; 
        }

        if (NULL!=hPrefixMap)
        {
            PrefixMapCloseHandle(&hPrefixMap);
        }
    }
    __except (GetExceptionData(GetExceptionInformation(), 
                               &dwExceptCode, 
                               &pEA, 
                               &ulErr, 
                               &ulDSID)){
        ulErr = DoSetGCVerifySvcError(ulErr, ulDSID);
    }

    return(ulErr);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// SampGcLookupSids implementation                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


ATTRTYP GCLookupSidsRequiredAttrList[] = 
{ ATT_SAM_ACCOUNT_TYPE,
  ATT_SAM_ACCOUNT_NAME
};

ULONG
SampGCLookupSids(
    IN  ULONG           cSid,
    IN  PSID            *rpSid,
    OUT PDS_NAME_RESULTW *pResults
    )

/*++

Description:

    Maps a set of SIDs to DSNAMEs at the GC.  SAM pledges only to 
    map those which aren't local.  I.e. - We don't need to do a
    local lookup first.  SAM is the only expected caller.

Arguments:

    cSid    - Count of SIDs.
            
    rpSid   - Array of SID pointers.  This is not thread state
              allocated memory.

    rEntInf - Info about each resolved sid

Returns:

    0 on success, !0 otherwise.
    Sets pTHStls->errCode on error.

--*/
{
    DWORD                       i, err = 0, errRpc;

    THSTATE                     *pTHS = pTHStls;

    DRS_MSG_CRACKREQ            CrackReq;
    DRS_MSG_CRACKREPLY          CrackReply;
    DWORD                       dwReplyVersion;

    PVOID                       pEA;
    ULONG                       ulErr, ulDSID;
    DWORD                       dwExceptCode;
    
    // SAM should have a valid thread state but not be
    // inside a transaction.

    Assert(NULL != pTHS);
    Assert(NULL == pTHS->pDB);

    // Init the out param
    *pResults = NULL;
    __try  {
        __try  {
    
            // Construct DRSCrackName arguments.
    
            memset(&CrackReq, 0, sizeof(CrackReq));
            memset(&CrackReply, 0, sizeof(CrackReply));
    
            CrackReq.V1.CodePage = GetACP();
            // Does this call make any sense for local system?
            CrackReq.V1.LocaleId = GetUserDefaultLCID();
            
            //
            // Honor gEnableXForest registry value to ensure correct xforest
            // lookup behavior in self host deployments that have forest 
            // versions less than DS_BEHAVIOR_WIN_DOT_NET
            //
            if ( gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WIN_DOT_NET ||
                 0 != gEnableXForest )
            {
                CrackReq.V1.dwFlags = DS_NAME_FLAG_TRUST_REFERRAL;    
            }
            
            CrackReq.V1.formatOffered = DS_STRING_SID_NAME;
            CrackReq.V1.formatDesired = DS_NT4_ACCOUNT_NAME;
            CrackReq.V1.cNames = cSid;
            CrackReq.V1.rpNames = THAllocEx(pTHS, cSid * sizeof(WCHAR*));
    
            for ( i = 0; i < cSid; i++ ) {
    
                NTSTATUS       st;
                UNICODE_STRING SidStringU;
    
                RtlZeroMemory( &SidStringU, sizeof(UNICODE_STRING) );
    
                Assert( RtlValidSid( rpSid[i] ) );
    
                st = RtlConvertSidToUnicodeString( &SidStringU,
                                                   rpSid[i],
                                                   TRUE );
    
                if ( !NT_SUCCESS( st ) ) {
    
                    //
                    // This should only fail on memory allocation problems
                    //
                    err = SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ERROR_NOT_ENOUGH_MEMORY );
                    _leave;
                    
                }
    
                //
                // The RtlConvert function returns a NULL terminated string
                //
                Assert( SidStringU.Buffer[(SidStringU.Length/2)] == L'\0' );

                CrackReq.V1.rpNames[i] = SidStringU.Buffer;
                
            }

            //
            // Crack the sids
            //
    
            if (gAnchor.fAmGC || gAnchor.fAmVirtualGC)
            {
                //
                // Perform operations locally if we are the GC
                //
    
                __try
                {
                    DWORD cNamesOut, cBytes;
                    CrackedName *rCrackedNames = NULL;

                    // Should not have an open transaction at this point
                    Assert(NULL!=pTHS);
                    Assert(NULL==pTHS->pDB);
                    Assert(0==pTHS->transactionlevel);
    
                    // begin a new transaction
                    DBOpen2(TRUE,&pTHS->pDB);
    
                    CrackNames( CrackReq.V1.dwFlags,
                                CrackReq.V1.CodePage,
                                CrackReq.V1.LocaleId,
                                CrackReq.V1.formatOffered,
                                CrackReq.V1.formatDesired,
                                CrackReq.V1.cNames,
                                CrackReq.V1.rpNames,
                                &cNamesOut,
                                &rCrackedNames );
    
    
                    //
                    // Make a PDS_NAME_RESULT structure
                    //
                    *pResults = (DS_NAME_RESULTW *) THAllocEx(pTHS, sizeof(DS_NAME_RESULTW));
        
                    if ( (cNamesOut > 0) && rCrackedNames )
                    {
                        // Server side MIDL_user_allocate is same as THAlloc which
                        // also zeros memory by default.
            
                        cBytes = cNamesOut * sizeof(DS_NAME_RESULT_ITEMW);
                        (*pResults)->rItems =
                            (DS_NAME_RESULT_ITEMW *) THAllocEx(pTHS, cBytes);
            
                        for ( i = 0; i < cNamesOut; i++ )
                        {
                            (*pResults)->rItems[i].status =
                                                        rCrackedNames[i].status;
                            (*pResults)->rItems[i].pDomain =
                                                        rCrackedNames[i].pDnsDomain;
                            (*pResults)->rItems[i].pName =
                                                        rCrackedNames[i].pFormattedName;
                        }
        
                        THFree(rCrackedNames);
                        (*pResults)->cItems = cNamesOut;
        
                    } else {

                        Assert( !"Unexpected return from CrackNames" );
                        err = SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ERROR_INVALID_PARAMETER );
                        _leave;

                    }
    
                }
                __finally
                {
                    // close the transaction
    
                    DBClose(pTHS->pDB,TRUE);
                    pTHS->pDB=NULL;
                }
    
            }
            else
            {
                //
                // Go to a remote GC
                //
                errRpc = I_DRSCrackNamesFindGC(pTHS,
                                               NULL,
                                               NULL,
                                               1,
                                               &CrackReq,
                                               &dwReplyVersion,
                                               &CrackReply,
                                               0);
    
                if ( errRpc )
                {
                    // Assume that RPC errors means the GC is not available.
                    // Map errors to "unavailable".  From XDS spec, "unavailable"
                    // means "some part of the directory is currently not available."
                    err = SetGCVerifySvcError(errRpc);
                    leave;
                }
    
                // Return the values in the ENTINF structure
                *pResults = CrackReply.V1.pResult;
    
            }
    
    
        }
        __finally
        {
            //
            // Release the heap allocated memory
            //
            for ( i = 0; i < CrackReq.V1.cNames; i++) {
                if ( CrackReq.V1.rpNames[i] ) {
        
                    RtlFreeHeap( RtlProcessHeap(), 0, CrackReq.V1.rpNames[i] );
                }
            }
        }
    }
    __except (GetExceptionData(GetExceptionInformation(), 
                               &dwExceptCode, 
                               &pEA, 
                               &ulErr, 
                               &ulDSID))
    {
        err = DoSetGCVerifySvcError(ulErr, ulDSID);
    }

    return(err);
}


ATTRTYP GCLookupNamesRequiredAttrList[] = 
{ ATT_SAM_ACCOUNT_TYPE,
  ATT_OBJECT_SID,
  ATT_SAM_ACCOUNT_NAME
};

NTSTATUS
SampGCLookupNames(
    IN  ULONG           cNames,
    IN  UNICODE_STRING *rNames,
    OUT ENTINF         **rEntInf
    )
/*++

Description:

    This routine maps a set of nt4 style names to sids.

Arguments:

    cNames  - Count of names.

    rNames  - Array of names.  This is not thread state
              allocated memory.

    rEntInf - Info about each resolved name

Returns:

    0 on success, !0 otherwise.
    Sets pTHStls->errCode on error.

--*/

{
    DWORD                       i, errRpc;
    WCHAR                       *NullName = L"\0";
    // DRSVerifyNames arguments
    DRS_MSG_VERIFYREQ           VerifyReq;
    DRS_MSG_VERIFYREPLY         VerifyReply;
    DWORD                       dwReplyVersion;
    SCHEMA_PREFIX_TABLE *       pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap=NULL;
    THSTATE                     *pTHS = pTHStls;

    PVOID                       pEA;
    ULONG                       ulErr = 0, ulDSID;
    DWORD                       dwExceptCode;
    
    // SAM should have a valid thread state but not be
    // inside a transaction.

    Assert(NULL != pTHS);
    Assert(NULL == pTHS->pDB);

    *rEntInf = NULL;

    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    __try
    {
        // Construct DRSVerifyNames arguments.

        memset(&VerifyReq, 0, sizeof(VerifyReq));
        memset(&VerifyReply, 0, sizeof(VerifyReply));

        VerifyReq.V1.dwFlags = DRS_VERIFY_SAM_ACCOUNT_NAMES;
        VerifyReq.V1.cNames = cNames;
        VerifyReq.V1.rpNames = (DSNAME **) THAllocEx(pTHS, cNames * sizeof(DSNAME*));
        VerifyReq.V1.PrefixTable = *pLocalPrefixTable;

        for ( i = 0; i < cNames; i++ )
        {
            ULONG len;

            len = (rNames[i].Length / sizeof(WCHAR));

            VerifyReq.V1.rpNames[i] = 
                    (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(len));
            VerifyReq.V1.rpNames[i]->structLen = DSNameSizeFromLen(len);
            memcpy( VerifyReq.V1.rpNames[i]->StringName, rNames[i].Buffer, rNames[i].Length );
            VerifyReq.V1.rpNames[i]->StringName[(rNames[i].Length / sizeof(WCHAR))] = L'\0';
            VerifyReq.V1.rpNames[i]->NameLen = len;
        }

        // Currently the attributes that are asked are 
        // group type, object class, and sid along with the
        // full DSNAME of the object

        VerifyReq.V1.RequiredAttrs.attrCount = ARRAY_COUNT(GCLookupNamesRequiredAttrList);
        VerifyReq.V1.RequiredAttrs.pAttr = 
               THAllocEx(pTHS, ARRAY_COUNT(GCLookupNamesRequiredAttrList) * sizeof(ATTR));

        for (i=0;i<ARRAY_COUNT(GCLookupNamesRequiredAttrList);i++)
        {
            VerifyReq.V1.RequiredAttrs.pAttr[i].attrTyp = GCLookupNamesRequiredAttrList[i];
        }


        if (gAnchor.fAmGC || gAnchor.fAmVirtualGC)
        {
            //
            // Perform operations locally if we are the GC
            //

            __try
            {
                // Should not have an open transaction at this point
                Assert(NULL!=pTHS);
                Assert(NULL==pTHS->pDB);
                Assert(0==pTHS->transactionlevel);

                // begin a new transaction
                DBOpen2(TRUE,&pTHS->pDB);

                memset(&VerifyReply, 0, sizeof(DRS_MSG_VERIFYREPLY));
                VerifyReply.V1.rpEntInf = (ENTINF *) THAllocEx(pTHS, 
                                        VerifyReq.V1.cNames * sizeof(ENTINF));
                VerifySamAccountNames_V1(
                    pTHS,
                    &VerifyReq.V1,
                    &VerifyReply.V1);
            }
            __finally
            {
                // close the transaction

                DBClose(pTHS->pDB,TRUE);
                pTHS->pDB=NULL;
            }

        }
        else
        {
            errRpc = I_DRSVerifyNamesFindGC(pTHS,
                                            NULL,
                                            NULL,
                                            1,
                                            &VerifyReq,
                                            &dwReplyVersion,
                                            &VerifyReply,
                                            0);
            
            if ( errRpc || VerifyReply.V1.error )
            {
                // Assume that RPC errors means the GC is not available.
                // Map both errors to "unavailable".  From XDS spec, "unavailable"
                // means "some part of the directory is currently not available."
                // Note that VerifyReply.V1.error indicates a general processing
                // error at the GC, not the failure to validate a given DSNAME.
                // Names which don't validate are represented as NULL pointers in
                // the reply.

                return(SetGCVerifySvcError(errRpc ? errRpc : VerifyReply.V1.error));
            }

            hPrefixMap = PrefixMapOpenHandle(&VerifyReply.V1.PrefixTable,
                                         pLocalPrefixTable);

        }

        if ( hPrefixMap ) {
            
            for ( i = 0; i < VerifyReply.V1.cNames; i++ ) {
    
                ENTINF *pEntInf = &VerifyReply.V1.rpEntInf[i];
    
                if ( !PrefixMapAttrBlock(hPrefixMap, &pEntInf->AttrBlock) ) {
    
                    DsaExcept(DSA_EXCEPTION, DIRERR_DRA_SCHEMA_MISMATCH, 0);
    
                }
    
            }
    
            PrefixMapCloseHandle(&hPrefixMap);

        }

        // Return the values in the ENTINF structure
        *rEntInf = VerifyReply.V1.rpEntInf;

    }
    __except (GetExceptionData(GetExceptionInformation(), 
                               &dwExceptCode, 
                               &pEA, 
                               &ulErr, 
                               &ulDSID))
    {
        ulErr = DoSetGCVerifySvcError(ulErr, ulDSID);
    }

    return(ulErr);
}


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// FindDC / FindGC logic                                                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// These routines isolate the logic of finding and refreshing the 
// address of a GC (or DC for a specified dns NC) to use for DSNAME 
// verification or for VerifyByCrack() for the Domain Naming FSMO.  
// Logic exists to insure we do not force rediscovery too often for 
// GCs.  For DCs location, there is no caching logic yet, but these
// routines are called only during the creation of a cross-ref, which
// is obviously a fairly infrequent event.  The caching rationale for
// GCs is based on the assumption that since netlogon maintains a DC
// location cache for the entire machine, then it is likely some 
// other process has already forced rediscovery and thus getting a 
// new value from the netlogon cache is sufficient.

// The FIND_DC_USE_CACHED_FAILURES flag allows callers to leverage a known
// bad address state and bypass rediscovery of any form if desired.

typedef struct _INVALIDATE_HISTORY 
{
    DWORD           seqNum;
    LARGE_INTEGER   time;
} INVALIDATE_HISTORY;

// A macro to convert a time interval expressed in seconds to a file time 
// (LARGE_INTEGER) constant. File time is measured in 100-nanosecond intervals, 
// so a second is 10,000,000 of them.
#define FTIME(seconds) { (DWORD)((((ULONGLONG)(seconds))*10000000) & 0xFFFFFFFF), (LONG)((((ULONGLONG)(seconds))*10000000) >> 32) }

CRITICAL_SECTION    gcsFindGC;
DWORD               gSeqNumGC = 0;  // known to wrap - no problem
INVALIDATE_HISTORY  gInvalidateHistory[2] = { { 0, { 0, 0 } }, 
                                              { 0, { 0, 0 } } };
BOOL                gfFindInProgress = FALSE;
BOOL                gfForceNextFindGC = FALSE;
FIND_DC_INFO         *gpGCInfo = NULL;
// Following in GetSystemTimeAsFileTime/NtQuerySystemTime units ...
// Force rediscovery if two failed DsrGetDcNameEx2 within one minute.
LARGE_INTEGER       gliForceRediscoveryWindow = FTIME(DEFAULT_GCVERIFY_FORCE_REDISCOVERY_WINDOW); 
// Force rediscovry if no GC and more than five minutes since invalidation.
LARGE_INTEGER       gliForceWaitExpired = FTIME(DEFAULT_GCVERIFY_FORCE_WAIT_EXPIRED);
// Honor FIND_DC_USE_CACHED_FAILURES for 1 minute, then cause DsrGetDcNameEx2.
LARGE_INTEGER       gliHonorFailureWindow = FTIME(DEFAULT_GCVERIFY_HONOR_FAILURE_WINDOW);
// Time at which we last used forced rediscovery in a locator call.
LARGE_INTEGER       gliTimeLastForcedLocatorCall = {0, 0};
// The cause of the last failure.
DWORD               gdwLastFailure = ERROR_DS_INTERNAL_FAILURE;
// Failback time if we failed to an offsite GC -- 30 mins
DWORD               gdwFindGcOffsiteFailbackTime = DEFAULT_GCVERIFY_FINDGC_OFFSITE_FAILBACK_TIME;


#define FIND_DC_SANITY_CHECK \
    Assert(!gpGCInfo || (gSeqNumGC == gpGCInfo->seqNum)); \
    Assert(gInvalidateHistory[1].time.QuadPart >= \
                                        gInvalidateHistory[0].time.QuadPart);

// list of invalidated DCs
PINVALIDATED_DC_LIST gpInvalidatedDCs = NULL;

// Time interval before an invalidated GC is removed from the invalidated list
LARGE_INTEGER gliDcInvalidationPeriod = FTIME(DEFAULT_GCVERIFY_DC_INVALIDATION_PERIOD);

// Private function: try to find the DC in the invalidated DC list.
// The function will scan the invalidated list and throw away all expired invalidations.
PINVALIDATED_DC_LIST findDCInvalidated(PWCHAR pDCName) {
    PINVALIDATED_DC_LIST pCur, pPrev;
    LARGE_INTEGER liThreshold; 

    // this function must be called while holding the FindGC lock
    Assert(OWN_CRIT_SEC(gcsFindGC));

    // DCs invalidated before (NOW-liInvalidationPeriod) should be removed from the list
    GetSystemTimeAsFileTime((FILETIME *) &liThreshold);
    liThreshold.QuadPart -= gliDcInvalidationPeriod.QuadPart;

    pCur = gpInvalidatedDCs;
    pPrev = NULL;
    while (pCur) {
        if (pCur->lastInvalidation.QuadPart < liThreshold.QuadPart) {
            // this one needs to be removed
            if (pPrev == NULL) {
                // no previous -- this is the first element
                gpInvalidatedDCs = pCur->pNext;
                free(pCur);
                pCur = gpInvalidatedDCs;
            }
            else {
                // not the first element. Remove from the middle of the list
                pPrev->pNext = pCur->pNext;
                free(pCur);
                pCur = pPrev->pNext;
            }
            continue;
        }
        if (DnsNameCompare_W(pCur->dcName, pDCName)) {
            // Found! This is an invalidated DC
            return pCur;
            // Note: only entries BEFORE the target entry are thrown away if no longer 
            // invalidated. This is a correct (though lazy) behavior. Moreover, if a 
            // non-existant entry is being searched for, the whole list will be scanned 
            // and cleaned.
        }
        pPrev = pCur;
        pCur = pCur->pNext;
    }
    // not found
    return NULL;
}

// Check if the DC is in invalidated DC list.
BOOL isDCInvalidated(PWCHAR pDCName) {
    PINVALIDATED_DC_LIST pRes;
    // drop the prepended "\\" if any
    if (pDCName[0] == '\\' && pDCName[1] == '\\') {
        pDCName += 2;
    }
    EnterCriticalSection(&gcsFindGC);
    pRes = findDCInvalidated(pDCName);
    LeaveCriticalSection(&gcsFindGC);
    return pRes != NULL;
}

// Mark a DC as invalidated. Add to the invalidated DC list if needed.
// Set the invalidationTime as NOW.
// Return 0 on success, !0 on failure (out of memory)
DWORD setDCInvalidated(PWCHAR pDCName) {
    PINVALIDATED_DC_LIST pCur;
    DWORD err = 0;

    // drop the prepended "\\" if any
    if (pDCName[0] == '\\' && pDCName[1] == '\\') {
        pDCName += 2;
    }

    EnterCriticalSection(&gcsFindGC);

    // try to find the DC in the list (and throw away expired invalidations)
    pCur = findDCInvalidated(pDCName);
    
    if (pCur == NULL) {
        // did not find it, need to add
        // we got an extra WCHAR inside INVALIDATED_DC_LIST struct to cover the final NULL
        pCur = (PINVALIDATED_DC_LIST)malloc(wcslen(pDCName)*sizeof(WCHAR) + sizeof(INVALIDATED_DC_LIST));
        if (pCur == NULL) {
            // we are out of memory. Bail.
            err = ERROR_OUTOFMEMORY;
            goto finish;
        }
        wcscpy(pCur->dcName, pDCName);
        pCur->pNext = gpInvalidatedDCs;
        gpInvalidatedDCs = pCur;
    }
    GetSystemTimeAsFileTime((FILETIME *) &pCur->lastInvalidation);
finish:
    LeaveCriticalSection(&gcsFindGC);
    return err;
}

// Flush the invalidated DC list
VOID flushDCInvalidatedList() {
    PINVALIDATED_DC_LIST pCur;

    EnterCriticalSection(&gcsFindGC);
    while (pCur = gpInvalidatedDCs) {
        gpInvalidatedDCs = gpInvalidatedDCs->pNext;
        free(pCur);
    }
    LeaveCriticalSection(&gcsFindGC);
}

// make a fake DOMAIN_CONTROLLER_INFOW to mimic the one that DsrGetDcNameEx2 returns
// We only fill DomainControllerName, DomainName and SiteName fields.
DWORD makeFakeDCInfo(
    PWCHAR szDnsHostName, 
    PWCHAR szDomainName, 
    PWCHAR szSiteName, 
    DOMAIN_CONTROLLER_INFOW **ppDCInfo, 
    DWORD* pulDSID) 
{
    DWORD err;

    Assert(szDnsHostName && szDomainName && szSiteName && ppDCInfo && pulDSID);
    err = NetApiBufferAllocate(
        sizeof(DOMAIN_CONTROLLER_INFOW) +
        (wcslen(szDnsHostName)+3)*sizeof(WCHAR) +   // we will prepend the DC name with "\\"
        (wcslen(szDomainName)+1)*sizeof(WCHAR) +
        (wcslen(szSiteName)+1)*sizeof(WCHAR),
        ppDCInfo
        );
    if (err) {
        // could not alloc memory. Bail
        *pulDSID = DSID(FILENO, __LINE__);
        return err;
    }
    memset(*ppDCInfo, 0, sizeof(DOMAIN_CONTROLLER_INFOW));

    // prepend DC name with "\\" because this is what DsrGetDcNameEx2 does
    (*ppDCInfo)->DomainControllerName = (PWCHAR)((PBYTE)(*ppDCInfo) + sizeof(DOMAIN_CONTROLLER_INFOW));
    (*ppDCInfo)->DomainControllerName[0] = (*ppDCInfo)->DomainControllerName[1] = '\\';
    wcscpy((*ppDCInfo)->DomainControllerName+2, szDnsHostName);

    (*ppDCInfo)->DomainName = (*ppDCInfo)->DomainControllerName + wcslen((*ppDCInfo)->DomainControllerName)+1;
    wcscpy((*ppDCInfo)->DomainName, szDomainName);

    (*ppDCInfo)->DcSiteName = (*ppDCInfo)->DomainName + wcslen((*ppDCInfo)->DomainName)+1;
    wcscpy((*ppDCInfo)->DcSiteName, szSiteName);

    // We are not setting DS_CLOSEST_FLAG since this is apparently not the best DC.
    // Thus, we will try to fail back later.
    (*ppDCInfo)->Flags = 0; 

    return 0;
}

VOID
InvalidateGCUnilaterally()
{
    EnterCriticalSection(&gcsFindGC);
    FIND_DC_SANITY_CHECK;
    if ( gpGCInfo ) {
        free(gpGCInfo);
        gpGCInfo = NULL;
    }
    gfForceNextFindGC = TRUE;
    LeaveCriticalSection(&gcsFindGC);
}

VOID
FailbackOffsiteGC(
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
   FIND_DC_INFO *pGCInfo = (FIND_DC_INFO * )buffer;

   InvalidateGC(pGCInfo,ERROR_DS_NOT_CLOSEST);
   free(pGCInfo);

   (void) ppvNext;     // unused -- task will not be rescheduled
   (void) pcSecsUntilNextIteration; // unused -- task will not be rescheduled
}
 
VOID
InvalidateGC(
    FIND_DC_INFO *pCancelInfo,
    DWORD       winError)
{
    LARGE_INTEGER   liNow, delta;
    BOOL            fLogEvent = FALSE;
    
    Assert(winError);

    GetSystemTimeAsFileTime((FILETIME *) &liNow);

    EnterCriticalSection(&gcsFindGC);
    FIND_DC_SANITY_CHECK;

    // We maintain a two level invalidation history in gInvalidateHistory.
    // The idea is that if we get two consecutive and distinct invalidations
    // (which by definition represent two consecutive and distinct 
    // DsrGetDcNameEx2 calls) within the acceptable time window, then
    // we mark the next DsrGetDcNameEx2 to force rediscovery.  I.e. If we
    // get consecutive and distinct cancellations differing by more than
    // the acceptable time limit, then we assume some other process/thread
    // has already forced rediscovery, thus using netlogon's cached GC
    // value most likely gets us a recent (and better) GC.

    if (    gpGCInfo
         && pCancelInfo
         && (gpGCInfo->seqNum == pCancelInfo->seqNum)
         && DnsNameCompare_W(gpGCInfo->addr, pCancelInfo->addr) )
    {
        // This is a new invalidation.  Move entry down and save new one.
        gInvalidateHistory[0] = gInvalidateHistory[1];
        gInvalidateHistory[1].seqNum = pCancelInfo->seqNum;
        gInvalidateHistory[1].time.QuadPart = liNow.QuadPart;

        if(gInvalidateHistory[1].time.QuadPart < 
           gInvalidateHistory[0].time.QuadPart    ) {
            // Someone is playing games with system time.  Force sanity on the
            // cache. 
            gInvalidateHistory[0].time.QuadPart =
                gInvalidateHistory[1].time.QuadPart;
        }

        // Set force flag if we're within the time limit.
        delta.QuadPart = gInvalidateHistory[1].time.QuadPart -
                                    gInvalidateHistory[0].time.QuadPart;
        if ( delta.QuadPart <= gliForceRediscoveryWindow.QuadPart )
        {
            // Only person to reset this is FindDC on a successfull
            // rediscovery forced DsrGetDcNameEx2;
            gfForceNextFindGC = TRUE;
        }

        // Log event outside of critical section.
        fLogEvent = TRUE;

        // Clear current gpGCInfo;
        free(gpGCInfo);
        gpGCInfo = NULL;
    }

    // Add the GC to the invalidated DC list, unless this is a OFFSITE_GC_FAILBACK call
    // This will exclude this DC from consideration for the next gliInvalidationPeriod time period.
    if (winError != ERROR_DS_NOT_CLOSEST) {
        // ignore errors, they are not critical here
        setDCInvalidated(pCancelInfo->addr);
    }

    LeaveCriticalSection(&gcsFindGC);

    if (fLogEvent) {

        if (ERROR_DS_NOT_CLOSEST!=winError) {

            // an error occured causing the invalidate

            LogEvent8(DS_EVENT_CAT_GLOBAL_CATALOG,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_GC_INVALIDATED,
                      szInsertWC(pCancelInfo->addr),
                      szInsertWin32Msg(winError),
                      szInsertWin32ErrCode(winError),
                      NULL, NULL, NULL, NULL, NULL );
        } else {

           // the GC is being invalidate simply because it is not
           // in the closest site

           LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                    DS_EVENT_SEV_ALWAYS, 
                    DIRLOG_OFFSITE_GC_FAILBACK,
                    szInsertWC(pCancelInfo->addr),
                    NULL, NULL );
       }
    }
}

DWORD readDcInfo(
    IN THSTATE* pTHS, 
    IN PWCHAR pszDnsHostName, 
    OUT PWCHAR* ppszDomainName, 
    OUT PWCHAR* ppszSiteName,
    OUT DWORD* pulDSID) 
/*++

Description:
    For a given DC dnsname, determine the domain and the site this DC is in.
    This is done by searching the config container for a server object with
    the specified dnsHostName. The site and domain names are constructed from
    the returned server object.
    
Arguments:
    pTHS -- thread state
    pszDnsHostName -- (IN) DC dns name
    ppszDomainName -- (OUT) ptr to the THAllocEx'ed string
    ppszSiteName   -- (OUT) ptr to the THAllocEx'ed string
    pulDSID        -- (OUT) ptr to ulDSID, it will be set in case of an error
    
Return values:
    0 on success.
    error code on failure

++*/
{
    FILTER ObjCategoryFilter, DnsHostNameFilter, AndFilter;
    CLASSCACHE *pCC;
    SEARCHARG SearchArg;
    SEARCHRES SearchRes;
    ENTINFSEL sel;
    ATTR attr;
    ATTRVAL *pVal;
    DSNAME *pComputerObj, *pServerObj;
    CROSS_REF* pDomainCR;
    ATTRBLOCK* blockName = NULL;
    
    DWORD dwErr = 0;
    DBPOS* pDBsave = pTHS->pDB;
    BOOL   fDSAsave = pTHS->fDSA;
    PVOID  pEA;
    DWORD  dwExceptCode;

    Assert(ppszDomainName && ppszSiteName);
    *ppszDomainName = NULL;
    *ppszSiteName = NULL;

    __try {
        pTHS->pDB = NULL;
        pTHS->fDSA = TRUE; // suppress checks

        __try {
            DBOpen(&(pTHS->pDB));

            //initialize SearchArg
            memset(&SearchArg,0,sizeof(SearchArg));
            SearchArg.pObject = gAnchor.pConfigDN;
            SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
            SearchArg.bOneNC  = TRUE;

            if (dwErr = DBFindDSName(pTHS->pDB, SearchArg.pObject)) {
                *pulDSID = DSID(FILENO, __LINE__);
                __leave;
            }

            SearchArg.pResObj = CreateResObj(pTHS->pDB, SearchArg.pObject);

            InitCommarg(&SearchArg.CommArg);

            // we need one attribute only -- server reference, to compute the domain name
            memset(&sel,0,sizeof(ENTINFSEL));
            SearchArg.pSelection= &sel;
            sel.attSel = EN_ATTSET_LIST;
            sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
            sel.AttrTypBlock.attrCount = 1;

            memset(&attr,0,sizeof(attr));
            sel.AttrTypBlock.pAttr = &attr;
            attr.attrTyp = ATT_SERVER_REFERENCE;

            pCC = SCGetClassById(pTHS, CLASS_SERVER);
            Assert(pCC);

            //set filter (objCategory==server)&&(dnsHostName=xxx)
            memset(&AndFilter,0,sizeof(AndFilter));
            AndFilter.choice = FILTER_CHOICE_AND;
            AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;
            AndFilter.FilterTypes.And.count = 2;

            memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
            ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
            ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                             pCC->pDefaultObjCategory->structLen;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                             (BYTE*)(pCC->pDefaultObjCategory);
            ObjCategoryFilter.pNextFilter = &DnsHostNameFilter;

            memset(&DnsHostNameFilter,0,sizeof(DnsHostNameFilter));
            DnsHostNameFilter.choice = FILTER_CHOICE_ITEM;
            DnsHostNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
            DnsHostNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_DNS_HOST_NAME;
            DnsHostNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = wcslen(pszDnsHostName) * sizeof(WCHAR);
            DnsHostNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)pszDnsHostName;

            SearchArg.pFilter = &AndFilter;

            //return one object only
            SearchArg.CommArg.ulSizeLimit = 1;

            memset(&SearchRes,0,sizeof(SearchRes));

            if (dwErr = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
                *pulDSID = DSID(FILENO, __LINE__);
                __leave;
            }
            if (SearchRes.count == 0) {
                *pulDSID = DSID(FILENO, __LINE__);
                dwErr = ERROR_DS_NO_SUCH_OBJECT;
                __leave;
            }

            pServerObj = SearchRes.FirstEntInf.Entinf.pName;

            if (SearchRes.FirstEntInf.Entinf.AttrBlock.attrCount > 0 &&
                SearchRes.FirstEntInf.Entinf.AttrBlock.pAttr[0].attrTyp == ATT_SERVER_REFERENCE &&
                SearchRes.FirstEntInf.Entinf.AttrBlock.pAttr[0].AttrVal.valCount > 0)  
            {
                pComputerObj = (DSNAME*)SearchRes.FirstEntInf.Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;
            }
            else {
                *pulDSID = DSID(FILENO, __LINE__);
                dwErr = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }

            Assert(pComputerObj);
            // find the cross-ref the computer belongs to
            pDomainCR = FindBestCrossRef(pComputerObj, NULL);
            if (pDomainCR == NULL) {
                // something is wrong
                LooseAssert(!"Could not find the cross-ref for the computer object", GlobalKnowledgeCommitDelay);
                *pulDSID = DSID(FILENO, __LINE__);
                dwErr = ERROR_DS_UNKNOWN_ERROR;
                __leave;
            }
            // copy the domain name
            Assert(pDomainCR->DnsName);
            *ppszDomainName = (PWCHAR)THAllocEx(pTHS, (wcslen(pDomainCR->DnsName)+1)*sizeof(WCHAR));
            wcscpy(*ppszDomainName, pDomainCR->DnsName);

            // compute the site name from the server object name
            // the site container is the grandparent of the server object
            dwErr = DSNameToBlockName(pTHS, pServerObj, &blockName, DN2BN_PRESERVE_CASE);
            if (dwErr) {
                *pulDSID = DSID(FILENO, __LINE__);
                __leave;
            }
            if (blockName->attrCount <= 2) {
                Assert(!"Invalid server object name");
                *pulDSID = DSID(FILENO, __LINE__);
                dwErr = ERROR_DS_UNKNOWN_ERROR;
                __leave;
            }
            // site container is the grandparent of the server object
            pVal = blockName->pAttr[blockName->attrCount-3].AttrVal.pAVal;
            *ppszSiteName = (PWCHAR)THAllocEx(pTHS, pVal->valLen + sizeof(WCHAR));
            memcpy(*ppszSiteName, pVal->pVal, pVal->valLen);
            (*ppszSiteName)[pVal->valLen/sizeof(WCHAR)] = L'\0';
        }
        __finally {
            if (blockName) {
                FreeBlockName(blockName);
            }
            if (dwErr || AbnormalTermination()) {
                // free memory if we alloced any
                if (*ppszDomainName) {
                    THFreeEx(pTHS, *ppszDomainName);
                    *ppszDomainName = NULL;
                }
                if (*ppszSiteName) {
                    THFreeEx(pTHS, *ppszSiteName);
                    *ppszSiteName = NULL;
                }
            }
            if (pTHS->pDB) {
                DBClose(pTHS->pDB, !AbnormalTermination());
            }
            pTHS->pDB = pDBsave;
            pTHS->fDSA = fDSAsave;
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), 
                              &dwExceptCode, 
                              &pEA, 
                              &dwErr, 
                              pulDSID)) {
        // make sure err is set
        if (dwErr == 0) {
            Assert(!"Error is not set");
            dwErr = ERROR_DS_UNKNOWN_ERROR;
        }
    }

    Assert(dwErr == 0 || *pulDSID != 0);
    return dwErr;
}

DWORD
FindDC(
    IN DWORD    dwFlags,
    IN WCHAR *  wszNcDns,  // DNS name of a Naming Context.
    FIND_DC_INFO **ppDCInfo)

/*++

Description:

    Finds a DC for DSNAME verification.
    
Arguments:

    dwFlags - Flags to Control operation of this routine. Currently 
        defined flags are:
        
        FIND_DC_USE_CACHED_FAILURES - fail without calling the locator if we have
            no cached GC and we last attempted a forced rediscovery less than a
            minute ago.
            
            NOTE: This flag is not enabled unless the FIND_DC_GC_ONLY flag
            is also specified.
     
        FIND_DC_USE_FORCE_ON_CACHE_FAIL - if a call to the locator should become
            necessary, use the "force" flag.

            NOTE: This flag is not enabled unless the FIND_DC_GC_ONLY flag
            is also specified.
            
        FIND_DC_GC_ONLY - If a this flag is specified to this routine, then the 
            routine will behave as it did when it was called FindGC back in the
            win2k days.  For Whistler and later it finds any NC specified.

        FIND_DC_FLUSH_INVALIDATED_DC_LIST - clear the invalidated DC list

    ppDCInfo - address of FIND_DC_INFO struct pointer which receives a thread
        state allocated struct on success return
        
Return values:

    0 on success.
    Sets and returns pTHStls->errCode on error.

--*/

{
    THSTATE                 *pTHS=pTHStls;
    DWORD                   err = 0;
    DOMAIN_CONTROLLER_INFOW *pDCInfo = NULL;
    DWORD                   cWaits = 0;
    DWORD                   maxWaits = 10;
    DWORD                   cBytes;
    FIND_DC_INFO            *pTmpInfo = NULL;
    FIND_DC_INFO            *pPermInfo = NULL;
    LARGE_INTEGER           liNow;
    BOOL                    fLocalForce = FALSE;
    DWORD                   cchDomainControllerName;
    DWORD                   dwLocatorFlags = 0;
    PVOID                   pEA;
    ULONG                   ulDSID = 0;
    DWORD                   dwExceptCode;
    
    HANDLE                  hGetDcContext;
    PWCHAR                  szDomainName;
    PWCHAR                  szSiteName;
    PWCHAR                  szDnsHostName = NULL;

    Assert(ppDCInfo);
    // If were not doing a GC_ONLY locator call, we'll need
    // a wszNcDns parameter.
    Assert(wszNcDns || (dwFlags & FIND_DC_GC_ONLY));  
    // If we're doing a GC_ONLY locator call, then we support 
    // other flags, but if we're looking for a certain NC, then 
    // we don't support any flags yet, as we don't cache the
    // stuff yet.
    Assert((dwFlags & FIND_DC_GC_ONLY) || (dwFlags == 0));

    *ppDCInfo = NULL;

    if (dwFlags & FIND_DC_FLUSH_INVALIDATED_DC_LIST) {
        flushDCInvalidatedList();
    }

    // DsGetDcName will go off machine and thus is subject to various network
    // timeouts, etc.  Although we only want one thread to find the GC at a 
    // time, we neither want all threads to be delayed unnecessarily, nor do 
    // we want to risk a critical section timeout.  So the first thread to 
    // need to find the GC sets gfFindInProgress, and no other thread waits 
    // more than 5 seconds for the GC to be found.  Thus only the first 
    // thread pays the price of a lengthy DsGetDcName() call.

    if(dwFlags & FIND_DC_GC_ONLY){
        
        // We're doing a GC only version, which means we must use the caching
        // login.  NOTE: In Blackcomb, when finding a DC for NDNCs is needed
        // to improve DSNAME atts across NDNCs, then someone should correct
        // this caching code to work for NDNCs too.

        for ( cWaits = 0; cWaits < maxWaits; cWaits++ )
        {
            GetSystemTimeAsFileTime((FILETIME *) &liNow);

            EnterCriticalSection(&gcsFindGC);
            if(liNow.QuadPart < gInvalidateHistory[1].time.QuadPart) {
                // Someone is playing games with system time.  Force sanity on the
                // cache. 
                gInvalidateHistory[1].time.QuadPart = liNow.QuadPart;
                if(gInvalidateHistory[1].time.QuadPart < 
                   gInvalidateHistory[0].time.QuadPart    ) {
                    gInvalidateHistory[0].time.QuadPart =
                        gInvalidateHistory[1].time.QuadPart;
                }           
            }

            FIND_DC_SANITY_CHECK;

            if ( gpGCInfo )
            {
                // We have a cached value - return it.
                __try {
                    *ppDCInfo = (FIND_DC_INFO *) THAllocEx(pTHS, gpGCInfo->cBytes);
                    // THAllocEx succeeds or excepts
                    memcpy(*ppDCInfo, gpGCInfo, gpGCInfo->cBytes);
                }
                __finally {
                    LeaveCriticalSection(&gcsFindGC);
                }
                return(0);
            }

            // No cached GC.
            if ((dwFlags & FIND_DC_USE_CACHED_FAILURES)
                && (liNow.QuadPart > gliTimeLastForcedLocatorCall.QuadPart)
                && ((liNow.QuadPart - gliTimeLastForcedLocatorCall.QuadPart)
                    < gliHonorFailureWindow.QuadPart))
            {
                // No cached GC, and we last requested the locator to find a GC
                // with force less than a minute ago.  Assume that a locator
                // call now would also fail, and thereby save the bandwidth we'd
                // consume by hitting the locator again.
                LeaveCriticalSection(&gcsFindGC);
                return(SetGCVerifySvcError(gdwLastFailure));
            }

            // make sure no two threads request DC discovery simultaneously
            if (InterlockedExchange(&gfFindInProgress, TRUE) == FALSE)
            {
                // The logic for setting gfForceNextFindGC in InvalidateGC works
                // well when there is a high rate of FindDC (and potentially
                // subsequent InvalidateGC) calls.  However, in the low call
                // rate scenario, we may not get a second InvalidateGC call
                // within the gliForceRediscoveryWindow time frame.  So here
                // we additionaly stipulate that if we've gone too long w/o
                // finding a new GC since the last invalidation, then we
                // should force rediscovery anyway.

                if (    (   (dwFlags & FIND_DC_USE_FORCE_ON_CACHE_FAIL)
                         && (0 != gSeqNumGC))
                        // No cached GC, and caller explicitly asked us to use
                        // force to find a new one should we need to call the
                        // locator, and this is not our very first attempt to
                        // find a GC after boot.  (Don't want to unnecesarily
                        // force rediscovery if the only reason we don't have a
                        // GC cached is that we've never tried to find one.)

                     || (   (0 != liNow.QuadPart)
                         && (0 != gInvalidateHistory[1].time.QuadPart)
                         && ((liNow.QuadPart - gInvalidateHistory[1].time.QuadPart) >
                                                        gliForceWaitExpired.QuadPart) ) )
                        // We queried current time successfully AND there's been
                        // at least one invalidation (i.e. not the startup case)
                        // AND its been more than gliForceWaitExpired since
                        // the last invalidation.
                {
                    gfForceNextFindGC = TRUE;
                }

                fLocalForce = gfForceNextFindGC;
                LeaveCriticalSection(&gcsFindGC);
                break;
            }

            LeaveCriticalSection(&gcsFindGC);
            // some other thread has requested a find. Let's wait for it to finish.
            Sleep(500);
        }

        if ( cWaits >= maxWaits ) 
        {
            // We waited for a half-second 10 times, while some other thread attempted a discovery.
            // It still has not found anything. Bail.
            return(SetGCVerifySvcError(ERROR_TIMEOUT));
        }

    } else {
        // We always force the locator for any NC, we'll need to
        // change this once we start using this code for more than
        // crossRef nCName verification.
        fLocalForce = TRUE;
    }
    // End check GC cache.

    // We should not touch any of the protected globals outside the gcsFindGC
    // lock with two exceptions.  The thread here now also set gfFindInProgress
    // and will be the only one to reset it.  And only the "holder" of 
    // gfFindInProgress may increment gSeqNumGC.

    __try {

        // Need to get a new GC or DC address.  CliffV & locator.doc say
        // that if NULL is passed for the domain name and we specify
        // DS_GC_SERVER_REQUIRED, then he'll automatically use the
        // enterprise root domain which is where GCs are registered.
        // Similarly, NULL for site will find the closest available site.

        __try {

            // Setup the locator flages.
            dwLocatorFlags = (fLocalForce ? DS_FORCE_REDISCOVERY : 0);
            if(dwFlags & FIND_DC_GC_ONLY){
                dwLocatorFlags |= (DS_RETURN_DNS_NAME | 
                                   DS_DIRECTORY_SERVICE_REQUIRED |
                                   DS_GC_SERVER_REQUIRED);
            } else {             
                // We always force rediscovery on for non GCs, but this
                // should be changed when we start using this interface
                // for general DC verification for adding cross-NC DN
                // references in Blackcomb.
                dwLocatorFlags |= (DS_ONLY_LDAP_NEEDED |
                                   DS_FORCE_REDISCOVERY);
            }

            // Use dsDsrGetDcNameEx2 so mkdit/mkhdr can link to core.lib.
            err = dsDsrGetDcNameEx2(
                            NULL,               // computer name
                            NULL,               // account name
                            0x0,                // allowable account control
                                                // Cliff says use 0x0 in GC case
                            ((dwFlags & FIND_DC_GC_ONLY) ? NULL : wszNcDns),  // Nc DNS Name
                            NULL,               // domain guid
                            NULL,               // site name
                            dwLocatorFlags,
                            &pDCInfo);

            if(err){
                // If we've an error, need to set the DSID for the 
                // logged event/error below.
                ulDSID = DSID(FILENO, __LINE__);
            }

        } __except(GetExceptionData(GetExceptionInformation(), 
                                    &dwExceptCode, 
                                    &pEA, 
                                    &err, 
                                    &ulDSID)) {
              // make sure err is set
              if (err == 0) {
                  Assert(!"Error is not set");
                  err = ERROR_DS_UNKNOWN_ERROR;
              }
        }

        if (err) {
            __leave;
        }

        // Make sure the DC returned is not on invalidated list
        if (isDCInvalidated(pDCInfo->DomainControllerName)) {
            // Oops. This DC was invalidated in the last gliInvalidationPeriod time interval.
            // This indeed can happen because DsrGetDcNameEx2 (the locator) uses a ping mechanism
            // that is different from the way we talk to GCs. That is, a GC might be alive from
            // locator's point of view, but not usable from ours: for example, we could not bind
            // to it because of the time skew.
            // In this case, we fall back to using DsGetDcOpen/Next/Close enumerator mechanism.
            // In Longhorn, DsrGetDcNameEx2 should be extended to accept a list of "no-good" DCs.
            // Then, this code can be eliminated.

            NetApiBufferFree(pDCInfo); // we don't need this anymore, it's no good.
            pDCInfo = NULL;
            
            if (dwFlags & FIND_DC_GC_ONLY) {
                szDomainName = gAnchor.pwszRootDomainDnsName;
            }
            else {
                szDomainName = wszNcDns;
            }
            dwLocatorFlags &= DS_OPEN_VALID_FLAGS;
            
            err = DsGetDcOpenW(
                    szDomainName,   // domain DNS name
                    0,              // OptionFlags
                    NULL,           // SiteName (not needed)
                    NULL,           // DomainGuid (not needed)
                    NULL,           // DnsForestName (not needed)
                    dwLocatorFlags, // DC flags
                    &hGetDcContext  // out -- interator handle
                );
            if (err) {
                ulDSID = DSID(FILENO, __LINE__);
                __leave;
            }
            while (TRUE) {
                err = DsGetDcNextW(
                        hGetDcContext,                  // iterator handle
                        NULL,                           // SockAddressCount
                        NULL,                           // SockAddresses
                        &szDnsHostName                  // returned host name
                    );
                if (err) {
                    ulDSID = DSID(FILENO, __LINE__);
                    if (err == ERROR_NO_MORE_ITEMS) {
                        // We got to the end of the list without finding
                        // a non-invalidated GC. Map to an error that
                        // DsrGetDcNameEx2 returns when it can not find
                        // a GC.
                        err = ERROR_NO_SUCH_DOMAIN;
                    }
                    break;
                }

                // now, check if this DC name has been invalidated
                if (!isDCInvalidated(szDnsHostName)) {
                    // found a DC that is good.
                    break;
                }
                NetApiBufferFree(szDnsHostName);
                szDnsHostName = NULL;
            }
            DsGetDcCloseW(hGetDcContext);
            if (err) {
                // we did not find an appropriate DC.
                __leave;
            }

            // OK, we got a DC that is not invalidated. 
            // Get the domain DNS and site name for this DC.
            err = readDcInfo(pTHS, szDnsHostName, &szDomainName, &szSiteName, &ulDSID);
            if (err) {
                NetApiBufferFree(szDnsHostName);
                __leave;
            }

            // now, we can construct the DOMAIN_CONTROLLER_INFOW structure
            err = makeFakeDCInfo(szDnsHostName, szDomainName, szSiteName, &pDCInfo, &ulDSID);
            NetApiBufferFree(szDnsHostName);
            THFreeEx(pTHS, szDomainName);
            THFreeEx(pTHS, szSiteName);
            if (err) {
                // could not alloc memory. Bail
                __leave;
            }
        }

        // WLees claims we must use a DNS name, not a dotted ip name,
        // in order to get SPN-based mutual authentication.  So we always
        // use the DomainControllerName, not DomainControllerAddress.

        cchDomainControllerName = wcslen(pDCInfo->DomainControllerName) + 1;
        cBytes = cchDomainControllerName;
        cBytes += 1 + wcslen(pDCInfo->DomainName);
        cBytes *= sizeof(WCHAR);
        cBytes += sizeof(FIND_DC_INFO);
        
        // Make FIND_DC_INFO to pass back to caller.
        pTmpInfo = (FIND_DC_INFO *) THAllocEx(pTHS, cBytes);
        pTmpInfo->cBytes = cBytes;
        pTmpInfo->seqNum = (dwFlags & FIND_DC_GC_ONLY)? ++gSeqNumGC : 0;
        pTmpInfo->cchDomainNameOffset = cchDomainControllerName;
        wcscpy(pTmpInfo->addr, pDCInfo->DomainControllerName);
        wcscpy(&pTmpInfo->addr[cchDomainControllerName],
               pDCInfo->DomainName);

        *ppDCInfo = pTmpInfo;   
        
        // If we're doing a GC locate, then we must cache the results
        // to ensure we don't force the locator too often.
        if(dwFlags & FIND_DC_GC_ONLY){
            pPermInfo = malloc(pTmpInfo->cBytes);
            if(NULL == pPermInfo){
                err = ERROR_OUTOFMEMORY;
                ulDSID = DSID(FILENO, __LINE__);

            } else {
                memcpy(pPermInfo, pTmpInfo, pTmpInfo->cBytes);
                //
                // If the returned GC is not from a "close site"
                // queue a task to invalidate it after a while to 
                // initiate a failback
                //

                if (!(pDCInfo->Flags & DS_CLOSEST_FLAG )) {

                    FIND_DC_INFO *pInvalidateInfo;                        

                    pInvalidateInfo = malloc(pTmpInfo->cBytes);
                    if (NULL==pInvalidateInfo) {
                        err = ERROR_OUTOFMEMORY;
                        ulDSID = DSID(FILENO, __LINE__);
                        free(pPermInfo);
                        pPermInfo = NULL;
                    } else {

                       memcpy(pInvalidateInfo,pTmpInfo,pTmpInfo->cBytes);

                       InsertInTaskQueue( 
                          TQ_FailbackOffsiteGC, 
                          pInvalidateInfo, 
                          gdwFindGcOffsiteFailbackTime * 60
                         );
                    }
                }
            }

            if (ERROR_SUCCESS==err) {
                //
                // We succeeding in finding a GC and succeeded in caching
                // it
                //

                LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_GC_FOUND,
                         szInsertWC(pDCInfo->DomainControllerName),
                         szInsertWC(pDCInfo->DcSiteName),
                         NULL );
            }


        }
    }
    __finally
    {
        if(pDCInfo) { NetApiBufferFree(pDCInfo); }

        if(dwFlags & FIND_DC_GC_ONLY){

            EnterCriticalSection(&gcsFindGC);

            // Should only have come this far if there was no cached address
            // to return to start with and thus find in progress should be set.
            Assert(!gpGCInfo && gfFindInProgress);

            if ( pPermInfo ) {
                // Save new GC info to global.
                gpGCInfo = pPermInfo;
                // Reset global force flag if we did a force rediscovery.
                if ( fLocalForce ) {
                    gfForceNextFindGC = FALSE;
                }
            }

            // Remember the time at which we last forced a locator call (successful
            // or not).
            if ( fLocalForce ) {
                gliTimeLastForcedLocatorCall.QuadPart = liNow.QuadPart;
            }
            
            gfFindInProgress = FALSE;
            FIND_DC_SANITY_CHECK;

            LeaveCriticalSection(&gcsFindGC);
        }
    }

    if ( err ){
        gdwLastFailure = err;
        Assert(ulDSID != 0); // No big deal if it is 0 though.
        if(dwFlags & FIND_DC_GC_ONLY){                      
            return(DoSetGCVerifySvcError(err, ulDSID));
        } else {
            return(SetDCVerifySvcError(L"", wszNcDns, err, ulDSID));
        }
    }

    return(0);
}

DWORD
GCGetVerifiedNames (
        IN  THSTATE *pTHS,
        IN  DWORD    count,
        IN  PDSNAME *pObjNames,
        OUT PDSNAME *pVerifiedNames
        )
/*++
  Description:
      Given an array of GUIDs, contact a GC and ask for an entinf for each.  We
      need the current string name of the objects and whether they are deleted
      or not.

      The only known consumer of this routine is the stale phantom cleanup
      daemon. 

  Parameters:
      pTHS - The thread state.
      count - how many guids?
      pObjGuids - the guids themselves
      ppEntInf - place to return the entinf array

  Return values:
      returns 0 if all went well, an error code otherwise.
  
--*/      
{
    DRS_MSG_VERIFYREQ           VerifyReq;
    DRS_MSG_VERIFYREPLY         VerifyReply;
    SCHEMA_PREFIX_TABLE *       pLocalPrefixTable;
    ATTR                        Attr;
    DWORD                       i;
    DWORD                       errRpc;
    DWORD                       dwReplyVersion;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap=NULL;
    
    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    Attr.attrTyp = ATT_IS_DELETED;
    Attr.AttrVal.valCount = 0;
    Attr.AttrVal.pAVal = NULL;
    
    
    // Construct DRSVerifyNames arguments.
    
    memset(&VerifyReq, 0, sizeof(VerifyReq));
    memset(&VerifyReply, 0, sizeof(VerifyReply));

    VerifyReq.V1.dwFlags = DRS_VERIFY_DSNAMES;
    VerifyReq.V1.cNames = count;
    VerifyReq.V1.rpNames = pObjNames;
    VerifyReq.V1.PrefixTable = *pLocalPrefixTable;

    // Ask for IS_DELETED
    VerifyReq.V1.RequiredAttrs.attrCount = 1;
    VerifyReq.V1.RequiredAttrs.pAttr = &Attr;



    Assert(!gAnchor.fAmGC);

    errRpc = I_DRSVerifyNamesFindGC(pTHS,
                                    NULL,
                                    NULL,
                                    1,
                                    &VerifyReq,
                                    &dwReplyVersion,
                                    &VerifyReply,
                                    0);

    if ( errRpc || VerifyReply.V1.error ) {
        // Assume that RPC errors means the GC is not available
        // or doesn't support the extension.        
        // Map both errors to "unavailable".  From XDS spec, "unavailable"
        // means "some part of the directory is currently not available."
        // Note that VerifyReply.V1.error indicates a general processing
        // error at the GC, not the failure to validate a given DSNAME.
        // Names which don't validate are represented as NULL pointers in
        // the reply.
        
        return(SetGCVerifySvcError(errRpc ? errRpc : VerifyReply.V1.error));
    }
    
    // Make sure that the DS didn't shut down while we were gone
    
    if (eServiceShutdown) {
        return ErrorOnShutdown();
    }

    hPrefixMap = PrefixMapOpenHandle(&VerifyReply.V1.PrefixTable,
                                     pLocalPrefixTable);
    

    // Save verified names in the thread state.
    for ( i = 0; i < VerifyReply.V1.cNames; i++ ) {
        pVerifiedNames[i] = VerifyReply.V1.rpEntInf[i].pName;
        if (NULL!=VerifyReply.V1.rpEntInf[i].pName) {
            GCVerifyCacheAdd(hPrefixMap, &VerifyReply.V1.rpEntInf[i]);
        }
    }
    
    if (NULL!=hPrefixMap) {
        PrefixMapCloseHandle(&hPrefixMap);
    }

    return 0;
    
}

BOOL
IsClientHintAKnownDC(
              IN  THSTATE *pTHS,
              IN  PWCHAR  pVerifyHint
              )
/*++
  Description:
      This function verifies that the the dns hostname that the client is
      offering as a hint about where to verify a external name is actually
      a DC in the forest.  It does this by searching the config container for 
      server objects whose dnsHostName attribute equals the hostname passed
      by the client.
    
  Parameters:
      pTHS - The thread state.
      pGCVerifyHint - The hostname to verify.

  Return values:
      returns TRUE if the hostname is truly a DC, otherwise FALSE.
  
--*/      
{
    SEARCHARG  SearchArg;
    SEARCHRES  SearchRes;
    FILTER     AndFilter, ObjCategoryFilter, DnsHostNameTerminatedFilter;
    FILTER     DnsHostNameEqualityFilter, OrFilter;
    ENTINFSEL  HostNameSelection;
    ENTINFLIST *pEntInfList;
    CLASSCACHE *pCC;
    ATTR       attr;
    PWCHAR     pwchHostName;
    DWORD      cbHostName;
    BOOL       fDSA;
    BOOL       fDBCreated = FALSE;
    DWORD      i;
    DWORD      dwErr;
    BOOL       fRet = FALSE;


    // Make sure that we have one copy of the verify hint that has a period
    // at the end and one that does not, as these are equivalent in a 
    // fully qualified dns name.
    cbHostName = wcslen(pVerifyHint) * sizeof(WCHAR);
    if (cbHostName < sizeof(WCHAR)) {
        return FALSE;
    }
    if (L'.' == pVerifyHint[cbHostName/sizeof(WCHAR)-1]) {
        if (cbHostName < (sizeof(WCHAR) * 2)) {
            // They supplied a single period.  That's not going to fly.
            return FALSE;
        }
    } else {
        cbHostName += sizeof(WCHAR);
    }

    //Make a copy of the hint with a period at the end.
    pwchHostName = THAllocEx(pTHS, cbHostName);
    memcpy(pwchHostName, pVerifyHint, cbHostName - sizeof(WCHAR));
    pwchHostName[cbHostName/sizeof(WCHAR)-1] = L'.';

    
    // Save the state of the fDSA flag on pTHS so that we can clear it for 
    // this operation.
    fDSA = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    __try {

        if (NULL == pTHS->pDB) {
            DBOpen(&pTHS->pDB);
            fDBCreated = TRUE;
        }

        __try {
            memset(&SearchArg, 0, sizeof(SearchArg));
            InitCommarg(&SearchArg.CommArg);

            SearchArg.pObject = gAnchor.pConfigDN;  // Could the Sites container be used instead?

            if (dwErr = DBFindDSName(pTHS->pDB, SearchArg.pObject)) {
                // This should never happen.
                __leave;
            }

            SearchArg.pResObj = CreateResObj(pTHS->pDB, SearchArg.pObject);

            pCC = SCGetClassById(pTHS, CLASS_SERVER);
            Assert(pCC);

            //set filter (objCategory==server)&&((dnsHostName=xxx)||(dnsHostName=xxx.*))
            memset(&AndFilter,0,sizeof(AndFilter));
            AndFilter.choice = FILTER_CHOICE_AND;
            AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;
            AndFilter.FilterTypes.And.count = 2;

            memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
            ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
            ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                             pCC->pDefaultObjCategory->structLen;
            ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                             (BYTE*)(pCC->pDefaultObjCategory);
            ObjCategoryFilter.pNextFilter = &OrFilter;

            memset(&OrFilter, 0, sizeof(OrFilter));
            OrFilter.choice = FILTER_CHOICE_OR;
            OrFilter.FilterTypes.Or.pFirstFilter = &DnsHostNameTerminatedFilter;
            OrFilter.FilterTypes.Or.count = 2;

            memset(&DnsHostNameTerminatedFilter,0,sizeof(DnsHostNameTerminatedFilter));
            DnsHostNameTerminatedFilter.choice = FILTER_CHOICE_ITEM;
            DnsHostNameTerminatedFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
            DnsHostNameTerminatedFilter.FilterTypes.Item.FilTypes.ava.type = ATT_DNS_HOST_NAME;
            DnsHostNameTerminatedFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                (PUCHAR)pwchHostName;
            DnsHostNameTerminatedFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = 
                cbHostName;
            DnsHostNameTerminatedFilter.pNextFilter = &DnsHostNameEqualityFilter;

            memset(&DnsHostNameEqualityFilter, 0, sizeof(DnsHostNameEqualityFilter));
            DnsHostNameEqualityFilter.choice = FILTER_CHOICE_ITEM;
            DnsHostNameEqualityFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
            DnsHostNameEqualityFilter.FilterTypes.Item.FilTypes.ava.type = ATT_DNS_HOST_NAME;
            DnsHostNameEqualityFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = 
                               (PUCHAR)pVerifyHint;
            DnsHostNameEqualityFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = 
                               cbHostName - sizeof(WCHAR);

            // we need the dnsHostName attribute
            memset(&HostNameSelection,0,sizeof(ENTINFSEL));
            HostNameSelection.attSel = EN_ATTSET_LIST;
            HostNameSelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
            HostNameSelection.AttrTypBlock.attrCount = 1;

            memset(&attr,0,sizeof(attr));
            HostNameSelection.AttrTypBlock.pAttr = &attr;
            attr.attrTyp = ATT_DNS_HOST_NAME;

            SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
            SearchArg.bOneNC  = TRUE;
            SearchArg.pFilter = &AndFilter;
            SearchArg.pSelection = &HostNameSelection;

            SearchArg.CommArg.ulSizeLimit = 1000;

            memset(&SearchRes,0,sizeof(SearchRes));

            if (dwErr = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
                // *pulDSID = DSID(FILENO, __LINE__);
                Assert(!dwErr);
                __leave;
            }
            if (SearchRes.count == 0) {
                // Nothing matched.
                __leave;
            }

            for (i=0, pEntInfList = &SearchRes.FirstEntInf;
                 i < SearchRes.count && NULL != pEntInfList;
                 i++, pEntInfList = pEntInfList->pNextEntInf ) {

                Assert(1 == pEntInfList->Entinf.AttrBlock.attrCount);
                Assert(pEntInfList->Entinf.AttrBlock.pAttr);
                Assert(pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.valCount == 1);
                Assert(pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.pAVal->valLen);
                Assert(pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.pAVal->pVal);

                if (pEntInfList->Entinf.AttrBlock.pAttr &&
                    pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.valCount == 1 &&
                    pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.pAVal &&
                    pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.pAVal->valLen &&
                    pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.pAVal->pVal ) {

                    DWORD tmpSize;
                    tmpSize = pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.pAVal->valLen;

                    if (cbHostName < tmpSize + sizeof(WCHAR)) {
                        pwchHostName = THReAllocEx(pTHS, pwchHostName, tmpSize + sizeof(WCHAR));
                    }
                    memcpy(pwchHostName,
                           pEntInfList->Entinf.AttrBlock.pAttr->AttrVal.pAVal->pVal,
                           tmpSize);
                    pwchHostName[tmpSize/sizeof(WCHAR)] = L'\0';

                    if (DnsNameCompare_W(pVerifyHint, pwchHostName)) {
                        fRet = TRUE;
                        break;
                    }
                }
            }

        }
        __finally{
            if (fDBCreated) {
                DBClose(pTHS->pDB, FALSE);
            }
        }

    }
    __finally {
        pTHS->fDSA = fDSA;

        THFreeEx(pTHS, pwchHostName);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\gtcache.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       gtcache.c
//
//--------------------------------------------------------------------------


#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <dsjet.h>		/* for error codes */
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>
#include <filtypes.h>
#include <usn.h>
#include "dsexcept.h"
#include <dsconfig.h>                   // Definition of mask for visible
                                        // containers
#include "debug.h"          // standard debugging header
#define DEBSUB "GTCACHE:"              // define the subsystem for debugging


#include <fileno.h>
#define  FILENO FILENO_GTCACHE

HANDLE hevGTC_OKToInsertInTaskQueue;
CRITICAL_SECTION csGroupTypeCacheRequests;

// This variable holds the DNT that the group type cache manager is currently
// working on adding to the cache.  It should only be set/reset inside the
// critical section.  The invalidation routine may set it to INVALIDDNT as a
// signal to the group type cache manager that it should invalidate the DNT it
// is working on. Thus, the manager may take the critsec and decide to work on
// DNT 5, then release the crit sec.  The invalidator may then take the crit sec
// and notice that the manager is working on DNT 5.  If the invalidator is
// trying to invalidate DNT 5, it sets gCurrentGroupTYpeCacheDNT to INVALIDDNT
// and releases the critsec.  The manager finishes adding 5 to the cache, and
// then takes the critsec.  It notices that someone has set the
// gCurrentGroupTypeCacheDNT value to INVALIDDNT, so it goes back and
// invalidates the entry it just put into the cache.
volatile DWORD gCurrentGroupTypeCacheDNT=INVALIDDNT;

#define GROUP_TYPE_CACHE_RECS_PER_BUCKET 8

typedef struct _GROUPTYPECACHEBUCKET {
    DWORD index;
    GROUPTYPECACHERECORD entry[GROUP_TYPE_CACHE_RECS_PER_BUCKET];
} GROUPTYPECACHEBUCKET;
 
typedef struct _GROUPTYPECACHEGUIDINDEX {
    DWORD index;
    GROUPTYPECACHEGUIDRECORD entry[GROUP_TYPE_CACHE_RECS_PER_BUCKET];
} GROUPTYPECACHEGUIDINDEX;

// NOTE: we hard code the size of our group cache to be 512 buckets.
#define NUM_GROUP_TYPE_CACHE_BUCKETS 512
#define GROUP_TYPE_CACHE_MASK        511

GROUPTYPECACHEBUCKET *gGroupTypeCache=NULL;
GROUPTYPECACHEGUIDINDEX *gGroupTypeGuidIndex=NULL;
volatile gbGroupTypeCacheInitted = FALSE;
ULONG GroupTypeCacheSize=0;
ULONG GroupTypeCacheMask=0;

typedef struct _GROUPTYPECACHEREQUEST {
    DWORD DNT;
    DWORD count;
} GROUPTYPECACHEREQUEST;

#define NUM_GROUP_TYPE_CACHE_REQUESTS 100
GROUPTYPECACHEREQUEST gCacheRequests[NUM_GROUP_TYPE_CACHE_REQUESTS];
volatile DWORD gulCacheRequests = 0;

#if DBG
DWORD gtCacheDNTTry = 0;
DWORD gtCacheDNTHit = 0;
DWORD gtCacheGuidTry = 0;
DWORD gtCacheGuidHit = 0;
DWORD gtCacheCrawlTry = 0;
DWORD gtCacheCrawlHit = 0;
DWORD gtCacheTry = 0;
// NOTE, we use ++ instead of interlocked or critsec because these are simple,
// debug only, internal perfcounters.  They are only visible with a debugger.
// The perf teams tells us that in cases where the occasional increment can
// afford to be lost, ++ instead of interlocked can make a measurable
// performance boost.
#define INC_DNT_CACHE_TRY  gtCacheDNTTry++
#define INC_DNT_CACHE_HIT  gtCacheDNTHit++
#define INC_GUID_CACHE_TRY gtCacheGuidTry++
#define INC_GUID_CACHE_HIT gtCacheGuidHit++
#define INC_GUID_CRAWL_TRY gtCacheCrawlTry++
#define INC_GUID_CRAWL_HIT gtCacheCrawlHit++
#define INC_GT_CACHE_TRY   gtCacheTry++
#else

#define INC_DNT_CACHE_TRY 
#define INC_DNT_CACHE_HIT 
#define INC_GUID_CACHE_TRY
#define INC_GUID_CACHE_HIT
#define INC_GUID_CRAWL_TRY
#define INC_GUID_CRAWL_HIT
#define INC_GT_CACHE_TRY   
#endif


DWORD
GroupTypeGuidHashFunction (
        GUID guid
        )
/*++     
  Description:
      Hash function to look things up by GUID.

      This first version of a hash function is very simple.  Cast the
      GUID to be an array of DWORDs, sum, then mod by size of cache.

      
--*/
{
    DWORD *pTemp = (DWORD *)&guid;
    DWORD i, acc=0;

    for(i=0;i<(sizeof(GUID)/sizeof(DWORD));i++) {
        acc+= pTemp[i];
    }

    return acc & GroupTypeCacheMask;
}

 
BOOL
GetGroupTypeCacheElement (
        GUID  *pGuid,
        DWORD *pulDNT,
        GROUPTYPECACHERECORD *pGroupTypeCacheRecord)
/*++
    Look up a dnt in the grouptype cache.  If it is there, copy the data from the
    cache and return it.  If it isn't there, add the DNT to the request queue.
    Finally, if noone else has signalled the grouptype cache manager, do so.       
--*/
{
    GROUPTYPECACHEREQUEST *pNewRequest;
    DWORD i, j;
    
    DPRINT2(4,"GT Lookup, pGUid = %X, *pulDNT = %X\n",pGuid,*pulDNT);

    INC_GT_CACHE_TRY;
    
    memset(pGroupTypeCacheRecord, 0, sizeof(GROUPTYPECACHERECORD));

    if(GroupTypeCacheSize) {
        if(pGuid) {
            // We aren't looking up by DNT yet.
            *pulDNT = INVALIDDNT;
            // First, look for the guid in the guid index.
            DPRINT(5,"Looking in GT GUID index\n");
            INC_GUID_CACHE_TRY;
            i = GroupTypeGuidHashFunction(*pGuid);
            for(j=0;j<GROUP_TYPE_CACHE_RECS_PER_BUCKET;j++) {
                if(gGroupTypeGuidIndex[i].entry[j].DNT != INVALIDDNT &&
                   (0 == memcmp(&gGroupTypeGuidIndex[i].entry[j].guid,
                                pGuid,
                                sizeof(GUID)))) {
                    // Found it.
                    *pulDNT = gGroupTypeGuidIndex[i].entry[j].DNT;
                    INC_GUID_CACHE_HIT;
                    break;
                }
            }

            if(*pulDNT == INVALIDDNT) {
                // Couldn't find the guid in the guid to DNT cache, so we have
                // to do this the hard way.
                DPRINT(5,"Looking in GT by GUID\n");
                INC_GUID_CRAWL_TRY;
                
                // Couldn't find it in the guid index.  However, there are some
                // cases where even that is not good enough, and it still might
                // be in the normal cache.
                // Look through the cache for the guid specified
                for(i=0;i<NUM_GROUP_TYPE_CACHE_BUCKETS;i++) {
                    for(j=0;j<GROUP_TYPE_CACHE_RECS_PER_BUCKET;j++) {
                        if(gGroupTypeCache[i].entry[j].DNT != INVALIDDNT &&
                           (memcmp(&gGroupTypeCache[i].entry[j].Guid,
                                   pGuid,
                                   sizeof(GUID)) == 0)) {
                            // Found it.
                            *pulDNT = gGroupTypeCache[i].entry[j].DNT;
                            // set up the return pGrouptypeCacheRecord structure
                            memcpy(pGroupTypeCacheRecord,
                                   &gGroupTypeCache[i].entry[j],
                                   sizeof(GROUPTYPECACHERECORD));
                            
                            if(pGroupTypeCacheRecord->DNT == *pulDNT &&
                               (memcmp(&pGroupTypeCacheRecord->Guid,
                                       pGuid,
                                       sizeof(GUID)) == 0)) {
                                // Still good, no one has munged the record
                                // during the copy. 
                                DPRINT1(5,"Found 0x%X in GT by GUID\n",*pulDNT);
                                INC_GUID_CRAWL_HIT;
                                return TRUE;
                            }
                            // Someone threw us out of the cache while we were
                            // copying.
                            DPRINT(4,"Thrown out of GT by GUID (1)\n");
                            goto NotFound;
                        }
                    }
                }
            }
        }

        if(*pulDNT != INVALIDDNT) {
            DPRINT1(5,"Looking for 0x%X in GT cache\n", *pulDNT);
            INC_DNT_CACHE_TRY;
            
            // Look through the cache for the DNT specified.
            i = (*pulDNT & GroupTypeCacheMask);
            
            for(j=0;j<GROUP_TYPE_CACHE_RECS_PER_BUCKET;j++) {
                if(gGroupTypeCache[i].entry[j].DNT == *pulDNT) {
                    // Found it.
                    // set up the return pGrouptypeCacheRecord structure
                    memcpy(pGroupTypeCacheRecord,
                           &gGroupTypeCache[i].entry[j],
                           sizeof(GROUPTYPECACHERECORD));
                    
                    if(pGroupTypeCacheRecord->DNT == *pulDNT) {
                        // Still good, no one has munged the record during the
                        // copy. 
                        DPRINT1(5,"Found 0x%X in GT cache by DNT\n", *pulDNT);
                        INC_DNT_CACHE_HIT;
                        return TRUE;
                    }
                    // Someone threw us out of the cache while we were copying.
                    DPRINT(4,"Thrown out of GT by DNT\n");
                    goto NotFound;
                }
            }
        }
    }

 NotFound:
    // Not Found.
    DPRINT2(5,"GT Lookup failed, pGUid = %X, *pulDNT = %X\n",pGuid,*pulDNT);

    if(!pGuid) {
        // We have a DNT to try to put in the cache
        GroupTypeCacheAddCacheRequest (*pulDNT);
    }

    return FALSE;
}

VOID
GroupTypeCacheAddCacheRequest (
        DWORD ulDNT
        )
{
    BOOL fDone;
    DWORD i;

    DPRINT1(4,"Adding 0x%X to cache list request\n",ulDNT);
    // add this to the list of things we would like cached.
    EnterCriticalSection(&csGroupTypeCacheRequests);
    __try {
        fDone = FALSE;
        for(i=0;i<gulCacheRequests && !fDone ;i++) {
            if(gCacheRequests[i].DNT == ulDNT) {
                fDone = TRUE;
                gCacheRequests[i].count += 1;
            }
        }
        
        if(!fDone &&
           // Not already inserted.
           gulCacheRequests < NUM_GROUP_TYPE_CACHE_REQUESTS) {
            // space to insert.
            gCacheRequests[gulCacheRequests].DNT = ulDNT;
            gCacheRequests[gulCacheRequests].count = 0;
            gulCacheRequests++;
        }
    }
    __finally {
        LeaveCriticalSection(&csGroupTypeCacheRequests);
    }

#if DBG
    if(fDone) {
        DPRINT1(5,"0x%X already in cache list request\n",ulDNT);
    }
    else if(gulCacheRequests < NUM_GROUP_TYPE_CACHE_REQUESTS) {
        DPRINT1(5,"Added 0x%X to cache list request\n",ulDNT);
    }
    else {
        DPRINT1(5,"No room in cache list request, 0x%X not added\n",ulDNT);
    }
#endif
        
    
    // We got here, which means we missed when looking in the cache.  So, either
    // we added our DNT to the request array, or the request array was full, or
    // we already found our object in the request array.  In anycase, the
    // grouptypecache manager should be put in the task queue.  Unless, that is,
    // someone else already did so and the cachemanager hasn't managed to start
    // running to handle that request.
    if(0==WaitForSingleObject(hevGTC_OKToInsertInTaskQueue, 0)) {
        DPRINT(4,"Signalling the grouptype cache manager\n");
        // Signal that there are some things to be cached.
        ResetEvent(hevGTC_OKToInsertInTaskQueue);
        InsertInTaskQueue(TQ_GroupTypeCacheMgr, NULL, 300);
    }
    
    return;
}

void
gcache_AddToCache (
        DWORD DNT
        )
/*++
    Worker routine for the grouptype cache manager.  Opens a DBPOS, finds the
    DNT, reads the data, closes the DBPOS, then puts the data in the grouptype
    cache. 

--*/
{
    DWORD actualNCDNT;
    ATTRTYP actualClass;
    DWORD actualGroupType;
    ULONG len, i, j;
    PDSNAME pDSName = NULL;
    THSTATE *pTHS = pTHStls;
    DWORD flags=0;
    DWORD err=0;
    
    DPRINT1(4,"Adding 0x%X to gtcache\n",DNT);
    
    DBOpen(&(pTHS->pDB));
    __try { //Except
        __try { //Finally
            // Try to find a DNT.
            if(DBTryToFindDNT(pTHS->pDB,DNT)) {
                __leave;
            }

            if(!DBCheckObj(pTHS->pDB)) {
                __leave;
            }
            
            //
            // Obtain the DS Name of the Currently Positioned Object
            //
            
            // Get the data
            if ( 0 != DBGetSingleValue(
                    pTHS->pDB,
                    FIXED_ATT_NCDNT,
                    &actualNCDNT,
                    sizeof(actualNCDNT),
                    NULL) ) {
                __leave;
            }
            
            if ( 0 != DBGetSingleValue(
                    pTHS->pDB,
                    ATT_GROUP_TYPE,
                    &actualGroupType,
                    sizeof(actualGroupType),
                    NULL) ) {

                __leave;
            }
            
            if ( 0 != DBGetSingleValue(
                    pTHS->pDB,
                    ATT_OBJECT_CLASS,
                    &actualClass,
                    sizeof(actualClass),
                    NULL) ) {
                __leave;
            }

            if(DBGetAttVal(
                    pTHS->pDB,
                    1,
                    ATT_OBJ_DIST_NAME,
                    DBGETATTVAL_fSHORTNAME,
                    0,
                    &len,
                    (UCHAR **)&pDSName)) {
                __leave;
            }

            if(DBHasValues(pTHS->pDB,ATT_SID_HISTORY)) {
                flags |= GTC_FLAGS_HAS_SID_HISTORY;
            }

            // reset the structure length of the dsname to be minimal
            pDSName->structLen = sizeof(DSNAME);

            // Find the correct location in the cache.
            i = (DNT & GroupTypeCacheMask);
            // First, a quick scan looking for an empty slot
            for(j=0;
                (j < GROUP_TYPE_CACHE_RECS_PER_BUCKET &&
                 gGroupTypeCache[i].entry[j].DNT != INVALIDDNT);
                j++);

            if(j == GROUP_TYPE_CACHE_RECS_PER_BUCKET) {
                // didn't find an unused slot.  Use a simple queue replacement
                // policy. 
                GUID deadGuid;
                DWORD k,l;
                
                j = gGroupTypeCache[i].index;
                gGroupTypeCache[i].index =
                    (gGroupTypeCache[i].index + 1) %
                        GROUP_TYPE_CACHE_RECS_PER_BUCKET;
                
                // We are replacing a live element in the group type cache.
                // That means that there may be an element in the guid index
                // that is no longer needed.  Look for it.
                deadGuid = gGroupTypeCache[i].entry[j].Guid;
                
                k = GroupTypeGuidHashFunction(deadGuid);
                for(l=0;
                    (l < GROUP_TYPE_CACHE_RECS_PER_BUCKET &&
                     gGroupTypeGuidIndex[k].entry[l].DNT != INVALIDDNT &&
                     !memcmp(&deadGuid,
                             &gGroupTypeGuidIndex[k].entry[l].guid,
                             sizeof(GUID)));
                    l++);
                if(l != GROUP_TYPE_CACHE_RECS_PER_BUCKET) {
                    gGroupTypeGuidIndex[k].entry[l].DNT = INVALIDDNT;
                }
                
                
            }
            
            gGroupTypeCache[i].entry[j].DNT = INVALIDDNT;
            gGroupTypeCache[i].entry[j].Guid = pDSName->Guid;
            gGroupTypeCache[i].entry[j].Sid = pDSName->Sid;
            gGroupTypeCache[i].entry[j].SidLen = pDSName->SidLen;
            gGroupTypeCache[i].entry[j].NCDNT = actualNCDNT;
            gGroupTypeCache[i].entry[j].GroupType = actualGroupType;
            gGroupTypeCache[i].entry[j].Class = actualClass;
            gGroupTypeCache[i].entry[j].DNT = DNT;
            gGroupTypeCache[i].entry[j].flags = flags;

            // Now, find the correct place in the guid index.
            
            i = GroupTypeGuidHashFunction(pDSName->Guid);
            // First, a quick scan looking for an empty slot
            for(j=0;
                (j < GROUP_TYPE_CACHE_RECS_PER_BUCKET &&
                 gGroupTypeGuidIndex[i].entry[j].DNT == INVALIDDNT);
                j++);
            
            if(j == GROUP_TYPE_CACHE_RECS_PER_BUCKET) {
                // didn't find an unused slot.  Use a simple queue replacement
                // policy. 
                j = gGroupTypeGuidIndex[i].index;
                gGroupTypeGuidIndex[i].index =
                    (gGroupTypeGuidIndex[i].index + 1) %
                        GROUP_TYPE_CACHE_RECS_PER_BUCKET; 
            }

            // Do this in this order so that if someone looks up this entry,
            // they never find an entry with a GUID from one object and a DNT
            // from another.  The worse they will find is a GUID from some
            // object and INVALIDDNT
            gGroupTypeGuidIndex[i].entry[j].DNT = INVALIDDNT;
            gGroupTypeGuidIndex[i].entry[j].guid = pDSName->Guid;
            gGroupTypeGuidIndex[i].entry[j].DNT = DNT;



            THFreeEx(pTHS, pDSName);
        }
        __finally {
            DBClose(pTHS->pDB,TRUE);
        }
    }
    __except (HandleMostExceptions(err = GetExceptionCode())) {
        // Failed to add this to the cache.  I wonder why?
        LogUnhandledError(err);
    }

    return;
}

void
RunGroupTypeCacheManager(
    void *  pv,
    void ** ppvNext,
    DWORD * pcSecsUntilNextIteration
    )
/*++     
  Main grouptype cache manager.  Called by the task queue, runs as a task.
  Drains the DNTs in the request queue.  Looks up those DNTs and puts the data
  in the grouptype cache.  
--*/
{
    DWORD currentDNT;
    ULONG i, j;
    BOOL fDone = FALSE;

    __try {
        DPRINT(3,"Grouptype cache mgr\n");
        // We don't reschedule ourselves.
        *pcSecsUntilNextIteration = TASKQ_DONT_RESCHEDULE;
        
        if(!gbGroupTypeCacheInitted) {
            EnterCriticalSection(&csGroupTypeCacheRequests);
            __try {
                if(!gbGroupTypeCacheInitted) {
                    // OK, still needs to be inited
                    gGroupTypeCache =
                        malloc((NUM_GROUP_TYPE_CACHE_BUCKETS *
                                sizeof(GROUPTYPECACHEBUCKET)) +
                               (NUM_GROUP_TYPE_CACHE_BUCKETS *
                                sizeof(GROUPTYPECACHEGUIDINDEX))); 
                    if(gGroupTypeCache) {
                        // Get the guid index structure, which we allocated at
                        // the end of the group type cache.
                        gGroupTypeGuidIndex = (GROUPTYPECACHEGUIDINDEX *)
                            &gGroupTypeCache[NUM_GROUP_TYPE_CACHE_BUCKETS];
                        // we don't need to set the whole structure to null,
                        // just set the DNTs  and indices.
                        for(i=0;i<NUM_GROUP_TYPE_CACHE_BUCKETS;i++) {
                            gGroupTypeCache[i].index = 0;
                            gGroupTypeGuidIndex[i].index = 0;
                            
                            for(j=0;j<GROUP_TYPE_CACHE_RECS_PER_BUCKET;j++) {
                                gGroupTypeCache[i].entry[j].DNT = INVALIDDNT;
                                gGroupTypeGuidIndex[i].entry[j].DNT =
                                    INVALIDDNT; 
                            }
                        }

                        
                        GroupTypeCacheMask = GROUP_TYPE_CACHE_MASK;
                        GroupTypeCacheSize = NUM_GROUP_TYPE_CACHE_BUCKETS;
                        gbGroupTypeCacheInitted = TRUE;
                    }
                }
            }
            __finally {
                LeaveCriticalSection(&csGroupTypeCacheRequests);
            }
        }

        if ( !gbGroupTypeCacheInitted ) {
            //  malloc above must have failed, so bail out
            //  (lookups will simply have to consult the
            //  database instead until a future task can
            //  attempt to initialise the cache again)
            //
            __leave;
        }

        while(!fDone) {
            currentDNT = INVALIDDNT;
            // Lock the cache
            EnterCriticalSection(&csGroupTypeCacheRequests);
            __try {
                // Grab the first element.
                if(gulCacheRequests) {
                    gulCacheRequests--;
                    if(gCacheRequests[gulCacheRequests].count) {
                        // Yes, we're going to do this one.
                        // gCurrentGroupTypeCacheDNT is the DNT we're about to
                        // add.  Note that another thread may reset this to
                        // INVALIDDNT to request that we invalidate the object
                        // we're about to add. (see the comment at the
                        // definition of the variable gCurrentGroupTypeCacheDNT,
                        // at the top of this file.) 
                        gCurrentGroupTypeCacheDNT =
                            gCacheRequests[gulCacheRequests].DNT;   
                        currentDNT = gCurrentGroupTypeCacheDNT;
                    }
                }
                else {
                    // There are no more elements, we're done.
                    fDone = TRUE;
                }
            }
            __finally {
                // release the queue lock.
                LeaveCriticalSection(&csGroupTypeCacheRequests);
            }
            
            if(currentDNT != INVALIDDNT) {
                
                gcache_AddToCache(currentDNT);
                
                // Take the lock again.
                EnterCriticalSection(&csGroupTypeCacheRequests);
                __try {
                    if(gCurrentGroupTypeCacheDNT != INVALIDDNT) {
                        currentDNT = gCurrentGroupTypeCacheDNT = INVALIDDNT;
                    }
                    // Note that if gCurrentGroupTypeCacheDNT is already
                    // INVALIDDNT, then we will leave the value of currentDNT
                    // unchanged. 
                }
                __finally {
                    // Release the lock.
                    LeaveCriticalSection(&csGroupTypeCacheRequests);
                }
                
                if(currentDNT != INVALIDDNT) {
                    // Someone asked us to invalidate this while we were working
                    // on it, find the object in the cache and invalidate it
                    // there. 
                    if(GroupTypeCacheSize) {
                        i = (currentDNT & GroupTypeCacheMask);
                        
                        for(j=0;j<GROUP_TYPE_CACHE_RECS_PER_BUCKET;j++) {
                            if(gGroupTypeCache[i].entry[j].DNT == currentDNT) {
                                // Found it.
                                gGroupTypeCache[i].entry[j].DNT = INVALIDDNT;
                            }
                        }
                    }
                }
            }
            
        }
    }
    __finally {
        SetEvent(hevGTC_OKToInsertInTaskQueue);
    }
    
    return;
}


VOID
InvalidateGroupTypeCacheElement(
        DWORD ulDNT
        )
/*++
    Invalidate a DNT from the GroupType cache.  There are three steps to this,
    1) if the GroupType cache manager is currently adding this DNT to the cache,
       make a mark so that it will remove it from the cache when it is done.
    2) if the DNT is in the request list of objects to be added to the cache,
       remove it.
    3) reach into the GroupType cache and invalidate the cache entry by setting
       the DNT to INVALIDDNT.
    
--*/
{
    DWORD i,j;
    BOOL  fDone;
    
    DPRINT1(3,"Invalidating 0x%X in the GroupType cache\n",ulDNT);
    // First, lock the queue of cache requests
    EnterCriticalSection(&csGroupTypeCacheRequests);
    __try {
        
        // Check to see if the manager is currently messing with this dnt
        if(ulDNT == gCurrentGroupTypeCacheDNT) {
            // Yep, mark it so the manager invalidates after he's finished
            // putting it in the cache.
            gCurrentGroupTypeCacheDNT = INVALIDDNT;
        }

        // Now, go through queue of pending cache modifications to see if the
        // dnt is in the request queue. 
        if(gulCacheRequests) {
            // There are some things in the cache
            fDone = FALSE;
            for(i=0;i<gulCacheRequests && !fDone ;i++) {
                if(gCacheRequests[i].DNT == ulDNT) {
                    gulCacheRequests--;
                    if(i != gulCacheRequests) {
                        memcpy(&gCacheRequests[i],
                               &gCacheRequests[gulCacheRequests],
                               sizeof(GROUPTYPECACHEREQUEST));
                    }
                    fDone = TRUE;
                }
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csGroupTypeCacheRequests);
    }

    // Last step, find the object in the cache and invalidate it there.
    if(GroupTypeCacheSize) {
        GUID guid;
        
        i = (ulDNT & GroupTypeCacheMask);
        
        for(j=0;j<GROUP_TYPE_CACHE_RECS_PER_BUCKET;j++) {
            if(gGroupTypeCache[i].entry[j].DNT == ulDNT) {
                // Found it.
                guid = gGroupTypeCache[i].entry[j].Guid;
                gGroupTypeCache[i].entry[j].DNT = INVALIDDNT;
            }
        }

        // See if we can find and invalidate the object in the GUID index.
        i = GroupTypeGuidHashFunction(guid);
        for(j=0;j<GROUP_TYPE_CACHE_RECS_PER_BUCKET;j++) {
            if(gGroupTypeGuidIndex[i].entry[j].DNT != INVALIDDNT &&
               (0 == memcmp(&gGroupTypeGuidIndex[i].entry[j].guid,
                            &guid,
                            sizeof(GUID)))) {
                // Found it.
                gGroupTypeGuidIndex[i].entry[j].DNT = INVALIDDNT;
                break;
            }
        }        
    }
    
    
    
    return;
}


void
GroupTypeCachePostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
/*++
    Called by the code that tracks modified objects when committing to
    transaction level 0.  Walks through the accumulated data of what DNTs have
    been modified and invalidates those DNTs from the GroupType cache.
    
    Note that since we do this AFTER the we have committed, we have a brief
    period where the data in the cache is stale (in between the Jet commit and
    this call).  Pragmatically, this doesn't lead to any problems.  If we
    flushed stale cache entries before we commit, then someone else may put the
    entry back in the cache using a transaction opened before we commit, thus
    putting stale data back in the cache.  Since we flush after we commit, and
    the transaction used to put data back in the case is opened after the flush,
    that transaction gets fresh data.
    
--*/       
{
    MODIFIED_OBJ_INFO *pTemp;
    DWORD              i;
    
    Assert(VALID_THSTATE(pTHS));
    
    if(!pTHS->JetCache.dataPtr->pModifiedObjects ||
       !fCommitted ||
       pTHS->transactionlevel > 0 ) {
        // Nothing changed, or not committing or committing to a non zero
        // transaction level.  Nothing to do.
        return;
    }

    // OK, we're committing to transaction level 0.  Go through all the DNTs
    // we've saved up for this transaction and invalidate them in the Group
    // Type Cache.  The DNTs we've saved are DNTs of objects that have been
    // modified or deleted, so if they are in the cache, they now may have
    // stale information.
    
    pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
    while(pTemp) {
        for(i=0;i<pTemp->cItems;i++) {
            if(pTemp->Objects[i].fChangeType !=  MODIFIED_OBJ_intrasite_move) {
                // Don't bother doing this for intrasite moves.  For such
                // elements in the list, there will always be another element
                // with the same ulDNT, but fChangeType !=
                // MODIFIED_OBJ_intrasite_move, so lets not invalidate the same
                // DNT twice. (NOTE: for _intersite_move, there isn't guaranteed
                // to be another such element.  Do the invalidation.  Yeah, we
                // might invalidate twice, but that doesn't result in
                // incorrectness, just a few extra cycles (and right now, such
                // moves do indeed only result in one element in this list
                // anyway, so we don't even spend extra cycles)).
                InvalidateGroupTypeCacheElement(
                        pTemp->Objects[i].pAncestors[pTemp->Objects[i].cAncestors-1]
                        );
            }
        }
        pTemp = pTemp->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\lht.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    lht.c

Abstract:

    This module contains an implemenation of an unsynchronized linear hash
    table (LHT).  The LHT is designed to address two scenarios:  a global,
    read-only table accessed concurrently by many threads and a local
    read-write table accessed by only a single thread.

Author:

    Andrew E. Goodsell (andygo) 01-Apr-2001

Revision History:

    01-Apr-2001     andygo

        Ported from \nt\ds\ese98\export\dht.hxx

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include "lht.h"
#include "lhtp.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB     "LHT:"               // define the subsystem for debugging

#include <fileno.h>
#define FILENO FILENO_LHT


//#define LHT_PERF


//  Prototypes

VOID LhtpLog2(
    IN      SIZE_T      iValue,
    OUT     SIZE_T*     piExponent,
    OUT     SIZE_T*     piRemainder
    );
PLHT_CLUSTER LhtpPOOLAlloc(
    IN      PLHT            plht
    );
VOID LhtpPOOLFree(
    IN      PLHT            plht,
    IN      PLHT_CLUSTER    pCluster
    );
BOOLEAN LhtpPOOLReserve(
    IN      PLHT            plht
    );
PLHT_CLUSTER LhtpPOOLCommit(
    IN      PLHT            plht
    );
VOID LhtpPOOLUnreserve(
    IN      PLHT            plht
    );
VOID LhtpSTTransition(
    IN      PLHT        plht,
    IN      LHT_STATE   stateNew
    );
VOID LhtpSTCompletionSplit(
    IN      PLHT    plht
    );
VOID LhtpSTCompletionMerge(
    IN      PLHT    plht
    );
LHT_ERR LhtpDIRInit(
    IN      PLHT        plht
    );
VOID LhtpDIRTerm(
    IN      PLHT        plht
    );
LHT_ERR LhtpDIRCreateBucketArray(
    IN      PLHT        plht,
    IN      SIZE_T      cBucketAlloc,
    OUT     CHAR**      prgBucket
    );
VOID LhtpDIRSplit(
    IN      PLHT        plht
    );
VOID LhtpDIRMerge(
    IN      PLHT        plht
    );
PLHT_CLUSTER LhtpDIRResolve(
    IN      PLHT        plht,
    IN      SIZE_T      iBucketIndex,
    IN      SIZE_T      iBucketOffset
    );
PLHT_CLUSTER LhtpDIRHash(
    IN      PLHT        plht,
    IN      SIZE_T      iHash,
    OUT     SIZE_T*     piBucket
    );
PVOID LhtpBKTMaxEntry(
    IN      PLHT            plht,
    IN      PLHT_CLUSTER    pCluster
    );
PLHT_CLUSTER LhtpBKTNextCluster(
    IN      PLHT            plht,
    IN      PLHT_CLUSTER    pCluster
    );
LHT_ERR LhtpBKTFindEntry(
    IN      PLHT        plht,
    IN      PVOID       pvKey,
    OUT     PLHT_POS    ppos
    );
LHT_ERR LhtpBKTRetrieveEntry(
    IN      PLHT        plht,
    IN OUT  PLHT_POS    ppos,
    OUT     PVOID       pvEntry
    );
LHT_ERR LhtpBKTReplaceEntry(
    IN      PLHT        plht,
    IN OUT  PLHT_POS    ppos,
    OUT     PVOID       pvEntry
    );
LHT_ERR LhtpBKTInsertEntry(
    IN      PLHT        plht,
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    );
LHT_ERR LhtpBKTDeleteEntry(
    IN      PLHT        plht,
    IN OUT  PLHT_POS    ppos
    );
VOID LhtpBKTSplit(
    IN      PLHT        plht
    );
VOID LhtpBKTMerge(
    IN      PLHT        plht
    );
VOID LhtpSTATInsertEntry(
    IN      PLHT        plht
    );
VOID LhtpSTATDeleteEntry(
    IN      PLHT        plht
    );
VOID LhtpSTATInsertOverflowCluster(
    IN      PLHT        plht
    );
VOID LhtpSTATDeleteOverflowCluster(
    IN      PLHT        plht
    );
VOID LhtpSTATSplitBucket(
    IN      PLHT        plht
    );
VOID LhtpSTATMergeBucket(
    IN      PLHT        plht
    );
VOID LhtpSTATSplitDirectory(
    IN      PLHT        plht
    );
VOID LhtpSTATMergeDirectory(
    IN      PLHT        plht
    );
VOID LhtpSTATStateTransition(
    IN      PLHT        plht
    );
VOID LhtpSTATPolicySelection(
    IN      PLHT        plht
    );
VOID LhtpSTATAllocateMemory(
    IN      PLHT        plht,
    IN      SIZE_T      cbAlloc
    );
VOID LhtpSTATFreeMemory(
    IN      PLHT        plht,
    IN      SIZE_T      cbAlloc
    );
PVOID LhtpMEMAlloc(
    IN      PLHT        plht,
    IN      SIZE_T      cbAlloc
    );
VOID LhtpMEMFree(
    IN      PLHT        plht,
    IN      PVOID       pvAlloc,
    IN      SIZE_T      cbAlloc
    );


//  Maintenance State Transition Table

CONST LHT_STATE_TRANSITION rgstt[] = {
    /*  stateNil        */  { NULL,                     LHT_stateNil,       },
    /*  stateGrow       */  { NULL,                     LHT_stateNil,       },
    /*  stateShrink     */  { NULL,                     LHT_stateNil,       },
    /*  stateSplit      */  { LhtpSTCompletionSplit,    LHT_stateGrow       },
    /*  stateMerge      */  { LhtpSTCompletionMerge,    LHT_stateShrink     },
    };


//  Utilities

VOID LhtpLog2(
    IN      SIZE_T      iValue,
    OUT     SIZE_T*     piExponent,
    OUT     SIZE_T*     piRemainder
    )

/*++

Routine Description:

    This routine computes the base-2 logarithm of an integer, returning the
    integral result and an integral remainder representing the fractional
    result.  This function deviates from a true base-2 logarithm in the
    following way:

        LhtpLog2( 0 ) => 0, 0
        LhtpLog2( 1 ) => 0, 1

Arguments:

    iValue          - Supplies the integer of which the logarithm will be
                    computed
    piExponent      - Returns the integral result of the logarithm
    piRemainder     - Returns the fractional result of the logarithm as an
                    integral remainder

Return Value:

    None

 --*/

{
    SIZE_T  iExponent;
    SIZE_T  iMaskLast;
    SIZE_T  iMask;

    iExponent   = 0;
    iMaskLast   = 1;
    iMask       = 1;

    while ( iMask < iValue ) {
        iExponent++;
        iMaskLast   = iMask;
        iMask       = ( iMask << 1 ) + 1;
    }

    Assert( iExponent < ( sizeof( SIZE_T ) * 8 ) );

    *piExponent     = iExponent;
    *piRemainder    = iMaskLast & iValue;
}


//  Cluster Pool

BOOLEAN LhtpPOOLIReserve(
    IN      PLHT            plht
    )

/*++

Routine Description:

    This routine allocates a new cluster and places it on the reserved cluster
    list for the cluster pool.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    TRUE when a cluster has been successfully reserved.

 --*/

{
    PLHT_CLUSTER pCluster;

    pCluster = LhtpPOOLAlloc( plht );
    if ( pCluster ) {
        pCluster->pvNextLast = plht->pClusterReserve;
        plht->pClusterReserve = pCluster;
        return TRUE;
    } else {
        return FALSE;
    }
}

__inline
PLHT_CLUSTER LhtpPOOLAlloc(
    IN      PLHT            plht
    )

/*++

Routine Description:

    This routine allocates a cluster from the cluster pool.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    The allocated cluster or NULL if the allocation failed.

 --*/

{
    PLHT_CLUSTER pClusterAlloc;

    if ( plht->pClusterAvail ) {
        pClusterAlloc = plht->pClusterAvail;
        plht->pClusterAvail = plht->pClusterAvail->pvNextLast;
    } else {
        pClusterAlloc = LhtpMEMAlloc(
                        plht,
                        plht->cbCluster );
    }

    return pClusterAlloc;
}

__inline
VOID LhtpPOOLFree(
    IN      PLHT            plht,
    IN      PLHT_CLUSTER    pCluster
    )

/*++

Routine Description:

    This routine frees a cluster to the cluster pool.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    if ( plht->pfnMalloc != NULL && plht->pfnFree == NULL ) {
        pCluster->pvNextLast = plht->pClusterAvail;
        plht->pClusterAvail = pCluster;
    } else {
        LhtpMEMFree(
            plht,
            pCluster,
            plht->cbCluster );
    }
}

__inline
BOOLEAN LhtpPOOLReserve(
    IN      PLHT            plht
    )

/*++

Routine Description:

    This routine guarantees the future availability of a cluster for allocation
    by ensuring that there is at least one cluster in the cluster pool for each
    outstanding reservation.  Reserved clusters are allocated by committing
    them.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    TRUE when a cluster has been successfully reserved.

 --*/

{
    if ( plht->cClusterReserve ) {
        plht->cClusterReserve--;
        return TRUE;
    } else {
        return LhtpPOOLIReserve( plht );
    }
}

__inline
PLHT_CLUSTER LhtpPOOLCommit(
    IN      PLHT            plht
    )

/*++

Routine Description:

    This routine commits (i.e. consumes) a previously reserved cluster from the
    cluster pool.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    The allocated cluster.

 --*/

{
    PLHT_CLUSTER pClusterCommit;

    pClusterCommit = plht->pClusterReserve;
    plht->pClusterReserve = plht->pClusterReserve->pvNextLast;
    return pClusterCommit;
}

__inline
VOID LhtpPOOLUnreserve(
    IN      PLHT            plht
    )

/*++

Routine Description:

    This routine cancels a prior reservation of a cluster.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    plht->cClusterReserve++;
}


//  Maintenance State Manager

VOID LhtpSTICompletion(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine performs the work necessary to complete the transition of the
    linear hash table to a new maintenance state.  The work to be done is
    derived from the state transition table based on the newly acheived state.
    This work may include the calling of an arbitrary function as well as the
    immediate transition to a new state.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    LHT_STATE stateCurrent;
    
    LhtpSTATStateTransition( plht );

    stateCurrent = plht->stateCur;

    if ( rgstt[ stateCurrent ].pfnStateCompletion ) {
        rgstt[ stateCurrent ].pfnStateCompletion( plht );
    }

    if ( rgstt[ stateCurrent ].stateNext ) {
        LhtpSTTransition(
            plht,
            rgstt[ stateCurrent ].stateNext );
    }
}

__inline
VOID LhtpSTTransition(
    IN      PLHT        plht,
    IN      LHT_STATE   stateNew
    )

/*++

Routine Description:

    This routine initiates a transition to a new maintenance state for the
    linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    plht->stateCur = stateNew;

    LhtpSTICompletion( plht );
}

VOID LhtpSTCompletionSplit(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine performs the work necessary for the Directory Split maintenance
    state of the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    LhtpDIRSplit( plht );
}

VOID LhtpSTCompletionMerge(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine performs the work necessary for the Directory Merge maintenance
    state of the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    LhtpDIRMerge( plht );
}


//  Directory Manager

VOID LhtpDIRIDestroyBucketArray(
    IN      PLHT        plht,
    IN      CHAR*       rgBucket,
    IN      SIZE_T      cBucket
    )

/*++

Routine Description:

    This routine deallocates a bucket array in the directory for the linear
    hash table.  This includes the deallocation of any overflow clusters
    chained into each of the buckets.

Arguments:

    plht            - Supplies the context for the linear hash table
    rgBucket        - Supplies the bucket array to deallocate
    cBucket         - Supplies the size of the bucket array to deallocate

Return Value:

    None

 --*/

{
    SIZE_T          iBucket;
    PLHT_CLUSTER    pCluster;
    PLHT_CLUSTER    pClusterNext;

    for ( iBucket = 0; iBucket < cBucket; iBucket++ ) {
        pCluster = (PLHT_CLUSTER)&rgBucket[ iBucket * plht->cbCluster ];

        pCluster = LhtpBKTNextCluster(
                    plht,
                    pCluster );
        while ( pCluster ) {
            pClusterNext = LhtpBKTNextCluster(
                            plht,
                            pCluster );
            LhtpPOOLFree(
                plht,
                pCluster );
            pCluster = pClusterNext;
        }
    }

    LhtpMEMFree(
        plht,
        rgBucket,
        cBucket * plht->cbCluster );
}

LHT_ERR LhtpDIRInit(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine creates the directory of the linear hash table.  The baseic
    properties of a bucket and the size of the hash table are computed from the
    initial configuration of the table and the initial bucket array(s) used by
    the table are allocated.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    LHT_ERR

 --*/

{
    LHT_ERR     err;
    SIZE_T      iExponent;
    SIZE_T      iRemainder;

    //  calculate the cluster size, accounting for:
    //
    //  -  cluster header
    //  -  enough room for twice the load factor to eliminate overflow clusters
    //     with uniform hashing
    //  -  room for an additional entry to give us some flexibility in our
    //     actual load factor to reduce maintenance overhead
    //  -  cache line alignment of the cluster

    plht->cbCluster  = offsetof( LHT_CLUSTER, rgEntry ) + ( plht->cLoadFactor * 2 + 1 ) * plht->cbEntry;
    plht->cbCluster  = ( ( plht->cbCluster + plht->cbCacheLine - 1 ) / plht->cbCacheLine ) * plht->cbCacheLine;

    //  calculate the number of entries we can fit into a single cluster
    //
    //  NOTE: this may be larger than intended because we rounded the cluster
    //  size up the nearest cache-line

    plht->cEntryCluster = ( plht->cbCluster - offsetof( LHT_CLUSTER, rgEntry ) ) / plht->cbEntry;

    //  calculate the minimum number of buckets using the following
    //  lower-bounds:
    //      cEntryMin   user parameter
    //      2           hash table assumes at least 2 buckets

    plht->cBucketMin = max( plht->cEntryMin / plht->cLoadFactor, 2 ); 

    //  align the minimum number of buckets to the next highest power of 2
    //  unless it's already a power of 2

    LhtpLog2(
        plht->cBucketMin,
        &iExponent,
        &iRemainder );
    if ( iRemainder ) {
        if ( ++iExponent >= sizeof( plht->rgrgBucket ) / sizeof( plht->rgrgBucket[ 0 ] ) ) {
            return LHT_errInvalidParameter;
        }
    }
    plht->cBucketMin = 1 << iExponent;

    //  setup the directory pointers for a new split level at the initial size

    plht->cBucketMax    = plht->cBucketMin;
    plht->cBucket       = 0;

    //  SPECIAL CASE:  allocate 2 entries for the first bucket array

    err = LhtpDIRCreateBucketArray(
        plht,
        2,
        &plht->rgrgBucket[ 0 ] );
    if ( err != LHT_errSuccess ) {
        return err;
    }

    //  allocate memory normally for all other initial bucket arrays

    for ( iExponent = 1; (SIZE_T)1 << iExponent < plht->cBucketMin; iExponent++ ) {
        err = LhtpDIRCreateBucketArray(
            plht,
            (SIZE_T)1 << iExponent,
            &plht->rgrgBucket[ iExponent ] );
        if ( err != LHT_errSuccess ) {
            return err;
        }
    }

    return LHT_errSuccess;
}

VOID LhtpDIRTerm(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine destroys the directory of the linear hash table.  All buckets
    allocated for use by the table are deallocated.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    SIZE_T iExponent;
    
    if ( plht->rgrgBucket[ 0 ] ) {
        LhtpDIRIDestroyBucketArray(
            plht,
            plht->rgrgBucket[ 0 ],
            2 );
        plht->rgrgBucket[ 0 ] = NULL;
    }

    for ( iExponent = 1; iExponent < sizeof( SIZE_T ) * 8; iExponent++ ) {
        if ( plht->rgrgBucket[ iExponent ] ) {
            LhtpDIRIDestroyBucketArray(
                plht,
                plht->rgrgBucket[ iExponent ],
                (SIZE_T)1 << iExponent );
            plht->rgrgBucket[ iExponent ] = NULL;
        }
    }

    plht->cBucketMax    = 0;
    plht->cBucket       = 0;
}

LHT_ERR LhtpDIRCreateBucketArray(
    IN      PLHT        plht,
    IN      SIZE_T      cBucket,
    OUT     CHAR**      prgBucket
    )

/*++

Routine Description:

    This routine allocates a bucket array in the directory for the linear hash
    table.

Arguments:

    plht            - Supplies the context for the linear hash table
    cBucket         - Supplies the size of the bucket array to allocate
    prgBucket       - Returns the allocated bucket array

Return Value:

    LHT_ERR

 --*/

{
    CHAR*   rgBucket;
    SIZE_T  iBucket;

    rgBucket = LhtpMEMAlloc(
                plht,
                cBucket * plht->cbCluster );
    if ( !rgBucket ) {
        *prgBucket = NULL;
        return LHT_errOutOfMemory;
    }

    for ( iBucket = 0; iBucket < cBucket; iBucket ++ ) {
        PLHT_CLUSTER pCluster = (PLHT_CLUSTER)&rgBucket[ iBucket * plht->cbCluster ];

        pCluster->pvNextLast = NULL;
    }

    *prgBucket = rgBucket;
    return LHT_errSuccess;
}

VOID LhtpDIRSplit(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine splits the directory of the linear hash table.  Because new
    bucket arrays are defer created as needed, this procedure merely changes
    the constants used to interpret the current bucket arrays for the new split
    level.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    Assert( plht->cBucketMax > 0 );
    Assert( plht->cBucket == plht->cBucketMax );

    plht->cBucketMax    = plht->cBucketMax * 2;
    plht->cBucket       = 0;

    LhtpSTATSplitDirectory( plht );
}

VOID LhtpDIRMerge(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine merges the directory of the linear hash table.  The bucket
    array no longer in use is deallocated.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    SIZE_T  iExponent;
    SIZE_T  iRemainder;
    
    Assert( plht->cBucketMax > 1 );
    Assert( plht->cBucket == 0 );

    LhtpLog2(
        plht->cBucketMax,
        &iExponent,
        &iRemainder );

    Assert( (SIZE_T)1 << iExponent == plht->cBucketMax );
    Assert( iRemainder == 0 );

    if ( plht->pfnMalloc == NULL || plht->pfnFree != NULL ) {
        if ( plht->rgrgBucket[ iExponent ] ) {
            LhtpDIRIDestroyBucketArray(
                plht,
                plht->rgrgBucket[ iExponent ],
                plht->cBucketMax );
            plht->rgrgBucket[ iExponent ] = NULL;
        }
    }

    plht->cBucketMax    = plht->cBucketMax / 2;
    plht->cBucket       = plht->cBucketMax;

    LhtpSTATMergeDirectory( plht );
}

__inline
PLHT_CLUSTER LhtpDIRResolve(
    IN      PLHT        plht,
    IN      SIZE_T      iBucketIndex,
    IN      SIZE_T      iBucketOffset
    )

/*++

Routine Description:

    This routine translates a bucket array index (the exponent of the base-2
    logarithm of a bucket index) and a bucket array offset (the remainder of
    the base-2 logarithm of a bucket index) into a pointer to the head of the
    cluster chain for that bucket in the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table
    iBucketIndex    - Supplies the index of the bucket array in the directory
                    containing the desired bucket
    iBucketOffset   - Supplies the offset into the bucket array in the
                    directory containing the desired bucket

Return Value:

    A pointer to the head of the cluster chain for the desired bucket

 --*/

{
    return (PLHT_CLUSTER)&plht->rgrgBucket[ iBucketIndex ][ iBucketOffset * plht->cbCluster ];
}

PLHT_CLUSTER LhtpDIRHash(
    IN      PLHT        plht,
    IN      SIZE_T      iHash,
    OUT     SIZE_T*     piBucket
    )

/*++

Routine Description:

    This routine uses the directory of the linear hash table to translate a hash
    index to a bucket into the absolute index to that bucket as well as a
    pointer to the head of the cluster chain of that bucket.

Arguments:

    plht            - Supplies the context for the linear hash table
    iHash           - Supplies the hash index of the desired bucket
    piBucket        - Returns the absolute index of the desired bucket

Return Value:

    A pointer to the head of the cluster chain for the desired bucket

 --*/

{
    SIZE_T  iExponent;
    SIZE_T  iRemainder;

    *piBucket = iHash & ( ( plht->cBucketMax - 1 ) + plht->cBucketMax );
    if ( *piBucket >= plht->cBucketMax + plht->cBucket ) {
        *piBucket -= plht->cBucketMax;
    }

    LhtpLog2(
        *piBucket,
        &iExponent,
        &iRemainder );

    return LhtpDIRResolve(
            plht,
            iExponent,
            iRemainder );
}


//  Bucket Manager

LHT_ERR LhtpBKTIFindEntry(
    IN      PLHT        plht,
    IN      PVOID       pvKey,
    IN OUT  PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine searches all clusters in a bucket for an entry that matches a
    given key.  If a matching entry is discovered then its position is saved.

Arguments:

    plht            - Supplies the context for the linear hash table
    pvKey           - Supplies the key of the entry for which we are looking
    ppos            - Supplies the bucket to search for the entry and returns
                    the position of the entry if found

Return Value:

    LHT_ERR

        LHT_errEntryNotFound    - the entry was not found in the current bucket

 --*/

{
    PLHT_CLUSTER    pClusterThis;
    PLHT_CLUSTER    pClusterPrev;
    PVOID           pvEntryThis;
    PVOID           pvEntryMax;

    pClusterThis = ppos->pClusterHead;
    do {
        pvEntryThis     = &pClusterThis->rgEntry[ 0 ];
        pvEntryMax      = LhtpBKTMaxEntry(
                            plht,
                            pClusterThis );
        while ( pvEntryThis < pvEntryMax ) {
            if ( !plht->pfnEntryMatchesKey(
                    pvEntryThis,
                    pvKey ) ) {
            } else {
                ppos->pCluster      = pClusterThis;
                ppos->pvEntry       = pvEntryThis;
                return LHT_errSuccess;
            }

            pvEntryThis = (CHAR*)pvEntryThis + plht->cbEntry;
        }

        pClusterPrev    = pClusterThis;
        pClusterThis    = LhtpBKTNextCluster(
                            plht,
                            pClusterThis );
    } while ( pClusterThis != NULL );

    ppos->pCluster      = pClusterPrev;
    ppos->pvEntry       = NULL;
    return LHT_errEntryNotFound;
}

__inline
VOID LhtpBKTICopyEntry(
    IN      PLHT    plht,
    OUT     PVOID   pvEntryDest,
    IN      PVOID   pvEntrySrc
    )

/*++

Routine Description:

    This routine copies an entry from one slot to another slot in the linear
    hash table.  These slots may be in different clusters and buckets in the
    table.  If a user provided copy routine was provided at create time then
    that routine is used.  Otherwise, a shallow copy of the entry will be
    performed.

Arguments:

    plht            - Supplies the context for the linear hash table
    pvEntryDest     - Returns the new copy of the entry
    pvEntrySrc      - Supplies the entry to duplicate

Return Value:

    None

 --*/

{
    if ( plht->pfnCopyEntry ) {
        plht->pfnCopyEntry(
            pvEntryDest,
            pvEntrySrc );
    } else {
        memcpy(
            pvEntryDest,
            pvEntrySrc,
            plht->cbEntry );
    }
}

VOID LhtpBKTIDoSplit(
    IN      PLHT            plht,
    IN OUT  PLHT_CLUSTER    pClusterHeadSrc,
    OUT     PLHT_CLUSTER    pClusterHeadDest
    )

/*++

Routine Description:

    This routine moves entries from the source bucket into the destination
    bucket by hash index.  All entries whose hash index has the critical bit
    set will be moved to the destination bucket.  All other entries will remain
    in the source bucket.  The critical bit is the bit corresponding to the
    current split level of the directory (cBucketMax).

Arguments:

    plht                - Supplies the context for the linear hash table
    pClusterHeadSrc     - Supplies the unsplit bucket and returns the split
                        bucket containing the entries whose hash index has the
                        critical bit clear
    pClusterHeadDest    - Returns the split bucket containing the entries whose
                        hash index has the critical bit set

Return Value:

    None

 --*/

{
    PLHT_CLUSTER    pClusterSrc;
    PVOID           pvEntrySrc;
    PLHT_CLUSTER    pClusterDest;
    PVOID           pvEntryDest;
    PLHT_CLUSTER    pClusterAvail;
    BOOLEAN         fUsedReserve;
    PLHT_CLUSTER    pClusterAlloc;
    PLHT_CLUSTER    pClusterLast;
    PLHT_CLUSTER    pClusterNext;
    PLHT_CLUSTER    pClusterPrev;
    PVOID           pvEntrySrcMax;

    //  establish our initial position at the start of the source bucket

    pClusterSrc = pClusterHeadSrc;
    if ( pClusterSrc->pvNextLast == NULL ) {
        pvEntrySrc = NULL;
    } else {
        pvEntrySrc = &pClusterSrc->rgEntry[ 0 ];
    }

    //  establish our initial position at the start of the destination bucket

    pClusterDest    = pClusterHeadDest;
    pvEntryDest     = &pClusterDest->rgEntry[ 0 ];

    //  reset the local cluster pool

    pClusterAvail   = NULL;
    fUsedReserve    = FALSE;

    //  move entries until we have consumed all the entries in the source bucket

    while ( pvEntrySrc != NULL ) {

        //  the current source entry belongs in the destination bucket
        
        if ( ( plht->pfnHashEntry( pvEntrySrc ) & plht->cBucketMax ) != 0 ) {

            //  there is no room in the destination bucket for this entry
            
            if ( pvEntryDest == &pClusterDest->rgEntry[ plht->cbEntry * plht->cEntryCluster ] ) {

                //  if there are no clusters in the local cluster pool then
                //  commit our reservation from the cluster reserve pool and
                //  put that cluster in the local cluster pool
                
                if ( pClusterAvail == NULL ) {
                    Assert( !fUsedReserve );
                    fUsedReserve = TRUE;
                    pClusterAvail = LhtpPOOLCommit( plht );
                    pClusterAvail->pvNextLast = NULL;
                }

                //  grab a new cluster from the local cluster pool

                pClusterAlloc   = pClusterAvail;
                pClusterAvail   = pClusterAvail->pvNextLast;

                //  append the new cluster to the destination bucket

                pClusterDest->pvNextLast    = pClusterAlloc;
                pClusterAlloc->pvNextLast   = NULL;

                //  establish our position at the end of the destination bucket

                pClusterDest    = pClusterAlloc;
                pvEntryDest     = &pClusterAlloc->rgEntry[ 0 ];
            }

            //  consume a slot in the destination bucket

            pClusterDest->pvNextLast = pvEntryDest;

            //  copy the entry from the source slot to the destination slot

            LhtpBKTICopyEntry(
                plht,
                pvEntryDest,
                pvEntrySrc );

            //  bump our destination position

            pvEntryDest = (CHAR*)pvEntryDest + plht->cbEntry;

            //  copy the entry from the end of the source bucket into the empty
            //  slot in the source bucket

            if ( pvEntrySrc == pClusterSrc->pvNextLast ) {
                pClusterLast = pClusterSrc;
            } else {
                pClusterNext = pClusterSrc;
                do {
                    pClusterLast    = pClusterNext;
                    pClusterNext    = LhtpBKTNextCluster(
                                        plht,
                                        pClusterLast );
                } while ( pClusterNext != NULL );

            LhtpBKTICopyEntry(
                plht,
                pvEntrySrc,
                pClusterLast->pvNextLast );
            }

            //  if we are on the last entry in the source bucket then stop the
            //  split after this iteration

            if ( pvEntrySrc == pClusterSrc->pvNextLast ) {
                pvEntrySrc = NULL;
            }

            //  if we didn't move the last entry in a cluster then free its slot

            if ( pClusterLast->pvNextLast != &pClusterLast->rgEntry[ 0 ] ) {
                pClusterLast->pvNextLast = (CHAR*)pClusterLast->pvNextLast - plht->cbEntry;

            //  if we moved the last entry in the head cluster then mark the
            //  head cluster as empty
            
            } else if ( pClusterLast == pClusterHeadSrc ) {
                pClusterLast->pvNextLast = NULL;

            //  we moved the last entry in an overflow cluster
            
            } else {
            
                //  remove this cluster from the source bucket
                
                pClusterNext = pClusterHeadSrc;
                do {
                    pClusterPrev    = pClusterNext;
                    pClusterNext    = LhtpBKTNextCluster(
                                        plht,
                                        pClusterPrev );
                } while ( pClusterNext != pClusterLast );

                pClusterPrev->pvNextLast = &pClusterPrev->rgEntry[ plht->cbEntry * ( plht->cEntryCluster - 1 ) ];

                //  place the cluster in the local cluster pool

                pClusterLast->pvNextLast    = pClusterAvail;
                pClusterAvail               = pClusterLast;
            }

        //  the current source entry belongs in the destination bucket
        
        } else {

            //  move to the next source position in the source bucket
            
            pvEntrySrc      = (CHAR*)pvEntrySrc + plht->cbEntry;
            pvEntrySrcMax   = LhtpBKTMaxEntry(
                                plht,
                                pClusterSrc );
            if ( pvEntrySrc >= pvEntrySrcMax ) {
                pClusterSrc = LhtpBKTNextCluster(
                                plht,
                                pClusterSrc );
                if ( pClusterSrc == NULL || pClusterSrc->pvNextLast == NULL ) {
                    pvEntrySrc = NULL;
                } else {
                    pvEntrySrc = &pClusterSrc->rgEntry[ 0 ];
                }
            }
        }
    }

    //  free any clusters in the local cluster pool

    while ( pClusterAvail ) {
        pClusterNext = LhtpBKTNextCluster(
                        plht,
                        pClusterAvail );
        LhtpPOOLFree(
            plht,
            pClusterAvail );
        pClusterAvail = pClusterNext;
    }

    //  if we did not need our reserve cluster then cancel our reservation

    if ( !fUsedReserve ) {
        LhtpPOOLUnreserve( plht );
    }

    LhtpSTATSplitBucket( plht );
}

VOID LhtpBKTIDoMerge(
    IN      PLHT            plht,
    IN OUT  PLHT_CLUSTER    pClusterHeadDest,
    IN OUT  PLHT_CLUSTER    pClusterHeadSrc
    )

/*++

Routine Description:

    This routine moves all entries from the destination bucket into the source
    bucket.

Arguments:

    plht                - Supplies the context for the linear hash table
    pClusterHeadDest    - Supplies the unmerged destination bucket and returns
                        the merged destination bucket containing all the
                        entries from both buckets
    pClusterHeadSrc     - Supplies the unmerged source bucket and returns an
                        empty bucket

Return Value:

    None

 --*/

{
    PLHT_CLUSTER    pClusterNext;
    PLHT_CLUSTER    pClusterDest;
    PVOID           pvEntryDest;
    PLHT_CLUSTER    pClusterSrc;
    PVOID           pvEntrySrc;
    PLHT_CLUSTER    pClusterAvail;
    BOOLEAN         fUsedReserve;
    PLHT_CLUSTER    pClusterAlloc;
    PVOID           pvEntrySrcMax;

    //  establish our initial position at the end of the destination bucket

    pClusterNext = pClusterHeadDest;
    do {
        pClusterDest    = pClusterNext;
        pClusterNext    = LhtpBKTNextCluster(
                            plht,
                            pClusterDest );
    } while ( pClusterNext != NULL );
    pvEntryDest = LhtpBKTMaxEntry(
                    plht,
                    pClusterDest );

    //  establish our initial position at the start of the source bucket

    pClusterSrc = pClusterHeadSrc;
    if ( pClusterSrc->pvNextLast == NULL ) {
        pvEntrySrc = NULL;
    } else {
        pvEntrySrc = &pClusterSrc->rgEntry[ 0 ];
    }

    //  reset the local cluster pool

    pClusterAvail   = NULL;
    fUsedReserve    = FALSE;

    //  move entries until we have consumed all the entries in the source bucket

    while ( pvEntrySrc != NULL ) {

        //  there is no room in the destination bucket for this entry
            
        if ( pvEntryDest == &pClusterDest->rgEntry[ plht->cbEntry * plht->cEntryCluster ] ) {

            //  if there are no clusters in the local cluster pool then commit
            //  our reservation from the cluster reserve pool and put that
            //  cluster in the local cluster pool
                
            if ( pClusterAvail == NULL ) {
                Assert( !fUsedReserve );
                fUsedReserve = TRUE;
                pClusterAvail = LhtpPOOLCommit( plht );
                pClusterAvail->pvNextLast = NULL;
            }

            //  grab a new cluster from the local cluster pool

            pClusterAlloc   = pClusterAvail;
            pClusterAvail   = pClusterAvail->pvNextLast;

            //  append the new cluster to the destination bucket

            pClusterDest->pvNextLast    = pClusterAlloc;
            pClusterAlloc->pvNextLast   = NULL;

            //  establish our position at the end of the destination bucket

            pClusterDest    = pClusterAlloc;
            pvEntryDest     = &pClusterAlloc->rgEntry[ 0 ];
        }

        //  consume a slot in the destination bucket

        pClusterDest->pvNextLast = pvEntryDest;

        //  copy the entry from the source slot to the destination slot

        LhtpBKTICopyEntry(
            plht,
            pvEntryDest,
            pvEntrySrc );

        //  bump our destination position

        pvEntryDest = (CHAR*)pvEntryDest + plht->cbEntry;

        //  move to the next source position in the source bucket
            
        pvEntrySrc      = (CHAR*)pvEntrySrc + plht->cbEntry;
        pvEntrySrcMax   = LhtpBKTMaxEntry(
                            plht,
                            pClusterSrc );
        if ( pvEntrySrc >= pvEntrySrcMax ) {
            pClusterNext = LhtpBKTNextCluster(
                            plht,
                            pClusterSrc );

            //  we just walked off of a source cluster.  if that cluster was
            //  not the head cluster of the bucket then remove that cluster
            //  from the source bucket and place it in the local cluster pool

            if ( pClusterSrc != pClusterHeadSrc ) {
                pClusterHeadSrc->pvNextLast = pClusterNext;
                
                pClusterSrc->pvNextLast     = pClusterAvail;
                pClusterAvail               = pClusterSrc;
            }

            pClusterSrc = pClusterNext;
            if ( pClusterSrc == NULL || pClusterSrc->pvNextLast == NULL ) {
                pvEntrySrc = NULL;
            } else {
                pvEntrySrc = &pClusterSrc->rgEntry[ 0 ];
            }
        }
    }

    //  mark the source bucket as empty

    pClusterHeadSrc->pvNextLast = NULL;

    //  free any clusters in the local cluster pool

    while ( pClusterAvail ) {
        pClusterNext = LhtpBKTNextCluster(
                        plht,
                        pClusterAvail );
        LhtpPOOLFree(
            plht,
            pClusterAvail );
        pClusterAvail = pClusterNext;
    }

    //  if we did not need our reserve cluster then cancel our reservation

    if ( !fUsedReserve ) {
        LhtpPOOLUnreserve( plht );
    }

    LhtpSTATMergeBucket( plht );
}

__inline
PVOID LhtpBKTMaxEntry(
    IN      PLHT            plht,
    IN      PLHT_CLUSTER    pCluster
    )

/*++

Routine Description:

    This routine computes the number of used entries in the given cluster and
    returns a pointer just beyond the last utilized entry.

Arguments:

    plht            - Supplies the context for the linear hash table
    pCluster        - Supplies the cluster to query

Return Value:

    A pointer just beyond the last entry in the cluster

 --*/

{
    if ( (DWORD_PTR)pCluster->pvNextLast - (DWORD_PTR)pCluster < plht->cbCluster ) {
        return (CHAR*)pCluster->pvNextLast + plht->cbEntry;
    } else if ( pCluster->pvNextLast == NULL ) {
        return &pCluster->rgEntry[ 0 ];
    } else {
        return &pCluster->rgEntry[ plht->cbEntry * plht->cEntryCluster ];
    }
}

__inline
PLHT_CLUSTER LhtpBKTNextCluster(
    IN      PLHT            plht,
    IN      PLHT_CLUSTER    pCluster
    )

/*++

Routine Description:

    This routine returns the next cluster after the given cluster in the chain
    of clusters in a bucket.

Arguments:

    plht            - Supplies the context for the linear hash table
    pCluster        - Supplies the cluster to query

Return Value:

    A pointer to the next cluster in the cluster chain or NULL if the given
    cluster is the last cluster in the bucket

 --*/

{
    if ( (DWORD_PTR)pCluster->pvNextLast - (DWORD_PTR)pCluster < plht->cbCluster ) {
        return NULL;
    } else {
        return (PLHT_CLUSTER)pCluster->pvNextLast;
    }
}

LHT_ERR LhtpBKTFindEntry(
    IN      PLHT        plht,
    IN      PVOID       pvKey,
    OUT     PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine searches the initial cluster of a bucket for an entry that
    matches the given key.  If a matching entry is found then its position is
    saved.  If a matching entry cannot be ruled out by the state of the initial
    cluster then we hand off to another routine that will search the entire
    cluster chain.

Arguments:

    plht            - Supplies the context for the linear hash table
    pvKey           - Supplies the key of the entry for which we are looking
    ppos            - Supplies the bucket to search for the entry and returns
                    the position of the entry if found

Return Value:

    LHT_ERR

        LHT_errEntryNotFound    - the entry was not found in the current bucket

 --*/

{
    PVOID pvEntry;
    
    ppos->pCluster      = ppos->pClusterHead;
    ppos->pvEntryPrev   = NULL;
    ppos->pvEntryNext   = NULL;

    if ( (DWORD_PTR)ppos->pClusterHead->pvNextLast - (DWORD_PTR)ppos->pClusterHead < plht->cbCluster ) {
        pvEntry = ppos->pClusterHead->rgEntry;
        do {
            if ( plht->pfnEntryMatchesKey(
                    pvEntry,
                    pvKey ) ) {
                ppos->pvEntry = pvEntry;
                return LHT_errSuccess;
            }
            pvEntry = (CHAR*)pvEntry + plht->cbEntry;
        } while ( pvEntry <= ppos->pClusterHead->pvNextLast );
        ppos->pvEntry = NULL;
        return LHT_errEntryNotFound;
    } else if ( ppos->pClusterHead->pvNextLast == NULL ) {
        ppos->pvEntry = NULL;
        return LHT_errEntryNotFound;
    } else {
        return LhtpBKTIFindEntry(
                plht,
                pvKey,
                ppos );
    }
}

__inline
LHT_ERR LhtpBKTRetrieveEntry(
    IN      PLHT        plht,
    IN      PLHT_POS    ppos,
    OUT     PVOID       pvEntry
    )

/*++

Routine Description:

    This routine retrieves the entry at the current position into the buffer
    provided by the caller.

Arguments:

    plht            - Supplies the context for the linear hash table
    ppos            - Supplies the position of the entry to retrieve
    pvEntry         - Returns the retrieved entry

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    if ( ppos->pvEntry != NULL ) {
        LhtpBKTICopyEntry(
            plht,
            pvEntry,
            ppos->pvEntry );
        return LHT_errSuccess;
    } else {
        return LHT_errNoCurrentEntry;
    }
}

__inline
LHT_ERR LhtpBKTReplaceEntry(
    IN      PLHT        plht,
    IN      PLHT_POS    ppos,
    IN      PVOID       pvEntry
    )

/*++

Routine Description:

    This routine replaces the entry at the current position with the entry
    provided by the caller.  The new entry must have the same key as the old
    entry.

Arguments:

    plht            - Supplies the context for the linear hash table
    ppos            - Supplies the position of the entry to replace
    pvEntry         - Supplies the new entry

Return Value:

    LHT_ERR

        LHT_errKeyChange        - the new entry doesn't have the same key as
                                the old entry
        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    SIZE_T  iHashOld;
    SIZE_T  iHashNew;
    
    if ( ppos->pvEntry != NULL ) {
        iHashOld    = plht->pfnHashEntry( ppos->pvEntry );
        iHashNew    = plht->pfnHashEntry( pvEntry );
        if ( iHashOld != iHashNew ) {
            return LHT_errKeyChange;
        } else {
            LhtpBKTICopyEntry(
                plht,
                ppos->pvEntry,
                pvEntry );
            return LHT_errSuccess;
        }
    } else {
        return LHT_errNoCurrentEntry;
    }
}

LHT_ERR LhtpBKTInsertEntry(
    IN      PLHT        plht,
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    )

/*++

Routine Description:

    This routine inserts a new entry into the current bucket.  If there is
    another entry at the current position in this bucket then we cannot insert
    the new entry because it would have the same key.  The new entry must have
    the same key as was used to position on this bucket.

Arguments:

    plht            - Supplies the context for the linear hash table
    ppos            - Supplies the bucket to place the new entry and returns
                    the position of the new entry if inserted
    pvEntry         - Supplies the new entry

Return Value:

    LHT_ERR

        LHT_errKeyDuplicate     - the new entry has the same key as an existing
                                entry
        LHT_errKeyChange        - the new entry doesn't have the same key as
                                was used to position on this bucket
        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    SIZE_T          iBucketNew;
    PLHT_CLUSTER    pClusterNext;
    PLHT_CLUSTER    pClusterNew;

    //  if we already positioned on an entry then this is a duplicate entry
    
    if ( ppos->pvEntry != NULL ) {
        return LHT_errKeyDuplicate;
    } else {

        //  if the new entry doesn't go in the current bucket then the caller
        //  tried to change the key on us
        
        LhtpDIRHash(
            plht,
            plht->pfnHashEntry( pvEntry ),
            &iBucketNew );
        if ( iBucketNew != ppos->iBucket ) {
            return LHT_errKeyChange;
        } else {

            //  change the current position to the end of the bucket

            pClusterNext = ppos->pCluster;
            do {
                ppos->pCluster  = pClusterNext;
                pClusterNext    = LhtpBKTNextCluster(
                                    plht,
                                    ppos->pCluster );
            } while ( pClusterNext != NULL );
            ppos->pvEntry = LhtpBKTMaxEntry(
                                plht,
                                ppos->pCluster );
            
            //  there is no room in the bucket for this entry

            if ( ppos->pvEntry == &ppos->pCluster->rgEntry[ plht->cbEntry * plht->cEntryCluster ] ) {

                //  allocate a new cluster
                
                pClusterNew = LhtpPOOLAlloc( plht );
                if ( !pClusterNew ) {
                    return LHT_errOutOfMemory;
                }

                LhtpSTATInsertOverflowCluster( plht );

                //  append the new cluster to the bucket

                ppos->pCluster->pvNextLast = pClusterNew;

                //  change the current position to the end of the bucket

                ppos->pCluster  = pClusterNew;
                ppos->pvEntry   = &pClusterNew->rgEntry[ 0 ];
            }

            //  consume a slot in the bucket

            ppos->pCluster->pvNextLast = ppos->pvEntry;

            //  copy the new entry into the new slot
            
            LhtpBKTICopyEntry(
                plht,
                ppos->pvEntry,
                pvEntry );

            return LHT_errSuccess;
        }
    }
}

LHT_ERR LhtpBKTDeleteEntry(
    IN      PLHT        plht,
    IN OUT  PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine deletes the entry at the current position.

Arguments:

    plht            - Supplies the context for the linear hash table
    ppos            - Supplies the position of the entry to delete

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    PLHT_CLUSTER    pClusterNext;
    PLHT_CLUSTER    pClusterLast;
    PLHT_CLUSTER    pClusterPrev;

    //  if there is no current entry then we cannot delete it

    if ( ppos->pvEntry == NULL ) {
        return LHT_errNoCurrentEntry;
    } else {

        //  copy the entry from the end of the bucket into the empty slot

        if ( ppos->pvEntry == ppos->pCluster->pvNextLast ) {
            pClusterLast = ppos->pCluster;
        } else {
            pClusterNext = ppos->pCluster;
            do {
                pClusterLast    = pClusterNext;
                pClusterNext    = LhtpBKTNextCluster(
                                    plht,
                                    pClusterLast );
            } while ( pClusterNext != NULL );

        LhtpBKTICopyEntry(
            plht,
            ppos->pvEntry,
            pClusterLast->pvNextLast );
        }

        //  set our new position to be between the entry before the entry that
        //  was just deleted and the entry after the entry we just deleted

        if ( ppos->pvEntry == &ppos->pCluster->rgEntry[ 0 ] ) {
            ppos->pvEntryPrev   = NULL;
            ppos->pvEntry       = NULL;
            ppos->pvEntryNext   = ppos->fScan ? ppos->pvEntry : NULL;
        } else if ( ppos->pvEntry == ppos->pCluster->pvNextLast ) {
            ppos->pvEntryPrev   = ppos->fScan ? (CHAR*)ppos->pvEntry - plht->cbEntry : NULL;
            ppos->pvEntry       = NULL;
            ppos->pvEntryNext   = NULL;
        } else {
            ppos->pvEntryPrev   = ppos->fScan ? (CHAR*)ppos->pvEntry - plht->cbEntry : NULL;
            ppos->pvEntry       = NULL;
            ppos->pvEntryNext   = ppos->fScan ? ppos->pvEntry : NULL;
        }

        //  if we didn't move the last entry in a cluster then free its slot

        if ( pClusterLast->pvNextLast != &pClusterLast->rgEntry[ 0 ] ) {
            pClusterLast->pvNextLast = (CHAR*)pClusterLast->pvNextLast - plht->cbEntry;

        //  if we moved the last entry in the head cluster then mark the gead
        //  cluster as empty
        
        } else if ( pClusterLast == ppos->pClusterHead ) {
            pClusterLast->pvNextLast = NULL;

        //  we moved the last entry in an overflow cluster
            
        } else {
            
            //  remove this cluster from the source bucket
                
            pClusterNext = ppos->pClusterHead;
            do {
                pClusterPrev    = pClusterNext;
                pClusterNext    = LhtpBKTNextCluster(
                                    plht,
                                    pClusterPrev );
            } while ( pClusterNext != pClusterLast );

            pClusterPrev->pvNextLast = &pClusterPrev->rgEntry[ plht->cbEntry * ( plht->cEntryCluster - 1 ) ];

            //  free the overflow cluster

            LhtpPOOLFree(
                plht,
                pClusterLast );

            LhtpSTATDeleteOverflowCluster( plht );

            //  if we just freed the cluster that we are positioned on then
            //  move to be after the last entry in the bucket

            if ( ppos->pCluster == pClusterLast ) {
                ppos->pCluster      = pClusterPrev;
                ppos->pvEntryPrev   = ppos->fScan ? pClusterPrev->pvNextLast : NULL;
                ppos->pvEntry       = NULL;
                ppos->pvEntryNext   = NULL;
            }
        }

        return LHT_errSuccess;
    }
}

VOID LhtpBKTSplit(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine attempts to split the highest unsplit bucket in the linear
    hash table.  If the split cannot be performed then no action is taken.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    PLHT_CLUSTER    pClusterHeadSrc;
    SIZE_T          iBucketT;
    SIZE_T          iExponent;
    SIZE_T          iRemainder;
    PLHT_CLUSTER    pClusterHeadDest;

    Assert( plht->cBucketMax + plht->cBucket < plht->cBucketPreferred );
    Assert( plht->cBucket < plht->cBucketMax );

    //  if we can't reserve a cluster for use during the split then we cannot
    //  continue
    
    if ( !LhtpPOOLReserve( plht ) ) {
        return;
    }

    //  get the source bucket for the split

    pClusterHeadSrc = LhtpDIRHash(
                        plht,
                        plht->cBucket,
                        &iBucketT );

    //  if the destination bucket doesn't exist yet then create its bucket array

    LhtpLog2(
        plht->cBucketMax + plht->cBucket,
        &iExponent,
        &iRemainder );

    if ( !plht->rgrgBucket[ iExponent ] ) {
        if ( LhtpDIRCreateBucketArray(
                plht,
                plht->cBucketMax,
                &plht->rgrgBucket[ iExponent ] ) != LHT_errSuccess ) {
            LhtpPOOLUnreserve( plht );
            return;
        }
    }

    //  get the destination bucket for the split

    pClusterHeadDest = LhtpDIRResolve(
                        plht,
                        iExponent,
                        iRemainder );

    //  update the table state to indicate that the bucket has been split

    plht->cBucket++;

    //  split the bucket

    LhtpBKTIDoSplit(
        plht,
        pClusterHeadSrc,
        pClusterHeadDest );
}

VOID LhtpBKTMerge(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine attempts to merge the highest unmerged bucket in the linear
    hash table.  If the merge cannot be performed then no action is taken.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    PLHT_CLUSTER    pClusterHeadDest;
    SIZE_T          iBucketT;
    PLHT_CLUSTER    pClusterHeadSrc;

    Assert( plht->cBucketMax + plht->cBucket > plht->cBucketPreferred );
    Assert( plht->cBucket > 0 );

    //  if we can't reserve a cluster for use during the merge then we cannot
    //  continue
    
    if ( !LhtpPOOLReserve( plht ) ) {
        return;
    }

    //  get the destination bucket for the merge

    pClusterHeadDest = LhtpDIRHash(
                        plht,
                        plht->cBucket - 1,
                        &iBucketT );

    //  get the source bucket for the split

    pClusterHeadSrc = LhtpDIRHash(
                        plht,
                        plht->cBucketMax + plht->cBucket - 1,
                        &iBucketT );

    //  update the table state to indicate that the bucket has been merged

    plht->cBucket--;

    //  merge the bucket

    LhtpBKTIDoMerge(
        plht,
        pClusterHeadDest,
        pClusterHeadSrc );
}


//  Statistics and Metrics

__inline
VOID LhtpSTATInsertEntry(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that an entry has been inserted into the
    linear hash table.  These statistics are used to drive table maintenance.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    plht->cEntry++;
    plht->cOp++;
}

__inline
VOID LhtpSTATDeleteEntry(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that an entry has been delted from the
    linear hash table.  These statistics are used to drive table maintenance.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    plht->cEntry--;
    plht->cOp++;
}

__inline
VOID LhtpSTATInsertOverflowCluster(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that an overflow cluster has been inserted
    into a bucket in the linear hash table.  These statistics are used to
    analyze the performance of the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cOverflowClusterAlloc++;
#endif  //  LHT_PERF
}

__inline
VOID LhtpSTATDeleteOverflowCluster(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that an overflow cluster has been deleted
    from a bucket in the linear hash table.  These statistics are used to
    analyze the performance of the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cOverflowClusterFree++;
#endif  //  LHT_PERF
}

__inline
VOID LhtpSTATSplitBucket(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that a bucket has been split in the linear
    hash table.  These statistics are used to analyze the performance of the
    linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cBucketSplit++;
#endif  //  LHT_PERF
}

__inline
VOID LhtpSTATMergeBucket(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that a bucket has been merged in the linear
    hash table.  These statistics are used to analyze the performance of the
    linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cBucketMerge++;
#endif  //  LHT_PERF
}

__inline
VOID LhtpSTATSplitDirectory(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that the directory has been split in the
    linear hash table.  These statistics are used to analyze the performance of
    the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cDirectorySplit++;
#endif  //  LHT_PERF
}

__inline
VOID LhtpSTATMergeDirectory(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that the directory has been merged in the
    linear hash table.  These statistics are used to analyze the performance of
    the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cDirectoryMerge++;
#endif  //  LHT_PERF
}

__inline
VOID LhtpSTATStateTransition(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that there has been a transition in the
    maintenance state of the linear hash table.  These statistics are used to
    analyze the performance of the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cStateTransition++;
#endif  //  LHT_PERF
}

__inline
VOID LhtpSTATPolicySelection(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine records the fact that there has been a maintenance policy
    selection for the linear hash table.  These statistics are used to analyze
    the performance of the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cPolicySelection++;
#endif  //  LHT_PERF
}

VOID LhtpSTATAllocateMemory(
    IN      PLHT        plht,
    IN      SIZE_T      cbAlloc
    )

/*++

Routine Description:

    This routine records the fact that a memory block of the given size has
    been allocated.  These statistics are used to analyze the performance of
    the linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table
    cbAlloc         - Supplies the size of the allocated memory block

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cMemoryAllocation++;
    plht->cbMemoryAllocated += cbAlloc;
#endif  //  LHT_PERF
}

VOID LhtpSTATFreeMemory(
    IN      PLHT        plht,
    IN      SIZE_T      cbAlloc
    )

/*++

Routine Description:

    This routine records the fact that a memory block of the given size has
    been freed.  These statistics are used to analyze the performance of the
    linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table
    cbAlloc         - Supplies the size of the freed memory block

Return Value:

    None

 --*/

{
#ifdef LHT_PERF
    plht->cMemoryFree++;
    plht->cbMemoryFreed += cbAlloc;
#endif  //  LHT_PERF
}


//  Memory Manager

__inline
PVOID LhtpMEMIAlign(
    IN      PLHT        plht,
    IN OUT  PVOID       pv
    )

/*++

Routine Description:

    This routine takes a chunk of memory and aligns it to the nearest cache
    line boundary as configured for this linear hash table.  The alignment
    offset is stored in the chunk of memory just before the aligned pointer.

Arguments:

    plht            - Supplies the context for the linear hash table
    pv              - Supplies a chunk of raw memory to align and returns that
                    chunk of memory with the alignment offset stored in the
                    byte immediately preceeding the aligned pointer

Return Value:

    A pointer to the first cache line in the given chunk of memory

 --*/

{
    DWORD_PTR   dwAligned;
    DWORD_PTR   dwOffset;
    
    dwAligned   = ( ( (DWORD_PTR)pv + plht->cbCacheLine ) / plht->cbCacheLine ) * plht->cbCacheLine;
    dwOffset    = dwAligned - (DWORD_PTR)pv;

    Assert( (UCHAR)dwOffset == dwOffset );

    ((UCHAR*)dwAligned)[ -1 ] = (UCHAR)dwOffset;

    return (PVOID)dwAligned;
}

__inline
PVOID LhtpMEMIUnalign(
    IN      PVOID       pv
    )

/*++

Routine Description:

    This routine returns the original unaligned pointer to a chunk of memory
    given its aligned pointer.

Arguments:

    pv              - Supplies a chunk of memory to unalign

Return Value:

    A pointer to the unaligned chunk of memory

 --*/

{
    return (PVOID)( (DWORD_PTR)pv - ((UCHAR*)pv)[ -1 ] );
}

PVOID LhtpMEMAlloc(
    IN      PLHT        plht,
    IN      SIZE_T      cbAlloc
    )

/*++

Routine Description:

    This routine allocates a cache line aligned chunk of memory of the given
    size.  The allocator used is either the configured allocator for the linear
    hash table or malloc().

Arguments:

    plht            - Supplies the context for the linear hash table
    cbAlloc         - Supplies the size of the chunk of memory to allocate

Return Value:

    A pointer to an aligned chunk of memory of the requested size

 --*/

{
    SIZE_T  cbPad;
    PVOID   pv;

    cbPad = cbAlloc + plht->cbCacheLine;

    if ( plht->pfnMalloc ) {
        pv = plht->pfnMalloc( cbPad );
    } else {
        pv = malloc( cbPad );
    }

    if ( pv == NULL ) {
        return NULL;
    } else {
        LhtpSTATAllocateMemory(
            plht,
            cbPad );
        return LhtpMEMIAlign(
                plht,
                pv );
    }
}

VOID LhtpMEMFree(
    IN      PLHT        plht,
    IN      PVOID       pvAlloc,
    IN      SIZE_T      cbAlloc
    )

/*++

Routine Description:

    This routine frees an aligned chunk of memory.  The deallocator used is
    either the configured deallocator for the linear hash table or free() if no
    allocator or deallocator is configured.  If an allocator but no deallocator
    is configured then the memory is not freed.

Arguments:

    plht            - Supplies the context for the linear hash table
    pvAlloc         - Supplies the chunk of aligned memory to free

Return Value:

    None

 --*/

{
    PVOID pvUnalign;
    
    if ( pvAlloc != NULL ) {
        pvUnalign = LhtpMEMIUnalign( pvAlloc );

        LhtpSTATFreeMemory(
            plht,
            cbAlloc + plht->cbCacheLine );
        
        if ( plht->pfnMalloc ) {
            if ( plht->pfnFree ) {
                plht->pfnFree( pvUnalign );
            }
        } else {
            free( pvUnalign );
        }
    }
}


//  API

VOID LhtpPerformMaintenance(
    IN      PLHT        plht,
    IN      SIZE_T      iBucketPos
    )

/*++

Routine Description:

    This routine performs maintenance on the linear hash table.  Typically,
    this consists of splitting or merging buckets to strive for the current
    preferred size of the table.  The routine avoids performing maintenance on
    the specified bucket so as to preserve the current position of the caller.

Arguments:

    plht            - Supplies the context for the linear hash table
    iBucketPos      - Supplies the index of the bucket to protect from
                    maintenance

Return Value:

    None

 --*/

{
    //  we are currently splitting buckets
    
    if ( plht->stateCur == LHT_stateGrow ) {

        //  there are still more buckets that can be split at this split level
        
        if ( plht->cBucket < plht->cBucketMax ) {
            
            //  the next bucket to split is not protected from maintenance
            
            if ( plht->cBucket != iBucketPos ) {

                //  split a bucket
                
                LhtpBKTSplit( plht );
            }
        }

    //  we are currently merging buckets
    
    } else if ( plht->stateCur == LHT_stateShrink ) {

        //  there are still more buckets that can be merged at this split level
        
        if ( plht->cBucket > 0 ) {

            //  the next bucket to merge is not protected from maintenance
            
            if ( plht->cBucket - 1 != iBucketPos && plht->cBucketMax + plht->cBucket - 1 != iBucketPos ) {

                //  merge a bucket
                
                LhtpBKTMerge( plht );
            }
        }
    }
}

VOID LhtpSelectMaintenancePolicy(
    IN      PLHT        plht
    )

/*++

Routine Description:

    This routine selects the overall maintenance policy for the linear hash
    table based on the statistics collected over the last collection interval.
    The strategy is to keep the table as near to its preferred size as possible
    while minimizing useless growth/shrinkage in reaction to local fluctuations
    in the size of the table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    SIZE_T      cBucketActive;
    SIZE_T      cEntryIdeal;
    SIZE_T      cEntryMax;
    SIZE_T      cEntryFlexibility;
    SIZE_T      cOpSensitivity;
    SIZE_T      cEntryPreferred;
    SIZE_T      cBucketPreferred;
    LHT_STATE   stateNew;

    //  reset the operation count

    plht->cOp = 0;

    //  compute the current active bucket count

    cBucketActive = plht->cBucketMax + plht->cBucket;

    //  compute the ideal entry count

    cEntryIdeal = plht->cLoadFactor * cBucketActive;

    //  compute the max entry count

    cEntryMax = plht->cEntryCluster * cBucketActive;

    //  determine our current flexibility in the entry count

    cEntryFlexibility = max( plht->cEntryCluster - plht->cLoadFactor, cEntryMax / 2 - cEntryIdeal );

    //  determine our current threshold sensitivity

    cOpSensitivity = max( 1, cEntryFlexibility / 2 );

    //  compute the preferred entry count

    cEntryPreferred = plht->cEntry;
    if ( cEntryIdeal + ( cEntryFlexibility - cOpSensitivity ) < plht->cEntry ) {
        cEntryPreferred = plht->cEntry - ( cEntryFlexibility - cOpSensitivity );
    } else if ( cEntryIdeal > plht->cEntry + ( cEntryFlexibility - cOpSensitivity ) ) {
        cEntryPreferred = plht->cEntry + ( cEntryFlexibility - cOpSensitivity );
    }

    //  compute the preferred bucket count

    cBucketPreferred = max( plht->cBucketMin, ( cEntryPreferred + plht->cLoadFactor - 1 ) / plht->cLoadFactor );

    //  determine the new policy

    stateNew = LHT_stateNil;
    if ( plht->stateCur == LHT_stateGrow ) {
        if ( cBucketPreferred < cBucketActive ) {
            stateNew = LHT_stateShrink;
        } else if ( cBucketPreferred > cBucketActive ) {
            if ( plht->cBucket == plht->cBucketMax ) {
                stateNew = LHT_stateSplit;
            }
        }
    } else {
        Assert( plht->stateCur == LHT_stateShrink );
        if ( cBucketPreferred < cBucketActive) {
            if ( plht->cBucket == 0 ) {
                stateNew = LHT_stateMerge;
            }
        } else if ( cBucketPreferred > cBucketActive ) {
            stateNew = LHT_stateGrow;
        }
    }

    //  enact the new policy

    if ( plht->cOpSensitivity != cOpSensitivity ) {
        plht->cOpSensitivity = cOpSensitivity;
    }
    if ( plht->cBucketPreferred != cBucketPreferred ) {
        plht->cBucketPreferred = cBucketPreferred;
    }
    if ( stateNew != LHT_stateNil ) {
        LhtpSTTransition(
            plht,
            stateNew );
    }

    LhtpSTATPolicySelection( plht );
}

__inline
VOID LhtpMaintainTable(
    IN      PLHT        plht,
    IN      SIZE_T      iBucketPos
    )

/*++

Routine Description:

    This routine is called by every operation that may affect the health of the
    linear hash table.  It decides if and when to perform table maintenance or
    select a maintenance policy based on the usage statistics of the table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    //  decide on a new policy if we have breached one of our thresholds
    
    if ( plht->cOp > plht->cOpSensitivity ) {
        LhtpSelectMaintenancePolicy( plht );
    }

    //  perform amortized work on the table as necessary
    
    if ( plht->cBucketMax + plht->cBucket != plht->cBucketPreferred ) {
        LhtpPerformMaintenance(
            plht,
            iBucketPos );
    }
}

LHT_ERR LhtpMoveNext(
    IN OUT  PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine finds the next entry in the table after the current position
    in the table.  The starting position is always after the last entry in a
    cluster.

Arguments:

    ppos            - Supplies the current position in the table and returns
                    the new position in the table

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (after last)

 --*/

{
    PLHT_CLUSTER pClusterNext;
    
    pClusterNext = LhtpBKTNextCluster(
                    ppos->plht,
                    ppos->pCluster );
    
    if ( pClusterNext != NULL ) {
        ppos->pCluster      = pClusterNext;
        ppos->pvEntryPrev   = NULL;
        ppos->pvEntry       = &pClusterNext->rgEntry[ 0 ];
        ppos->pvEntryNext   = NULL;
        return LHT_errSuccess;
    } else if ( ppos->iBucket >= ppos->plht->cBucketMax + ppos->plht->cBucket - 1 ) {
        ppos->pvEntryPrev   = ppos->pCluster->pvNextLast;
        ppos->pvEntry       = NULL;
        ppos->pvEntryNext   = NULL;
        return LHT_errNoCurrentEntry;
    } else {
        do {
            ppos->pClusterHead  = LhtpDIRHash(
                                    ppos->plht,
                                    ppos->iBucket + 1,
                                    &ppos->iBucket );
            ppos->pCluster      = ppos->pClusterHead;
            ppos->pvEntryPrev   = NULL;
            ppos->pvEntry       = NULL;
            ppos->pvEntryNext   = NULL;

            if ( ppos->pClusterHead->pvNextLast != NULL ) {
                ppos->pvEntry = &ppos->pClusterHead->rgEntry[ 0 ];
                return LHT_errSuccess;
            }
        } while ( ppos->iBucket < ppos->plht->cBucketMax + ppos->plht->cBucket - 1 );
        return LHT_errNoCurrentEntry;
    }
}

LHT_ERR LhtpMovePrev(
    IN OUT  PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine finds the previous entry in the table before the current
    position in the table.  The starting position is always before the first
    entry in a cluster.

Arguments:

    ppos            - Supplies the current position in the table and returns
                    the new position in the table

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first)

 --*/

{
    PLHT_CLUSTER     pClusterNext;
    PLHT_CLUSTER     pClusterPrev;
    PLHT_CLUSTER     pClusterLast;
    
    pClusterNext = ppos->pClusterHead;
    do {
        pClusterPrev    = pClusterNext;
        pClusterNext    = LhtpBKTNextCluster(
                            ppos->plht,
                            pClusterPrev );
    } while ( pClusterNext != NULL && pClusterNext != ppos->pCluster );
    
    if ( pClusterNext == ppos->pCluster ) {
        ppos->pCluster      = pClusterPrev;
        ppos->pvEntryPrev   = NULL;
        ppos->pvEntry       = &pClusterPrev->rgEntry[ ppos->plht->cbEntry * ( ppos->plht->cEntryCluster - 1 ) ];
        ppos->pvEntryNext   = NULL;
        return LHT_errSuccess;
    } else if ( ppos->iBucket == 0 ) {
        ppos->pvEntryPrev   = NULL;
        ppos->pvEntry       = NULL;
        ppos->pvEntryNext   = &ppos->pCluster->rgEntry[ 0 ];
        return LHT_errNoCurrentEntry;
    } else {
        do {
            ppos->pClusterHead  = LhtpDIRHash(
                                    ppos->plht,
                                    ppos->iBucket - 1,
                                    &ppos->iBucket );
            ppos->pCluster      = NULL;
            ppos->pvEntryPrev   = NULL;
            ppos->pvEntry       = NULL;
            ppos->pvEntryNext   = NULL;

            pClusterNext = ppos->pClusterHead;
            do {
                pClusterLast    = pClusterNext;
                pClusterNext    = LhtpBKTNextCluster(
                                    ppos->plht,
                                    pClusterLast );
            } while ( pClusterNext != NULL );

            ppos->pCluster      = pClusterLast;
            ppos->pvEntry       = pClusterLast->pvNextLast;

            if ( ppos->pvEntry != NULL ) {
                return LHT_errSuccess;
            }
        } while ( ppos->iBucket > 0 );
        return LHT_errNoCurrentEntry;
    }
}

LHT_ERR LhtCreate(
    IN      SIZE_T                      cbEntry,
    IN      LHT_PFNHASHKEY              pfnHashKey,
    IN      LHT_PFNHASHENTRY            pfnHashEntry,
    IN      LHT_PFNENTRYMATCHESKEY      pfnEntryMatchesKey,
    IN      LHT_PFNCOPYENTRY            pfnCopyEntry        OPTIONAL,
    IN      SIZE_T                      cLoadFactor         OPTIONAL,
    IN      SIZE_T                      cEntryMin           OPTIONAL,
    IN      LHT_PFNMALLOC               pfnMalloc           OPTIONAL,
    IN      LHT_PFNFREE                 pfnFree             OPTIONAL,
    IN      SIZE_T                      cbCacheLine         OPTIONAL,
    OUT     PLHT*                       pplht
    )

/*++

Routine Description:

    This routine creates a linear hash table with the given configuration.

Arguments:

    cbEntry             - Supplies the size of an individual entry in bytes
    pfnHashKey          - Supplies a function to compute the hash index for a
                        given key
    pfnHashEntry        - Supplies a function to compute the hash index for a
                        given entry
    pfnEntryMatchesKey  - Supplies a function to match a given entry with a
                        given key
    pfnCopyEntry        - Supplies a function that copies an entry.  If no
                        function is supplied then memcpy() will be used
    cLoadFactor         - Supplies the ideal number of entries per bucket
    cEntryMin           - Supplies the ideal minimum capacity of the table
    pfnMalloc           - Supplies a function to allocate blocks of memory.  If
                        no function is supplied then malloc() will be used
    pfnFree             - Supplies a function to deallocate blocks of memory.
                        If no function is supplied for either the allocator or
                        the deallocator then free() will be used.  If a
                        function is supplied for the allocator but not the
                        deallocator then memory will not be deallocated by the
                        table
    cbCacheLine         - Supplies the ideal memory alignment for memory blocks
                        used by the table
    pplht               - Returns a pointer to the new linear hash table

Return Value:

    LHT_ERR

 --*/

{
    LHT     lht;
    PLHT    plht;
    LHT_ERR err;

    if ( ARGUMENT_PRESENT( pplht ) ) {
        *pplht = NULL;
    }

    if ( !ARGUMENT_PRESENT( cbEntry ) ) {
        return LHT_errInvalidParameter;
    }
    if ( !ARGUMENT_PRESENT( pfnHashKey ) ) {
        return LHT_errInvalidParameter;
    }
    if ( !ARGUMENT_PRESENT( pfnHashEntry ) ) {
        return LHT_errInvalidParameter;
    }
    if ( !ARGUMENT_PRESENT( pfnEntryMatchesKey ) ) {
        return LHT_errInvalidParameter;
    }
    if ( !ARGUMENT_PRESENT( pfnMalloc ) && ARGUMENT_PRESENT( pfnFree ) ) {
        return LHT_errInvalidParameter;
    }
    if ( !ARGUMENT_PRESENT( pplht ) ) {
        return LHT_errInvalidParameter;
    }

    memset( &lht, 0, sizeof( LHT ) );

    lht.cbEntry             = cbEntry;
    lht.pfnHashKey          = pfnHashKey;
    lht.pfnHashEntry        = pfnHashEntry;
    lht.pfnEntryMatchesKey  = pfnEntryMatchesKey;
    lht.pfnCopyEntry        = pfnCopyEntry;
    lht.cLoadFactor         = cLoadFactor;
    lht.cEntryMin           = cEntryMin;
    lht.pfnMalloc           = pfnMalloc;
    lht.pfnFree             = pfnFree;
    lht.cbCacheLine         = cbCacheLine;

    if ( !ARGUMENT_PRESENT( cLoadFactor ) ) {
        lht.cLoadFactor = 5;
    }
    if ( !ARGUMENT_PRESENT( cbCacheLine ) ) {
        lht.cbCacheLine = 32;
    }

    lht.stateCur = LHT_stateGrow;

    plht = LhtpMEMAlloc(
            &lht,
            sizeof( LHT ) );
    if ( !plht ) {
        return LHT_errOutOfMemory;
    }
    memcpy( plht, &lht, sizeof( LHT ) );

    err = LhtpDIRInit( plht );
    if ( err != LHT_errSuccess ) {
        LhtpMEMFree(
            plht,
            plht,
            sizeof( LHT ) );
        return err;
    }

    *pplht = plht;
    return LHT_errSuccess;
}

VOID LhtDestroy(
    IN      PLHT        plht    OPTIONAL
    )

/*++

Routine Description:

    This routine destroys a linear hash table.

Arguments:

    plht            - Supplies the context for the linear hash table

Return Value:

    None

 --*/

{
    if ( ARGUMENT_PRESENT( plht ) ) {
        LhtpDIRTerm( plht );

        LhtpMEMFree(
            plht,
            plht,
            sizeof( LHT ) );
    }
}

VOID LhtMoveBeforeFirst(
    IN      PLHT        plht,
    OUT     PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine creates a new position context for the linear hash table and
    places it before all entries in the table.

Arguments:

    plht            - Supplies the context for the linear hash table
    ppos            - Returns a new position context

Return Value:

    None

 --*/

{
    ppos->plht          = plht;
    ppos->fScan         = TRUE;
    ppos->pClusterHead  = LhtpDIRHash(
                            plht,
                            0,
                            &ppos->iBucket );
    ppos->pCluster      = NULL;
    ppos->pvEntryPrev   = NULL;
    ppos->pvEntry       = NULL;
    ppos->pvEntryNext   = NULL;

    ppos->pCluster = ppos->pClusterHead;
    if ( ppos->pClusterHead->pvNextLast != NULL ) {
        ppos->pvEntryNext = &ppos->pClusterHead->rgEntry[ 0 ];
    }
}

LHT_ERR LhtMoveNext(
    IN OUT  PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine finds the next entry in the table after the current position
    in the table.

Arguments:

    ppos            - Supplies the current position in the table and returns
                    the new position in the table

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (after last)

 --*/

{
    PVOID   pvEntryNext;
    PVOID   pvEntryMax;
    
    if ( ppos->pvEntry != NULL ) {
        pvEntryNext     = (CHAR*)ppos->pvEntry + ppos->plht->cbEntry;
        pvEntryMax      = LhtpBKTMaxEntry(
                            ppos->plht,
                            ppos->pCluster );
        if ( pvEntryNext >= pvEntryMax ) {
            ppos->pvEntry = NULL;
        } else {
            ppos->pvEntry = pvEntryNext;
        }
    } else {
        ppos->pvEntry = ppos->pvEntryNext;
    }

    ppos->pvEntryPrev   = NULL;
    ppos->pvEntryNext   = NULL;

    if ( ppos->pvEntry != NULL ) {
        return LHT_errSuccess;
    } else {
        return LhtpMoveNext( ppos );
    }
}

LHT_ERR LhtMovePrev(
    IN OUT  PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine finds the previous entry in the table before the current
    position in the table.

Arguments:

    ppos            - Supplies the current position in the table and returns
                    the new position in the table

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first)

 --*/

{
    PVOID   pvEntryPrev;
    PVOID   pvEntryMin;
    
    if ( ppos->pvEntry != NULL ) {
        pvEntryPrev     = (CHAR*)ppos->pvEntry - ppos->plht->cbEntry;
        pvEntryMin      = &ppos->pCluster->rgEntry[ 0 ];
        if ( pvEntryPrev < pvEntryMin ) {
            ppos->pvEntry = NULL;
        } else {
            ppos->pvEntry = pvEntryPrev;
        }
    } else {
        ppos->pvEntry = ppos->pvEntryPrev;
    }

    ppos->pvEntryPrev   = NULL;
    ppos->pvEntryNext   = NULL;

    if ( ppos->pvEntry != NULL ) {
        return LHT_errSuccess;
    } else {
        return LhtpMovePrev( ppos );
    }
}

VOID LhtMoveAfterLast(
    IN      PLHT        plht,
    OUT     PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine creates a new position context for the linear hash table and
    places it after all entries in the table.

Arguments:

    plht            - Supplies the context for the linear hash table
    ppos            - Returns a new position context

Return Value:

    None

 --*/

{
    PLHT_CLUSTER    pClusterNext;
    PLHT_CLUSTER    pClusterLast;
    
    ppos->plht          = plht;
    ppos->fScan         = TRUE;
    ppos->pClusterHead  = LhtpDIRHash(
                            plht,
                            plht->cBucketMax + plht->cBucket - 1,
                            &ppos->iBucket );
    ppos->pCluster      = NULL;
    ppos->pvEntryPrev   = NULL;
    ppos->pvEntry       = NULL;
    ppos->pvEntryNext   = NULL;

    pClusterNext = ppos->pClusterHead;
    do {
        pClusterLast    = pClusterNext;
        pClusterNext    = LhtpBKTNextCluster(
                            plht,
                            pClusterLast );
    } while ( pClusterNext != NULL );

    ppos->pCluster      = pClusterLast;
    ppos->pvEntryPrev   = pClusterLast->pvNextLast;
}

LHT_ERR LhtFindEntry(
    IN      PLHT        plht,
    IN      PVOID       pvKey,
    OUT     PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine searches the linear hash table for an entry that matches a
    given key.  If a matching entry is discovered then its position is saved.
    If a matching entry is not found then the position of where it could be is
    saved to facilitate insertion of a new entry with that key.

Arguments:

    plht            - Supplies the context for the linear hash table
    pvKey           - Supplies the key of the entry for which we are looking
    ppos            - Returns a new position context pointing to the entry if
                    found or where it could be if not found

Return Value:

    LHT_ERR

        LHT_errEntryNotFound    - the entry was not found in the table

 --*/

{
    ppos->plht          = plht;
    ppos->fScan         = FALSE;
    ppos->pClusterHead  = LhtpDIRHash(
                            plht,
                            plht->pfnHashKey( pvKey ),
                            &ppos->iBucket );

    return LhtpBKTFindEntry(
            plht,
            pvKey,
            ppos );
}

LHT_ERR LhtRetrieveEntry(
    IN OUT  PLHT_POS    ppos,
    OUT     PVOID       pvEntry
    )

/*++

Routine Description:

    This routine retrieves the entry at the current position into the buffer
    provided by the caller.

Arguments:

    ppos            - Supplies the position of the entry to retrieve
    pvEntry         - Returns the retrieved entry

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    return LhtpBKTRetrieveEntry(
            ppos->plht,
            ppos,
            pvEntry );
}

LHT_ERR LhtReplaceEntry(
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    )

/*++

Routine Description:

    This routine replaces the entry at the current position with the entry
    provided by the caller.  The new entry must have the same key as the old
    entry.

Arguments:

    ppos            - Supplies the position of the entry to replace
    pvEntry         - Supplies the new entry

Return Value:

    LHT_ERR

        LHT_errKeyChange        - the new entry doesn't have the same key as
                                the old entry
        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    return LhtpBKTReplaceEntry(
            ppos->plht,
            ppos,
            pvEntry );
}

LHT_ERR LhtInsertEntry(
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    )

/*++

Routine Description:

    This routine inserts a new entry at the current position in the linear hash
    table.  If there is another entry at the current position then we cannot
    insert the new entry because it would have the same key.  The new entry
    must have the same key as was used to find this position.  It is illegal to
    attempt to insert an entry while scanning the table.

Arguments:

    ppos            - Supplies the position to place the new entry and returns
                    the position of the new entry if inserted
    pvEntry         - Supplies the new entry

Return Value:

    LHT_ERR

        LHT_errKeyDuplicate     - the new entry has the same key as an existing
                                entry
        LHT_errKeyChange        - the new entry doesn't have the same key as
                                was used to position on this bucket
        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    LHT_ERR err;

    if ( ppos->fScan ) {
        return LHT_errInvalidParameter;
    }

    err = LhtpBKTInsertEntry(
            ppos->plht,
            ppos,
            pvEntry );
    if ( err == LHT_errSuccess ) {
        LhtpSTATInsertEntry( ppos->plht );

        LhtpMaintainTable(
            ppos->plht,
            ppos->iBucket );
    }

    return err;
}

LHT_ERR LhtDeleteEntry(
    IN OUT  PLHT_POS    ppos
    )

/*++

Routine Description:

    This routine deletes the entry at the current position.

Arguments:

    ppos            - Supplies the position of the entry to delete

Return Value:

    LHT_ERR

        LHT_errNoCurrentEntry   - there is no entry at the current position
                                (before first, after last, entry was deleted)

 --*/

{
    LHT_ERR err;

    err = LhtpBKTDeleteEntry(
            ppos->plht,
            ppos );
    if ( err == LHT_errSuccess ) {
        LhtpSTATDeleteEntry( ppos->plht );

        LhtpMaintainTable(
            ppos->plht,
            ppos->iBucket );
    }

    return err;
}

VOID LhtQueryStatistics(
    IN      PLHT        plht,
    OUT     PLHT_STAT   pstat
    )

/*++

Routine Description:

    This routine queries a linear hash table for statistics regarding its
    operation.

Arguments:

    plht            - Supplies the context for the linear hash table
    pstat           - Returns statistics for the linear hash table

Return Value:

    None

 --*/

{
    memset( pstat, 0, sizeof( LHT_STAT ) );

    pstat->cEntry                   = plht->cEntry;
    pstat->cBucket                  = plht->cBucketMax + plht->cBucket;
    pstat->cBucketPreferred         = plht->cBucketPreferred;
#ifdef LHT_PERF
    pstat->cOverflowClusterAlloc    = plht->cOverflowClusterAlloc;
    pstat->cOverflowClusterFree     = plht->cOverflowClusterFree;
    pstat->cBucketSplit             = plht->cBucketSplit;
    pstat->cBucketMerge             = plht->cBucketMerge;
    pstat->cDirectorySplit          = plht->cDirectorySplit;
    pstat->cDirectoryMerge          = plht->cDirectoryMerge;
    pstat->cStateTransition         = plht->cStateTransition;
    pstat->cPolicySelection         = plht->cPolicySelection;
    pstat->cMemoryAllocation        = plht->cMemoryAllocation;
    pstat->cMemoryFree              = plht->cMemoryFree;
    pstat->cbMemoryAllocated        = plht->cbMemoryAllocated;
    pstat->cbMemoryFreed            = plht->cbMemoryFreed;
#endif  //  LHT_PERF
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\fpoclean.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       fpoclean.c
//
//--------------------------------------------------------------------------

/*++                                                     

Abstract:

    This module contains routines for implementing FPO cleanup. 

    When DS starting up, insert Foreign-Security Principal Object 
    Cleanup task into DSA task queue. Then DSA task queue will 
    schedule/Execute the Cleanup thread when we reach next iteration
    time.
       
    Two Cases:
    
    1. FPO Cleanup on G.C.
       
       1.1 Search NUMBER_OF_SEARCH_LIMIT Foreign-Security Principals
           object under the local domain NC.
       1.2 Get the object SID for each every FPO in the Search Result
           (FPO has the same SID with the original object which might 
            exist in the other domain, maybe NT4 or NT5)
       1.3 Search any Non-FPO with the same SID
       1.4 If no object found, then goto 1.2 until we reach the end of
           search result
       1.5 If we found exactly one Non-FPO which has the same SID as the
           FPO. We need to modify each every Group's membership, let them
           point to the newly found Non-FPO instead of the FPO. 
       1.6 Once we modify all the group memberships. Remove this FPO
       1.7 goto to 1.2 until the end.
       1.8 Insert FPO cleanup task into DSA task queue again. 
       
    2. FPO Cleanup on non G.C.
    
       2.1 FPO cleanup main thread create EVENT - FPO_CLEANUP_EVENT_NAME
       2.2 FPO cleanup main thread folds the worker thread
       2.3 FPO cleanup main thread waits until the worker thread set the 
           event - FPO_CLEANUP_EVENT_NAME.
       2.4 FPO cleanup main thread schedules the next FPO cleanup task 
           and returns immediately.

       3.1 The FPO cleanup worker thread searches NUMBER_OF_SEARCH_LIMIT 
           FPOs under the local domain NC.
       3.2 Once the worker thread gets the search result, set the event
           immediately, so that the main thread can continue. 
           NOTE: we just do a DirSearch which is a local operation. We are
           guaranteed to get the search result immediately, which means
           the FPO cleanup main thread will not been blocked.
       3.3 FPO cleanup worker thread locates the G.C., Pack FPOs together, 
           go off machine, let G.C. to verify these FPO, find Non FPOs for 
           them. 
       3.4 For each returned Non FPO, modify group membership as 1.5
       3.5 Delete FPOs as neccessary.
       3.6 FPO cleanup worker thread terminates. 
           
Author:

    Shaohua Yin    (shaoyin)   26-Mar-98

Revision History:

    26-Mar-98   ShaoYin Created 

    14-Apr-98   ShaoYin Added ScanCrossRefList()
                        to less unneccessary Non FPO Search.

    24-Mar-99  ShaoYin Extend FPO cleanup to Non G.C.                        


--*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <drs.h>                        // defines the drs wire interface
#include <drsuapi.h>                    // I_DRSVerifyNames
#include <gcverify.h>                   // FindDC, InvalidateGC
#include <prefix.h>

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"

// Filter and Attribute 
#include <filtypes.h>                   // header for filter type
#include <attids.h>                     // attribuet IDs 

#include <sddl.h>                       // ConvertSidToStringSidW

#include "debug.h"                      // standard debugging header
#define DEBSUB     "FPO:"               // define the subsystem for debugging


#include <fileno.h>                     // used for THAlloEx, but I did not 
#define  FILENO FILENO_FPOCLEAN         // use it in this module


#if DBG
#define SECONDS_UNTIL_NEXT_ITERATION  (60 * 60)  // one hour in seconds
#else
#define SECONDS_UNTIL_NEXT_ITERATION  (12 * 60 * 60) // 12 hours in seconds
#endif  // DBG

#if DBG
#define FPO_SEARCH_LIMIT      ((ULONG) 200)
#else
#define FPO_SEARCH_LIMIT      ((ULONG) 300)
#endif  // DBG

#define FPO_CLEANUP_EVENT_NAME      L"\\FPO_CLEANUP_EVENT"


typedef enum _FPO_CALLER_TYPE {
    FpoTaskQueue = 1,           // means the caller is from DSA task queue.
    FpoLdapControl              // 
} FPO_CALLER_TYPE;


typedef struct _FPO_THREAD_PARMS {
    FPO_CALLER_TYPE CallerType; 
    ULONG          SearchLimit; 
    HANDLE         EventHandle;
    PAGED_RESULT * pPagedResult; 
} FPO_THREAD_PARMS;



//
// Global variable -- used to hold the paged result, and restart next search
// 

PAGED_RESULT gFPOCleanupPagedResult;

//
// Reflect the number of active FPO Cleanup threads
// 
ULONG       gulFPOCleanupActiveThread = 0;

//
// Stop any FPO Cleanup thread
// 
BOOLEAN     gFPOCleanupStop = FALSE;





//////////////////////////////////////////////////////////////////
//                                                              //
//          Private routines.  Restricted to this file          //
//                                                              //
//////////////////////////////////////////////////////////////////


ULONG
FPOCleanupOnGC(
    IN PAGED_RESULT *pPagedResult,
    IN ULONG    SearchLimit
    );

void
FPOCleanupOnNonGC(
    IN PAGED_RESULT *pPagedResult,
    IN ULONG    SearchLimit
    );

ULONG                     
__stdcall
FPOCleanupOnNonGCWorker(
    IN FPO_THREAD_PARMS * pThreadParms
    );

ULONG
__stdcall
FPOCleanupControlWorker(
    PVOID StartupParms
    );

ULONG
GetNextFPO( 
    IN THSTATE *pTHS,
    IN PRESTART pRestart,
    IN ULONG    SearchLimit,
    OUT SEARCHRES ** ppSearchRes 
    );

ULONG
GetNextNonFPO( 
    IN PDSNAME   pDomainDN,
    IN PSID      pSid,
    OUT SEARCHRES **ppSearchRes
    );

ULONG
ModifyGroupMemberAttribute(
    IN PDSNAME pGroupDsName,
    IN PDSNAME pFpoDsName,
    IN PDSNAME pNonFpoDsName
    );

BOOLEAN
ScanCrossRefList(
    IN PSID    pSid,
    OUT PDSNAME * ppDomainDN  OPTIONAL
    );

BOOLEAN
FillVerifyReqArg(
    IN THSTATE * pTHS,
    IN SEARCHRES *FpoSearchRes, 
    OUT DRS_MSG_VERIFYREQ *VerifyReq, 
    OUT ENTINF **VerifyMemberOfAttr
    );

BOOLEAN
AmFSMORoleOwner(
    IN THSTATE * pTHS
    );


//////////////////////////////////////////////////////////////////
//                                                              //
//          Implemenations                                      // 
//                                                              //
//////////////////////////////////////////////////////////////////
    
//
//    FPO Cleanup Main Function
//

void
FPOCleanupMain(
    void *  pv, 
    void ** ppvNext, 
    DWORD * pcSecsUntilNextIteration
    )
/*++

Routine Description:

    This is the main funcion of FPO cleanup. It will be scheduled by 
    Task Scheduler when the time is out. After been executed, this
    routine will search Foreign-Security-Principal objects. For each 
    Foreign-Security-Principal objects, obtain its SID, accordin to 
    the SID, try to search any Non Foreign-Security-Principal object. 
    If that kind of object with the same SID exists, update any group
    object with hold the FPO in its member attribute. Replace the FPO
    with the Non PFO. If all updating successfully finished, then 
    remove this FPO. Same operation happened on every FPO.


Parameters:

    pv - NULL (no use), 

    ppvNext - NULL (no use).

Return Values:

    None.

--*/

{
    THSTATE     *pTHS = pTHStls;
    LONG        ActiveThread = 0;
    DWORD       err;
    BOOLEAN     fActiveThreadCountIncreased = FALSE;


    DPRINT(1,"DS: Foreign-Security-Principal Objects Cleanup Task Started\n");

    // This Thread is on behalf of DSA 

    pTHS->fDSA = TRUE;


    __try {

        // First, find out weather I'm FSMO role holder or not

        if (!AmFSMORoleOwner(pTHS))
        {
            // I am NOT FSMO role owner.
            __leave;
        }

        // Check whether there is any active FPO Cleanup thread
        ActiveThread = InterlockedIncrement(&gulFPOCleanupActiveThread);
        fActiveThreadCountIncreased = TRUE;

        if (ActiveThread > 1)
        {
            // Someone ahead of me is cleaning up FPO now.
            __leave;
        }
        Assert(ActiveThread == 1);

        if (gAnchor.fAmGC) 
        {
            //
            // This is an G.C.
            // 
            FPOCleanupOnGC((PAGED_RESULT *) &gFPOCleanupPagedResult,
                           FPO_SEARCH_LIMIT
                           ); 
        }
        else
        {
            //
            // Not a G.C.
            // 
            FPOCleanupOnNonGC((PAGED_RESULT *) &gFPOCleanupPagedResult, 
                              FPO_SEARCH_LIMIT
                              );
        }
    }
    __finally
    {

        if (fActiveThreadCountIncreased)
        {
            InterlockedDecrement(&gulFPOCleanupActiveThread);
        }

        *ppvNext = NULL;
        *pcSecsUntilNextIteration = SECONDS_UNTIL_NEXT_ITERATION;
    }

    return;
}


ULONG
FPOCleanupControl(
    IN OPARG *pOpArg, 
    IN OPRES *pOpRes
    )
/*++
Routine Description:

    This routine is called because our client made a request through
    LDAP explicitly. Our client can choose to start an FPO Cleanup 
    task or stop an running FPO Cleanup task. 
    
    For cleanup, this routine will create a worker thread to do the 
    job and return to client immediately.

    For stop, this routine will set the global variable and exit. 
    any running FPO cleanup thread will check the global variable 
    periodically, when the cleanup thread finds the global variable 
    has been set. Ihe cleanup thread will stop and exit. 
 
Parameters:

    pOpArg - pointer to OpArg 
    
    pOpRes -- pointer to OpRes
    
Return Values:

    0 -- Succeed
    
    Non Zero - Error

--*/
{
    THSTATE     *pTHS = pTHStls;
    HANDLE      ThreadHandle = INVALID_HANDLE_VALUE;
    ULONG       ulThreadId = 0;
    DWORD       DirErr = 0;


    //
    // N.B. No access check since not called by external callers
    //

    if ((NULL == pOpArg->pBuf) ||
        (sizeof(BOOLEAN) != pOpArg->cbBuf) )
    {
        // bad parameter
        DirErr = SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM, 
                    DIRERR_ILLEGAL_MOD_OPERATION);
        return DirErr;
    }

    if (FALSE == (BOOLEAN) *(pOpArg->pBuf))
    {
        //
        // Stop any FPO cleanup task
        // 
        gFPOCleanupStop = TRUE;
    }
    else
    {
        //
        // Initialize an FPO cleanup task
        // 
        gFPOCleanupStop = FALSE;
        ThreadHandle = (HANDLE) _beginthreadex(NULL,
                                               0,
                                               FPOCleanupControlWorker,
                                               NULL,
                                               0,
                                               &ulThreadId
                                               );
        if (!ThreadHandle)
        {
            DPRINT(0, "DS:FPO Failed to create Ldap Control Worker Thread\n");
            DirErr = SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, 
                                 ERROR_SERVICE_NO_THREAD);
        }

        // Close the thread handle immediately
        CloseHandle(ThreadHandle);
    }

    return DirErr;
}


ULONG
__stdcall
FPOCleanupControlWorker(
    PVOID StartupParms
    )
/*++
Routine Description:

    This routine is the worker routine to cleanup ALL FPOs in the local
    domain. It is only invoked by the LDAP control. Once started, it will
    search FPOs and cleanup them until it reaches the end of search.

    Periodically, it will check a global variable gFPOCleanupStop, if
    that variable has been set, we will stop any cleanup work and exit.
 
Parameters:

    StartupParms -- Ignored
    
Return Values:

    None

--*/
{
    THSTATE     *pTHS = NULL;
    FPO_THREAD_PARMS FpoThreadParms;
    PAGED_RESULT PagedResult; 
    BOOLEAN     fActiveThreadCountIncreased = FALSE;
    LONG        ActiveThread = 0;
    DWORD       err = 0;


    DPRINT(1,"DS: Foreign-Security-Principal Objects Cleanup LDAP Control Started\n");


    __try {

        // Increase active thread count 
        ActiveThread = InterlockedIncrement(&gulFPOCleanupActiveThread);
        fActiveThreadCountIncreased = TRUE;

        if (ActiveThread > 1)
        {
            // another FPO Cleanup thread is running
            __leave;
        }
        Assert(ActiveThread == 1);


        // initialize Thread State
        pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);

        if (NULL == pTHS)
        {
            err = serviceError;
            __leave;
        }
    
        // This thread is on behalf of DSA
        pTHS->fDSA = TRUE;

        //
        // initialize local variables
        // 
        memset(&PagedResult, 0, sizeof(PAGED_RESULT));
        memset(&FpoThreadParms, 0, sizeof(FPO_THREAD_PARMS));

        if (gAnchor.fAmGC)
        {
            do
            {
                err = FPOCleanupOnGC(&PagedResult, 
                                     FPO_SEARCH_LIMIT
                                     );

            } while ( (0 == err) &&
                      (!gFPOCleanupStop) && 
                      (PagedResult.fPresent) );
        }
        else
        {
            FpoThreadParms.CallerType = FpoLdapControl;
            FpoThreadParms.SearchLimit = FPO_SEARCH_LIMIT;
            FpoThreadParms.EventHandle = INVALID_HANDLE_VALUE;
            FpoThreadParms.pPagedResult = &PagedResult;

            do
            {
                err = FPOCleanupOnNonGCWorker(&FpoThreadParms);

            } while ( (0 == err) &&
                      (!gFPOCleanupStop) && 
                      (PagedResult.fPresent) );
        }
    }
    __finally
    {
        if (NULL != pTHS)
        {
            free_thread_state();
        }

        if (fActiveThreadCountIncreased)
        {
            InterlockedDecrement(&gulFPOCleanupActiveThread);
        }
    }

    return err; 
}


ULONG
FPOCleanupOnGC(
    IN PAGED_RESULT *pPagedResult,
    IN ULONG    SearchLimit
    )
/*++
Routine Description:

    This is routine will do the following:
        1. Search FPO in the local domain
        2. Try to find any couterpart of these FPOs
        3. If found one, then update the member attribute of the 
           group which FPOs are member of
        4. Delete the FPO

Arguments:

    pPagedResult -- Pointer to paged result structure
    
    SearchLimit -- Indicate the number of FPOs to search        

Return Value:

    0 -- succeed
    
    Non zero -- error. would be anything from dirErr.
--*/
{
    SEARCHRES    * FpoSearchRes = NULL;
    SEARCHRES    * NonFpoSearchRes = NULL;
    ENTINFLIST   * pEntInfList;
    PDSNAME      pFpoDsName = NULL; 
    ULONG        DirErr = 0;
    PVOID        pRestartTemp = NULL;
    PSID         pSid = NULL;
    PDSNAME      pDomainDN = NULL;
    THSTATE      *pTHS = pTHStls;


    DPRINT(1,"DS: FPO Cleanup On GC\n");


    //
    // Create a second heap, so that we can free them then this 
    // routine returns.
    // 

    TH_mark(pTHS);

    __try
    {

        //
        // Search Foreign Security Principals Object
        //

        DirErr = GetNextFPO(pTHS,
                            pPagedResult->fPresent ? pPagedResult->pRestart : NULL,
                            SearchLimit,
                            &FpoSearchRes
                            );

        if ( DirErr )
        {
            DPRINT1(0, "GetNextFPO Error: %d\n", DirErr);
            return DirErr;
        }

        // 
        // Handle the Paged_Results. We would like to begin next search 
        // from the end of this search, so we should keep the Paged-Result
        // in the process's heap instead of thread heap.
        // When there is no more memory available to keep the paged result, 
        // we will keep the old value and return immediately.
        //

        if ( FpoSearchRes->PagedResult.pRestart != NULL &&
             FpoSearchRes->PagedResult.fPresent )
        {
            pRestartTemp = malloc( FpoSearchRes->PagedResult.pRestart->structLen );
        
            if ( NULL != pRestartTemp)
            {
                memset(pRestartTemp, 
                       0, 
                       FpoSearchRes->PagedResult.pRestart->structLen
                       );

                memcpy(pRestartTemp, 
                       FpoSearchRes->PagedResult.pRestart, 
                       FpoSearchRes->PagedResult.pRestart->structLen
                       );

                if ( NULL != pPagedResult->pRestart ) 
                {
                    free( pPagedResult->pRestart );
                }
                memset(pPagedResult, 0, sizeof(PAGED_RESULT));
                pPagedResult->pRestart = pRestartTemp;
                pPagedResult->fPresent = TRUE;
                pRestartTemp = NULL;
            }
            else
            {
                // if can't allocate memory, most likely we are going to 
                // fail later, so just bail out.
                DirErr = SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, 
                                     ERROR_NOT_ENOUGH_MEMORY 
                                     );

                return DirErr;
            }
        }
        else
        {
            if ( NULL != pPagedResult->pRestart)
            {
                free( pPagedResult->pRestart );
            }
            memset(pPagedResult, 0, sizeof(PAGED_RESULT));
        }


        for ( pEntInfList = &FpoSearchRes->FirstEntInf;
              ((pEntInfList != NULL)&&(FpoSearchRes->count));
              pEntInfList = pEntInfList->pNextEntInf
            )
        {

            NonFpoSearchRes = NULL;
    
            // 
            // Get next Foreign-Security-Principal.
            //
            pFpoDsName = pEntInfList->Entinf.pName;
     
            //
            // Get the FPO's SID
            //

            if ( pFpoDsName->SidLen == 0 )
            {
                // This FPO doesn't have a Sid, skip this one.
                continue;
            }

            pSid = &pFpoDsName->Sid;
            Assert(NULL != pSid);

            // 
            // Check the gAnchor Cross Reference List First
            // if found the domain, continue whatever next. 
            // otherwise, skip this one, examine next FPO.
            //

            if ( !ScanCrossRefList(pSid, &pDomainDN) )
            {
                continue;
            }
            Assert(NULL != pDomainDN);


            //
            // Search Any Non FPO with the same Sid
            //

            DirErr = GetNextNonFPO(pDomainDN, pSid, &NonFpoSearchRes);

            if ( DirErr )
            {
                DPRINT1(0, "Main: Get NON FPO Dir Error: %d\n", DirErr);
                continue;
            }

            //
            // We only take care of the case of finding exactlly ONE Non FPO
            // In this case, modify any group object with in the FPO's
            // memberOf attribute, if all modifation successful, then remove
            // that FPO. 
            //
            // If zero or more than 1 Non-FPO was found, no-op. 
            //

            if (NonFpoSearchRes->count == 1)
            {

                PDSNAME     pNonFpoDsName = NULL;
                PDSNAME     pGroupDsName = NULL;
                BOOLEAN     HasMemberOf = FALSE; // whether the FPO has 
                                                 // memberOf attribute 
                BOOLEAN     Success = TRUE;      // assume update all group 
                                                 // objects successfully.
                BOOLEAN     TombStone = FALSE; 
                ULONG       j = 0;

                //
                // Get the pointer to that Non FPO
                //

                pNonFpoDsName = NonFpoSearchRes->FirstEntInf.Entinf.pName;

                //
                // If that Non FPO is a TombStone
                // then remove the FpoDsName.
                //
                // If the Non FPO has the ATT_IS_DELETED attribute, AND
                // the value is TRUE ==> This is a TombStone.
                // Otherwise we'll treat that Non FPO as a normal object.  
                //

                if ( NonFpoSearchRes->FirstEntInf.Entinf.AttrBlock.attrCount )
                {
                    Assert ( NonFpoSearchRes->FirstEntInf.Entinf.AttrBlock.
                             pAttr[0].attrTyp == ATT_IS_DELETED );

                    if ( *NonFpoSearchRes->FirstEntInf.Entinf.AttrBlock.
                         pAttr[0].AttrVal.pAVal[0].pVal == TRUE )
                    {
                        TombStone = TRUE;
                    }
                }

                //
                // Otherwise, not a TombStone. Then exam the memberOf
                // attribute.   
                //

                if ( (!TombStone) && pEntInfList->Entinf.AttrBlock.attrCount ) 
                {

                    Assert ( pEntInfList->Entinf.AttrBlock.pAttr[0].attrTyp
                            == ATT_IS_MEMBER_OF_DL );

                    HasMemberOf = TRUE; 

                    // 
                    // For each group in the FPO's memberOf attribute, 
                    // modify its membership. Use the Non FPO Dsname 
                    // replace the FPO DsName.
                    //

                    for (j = 0; 
                         j < pEntInfList->Entinf.AttrBlock.pAttr[0].
                                          AttrVal.valCount;
                         j ++)
                    {

                        pGroupDsName = (PDSNAME)pEntInfList->Entinf.
                                       AttrBlock.pAttr[0].AttrVal.pAVal[j].pVal;

                        if( ModifyGroupMemberAttribute(pGroupDsName, 
                                                       pFpoDsName, 
                                                       pNonFpoDsName
                                                       ) )
                        {
                            DPRINT(0, "DirModify: Failed\n");
                            Success = FALSE;
                        }

                    }   // end of all group membership list

                } // end of update memberlist attribute if that attr exists

                //
                // If the Non FPO is a TombStone, or 
                // we successfully modify all groups object (replace). or 
                // that FPO is no belonged to any group.
                // O.K. to Remove that FPO
                //  

                if ( (HasMemberOf && Success) || !HasMemberOf || TombStone )
                {
                    //
                    // Remove This FPO, since no Group contains that FPO
                    // right now.
                    //
                
                    REMOVEARG   RemoveArg;
                    REMOVERES   * RemoveRes = NULL;
                    COMMARG     * pRemCommArg = NULL;

                    memset( &RemoveArg, 0, sizeof(REMOVEARG) );
                    RemoveArg.pObject = pFpoDsName;
                    pRemCommArg = & (RemoveArg.CommArg);
                    InitCommarg ( pRemCommArg );

                    DPRINT(2, "Main: DirRemoveEntry Remove an FPO\n");

                    DirErr = DirRemoveEntry( &RemoveArg, &RemoveRes );

                    if ( DirErr )
                    {
                        DPRINT1(0, "Main: DirRemoveEntry Error: %d\n", DirErr);
                    }

                } // end of Remove FPO

            } // end of find exactly ONE Non FPO
        }  // end of one FPO cleanup. for loop
        
    } 
    __finally
    {

        //
        // free the second thread heap
        // 

        TH_free_to_mark(pTHS);
    }

    return 0;
}


void
FPOCleanupOnNonGC(
    IN PAGED_RESULT *pPagedResult,
    IN ULONG    SearchLimit
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DWORD       WaitStatus;
    HANDLE      EventHandle = INVALID_HANDLE_VALUE; 
    HANDLE      ThreadHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING  EventName;
    OBJECT_ATTRIBUTES   EventAttributes;
    ULONG       ulThreadId = 0;
    FPO_THREAD_PARMS    *pFpoThreadParms = NULL;


    DPRINT(1, "DS: FPO Cleanup on Non GC.\n");

    //
    // Allocate memory for the thread parameter
    //
    pFpoThreadParms = malloc(sizeof(FPO_THREAD_PARMS));
    if (NULL == pFpoThreadParms)
    {
        // no memory;
        return;
    }


    // 
    // Create an Event
    // 
    RtlInitUnicodeString(&EventName, FPO_CLEANUP_EVENT_NAME);
    InitializeObjectAttributes(&EventAttributes, &EventName, 0, 0, NULL);
    NtStatus = NtCreateEvent(&EventHandle, 
                             EVENT_ALL_ACCESS,
                             &EventAttributes, 
                             NotificationEvent,
                             FALSE  // The event is initially not signaled
                             );

    if (!NT_SUCCESS(NtStatus))
    {
        DPRINT(0, "Failed to create event\n");
        free(pFpoThreadParms);
        return;
    }

    memset(pFpoThreadParms, 0, sizeof(FPO_THREAD_PARMS));
    pFpoThreadParms->CallerType = FpoTaskQueue;
    pFpoThreadParms->SearchLimit = SearchLimit;
    pFpoThreadParms->EventHandle = EventHandle;
    pFpoThreadParms->pPagedResult = pPagedResult;

    //
    // start the work thread
    // 
    ThreadHandle = (HANDLE) _beginthreadex(NULL, 
                                  0, 
                                  FPOCleanupOnNonGCWorker, 
                                  (FPO_THREAD_PARMS *) pFpoThreadParms,
                                  0, 
                                  &ulThreadId
                                  );

    if (!ThreadHandle)
    {
        DPRINT(0, "Failed to create the worker thread\n");
        free(pFpoThreadParms);
        goto Cleanup;
    }

    // close the thread handle immediately
    CloseHandle(ThreadHandle);

    // wait until the worker thread copies the paged result to 
    // gFPOCleanupPagedResult. The worker thread will set the Event when done. 
    while (TRUE)
    {
        WaitStatus = WaitForSingleObject(EventHandle, 
                                         20 * 1000  // 20 seconds, INFINITE
                                         );

        if (WAIT_TIMEOUT == WaitStatus)
        {
            // time out, but event not signaled
            KdPrint(("FPOCleanupOnNonGC 20-secound timeout, (Rewaiting)\n"));
        }
        else if (WAIT_OBJECT_0 == WaitStatus)
        {
            // Event signaled.
            break;
        }       
        else 
        {
            KdPrint(("FPOCleanupOnNonGC WaitForSingleObject Failed with error %ld %ld\n", 
                     GetLastError(), 
                     WaitStatus ));
            break;
        }
    }

Cleanup:

    if (INVALID_HANDLE_VALUE != EventHandle)
    {
        // always close the Event Handle.
        NtClose(EventHandle);
    }

    return;
}
    


ULONG                     
__stdcall
FPOCleanupOnNonGCWorker(
    IN FPO_THREAD_PARMS * pThreadParms
    )
{
    THSTATE     *pTHS = NULL;
    FIND_DC_INFO *pGCInfo = NULL;
    SEARCHRES   * FpoSearchRes = NULL;
    ENTINFLIST  * pEntInfList = NULL;
    PDSNAME     pFpoDsName = NULL;
    PRESTART    pRestartTemp = NULL; 
    DRS_MSG_VERIFYREQ   VerifyReq;
    DRS_MSG_VERIFYREPLY VerifyReply;
    SCHEMA_PREFIX_TABLE * pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE hPrefixMap=NULL;
    ENTINF      * VerifyMemberOfAttr = NULL;
    ULONG       dwReplyVersion;
    ATTR        AttributeIsDeleted;
    ULONG       RetErr = 0;
    ULONG       Index = 0;
    BOOLEAN     IsEventSignaled = FALSE; 
    BOOLEAN     ThreadHeapMarked = FALSE; 

    
    DPRINT(1, "DS: FPO Cleanup on Non G.C. (worker routine)\n");

    Assert(NULL != pThreadParms);

    __try
    {
        // Initialize Thread State
        if (pThreadParms->CallerType == FpoTaskQueue)
        {
            InterlockedIncrement(&gulFPOCleanupActiveThread);

            pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);

            if (NULL == pTHS)
            {
                RetErr = serviceError;
                __leave;
            }
        }
        else
        {
            pTHS = pTHStls; 
        }

        //
        // Create the second thread heap, so that we can discard all 
        // of them when this worker routine returns.
        // 
        TH_mark(pTHS);
        ThreadHeapMarked = TRUE;
        
        // This thread is on behalf of DSA 
        pTHS->fDSA = TRUE;

        //
        // PREFIX: PREFIX complains that pTHS->CurrSchemaPtr may be NULL
        // at this point.  However, this code doesn't get run until the
        // DS is fully up and running.  The schema pointer will not be 
        // NULL once the DS is up and running.
        //
        Assert(pTHS->CurrSchemaPtr);

        // Search any Foreign-Security-Principal Objects 
        RetErr = GetNextFPO(pTHS, 
                            pThreadParms->pPagedResult->fPresent ? pThreadParms->pPagedResult->pRestart:NULL, 
                            pThreadParms->SearchLimit,
                            &FpoSearchRes
                            );

        if (RetErr)
        {
            DPRINT1(0, "FPO Cleanup on NonGC: GetNextFPO Error==> %ld\n", RetErr);
            __leave;
        }

        //
        // Handle the Paged Results. 
        // 
        
        if (FpoSearchRes->PagedResult.pRestart != NULL &&
            FpoSearchRes->PagedResult.fPresent )
        {
            pRestartTemp = malloc(FpoSearchRes->PagedResult.pRestart->structLen);
            
            if (NULL != pRestartTemp)
            {
                memset(pRestartTemp, 
                       0, 
                       FpoSearchRes->PagedResult.pRestart->structLen
                       );

                memcpy(pRestartTemp, 
                       FpoSearchRes->PagedResult.pRestart,
                       FpoSearchRes->PagedResult.pRestart->structLen
                       );

                if (NULL != pThreadParms->pPagedResult->pRestart)
                {
                    free(pThreadParms->pPagedResult->pRestart);
                }
                memset(pThreadParms->pPagedResult, 0, sizeof(PAGED_RESULT));
                pThreadParms->pPagedResult->pRestart = pRestartTemp;
                pThreadParms->pPagedResult->fPresent = TRUE;
                pRestartTemp = NULL;
            }
            else
            {
                // if can't allocate memory, most likely we are going to 
                // fail later, so just bail out.
                RetErr = SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, 
                                     ERROR_NOT_ENOUGH_MEMORY 
                                     );

                __leave;
            }
        }
        else
        {
            if (NULL != pThreadParms->pPagedResult->pRestart)
            {
                free(pThreadParms->pPagedResult->pRestart);
            }
            memset(pThreadParms->pPagedResult, 0, sizeof(PAGED_RESULT));
        }

        // 
        // Set the Event as soon as the worker thread copies the paged result
        // to the global variable -- gFPOCleanupPagedResult
        // Since all above operations are local calls, so it should be fast.
        // 
        // 1. Only do so if the caller is TaskQueue
        // 
        // 2. If the caller is Ldap Control, there is no thread waiting for 
        //    us, do not singal event
        // 
        if (pThreadParms->CallerType == FpoTaskQueue)
        {
            Assert(INVALID_HANDLE_VALUE != (HANDLE) pThreadParms->EventHandle);
            SetEvent((HANDLE) pThreadParms->EventHandle);                
            IsEventSignaled = TRUE;
        }


        //
        // For each every Foreign-Security-Principal object, 
        // try to find the Naming Context head that is the 
        // authoritative domain for the SID, if we find the 
        // naming context head, then build a list of FPO which
        // sent to GC for reference.
        // 

        pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

        // 
        // Construct DRSVerifyNames arguments.
        // 
        memset(&VerifyReq, 0, sizeof(VerifyReq));
        memset(&VerifyReply, 0, sizeof(VerifyReply));

        VerifyReq.V1.dwFlags = DRS_VERIFY_FPOS;     // DRS_VERIFY_SIDS;

        VerifyReq.V1.PrefixTable = *pLocalPrefixTable;

        VerifyReq.V1.RequiredAttrs.attrCount = 1;
        VerifyReq.V1.RequiredAttrs.pAttr = &AttributeIsDeleted;
        AttributeIsDeleted.attrTyp = ATT_IS_DELETED;
        AttributeIsDeleted.AttrVal.valCount = 0;
        AttributeIsDeleted.AttrVal.pAVal = NULL;

        //
        // if FillVerifyReqArg() succeed, VerifyReq will contain 
        // these FPO's SID which needs to be verified.
        // VerifyMemberOfAttr is used to hold the memberOf attribute
        // of these FPOs.
        // For example: VerifyMemberOfAttr[i] will contain the 
        // value of memberOf attribute for FPO in VerifyReq.V1.rpNames[i]
        // 

        if (FALSE == FillVerifyReqArg(pTHS, 
                                      FpoSearchRes, 
                                      &VerifyReq, 
                                      &VerifyMemberOfAttr))
        {
            //
            // low memory is the only cause
            // 
            DPRINT(0, "FPOCleanup on NonGC: Failed to build VerifyReqArg\n");
            RetErr = SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, 
                                 ERROR_NOT_ENOUGH_MEMORY 
                                 );

            __leave;
        }

        DPRINT1(2, "Verify Request is %d Entries\n", VerifyReq.V1.cNames);

        if (0 == VerifyReq.V1.cNames)
        {
            // if no FPO should be verified, then return immediately.
            RetErr = 0;
            __leave;
        }

        //
        // Present these FPOs to GC, let GC verify them
        // 
        RetErr = I_DRSVerifyNamesFindGC(pTHS, 
                                        NULL,
                                        NULL,
                                        1,                // dwInVersion
                                        &VerifyReq,
                                        &dwReplyVersion, 
                                        &VerifyReply,
                                        FIND_DC_USE_CACHED_FAILURES);

        if (RetErr || VerifyReply.V1.error)
        {
            DPRINT2(0, "FPO Cleanup on Non G.C.: I_DRSVerifyNames Error==> %d %d\n", 
                    RetErr, VerifyReply.V1.error);

            __leave;
        }


        //
        // For each returned DS name, use the DS object name 
        // replace the FPO in the group membership.
        // 
        for (Index = 0; Index < VerifyReply.V1.cNames; Index++)
        {
            ENTINF * pEntInf = NULL;
            BOOLEAN  TombStone = FALSE;
            BOOLEAN  HasMemberOf = FALSE;
            BOOLEAN  Success = TRUE;

            pEntInf = &(VerifyReply.V1.rpEntInf[Index]);

            //
            // Did not find the object from G.C.
            // 
            if (NULL == pEntInf->pName)
            {
                continue;
            }


            if (pEntInf->AttrBlock.attrCount)
            {
                Assert(ATT_IS_DELETED == pEntInf->AttrBlock.pAttr[0].attrTyp);

                if (TRUE == *pEntInf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal)
                {
                    // This object (found from G.C.) has been deleted already.
                    TombStone = TRUE;
                }
            }

            //
            // Update All groups' (contain this FPO) membership
            // 
            if ( (!TombStone) && VerifyMemberOfAttr[Index].AttrBlock.attrCount)
            {
                ULONG   i;

                Assert(ATT_IS_MEMBER_OF_DL ==
                       VerifyMemberOfAttr[Index].AttrBlock.pAttr[0].attrTyp);

                HasMemberOf = TRUE;

                for (i = 0; 
                     i < VerifyMemberOfAttr[Index].AttrBlock.pAttr[0].AttrVal.valCount;
                     i++)
                {
                    DSNAME  * pGroupDsName;

                    //
                    // Update G.C. Verify Cache.
                    // We have to execute GCVerifyCacheAdd in the for() loop.
                    // Because each time after one Dir* operation, DS will
                    // NULL the GV Verify Cache associated with the thread state
                    // 
                    GCVerifyCacheAdd(hPrefixMap, pEntInf);

                    //
                    // find each group the FPO belongs to
                    // 
                    pGroupDsName = (PDSNAME)VerifyMemberOfAttr[Index].AttrBlock.
                                   pAttr[0].AttrVal.pAVal[i].pVal;

                    // update
                    if ( ModifyGroupMemberAttribute(pGroupDsName, 
                                                    VerifyMemberOfAttr[Index].pName, 
                                                    pEntInf->pName)
                        )
                    {
                        DPRINT(0, "FPO Cleanup on non GC: DirModidy Failed\n");
                        Success = FALSE;
                    }

                }
            }

            //
            // if the Non FPO is a TombStone 
            // OR we successfully modify all groups' membership 
            // OR this FPO does not belong to any group.
            // 
            // ==> O.K. to remove this FPO
            // 

            if ( (HasMemberOf && Success) || !HasMemberOf || TombStone)
            {
                //
                // Remove this Foreign-Security-Principal Object
                // 
                REMOVEARG   RemoveArg;
                REMOVERES   * RemoveRes = NULL;

                memset(&RemoveArg, 0, sizeof(REMOVEARG));
                RemoveArg.pObject = VerifyMemberOfAttr[Index].pName;
                InitCommarg( &(RemoveArg.CommArg) );

                DPRINT1(1, "FPO Cleanup on non GC: Remove an FPO %ls\n", (pEntInf->pName)->StringName);

                RetErr = DirRemoveEntry(&RemoveArg, &RemoveRes);

                if (RetErr)
                {
                    DPRINT1(0, "FPO Cleanup on non GC: Remove FPO failed ==> %d\n", RetErr);
                }

            }

        }

        if (NULL != hPrefixMap)
        {
            PrefixMapCloseHandle(&hPrefixMap);
        }
    }
    __finally
    {
        //
        // Discard the second thread heap
        // 
        if (ThreadHeapMarked)
        {
            TH_free_to_mark(pTHS);
        }


        //
        // 1. if the caller is TaskQueue, do cleanup work
        //
        // 2. if the caller is Ldap Control, nothing to do. 
        // 
        if (FpoTaskQueue == pThreadParms->CallerType)
        {
            if (!IsEventSignaled)
            {
                // Be Sure to Set the Event, otherwise the Parent Thread will 
                // wait for us forever.
                Assert(INVALID_HANDLE_VALUE != (HANDLE) pThreadParms->EventHandle);
                SetEvent((HANDLE) pThreadParms->EventHandle);
            }

            if (NULL != pTHS)
            {
                // Always releave the thread state is necessary.
                free_thread_state();
            }

            //
            // Free the Thread Parameters 
            // 
            free(pThreadParms);

            InterlockedDecrement(&gulFPOCleanupActiveThread);
        }
    }
    
    return (RetErr);
}







ULONG
GetNextFPO( 
    IN THSTATE   *pTHS,
    IN PRESTART  pRestart,
    IN ULONG     SearchLimit,
    OUT SEARCHRES ** ppSearchRes 
    )
/*++

Routine Description:

    This funtion implements Search Foreign-Security-Principal Object.
    Given the last Paged-Result, pointed by pv, this routine searches
    next NUMBER_OF_SEARCH_LIMIT FPO.

Parameters:

    pTHS - pointer to thread state

    pRestart - pointer to Paged Results, or NULL, 
               NULL means this is the first call, or search from beginning.

    SearchLimit - Number of FPO to search               

    ppSearchRes - used to reture the Search Results.

Return Values:

    DirError Code: 

        0 means success.
        !0 Error 
--*/
{

    SEARCHARG    SearchArg;
    COMMARG      * pCommArg = NULL;
    FILTER       ObjCategoryFilter;
    ATTR         AttributeMemberOf;
    ENTINFSEL    EntInfSel;
    ULONG        DirErr = 0;
    ULONG        ObjectClassId = CLASS_FOREIGN_SECURITY_PRINCIPAL;
    CLASSCACHE   * pCC = NULL;

    //
    // Get FPO Class Category from Class Cache
    //

    pCC = SCGetClassById(pTHS, ObjectClassId);

    if ( pCC == NULL ) {
        Assert(FALSE && "SCGetClassById should always succeed!!");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Setup the Object Class Filter
    //
    memset( &ObjCategoryFilter, 0, sizeof( ObjCategoryFilter ));
    ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
    ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = 
                   ((PDSNAME)(pCC->pDefaultObjCategory))->structLen;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = 
                   (BYTE*)(pCC->pDefaultObjCategory);

    //
    // Setup the Attribuet Select parameter
    // only retrieve memberOf attribute
    //
    AttributeMemberOf.attrTyp = ATT_IS_MEMBER_OF_DL;
    AttributeMemberOf.AttrVal.valCount = 0;
    AttributeMemberOf.AttrVal.pAVal = NULL;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &AttributeMemberOf;

    //
    // Build the SearchArg Structure
    // use default, search One NC, since the Foreign-Security-Principal
    // is NC depended.  
    //
    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = gAnchor.pDomainDN;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC = TRUE;
    SearchArg.pFilter = &ObjCategoryFilter;
    SearchArg.searchAliases = FALSE;   // Always FALSE for this release
    SearchArg.pSelection = &EntInfSel;
    SearchArg.pSelectionRange = NULL;

    //
    // Build the CommArg structure
    //

    pCommArg = &(SearchArg.CommArg);
    InitCommarg(pCommArg);
    pCommArg->PagedResult.fPresent = TRUE;
    // pRestart might be NULL, that's fine
    pCommArg->PagedResult.pRestart = pRestart;
    pCommArg->ulSizeLimit = SearchLimit;


    // 
    // Call DirSearch 
    //

    DirErr = DirSearch(&SearchArg, ppSearchRes);

    DPRINT1(2, "GetNextFPO DirErr==> %ld. \n", DirErr); 


    return (DirErr);
}



ULONG
GetNextNonFPO( 
    IN PDSNAME   pDomainDN,
    IN PSID      pSid,
    OUT SEARCHRES **ppSearchRes
    )
/*++

Routine Description:

    This funtion implements Search Any Non Foreign-Security-Principal 
    Object which has the same Sid as provided by pSid.

Parameters:

    pDomainDN - pointer to the Name of the Domain to execute the Search
    
    pSid - pointer to a Sid. 

    ppSearchRes - used to reture the Search Results.
                  It will hold any Non Foreign-Security-Principal 
                  Object with the same SID.

Return Values:

    DirError Code: 

        0 means success.
        Other values: Error 
--*/

{

    SEARCHARG    SearchArg;
    COMMARG      * pCommArg;
    FILTER       SidFilter;
    FILTER       FpoFilter;
    FILTER       AndFilter;
    FILTER       NotFilter;
    ATTR         AttributeIsDeleted;
    ENTINFSEL    EntInfSel;    
    ULONG        ObjectClass = CLASS_FOREIGN_SECURITY_PRINCIPAL;
    ULONG        DirErr = 0;


    Assert( pSid );
    Assert( pDomainDN );
     
    //
    // Build the Select Structure, 
    // only want to retrieve the isDeleted attribute
    // of the object.
    //

    AttributeIsDeleted.attrTyp = ATT_IS_DELETED;
    AttributeIsDeleted.AttrVal.valCount = 0;
    AttributeIsDeleted.AttrVal.pAVal = NULL;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &AttributeIsDeleted;
    
    //
    // Build the Filter, the Filter has the following structure:
    // We should use this structure because of the intention return
    // from MutliValue Attribute comparation. Ask for DonH for 
    // detailed reason.
    //
    // AND Set
    // -----------
    // | 2 items |----> First Item  --------------> Not Set(1 item)
    // |         |     ------------------------          |
    // -----------     | Object's Sid == pSid |          |
    //                 ------------------------          V 
    //                                            -------------
    //                                            |  NOT FPO  |
    //                                            -------------
    //
    //         

    memset( &SidFilter, 0, sizeof(SidFilter) );
    SidFilter.choice = FILTER_CHOICE_ITEM;
    SidFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    SidFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_SID;
    SidFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = RtlLengthSid(pSid);
    SidFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pSid; 

    memset( &FpoFilter, 0, sizeof(FILTER) );
    FpoFilter.choice = FILTER_CHOICE_ITEM;
    FpoFilter.pNextFilter = NULL;
    FpoFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FpoFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    FpoFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    FpoFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) &ObjectClass;

    memset( &NotFilter, 0, sizeof(FILTER) );
    NotFilter.choice = FILTER_CHOICE_NOT;
    NotFilter.FilterTypes.pNot = &FpoFilter;

    memset( &AndFilter, 0, sizeof(FILTER) );
    AndFilter.choice = FILTER_CHOICE_AND;
    AndFilter.pNextFilter = NULL;
    AndFilter.FilterTypes.And.count = 2;
    AndFilter.FilterTypes.And.pFirstFilter = &SidFilter;
    SidFilter.pNextFilter = &NotFilter;

    //
    // Build the search arguement.
    // All use defaults, except makeDeletionsAvail 
    // since we are willing to search any TombStone object.
    //
    //

    memset( &SearchArg, 0, sizeof(SEARCHARG) );
    SearchArg.pObject = pDomainDN;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter = &AndFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &EntInfSel;
    SearchArg.pSelectionRange = NULL;

    pCommArg = &(SearchArg.CommArg);
    InitCommarg(pCommArg);
    pCommArg->Svccntl.makeDeletionsAvail = TRUE;

    DirErr = DirSearch(&SearchArg, ppSearchRes);

    DPRINT1(2, "GetNextNonFPO DirErr==> %ld \n", DirErr);


    return ( DirErr );

}


ULONG
ModifyGroupMemberAttribute(
    IN PDSNAME pGroupDsName,
    IN PDSNAME pFpoDsName,
    IN PDSNAME pNonFpoDsName
    )
/*++

Routine Description:

    This routine implements Modification of Local Group's Member
    Attribute. Given a group's DsName, we will delete pFpoDsName
    from the group object's member attribute and add pNonFpoDsName.
    In one DirModifyEntry call, we do two things: First REMOVE_VALUE, 
    second ADD_VALUE.

Parameters:

    pGroupDsName - the target group Ds Name.

    pFpoDsName - this is the member to be replaced. We will try to 
                 find this object in the Group's member attribute first, 
                 if not find it, routine will not modify group.

    pNonFpoDsName - this is the member to be added into the group object's
                    member attribute.

Return Values:

    DirError Code: 

        0 means success.

        Other values: Error 

--*/

{

    COMMARG     * pModCommArg = NULL;
    MODIFYARG   ModifyArg;
    MODIFYRES   * ModifyRes = NULL; 
    ATTRMODLIST SecondMod;
    ATTRVAL     FpoAttrVal;
    ATTRVAL     NonFpoAttrVal;
    ULONG       DirErr = 0;

    DPRINT1(2, "Group DsName %ls\n", pGroupDsName->StringName);
    DPRINT1(2, "FPO DsName %ls\n", pFpoDsName->StringName);
    DPRINT1(2, "NonFPO DsName %ls\n", pNonFpoDsName->StringName);

    // 
    // Build the Second Modification List
    // contains the object to be added. 
    // This the Non Fpo Object. 
    //

    NonFpoAttrVal.valLen = pNonFpoDsName->structLen;
    NonFpoAttrVal.pVal = (BYTE*) pNonFpoDsName;

    memset( &SecondMod, 0, sizeof(ATTRMODLIST) );
    SecondMod.pNextMod = NULL;
    SecondMod.choice = AT_CHOICE_ADD_VALUES;
    SecondMod.AttrInf.attrTyp = ATT_MEMBER;
    SecondMod.AttrInf.AttrVal.valCount = 1;
    SecondMod.AttrInf.AttrVal.pAVal = &NonFpoAttrVal;

    //
    // Build the ModifyArg, FirstMod contains the 
    // Object to be removed. (Fpo)
    //

    FpoAttrVal.valLen = pFpoDsName->structLen;
    FpoAttrVal.pVal = (BYTE*) pFpoDsName;
    
    memset( &ModifyArg, 0, sizeof(MODIFYARG) );
    ModifyArg.pObject = pGroupDsName;
    ModifyArg.count = 2;
    ModifyArg.FirstMod.pNextMod = &SecondMod;
    ModifyArg.FirstMod.choice = AT_CHOICE_REMOVE_VALUES;
    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_MEMBER;
    ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &FpoAttrVal;

    pModCommArg = &(ModifyArg.CommArg);
    InitCommarg(pModCommArg);

    DirErr = DirModifyEntry (&ModifyArg, &ModifyRes);
    
    DPRINT1(2, "Modify: After DirModify, Dir Error: %d\n", DirErr);

    return( DirErr );

}


BOOLEAN
ScanCrossRefList(
    IN PSID    pSid,
    OUT PDSNAME * ppDomainDN  OPTIONAL
    )
/*++
 
  Routine Description

    Given a SID, this routine extracts the Domain Sid from the passed
    value, then walks the gAnchor's Cross Reference List to compare the 
    Domain Sid with the Nameing Context's Sid. Return the boolean result.

  Parameters:
    
    pSid -- The Sid to be compared.

    ppDomainDN - Hold the Domain Name to execute the Non FPO Search. 

  Return Values:

    TRUE -- The Domain Sid is equal to one in the Cross Reference List.
    FALSE -- The Domain Sid is not equal to none of in the Cross Ref. List.

--*/
{
    BOOLEAN Found = FALSE;
    CROSS_REF_LIST * pCRL;

    Assert( pSid != NULL ); 
    Assert( (*RtlSubAuthorityCountSid(pSid)) >= 1 );
    
    (*RtlSubAuthorityCountSid(pSid))--;

    //
    // Walk through the gAnchor structure
    //
    
    for (pCRL = gAnchor.pCRL;
         pCRL != NULL;
         pCRL = pCRL->pNextCR)
    {

        //
        // FPO cleanup cleans up FPO's that represent security principals
        // in other domains in the same forest. Therefore consider only
        // Cross Ref objects that represent other domains in the same forest
        // FLAG_CR_NTDS_DOMAIN indicates that the cross ref represents
        // and NT domain, and FLAG_CR_NTDS_NC represents a naming context 
        // in the same forest. For a domain in the same forest both flags 
        // must be set
        //

        if ((pCRL->CR.pNC->SidLen > 0) && 
            (pCRL->CR.flags & FLAG_CR_NTDS_NC ) && 
            (pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN))
        {
            if ( RtlEqualSid(pSid, &(pCRL->CR.pNC->Sid)) )
            {
                Found = TRUE;

                if (ARGUMENT_PRESENT(ppDomainDN))
                {
                    *ppDomainDN = pCRL->CR.pNC;
                }

                break;
            }
        }
    }

    (*RtlSubAuthorityCountSid(pSid))++;

    return( Found );

}


BOOLEAN
AmFSMORoleOwner(
    IN THSTATE * pTHS
    )
{
    BOOLEAN result = FALSE;
    DSNAME  *pTempDN = NULL;
    DWORD   outSize = 0;
    
    Assert(!pTHS->pDB);
    DBOpen(&pTHS->pDB);

    __try {

        if ((DBFindDSName(pTHS->pDB, gAnchor.pDomainDN)) ||
            (DBGetAttVal(pTHS->pDB, 
                         1, 
                         ATT_FSMO_ROLE_OWNER, 
                         DBGETATTVAL_fREALLOC | DBGETATTVAL_fSHORTNAME,
                         0, 
                         &outSize, 
                         (PUCHAR *) &pTempDN)))
        {
            // Can't verify who the FSMO role owner is
            DPRINT(0, "DS:FPO Failed to verify who the FSMO role owner is.\n");
            __leave;
        }

        if (NameMatched(pTempDN, gAnchor.pDSADN))
        {
            // I am the FSMO role holder, set the return value 
            result = TRUE;
        }
    }
    __finally
    {
        if (NULL != pTempDN)
        {
            THFreeEx(pTHS, pTempDN);
        }

        DBClose(pTHS->pDB, TRUE);   // always do a commit because this is a read
        Assert(NULL == pTHS->pDB);
    }

    return (result);
}




BOOLEAN
FillVerifyReqArg(
    IN THSTATE * pTHS,
    IN SEARCHRES *FpoSearchRes, 
    OUT DRS_MSG_VERIFYREQ *VerifyReq, 
    OUT ENTINF **VerifyMemberOfAttr
    )
/*++
Routine Description:

Parameters:

    pTHS - point to thread state
    
    FpoSearchRes -- Search Result contains FPOs 

    VerifyReq -- pointer to verify request argument. if routine succeed, 
                 it will contain those FPOs' SID which needs to go off 
                 machine to G.C. for verification.
                 
    VerifyMemberOfAttr -- For each every FPO needs to verify, VerifyMemberOfAttr
                  is used to point to its memberOf attribute.
                  For example: (*VerifyMemberOfAttr)[i] will contains the value
                  of memberOf attribute for FPO in VerifyReq.V1.rpNames[i].

Return Values:

    TREU -- Succeed.
    FALSE -- Routine Failed.

--*/
{
    ULONG       TotalFpoCount, Index = 0; 
    ENTINFLIST  * pEntInfList = NULL;
    DSNAME      * pFpoDsName = NULL;
    PSID        pSid = NULL;


    if (0 == FpoSearchRes->count)
    {
        return TRUE;
    }

    TotalFpoCount = FpoSearchRes->count;
    VerifyReq->V1.cNames = 0;

    VerifyReq->V1.rpNames = (DSNAME **) THAllocEx(pTHS, TotalFpoCount * sizeof(DSNAME *)); 
    *VerifyMemberOfAttr = (ENTINF *) THAllocEx(pTHS, TotalFpoCount * sizeof(ENTINF));
    if (NULL == *VerifyMemberOfAttr || NULL == VerifyReq->V1.rpNames)
    {
        return FALSE;
    }


    for ( pEntInfList = &(FpoSearchRes->FirstEntInf);
          ((pEntInfList != NULL)&&(FpoSearchRes->count));
          pEntInfList = pEntInfList->pNextEntInf
        )
    {
        // 
        // Get next Foreign-Security-Principal.
        //
    
        pFpoDsName = pEntInfList->Entinf.pName;
         
        //
        // Get the FPO's SID
        //
    
        if ( pFpoDsName->SidLen == 0 )
        {
           // This FPO doesn't have a Sid, skip this one.
           continue;
        }
    
        pSid = &pFpoDsName->Sid;
        Assert(NULL != pSid);
    
        // 
        // Check the gAnchor Cross Reference List First
        // if found the domain, continue whatever next. 
        // otherwise, skip this one, examine next FPO.
        //
    
        if ( !ScanCrossRefList(pSid, NULL) )
        {
            continue;
        }

        VerifyReq->V1.rpNames[Index] = (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(0));
        if (NULL == VerifyReq->V1.rpNames[Index])
        {
            return FALSE;
        }

        VerifyReq->V1.rpNames[Index]->structLen = DSNameSizeFromLen(0);
        VerifyReq->V1.rpNames[Index]->SidLen = pFpoDsName->SidLen;
        memcpy(&(VerifyReq->V1.rpNames[Index]->Sid), 
               pSid, 
               pFpoDsName->SidLen
               );

        (*VerifyMemberOfAttr)[Index] = pEntInfList->Entinf; 
        
        // assert the Attribute is indeed MemberOf Attr

#if DBG
        if (pEntInfList->Entinf.AttrBlock.attrCount)
        {
            Assert(ATT_IS_MEMBER_OF_DL ==
                   pEntInfList->Entinf.AttrBlock.pAttr[0].attrTyp);
        }
#endif // DBG

        Index++;
        VerifyReq->V1.cNames++;
    }


    return TRUE;
}



/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*  GetDacl and GetSacl are small wrappers for GetSecurityDescriptor?acl      */
/*----------------------------------------------------------------------------*/
PACL GetDacl(
    IN PSECURITY_DESCRIPTOR Sd
    ) 
{

    BOOL     Status;
    PACL     Dacl = NULL;
    PACL     DaclToReturn = NULL;
    BOOL     DaclPresent;
    BOOL     DaclDefaulted;

    Status = GetSecurityDescriptorDacl(
                    Sd,
                    &DaclPresent,
                    &Dacl,
                    &DaclDefaulted
                    );
    if ((Status)
        && DaclPresent
        && !DaclDefaulted) {
        DaclToReturn = Dacl;
    }

    return DaclToReturn;

}

PACL GetSacl(
    IN PSECURITY_DESCRIPTOR Sd
    ) 
{
    BOOL     Status;
    PACL     Sacl = NULL;
    PACL     SaclToReturn = NULL;
    BOOL     SaclPresent;
    BOOL     SaclDefaulted;

    Status = GetSecurityDescriptorSacl(
                    Sd,
                    &SaclPresent,
                    &Sacl,
                    &SaclDefaulted
                    );
    if ((Status)
        && SaclPresent
        && !SaclDefaulted) {
        SaclToReturn = Sacl;
    }

    return SaclToReturn;

}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*  This routine creates the default security descriptor for FPO's.  Since    */
/*  FPO's are created as fDSA we need to make sure the owner is not set the   */
/*  to the caller that indirectly initiated the creation of the FPO. The      */
/*  owner is set to Builtin\Administrators as this was the owner in the win2k */
/*  release when FPO's were introduced.                                       */
/*                                                                            */
/*  pTHS -- in, thread state                                                  */
/*  valLen -- out, the length of self-relative SD that is returned            */
/*  pVal   -- out, the self-relative SD for the FPO (allocated via THAlloc    */
/*                                                                            */
/*  Returns only unexpected or resource errors (or success)                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/
DWORD
fpoConstructSd(THSTATE *pTHS,  /* in */
               ULONG  *valLen, /* out */
               PUCHAR *pVal)   /* out */
{
    ULONG err = 0;
    NTSTATUS ntStatus;
    ULONG len;
    PUCHAR val;  
    ULONG Buffer[SECURITY_MAX_SID_SIZE/sizeof( ULONG ) + 1 ];
    PSID AdminsSid = (PSID)Buffer;
    SECURITY_DESCRIPTOR SdAbsolute;
    PSECURITY_DESCRIPTOR DefaultSecurityDescriptor = NULL;
    CLASSCACHE  *pCC;

    // make the Administrators sid
    len = sizeof(Buffer);
    if (!CreateWellKnownSid(WinAccountDomainAdminsSid,
                            (PSID)&gAnchor.pDomainDN->Sid,
                            AdminsSid,
                            &len)) {

        err = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                            ERROR_DS_UNKNOWN_ERROR, 
                            GetLastError());
        goto exit;
    }

    // get the default security descriptor
    pCC = SCGetClassById(pTHS, CLASS_FOREIGN_SECURITY_PRINCIPAL);
    Assert(NULL != pCC);
    DefaultSecurityDescriptor = (PSECURITY_DESCRIPTOR) pCC->pSD;

    if (InitializeSecurityDescriptor(&SdAbsolute,SECURITY_DESCRIPTOR_REVISION)
     && SetSecurityDescriptorOwner(&SdAbsolute,AdminsSid,FALSE)
     && SetSecurityDescriptorGroup(&SdAbsolute,AdminsSid,FALSE)
     && SetSecurityDescriptorDacl(&SdAbsolute,TRUE,GetDacl(DefaultSecurityDescriptor),FALSE) 
     && SetSecurityDescriptorSacl(&SdAbsolute,TRUE,GetSacl(DefaultSecurityDescriptor),FALSE) ) {

        // get the buffer length first
        *valLen = 0;
        MakeSelfRelativeSD(&SdAbsolute,*pVal,valLen);
        Assert(*valLen);

        *pVal = THAllocEx(pTHS, *valLen);
        if (!MakeSelfRelativeSD(&SdAbsolute,*pVal,valLen)) {
            THFreeEx(pTHS, *pVal);
            *pVal = NULL;
            *valLen = 0;
            err = GetLastError();
        }
        else {
            Assert(RtlLengthSecurityDescriptor((PSECURITY_DESCRIPTOR)*pVal) == *valLen);
        }
    } else {
        err = GetLastError();
    }
    if (err) {
        err = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                            ERROR_DS_UNKNOWN_ERROR, 
                            GetLastError());
        goto exit;
    }

exit:

    return err;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* This routine creates the distinguished name for an FPO object given a SID. */
/* Note that it first reads the location of the wellknown                     */ 
/* "ForiegnSecurityPrincipal" container.  This will not exist in upgraded     */
/* win2k domains and since the wellKnownObject attributes is systemonly in    */
/* win2k, we have to live with this.  So, in this case, hard code the         */
/* container to be CN=ForeignSecurityPrincipals,<domainDN>.                   */
/*                                                                            */
/* pTHS -- in, the thread state                                               */
/* NCDNT -- the NC the object being modified                                  */
/* pSid -- in, the sid of the FPO                                             */
/* dsName -- out, the dsname of the new FPO object                            */
/* parent -- the parent DN of dsName                                          */
/*                                                                            */
/* Returns unexpected or resource errors, or success                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/
DWORD
fpoConstructDn(THSTATE *pTHS,     /* in */
               ULONG    NCDNT,    /* in */
               PSID     pSid,     /* in */
               DSNAME** dsName,   /* out */
               DSNAME** parent)   /* out */
{

    ULONG err = 0;
    ULONG DNT = 0;
    DBPOS *pDB=NULL;
    BOOL  fCommit = FALSE;
    DSNAME *fpoContainer = NULL;
    LPWSTR StringSid = NULL;
    LONG bufSize;
    ULONG len;

    *dsName = NULL;

    // Find the container for foriegn security principals
    DBOpen(&pDB);
    __try {
        // First, find the root of the NC.
        DBFindDNT(pDB, NCDNT);

        // Now, get the DNT of the FPO container
        if(GetWellKnownDNT(pDB,
                           (GUID *)GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE,
                           &DNT) 
        && DNT != INVALIDDNT) {

            DBFindDNT(pDB, DNT);
            err = DBGetAttVal(
                    pDB,
                    1,                      // get one value
                    ATT_OBJ_DIST_NAME,
                    0,
                    0,
                    &len,
                    (PUCHAR *)&fpoContainer);
            if(err) {
                __leave;
            }

        } else if (DNT == INVALIDDNT) {

            // Need to hard code the name
            LPWSTR defaultFPOContainer = L"ForeignSecurityPrincipals";

            // This should only happen for win2k upgrades where the WellKnown
            // GUID for the FPO container doesn't exist
            Assert(NCDNT == gAnchor.ulDNTDomain);
    
            bufSize  = AppendRDN(gAnchor.pDomainDN,
                                 NULL,
                                 0,
                                 defaultFPOContainer,
                                 0,
                                 ATT_COMMON_NAME);
            if (bufSize > 0) {
        
                fpoContainer = THAllocEx(pTHS, bufSize);
                bufSize = AppendRDN(gAnchor.pDomainDN,
                                    fpoContainer,
                                    bufSize,
                                    defaultFPOContainer,
                                    0,
                                    ATT_COMMON_NAME);
        
            }
    
            if (bufSize < 0) {
                // error!
                err = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                                    DIRERR_GENERIC_ERROR, 
                                    ERROR_INVALID_PARAMETER);
                __leave;
            }

        } else {

            // A fatal error occurred
            err = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                                DIRERR_GENERIC_ERROR, 
                                ERROR_DS_MISSING_EXPECTED_ATT);
            __leave;

        }
        fCommit = TRUE;
    }
    __finally {
        DBClose(pDB, fCommit);
    }

    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                      DIRERR_GENERIC_ERROR, 
                      err);
        goto exit;
    }

    // Construct the RDN
    if (!ConvertSidToStringSidW(pSid, &StringSid)) {

        err = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                            DIRERR_GENERIC_ERROR, 
                            ERROR_INVALID_PARAMETER);

        goto exit;
    
    }

    bufSize  = AppendRDN(fpoContainer,
                         NULL,
                         0,
                         StringSid,
                         0,
                         ATT_COMMON_NAME);
    if (bufSize > 0) {

        (*dsName) = THAllocEx(pTHS, bufSize);
        bufSize = AppendRDN(fpoContainer,
                           (*dsName),
                           bufSize,
                           StringSid,
                           0,
                           ATT_COMMON_NAME);

    }

    if (bufSize < 0) {
        // error!
        err = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                            DIRERR_GENERIC_ERROR, 
                            ERROR_INVALID_PARAMETER);
        goto exit;
    }

    *parent = fpoContainer;
    fpoContainer = NULL;

exit:

    if (StringSid) {
        LocalFree(StringSid);
    }

    if (err && (*dsName)) {
        THFreeEx(pTHS, (*dsName));
        *dsName = NULL;
    }

    if (fpoContainer) {
        THFreeEx(pTHS, fpoContainer);
    }

    return err;
}


/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Given a SID-only dsname this routine creates an FPO object in the          */
/* database and fills in the GUID portion of pFPO so the dsname reference     */
/* points to a real object for the rest of the transaction.                   */
/*                                                                            */
/* Note that the FPO's are owned by the DS and are created so that linked     */
/* value attributes (like member) can point to an entity outside the          */
/* name space of the forest.                                                  */
/*                                                                            */
/* pTHS -- the thread state                                                   */
/* NCDNT -- the NC the object being modified                                  */
/* pFPO -- a SID-only dsname                                                  */
/*                                                                            */
/* Returns only unexpected or resource failures, or success.                  */
/*----------------------------------------------------------------------------*/
DWORD
fpoCreate(THSTATE *pTHS,  /* in */
          ULONG    NCDNT, /* in */
          DSNAME  *pFPO)  /* in */
{
    NTSTATUS ntStatus;
    ULONG err = 0;
    ULONG objectClass = CLASS_FOREIGN_SECURITY_PRINCIPAL;

    ATTRVAL attrVal[] = {
        {sizeof(DWORD), (PUCHAR)&objectClass},
        {0, NULL},   // SID
        {0, NULL},   // Security Descriptor
        };
    ATTR attrs[] = { 
        {ATT_OBJECT_CLASS, {1, &attrVal[0]}},
        {ATT_OBJECT_SID,   {1, &attrVal[1]}},
        {ATT_NT_SECURITY_DESCRIPTOR,   {1, &attrVal[2]}},
        };
    ATTRBLOCK attrBlock = {RTL_NUMBER_OF(attrs), attrs};
    BOOL  fSaveDSA;
    LPWSTR StringSid = NULL;
    PSID pSid = (PSID)&pFPO->Sid;
    ADDARG addArg;
    COMMRES comRes;
    ULONG len;

    DSNAME *targetDsName = NULL;
    DSNAME *targetParent = NULL;

    // We expect a SID-only DSNAME
    Assert(pFPO->NameLen == 0);
    Assert(fNullUuid(&pFPO->Guid));
    Assert(pFPO->SidLen > 0);

    // Setup the SID for the add argument
    attrVal[1].pVal = THAllocEx(pTHS, RtlLengthSid(pSid));
    CopySid(RtlLengthSid(pSid), attrVal[1].pVal, pSid);
    attrVal[1].valLen = RtlLengthSid(pSid);

    // Setup the security descriptor for the add argument
    err = fpoConstructSd(pTHS, &attrVal[2].valLen, &attrVal[2].pVal);
    if (err) {
        Assert(0 != pTHS->errCode);
        goto exit;
    }

    // Create the targetDsName
    err = fpoConstructDn(pTHS, NCDNT, pSid, &targetDsName, &targetParent);
    if (err) {
        Assert(0 != pTHS->errCode);
        goto exit;
    }

    // Add the object
    ZeroMemory(&addArg, sizeof(addArg));
    addArg.pObject = targetDsName;
    addArg.AttrBlock = attrBlock;
    InitCommarg(&addArg.CommArg);

    fSaveDSA = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    _try {

        // Position on the parent
        err = DoNameRes(pTHS,
                        0, // no flags
                        targetParent,
                        &addArg.CommArg,
                        &comRes,
                        &addArg.pResParent);
        if (!err) {
            // Add the object
            err = LocalAdd(pTHS, &addArg, FALSE);
        }

    } _finally {
        pTHS->fDSA = fSaveDSA;
    }


    if (err) {
        Assert(0 != pTHS->errCode);
        goto exit;
    }

    // Copy the GUID into pFPO
    Assert(!fNullUuid(&(addArg.pObject->Guid)));
    memcpy(&(pFPO->Guid),&(addArg.pObject->Guid), sizeof(GUID)); 

exit:

    if (targetDsName) {
        THFreeEx(pTHS, targetDsName);
    }

    if (attrVal[1].pVal) {
        THFreeEx(pTHS, attrVal[1].pVal);
    }

    return err;

}


/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* This routine determines if there are duplicate FPO's representing the SID  */
/* in pDN.  This can happen if two FPO's are created at the same time on two  */
/* different DC's. The algorithm will return the one with the latest creation */
/* time.                                                                      */
/* The DSNAME is then updated in memory to contain the guid of the newest FPO */
/* that represents the principal.                                             */
/*                                                                            */
/* pTHS    -- the thread state                                                */
/* NCDNT   -- the NC the object being modified                                */
/* pDN     -- the sid only DN                                                 */
/* Winner  -- the DN of the FPO that takes precedence                         */
/*                                                                            */
/* Returns only unexpected or resource failures, or success.                  */
/*                                                                            */
/*----------------------------------------------------------------------------*/
DWORD
fpoHandleDuplicates(THSTATE *pTHS,    /* in */
                    ULONG    NCDNT,   /* in */
                    DSNAME  *pDN,     /* in */
                    DSNAME  **Winner) /* out */
{
    DWORD          err = 0;
    FILTER         Filter = {0};
    SEARCHARG      SearchArg = {0};
    SEARCHRES     *pSearchRes = NULL;
    ENTINFSEL      EntInfSel = {0};
    DSNAME        *pSearchRootDN = NULL;
    ULONG          len = 0;
    DSNAME        *NewestObject = NULL;
    LARGE_INTEGER  NewestTime = {0};
    ATTR           AttrResult = {0};

    // Get the root object of the search
    DBFindDNT(pTHS->pDB, NCDNT);
    err = DBGetAttVal(pTHS->pDB, 
                      1, 
                      ATT_OBJ_DIST_NAME, 
                      0, 
                      0,
                      &len, 
                     (UCHAR **) &pSearchRootDN);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
        return pTHS->errCode; 
    }

    // build search arg
    SearchArg.pObject = pSearchRootDN;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.bOneNC = TRUE;
    SearchArg.pSelection = &EntInfSel;
    InitCommarg(&(SearchArg.CommArg));
    
    // build filter
    Filter.pNextFilter = NULL;
    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_SID;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = pDN->SidLen;
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR)&(pDN->Sid);

    // build selection
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &AttrResult;
    AttrResult.attrTyp = ATT_WHEN_CREATED;
    AttrResult.AttrVal.valCount = 0;
    AttrResult.AttrVal.pAVal = NULL;

    // search for the account
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    SearchBody(pTHS, &SearchArg, pSearchRes,0);
    
    // find the newest object
    if (pSearchRes->count > 0) {

        ENTINFLIST *EnfIntList = &pSearchRes->FirstEntInf;
        do {
            if ((EnfIntList->Entinf.AttrBlock.attrCount >= 1)
             && (EnfIntList->Entinf.AttrBlock.pAttr[0].attrTyp == ATT_WHEN_CREATED)) {

                LARGE_INTEGER CreationTime;
                CreationTime = *((LARGE_INTEGER *)EnfIntList->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
                if (CreationTime.QuadPart > NewestTime.QuadPart) {
                    NewestObject = (DSNAME*) EnfIntList->Entinf.pName;
                    NewestTime = CreationTime;
                }
            }
            EnfIntList = EnfIntList->pNextEntInf;
        } while (EnfIntList != NULL);
    }

    if (NewestObject) {
        // This will be our target object
        *Winner = NewestObject;
    } else {
        // LocalFind err'ed out.  We tried to find duplicates but didn't find
        // any.  This condition is unhandled.  As such, error out.
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, 0);
        err = pTHS->errCode; 
    }

    return err;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* This routine determines if the SID only pDN is already represented by an   */
/* FPO in the NCDNT.                                                          */
/* DSNAME references that reference security principals outside of the forest.*/
/* The DSNAME is then updated in memory to contain the guid of the FPO that   */
/* represents the principal.                                                  */
/*                                                                            */
/* pTHS -- the thread state                                                   */
/* NCDNT -- the NC the object being modified                                  */
/* pDN  --  the sid only DN                                                   */
/* fExists --  TRUE if an FPO for pDN exists, FALSE otherwise                 */
/*                                                                            */
/* Returns only unexpected or resource failures, or success.                  */
/*                                                                            */
/*----------------------------------------------------------------------------*/
DWORD
fpoCheckForExistence(THSTATE *pTHS,    /* in */
                     ULONG    NCDNT,   /* in */
                     DSNAME  *pDN,     /* in */
                     BOOL    *fExists) /* out */
{
    DWORD err = 0;
    FINDARG findArg;
    FINDRES findRes;

    ZeroMemory(&findArg, sizeof(findArg));
    ZeroMemory(&findRes, sizeof(findRes));

    findArg.hDomain = NCDNT;
    findArg.AttId = ATT_OBJECT_SID;
    findArg.AttrVal.valLen = pDN->SidLen;
    findArg.AttrVal.pVal = (PSID)&pDN->Sid;
    InitCommarg(&findArg.CommArg);

    err = LocalFind(&findArg, &findRes);

    if (err == 0) {
        // Object was found; copy in the guid
        memcpy(&(pDN->Guid), &(findRes.pObject->Guid), sizeof(GUID));
        *fExists = TRUE;

    } else if (NULL == pTHS->pErrInfo) {

        err = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                            DIRERR_UNKNOWN_ERROR,
                            ERROR_NOT_ENOUGH_MEMORY);

    } else if ( (err == nameError)
            &&  (pTHS->pErrInfo->NamErr.problem == NA_PROBLEM_NO_OBJECT)){
        // no existing object exists
        *fExists = FALSE;
        THClearErrors();
        err = 0;
    } else {

        // LocalFind will return a directory error when duplicates are found
        // This segment determines if, in fact, there are duplicates.  If there
        // are no duplicates, then an unexpected directory error occurred 
        // and this will be returned to the caller.  If there are duplicates
        // then the newest will be returned.
        DSNAME *Winner;

        THClearErrors();
        err = fpoHandleDuplicates(pTHS,
                                  NCDNT,
                                  pDN,
                                  &Winner);
        if (err == 0) {
            memcpy(&(pDN->Guid), &(Winner->Guid), sizeof(GUID));
            *fExists = TRUE;
        }
    }

    return err;
}


/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* This routine iterates through the values of an attribute (that was         */
/* specified on a add or a modify and finds or creates an FPO object for all  */
/* DSNAME references that reference security principals outside of the forest.*/
/* The DSNAME is then updated in memory to contain the guid of the FPO that   */
/* represents the principal.                                                  */
/*                                                                            */
/* pTHS -- the thread state                                                   */
/* NCDNT -- the DNT of the NC of the object being modified                    */
/* fCreate -- if no FPO is found, create one                                  */
/* fAllowInForest -- a flag used during initialization to override the        */
/*                   condition that the code doesn't create intra-forest      */
/*                   FPO's                                                    */
/* pObject -- the object that is being added or modified                      */
/* pAttr   -- an attribute that is being modified or added on pObject         */
/*                                                                            */
/* Returns only unexpected or resource failures, or success.                  */
/*                                                                            */
/*----------------------------------------------------------------------------*/

DWORD
FPOUpdateWithReference(THSTATE *pTHS,           /* in */
                       ULONG    NCDNT,          /* in */
                       BOOL     fCreate,        /* in */
                       BOOL     fAllowInForest, /* in */
                       DSNAME  *pObject,        /* in */
                       ATTR    *pAttr)          /* in */
{
    ULONG err = 0;
    ATTCACHE *pAC;
    ATTRVAL  *pAVal;
    ULONG i;
    BOOL fExists = FALSE;
    ULONG saveDNT, saveNCDNT;

    // There should be transaction at this point
    Assert(pTHS->pDB);

    // Skip for replication; SID only names should never be
    // replicated.
    if (pTHS->fDRA) {
        return 0;
    }

    // Skip for objects not belonging to the current domain
    if (NCDNT != gAnchor.ulDNTDomain) {
        return 0;
    }

    // Save off the DNT so that it can be repositioned
    saveDNT = pTHS->pDB->DNT;
    // Save off NCDNT which was computed for the new object in add
    saveNCDNT = pTHS->pDB->NCDNT;

    // Find the attribute that is being modified or added
    if (!(pAC = SCGetAttById(pTHS, pAttr->attrTyp))) {
        SetAttError(pObject,
                    pAttr->attrTyp,
                    PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                    DIRERR_ATT_NOT_DEF_IN_SCHEMA); 
        return(pTHS->errCode);
    }

    // Iterate over its values searching for SID references
    for ( i = 0; i < pAttr->AttrVal.valCount; i++ ) {

        DSNAME *pDN;
        DSNAME *pDNOriginal;
        DSNAME *pCrossRef;
        ENTINF *pEntInf;

        pAVal = &(pAttr->AttrVal.pAVal[i]);
        pDNOriginal = DSNameFromAttrVal(pAC, pAVal);
        if (NULL == pDNOriginal) {
            // not a DN value
            continue;
        }

        // See if the name has been verified
        pEntInf = GCVerifyCacheLookup(pDNOriginal);
        if (pEntInf && pEntInf->pName) {

            // Use the verified name
            pDN = pEntInf->pName;

        } else {

            // The name wasn't verified, check locally to see if the object
            // has a SID
            if (pDNOriginal->SidLen == 0) {
                // Determine if pDN has a SID value, if possible
                err = DBFindDSName(pTHS->pDB, pDNOriginal);
                if ((err == 0) || (err == DIRERR_NOT_AN_OBJECT)) {
                    err = DBFillGuidAndSid(pTHS->pDB, pDNOriginal);
                } else if (err == DIRERR_OBJ_NOT_FOUND) {
                    // This is ok
                    err = 0;
                }
            }

            if (err) {
                err =  SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                     DIRERR_GENERIC_ERROR,
                                     err);
                return err;
            }

            // Use the caller supplied DN to determine if an FPO is needed
            pDN = pDNOriginal;
        }


        // Handle references to SID based names that are outside our
        // forest by creating and/or referencing an FPO for that SID
        if ( (pDN->SidLen > 0)
         &&  (fAllowInForest
          || !FindNcForSid(&pDN->Sid, &pCrossRef))) {

            DSNAME *pDNNew;
            pDNNew = THAllocEx(pTHS, DSNameSizeFromLen(0));
            pDNNew->structLen = DSNameSizeFromLen(0);
            pDNNew->SidLen = pDN->SidLen;
            memcpy(&pDNNew->Sid, &pDN->Sid, pDN->SidLen);

            // See if the object exists locally -- this also
            // catches BUILTIN domain references
            err = fpoCheckForExistence(pTHS,
                                       NCDNT,
                                       pDNNew,
                                       &fExists);
            if (err) {
                Assert(0 != pTHS->errCode);
                return err;
            }

            if (!fExists
              && fCreate )  {

                // The SID is not in our forest, or we are allowing
                // FPO's for objects in our own forest (using during
                // initialization) 

                // create an FPO for the object
                err = fpoCreate(pTHS,
                                NCDNT,
                                pDNNew);
                if (err) {
                    Assert(0 != pTHS->errCode);
                    return err;
                }
            }

            if ( fExists
             ||  fCreate ) {

                //
                // Update the original update arg
                //
                Assert(!fNullUuid(&pDNNew->Guid));
    
                //
                // Note that we can't safely realloc the callers parameter,
                // so just replace the GUID and zero out the string name
                //
                pDNOriginal->NameLen = 0;
                pDNOriginal->StringName[0] = L'\0';
                memcpy(&pDNOriginal->Guid, &pDNNew->Guid, sizeof(GUID));
                pDNOriginal->SidLen = pDNNew->SidLen;
                memcpy(&pDNOriginal->Sid, &pDNNew->Sid, pDNNew->SidLen);
            }

            THFreeEx(pTHS, pDNNew);
        }
    }

    if (saveDNT != INVALIDDNT && saveDNT != 0) {
        // Restore DNT positioning
        DBFindDNT(pTHS->pDB, saveDNT);
    }
    pTHS->pDB->NCDNT = saveNCDNT;

    return err;
}

BOOL
FPOAttrAllowed(
    ULONG Attr   /* in */
    )
{

    switch (Attr) {
    case ATT_MS_DS_MEMBERS_FOR_AZ_ROLE:
    case ATT_MEMBER:
    case ATT_MS_DS_NON_MEMBERS:
        return TRUE;
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\hiertab.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       hiertab.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <dsjet.h>		/* for error codes */
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>
#include <filtypes.h>
#include <usn.h>
#include "dsexcept.h"
#include <dsconfig.h>                   // Definition of mask for visible
                                        // containers
#include "debug.h"          // standard debugging header
#define DEBSUB "HIERARCH:"              // define the subsystem for debugging

#include <hiertab.h>

#include <fileno.h>
#define  FILENO FILENO_HIERTAB




/*****************************
 * Definition of globals.
 *****************************/

ULONG gulHierRecalcPause;
ULONG gulDelayedHierRecalcPause = 300;

/*   exported in hiertab.h */
PHierarchyTableType    HierarchyTable = NULL;

/*****************************
 * Local help routines.
 *****************************/
CRITICAL_SECTION csMapiHierarchyUpdate;

DWORD
HTBuildHierarchyTableLocal ( 
        void
        );

DWORD
HTGetHierarchyTable (
        PHierarchyTableType * DBHierarchyTable
        );

BOOL
HTCompareHierarchyTables (
        PHierarchyTableType NewTable,
        PHierarchyTableType HierarchyTable
        );


/*****************************
 * Code.
 *****************************/


DWORD
InitHierarchy()
{
    PHierarchyTableType     DbHierarchyTable=NULL;
    DWORD                   i;
    DWORD                   err = 0;

    Assert(HierarchyTable==NULL);
    
    // First, a shortcut.  If we aren't yet installed, we don't need to get a
    //  real hierarchy, just fall through and create a  simple Hierarchy table
    // with only a GAL, and nothing in it. 
    if(DsaIsRunning()) {
        // Nope we are installed. Go ahead and build a real hierarchy. 

        /* Get Hierarchy Table from DBLayer */
        if (!HTGetHierarchyTable(&DbHierarchyTable)) {
            // Got one.
            DbHierarchyTable->Version = 1;
            HierarchyTable=DbHierarchyTable;
            
            return 0;
            
        }
        
        // We couldn't get a table from the DBLayer.
        LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_BUILD_HIERARCHY_TABLE_FAILED,
                         szInsertUL(HIERARCHY_DELAYED_START / 60),
                         0, 0);
    }
    
    // For some reason, we didn't get a satisfactory hierarchy table.  So now,
    // build the simple, empty, hierarchy. 
    
    DbHierarchyTable = malloc(sizeof(HierarchyTableType));
    if(!DbHierarchyTable) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                 szInsertUL(sizeof(HierarchyTableType)),
                 NULL, NULL);
        return DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
    }

    DbHierarchyTable->GALCount = 0;
    DbHierarchyTable->pGALs = NULL;
    DbHierarchyTable->TemplateRootsCount = 0;
    DbHierarchyTable->pTemplateRoots = NULL;
    DbHierarchyTable->Version = 1;
    DbHierarchyTable->Size = 0;
    DbHierarchyTable->Table = (PHierarchyTableElement)malloc(0);
    if(!DbHierarchyTable->Table) {
        free(DbHierarchyTable);
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                 szInsertUL(0),
                 NULL, NULL);
        return DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
    }
    
    HierarchyTable = DbHierarchyTable;

    if(DsaIsRunning() && gfDoingABRef) {
        // If we are really running, and we are tracking entries in address
        // books, schedule HierarchyTable construction to begin relatively soon
        InsertInTaskQueue(TQ_BuildHierarchyTable,
                          (void *)((DWORD_PTR) HIERARCHY_DELAYED_START),
                          gulDelayedHierRecalcPause);
    }

    return 0;
}


/**************************************
 *
 * Walk through the dit and build a hierarchy table.  This data is
 * passed back to clients through the abp interface to support the
 * GetHierarchyTable Mapi call. This routine is expected to be
 * called from the task queue at startup and periodically thereafter.
 *
 * This routine is a wrapper.  It calls
 * the worker routine.
 *
 ***************************************/

void
BuildHierarchyTableMain (
    void *  pv,
    void ** ppvNext,
    DWORD * pcSecsUntilNextIteration
    )
{
    THSTATE *pTHS = pTHStls;
    BOOL fOldDSA = pTHS->fDSA;

    Assert(gfDoingABRef || (PtrToUlong(pv) == HIERARCHY_DO_ONCE));

    // We always build the hierarchy table on behalf of the DSA, security is
    // applied later when returning it to clients.
    pTHS->fDSA= TRUE;
    __try {
        if(HTBuildHierarchyTableLocal()) {
            // Something went wrong.  Figure out when to reschedule
            if(!eServiceShutdown) {
                
                switch(PtrToUlong(pv)) {
                case HIERARCHY_PERIODIC_TASK:
                    // This is the normal periodic hierarchy recalc 
                    // We should reschedule an hour hence. 
                    *pcSecsUntilNextIteration = 3600;
                    
                    LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                     DS_EVENT_SEV_MINIMAL,
                                     DIRLOG_BUILD_HIERARCHY_TABLE_FAILED,
                                     szInsertUL((*pcSecsUntilNextIteration) / 60),
                                     0, 0);
                    break;
                    
                case  HIERARCHY_DELAYED_START:
                    
                    // This is the delayed startup recalc. See if and when to
                    // reschedule.
                    gulDelayedHierRecalcPause *= 2;
                    if(gulDelayedHierRecalcPause < gulHierRecalcPause) {
                        // The pause is still short enough that we should
                        // reschedule rather than let normal periodic recalc
                        // take over.
                        *pcSecsUntilNextIteration = gulDelayedHierRecalcPause;
                        
                        LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                         DS_EVENT_SEV_MINIMAL,
                                         DIRLOG_BUILD_HIERARCHY_TABLE_FAILED,
                                         szInsertUL(gulDelayedHierRecalcPause),
                                         0,0);
                    }
                    else {
                        // OK, let normal periodic take over.
                        *pcSecsUntilNextIteration = 0;
                    }
                    break;
                case  HIERARCHY_DO_ONCE:
                default:
                    // Don't reschedule.
                    *pcSecsUntilNextIteration = 0;
                    break;
                }
            }
        }
        else {
            
            // If an exchange config object has been added or deleted
            // the Nspis interface may need to be start or stopped.
            DsStartOrStopNspisInterface();
            
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_BUILD_HIERARCHY_TABLE_SUCCEEDED,
                     NULL, NULL, NULL);
            
            if(!eServiceShutdown &&  (PtrToUlong(pv) == HIERARCHY_PERIODIC_TASK)) {
                // Nothing went wrong, but this is the normal periodic hierarchy
                // recalc.  We should reschedule.
                *pcSecsUntilNextIteration = gulHierRecalcPause;
            }
        }
        
    }
    __finally {
        pTHS->fDSA = fOldDSA;
        *ppvNext = pv;
    }
}


/*****************************************
*
*  This routine does the work of building the hierarchy table.
*
******************************************/


DWORD
HTBuildHierarchyTableLocal (
        )
{
    PHierarchyTableType  NewHierarchyTable=NULL, OldHierarchy=NULL;
    BOOL                 fOK=FALSE;
    DWORD                i=0,j,freesize=0;
    DWORD_PTR            *pointerArray;
    DWORD                err=0;

    /* First, get the New HierarchyTable from the DBLayer. */
    if (err = HTGetHierarchyTable(&NewHierarchyTable) ) {
       
        return err;
    }
    
    /* Are we being shutdown? If so, exit */
    if (eServiceShutdown) {
        return DIRERR_BUILD_HIERARCHY_TABLE_FAILED;
    }

    // We're done messing with the DB.  Now, we need to do some stuff with the
    // global hierarchy table.  Let's make sure no one else is messing with it
    // at the same time.  This shouldn't take long.
    EnterCriticalSection(&csMapiHierarchyUpdate);
    __try {
        if(HTCompareHierarchyTables(NewHierarchyTable, HierarchyTable)) {
            /* The new one is the same as the old one.  Destroy the new
             * one and return No error.
             */
            for(i = 0; i < NewHierarchyTable->Size; i++) {
                free(NewHierarchyTable->Table[i].displayName);
                free(NewHierarchyTable->Table[i].pucStringDN);
            }
            free(NewHierarchyTable->Table);
            free(NewHierarchyTable);
            __leave;
            
        }
        
        /* Are we being shutdown? If so, exit */
        if (eServiceShutdown) {
            err = DIRERR_BUILD_HIERARCHY_TABLE_FAILED;
            __leave;
        }
        
        // We have a new hierarchy table.
        if(HierarchyTable ) {
            // Pack up the old Hierarchy Table and delete it.
            freesize = (5+2*HierarchyTable->Size);
            
            /* Update the Version number on the New Hierarchy Table */
            NewHierarchyTable->Version = 1 + HierarchyTable->Version;
            
            /* Grab pointers to the current table. */
            OldHierarchy = HierarchyTable;
            
            pointerArray = (DWORD_PTR *)malloc(freesize*sizeof(DWORD_PTR));
            if(pointerArray) {
                // Replace the current HierarchyTable with this new one.
                HierarchyTable = NewHierarchyTable;
                
                for(i=1, j=0;j<OldHierarchy->Size;j++) {
                    pointerArray[i++] =
                        (DWORD_PTR) (OldHierarchy->Table[j].displayName);
                    pointerArray[i++] =
                        (DWORD_PTR) (OldHierarchy->Table[j].pucStringDN);
                }
                pointerArray[i++] = (DWORD_PTR) OldHierarchy;
                if(OldHierarchy->pGALs) {
                    pointerArray[i++] = (DWORD_PTR) OldHierarchy->pGALs;
                }
                if(OldHierarchy->pTemplateRoots) {
                    pointerArray[i++] = (DWORD_PTR)OldHierarchy->pTemplateRoots;
                }
                pointerArray[i] = (DWORD_PTR) OldHierarchy->Table;
                pointerArray[0] = (DWORD_PTR)(i);
                
                /* Add this to the event queue as a cleanup event. */
                DelayedFreeMemoryEx(pointerArray, 3600);
            }
            else {
                /* Couldn't allocate the memory we need to send the list
                 * of used pointers to the cleaners.
                 *
                 * We have successfully built a new hierarchy table,
                 * and must now free the new hierarchy table,
                 * live with the old hierarchy table for a while, and schedule
                 * new hierarchy table creation for a little while from now.
                 */
                for(i = 0; i < NewHierarchyTable->Size; i++) {
                    free(NewHierarchyTable->Table[i].displayName);
                    free(NewHierarchyTable->Table[i].pucStringDN);
                }
                free(NewHierarchyTable->Table);
                if(NewHierarchyTable->pGALs) {
                    free(NewHierarchyTable->pGALs);
                }
                if(NewHierarchyTable->pTemplateRoots) {
                    free(NewHierarchyTable->pTemplateRoots);
                }
                free(NewHierarchyTable);
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                         szInsertUL(freesize*sizeof(DWORD_PTR)),
                         NULL, NULL);
                err = DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
                __leave;
            }
        }
        else {
            /* Replace the current HierarchyTable with this new one.     */
            HierarchyTable = NewHierarchyTable;
        }
    }
    __finally {
        LeaveCriticalSection(&csMapiHierarchyUpdate);
    }
    return err;

}

BOOL
htVerifyObjectIsABContainer(
        THSTATE *pTHS,
        DWORD DNT
        )
/*++
  Visit the object passed in, and verify that
  1) It's an active DNT
  2) It's a normal, instantiated, non-deleted object
  3) It's an address book container.

  In success return, currency is left on the DNT in question.
--*/
{
    CLASSCACHE *pCC;
    DWORD       j, val;
    
    if(DBTryToFindDNT(pTHS->pDB, DNT)) {
        return FALSE;
    }

    val = FALSE;
    if(DBGetSingleValue(pTHS->pDB,
                        FIXED_ATT_OBJ,
                        &val,
                        sizeof(val),
                        NULL)) {
        // not an object.
        return FALSE;
    }
    
    if(!val) {
        // Not an object.
        return FALSE;
    }
    
    val = TRUE;
    if(DBGetSingleValue(pTHS->pDB,
                        ATT_IS_DELETED,
                        &val,
                        sizeof(val),
                        NULL)) {
        // no is-deleted.
        val = FALSE;
    }

    if(val) {
        // It's deleted.
        return FALSE;
    }
    
    if(DBGetSingleValue(pTHS->pDB,
                        ATT_OBJECT_CLASS,
                        &val,
                        sizeof(val),
                        NULL)) {
        // huh?
        return FALSE;
    }

    if(val == CLASS_ADDRESS_BOOK_CONTAINER) {
        return TRUE;
    }

    // The object class was incorrect.  See if we are a subclass of the correct
    // class
    pCC = SCGetClassById(pTHS, val);
    for (j=0; j<pCC->SubClassCount; j++) {
        if (pCC->pSubClassOf[j] == CLASS_ADDRESS_BOOK_CONTAINER) {
            // OK, the object is a subclass of an AB container.  Good enough.
            return TRUE;
        }
    }

    return FALSE;
}

int __cdecl
AuxDNTCmp(const void *keyval, const void * datum)
{
    int *pKeyVal = (int *)keyval;
    int *pDatum = (int *)datum;

    return(*pKeyVal - *pDatum);
}
        
void
htSearchResForLevelZeroAddressBooks(
        SEARCHRES *pSearchRes,
        DWORD     *pGALCount,
        DWORD     **ppGALs,
        DWORD     *pTemplateRootCount,
        DWORD     **ppTemplateRoots
        )
/*++     
  Find the Exchange config object (the DN is in the anchor).  If we find the
  object, read the GAL DNTs off of it, and read the DNs which refer to the roots
  of the address book hierarchy.  Go visit those objects and return back a hand
  built search res structure that makes it look like someone issued a search
  that found those objects.

  This routine is called by the hierarchy table building stuff.  Once we've got
  this list, we then recurse on it doing searches.  The recursion expects to
  work on search res's, thus the data returned from this routine is in the same
  format.

  If there is some problem finding the Exchange config DN, we return an empty
  search res.  We also verify that the objects we return (both in pGALs and
  the search res) are of the appropriate object class (i.e. address book
  containers, not deleted, etc.).
  
--*/
{
    THSTATE    *pTHS=pTHStls;
    ATTCACHE   *pAC=NULL;
    DWORD       i, cbActual, ObjDNTs[256], *pObjDNT, count;
    ENTINFLIST *pEIL=NULL, *pEILTemp = NULL;
    ENTINFSEL   eiSel;
    ATTR        SelAttr[2];
    DWORD       cDNTs, ThisDNT, index, cDNTsAlloced;
    DWORD       *pThisDNT=&ThisDNT, *pDNTs, *pDNTsTemp;
    DWORD       cTemplates, cTemplatesAlloced;
    DWORD       *pTemplates, *pTemplatesTemp;
    
    memset(pSearchRes, 0, sizeof(SEARCHRES));
    *pGALCount = 0;
    *ppGALs = NULL;

    *pTemplateRootCount = 0;
    *ppTemplateRoots = NULL;
    
    if(!gAnchor.pExchangeDN) {
        // No exchange config object, so no hierarchy roots and no gal.  Take a
        // quick look to see if there should be an exchange config (i.e. one has
        // been added since boot).
        PDSNAME pNew = mdGetExchangeDNForAnchor (pTHS, pTHS->pDB);
        if(pNew) {
            // Cool, we now have one.
            EnterCriticalSection(&gAnchor.CSUpdate);
            __try {
                gAnchor.pExchangeDN = pNew;
            }
            __finally {
                LeaveCriticalSection(&gAnchor.CSUpdate);
            }
        }
        else {
            // nope, no object.
            return;
        }
    }
  
    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_SHORTNAMES;
    eiSel.AttrTypBlock.attrCount = 2;
    eiSel.AttrTypBlock.pAttr = SelAttr;
    
    SelAttr[0].attrTyp = ATT_DISPLAY_NAME;
    SelAttr[0].AttrVal.valCount = 0;
    SelAttr[0].AttrVal.pAVal = NULL;
    
    SelAttr[1].attrTyp = ATT_LEGACY_EXCHANGE_DN;
    SelAttr[1].AttrVal.valCount = 0;
    SelAttr[1].AttrVal.pAVal = NULL;


    pAC = SCGetAttById(pTHS, ATT_ADDRESS_BOOK_ROOTS);
    
    i = 1;
    count = 0;
    
    Assert(pTHS->pDB);
    if(!DBFindDSName(pTHS->pDB, gAnchor.pExchangeDN)) {
        // Found the exchange config object.
        
        // First, read all the DNTs of the address book roots.  Do this now,
        // since we have to visit them all, and getting everything we need off
        // the current object now saves excessive Jet seeks.
        i = 1;
        pObjDNT = ObjDNTs;
        while(i <= 256 &&
              !DBGetAttVal_AC(
                      pTHS->pDB,
                      i,
                      pAC,
                      (DBGETATTVAL_fCONSTANT | DBGETATTVAL_fINTERNAL),
                      sizeof(DWORD),
                      &cbActual,
                      (PUCHAR *)&pObjDNT)) {
            pObjDNT = &ObjDNTs[i];
            i++;
        }
        i--;

        // Get the DNTs of the template roots. 
        cTemplates = 0;
        cTemplatesAlloced = 10;
        pTemplates=malloc(cTemplatesAlloced * sizeof(DWORD));
        if(!pTemplates) {
            MemoryPanic(cTemplatesAlloced * sizeof(DWORD));
            RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                           DSID(FILENO, __LINE__),
                           DS_EVENT_SEV_MINIMAL);
        }

        index = 1;
        // The necessary att is not yet in the schema.
        while(!DBGetAttVal(
                pTHS->pDB,
                index,
                ATT_TEMPLATE_ROOTS,
                (DBGETATTVAL_fCONSTANT | DBGETATTVAL_fINTERNAL),
                sizeof(DWORD),
                &cbActual,
                (PUCHAR *)&pThisDNT)) {
            // Read a value.  Put it in the list.
            if(cTemplates == cTemplatesAlloced) {
                cTemplatesAlloced = (cTemplatesAlloced * 2);
                pTemplatesTemp  = realloc(pTemplates,
                                          cTemplatesAlloced * sizeof(DWORD));
                if(!pTemplatesTemp) {
                    // Failed to allocate.
                    free(pTemplates);
                    MemoryPanic(cTemplatesAlloced * sizeof(DWORD));
                    RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                                   DSID(FILENO, __LINE__),
                                   DS_EVENT_SEV_MINIMAL);
                }
                pTemplates = pTemplatesTemp;
            }
            pTemplates[cTemplates] = ThisDNT;
            cTemplates++;
            index++;
        }

        if(!cTemplates) {
            // Temporarily, just use the DNT of the exchange config object.
            // This is here just to ease the transition from always using the
            // exchange config object as the root of the template tree (old
            // behaviour) to using a value on the exchange config object as
            // multiple template trees (new behaviour)
            cTemplates = 1;
            pTemplates[0] = pTHS->pDB->DNT;
        }


        switch(cTemplates) {
        case 0:
            free(pTemplates);
            break;

        default:
            // Sort things
            qsort(pTemplates, cTemplates, sizeof(DWORD), AuxDNTCmp);
            // fall through
        case 1:
            *pTemplateRootCount = cTemplates;
            *ppTemplateRoots = pTemplates;
            break;
        }        

        
        
        // Get the DNTs of the GALs
        cDNTs = 0;
        cDNTsAlloced = 10;
        pDNTs = malloc(cDNTsAlloced * sizeof(DWORD));
        if(!pDNTs) {
            free(pTemplates);
            MemoryPanic(cDNTsAlloced * sizeof(DWORD));
            RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                           DSID(FILENO, __LINE__),
                           DS_EVENT_SEV_MINIMAL);
        }
        index = 1;
        while(!DBGetAttVal(
                pTHS->pDB,
                index,
                ATT_GLOBAL_ADDRESS_LIST,
                (DBGETATTVAL_fCONSTANT | DBGETATTVAL_fINTERNAL),
                sizeof(DWORD),
                &cbActual,
                (PUCHAR *)&pThisDNT)) {
            // Read a value.  Put it in the list.
            if(cDNTs == cDNTsAlloced) {
                cDNTsAlloced = (cDNTsAlloced * 2);
                pDNTsTemp  = realloc(pDNTs, cDNTsAlloced * sizeof(DWORD));
                if(!pDNTsTemp) {
                    // Failed to allocate.
                    free(pTemplates);
                    free(pDNTs);
                    MemoryPanic(cDNTsAlloced * sizeof(DWORD));
                    RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                                   DSID(FILENO, __LINE__),
                                   DS_EVENT_SEV_MINIMAL);
                }
                pDNTs = pDNTsTemp;
            }
            pDNTs[cDNTs] = ThisDNT;
            cDNTs++;
            index++;
        }

        // Now, verify that those objects are good
        for(index=0;index<cDNTs;) {
            if(htVerifyObjectIsABContainer(pTHS, pDNTs[index])) {
                // Yep, a valid object
                index++;
            }
            else {
                // Not valid.  Skip this one by grabbing the unexamined DNT from
                // the end of the list.
                cDNTs--;
                pDNTs[index] = pDNTs[cDNTs];
            }
        }

    
        switch(cDNTs) {
        case 0:
            free(pDNTs);
            break;

        default:
            // Sort things
            qsort(pDNTs, cDNTs, sizeof(DWORD), AuxDNTCmp);
            // fall through
        case 1:
            *pGALCount = cDNTs;
            *ppGALs = pDNTs;
            break;
        }


        count = 0;
        while(i) {
            i--;
            // verify that the object is of the correct class and is not
            // deleted.
            if(htVerifyObjectIsABContainer(pTHS, ObjDNTs[i])) {
                count++;
                pEILTemp = THAllocEx(pTHS, sizeof(ENTINFLIST));
                GetEntInf(pTHS->pDB,
                          &eiSel,
                          NULL,
                          &(pEILTemp->Entinf),
                          NULL,
                          0,
                          NULL,
                          GETENTINF_NO_SECURITY,
                          NULL,
                          NULL);
                
                pEILTemp->pNextEntInf = pEIL;
                pEIL = pEILTemp;
            }
        }
    }
    
    pSearchRes->count = count;
    if(count) {
        memcpy(&pSearchRes->FirstEntInf, pEIL, sizeof(ENTINFLIST));
    }
    
    return;
}


DWORD
HTBuildHierarchyLayer (
        PHierarchyTableElement *ppTempData,
        DWORD                  *pdwAllocated,
        DWORD                  *pdwIndex,
        DSNAME                 *pDN,
        DWORD                   currentDepth,
        DWORD                  *pGALCount,
        DWORD                 **ppGALs,
        DWORD                  *pTemplateRootsCount,
        DWORD                 **ppTemplateRoots
        )
/*++     
  DESCRIPTION
      This routine fills in part of the hierarchy table.  It is called
      recursively with an array which it fills in using an index.  The array and
      the index are passed by pointer so that the recursive invocations
      concatenate to the end, and so that if the table needs to grow, the nested
      invocations grow of the table is reflected in the outer call.  Note that
      ALL access to the table we are filling in MUST be done via an indexed
      array, not via simple pointer arithmetic.

      The elements of the array are filled in by doing a one level search from
      the DN passed in looking for ABView objects.  After dealing with an object
      from the search, this routine recurses looking for children of that
      object, essentially doing a depth first traversal.  Results in a properly
      arranged hierarchy table.
      

  Parameters
    ppTempData pointer to a pointer to an allocated array of
                   HierarchyTableElements. This routine may realloc the array,
                   hence the use of the double pointer.

    pdwAllocated size of the allocated array.  May be changed by this routine
    pdwIndex     index of next unused element in the array.  Will be changed by
                 this routine    
    pDN          DN to base the search from
    currentDepth depth of recursion (is the same as the depth in the hierarchy
                 tree of the elements added to the tree by this routine.)

  RETURN VALUES                 
    0 on success, non-zero on error.
--*/  
{
    SEARCHARG              SearchArg;
    SEARCHRES             *pSearchRes;
    FILTER                 Filter;
    ENTINFSEL              eiSel;
    ATTRBLOCK              AttrTypBlock;
    ENTINFLIST            *pEIL;
    ULONG                  i;
    THSTATE               *pTHS = pTHStls;           // for speed
    ULONG                  objClass;
    DWORD                  err;
    ATTR                   SelAttr[2];


    // allocate space for search res
    pSearchRes = (SEARCHRES *)THAlloc(sizeof(SEARCHRES));
    if (pSearchRes == NULL) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                 szInsertUL(sizeof(SEARCHRES)),
                 NULL, NULL);
        return DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
    }
    
    pTHS->errCode = 0;
    pSearchRes->CommRes.aliasDeref = FALSE;   //Initialize to Default
    
        
    
    if(currentDepth == 0) {
        Assert(!pDN);
        Assert(ppGALs);
        Assert(pGALCount);
        Assert(ppTemplateRoots);
        Assert(pTemplateRootsCount);
        
        // Find the gAnchor.pExchangeDN object, read the DNs in the
        // ADDRESS_BOOK_ROOTS attribute, and fake a SearchRes for those objects.
        htSearchResForLevelZeroAddressBooks(pSearchRes, pGALCount, ppGALs,
                                            pTemplateRootsCount,
                                            ppTemplateRoots);
    }
    else {
        Assert(pDN);
        Assert(!ppGALs);
        Assert(!pGALCount);
        Assert(!ppTemplateRoots);
        Assert(!pTemplateRootsCount);
        
        // build search argument
        memset(&SearchArg, 0, sizeof(SEARCHARG));
        SearchArg.pObject = pDN;
        SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
        SearchArg.pFilter = &Filter;
        SearchArg.searchAliases = FALSE;
        SearchArg.bOneNC = TRUE;
        SearchArg.pSelection = &eiSel;
        InitCommarg(&(SearchArg.CommArg));
        
        // build filter
        memset (&Filter, 0, sizeof (Filter));
        Filter.pNextFilter = (FILTER FAR *)NULL;
        Filter.choice = FILTER_CHOICE_ITEM;
        Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        Filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
        Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof (ULONG);
        Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PCHAR)&objClass;
        objClass = CLASS_ADDRESS_BOOK_CONTAINER;
        
        // build selection
        eiSel.attSel = EN_ATTSET_LIST;
        eiSel.infoTypes = EN_INFOTYPES_SHORTNAMES;
        eiSel.AttrTypBlock.attrCount = 2;
        eiSel.AttrTypBlock.pAttr = SelAttr;
        
        SelAttr[0].attrTyp = ATT_DISPLAY_NAME;
        SelAttr[0].AttrVal.valCount = 0;
        SelAttr[0].AttrVal.pAVal = NULL;
        
        SelAttr[1].attrTyp = ATT_LEGACY_EXCHANGE_DN;
        SelAttr[1].AttrVal.valCount = 0;
        SelAttr[1].AttrVal.pAVal = NULL;
        
        // Search for all Address Book objects.
        SearchBody(pTHS, &SearchArg, pSearchRes,0);
    }

    if (pTHS->errCode) {
        LogAndAlertEvent(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_SCHEMA_SEARCH_FAILED, szInsertUL(1),
                         szInsertUL(pTHS->errCode), 0);
        return pTHS->errCode;
    }
    
    //  for each Address book, add it to the hierarchy table.
    if(*pdwIndex + pSearchRes->count >= *pdwAllocated) {
        // Table was too small, make it bigger.
        PHierarchyTableElement pNewTempData;
        (*pdwAllocated) = 2 * (*pdwIndex + pSearchRes->count);
        pNewTempData = realloc(*ppTempData,
                              (*pdwAllocated * sizeof(HierarchyTableElement)));
        if (!pNewTempData) {
            free(*ppTempData);
            *ppTempData = NULL;
            MemoryPanic((*pdwAllocated * sizeof(HierarchyTableElement)));
            RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                           DSID(FILENO, __LINE__),
                           DS_EVENT_SEV_MINIMAL);
        }
        *ppTempData = pNewTempData;
    }
    
    if(!pSearchRes->count) {
        // No address book objects at all.
        return 0;
    }
    
    pEIL = &(pSearchRes->FirstEntInf);
    for (i=0; i<pSearchRes->count; i++) {
        ATTRVAL *pVal;
        DWORD index;
        wchar_t *pTempW;
        PUCHAR  pTempA;
        
        (*ppTempData)[*pdwIndex].dwEph =
            *((DWORD *)pEIL->Entinf.pName->StringName);
        (*ppTempData)[*pdwIndex].depth = currentDepth;

        if((pEIL->Entinf.AttrBlock.attrCount == 0) ||
           ((pEIL->Entinf.AttrBlock.attrCount) &&
           (pEIL->Entinf.AttrBlock.pAttr[0].attrTyp != ATT_DISPLAY_NAME))) {
            // This doesn't have a display name.  Drop it from the list.
            continue;
        }

        pVal = pEIL->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal;

        // allocate with enough space to null terminate
        pTempW = malloc(pVal->valLen + sizeof(wchar_t));
        if(!pTempW) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                     szInsertUL(pVal->valLen + sizeof(wchar_t)),
                     NULL, NULL);
            return DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
        }
        memset(pTempW, 0, pVal->valLen + sizeof(wchar_t));
        memcpy(pTempW, pVal->pVal, pVal->valLen);
        // Null terminate.
        (*ppTempData)[*pdwIndex].displayName = pTempW;


        if (pEIL->Entinf.AttrBlock.attrCount > 1) {
            DPRINT1 (2, "Hierarchy: reading %s\n", pEIL->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal->pVal);
        }
        
        
        if ((pEIL->Entinf.AttrBlock.attrCount == 2) &&
            (pEIL->Entinf.AttrBlock.pAttr[1].attrTyp == ATT_LEGACY_EXCHANGE_DN)) {

            pVal = pEIL->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal;

            pTempA = malloc(pVal->valLen + sizeof(char));
            if(!pTempA) {
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                     szInsertUL(pVal->valLen + sizeof(char)),
                     NULL, NULL);
                return DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
            }

            memcpy(pTempA, pVal->pVal, pVal->valLen);
            pTempA[pVal->valLen]='\0';
        }
        else {
            pTempA = malloc((sizeof(GUID) * 2) + sizeof("/guid="));
            if(!pTempA) {
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                     szInsertUL((sizeof(GUID) * 2) + sizeof("/guid=")),
                     NULL, NULL);
                return DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
            }
            memcpy(pTempA, "/guid=", sizeof("/guid="));
            // Now, stringize the guid and tack it on to the end;
            for(index=0;index<sizeof(GUID);index++) {
                sprintf(&(pTempA[(2*index)+6]),"%02X",
                    ((PUCHAR)&pEIL->Entinf.pName->Guid)[index]);
            }
            pTempA[(2*index)+6]=0;

            DPRINT1 (2, "Hierarchy: reading %s\n", pTempA);
        }
        
        (*ppTempData)[*pdwIndex].pucStringDN = pTempA;

        (*pdwIndex)++;
        err = HTBuildHierarchyLayer (
                ppTempData,
                pdwAllocated,
                pdwIndex,
                pEIL->Entinf.pName,
                currentDepth+1,
                NULL,
                NULL,
                NULL,
                NULL);

        if(err) {
            return err;
        }

        pEIL = pEIL->pNextEntInf;
    }
    
    return 0;
}

/*
 * Construct the hierarchy table from the DBLayer.
 */
DWORD
HTGetHierarchyTable (
        PHierarchyTableType * DbHierarchyTable
        )
{

    // The plan is to search under the config container, looking for ABContainer
    // objects.
    DWORD               retval=DIRERR_BUILD_HIERARCHY_TABLE_FAILED;
    DWORD               numAllocated, index;
    THSTATE            *pTHS=pTHStls;
    PHierarchyTableType pTemp=NULL;
    PHierarchyTableElement pTempData=NULL;

    if(!gfDoingABRef) {
        // The DBLayer isn't tracking address book contents, so don't bother
        // building a hierarchy.
        return DIRERR_BUILD_HIERARCHY_TABLE_FAILED;
    }
    
    Assert(!pTHS->pDB);
    DBOpen(&(pTHS->pDB));
    __try { //Except
        __try { //Finally
            pTemp = malloc(sizeof(HierarchyTableType));
            if(!pTemp) {
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                         szInsertUL(sizeof(HierarchyTableType)),
                         NULL, NULL);
                retval = DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
                __leave;
            }
            memset(pTemp, 0, sizeof(HierarchyTableType));
            
            // Start by assuming no GAL, set to an invalid DNT
            pTemp->pGALs = NULL;
            pTemp->GALCount = 0;
            pTemp->pTemplateRoots = NULL;
            pTemp->TemplateRootsCount = 0;
            
            numAllocated = 100;
            pTempData = malloc(100 * sizeof(HierarchyTableElement));
            if(!pTempData) {
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED,
                         szInsertUL(100 * sizeof(HierarchyTableElement)),
                         NULL, NULL);
                retval = DIRERR_HIERARCHY_TABLE_MALLOC_FAILED;
                __leave;
            }

                
            memset(pTempData, 0 , 100 * sizeof(HierarchyTableElement));
            index = 0;

            retval = HTBuildHierarchyLayer (
                    &pTempData,
                    &numAllocated,
                    &index,
                    NULL,
                    0,
                    &pTemp->GALCount,
                    &pTemp->pGALs,
                    &pTemp->TemplateRootsCount,
                    &pTemp->pTemplateRoots);

            pTemp->Table = pTempData;
            pTemp->Size = index;
            pTemp->Version = 1;

            if(!retval) {
                *DbHierarchyTable = pTemp;
            }
        }
        __finally {
            DBClose(pTHS->pDB,TRUE);
        }
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        retval = DIRERR_BUILD_HIERARCHY_TABLE_FAILED;
        LogUnhandledError(retval);
    }

    if(retval) {
        if(pTempData) {
            free(pTempData);
        }
        if(pTemp) {
            free(pTemp);
        }
        *DbHierarchyTable = NULL;
        
    }
             
    return retval;
    
}

    
/**************************************
*
*  Given an address book container dnt, return the number of objects
*  which list that address book container as one they show in.
*  Called from the address book (nspis layer)
*
***************************************/

DWORD
GetIndexSize (
        THSTATE *pTHS,
        DWORD ContainerDNT
        )
{
    DWORD count, cbActual;

    if(ContainerDNT == INVALIDDNT) {
        return 0;
    }

    
    if(pTHS->pDB->DNT != ContainerDNT) {
        if(DBTryToFindDNT(pTHS->pDB, ContainerDNT)) {
            // couldn't find this object
            return 0;
        }
    }

    Assert(pTHS->pDB->DNT == ContainerDNT);
    
    if(DBGetSingleValue (pTHS->pDB,
                         FIXED_ATT_AB_REFCOUNT,
                         &count,
                         sizeof(count),
                         &cbActual) ||
       cbActual != sizeof(count)) {
        // error reading the value.  Say the container is empty.
        return 0;
    }
    
    return count;
}



BOOL
HTCompareHierarchyTables (
        PHierarchyTableType NewTable,
        PHierarchyTableType HierarchyTable
        )
// Compare the structure of two hierarchy tables.  One side effect, if the
// structure of the two tables are the same, set the gal of the second table to
// be the gal of the first table.     
{
    PHierarchyTableElement NewTableElement=NULL;
    PHierarchyTableElement HierarchyTableElement=NULL;
    DWORD                  i;
    
    if(!NewTable || !HierarchyTable)
        return FALSE;
    
    if(NewTable->Size != HierarchyTable->Size)
        return FALSE;
    
    for(i=0;i<NewTable->Size;i++) {
        NewTableElement = &(NewTable->Table[i]);
        HierarchyTableElement = &(HierarchyTable->Table[i]);
        
        if((NewTableElement->dwEph != HierarchyTableElement->dwEph) ||
           (NewTableElement->depth != HierarchyTableElement->depth)   )
            return FALSE;
        
        if(strcmp(NewTableElement->pucStringDN,
                  HierarchyTableElement->pucStringDN))
            return FALSE;
        
        if(wcscmp(NewTableElement->displayName,
                  HierarchyTableElement->displayName))
            return FALSE;
    }

    // OK, the structures are the same except for the GALs and template roots.
    // Check'em 
    if((HierarchyTable->GALCount != NewTable->GALCount) ||
       (HierarchyTable->TemplateRootsCount != NewTable->TemplateRootsCount) ) {
        return FALSE;
    }
    // Assume they are sorted the same.
    if(memcmp(HierarchyTable->pGALs,
              NewTable->pGALs,
              HierarchyTable->GALCount * sizeof(DWORD))) {
        return FALSE;
    }

    // Assume they are sorted the same.
    if(memcmp(HierarchyTable->pTemplateRoots,
              NewTable->pTemplateRoots,
              HierarchyTable->TemplateRootsCount * sizeof(DWORD))) {
        return FALSE;
    }
    
    // OK, it's all the same
    return TRUE;
}


DWORD
HTSortSubHierarchy(
        PHierarchyTableType    ptHierTab,
        DWORD *pSortedTable,
        DWORD SortedTableIndex,
        DWORD RawTableIndex,
        DWORD SortDepth
        )
/*++
  Worker routine called by HTSorteByLocale.  Sorts a single batch of siblings in
  the hierarchy table.
--*/
{
    DWORD NumFound=0, err;
    DWORD i;
    DBPOS *pDB = pTHStls->pDB;
    
    // First, find all the objects at level 0 and stuff them into the table.
    for(i=RawTableIndex;
        i< ptHierTab->Size && SortDepth <= ptHierTab->Table[i].depth;
        i++) {
        
        if(ptHierTab->Table[i].depth == SortDepth) {
            // Found one.  Put it in the sort table
            err = DBInsertSortTable(
                    pDB,
                    (PCHAR)ptHierTab->Table[i].displayName,
                    wcslen(ptHierTab->Table[i].displayName) * sizeof(wchar_t),
                    i);
            if(err) 
                return err;
            NumFound++;
        }
    }

    if(!NumFound) {
        // No objects at this depth.
        return 0;
    }

    Assert(ptHierTab->Size >= (SortedTableIndex + NumFound));
    
    // Move the bottom of the array down to make room
    memmove(&pSortedTable[SortedTableIndex + NumFound],
            &pSortedTable[SortedTableIndex],
            (ptHierTab->Size - SortedTableIndex - NumFound) * sizeof(DWORD));
    
    // Now, peel them out into the sortedtable
    
    err = DBMove(pDB, TRUE, DB_MoveFirst);
    i = SortedTableIndex;
    while(err == DB_success)  {
        err = DBGetDNTSortTable(pDB,&pSortedTable[i++]);
        if(err)
            return err;
        err = DBDeleteFromSortTable(pDB);
        if(err)
            return err;
        err = DBMove(pDB, TRUE, DB_MoveFirst);
    }            

    Assert((SortedTableIndex + NumFound) == i);
    
    return 0;
}

DWORD
HTSortByLocale (
        PHierarchyTableType    ptHierTab,
        DWORD                  SortLocale,
        DWORD                 *pSortedIndex
        )
/*++    

  Given a hierarchy table and a locale, create an index array filled with values
  that if used as indices to the hierarchy table yield a sorted hierarchy table.

--*/
{
    THSTATE *pTHS=pTHStls;
    DWORD NumFound = 0;
    DWORD i, err;
    ATTCACHE *pACDisplayName;
    DBPOS *pDB = pTHS->pDB;

    pACDisplayName = SCGetAttById(pTHS, ATT_DISPLAY_NAME);

    // Open a sort table to do this sorting.
    err = DBOpenSortTable(pDB, SortLocale, 0, pACDisplayName);
    if(err)
        return err;
    
    // Start with things at the top of the hierarchy.
    err = HTSortSubHierarchy(ptHierTab,
                             pSortedIndex,
                             0,
                             0,
                             0);
    if(err)
        return err;
    
    // Now, deal with children
    for(i=0;i<ptHierTab->Size;i++) {
        err = HTSortSubHierarchy(ptHierTab,
                                 pSortedIndex,
                                 i+1,
                                 pSortedIndex[i]+1,
                                 ptHierTab->Table[pSortedIndex[i]].depth + 1);
        if(err)
            return err;
    }
    
    // Close the table we're done.
    DBCloseSortTable(pDB); 

    return 0;
}

void
HTGetHierarchyTablePointer (
        PHierarchyTableType    *pptHierTab,
        DWORD                  **ppIndexArray,
        DWORD                  SortLocale
        )
/*++
  Given a sortlocale, return a hierarchy table and an index array.  If you
  access the hierarchy table directly, the objects compose a tree where siblings
  are arranged arbitrarily.  If you indirect through the index array, the table
  is sorted by display name. 


  Correct tree structure, but not sorted.
  for(i=0; i< size; i++) {
      (*pptHierTab)->Table[i];
  } 

  Sorted by DisplayName
  for(i=0; i< size; i++) { 
      (*ptHierTab)->Table[pSortedIndex[i]]; 
  } 


  If the table can't be sorted, the index array is filled with 0,1,...N, and you
  get the same answer from these two code fragments.


  Allocates in THS heap for the index array.  The hierarchy table is in malloc
  heap, should NOT be freed by caller, will be freed by Hiearchy Table code in a
  safe, delayed fashion.
  
--*/

{
    THSTATE *pTHS=pTHStls;
    DWORD i;

    *pptHierTab = HierarchyTable;
    *ppIndexArray=THAllocEx(pTHS, (*pptHierTab)->Size * sizeof(DWORD));

    if(HTSortByLocale(*pptHierTab, SortLocale, *ppIndexArray)) {
        // Failed to get a locale based hierarchy index.  Create a default.
        for(i=0;i<(*pptHierTab)->Size;i++) {
            (*ppIndexArray)[i] = i;
        }
    }
    
    return;
}



DWORD
findBestTemplateRoot(
        THSTATE *pTHS,
        DBPOS   *pDB,
        PHierarchyTableType   pMyHierarchyTable,
        PUCHAR   pLegacyDN,
        DWORD    cbLegacyDN)
/*++     
  Description
      Given a legacy exchange DN and a hierarchy table, visit the objects
      specified as TemplateRoots. Compare the LegacyExchangeDN of these objects
      with the one passed in.  Return the most specific match.

      If there is no match and the pLegacyDN passed in was non-NULL, simply
      return the template with the shortest LegacyExchangeDN.

  Parameters      
      pTHS - the thread state
      pDB  - the dbpos to use.
      pMyHierarchyTable - the hierarchyTable to get template roots from
      pDNTs - array of DNTs (may contain INVALIDDNT)
      pLegacyDN - the legacy exchange dn we're using to find the best template
              root for.

  Returns
      THe DNT of the best Template Root found.  Note that that might be
      INVALIDDNT. 
--*/
{
    DWORD    i;
    DWORD    cbActual;
    PUCHAR   pVal = NULL;
    DWORD    cbBest=0;
    DWORD    cbAlloced = 0;
    DWORD    TemplateDNT = INVALIDDNT;
    DWORD    err;
    ATTCACHE *pAC = SCGetAttById(pTHS, ATT_LEGACY_EXCHANGE_DN);

    Assert(pAC);

    if(!pLegacyDN) {
        // In this case, we're going to be looking for the SHORTEST value.  Set
        // the bounds case appropriately.
        cbBest = 0xFFFFFFFF;
    }

    for(i=0;i<pMyHierarchyTable->TemplateRootsCount;i++) {
        if(DBTryToFindDNT(pDB, pMyHierarchyTable->pTemplateRoots[i])) {
            // Hmm.  Doesn't seem to be a good object anymore.
            continue;
        }

        err = DBGetAttVal_AC(pDB,
                             1,
                             pAC,
                             DBGETATTVAL_fREALLOC,
                             cbAlloced,
                             &cbActual,
                             &pVal);
        switch(err) {
        case 0:
            cbAlloced = max(cbAlloced, cbActual);
            // Read a value.
            break;
            
        case  DB_ERR_NO_VALUE:
            // No value.  Make sure we set the size correctly.
            cbActual = 0;
            // problem getting the legacy exchange DN of this object.
            break;

        default:
            // Huh?  just skip this one.
            continue;
        }
        
        
        if(pLegacyDN) {
            // Looking for the longest match.
            if((cbActual <= cbBest) ||
               // Can't be better than the one we already have.
               (cbActual > cbLegacyDN) ||
               // And, it's longer than the DN on the object, so can't match.
               (_strnicmp(pVal, pLegacyDN, cbActual))
               // No match.  These are teletex, no CompareStringW is needed.
                                                     ) {
                continue;
            }
            
        }
        else {
            // We're actaully just looking for the shortest legacy exchange dn
            // on a template root.
            if(cbActual >= cbBest) {
                // Nope, not better than what we have;
                continue;
            }
        }

        // This is the best match we've had.
        cbBest = cbActual;
        TemplateDNT = pMyHierarchyTable->pTemplateRoots[i];
    }
    

    THFreeEx(pTHS,pVal);
    
    return TemplateDNT;
}

DWORD
findBestGALInList(
        THSTATE *pTHS,
        DBPOS   *pDB,
        DWORD   *pDNTs,
        DWORD    cDNTs
        )
/*++     
  Description
      Given a list of DNTs, go look at the objects and find the DNT which
      1) represents a non-deleted address book container
      2) The caller has the rights to open the address book container
      3) Has the most entries in the container.

      If none of the DNTs meets criteria 1 or 2, return INVALIDDNT.

  Parameters      
      pTHS - the thread state
      pDB  - the dbpos to use.
      pDNTs - array of DNTs (may contain INVALIDDNT)
      cDNTs - number of DNTs in that array.

  Returns
      THe DNT of the best GAL found.  Note that that might be INVALIDDNT.
--*/
{
    ATTR                *pAttr=NULL;
    DWORD                cOutAtts;
    DWORD                i, thisSize, temp, cbActual;
    DWORD                bestDNT = INVALIDDNT;
    DWORD                maxSize = 0;
    ATTCACHE            *pAC[3];
    CLASSCACHE          *pCC=NULL;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    PDSNAME              pName=NULL;

    pAC[0] = SCGetAttById(pTHS, ATT_OBJECT_CLASS);
    pAC[1] = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
    pAC[2] = SCGetAttById(pTHS, ATT_NT_SECURITY_DESCRIPTOR);
    
    for(i=0;i<cDNTs;i++) {
        if(pDNTs[i] == INVALIDDNT) {
            // Can't be a good GAL
            continue;
        }
        if(DBTryToFindDNT(pDB, pDNTs[i])) {
            // Couldn't find the object
            continue;
        }
        
        temp = 0;
        if(DBGetSingleValue(pDB,
                            FIXED_ATT_OBJ,
                            &temp,
                            sizeof(temp),
                            NULL)) {
            // Not marked as an object, therefore assume not an object.
            continue;
        }
        if(0 == temp) {
            // Marked as definitely not an object
            continue;
        }
        
        temp = 0;
        if(!DBGetSingleValue(pDB,
                             ATT_IS_DELETED,
                             &temp,
                             sizeof(temp),
                             NULL) &&
           temp) {
            // It's deleted.  This won't work.
            continue;
        }
        
        
        // Read some attributes.
        if(DBGetMultipleAtts(pDB,
                             3,
                             pAC,
                             NULL,
                             NULL,
                             &cOutAtts,
                             &pAttr,
                             (DBGETMULTIPLEATTS_fGETVALS |
                              DBGETMULTIPLEATTS_fEXTERNAL |
                              DBGETMULTIPLEATTS_fSHORTNAMES),
                             0)) {
            // Couldn't read the attributes we needed.
            continue;
        }
        
        if(cOutAtts != 3) {
            // Not all the attributes were there.
            continue;
        }
        
        if(*((ATTRTYP *)pAttr[0].AttrVal.pAVal->pVal) !=
           CLASS_ADDRESS_BOOK_CONTAINER) {
            // Wrong object class. Don't use this container.
            
            THFreeEx(pTHS,pAttr[0].AttrVal.pAVal->pVal);
            THFreeEx(pTHS,pAttr[1].AttrVal.pAVal->pVal);
            THFreeEx(pTHS,pAttr[2].AttrVal.pAVal->pVal);
            THFreeEx(pTHS,pAttr);
            pAttr = NULL;
            continue;
        }
        
        
        pCC = SCGetClassById(pTHS, CLASS_ADDRESS_BOOK_CONTAINER);
        pName = (DSNAME *)pAttr[1].AttrVal.pAVal->pVal;
        pNTSD = pAttr[2].AttrVal.pAVal->pVal;
        
        
        if(IsControlAccessGranted(pNTSD,
                                  pName,
                                  pCC,
                                  RIGHT_DS_OPEN_ADDRESS_BOOK,
                                  FALSE)) {
            // Can open the container.
            
            if((!DBGetSingleValue (pDB,
                                   FIXED_ATT_AB_REFCOUNT,
                                   &thisSize,
                                   sizeof(thisSize),
                                   &cbActual)) &&
               (cbActual == sizeof(thisSize)) &&
               (thisSize > maxSize)) {
                // Value is the greatest so far.
                // Remember this container as the GAL we want.
                bestDNT = pDNTs[i];
                maxSize = thisSize;
            }
        }
        // OK, clean up all this stuff.
        THFreeEx(pTHS,pAttr[0].AttrVal.pAVal->pVal);
        THFreeEx(pTHS,pAttr[1].AttrVal.pAVal->pVal);
        THFreeEx(pTHS,pAttr[2].AttrVal.pAVal->pVal);
        THFreeEx(pTHS,pAttr);
        pAttr = NULL;
    }
    
    return bestDNT;
}

void
htGetCandidateGals (
        THSTATE *pTHS,
        DBPOS *pDB,
        PHierarchyTableType  pMyHierarchyTable,        
        DWORD **ppGalCandidates,
        DWORD *pcGalCandidates )
{
    DWORD index;
    DWORD               *pDNTs = NULL;
    DWORD                cDNTs;
    DWORD                cDNTsAlloced;
    DWORD                cbActual;
    DWORD                ThisDNT, *pThisDNT = &ThisDNT;
    DWORD                i, j;

    *ppGalCandidates = NULL;
    *pcGalCandidates = 0;
    
    // Set up some bookkeeping.
    // 1) cDNTs is the count of DNTs we have found that are GAL
    // candidates 
    cDNTs = 0;
    // 2) Allocate a buffer for GAL candidates.  Make it as big as the
    //    number of GALS.
    cDNTsAlloced = pMyHierarchyTable->GALCount;
    pDNTs = THAllocEx(pTHS, (cDNTsAlloced * sizeof(DWORD)));
    
    // Get the DNTs of the containers this record is in.
    index = 1;
    while(!DBGetAttVal(
            pDB,
            index,
            ATT_SHOW_IN_ADDRESS_BOOK,
            (DBGETATTVAL_fCONSTANT | DBGETATTVAL_fINTERNAL),
            sizeof(DWORD),
            &cbActual,
            (PUCHAR *)&pThisDNT)) {
        // Read a value.  Put it in the list.
        if(cDNTs == cDNTsAlloced) {
            cDNTsAlloced = (cDNTsAlloced * 2);
            pDNTs = THReAllocEx(pTHS,
                                pDNTs,
                                cDNTsAlloced * sizeof(DWORD));
        }
        pDNTs[cDNTs] = ThisDNT;
        cDNTs++;
        index++;
    }
    
    
    if(cDNTs) {
        // We actually have a list of DNTs of address books we
        // are in. 
        // Sort them and trim out any that are not GALs.
        qsort(pDNTs, cDNTs, sizeof(DWORD), AuxDNTCmp);
        
        i=0;
        j=0;
        while(i < cDNTs && j < pMyHierarchyTable->GALCount) {
            if(pDNTs[i] < pMyHierarchyTable->pGALs[j]) {
                pDNTs[i] = INVALIDDNT;
                i++;
            }
            else if(pDNTs[i] == pMyHierarchyTable->pGALs[j]) {
                i++;
                j++;
            }
            else {
                Assert(pDNTs[i] > pMyHierarchyTable->pGALs[j]);
                j++;
            }
        }
        
        // If we ran out of pMyHierarchyTable->GALCount and i !=
        // cDNTs, we can set cDNTs to i to ignore the end of the
        // pDNTs list, since the DNTs in the rest of the list
        // aren't GALs 
        cDNTs = i;
    }

    // pDNTs holds an array of DNTs which are either candidate GALS or
    // INVALIDDNT. 
    
    *ppGalCandidates = pDNTs;
    *pcGalCandidates = cDNTs;
    
}


void
HTGetGALAndTemplateDNT (
        NT4SID *pSid,
        DWORD   cbSid,
        DWORD  *pGALDNT,
        DWORD  *pTemplateDNT
        )
/*++
  Description:
      Given an object sid,
      1) find the object with this sid in the directory.
      2) get the list of address books it's in.
      3) Intersect this list with the list of GALs
      4) If the resulting list is empty, use the list of all GALS.  Otherwise,
          use the resulting list.
      5) From the list chose, find the biggest GAL we have the rights to open.

      6) Also, find the best Template root to use.
      
      We might be called without a sid if the MAPI client we're doing this for
      said to be anonymous.  Also, steps 2 and 3 might result in an empty list.

  Parameters:
      pSid - the sid of the object to look for.
      cbSid - the size of the sid.

  Returns:
      Nothing.
--*/
{
    PHierarchyTableType  pMyHierarchyTable;
    DBPOS               *pDB=NULL;

    
    DWORD                GALDNT = INVALIDDNT;
    BOOL                 fDidGAL = FALSE;
    DWORD                TemplateRootDNT = INVALIDDNT;
    BOOL                 fDidTemplateRoots = FALSE;
    THSTATE             *pTHS = pTHStls;

    // Grab a pointer to the current Global Hierarchy table.  We don't want to
    // get confused if someone replaces the data structure while we are in here.
    pMyHierarchyTable = HierarchyTable;

    // Assume no GAL or Template root will be found.
    *pGALDNT = INVALIDDNT;
    *pTemplateDNT = INVALIDDNT;

    if(!pMyHierarchyTable->GALCount) {
        // No GALS.  So, INVALIDDNT was the best we could do.
        fDidGAL = TRUE;
    }
    else if (pMyHierarchyTable->GALCount==1) {
        // Only 1 GAL.  It's the best we can do anyway, so just return it.
        Assert(pMyHierarchyTable->pGALs);
        *pGALDNT = (pMyHierarchyTable->pGALs[0]);
        fDidGAL = TRUE;
    }

    if(!pMyHierarchyTable->TemplateRootsCount) {
        // No TemplateRoots.  So, INVALIDDNT was the best we could do.
        fDidTemplateRoots = TRUE;
    }
    else if (pMyHierarchyTable->TemplateRootsCount==1) {
        // Only 1 TemplateRoot.  It's the best we can do anyway, so just return
        // it. 
        Assert(pMyHierarchyTable->pTemplateRoots);
        TemplateRootDNT = *pTemplateDNT = (pMyHierarchyTable->pTemplateRoots[0]);
        fDidTemplateRoots = TRUE;
    }    

    if(fDidTemplateRoots && fDidGAL) {
        // Best we can do already.
        return;
    }
    
    DBOpen(&pDB);
    __try {
        //
        // We have multiple GALs and/or multiple TemplateRoots in the global
        // data structure.  We need to try to pick the best values from these
        // lists.  We do that by finding the object whose sid we were given as a
        // parameter, then doing tests based on info on that object.  
        //
        if(pSid && cbSid) {
            // These variables are used to find the object with the SID we were
            // given. 
            ATTCACHE            *pACSid;
            NT4SID               mySid;
            INDEX_VALUE          IV;
            
            // We were given a SID.  Try to find this object.
            pACSid = SCGetAttById(pTHS, ATT_OBJECT_SID);
            Assert(pACSid);
            DBSetCurrentIndex(pDB, 0, pACSid, FALSE);
            Assert(cbSid <= sizeof(mySid));
            memcpy(&mySid, pSid, cbSid);
            InPlaceSwapSid(&mySid);
            IV.pvData = &mySid;
            IV.cbData = cbSid;
            if(!DBSeek(pDB, &IV, 1, DB_SeekEQ)) {
                // Found the object.
                //
                // Now, if we still need a GAL, use info on
                // the object to pick the best GAL we can.  Note that we might
                // not be able to pick a GAL based on the info on the object.
                if(!fDidGAL) {
                    DWORD *pGalCandidates = NULL;
                    DWORD  cGalCandidates = 0;
                    
                    // Start by getting the intersection of the address books we
                    // are in and the global list of GAL containers.
                    htGetCandidateGals(pTHS,
                                       pDB,
                                       pMyHierarchyTable,        
                                       &pGalCandidates,
                                       &cGalCandidates);  

                    if(cGalCandidates) {
                        // We actually have some GAL candidates that this
                        // object is in.  See which of them is the best.
                        GALDNT = findBestGALInList(pTHS,
                                                   pDB,
                                                   pGalCandidates,
                                                   cGalCandidates);

                        DPRINT1 (2, "Best GAL1: %d\n", GALDNT);
                    }

                    if(pGalCandidates) {
                        THFreeEx(pTHS, pGalCandidates);
                    }
                    
                    if(GALDNT != INVALIDDNT) {
                        // We have found a GAL.
                        fDidGAL = TRUE;
                    }
                }
                
                
                // Now, if we still need a TemplateRoot, use info on the object
                // to pick the best TemplateRoot we can.  Note that we might 
                // not be able to pick a TemplateRoot based on the info on the
                // object.
                
                if(!fDidTemplateRoots) {
                    PUCHAR pLegacyDN = NULL;
                    DWORD  cbActual;
                    
                    // Start by getting the LegacyExchangeDN of the object.
                    if(!DBGetAttVal(pDB,
                                    1,
                                    ATT_LEGACY_EXCHANGE_DN,
                                    0,
                                    0,
                                    &cbActual,
                                    (PUCHAR *)&pLegacyDN)) {
                        // We have the Legacy DN if one exists on the object.
                        Assert(pLegacyDN);
                        
                        TemplateRootDNT = findBestTemplateRoot(
                                pTHS,
                                pDB,
                                pMyHierarchyTable,
                                pLegacyDN,
                                cbActual);
                        
                        THFreeEx(pTHS, pLegacyDN);
                    }
                    
                    if(TemplateRootDNT != INVALIDDNT) {
                        fDidTemplateRoots = TRUE;
                    }
                }
            }
        }

        
        if(!fDidGAL) {
            // Still haven't got a good GAL.  This could be because we couldn't
            // find the object whose sid we were told to look up, or because we
            // did find it, but the info on it was insufficient to pick a GAL.
            // Last chance here, try to pick a GAL from the full list of GALS in
            // the hierarchy table.
            GALDNT = findBestGALInList(pTHS, pDB,
                                       pMyHierarchyTable->pGALs,
                                       pMyHierarchyTable->GALCount);

            DPRINT1 (2, "Best GAL2: %d\n", GALDNT);
        }

        if(!fDidTemplateRoots) {
            // Still haven't got a good TemplateRoot.  This could be because we
            // couldn't find the object whose sid we were told to look up, or
            // because we did find it, but the info on it was insufficient to
            // pick a TemplateRoot. 
            // Last chance here, try to pick a TemplateRoot from the full list
            // of TemplateRoots in the hierarchy table.
            TemplateRootDNT = findBestTemplateRoot(
                    pTHS,
                    pDB,
                    pMyHierarchyTable,
                    NULL,
                    0);
        }
        
        // OK, we now have the best GAL and template root we can get.
         
    }
    __finally {
        DBClose(pDB,TRUE);
    }
    
    *pGALDNT = GALDNT;
    *pTemplateDNT = TemplateRootDNT;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdadd.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdadd.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirAddEntry API.

    DirAddEntry() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <prefix.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <sdprop.h>                     // Critical section for adds.
#include <gcverify.h>                   // GC DSNAME verification
#include <ntdsctr.h>                    // Perf Hook
#include <quota.h>

// SAM interoperability headers
#include <mappings.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "drautil.h"
#include "debug.h"                      // standard debugging header
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#define DEBSUB "MDADD:"                 // define the subsystem for debugging

// MD layer headers.
#include "drserr.h"

#include <fileno.h>
#define  FILENO FILENO_MDADD

#include <dnsapi.h>                     // DnsValidateDnsName
#include <dsgetdc.h>                    // DsValidateSubnetNameW

int SetAtts(THSTATE *pTHS,
            ADDARG *pAddArg,
            CLASSCACHE* pClassSch,
            BOOL *pfHasEntryTTL, 
            ULONG *cNonReplAtts,
            ATTRTYP **pNonReplAtts,
            const BOOL fAddingDeleted );

int SetSpecialAtts(THSTATE *pTHS,
                   CLASSCACHE **ppClassSch,
                   ADDARG *pAddArg,
                   DWORD ActiveContainerID,
                   CLASSSTATEINFO  *pClassInfo,
                   BOOL fHasEntryTTL);

int SetSpecialAttsForAuxClasses(THSTATE *pTHS,
                                ADDARG *pAddArg,
                                CLASSSTATEINFO  *pClassInfo,
                                BOOL fHasEntryTTL);

int StripAttsFromDelObj(THSTATE *pTHS,
                        DSNAME *pDN);
int SetNamingAtts(THSTATE *pTHS, CLASSCACHE *pClassSch, DSNAME *pDN);
int SetShowInAdvancedViewOnly(THSTATE *pTHS,
                              CLASSCACHE *pCC);

int
AddAutoSubRef(THSTATE *pTHS,
              ULONG id,
              ADDARG *pAddArg,
              BOOL fAddingDeleted);


DWORD ProcessActiveContainerAdd(THSTATE *pTHS,
                                CLASSCACHE *pClassSch,
                ADDARG *pAddArg,
                DWORD ActiveContainerID);

BOOL
SetClassSchemaAttr(
    THSTATE *pTHS,
    ADDARG* pAddArg
);

BOOL
SetAttrSchemaAttr(
    THSTATE *pTHS,
    ADDARG* pAddArg
);

ULONG AppendNonReplAttsToModifiedList(THSTATE *pTHS, 
                                      ULONG * pcModAtts,
                                      ATTRTYP **ppModAtts, 
                                      ULONG * pcNonReplAtts, 
                                      ATTRTYP **ppNonReplAtts);



ULONG
DirAddEntry(ADDARG  * pAddArg,
        ADDRES ** ppAddRes)
{
    THSTATE*        pTHS;
    ADDRES *        pAddRes;
    BOOL            fContinue;        // SAM loopback continuation flag
    DSNAME        * pParent;          // Used for name res
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    BOOL  RecalcSchemaNow=FALSE;
    BOOL  fNoGuid;
    BOOL  fSDPLockTaken = FALSE;

    DWORD           dwFlags;

    DPRINT1(2,"DirAddEntry(%ws) entered\n",pAddArg->pObject->StringName);


    // Initialize the THSTATE anchor and set a write sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    pTHS->fLazyCommit |= pAddArg->CommArg.fLazyCommit;
    *ppAddRes = pAddRes = NULL;

    if (eServiceShutdown) {
        return ErrorOnShutdown();
    }

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppAddRes = pAddRes = THAllocEx(pTHS, sizeof(ADDRES));
        if (pTHS->errCode) {
            __leave;
        }
        // GC verification intentially performed outside transaction scope.
        if ( GCVerifyDirAddEntry(pAddArg) )
            __leave;
        // AddNCPreProcess(), THAlloc's pCreateNC if the object being
        // created is to be added as an NC Head, instead of a regular internal
        // (to an NC) object.
        if ( AddNCPreProcess(pTHS, pAddArg, pAddRes) ) { 
            // This function returns an error, either if there was no 
            // object class or the operation tried to incorrectly add
            // an NC head.
            Assert(pTHS->errCode);
            __leave; 
        }
        
        // detect if this is an add during a SAM loopback.  if it is, then we do
        // not need to acquire the reader/writer lock.
        if (!(pTHS->fSAM && pTHS->pSamLoopback)) {
            // Enter the reader/writer critical section around adds.  Add threads are
            // the "readers", the security descriptor propagator is the "writer".  The
            // implementation of this critical section is done in the sdprop directory.
            if(!SDP_EnterAddAsReader()) {
                // The only valid reason to fail to enter as reader is if we are
                // shutting down.
                Assert(eServiceShutdown);
                ErrorOnShutdown();
                __leave;
            }
            fSDPLockTaken = TRUE;
        }
        
        SYNC_TRANS_WRITE();       /* Set Sync point - Transaction started */
        __try {
            pAddArg->pResParent = NULL;

            // Check to see if unput argument has a GUID (we need to know this
            // later for error cleanup)
            fNoGuid = fNullUuid(&pAddArg->pObject->Guid);

            // Inhibit update operations if the schema hasen't been loaded yet
            // or if we had a problem loading.

            if (!gUpdatesEnabled) {
                DPRINT(2, "Returning BUSY because updates are not enabled yet\n");
                SetSvcError(SV_PROBLEM_BUSY, DIRERR_SCHEMA_NOT_LOADED);
                __leave;
            }
            
            // If we are adding an NDNC, check to make sure we can initialize
            // and validate our NDNC info and parameters.  Specifically, we
            // set the NC Guid in pAddArg->pObject, and we set the pSDRefDom
            // in pAddArg->pCreateNC.
            if(fISADDNDNC(pAddArg->pCreateNC) &&
               AddNDNCInitAndValidate(pTHS, pAddArg->pObject, pAddArg->pCreateNC)){
                // This function returns an error, either if there was no 
                // valid SD Reference Domain to be found, or we're not supposed to
                // be the DC adding this NC Head.
                fNoGuid = TRUE; // clear GUID on error.
                Assert(pTHS->errCode);
                __leave;
            }

            // We need to perform NameRes on the parent of the new object,
            // to determine if we hold the NC that the object will be in,
            // unless pCreateNC != NULL, in which case we're adding an
            // NC Head and we need no parent for it.

            pParent = THAllocEx(pTHS, pAddArg->pObject->structLen);
            
            if (TrimDSNameBy(pAddArg->pObject,
                             1,
                             pParent)) {
                // A non-zero return code means that the name couldn't be
                // shortened  by even a single AVA.  There are two possible
                // cases: either the name is Root, or the name is bad.
                if (IsRoot(pAddArg->pObject)) {
                    // They're trying to add the root, but are claiming
                    // that it's not the head of an NC.  Since nothing
                    // is above the root, however, it cannot be inside
                    // an NC, and so this request is erroneous.
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                DIRERR_ROOT_MUST_BE_NC);
                }
                else {
                    // If the name isn't root, but still can't be trimmed,
                    // then the name passed in must have been junk.
                    SetNamError(NA_PROBLEM_BAD_NAME,
                                pAddArg->pObject,
                                DIRERR_BAD_NAME_SYNTAX);
                }
            }
            else{
                // Ok, we obtained the name of the parent of the object
                // we want to add, so now we need to do NameRes on that
                // object.
                if (!pAddArg->pCreateNC) {
                    // We're doing a normal add, so we need to check to
                    // see if we're holding a copy (because we can
                    // only add objects into NCs we hold master copies of).
                    // In order to enforce the restriction that we can only
                    // write master copies, we will diddle the commarg to
                    // forbid the use of a copy before doing name res.
                    dwFlags = 0;
                    pAddArg->CommArg.Svccntl.dontUseCopy = TRUE;
                }
                else {
                    // This is an abnormal add, in that we don't really
                    // have to have an object above us, we don't need
                    // a writable copy, etc.  This branch is not normally
                    // taken except during NC Head creation, which is
                    // during intial tree construction, or during an NDNC
                    // addition.
                    dwFlags = (  NAME_RES_PHANTOMS_ALLOWED 
                               | NAME_RES_VACANCY_ALLOWED);
                    pAddArg->CommArg.Svccntl.dontUseCopy = FALSE;
                }
                if (DoNameRes(pTHS,
                              dwFlags,
                              pParent,
                              &pAddArg->CommArg,
                              &pAddRes->CommRes,
                              &pAddArg->pResParent)){
                    
                    // Name Res failed.  Error generated by NameRes may
                    // be a referral, because we resolved to a subref.
                    Assert(pTHS->errCode);
                    DPRINT(2, "Name Resolution Failed error generated\n");
                    if (referralError == pTHS->errCode) {
                        // We generated a referral, but it's going to
                        // be a referral for the *parent* of the object
                        // being added, not the object itself!  We need
                        // to reach in and touch up the referral so that
                        // it has the original target name.
                        Assert(NameMatched(pParent,
                                 pTHS->pErrInfo->RefErr.Refer.pTarget));
                        pTHS->pErrInfo->RefErr.Refer.pTarget =
                          pAddArg->pObject;
                    }
                }
                else{
                    // Ok, we're adding a normal object inside an NC
                    // that we hold a master copy of.  Let'er rip
                    if ( (0 == SampAddLoopbackCheck(pAddArg,
                                                    &fContinue)) &&
                            fContinue ) {
                        LocalAdd(pTHS, pAddArg, FALSE);
                    }
                }
            }
        }
        __finally {
            // Security errors are logged separately
            if (pTHS->errCode != securityError) {
                BOOL fFailed = (BOOL)(pTHS->errCode || AbnormalTermination());

                LogEventWithFileNo(
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         fFailed ? 
                            DS_EVENT_SEV_VERBOSE :
                            DS_EVENT_SEV_INTERNAL,
                         fFailed ? 
                            DIRLOG_PRIVILEGED_OPERATION_FAILED :
                            DIRLOG_PRIVILEGED_OPERATION_PERFORMED,
                         szInsertSz(""),
                         szInsertDN(pAddArg->pObject),
                         NULL,
                         FILENO);
            }

            if (pTHS->errCode && fNoGuid) {
                // If the update failed, we need to make sure that we don't
                // give out an invalid Guid in the input arg, where we
                // normally return the new object Guid.
                memset(&pAddArg->pObject->Guid, 0, sizeof(GUID));
            }

            // Check if we need to enque an immediate schema update or not.
            if (pTHS->errCode==0 && pTHS->RecalcSchemaNow) {
                RecalcSchemaNow = TRUE;
            }

            CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                    &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (fSDPLockTaken) {
        SDP_LeaveAddAsReader();
    }
    if (pAddRes) {
        pAddRes->CommRes.errCode = pTHS->errCode;
        pAddRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    if (RecalcSchemaNow && (pTHS->errCode == 0) && 
            ( DsaIsRunning() ) )
    {
        // We have created either (1) a new prefix as part of a successful 
        // object add, or (2) a new class with an rdnAttId not equal to CN.
        // so do an immediate cache update to bring the prefix into the cache,
        // and in case of (2), so that a new class added immediately after
        // this as a subClass of this class can inherit the proper rdnAttId
        // if it didn't specify any explicitly.
        // Since the earlier transaction is closed, open a new
        // transaction, as the blocking schema cache update call
        // expects that. Note that we pay this additional cost only in the
        // two cases listed, which will be rare.
        // Don't do this during install, as new prefixes are directly added 
        // to the table in AddObjcaching during Install, and schema classes
        // replicated in will already have a rdnAttId

        // We are here because pTHS->errCode == 0, so there should be
        // nothing in pTHS->pErrInfo

        Assert(pTHS->pErrInfo == NULL);

        __try {


            if ( (ulErrorCode = SCUpdateSchemaBlocking()) != 0) {

                // the cache update was not successful
                // [ArobindG]: What do we do here? I do not want to
                // return an error and fail the entire call since the object
                // added is already committed and is actually successful.
                // At the same time, I do not want the cache update to occur
                // in the same transaction as the object add, as I do not
                // want the cache to pick up the object before it is committed
                // (what if the commit fails for some reason? we then have
                // a schema object in cache but not in dit!!) So for now, I will
                // stick with an entry in eventlog, and fail this particular
                // transaction. In the chance case the user adds
                // a new prefix and the cache load fails here, he may not be
                // able to see the object properly till the next cache update
                // (5 minutes max, since we trigger a lazy cache update for
                // every schema object add anyway

                LogEvent(DS_EVENT_CAT_SCHEMA,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_SCHEMA_NOT_LOADED, 0, 0, 0);

            };
        }
        __finally {

            // restore pTHS->errCode and pTHS->pErrInfo to what it was before,
            // which is 0 and Null
            pTHS->errCode = 0;
            pTHS->pErrInfo = NULL;
        }
    }

    return pTHS->errCode;

} /*S_DirAdd*/

ULONG FindNcdntFromParent(
    IN  RESOBJ *    pParent,
    IN  BOOL        fIsDeletedParentOK,
    OUT ULONG *     pncdnt
    )
/*++

Routine Description:

    Derive the NCDNT that should be set for an object created under the
    specified parent.

Arguments:

    pParent   - Information about the parent of the new object

    fIsDeletedParentOK - The parent of the object can be deleted.  This
        is typically set only if the object being added is itself deleted.

    fIsPhantomParentOK - The parent of the object need not exist on this
        machine (or any other, for that matter).

    pncdnt (OUT) - On exit, holds the derived NCDNT.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    // We shouldn't have any lingering thread state errors.
    Assert( 0 == pTHStls->errCode );
    Assert(pParent);

    if ( IsRoot(pParent->pObj)) {
        // No parent; NCDNT is ROOTTAG.
        *pncdnt = ROOTTAG;
    }
    else if (FExitIt(pParent->InstanceType)) {
        // Parent is an NC head; NCDNT of child object is the
        // DNT of the parent (the NC head).
        *pncdnt = pParent->DNT;
    }
    else {
        // Parent is an interior node; NCDNT of child object
        // is the same as that of the parent.
        *pncdnt = pParent->NCDNT;
    }
    
    if (   (pParent->InstanceType & IT_UNINSTANT)
        || (pParent->IsDeleted && !fIsDeletedParentOK)) {
        SetNamError(NA_PROBLEM_NO_OBJECT,
                    pParent->pObj,
                    DIRERR_NO_PARENT_OBJECT);
    }

    return pTHStls->errCode;
}

ULONG FindNcdntSlowly(
    IN  DSNAME *    pdnObject,
    IN  BOOL        fIsDeletedParentOK,
    IN  BOOL        fIsPhantomParentOK,
    OUT ULONG *     pncdnt
    )
/*++

Routine Description:

    Derive the NCDNT that should be set for an object with the given DN.

Arguments:

    pdnObject - Name of the object for which to derive the NCDNT.

    fIsDeletedParentOK - The parent of the object can be deleted.  This
        is typically set only if the object being added is itself deleted.

    fIsPhantomParentOK - The parent of the object need not exist on this
        machine (or any other, for that matter).

    pncdnt (OUT) - On exit, holds the derived NCDNT.

Return Values:

    0 on success.
    !0 otherwise.

--*/
{
    THSTATE *pTHS=pTHStls;
    // We shouldn't have any lingering thread state errors.
    Assert( 0 == pTHS->errCode );

    if ( IsRoot( pdnObject ) )
    {
        // Derive NCDNT of the root.

        if ( !fIsPhantomParentOK )
        {
            // Can't have a real parent for the root object!
            Assert( !"Root can't have an instantiated parent!" );
            SetUpdError( UP_PROBLEM_NAME_VIOLATION, DIRERR_ROOT_MUST_BE_NC );
        }
        else
        {
            // NCDNT of the root is 0.
            *pncdnt = 0;
        }
    }
    else
    {
        // Derive NCDNT of a non-root object.

        // Get the name of the object's parent.
        DSNAME * pdnParent = THAllocEx(pTHS, pdnObject->structLen );

        if ( TrimDSNameBy( pdnObject, 1, pdnParent ) )
        {
            // If we can't trim the name (which we know is not the root),
            // the name must be syntactically incorrect.
            SetNamError(
                NA_PROBLEM_BAD_NAME,
                pdnObject,
                DIRERR_BAD_NAME_SYNTAX
                );
        }
        else
        {
            ULONG faStatus;

            // Attempt to find the parent.
            faStatus = FindAliveDSName( pTHS->pDB, pdnParent );

            if ( !(    ( FIND_ALIVE_FOUND == faStatus )
                    || (    ( FIND_ALIVE_OBJ_DELETED == faStatus )
                         && fIsDeletedParentOK
                       )
                    || (    ( FIND_ALIVE_NOTFOUND == faStatus )
                         && fIsPhantomParentOK
                       )
                  )
               )
            {
                // No qualified parent exists locally.
                SetNamError(
                    NA_PROBLEM_NO_OBJECT,
                    pdnParent,
                    DIRERR_NO_PARENT_OBJECT
                    );
            }
            else
            {
                if ( FIND_ALIVE_NOTFOUND == faStatus )
                {
                    // No parent; NCDNT is ROOTTAG.
                    *pncdnt = ROOTTAG;
                }
                else
                {
                    SYNTAX_INTEGER it;

                    // Is the parent an NC head?
                    // (Note that if GetExistingAtt() fails, it will set an
                    // appropriate error in pTHStls.)
                    if ( 0 == GetExistingAtt(
                                    pTHS->pDB,
                                    ATT_INSTANCE_TYPE,
                                    &it,
                                    sizeof( it )
                                    )
                       )
                    {
                        if (it & IT_UNINSTANT) {
                            // Parent NC is uninstantiated -- the "child" NC
                            // should hang under the root.
                            *pncdnt = ROOTTAG;
                        }
                        else if ( FExitIt( it ) )
                        {
                            // Parent is an NC head; NCDNT of child object is the
                            // DNT of the parent (the NC head).
                            *pncdnt = pTHS->pDB->DNT;
                        }
                        else
                        {
                            // Parent is an interior node; NCDNT of child object
                            // is the same as that of the parent.
                            *pncdnt = pTHS->pDB->NCDNT;
                        }
                    }
                }
            }
        }
        THFreeEx(pTHS, pdnParent);
    }

    return pTHS->errCode;
}



int
CheckNameForAdd(
    IN  THSTATE    *pTHS,
    IN  ADDARG     *pAddArg

    )
/*++

Routine Description:

    Verify the given DSNAME is a valid name for a new object; i.e., that it
    does not conflict with those of existing objects.

    NOTE: If you change this function, you may also want to change its sister
    function, CheckNameForRename().

Arguments:

    pDN - the name of the proposed new object.

Return Values:

    Thread state error code.

--*/
{
    ULONG       dbError;
    GUID        guid;
    DSNAME      GuidOnlyDN;
    ATTRVAL     AttrValRDN = {0};
    DWORD       cchRDN;
    WCHAR       szRDN[MAX_RDN_SIZE];
    ULONG       RDNType;
    DSNAME *    pParentDN;
    BOOL        fSameType;
    DWORD       actuallen;
    ATTRTYP     DBType;
    ULONG       dntGuidlessPhantomMatchedByName = INVALIDDNT;
    REMOVEARG   removeArg;
    DWORD       dwInstanceType;
    INT         fDSASaved;
    DSNAME *    pDN = pAddArg->pObject; // for code simplicity

    Assert(0 == pTHS->errCode);

    //
    // Ensure string name is locally unique.  We do this by looking for ANY
    // child of the known parent with an RDN value equal to the new 
    // value (ignore types).
    //

    // Now, get the type from the name
    dbError = GetRDNInfo(pTHS, pDN, szRDN, &cchRDN, &RDNType);
    if(dbError) {
        return SetUpdError(UP_PROBLEM_NAME_VIOLATION, dbError);
    }
        
            
    dbError = DBFindChildAnyRDNType(pTHS->pDB, 
                                    pAddArg->pResParent->DNT, 
                                    szRDN, 
                                    cchRDN);
    
    switch ( dbError ) {
    case 0:
        // Local object with this name (dead or alive) already
        // exists.

        if(fISADDNDNC(pAddArg->pCreateNC)){
            // This is an NC Head creation, probably conflicting with a sub-ref,
            // so the sub-ref must be demoted to a phantom so the NC head can
            // be added in it's place.
            
            dbError = DBGetSingleValue(pTHS->pDB,
                                       ATT_INSTANCE_TYPE,
                                       &dwInstanceType,
                                       sizeof(DWORD),
                                       &actuallen);

            if(dbError) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_MISSING_REQUIRED_ATT,
                              dbError);
            } else if(dwInstanceType != SUBREF){
                // This is not a sub-ref, must error out.
                SetUpdError(
                        UP_PROBLEM_ENTRY_EXISTS,
                        ERROR_DS_OBJ_STRING_NAME_EXISTS
                        );
            } else {
                // This is just a sub-ref, OK to delete/phantomize the object, so
                //  the NC head can be added.

                DPRINT1(1, "Deleting sub ref object (%S)\n", pDN->StringName);

                // BUGBUG with this here, we probably can kill the LocalRemove in
                // the replication path to kill an NC that is being instantiated.
                // This would make more sense, as it would localize code.

                Assert(CheckCurrency(pDN));

                memset(&removeArg, 0, sizeof(removeArg));
                removeArg.pObject = pDN;
                removeArg.fGarbCollectASAP = TRUE;
                removeArg.pMetaDataVecRemote = NULL;
                removeArg.fPreserveRDN = TRUE;
                removeArg.pResObj = CreateResObj(pTHS->pDB, pDN);

                __try{
                   
                    fDSASaved = pTHS->fDSA;
                    pTHS->fDSA = TRUE;
                
                    LocalRemove(pTHS, &removeArg);
                
                } __finally {

                    pTHS->fDSA = fDSASaved;

                }

                THFreeEx(pTHS, removeArg.pResObj);

            }
        } else {
            // Not an NC Head object.
            SetUpdError(
                    UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_OBJ_STRING_NAME_EXISTS
                    );
        }
        
        break;

    case ERROR_DS_NAME_NOT_UNIQUE:
        // the object we are adding is not unique
        SetUpdError(UP_PROBLEM_NAME_VIOLATION, ERROR_DS_NAME_NOT_UNIQUE);
        break;

    case ERROR_DS_KEY_NOT_UNIQUE:
        // No local object with this name (dead or alive) already
        // exists, but one with the same key in the PDNT-RDN table exists.  In
        // that case, we don't allow the add (since the DB would bounce this
        // later anyway).
        SetUpdError(UP_PROBLEM_NAME_VIOLATION, ERROR_DS_KEY_NOT_UNIQUE);
        break;        
        
    case ERROR_DS_OBJ_NOT_FOUND:
        // Object name is locally unique.
        break;
        
    case ERROR_DS_NOT_AN_OBJECT:
        DPRINT2(1,
                "Found phantom for \"%ls\" @ DNT %u when searching"
                " by string name.\n",
                pDN->StringName,
                pTHS->pDB->DNT
                );
        
        // We found a phantom, but not by actually looking at the type of the
        // RDN.  We need to know whether the real type in the data base is the
        // same as the type in the name passed in.
        dbError = DBGetSingleValue(pTHS->pDB,
                                   FIXED_ATT_RDN_TYPE,
                                   &DBType,
                                   sizeof(DBType),
                                   &actuallen);
        if(dbError) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_MISSING_REQUIRED_ATT,
                          dbError);
        }

        // The rdnType is stored in the DIT as the msDS_IntId, not the
        // attributeId. This means an object retains its birth name
        // even if unforeseen circumstances allow the attributeId
        // to be reused.
        fSameType = (DBType == RDNType);
        
        // Found a phantom with this name; get its GUID (if any), and figure out
        // the type of the RDN.
        dbError = DBGetSingleValue(
                    pTHS->pDB,
                    ATT_OBJECT_GUID,
                    &guid,
                    sizeof( guid ),
                    NULL
                    );

        switch (dbError) {
        case DB_ERR_NO_VALUE:
            if (fSameType) {
                // Phantom has no guid; okay to promote it to this
                // real object.
                dntGuidlessPhantomMatchedByName = pTHS->pDB->DNT;
            }
            else {
                GUID data;
                DWORD dbErr;

                // RDN type of the phantom and the new name are different.
                
                // Allow the new object to take ownership of the name --
                // rename the phantom to avoid a name conflict, then allow
                // the add to proceed.

                DPRINT (1, "Found a Phantom with a conflicting RDN\n");

                DsUuidCreate(&data);

                #ifdef INCLUDE_UNIT_TESTS
                // Test hook for refcount test.
                {
                    extern GUID gLastGuidUsedToRenamePhantom;
                    gLastGuidUsedToRenamePhantom = data;
                }
                #endif

                dbErr = DBMangleRDNforPhantom(pTHS->pDB, MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,&data);
                if(!dbErr) {
                    dbErr = DBUpdateRec(pTHS->pDB);
                }
                if(dbErr) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY,
                                         ERROR_DS_DATABASE_ERROR, dbErr);
                }
            }
            break;
            
        case 0:
            // Phantom has a guid.
            if (0 != memcmp(&guid, &pDN->Guid, sizeof(GUID))) {
                DWORD dbErr;
                
                // Either the new object had no guid specified
                // or the specified guid is different from the
                // phantom's guid.  Thus, the phantom
                // corresponds to a different object.
                
                // Allow the new object to take ownership of the name --
                // rename the phantom to avoid a name conflict, then allow
                // the add to proceed.
                dbErr = DBMangleRDNforPhantom(pTHS->pDB, MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,&guid);
                if(!dbErr) {
                    dbErr = DBUpdateRec(pTHS->pDB);
                }
                if(dbErr) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY,
                                         ERROR_DS_DATABASE_ERROR, dbErr);
                }
            }
            else {
                // phantom and objects guids match.
                if (!fSameType) {
                    // The types of the names are different, but the guids are
                    // the same.  This is just way to confusing to deal with.
                    // Bail out with an error, we're not going to allow this
                    // add.
                    //
                    // This should never happen, as we don't allow the RDN
                    // type of object classes to be changed and we don't allow
                    // an object's objectClass to be modified.

                    Assert(!"RDN type of object has changed");
                    SetUpdError(
                            UP_PROBLEM_ENTRY_EXISTS,
                            ERROR_DS_OBJ_STRING_NAME_EXISTS
                            );
                }
                // ELSE phantom and object guids and types match; okay to
                // promote phantom to this real object.
            }
            break;

        default:
            // Unforeseen error return from DBGetSingleValue()
            // while trying to retrieve the phantom's GUID.
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_UNKNOWN_ERROR,
                          dbError);
        }
        break;


    case ERROR_DS_BAD_NAME_SYNTAX:
    case ERROR_DS_NAME_TOO_MANY_PARTS:
    case ERROR_DS_NAME_TOO_LONG:
    case ERROR_DS_NAME_VALUE_TOO_LONG:
    case ERROR_DS_NAME_UNPARSEABLE:
    case ERROR_DS_NAME_TYPE_UNKNOWN:
    default:
        // Bad object name.
        SetNamError(
                NA_PROBLEM_BAD_ATT_SYNTAX,
                pDN,
                ERROR_DS_BAD_NAME_SYNTAX
                );
    }

    if ((0 == pTHS->errCode) && !fNullUuid(&pDN->Guid))
        {
        //
        // Ensure GUID is locally unique.  Make a DSName with just a guid in it.
        //
        memset(&GuidOnlyDN, 0, sizeof(GuidOnlyDN));
        GuidOnlyDN.structLen = DSNameSizeFromLen(0);
        GuidOnlyDN.Guid = pDN->Guid;
        
        dbError = DBFindDSName( pTHS->pDB, &GuidOnlyDN);

        switch (dbError) {
        case 0:
            // Local object with this GUID (dead or alive) already
            // exists.
            SetUpdError(
                    UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_OBJ_GUID_EXISTS
                    );
            break;
            
        case ERROR_DS_OBJ_NOT_FOUND:
            // Object guid is locally unique.
            break;
            
        case ERROR_DS_NOT_AN_OBJECT:
            // Found a phantom.  If it has a GUID it must be the
            // same as the one we passed to DBFindDSName().  Thus,
            // whether it has no GUID or has the same GUID as the
            // new object it's okay to promote it to this real
            // object.
            DPRINT2(1,
                    "Found phantom for \"%ls\" @ DNT %u when searching"
                    " by GUID.\n",
                    pDN->StringName,
                    pTHS->pDB->DNT
                    );
            
            // Ensure phantom's name is the same as that of the object.
            if (dntGuidlessPhantomMatchedByName != INVALIDDNT) {
                // This is the odd case where we have two distinct phantoms
                // that match the DSNAME of the object we're adding -- one by
                // string name, the other by guid.  Coalesce the two phantoms
                // into one and give it the proper name.
                DBCoalescePhantoms(pTHS->pDB,
                                   pTHS->pDB->DNT,
                                   dntGuidlessPhantomMatchedByName);
            } else {
                pParentDN = THAllocEx(pTHS,pDN->structLen);
                
                if (TrimDSNameBy(pDN, 1, pParentDN)
                    || GetRDNInfo(pTHS, pDN, szRDN, &cchRDN, &RDNType)) {
                    // Bad object name.
                    SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pDN,
                                ERROR_DS_BAD_NAME_SYNTAX);
                }
                else {
                    AttrValRDN.pVal = (BYTE *) szRDN;
                    AttrValRDN.valLen = cchRDN * sizeof(WCHAR);
                    
                    // Modify the phantom's DN to be that of the object.
                    dbError = DBResetDN(pTHS->pDB, pParentDN, &AttrValRDN);
                    if(!dbError) {
                        dbError = DBUpdateRec(pTHS->pDB);
                    }
                    
                    if (dbError) {
                        SetSvcErrorEx(SV_PROBLEM_BUSY,
                                      ERROR_DS_DATABASE_ERROR, dbError);
                    }
                }
                THFreeEx(pTHS, pParentDN);
            }
            break;
            
        case ERROR_DS_BAD_NAME_SYNTAX:
        case ERROR_DS_NAME_TOO_MANY_PARTS:
        case ERROR_DS_NAME_TOO_LONG:
        case ERROR_DS_NAME_VALUE_TOO_LONG:
        case ERROR_DS_NAME_UNPARSEABLE:
        case ERROR_DS_NAME_TYPE_UNKNOWN:
        default:
            // Bad object name.
            SetNamError(
                    NA_PROBLEM_BAD_ATT_SYNTAX,
                    pDN,
                    ERROR_DS_BAD_NAME_SYNTAX
                    );
        }
    }

    return pTHS->errCode;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Do the actual work of adding the object. If fAddingDeleted is TRUE we
*  are adding a deleted object
*/

int
LocalAdd (THSTATE *pTHS, ADDARG *pAddArg, BOOL fAddingDeleted){

    CLASSCACHE *pClassSch;
    int  err;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    ULONG cbNTSD;
    ULONG iClass, LsaClass = 0;
    DWORD ActiveContainerID;
    BOOL fAllowDeletedParent;
    ULONG cAVA;
    GUID ObjGuid;
    BOOL fFoundObjGuidInEntry;
    NT4SID ObjSid;
    DWORD cbObjSid;
    DWORD Err;
    ULONG cModAtts;
    ATTRTYP *pModAtts = NULL;
    ULONG cNonReplAtts;
    ATTRTYP *pNonReplAtts = NULL;
    CLASSSTATEINFO  *pClassInfo = NULL;
    BOOL fHasEntryTTL = FALSE;
    ULONG i;
    
    DPRINT1(2,"LocalAdd(%ws) entered\n",pAddArg->pObject->StringName);

    PERFINC(pcTotalWrites);
    INC_WRITES_BY_CALLERTYPE( pTHS->CallerType );

    // Verify that callers have properly performed name resolution
    Assert(pAddArg->pResParent);

    //
    // Log Event for tracing
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_ADDENTRY,
                     EVENT_TRACE_TYPE_START,
                     DsGuidAdd,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertDN(pAddArg->pObject),
                     NULL, NULL, NULL, NULL, NULL, NULL);

    // Get some values from the ENTRY we need for processing
    if (FindValuesInEntry(pTHS,
                          pAddArg,
                          &pClassSch,
                          &ObjGuid,
                          &fFoundObjGuidInEntry,
                          &ObjSid,
                          &cbObjSid,
                          &pClassInfo)) {
        Assert(!pClassSch);
        // We couldn't figure out what we're adding.
        goto exit;
    }

    // We better have found the class in the entry.
    Assert(pClassSch);

    // mark the CLASSINFO that this is an add operation
    if (pClassInfo) {
        pClassInfo->fOperationAdd = TRUE;
    }
    
    // See if a SID is in the entry.  If it is, copy it into the name.
    if(cbObjSid) {
        memcpy(&(pAddArg->pObject->Sid), &ObjSid, cbObjSid);
    }

    //
    // Perform Security Checks
    //

    if (DoSecurityChecksForLocalAdd(
              pAddArg,
              pClassSch,
              fFoundObjGuidInEntry ? &ObjGuid : NULL,
              fAddingDeleted))
    {
        goto exit;
    }
    
    // Check if the class is defunct in which case we don't allow its
    // instantiation, except for DSA or DRA thread.
    // Return same error as if the class does not exist

    if ((pClassSch->bDefunct)  && !pTHS->fDRA && !pTHS->fDSA) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           DIRERR_OBJ_CLASS_NOT_DEFINED);
        goto exit;
    }

    // Check to see if this is an update in an active container
    CheckActiveContainer(pAddArg->pResParent->DNT, &ActiveContainerID);
    if(ActiveContainerID) {
        if(PreProcessActiveContainer(pTHS,
                                     ACTIVE_CONTAINER_FROM_ADD,
                                     pAddArg->pObject,
                                     pClassSch,
                                     ActiveContainerID)) {
            goto exit;
        }
    }


    if (!pTHS->fDSA && !pTHS->fDRA) {
        // Perform checks that we don't want to impose of the DS itself

        // Make sure they aren't trying to add a system only class.
        if(pClassSch->bSystemOnly && !gAnchor.fSchemaUpgradeInProgress) {
            // System only.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               DIRERR_CANT_ADD_SYSTEM_ONLY);
            goto exit;
        }

        // Make sure they aren't adding anything but an instance of a
        // structural or 88 class - you can't instantiate the abstract.
        if((pClassSch->ClassCategory != DS_88_CLASS) &&
           (pClassSch->ClassCategory != DS_STRUCTURAL_CLASS)) {
            // Not a concrete class.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               DIRERR_CLASS_MUST_BE_CONCRETE);
            goto exit;
        }

        if (!SampIsClassIdAllowedByLsa(pTHS, pClassSch->ClassId))
        {
            // only LSA can add TrustedDomainObject and secret object.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        DIRERR_CANT_ADD_SYSTEM_ONLY);
            goto exit;
        }
    }

    if (!pTHS->fDRA && !pTHS->fSingleUserModeThread) {
        // check for domain rename constraints
        switch (pClassSch->ClassId) {
        case CLASS_CROSS_REF:
        case CLASS_TRUSTED_DOMAIN:
        case CLASS_NTDS_DSA:
            // these objects can not be added if a rename domain operation is in progress
            if (err = VerifyDomainRenameNotInProgress(pTHS)) {
                // Most probably, err is ERROR_DS_DOMAIN_RENAME_IN_PROGRESS
                // (but it could be another error too, such as a DB error)
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, err);
                goto exit;
            }
            break;
        }
    }

    // lock the DN against multiple simultaneous insertions

    if (Err = DBLockDN(pTHS->pDB, 0, pAddArg->pObject)) {
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, Err);
        goto exit;
    }


    /* Make sure that the object doesn't already exist*/

    // The string name of the new object must not conflict with existing
    // objects, and the object guid, if supplied, must similarly not conflict.

    if (CheckNameForAdd(pTHS, pAddArg)) {

        goto exit;
    }

    // If we have any kind of NC Head we are adding, we'll need to figure out
    // whether we have the NC head above it.

    if(fISADDNDNC(pAddArg->pCreateNC)){
        if(!(pAddArg->pResParent->InstanceType & IT_UNINSTANT)){
            pAddArg->pCreateNC->fNcAbove = TRUE;
        }
    }

    // Remove attributes from previous incarnation of this object.

    if (StripAttsFromDelObj(pTHS, pAddArg->pObject))
    {
        Assert(pTHS->errCode != 0); // something failed, gotta have an error code
        goto exit;
    }

    // Find the DNT of the NC which this object will be in
    // Save the DNT in the pDB. When we create the object we copy this field
    // to the object's record.

    fAllowDeletedParent = fAddingDeleted;

    if (!pAddArg->pCreateNC) {
        // The normal case
        FindNcdntFromParent(pAddArg->pResParent,
                            fAllowDeletedParent,
                            &pTHS->pDB->NCDNT);
    }
    else {
        // Only during tree building
        FindNcdntSlowly(pAddArg->pObject,
                        fAllowDeletedParent,
                        TRUE,
                        &pTHS->pDB->NCDNT);
    }
    if (pTHS->errCode) {
        // Failed to derive NCDNT for this object.
        goto exit;
    }

    // Update SID-only references to FPOs, if any
    for(i=0;i<pAddArg->AttrBlock.attrCount;i++) {
        if (FPOAttrAllowed(pAddArg->AttrBlock.pAttr[i].attrTyp)) {
            // We do not want to create FPOs in an NDNC. So, pass
            // INVALIDDNT as the NCDNT param so that the initial
            // check in FPOUpdateWithReference (NCDNT == gAnchor.ulDNTDomain) 
            // will fail.
            err = FPOUpdateWithReference(pTHS,
                                         pAddArg->pCreateNC ? INVALIDDNT : pTHS->pDB->NCDNT,
                                         TRUE,  // create a reference, if necessary
                                         pAddArg->CommArg.Svccntl.fAllowIntraForestFPO,
                                         pAddArg->pObject,
                                         &pAddArg->AttrBlock.pAttr[i]);
            if (err) {
                Assert(0 != pTHS->errCode);
                goto exit;
            }
        }
    }
    
    DBInitObj(pTHS->pDB);       /*Init for new object*/
    DBInitRec(pTHS->pDB);       /* Insert the row, fails or excepts */

    // Don't add the GUID if it is null (could happen if replicating
    // auto-gen subrefs for virtual containers 
    if (!fNullUuid(&pAddArg->pObject->Guid) && !fFoundObjGuidInEntry) {
        // We have a guid and it didn't come from the Entry.  Go ahead and add
        // the guid here.  If we found it in entry, we'll add it in the normal
        // path to add values.
        
        err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_GUID, sizeof(GUID),
                          &pAddArg->pObject->Guid);
        if (err && (DB_ERR_VALUE_EXISTS != err)) {
            // If we can't set the Guid, this isn't going to be much use.
            LogUnhandledError(err);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
            goto exit;
        }
    }
 
    // Don't add the SID if it's null (this can happen if it's not created yet)
    if ((pAddArg->pObject->SidLen!=0) && (cbObjSid==0)) {
	// we have a sid and it didn't come from the entry.  Add it here.
	// if we found it in the entry, we'll add it in the normal path to
	// add values.
	err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_SID, pAddArg->pObject->SidLen,
                          &pAddArg->pObject->Sid);
        if (err && (DB_ERR_VALUE_EXISTS != err)) {
            // If we can't set the Sid, then we need to bail - otherwise we'll
	    // suceed replication with the sid missing, and update the UTD and NEVER
	    // get it set right.
            LogUnhandledError(err);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
            goto exit;
        }
    }
    
    
    /* The order of these validations are important. When adding a
     * validation that may result in an update, ensure the update 
     * occurs prior to collecting the metadata with DBMetaDataModifiedList 
     */

    if (
        // Ensure attributes conform to the schema and add them to database.
        SetAtts(pTHS, pAddArg, pClassSch, &fHasEntryTTL, &cNonReplAtts, &pNonReplAtts, fAddingDeleted)
            ||
        // Assign values for all special attributes such as parent classes,
        // auxClasses, replication properties, etc.
        SetSpecialAtts(pTHS, &pClassSch, pAddArg, ActiveContainerID, pClassInfo, fHasEntryTTL)
            ||
        // Validate Dns updates and potentially update SPNs
        ValidateSPNsAndDNSHostName(pTHS,
                                   pAddArg->pObject,
                                   pClassSch,
                                   FALSE, FALSE, FALSE, TRUE)
            ||
        // Grab the meta data for use below.  This *must* be done after all
        // updates have been made or changes may never replicate off!  
        ((err = DBMetaDataModifiedList(pTHS->pDB, &cModAtts, &pModAtts))
              && SetSvcError(SV_PROBLEM_DIR_ERROR, err))
            ||
        // Append the list of non-replicated attributes to the list of 
        // modified attributes, and pass it to ValidateObjClass. Note
        // that the list of modified attribute returned by DBMetaDataModifiedList()
        // does not contain the non-replicated attributes.
        (err = AppendNonReplAttsToModifiedList(pTHS, &cModAtts,&pModAtts, 
                                                     &cNonReplAtts, &pNonReplAtts))
            ||
        // Insure all mandatory attributes are present and all others
        // are allowed.
        ValidateObjClass(pTHS,
                         pClassSch,
                         pAddArg->pObject,
                         cModAtts,
                         pModAtts,
                         &pClassInfo,
                         FALSE)
            ||
        (pClassInfo && ModifyAuxclassSecurityDescriptor (pTHS, 
                                                         pAddArg->pObject,
                                                         &pAddArg->CommArg,
                                                         pClassSch, 
                                                         pClassInfo,
                                                         pAddArg->pResParent))
            ||
        // We may need to automatically create a subref
        AddAutoSubRef(pTHS, pClassSch->ClassId, pAddArg, fAddingDeleted)
            ||
        // Insert the object into the database for real.
        InsertObj(pTHS, pAddArg->pObject, pAddArg->pMetaDataVecRemote, FALSE, 
                    META_STANDARD_PROCESSING))
    {
        Assert(pTHS->errCode != 0); // something failed, gotta have an error code
        goto exit;
    }

    if (pTHS->fDRA && fNullUuid(&pAddArg->pObject->Guid) && pClassSch->ClassId != CLASS_TOP) {
        // DRA is attempting to bring in a guid-less object. This must be caused the the w2k
        // bug which used to create guid-less FPOs. Fix up the guid (it is computed from the sid).
        // Note that subrefs don't have guids.
        // The new guid gets written into pAddArg->pObject.
        VerifyGUIDIsPresent(pTHS->pDB, pAddArg->pObject);
    }

    if (pTHS->SchemaUpdate!=eNotSchemaOp ) {
        // On Schema updates we want to resolve conflicts, and we want to
        // do so without losing database currency, which would cause operations
        // a few lines below to fail.

        ULONG dntSave = pTHS->pDB->DNT;

        // write any new prefixes that were added by this thread
        // to the schema object

        if ( pTHS->cNewPrefix > 0 ) {
           if (WritePrefixToSchema(pTHS))
           {
               goto exit;
           }
        }
        if (ValidSchemaUpdate()) {
            goto exit;
        }

        if ( !pTHS->fDRA ) {
            if (WriteSchemaObject()) {
                goto exit;
            }

            // log the change
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DSA_SCHEMA_OBJECT_ADDED, 
                     szInsertDN(pAddArg->pObject),
                     0, 0);
        }

        // Now restore currency
        DBFindDNT(pTHS->pDB, dntSave);

        // Signal a urgent replication. We want schema changes to 
        // replicate out immediately to reduce the chance of a schema
        // change not replicating out before the Dc where the change is 
        // made crashes

        pAddArg->CommArg.Svccntl.fUrgentReplication = TRUE;

    }

    // If this is not a schema update, but a new prefix is created,
    // flag an error and bail out

    if (!pTHS->fDRA &&
        pTHS->SchemaUpdate == eNotSchemaOp &&
        pTHS->NewPrefix != NULL) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_SECURITY_ILLEGAL_MODIFY);
        goto exit;
    }

    // If this is a schema update and a new prefix is created,
    // signal an immediate cache update at the end of the transaction

    if (pTHS->SchemaUpdate != eNotSchemaOp &&
        pTHS->NewPrefix != NULL) {
        pTHS->RecalcSchemaNow = TRUE;
    }

    //
    // We need to inform SAM and NetLogon of 
    // changes to SAM objects to support downlevel replication.
    // If we are not the DRA, then we need to potentially inform Lsa of changes
    //

    if (SampSamClassReferenced(pClassSch,&iClass))
    {
        if ( SampQueueNotifications(
                 pAddArg->pObject,
                 iClass,
                 LsaClass,
                 SecurityDbNew,
                 FALSE,
                 FALSE,
                 DomainServerRoleBackup, // Place holder value for server
                                         // role. Will not be used as
                                         // Role transfer is set to FALSE
                 cModAtts,
                 pModAtts
                 ) )
        {
            //
            // the above routine failed. 
            // 
            goto exit;
        }
    }

    if (SampIsClassIdLsaClassId(pTHS,
                                pClassSch->ClassId,
                                cModAtts,
                                pModAtts,
                                &LsaClass)) {
        if ( SampQueueNotifications(
                 pAddArg->pObject,
                 iClass,
                 LsaClass,
                 SecurityDbNew,
                 FALSE,
                 FALSE,
                 DomainServerRoleBackup, // Place holder value for server
                                         // role. Will not be used as
                                         // Role transfer is set to FALSE
                 cModAtts,
                 pModAtts
                 ) )
        {
            //
            // the above routine failed.
            // 
            goto exit;
        }
    }
    if (fAddingDeleted) {
        // Adding a deleted object; add it to the deleted index.
        if ( DBAddDelIndex( pTHS->pDB, FALSE ) ) {
            goto exit;
        }

        // This tombstone being added may have promoted a phantom which has backlinks:
        // remove them.
        DBRemoveAllLinks( pTHS->pDB, pTHS->pDB->DNT, TRUE /* use backlink */ );
    }
    else {
        // Not a deleted object, so add it to the catalog
        if (AddCatalogInfo(pTHS, pAddArg->pObject)) {
            goto exit;
        }
    }

    if (AddObjCaching(pTHS, pClassSch, pAddArg->pObject, fAddingDeleted, FALSE)){
        goto exit;
    }


    // Only notify replicas if this is not the DRA thread. If it is, then
    // we will notify replicas near the end of DRA_replicasync. We can't
    // do it now as NC prefix is in inconsistent state

    if ( DsaIsRunning() )
    {
        if (!pTHS->fDRA) {
            // Currency of DBPOS must be at the target object
            DBNotifyReplicasCurrDbObj(pTHS->pDB,
                             pAddArg->CommArg.Svccntl.fUrgentReplication);
        }
    }

    // This must go here, because this call repositions the DBPOS and calls
    // LocalModify() and LocalAdd() functions for modifying the Cross-Ref 
    // and adding the special NC containers respectively.

    if(fISADDNDNC(pAddArg->pCreateNC)){

        // A new NDNC is being created for the 1st time, must change the CR
        //  to reflect this NC is fully instantiated.
        if(ModifyCRForNDNC(pTHS, pAddArg->pObject, pAddArg->pCreateNC)){
            goto exit;
        }

        // A new NDNC is being created, must add the special containers to it.
        if(AddSpecialNCContainers(pTHS, pAddArg->pObject, pAddArg->pCreateNC->pSDRefDomCR)){
            goto exit;
        }
        
        // and finally must add the wellKnownObjects attribute to the NC 
        // head pointing to the containers we created above.
        if(AddNCWellKnownObjectsAtt(pTHS, pAddArg)){
            goto exit;
        }

        // If this DC is in the middle of being demoted, we don't allow
        // NDNCs to be created.
        if (!gUpdatesEnabled) {
            SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN);
            goto exit;
        }

    }

exit:
    if (pModAtts) {
        THFreeEx(pTHS, pModAtts);
    }
    if (pClassInfo) {
        ClassStateInfoFree (pTHS, pClassInfo);
        pClassInfo = NULL;
    }
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_ADDENTRY,
                     EVENT_TRACE_TYPE_END,
                     DsGuidAdd,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL,
                     NULL, NULL, NULL, NULL, NULL);

    return (pTHS->errCode);  /* in case we have an attribute error */

}/*LocalAdd*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Instead of adding Entry-TTL, a constructed attribute with syntax INTEGER,
   add ms-DS-Entry-Time-To-Die, an attribute with syntax DSTIME. The garbage
   collection thread, garb_collect, deletes these entries after they
   expire.
*/
VOID AddSetEntryTTL(THSTATE    *pTHS,
                    DSNAME     *pObject,
                    ATTR       *pAttr,
                    ATTCACHE   *pACTtl,
                    BOOL       *pfHasEntryTTL
                    )
{
    LONG        Secs;
    DWORD       dwErr;
    DSTIME      TimeToDie;
    ATTCACHE    *pACTtd;

    // client is adding a value for the entryTTL attribute
    *pfHasEntryTTL = TRUE;

    // Verify EntryTTL and msDS-Entry-Time-To-Die
    if (!CheckConstraintEntryTTL(pTHS,
                                 pObject,
                                 pACTtl,
                                 pAttr,
                                 &pACTtd,
                                 &Secs)) {
        return;
    }

    // Set msDS-Entry-Time-To-Die
    TimeToDie = Secs + DBTime();
    if (dwErr = DBAddAtt_AC(pTHS->pDB, pACTtd, SYNTAX_TIME_TYPE)) {
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
        return;
    }
    if (dwErr = DBAddAttVal_AC(pTHS->pDB, pACTtd, sizeof(TimeToDie), &TimeToDie)) {
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
        return;
    }

}/*AddSetEntryTTL*/

VOID
FixSystemFlagsForAdd(
    IN THSTATE    *pTHS,
    IN ATTR       *pAttr
    )
/*++
Routine Description
    Quietly fix the systemFlags in caller's AddArgs. Previously, this
    logic was performed by SetClassInheritence while it added in
    class-specific systemFlags. The logic was moved here to allow
    a user to set, but not reset, FLAG_ATTR_IS_RDN. The user
    sets FLAG_ATTR_IS_RDN to identify which of several attributes
    with the same attributeId should be used as the rdnattid of
    a new class. Once set, the attribute is treated as if it were
    used as the rdnattid of some class; meaning it cannot be
    reused.

Paramters
    pTHS - thread struct, obviously
    pAttr - Address of ATTR in AddArgs

Return
    None
--*/
{
    ULONG   SystemFlags;

    // invalid params will be caught later during AddAtts
    if (!CallerIsTrusted(pTHS)
        && pAttr->AttrVal.valCount == 1
        && pAttr->AttrVal.pAVal->valLen == sizeof(LONG)) {

        memcpy(&SystemFlags, pAttr->AttrVal.pAVal->pVal, sizeof(LONG));

        // Allow the user to set, but not reset, FLAG_ATTR_IS_RDN on
        // attributeSchema objects in the SchemaNC.
        //
        // Technically, the check should include eSchemaAttUndefunct but
        // since that state will never be set for a newly added attribute,
        // why bother.
        if (pTHS->SchemaUpdate == eSchemaAttAdd) {
            SystemFlags &= (FLAG_CONFIG_ALLOW_RENAME
                            | FLAG_CONFIG_ALLOW_MOVE
                            | FLAG_CONFIG_ALLOW_LIMITED_MOVE
                            | FLAG_ATTR_IS_RDN);
        } else {
            SystemFlags &= (FLAG_CONFIG_ALLOW_RENAME
                            | FLAG_CONFIG_ALLOW_MOVE
                            | FLAG_CONFIG_ALLOW_LIMITED_MOVE);
        }

        memcpy(pAttr->AttrVal.pAVal->pVal, &SystemFlags, sizeof(LONG));
    }
}/*FixSystemFlagsForAdd*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add each input attribute to  the current object.  System reserved
   attributes are skipped.  We need to retrieve the attribute schema
   for each attribute before adding the attribute.  The schema gives us
   information such as the attribute syntax, an range restrictions and
   whether the attribute is  single or multi-valued.
*/

int
SetAtts(THSTATE *pTHS,
        ADDARG *pAddArg,
        CLASSCACHE* pClassSch,
        BOOL *pfHasEntryTTL,
        ULONG *pcNonReplAtts,
        ATTRTYP **ppNonReplAtts,
        const BOOL fAddingDeleted )
{
    DBPOS * const pDB = pTHS->pDB;
    ATTCACHE *    pAC;
    ULONG         i, err = 0;
    BOOL          fObjectCategory = FALSE;
    BOOL          fDefaultObjectCategory = FALSE;
    ULONG         dntOfNCObj;
    HVERIFY_ATTS  hVerifyAtts;
    BOOL          fSeEnableDelegation; // SE_ENABLE_DELEGATION_PRIVILEGE enabled
    ULONG         cAllocs;
    BOOL                    fIsDeletedWasSet = FALSE;
    BOOL                    fHasType = FALSE;
    SYNTAX_INTEGER          insttype = IT_WRITE;   // if instance type not in AttrBlock, then this must be a writable object
    PSECURITY_DESCRIPTOR    pSD = NULL;

    *pcNonReplAtts = cAllocs = 0;

    if (pAddArg->pCreateNC) {
        // We're just now creating the object corresponding to the root of this
        // NC.  pTHS->pDB->NCDNT holds the DNT of the NC above this one (if it
        // exists and is instantiated on this DC) or ROOTTAG (if parent NC not
        // instantiated here), but we want the DNT of the object we're adding,
        // which may exist as a phantom or may not exist yet at all.  Convey
        // this fact to VerifyAttsBegin() -- it will know what to do.
		//
		// [jliem - 06/27/02]
		// Actually, this function is only called by LocalAdd(), which guarantees
		// that by the time this function is called, we know that the DNT
		// of the new object will be pDB->DNT
		//
        dntOfNCObj = INVALIDDNT;
    } else {
        // The usual case -- we're adding a new interior node to an existing NC.
        // The DNT of the NC root has already been cached in pTHS->pDB->NCDNT by
        // LocalAdd().
        dntOfNCObj = pDB->NCDNT;
    }

    hVerifyAtts = VerifyAttsBegin(pTHS, pAddArg->pObject, dntOfNCObj, pAddArg->pCRInfo);

    __try {
        for (i = 0; 
            i < pAddArg->AttrBlock.attrCount
                && (pTHS->errCode == 0 || pTHS->errCode == attributeError);
            i++) {

            // save off instance type because we'll need it later for
            // quota enforcement/update
            if ( ATT_INSTANCE_TYPE == pAddArg->AttrBlock.pAttr[i].attrTyp ) {
                // should only see this once, should not be multi-valued,
                // and should be correct size
                //
                Assert( !fHasType );
                Assert( 1 == pAddArg->AttrBlock.pAttr[i].AttrVal.valCount );
                Assert( NULL != pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal );
                fHasType = TRUE;

                // should never be resetting InstanceType, but handle it
                // just in case
                //
                if ( 0 != pAddArg->AttrBlock.pAttr[i].AttrVal.valCount ) {
                    Assert( sizeof(SYNTAX_INTEGER) == pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal->valLen );
                    Assert( NULL != pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal->pVal );
                    insttype = *(SYNTAX_INTEGER *)pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
                }
            }
            else if ( ATT_IS_DELETED == pAddArg->AttrBlock.pAttr[i].attrTyp ) {
                // should only see this once, should not be multi-valued,
                // and should be correct size
                //
                Assert( !fIsDeletedWasSet );
                if ( 0 != pAddArg->AttrBlock.pAttr[i].AttrVal.valCount ) {
                    Assert( 1 == pAddArg->AttrBlock.pAttr[i].AttrVal.valCount );
                    Assert( NULL != pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal );
                    Assert( sizeof(SYNTAX_BOOLEAN) == pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal->valLen );
                    Assert( NULL != pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal->pVal );
                    fIsDeletedWasSet = *(SYNTAX_BOOLEAN *)pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;

                    //  whenever this attribute is present, it should only ever be TRUE
                    //
                    Assert( fIsDeletedWasSet );
                }
            }

            if (!(pAC = SCGetAttById(pTHS,
                                     pAddArg->AttrBlock.pAttr[i].attrTyp))) {
                DPRINT1(2, "Att not in schema <%lx>\n",
                        pAddArg->AttrBlock.pAttr[i].attrTyp);
                // Continue processing if the attribute error was sucessful
                SAFE_ATT_ERROR(pAddArg->pObject,
                               pAddArg->AttrBlock.pAttr[i].attrTyp,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                               DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }
            else if ((pAC->bDefunct) && !pTHS->fDRA && !pTHS->fDSA) {
    
                // Attribute is defunct, so as far as user is
                // concerned, it is not in schema. DRA or DSA thread is
                // allowed to use the attribute
    
                DPRINT1(2, "Att is defunct <%lx>\n",
                        pAddArg->AttrBlock.pAttr[i].attrTyp);
                // Continue processing if the attribute error was sucessful
                SAFE_ATT_ERROR(pAddArg->pObject,
                               pAddArg->AttrBlock.pAttr[i].attrTyp,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                               DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }
            else if (pAC->bIsConstructed) {
                // Funky EntryTTL can be added (actually adds
                // msDS-Entry-Time-To-Die)
                if (pAC->id == ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {
                    AddSetEntryTTL(pTHS, 
                                   pAddArg->pObject, 
                                   &pAddArg->AttrBlock.pAttr[i], 
                                   pAC,
                                   pfHasEntryTTL);
    
                    continue;
                }
    
                // Constructed atts cannot be added
    
                DPRINT1(2, "Att is constructed <%lx>\n",
                        pAddArg->AttrBlock.pAttr[i].attrTyp);
                // Continue processing if the attribute error was sucessful
                SAFE_ATT_ERROR(pAddArg->pObject,
                               pAddArg->AttrBlock.pAttr[i].attrTyp,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                               DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }
            else if (SysAddReservedAtt(pAC)
                     && !gAnchor.fSchemaUpgradeInProgress) {
                // Skip reserved attributes unless upgrading schema
                DPRINT1(2, "attribute type <%lx> is a reserved DB att...skipped\n",
                        pAddArg->AttrBlock.pAttr[i].attrTyp);
            }
            else if (pAC->id == ATT_OBJECT_CATEGORY &&
                        (pClassSch->ClassId == CLASS_CLASS_SCHEMA ||
                           pClassSch->ClassId == CLASS_ATTRIBUTE_SCHEMA)) {
                // Object-categories for classes and attributes are hardcoded
                // later to class-schema and attribute-schema respectively
                DPRINT(2, "Setting attribute object-category on schema objects"
                          " is not allowed.....skipped\n");
            } 
            else {
                if (pAC->id == ATT_SYSTEM_FLAGS) {
                    // Quietly adjust systemFlags (no errors).
                    FixSystemFlagsForAdd(pTHS, &pAddArg->AttrBlock.pAttr[i]);
                }
                else if (pAC->id == ATT_MS_DS_ALLOWED_TO_DELEGATE_TO) {
                    // 371706 Allowed-To-Delegate-To needs proper ACL and Privilege protection
                    //
                    // From the DCR:
                    //
                    // A2D2 is used to configure a service to be able to obtain
                    // delegated service tickets via S4U2proxy. KDCs will only
                    // issue service tickets in response to S4U2proxy TGS-REQs
                    // if the target service name is listed on the requesting
                    // services A2D2 attribute. The A2D2 attribute has the
                    // same security sensitivity as the Trusted-for-Delegation
                    // (T4D) and Trusted-to-Authenticate-for-Delegation (T2A4D)
                    // userAccontControl.  Thus, the ability to set A2D2 is also
                    // protected by both an ACL on the attribute, and a privilege.
                    //
                    // write/modify access control: User must have both WRITE
                    // permission to A2D2 attribute --and-- the SE_ENABLE_DELEGATION_NAME
                    // (SeEnableDelegationPrivilege) privilege 
                    if (!pTHS->fDRA && !pTHS->fDSA) {
                        err = CheckPrivilegeAnyClient(SE_ENABLE_DELEGATION_PRIVILEGE,
                                                      &fSeEnableDelegation); 
                        if (err || !fSeEnableDelegation) {
                            SetSecErrorEx(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, 
                                          ERROR_PRIVILEGE_NOT_HELD, err);
                            continue; // stops because pTHS->errCode != 0
                        }
                    }
                }

                // Make a list of all the non-replicated attributes.
               if (pAC->bIsNotReplicated) {
                    if (*pcNonReplAtts>=cAllocs) {
                        if (0==cAllocs) {
                            cAllocs = 8;  //initial buffer size
                            *ppNonReplAtts = THAllocEx(pTHS, cAllocs*sizeof(ATTRTYP));
                        }
                        else {
                            cAllocs *=2;
                            *ppNonReplAtts = THReAllocEx(pTHS,*ppNonReplAtts, cAllocs*sizeof(ATTRTYP));
                        }
                    }
                    (*ppNonReplAtts)[(*pcNonReplAtts)++] = pAC->id;
                }

                // ok all values are correct, can be applied
                // Note, AddAtt must be called here because it does a both an
                // AddAttType and an AddAttVals. The AddAttType is necessary so that
                // replication metadata is updated even when there are no values.
                //
                if ( 0 == AddAtt(pTHS, hVerifyAtts, pAC, &pAddArg->AttrBlock.pAttr[i].AttrVal)
                    && pAC->id == ATT_NT_SECURITY_DESCRIPTOR ) {
                    // should only see SD once, should not be multi-valued
                    //
                    Assert( NULL == pSD );
                    Assert( 1 == pAddArg->AttrBlock.pAttr[i].AttrVal.valCount );

                    // track security descriptor for quota enforcement/update below
                    //
                    pSD = pAddArg->AttrBlock.pAttr[i].AttrVal.pAVal->pVal;
                    Assert( NULL != pSD );
                }

                // Keep track of the following attributes, since we need to
                // default them if not present in the addarg
    
                switch (pAddArg->AttrBlock.pAttr[i].attrTyp) {
                case ATT_OBJECT_CATEGORY :
                    fObjectCategory = TRUE;
                    break;
                case ATT_DEFAULT_OBJECT_CATEGORY :
                    fDefaultObjectCategory = TRUE;
                    break;
                }
            }
        } // for

        // QUOTA_UNDONE: brettsh thinks that uninstantiated objects
        // shouldn't take this code path except for subrefs added by
        //,replication when the crossref doesn't exist
        //
        Assert( !( insttype & IT_UNINSTANT )
            || ( ( insttype & IT_NC_HEAD ) && pTHS->fDRA ) );

        // if security descriptor and all other
        // attributes were successfully added,
        // and we're not adding an NC and we're
        // supposed to track quota for this object,
        // enforce/update quota for the owner
        //
        if ( ERROR_SUCCESS == pTHS->errCode
            && NULL != pSD
            && NULL == pAddArg->pCreateNC
            && FQuotaTrackObject( insttype ) ) {
            // enforce/update quota for the new object
            //
            // QUOTA_UNDONE: If replication is adding a deleted object,
            // it should call LocalRemove() after, which is what will
            // update the tombstoned code (this is why in this case we
            // don't pass TRUE to ErrQuotaAddObject() for the
            // fIsTombstoned param)
            //
            // BUT, there's an exception to this, and that's if
            // fAddingDeleted is FALSE, but the IS_DELETED flag is
            // set. This should only happen whenever adding the
            // DeletedObjects container. A subsequent call to
            // LocalRemove() won't be made, so we need to account
            // for the tombstoned object now.
            //
            if ( ErrQuotaAddObject( pDB, pDB->NCDNT, pSD, !fAddingDeleted && fIsDeletedWasSet ) ) {
                DPRINT( 0, "Failed quota enforcement/update when adding object.\n" );
                Assert( ERROR_SUCCESS != pDB->pTHS->errCode );
                Assert( NULL != pDB->pTHS->pErrInfo );

                if ( serviceError == pDB->pTHS->errCode
                    && STATUS_QUOTA_EXCEEDED == pDB->pTHS->pErrInfo->SvcErr.extendedErr ) {
                    PSID    pOwnerSid   = NULL;
                    BOOL    fUnused;

                    // attempt to extract owner sid from the SD, but if we fail,
                    // ignore the error and just report the event without the sid
                    //
                    Assert( IsValidSecurityDescriptor( pSD ) );
                    (VOID)GetSecurityDescriptorOwner( pSD, &pOwnerSid, &fUnused );
                    Assert( NULL != pOwnerSid );
                    Assert( IsValidSid( pOwnerSid ) );

                    // report quota exceeded
                    //
                    LogEvent8WithData(
                            DS_EVENT_CAT_SECURITY,
                            DS_EVENT_SEV_MINIMAL,
                            DIRLOG_QUOTA_EXCEEDED_ON_ADD,
                            szInsertDN( pAddArg->pObject ),
                            szInsertUL( pDB->NCDNT ),
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            ( NULL != pOwnerSid ? GetLengthSid( pOwnerSid ) : 0 ),
                            pOwnerSid );
                }
            }
        }

    } __finally {
        pAddArg->pCRInfo = hVerifyAtts->pCRInfo; // Code.Improvement put this in VerifyAttsEnd(), but it is add specific.
        VerifyAttsEnd(pTHS, &hVerifyAtts);
    }

    if (pTHS->errCode != 0 && pTHS->errCode != attributeError) {
        return pTHS->errCode;
    }

    if (!pTHS->fDRA && !fObjectCategory) {

        // No Object Category specified by the user. We need to
        // provide a default, which is the default-object-category on the
        // object's class. We default for all objects during normal
        // operation

        if (DsaIsRunning()) {
            if (!(pAC = SCGetAttById(pTHS, ATT_OBJECT_CATEGORY))) {
                // Cannot even get the attcache. Something is wrong.
                // No point proceeding since the call will anyway fail
                // in ValidateObjClass since a must-contain is missing

                SetAttError(pAddArg->pObject, ATT_OBJECT_CATEGORY,
                            PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                            DIRERR_ATT_NOT_DEF_IN_SCHEMA);
                return pTHS->errCode;
            }

            if (err = AddAttType(pTHS,
                                 pAddArg->pObject,
                                 pAC)) {
                // Error adding the attribute type
                return pTHS->errCode;
            }
            if (err = DBAddAttVal(pDB,
                                  ATT_OBJECT_CATEGORY,
                                  pClassSch->pDefaultObjCategory->structLen,
                                  pClassSch->pDefaultObjCategory)){
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,err);
            }
        }
        else {
            // We only default for class-schema and attribute-schema
            // objects during install, which will be done when we
            // set other default attributes for them later. All other
            // objects in schema.ini are supposed to have object-category
            // value

            if (pClassSch->ClassId != CLASS_CLASS_SCHEMA &&
                pClassSch->ClassId != CLASS_ATTRIBUTE_SCHEMA) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,err);
            }
       }
    }

    if (!fDefaultObjectCategory &&
        pClassSch->ClassId == CLASS_CLASS_SCHEMA) {

        // Class-schema object with no default-object-category
        // Set it to itself. We do it here instead of later when we
        // set all other default attributes for a class since this
        // has to be set before SetNamingAtts sets the OBJ_DIST_NAME
        // attribute

        if (!(pAC = SCGetAttById(pTHS, ATT_DEFAULT_OBJECT_CATEGORY))) {
            // Cannot even get the attcache. Something is wrong.
            // No point proceeding since the call will anyway fail
            // in ValidateObjClass since a must-contain is missing
            // for the class-schema object

            SetAttError(pAddArg->pObject, ATT_DEFAULT_OBJECT_CATEGORY,
                        PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                        DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            return pTHS->errCode;
        }
        if (err = AddAttType(pTHS,
                             pAddArg->pObject,
                             pAC)) {
            // Error adding the attribute type
            return pTHS->errCode;
        }
        if (err = DBAddAttVal(pDB,
                              ATT_DEFAULT_OBJECT_CATEGORY,
                              pAddArg->pObject->structLen,
                              pAddArg->pObject)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,DIRERR_UNKNOWN_ERROR, err);
        }
    }

    return pTHS->errCode;

}/*SetAtts*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add attributes appropriate to this layer to the object.

   CLASS, DN, RDN, PROPERTY_META_DATA, and INSTANCE TYPE
*/

int SetSpecialAtts(THSTATE *pTHS,
                   CLASSCACHE **ppClassSch,
                   ADDARG *pAddArg,
                   DWORD ActiveContainerID,
                   CLASSSTATEINFO  *pClassInfo,
                   BOOL fHasEntryTTL)
{
    DSNAME* pDN=pAddArg->pObject;

    Assert (ppClassSch && *ppClassSch);

    DPRINT(2,"SetSpecialAtts entered\n");

    // WARNING: [jliem] SetNamingAtts() was originally called
    // before SetInstanceType(), but I switched the order because
    // I need the instance type set for quota-tracking purposes
    // if SetNamingAtts() ends up calling sbTablePromotePhantom
    //
    if ( SetClassInheritance(pTHS, ppClassSch, pClassInfo, TRUE, pAddArg->pObject)
        || SetInstanceType(pTHS, pDN, pAddArg->pCreateNC)
        || SetNamingAtts(pTHS, *ppClassSch, pDN)
        || SetShowInAdvancedViewOnly(pTHS, *ppClassSch)
        || SetSpecialAttsForAuxClasses(pTHS, pAddArg, pClassInfo, fHasEntryTTL)) {

        DPRINT1(2,"problem with SetSpecialAtts <%u>\n",pTHS->errCode);
        return pTHS->errCode;
    }

    if (ActiveContainerID) {
        ProcessActiveContainerAdd(pTHS, *ppClassSch, pAddArg, ActiveContainerID);
    }
    else if ( DsaIsInstalling() ) {
        /* How cheesy.  We already have schema-container specific
         * object handling via the active container hooks, but our install
         * code both adds incomplete schema objects that must be touched up
         * by this object massaging, and also fails to register the schema
         * container for monitoring.  Together that means that we must have
         * a fallback way to massage these objects during install and mkdit.
         * My deepest apologies to those offended by redundant code.
             *
             * [ArobindG: 01/15/98]: Also added code to set pTHS->SchemaUpdate
             * properly to allow new prefixes to be added correctly during
             * replicated install. 
             */
        switch((*ppClassSch)->ClassId) {
          case CLASS_ATTRIBUTE_SCHEMA:
            pTHS->SchemaUpdate = eSchemaAttAdd;
            SetAttrSchemaAttr(pTHS, pAddArg);
            break;

          case CLASS_CLASS_SCHEMA:
            pTHS->SchemaUpdate = eSchemaClsAdd;
            SetClassSchemaAttr(pTHS, pAddArg);
            break;

          default:
                pTHS->SchemaUpdate = eNotSchemaOp;
            ;
        }
    }

    return pTHS->errCode;

}/*SetSpecialAtts*/

/*++
 * This routine is a common dumping place for extra system flags that must
 * be added to an object of a specific class on add.  Were the table to grow
 * at all large it would probably be better to do this by adding a new
 * "defaultSystemFlags" attribute to classSchema and then read the flags
 * out of the schema cache.  This would require a schema upgrade and a new
 * protection mechanism to keep people from defining new classes and gaining
 * the ability to thereby set random systemFlags on newly created objects.
 *
 * This function is referenced only in SetClassInheritance, below, but it's
 * referenced twice, and so is pulled out into a separate routine, so that
 * any future updates need only be made in one place.
 *
 * INPUT:
 *   ClassID - a class id
 * RETURN VALUE:
 *   The ORed together system flags that should be added to objects of that
 *   class.  The caller is responsible for aggregating inherited flags.
 */
_inline DWORD ExtraClassFlags(ATTRTYP ClassID)
{
    DWORD flags = 0;

    switch (ClassID) {
      case CLASS_SERVER:
          flags = (FLAG_DISALLOW_MOVE_ON_DELETE |
                   FLAG_CONFIG_ALLOW_RENAME     |
                   FLAG_CONFIG_ALLOW_LIMITED_MOVE);
          break;

      case CLASS_SITE:
      case CLASS_SERVERS_CONTAINER:
      case CLASS_NTDS_DSA:
          flags = FLAG_DISALLOW_MOVE_ON_DELETE;
          break;
          
      case CLASS_SITE_LINK:
      case CLASS_SITE_LINK_BRIDGE:
      case CLASS_NTDS_CONNECTION:
          flags = FLAG_CONFIG_ALLOW_RENAME;
          break;
        
      default:
          break;
    }
    return flags;
}

int
SetClassInheritance (
        IN THSTATE              *pTHS,
        IN OUT CLASSCACHE      **ppClassSch,
        IN OUT CLASSSTATEINFO  *pClassInfo,
        IN BOOL                 bSetSystemFlags,
        IN DSNAME              *pObject
        )
/*++

Routine Description:
 
  Add the class and its inherited class identifiers to the class attribute.
  Also, add any class specific system-flags, and govern the sys-flags bits
  that users might try to sneak in.

Arguments:

    ppClassSch - the class of the object beeing added. note this might change 
                 if we are converting the structural object class of the object
                 (from user <---> inteOrgPerson).
                 
    pClassInfo - the CLASSSTATEINFO that propably contains info about auxClasses
    
    bSetSystemFlags - whether to set the System flags of the object
    
    pObject - the name of the object modified

Return Values:

    0 succes, else Thread state error code.

--*/



{
    DWORD        Err;
    unsigned     count;
    DWORD        ulSysFlags, ulSysFlagsOrg;
    CLASSCACHE  *pClassSch = *ppClassSch;
    
    DPRINT(2,"SetClassInheritance entered \n");
    
    if (bSetSystemFlags) {
        /* Get the current value of the system flags */
        if (DBGetSingleValue(pTHS->pDB,
                             ATT_SYSTEM_FLAGS,
                             &ulSysFlags,
                             sizeof(ulSysFlags),
                             NULL)) {
            ulSysFlags = 0;
        }
        ulSysFlagsOrg = ulSysFlags;
    }


    // if we have changed objectClass and have possibly
    // an auxClass specified, combine it with the objectClass
    // 
    if (pClassInfo && pClassInfo->fObjectClassChanged) {
        
        // first find which part is the auxClass
        // then calculate the complete value for the auxClass (close it)
        // and then write the value to the database

        if (Err = BreakObjectClassesToAuxClasses(pTHS, ppClassSch, pClassInfo)) {
            return Err;
        }
        pClassSch = *ppClassSch;

        if (Err = CloseAuxClassList (pTHS, pClassSch, pClassInfo)) {
            return Err;
        }

        if (Err = VerifyAndAdjustAuxClasses (pTHS, pObject, pClassSch, pClassInfo)) {
            return Err;
        }

        // we can only have auxClasses in NDNCs or in a Whistler Enterprise
        //
        if (pClassInfo && pClassInfo->cNewAuxClasses && !pTHS->fDRA) {

            // If not a whistler enterprise, auxclasses must be in an NDNC
            if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET) {
                CROSS_REF   *pCR;
                pCR = FindBestCrossRef(pObject, NULL);
                if (   !pCR
                    || !(pCR->flags & FLAG_CR_NTDS_NC)
                    || (pCR->flags & FLAG_CR_NTDS_DOMAIN)) {
                    DPRINT (0, "You can add auxclass/objectass only on an NDNC\n");
                    return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                       ERROR_DS_NOT_SUPPORTED);
                }
            }
        }

        // Delete the objectClass attribute if it exists
        //
        if (DBRemAtt(pTHS->pDB, ATT_OBJECT_CLASS) == DB_ERR_SYSERROR)
            return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                 DIRERR_DATABASE_ERROR,DB_ERR_SYSERROR);

        // Add class att first.  An error can not be a size error since we already
        // had a class value on the object
        //
        if ( (Err = DBAddAtt(pTHS->pDB, ATT_OBJECT_CLASS, SYNTAX_OBJECT_ID_TYPE))
            || (Err = DBAddAttVal(pTHS->pDB,ATT_OBJECT_CLASS,
                                  sizeof(SYNTAX_OBJECT_ID),&pClassSch->ClassId))){

            return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,Err);
        }
        ulSysFlags |= ExtraClassFlags(pClassSch->ClassId);

        // Add the inherited classes to the class attribute.  
        // Assume that an error is a size error.
        // Do up to the last one
        if (pClassSch->SubClassCount) {
            for (count = 0; count < pClassSch->SubClassCount-1; count++) {

                Err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_CLASS,
                                  sizeof(SYNTAX_OBJECT_ID),
                                  &pClassSch->pSubClassOf[count]);
                switch (Err) {
                  case 0:               // success
                    break;

                  case DB_ERR_VALUE_EXISTS:
                    /* we should NEVER get this one unless class is 0 */
                    if (pClassSch->pSubClassOf[count]) {
                        LogUnhandledError(pClassSch->ClassId);
                        Assert(FALSE);
                    }

                  default:
                    // all other problems are assumed
                    // to be temporary (record locks, etc.)
                    return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                         DIRERR_DATABASE_ERROR, Err);

                }

                ulSysFlags |= ExtraClassFlags(pClassSch->pSubClassOf[count]);
            }/*for*/
        }

        // now do the auxClasses (put them in the middle)
        //
        if (pClassInfo->cNewAuxClasses) {

            for (count = 0; count < pClassInfo->cNewAuxClasses; count++) {

                Err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_CLASS,
                                    sizeof(SYNTAX_OBJECT_ID), 
                                    &pClassInfo->pNewAuxClasses[count]);
                switch (Err) {
                  case 0:               // success
                    break;

                  case DB_ERR_VALUE_EXISTS:
                    /* we should NEVER get this one unless class is 0 */
                    if (pClassInfo->pNewAuxClasses[count]) {
                        LogUnhandledError(pClassInfo->pNewAuxClasses[count]);
                        Assert (!"Error computing auxClasses");
                    }

                  default:
                    // all other problems are assumed
                    // to be temporary (record locks, etc.)
                    return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                         DIRERR_DATABASE_ERROR, Err);

                }
            }
        }

        // last insert the last class in the structural hierarchy
        //
        if (pClassSch->SubClassCount) {
            Err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_CLASS,
                              sizeof(SYNTAX_OBJECT_ID),
                              &pClassSch->pSubClassOf[pClassSch->SubClassCount-1]);
            switch (Err) {
              case 0:               // success
                break;

              case DB_ERR_VALUE_EXISTS:
                /* we should NEVER get this one unless class is 0 */
                if (pClassSch->pSubClassOf[pClassSch->SubClassCount-1]) {
                    LogUnhandledError(pClassSch->pSubClassOf[pClassSch->SubClassCount-1]);
                    Assert(FALSE);
                }

              default:
                // all other problems are assumed
                // to be temporary (record locks, etc.)
                return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                     DIRERR_DATABASE_ERROR, Err);
            }

            ulSysFlags |= ExtraClassFlags(pClassSch->pSubClassOf[pClassSch->SubClassCount-1]);
        }

    }
    else {
        // the user did not specify an auxClass.  write the objectClass 

        // Delete the objectClass attribute if it exists
        //
        if (DBRemAtt(pTHS->pDB, ATT_OBJECT_CLASS) == DB_ERR_SYSERROR)
            return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                 DIRERR_DATABASE_ERROR,DB_ERR_SYSERROR);

        // Add class att first.  An error can not be a size error since we already
        // had a class value on the object
        //
        if ( (Err = DBAddAtt(pTHS->pDB, ATT_OBJECT_CLASS, SYNTAX_OBJECT_ID_TYPE))
            || (Err = DBAddAttVal(pTHS->pDB,ATT_OBJECT_CLASS,
                                  sizeof(SYNTAX_OBJECT_ID),&pClassSch->ClassId))){

            return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,Err);
        }
        ulSysFlags |= ExtraClassFlags(pClassSch->ClassId);


        /* Add the inherited classes to the class attribute.  Assume that an error
         *  is a size error.
         */
        for (count = 0; count < pClassSch->SubClassCount; count++){

            Err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_CLASS,
                              sizeof(SYNTAX_OBJECT_ID),
                              &pClassSch->pSubClassOf[count]);
            switch (Err) {
              case 0:               // success
                break;

              case DB_ERR_VALUE_EXISTS:
                /* we should NEVER get this one unless class is 0 */
                if (pClassSch->pSubClassOf[count]) {
                    LogUnhandledError(pClassSch->ClassId);
                    Assert(FALSE);
                }

              default:
                // all other problems are assumed
                // to be temporary (record locks, etc.)
                return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                     DIRERR_DATABASE_ERROR, Err);

            }

            ulSysFlags |= ExtraClassFlags(pClassSch->pSubClassOf[count]);
        }/*for*/
    }

    
    if (bSetSystemFlags) {
        // write back the systemFlags if they have changed
        //
        if (ulSysFlags != ulSysFlagsOrg) {
            DBResetAtt(pTHS->pDB,
                       ATT_SYSTEM_FLAGS,
                       sizeof(ulSysFlags),
                       &ulSysFlags,
                       SYNTAX_INTEGER_TYPE);
        }
    }

    return 0;

}/*SetClassInheritance*/

int
SetSpecialAttsForAuxClasses(
        THSTATE *pTHS,
        ADDARG *pAddArg,
        CLASSSTATEINFO  *pClassInfo,
        BOOL fHasEntryTTL
        )
/*++
 * Add the attributes for special auxclasses such as Dynamic-Object
 *
 */
{
    BOOL        fDynamicObject = FALSE;
    DWORD       Idx;
    DSTIME      TimeToDie;
    DWORD       dwErr;
    ATTCACHE    *pACTtd;
    
    DPRINT(2,"SetSpecialAttsForAuxClasses entered \n");

    // an object with an entryTTL is a dynamic object
    if (fHasEntryTTL) {
        fDynamicObject = TRUE;
    } else if (pClassInfo && pClassInfo->cNewAuxClasses) {
        // and an object with the auxClass, Dynamic-Object, is a dynamic object
        for (Idx = 0; Idx < pClassInfo->cNewAuxClasses ; Idx++) {    
            if (pClassInfo->pNewAuxClasses[Idx] == 
                ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId) {
                fDynamicObject = TRUE;
                break;
            }
        }
    }

    // Not a dynamic object.
    if (!fDynamicObject) {
        // non-dynamic object is not allowed under dynamic parent
        // unless installing, replicating, or running as system.
        //
        // DbSearchHasValuesByDnt maintains currency on the object
        // being creating by using JetSearchTbl instead of JetObjTbl.
        if (   !DsaIsInstalling() 
            && !pTHS->fDRA 
            && !pTHS->fDSA
            && (pACTtd = SCGetAttById(pTHS, ATT_MS_DS_ENTRY_TIME_TO_DIE))
            && DBSearchHasValuesByDnt(pTHS->pDB,
                                      pAddArg->pResParent->DNT,
                                      pACTtd->jColid)) {
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_UNWILLING_TO_PERFORM);
        }
        return 0;
    }

    // Check security
    if (dwErr = CheckIfEntryTTLIsAllowed(pTHS, pAddArg)) {
        return pTHS->errCode;
    }

    // Add entryTTL to object (actually msDS-Entry-Time-To-Die)
    if (dwErr = DBAddAtt(pTHS->pDB, ATT_MS_DS_ENTRY_TIME_TO_DIE, SYNTAX_TIME_TYPE)) {
        // client specified an entryTTL
        if (dwErr == DB_ERR_ATTRIBUTE_EXISTS) {
            return 0;
        }
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
    }

    // No entryTTL. Set entryTTL to the default.
    // We know that DynamicObjectDefaultTTL is between a constant min and max
    //  but it also must be larger than DynamicObjectMinTTL
    TimeToDie = DBTime() + ((DynamicObjectDefaultTTL < DynamicObjectMinTTL) 
                            ? DynamicObjectMinTTL : DynamicObjectDefaultTTL);
    if (dwErr = DBAddAttVal(pTHS->pDB, ATT_MS_DS_ENTRY_TIME_TO_DIE,
                        sizeof(TimeToDie), &TimeToDie)) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
    }

    return 0;

}/*SetSpecialAttsForAuxClasses*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add the Distinguished name and the RDN to the object.  The RDN is derived
   from the last AVA of the DN and is required to appear on the object from
   X500.  The DN is required by our implementation.

   The Root object (must have class TOP) does not have an RDN (a DN with
   no AVA's) but can be added (special case).

   Only object's whose class or inherited classes define an RDN type in the
   schema can be added.  There are classes that are defined that never have
   objects added to the Directory.  They exist for convenient subclass
   definitions.  These classes don't define an RDN type in the schema.
*/


int SetNamingAtts(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  DSNAME *pDN)
{
    UCHAR  syntax;
    ULONG len, tlen;
    WCHAR RdnBuff[MAX_RDN_SIZE];
    WCHAR *pVal=(WCHAR *)RdnBuff;
    WCHAR RDNVal[MAX_RDN_SIZE+1];
    ULONG RDNlen;
    ATTRTYP RDNtype;
    int rtn;
    BOOL fAddRdn;
    DWORD dnsErr;
    ATTCACHE *pAC;
    
    /* Add the Distname as an attribute of the object..If the DN name exists
       anywhere in the directory using a different set of attributes for the
       name we will get a VALEXISTS error,
       Otherwise assume that any error is a size error.
       */

    /* Remove any existing value*/
    if (DBRemAtt(pTHS->pDB, ATT_OBJ_DIST_NAME) == DB_ERR_SYSERROR)
      return SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);

    rtn = 0;

    if ( (rtn = DBAddAtt(pTHS->pDB, ATT_OBJ_DIST_NAME, SYNTAX_DISTNAME_TYPE))
        || (rtn = DBAddAttVal(pTHS->pDB,
                              ATT_OBJ_DIST_NAME,
                              pDN->structLen,
                              pDN))){
        
        switch (rtn) {
          case DB_ERR_VALUE_EXISTS:
            DPRINT(2,"The DN exists using different attributes\n");
            return SetAttError(pDN, ATT_OBJ_DIST_NAME,
                               PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                               DIRERR_OBJ_STRING_NAME_EXISTS);


          case DB_ERR_SYNTAX_CONVERSION_FAILED:
            return SetNamError(NA_PROBLEM_BAD_NAME,
                               pDN,
                               DIRERR_BAD_NAME_SYNTAX);

          case DB_ERR_NOT_ON_BACKLINK:
            // we seem to think the name is a backlink.
            return SetNamError(NA_PROBLEM_BAD_NAME,
                               pDN,
                               DIRERR_BAD_NAME_SYNTAX);

          default:
            // all other problems are assumed
            // to be temporary (record locks, etc.)
            return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                 DIRERR_DATABASE_ERROR,
                                 rtn);

        }
    }


    /* Set the RDN attribute on the object.  The Root object is the only object
     * that does not have an RDN.  The root object must be of class TOP.  Other
     * than the root, objects that can be added to the directory must contain
     * an RNDATTID in  the schema class or in an inherited schema class.  The
     * RDN att is set from the DN.  Any supplied values are ignored!
     */

    if (IsRoot(pDN)){
        if (pClassSch->ClassId  != CLASS_TOP){

            DPRINT(2,"The root object must have an object class of TOP\n");
            return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                               DIRERR_ROOT_REQUIRES_CLASS_TOP);
        }

        return 0;  /*No RDN for root so return */
    }

    rtn = GetRDNInfo(pTHS, pDN, RDNVal, &RDNlen, &RDNtype);
    if (rtn) {
        return SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pDN, DIRERR_BAD_NAME_SYNTAX);
    }

    // Disallow invalid RDN unless it's replicated in (in which case presumably
    // it's the name of a tombstone or a name morphed by replication 
    // name conflict, which is intentionally invalid).
    if (!pTHS->fDRA && fVerifyRDN(RDNVal,RDNlen)) {
        return SetNamError(NA_PROBLEM_NAMING_VIOLATION, pDN,
                           DIRERR_BAD_ATT_SYNTAX);
    }

    // We relax some naming restrictions when we're replicating in a naked
    // SUBREF (which has an object class of Top).  Specifically, if this
    // is a subref, we don't have any more checks to do, because they all
    // involve the class specific RDN, which subrefs don't have.
    if (pTHS->fDRA && (pClassSch->ClassId == CLASS_TOP)) {
        return 0;
    }

    /* Only classes that have or inherit an RDN att can be added to directory
     * (except for the root).  Other classes may exist just to group a set
     * of attributes for sub classes to use.
     */

    if (!pClassSch->RDNAttIdPresent) {

        /*This class can not have objects */
        DPRINT1(2,"Objects of this class <%lu> can not be added to the"
                " directory.  Schema RDNATTID missing.\n"
                ,pClassSch->ClassId);
        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           DIRERR_NO_RDN_DEFINED_IN_SCHEMA);

    }

    // The RDN derived from the DistName must exist. If not, the schema
    // must be out of sync with the source. Or the caller specified
    // nonsense. Eg, a crossDomainMove is creating the dst object with
    // an invalid RDN. In any case, don't create the object.
    if (NULL == (pAC = SCGetAttById(pTHS, RDNtype))) {
        return SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pDN, DIRERR_BAD_NAME_SYNTAX);
    }

    // The new schema reuse, defunct, and delete feature doesn't
    // allow reusing attributes used as the rdnattid of any class,
    // alive or defunct, or with FLAG_ATTR_IS_RDN set in systemFlags.
    //
    // A user sets FLAG_ATTR_IS_RDN to select which of several
    // defunct attrs can be used as the rdnattid of a new class.
    // The system will identify attributes once used as rdnattids
    // in purged classes by setting FLAG_ATTR_IS_RDN.
    //
    // The restrictions are in place because the NameMatched(), DNLock(),
    // and phantom upgrade code (list not exhaustive) depends on the
    // invariant relationship between ATT_RDN, ATT_FIXED_RDN_TYPE,
    // the rdnattid column, LDN-syntaxed DNs, and the RDNAttId in
    // the class definition. Breaking that dependency is beyond
    // the scope of the schema delete project.
    //
    // The RDN of a new object must match its object's RdnIntId.
    // Replicated objects and existing objects might not match
    // the rdnattid of their class because the class may be
    // superced by a class with a different rdnattid. The code
    // handles these cases by using the value in the
    // ATT_FIXED_RDN_TYPE column and *NOT* the rdnattid in the
    // class definition.
    //
    // Allow the replication engine to do what it wants.
    if (!pTHS->fDRA && RDNtype != pClassSch->RdnIntId) {
        DPRINT1(2, "Bad RDNATTID for this object class <%lx>\n", RDNtype);
        return SetNamError(NA_PROBLEM_NAMING_VIOLATION, pDN,
                           DIRERR_RDN_DOESNT_MATCH_SCHEMA);
    }

    // Validate site names - RAID 145341.
    // Validate subnet names - RAID 200090.
    if ( !pTHS->fDRA ) 
    {
        RDNVal[RDNlen] = L'\0';
        if (    (    (CLASS_SITE == pClassSch->ClassId)
                  && (    // Check for legal characters.
                          (    (dnsErr = DnsValidateName_W(RDNVal, DnsNameDomainLabel))
                            && (DNS_ERROR_NON_RFC_NAME != dnsErr) ) ) )
             || (    (CLASS_SUBNET == pClassSch->ClassId)
                  && (NO_ERROR != DsValidateSubnetNameW(RDNVal)) ) ) 
        {
            return SetNamError(NA_PROBLEM_BAD_NAME,
                               pDN,
                               DIRERR_BAD_NAME_SYNTAX);
        }
    }



    // If the caller set the attribute that is the RDN on this object, make
    // sure that the last RDN on the DN matches the value set on
    // the RDN id attribute.

    fAddRdn = TRUE;
    if(!DBGetAttVal(pTHS->pDB, 1, RDNtype,
                    DBGETATTVAL_fCONSTANT,
                    MAX_RDN_SIZE * sizeof(WCHAR),
                    &len, (PUCHAR *)&pVal)) {
        // Note that len is a count of bytes, not count of characters, while
        // RDNLen is count of char.
        if(2 != CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               RDNVal,
                               RDNlen,
                               pVal,
                               (len / sizeof(WCHAR)))) {
            if (pTHS->fCrossDomainMove) {
                // Cross domain moves are treated as adds (hence this
                // call to LocalAdd). An adopted object may now have
                // a different rdn as the key in its RDN. This means a
                // user can assign a new key as well as a new RDN during
                // a cross domain move. The source may have sent over the
                // attr not realizing the new RDN has a new key.
                //
                // Remove the current, incorrect value. The correct value
                // will be extracted from the DN and added below.
                DBRemAttVal(pTHS->pDB, RDNtype, len, pVal);
            } else {
                return SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pDN,
                                   ERROR_DS_SINGLE_VALUE_CONSTRAINT);
            }
        } else {
            if (memcmp(RDNVal, pVal, len)) {
                // The doubly specified RDNs compare as equal, but are bytewise
                // inequal.  We'll now remove the one specified in the entry and let
                // the standard code below add the one specified in the DN as the
                // "real" value.
                DBRemAttVal(pTHS->pDB, RDNtype, len, pVal);
            }
            else {
                /* The value is already there and good */
                fAddRdn = FALSE;
            }
        }
    }

    if (fAddRdn) {
        // We need to set whatever attribute is the RDN on this object,
        // copying the value from the name, because it wasn't set
        // separately.  First thing, though, is we need to check it
        // for schema compliance.
        ATTRVAL AVal;

        AVal.valLen = RDNlen * sizeof(WCHAR);
        AVal.pVal = (UCHAR*)RDNVal;

        if (!pTHS->fDRA) {
            // We always allow the replicator to set invalid data
            rtn = CheckConstraint(pAC, &AVal);
            if (rtn) {
                return SetAttErrorEx(pDN,
                                     RDNtype,
                                     PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                     &AVal,
                                     rtn,
                                     0);
            }
        }

        // The value's ok, so now actually add it to the RDN attribute

        if (rtn = DBAddAttVal_AC(pTHS->pDB,
                                 pAC,
                                 RDNlen * sizeof(WCHAR),
                                 RDNVal)) {

            switch (rtn) {
              case DB_ERR_VALUE_EXISTS:
                // we should NEVER be here, but
                // just in case, fall through
                DPRINT(0,"The RDN exists? weird!\n");
                Assert(FALSE);

              default:
                // all other problems are assumed
                // to be temporary (record locks, etc.)
                  return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                       DIRERR_DATABASE_ERROR,
                                       rtn);
            }
        }
    }

    // the RDN should always be single-valued, though in the 
    // schema definition, the attribute can be multi-valued. 
    // Now check if it has a second value.
    
    if(!pTHS->fDRA && !pAC->isSingleValued
       && !DBGetAttVal(pTHS->pDB, 2, RDNtype,
                       DBGETATTVAL_fCONSTANT,
                       MAX_RDN_SIZE * sizeof(WCHAR),
                       &len, (PUCHAR *)&pVal)) {

        DPRINT(2, "Multivalued RDNs\n");
        return SetNamError(NA_PROBLEM_NAMING_VIOLATION, pDN,
                           ERROR_DS_SINGLE_VALUE_CONSTRAINT);

    }


    // If we got to here, everything is ok

    return 0;

}/*SetNamingAtts*/


/*----------------------------------------------------------------------*/
/*----------------------------------------------------------------------*/
/*
   Set the object-category of an attribute-schema object to
   attribute-schema and of a class-schema object to class-schema

   Argument: pAddArg -- Pointer to ADDARG
             ClassId -- ClassId of object (ATTRIBUTE_SCHEMA or CLASS_SCHEMA)

   Return -- 0 on sucees, non-0 on error. Set pTHStls->errCode
*/

int SetSchObjCategory(THSTATE *pTHS, ADDARG *pAddArg, ATTRTYP ClassId)
{
    CLASSCACHE *pCC;
    WCHAR ClassName[32];
    DWORD Err;

        // Remove if already exists
    if (DBRemAtt(pTHS->pDB, ATT_OBJECT_CATEGORY) == DB_ERR_SYSERROR) {
       return SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
    }
    if (Err = DBAddAtt(pTHS->pDB, ATT_OBJECT_CATEGORY,
                       SYNTAX_DISTNAME_TYPE)) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, Err);
    }

    if (ClassId == CLASS_ATTRIBUTE_SCHEMA) {
        pCC = SCGetClassById(pTHS, CLASS_ATTRIBUTE_SCHEMA);
        wcscpy(ClassName, L"Attribute-Schema");
    }
    else {
        pCC = SCGetClassById(pTHS, CLASS_CLASS_SCHEMA);
        wcscpy(ClassName, L"Class-Schema");
    }

    // For normal case, we can just copy it from the
    // default-object-category of the attribute-schema or class-schema class
    // in the cache. For Install case however, we need to build the DN
    // since the cache at this stage is built from the boot schema,
    // and the default-object-category values there points to the
    // boot schema's attribute-schema


    if ( DsaIsRunning() ) {

        if (Err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_CATEGORY,
                              pCC->pDefaultObjCategory->structLen,
                              pCC->pDefaultObjCategory)) {
            
            return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,Err);
        }
    }
    else {
        // Install phase. Build the DN from the AddArg


        DSNAME *pSchemaDN =  THAllocEx(pTHS, pAddArg->pObject->structLen);
        DSNAME *pObjCatName = THAllocEx(pTHS, pAddArg->pObject->structLen + 32*sizeof(WCHAR));


        TrimDSNameBy(pAddArg->pObject, 1, pSchemaDN);
        AppendRDN(pSchemaDN,
                  pObjCatName,
                  pAddArg->pObject->structLen + 32*sizeof(WCHAR),
                  ClassName,
                  0,
                  ATT_COMMON_NAME);
        if (Err = DBAddAttVal(pTHS->pDB,ATT_OBJECT_CATEGORY,
                              pObjCatName->structLen,pObjCatName)) {
            
            return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, Err);
        }
        THFreeEx(pTHS, pSchemaDN);
        THFreeEx(pTHS, pObjCatName);
    }

    return 0;
}


//-----------------------------------------------------------------------
//
// Function Name:            SetAttrSchemaAttr
//
// Routine Description:
//
//    Sets Special Attributes on Attribute Schema Object
//
// Author: RajNath
//
// Arguments:
//
//    ADDARG* pAddArg      Client Passed in Arguments to this Create Call
//
// Return Value:
//
//    BOOL             0 On Succeess
//
//-----------------------------------------------------------------------
BOOL
SetAttrSchemaAttr(
    THSTATE *pTHS,
    ADDARG* pAddArg
)
{
    DBPOS *pDB = pTHS->pDB;
    ATTRBLOCK* pAB=&(pAddArg->AttrBlock);
    DWORD cnt;
    ATTR* att=pAB->pAttr;
    ULONG err;
    CLASSCACHE *pCC;
    ULONG ulLinkID;
    ULONG ulSysFlags;
    BOOL  fIsPartialSetMember;
    int   syntax = 0, omSyntax = 0;
    extern BOOL gfRunningAsMkdit;

    //
    // These are the Attributes we want to help
    // out on for our and user's sanity.  Note that
    // here we only need to give default values to
    // attributes that *must* have values.  Things
    // such as the searchFlags are defaulted at schema
    // evaluation time if no value is present, and
    // hence don't need to be given a value here if
    // none was specified.
    //
    BOOL bSchemaIdGuid         = FALSE ;
    BOOL bLdapDisplayName      = FALSE ;
    BOOL bAdminDisplayName     = FALSE ;
    BOOL bIsSingleValued       = FALSE ;
    BOOL bOMObjectClass        = FALSE ;
    BOOL bIntId                = FALSE ;

    // Irrespective of if the user has set any value or not, set the
    // object-category to attribute-schema.

    if (SetSchObjCategory(pTHS, pAddArg, CLASS_ATTRIBUTE_SCHEMA)) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    //
    // Lets find which of the defualt attributes they have not set.
    // Plus, gather some syntax info to correctly set omObjectClass
    // if needed
    //
    for (cnt=pAB->attrCount;cnt;cnt--,att++)
    {
        switch(att->attrTyp)
        {
        case ATT_SCHEMA_ID_GUID       : bSchemaIdGuid         = TRUE ;  break ;
        case ATT_LDAP_DISPLAY_NAME    : bLdapDisplayName      = TRUE ;  break ;
        case ATT_ADMIN_DISPLAY_NAME   : bAdminDisplayName     = TRUE ;  break ;
        case ATT_IS_SINGLE_VALUED     : bIsSingleValued       = TRUE ;  break ;
        case ATT_OM_OBJECT_CLASS      : bOMObjectClass        = TRUE ;  break ;
        case ATT_MS_DS_INTID          : bIntId                = TRUE ;  break ;
        case ATT_ATTRIBUTE_SYNTAX     : 
            if (att->AttrVal.valCount) {
                syntax = 0xFF & (*(int *) att->AttrVal.pAVal->pVal); 
            }
            break;
        case ATT_OM_SYNTAX            : 
            if (att->AttrVal.valCount) {
                omSyntax = *(int *) att->AttrVal.pAVal->pVal; 
            }
            break;
        case ATT_IS_DELETED           :
            // this object is marked as deleted
            // don't bother to fill in the missing attributes
            if (    att->AttrVal.valCount 
                &&  (*(ULONG *)(att->AttrVal.pAVal->pVal)) ){
                return 0;
            }
        }
    }


    //
    // Now Set All the properties they have not set.
    //

    if (  bSchemaIdGuid==FALSE ) {
        // Set the SchemaIdGuid for this Schema Object

        GUID data;
        DsUuidCreate(&data);

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_SCHEMA_ID_GUID,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR,err); 
        }

    }


    if (  bAdminDisplayName  ==FALSE ) {
        // Set the AdminDisplayName for this Schema Object by copying the RDN

        WCHAR  data[MAX_RDN_SIZE];
        ULONG  RDNlen;
        ULONG  RDNtyp;

        if (GetRDNInfo(pTHS, pAddArg->pObject,data,&RDNlen,&RDNtyp)!=0) {
            return SetNamError(NA_PROBLEM_BAD_NAME,
                   pAddArg->pObject,
                   DIRERR_BAD_NAME_SYNTAX);
        }

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_ADMIN_DISPLAY_NAME,
                  RDNlen*sizeof(WCHAR),
                  data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,ERROR_DS_DATABASE_ERROR,
                                 err); 
        }

    }


    if (  bIsSingleValued  ==FALSE ) {
        // Set the AdminDisplayName for this Schema Object by copying the RDN

        ULONG  data=0;

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_IS_SINGLE_VALUED,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_DATABASE_ERROR,
                                 err); 
        }

    }


    if (  bLdapDisplayName  ==FALSE ) {
        // Set the LdapDisplayName for this Schema Object

        WCHAR  rdn[MAX_RDN_SIZE];
        ULONG  RDNlen;
        ULONG  RDNtyp;
        WCHAR  data[MAX_RDN_SIZE];
        ULONG  datalen;

        if (GetRDNInfo(pTHS, pAddArg->pObject,rdn,&RDNlen,&RDNtyp)!=0) {
            return SetNamError(NA_PROBLEM_BAD_NAME,
                   pAddArg->pObject,
                   DIRERR_BAD_NAME_SYNTAX);
        }

        ConvertX500ToLdapDisplayName(rdn,RDNlen,data,&datalen);

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_LDAP_DISPLAY_NAME,
                  datalen*sizeof(WCHAR),
                  data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_DATABASE_ERROR,
                                 err); 
        }

    }

    if ( (omSyntax == OM_S_OBJECT) && (bOMObjectClass == FALSE) ) {
        // Object-syntaxed atribute with no om_object_class specified.
        // Default. The valid values used below are defined in scache.h

        ULONG valLen = 0;
        PVOID pTemp = NULL;
        PVOID pVal = NULL;

        
        switch (syntax) {
            case SYNTAX_DISTNAME_TYPE :
                // DS-DN
                valLen = _om_obj_cls_ds_dn_len;
                pTemp  = _om_obj_cls_ds_dn;
                break;
            case SYNTAX_ADDRESS_TYPE :
                // Presentation-Address
                valLen = _om_obj_cls_presentation_addr_len;
                pTemp  = _om_obj_cls_presentation_addr;
                break;
            case SYNTAX_OCTET_STRING_TYPE :
                // Replica-Link
                valLen = _om_obj_cls_replica_link_len;
                pTemp  = _om_obj_cls_replica_link;
                break;
            case SYNTAX_DISTNAME_STRING_TYPE :
                // Access-Point or DN-String. We will default to
                // Access-Point
                valLen = _om_obj_cls_access_point_len;
                pTemp  = _om_obj_cls_access_point;
                break;
            case SYNTAX_DISTNAME_BINARY_TYPE :
                // OR-Name or DN-Binary. We will default to OR-Name
                valLen = _om_obj_cls_or_name_len;
                pTemp  = _om_obj_cls_or_name;
                break;
            default :
                // Attribute-syntax and OM-syntax do not match,
                // since the above are the only matching attribute 
                // syntaxes corresponding to OM_S_OBJECT om-syntax.
                // This add will anyway fail later during schema 
                // validation where we check for mismatched
                // syntaxes. Don't fail it here, so that it fails
                // during schema validation and the error is logged
                
                DPRINT(0,"Syntax Mismatch detected in SetAttrSchemaAtts for object-syntaxed attribute\n");
                valLen = 0;

        }  
 
        if (valLen) {
            pVal = THAllocEx(pTHS, valLen);

            memcpy(pVal, pTemp, valLen);

            // Write it out to dblayer
            if (err = DBAddAttVal(pDB,
                      ATT_OM_OBJECT_CLASS,
                      valLen,
                      pVal)) {
                return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_DATABASE_ERROR,
                                     err);
            }
        }
    }

    if (DBGetSingleValue(pDB, ATT_LINK_ID, &ulLinkID, sizeof(ulLinkID), NULL)) {
        ulLinkID = 0;
    }

    if (DBGetSingleValue(pDB, ATT_SYSTEM_FLAGS, &ulSysFlags, sizeof(ulSysFlags),
                         NULL)) {
        ulSysFlags = 0;
    }

    if (DBGetSingleValue(pDB, ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET,
                         &fIsPartialSetMember, sizeof(fIsPartialSetMember),
                         NULL)) {
        fIsPartialSetMember = FALSE;
    }

    if (FIsBacklink(ulLinkID) && !(ulSysFlags & FLAG_ATTR_NOT_REPLICATED)) {
        // Set system flags to mark this backlink attribute as not replicated.
        ulSysFlags |= FLAG_ATTR_NOT_REPLICATED;

        DBResetAtt(pDB, ATT_SYSTEM_FLAGS, sizeof(ulSysFlags),
                   &ulSysFlags, SYNTAX_INTEGER_TYPE);
    }

    if ((ulSysFlags & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER)
        && !fIsPartialSetMember) {
        // Attributes that are members of the default (i.e., required) partial
        // set should be flagged as partial set members.
        fIsPartialSetMember = TRUE;

        DBResetAtt(pDB, ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET,
                   sizeof(fIsPartialSetMember), &fIsPartialSetMember,
                   SYNTAX_BOOLEAN_TYPE);
    }

    // Add a system generated internal id (intid)
    //     if not a base schema object
    //     if not running as mkdit (only base objects)
    //     if not replicating (assigned by originator)
    //     if not system (assigned by originator)
    //     if not running dcpromo (assigned by originator)
    //     if whistler beta3 or greater forest (downrev DCs die)
    //     if attribute definition exists
    if (   bIntId == FALSE
        && !(ulSysFlags & FLAG_SCHEMA_BASE_OBJECT)
        && !gfRunningAsMkdit
        && !pTHS->fDRA
        && !pTHS->fDSA
        && !DsaIsInstalling()
        && ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)
        && SCGetAttById(pTHS, ATT_MS_DS_INTID)) {

        ATTRTYP IntId = SCAutoIntId(pTHS);

        if (IntId == INVALID_ATT) {
            return SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_NO_MSDS_INTID, ERROR_DS_NO_MSDS_INTID); 
        }

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB, ATT_MS_DS_INTID, sizeof(IntId), &IntId)) {
            return SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_DATABASE_ERROR, err); 
        }
    }

    return 0;

} // End SetAttrSchemaAttr



//-----------------------------------------------------------------------
//
// Function Name:            SetClassSchemaAttr
//
// Routine Description:
//
//    Sets Special Attributes on Class Schema Object
//
// Author: RajNath
//
// Arguments:
//
//    ADDARG* pAddArg      Client Passed in Arguments to this Create Call
//
// Return Value:
//
//    BOOL             0 On Succeess
//
//-----------------------------------------------------------------------
BOOL
SetClassSchemaAttr(
    THSTATE *pTHS,
    ADDARG* pAddArg
)
{
    DBPOS *pDB = pTHS->pDB;
    ATTRBLOCK* pAB=&(pAddArg->AttrBlock);
    DWORD cnt;
    ATTR* att=pAB->pAttr;
    ULONG err;
    ULONG category = 0;     //initialized to avoid C4701
    CLASSCACHE *pCC;                                                  
    ULONG subClass=0, rdnAttId=ATT_COMMON_NAME;

    // These are the Attributes we want to help
    // out on for our and user's sanity
    //
    BOOL bObjectClassCategory  = FALSE ;
    BOOL bSchemaIdGuid         = FALSE ;
    BOOL bSubClassOf           = FALSE ;
    BOOL bPossSuperior         = FALSE ;
    BOOL bRDNAttId             = FALSE ;
    BOOL bSystemOnly           = FALSE ;
    BOOL bLdapDisplayName      = FALSE ;
    BOOL bAdminDisplayName     = FALSE ;

    // Irrespective of if the user has set any value or not, set the
    // object-category to class-schema.

    if (SetSchObjCategory(pTHS, pAddArg, CLASS_CLASS_SCHEMA)) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    //
    // Lets find which of the default attributes they have not set.
    //
    for (cnt=pAB->attrCount;cnt;cnt--,att++) {
        switch(att->attrTyp) {

      
        case ATT_OBJECT_CLASS_CATEGORY:
            if (att->AttrVal.valCount) {
                bObjectClassCategory = TRUE;
                category = *(ULONG *)(att->AttrVal.pAVal->pVal);
            }
            break;

        case ATT_SCHEMA_ID_GUID:
            bSchemaIdGuid = TRUE;
            break;

        case ATT_SUB_CLASS_OF:
            if (att->AttrVal.valCount) {
                bSubClassOf = TRUE;
                subClass = *(ULONG *)(att->AttrVal.pAVal->pVal);
            }
           break;
        
        case ATT_SYSTEM_POSS_SUPERIORS:
        case ATT_POSS_SUPERIORS:
            bPossSuperior = TRUE;
            break;
        
        case ATT_RDN_ATT_ID:
            if (att->AttrVal.valCount) {
                bRDNAttId = TRUE;
                rdnAttId = *(ULONG *)(att->AttrVal.pAVal->pVal);
            }
            break;
        
        case ATT_SYSTEM_ONLY:
            bSystemOnly = TRUE;
            break;
        
        case ATT_LDAP_DISPLAY_NAME:
            bLdapDisplayName = TRUE;
            break;
        
        case ATT_ADMIN_DISPLAY_NAME:
            bAdminDisplayName = TRUE;
            break;
            
        case ATT_IS_DELETED:
            // this object is marked as deleted
            // don't bother to fill in the missing attributes
            if (    att->AttrVal.valCount 
                &&  (*(ULONG *)(att->AttrVal.pAVal->pVal)) ){
                return 0;
            }
            break;
            
        default:
        ;           // nothing to do
        
        }
    }


    //
    // Set the values which they have not set
    //

    if ( bObjectClassCategory  == FALSE )
    {

        // Set the ObjectClassCategory for this Schema Object

    // If the category of the class is not specified then we assume
    // that it is an 88 class, because class categorization was not
    // present in the 88 spec, while the 93 spec requires classes
    // to be one of the explicit categories

        ULONG data = category = DS_88_CLASS;

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_OBJECT_CLASS_CATEGORY,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR,err);
        }
    }

    if ( bSchemaIdGuid == FALSE )
    {

        // Set the SchemaIdGuid for this Schema Object

        GUID data;
        DsUuidCreate(&data);

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_SCHEMA_ID_GUID,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR, err);
        }
    }

    if ( bSubClassOf == FALSE )
    {

        // Set the SubClassOf for this Schema Object

        ULONG data = CLASS_TOP; // By default...

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_SUB_CLASS_OF,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
        }
    }

    if ( bPossSuperior == FALSE && category == DS_88_CLASS)
    {

        // Set the PossSuperiors for this Schema Object

        ULONG data = CLASS_CONTAINER;

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_POSS_SUPERIORS,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR, err);
        }
    }

    if ( bRDNAttId == FALSE )
    {
        // Set the RDNAttId for this Schema Object from its superclass

        ULONG data = ATT_COMMON_NAME;

        // See if a subclass is specified. If not, we will default the
        // subClass value to Top, and hence, rdnAttId to cn (the variable
        // data is already set to it)

        if (bSubClassOf == TRUE) {
            // subClass specified. First try to get it in cache
            pCC = SCGetClassById(pTHS, subClass);
            if (pCC) {
                // found the class
               data = pCC->RdnExtId;
               rdnAttId = pCC->RdnExtId;
            }
            else {
               // not found. Possible if the superclass has also been just 
               // added. But in that case, if the rdn-att-id of the superclass
               // is anything but cn, we would have forced a cache update,
               // so this must be cn. Again, already set

            }
        }

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_RDN_ATT_ID,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR, err);
        }
    }

    // At this point, rdnAttId is set to whatever the rdn-att-id of the class
    // will be set to. If it is anything other than cn, indicate that we
    // need a schema cache update as part of this call. This is to ensure
    // that another class is immediately added as a subClass of this class,
    // and does not specify the rdnAttId, it can inherit the rdnAttId from
    // this class correctly from the cache. Otherwise, we will need to go to
    // the database to find the rdnAttId, which is not only costly (since we
    // will have to do a one-level search for the matching subClassOf attribute)
    // but more importantly, extremely complex at this point since we have a
    // prepared record at this point. An rdn-att-id != CN is rare, so an extra
    // cache update time is not a bummer really.


    if (rdnAttId != ATT_COMMON_NAME) {
        pTHS->RecalcSchemaNow = TRUE;
    }

    if ( bSystemOnly == FALSE )
    {

        // Set the systemonly for this Schema Object

        BOOL data=FALSE; // We set it true for all our classes,
                         // everything else is false

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_SYSTEM_ONLY,
                  sizeof(data),
                  &data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR, err);
        }
    }


    if (  bAdminDisplayName  ==FALSE )

    {
        // Set the SytemOnly for this Schema Object

        WCHAR  data[MAX_RDN_SIZE];
        ULONG  RDNlen;
        ULONG  RDNtyp;

        if (GetRDNInfo(pTHS, pAddArg->pObject,data,&RDNlen,&RDNtyp)!=0)
        {
            return SetNamError(NA_PROBLEM_BAD_NAME,
                   pAddArg->pObject,
                   DIRERR_BAD_NAME_SYNTAX);
        }

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                  ATT_ADMIN_DISPLAY_NAME,
                  RDNlen*sizeof(WCHAR),
                  data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR, err);
        }
    }


    if (  bLdapDisplayName  ==FALSE )

    {
        // Set the LdapDisplayName for this Schema Object

        WCHAR  rdn[MAX_RDN_SIZE];
        ULONG  RDNlen;
        ULONG  RDNtyp;
        WCHAR  data[MAX_RDN_SIZE];
        ULONG  datalen;

        if (err = GetRDNInfo(pTHS, pAddArg->pObject,rdn,&RDNlen,&RDNtyp)) {
            return SetNamErrorEx(NA_PROBLEM_BAD_NAME,
                                 pAddArg->pObject,
                                 DIRERR_UNKNOWN_ERROR,
                                 err);
        }

        ConvertX500ToLdapDisplayName(rdn,RDNlen,data,&datalen);

        // Write it out to dblayer
        if (err = DBAddAttVal(pDB,
                              ATT_LDAP_DISPLAY_NAME,
                              datalen*sizeof(WCHAR),
                              data)) {
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_DATABASE_ERROR, err);
        }

    }

    return 0;

}

int
CheckParentSecurity (
        RESOBJ *pParent,
        CLASSCACHE *pObjSch,
        BOOL fAddingDeleted,
        PDSNAME pNewObjectDN,
        PSECURITY_DESCRIPTOR *ppNTSD,
        ULONG *pcbNTSD,
        BOOL* pfSDIsGlobalSDRef
        )
/* Get the parent of the object to add and check access.

   This routine assumes the parent of the new object lives on this machine (no
   chaining).

   This routine fills in the GUID and SID of the pParent DSNAME.

   This assumption is ok for the XDS interface (ds_add_entry) because it
   doesn't allow the addition of NCs so the parent has to be in the same NC,
   guaranteeing the same machine.

   This routine will return the security descriptor of the parent object for
   further security checks.

Arguments:
    pParent             -- parent object RESOBJ
    pObjSch             -- class of the object being created
    fAddingDeleted      -- (dra only) adding a deleted object
    pNewObjectDN        -- (optional) DN of the new object for create_child audits (both GUID and StringName are used)
    ppNTSD              -- (OUT) ptr to parent's SD
    pcbNTSD             -- (OUT) length of parent's SD
    pfSDIsGlobalSDRef   -- (OUT) is parent's SD a ref to a cached SD?
   
*/

{
    THSTATE * pTHS = pTHStls;
    UCHAR  syntax;
    ULONG  len;
    unsigned i,j;
    ULONG classP, ulLen;
    UCHAR *pVal;
    ULONG err;
    BOOL fLegit=FALSE;
    CLASSCACHE *pCC;

    DPRINT(4, "CheckParentSecurity Entered.\n");

    // In case we leave early, set the security descriptor we're going to return
    // (which is the SD of the parent object we are checking) to null.
    if(ppNTSD)  {
        *ppNTSD = NULL;
    }
    *pcbNTSD = 0;

    if (!pTHS->fDRA) {
        if (pParent->IsDeleted) {
            return SetNamError(NA_PROBLEM_NO_OBJECT,
                               pParent->pObj,
                               DIRERR_NO_PARENT_OBJECT);
        }
            
        if(ppNTSD) {
            if (err = DBFindDNT(pTHS->pDB, pParent->DNT)) {
                return SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                                     pParent->pObj,
                                     DIRERR_NO_PARENT_OBJECT,
                                     err);
            }

            // The caller wants us to evaluate security, so pick up the SD
            err = DBGetObjectSecurityInfo(pTHS->pDB, pTHS->pDB->DNT,
                                          pcbNTSD, ppNTSD,  // parent's SD
                                          &pCC,             // parent's class
                                          NULL, NULL,
                                          DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                                          pfSDIsGlobalSDRef
                                         );
            if (err) {
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }
            if (*pcbNTSD == 0) {
                  // Every object should have an SD.
                  Assert(!DBCheckObj(pTHS->pDB));
                  *pcbNTSD = 0;
                  *ppNTSD = NULL;
              }
            // Check access to the parent.
            if(!DsaIsInstalling() &&
               !IsAccessGranted(*ppNTSD,
                                pParent->pObj,
                                pCC,
                                pObjSch,
                                RIGHT_DS_CREATE_CHILD,
                                pNewObjectDN != NULL ? pNewObjectDN->StringName : NULL,
                                pNewObjectDN != NULL ? &pNewObjectDN->Guid : NULL,
                                TRUE)) {
                return pTHS->errCode;
            }

        }

        // Find the class(es) of the parent and verify that it is a legal
        // possible superior of the class we are trying to add.
        fLegit = FALSE;

        // First, try the parent's most specific object class
        for (i=0; i<pObjSch->PossSupCount; i++){
            if (pParent->MostSpecificObjClass == pObjSch->pPossSup[i]) {
                /* legit superior */
                fLegit = TRUE;
                break;
            }
        }

        // Next, if needed, try the parent's set of superclasses
        if (!fLegit) {
            pCC = SCGetClassById(pTHS, pParent->MostSpecificObjClass);
            if (pCC) {
                for (j=0; j<pCC->SubClassCount && !fLegit; j++) {
                    for (i=0; i<pObjSch->PossSupCount; i++){
                        if (pCC->pSubClassOf[j] == pObjSch->pPossSup[i]) {
                            /* legit superior */
                            fLegit = TRUE;
                            break;
                        }
                    }
                }
            }
        }

        if (!fLegit) {
            // The parent wasn't on the list of possible superiors,
            // so reject.
            return SetNamError(NA_PROBLEM_NAMING_VIOLATION,
                               pParent->pObj,
                               DIRERR_ILLEGAL_SUPERIOR);
        }
    }
    
    return 0;

}

CLASSCACHE *
FindMoreSpecificClass(
        CLASSCACHE *pCC1,
        CLASSCACHE *pCC2
        )
/*++
Routine Description
    Returns the most specific of two classcache pointers passed in.
    The class return is a subclass of the other.  If neither is
    a subclass of the other, NULL is returned.

Paramters
    pCC1, pCC2 - class cache pointers to compare

Return
    pCC1 if pCC1 is a subclass of pCC2, pCC2 if pCC2 is a subclass of pCC1,
    NULL if neither is the case
--*/
{
    unsigned  count;

    if(pCC1 == pCC2) {
        return NULL;
    }

    for (count = 0; count < pCC1->SubClassCount; count++){
        if(pCC1->pSubClassOf[count] == pCC2->ClassId) {
            // pCC1 is a subclass of pCC2.  Return pCC1
            return pCC1;
        }
    }

    // OK, pCC1 is not a subclass of pCC2.  Try the other way.
    for (count = 0; count < pCC2->SubClassCount; count++){
        if(pCC2->pSubClassOf[count] == pCC1->ClassId) {
            // pCC1 is a subclass of pCC2.  Return pCC1
            return pCC2;
        }
    }

    return NULL;
}


int
FindValuesInEntry (
        IN  THSTATE     *pTHS,
        IN  ADDARG      *pAddArg,
        OUT CLASSCACHE **ppCC,
        OUT GUID        *pGuid,
        OUT BOOL        *pFoundGuid,
        OUT NT4SID      *pSid,
        OUT DWORD       *pSidLen,
        OUT CLASSSTATEINFO  **ppClassInfo
        )
/*++
Routine Description

    Tries to find specific values (objectClass, GUID, Sid) in the AttrBlock 
    specified (AddArg). 

    specifically for objectClass:
    It analyzes all the values of objectClass and breaks them apart into 
    objectClass and auxClasses. All the classes that are in the hierarchy
    of ONE structural class are considered to belong in the objectClass of the 
    object. The rest of the classes of type auxClass or abstract are 
    considered to belong in the auxClasses.

Parameters
    pAddArg - the ADDARG that containes the data added to the object
    
    ppCC - the CLASSCACHE of the most specific structural class of the object
    pGuid - the GUID of the object
    pFoundGuid - set to TRUE if pGuid valid

    pClassInfo - it is allocated if we are setting the objectClass
                 and we have found a potential auxClass for the object
    pClassInfo->pNewObjClasses - the new objectClass set of the object
    
Return
    0 on Success
    Err on Failure

--*/
{
    DWORD            err = 0;
    ULONG            oclass;
    ULONG            i, j, k, usedPos;
    CLASSCACHE       *pCC, *pCCNew, *pCCtemp;
    BOOL             fFoundClass=FALSE;
    CLASSSTATEINFO   *pClassInfo = NULL;
    CROSS_REF_LIST   *pCRL = NULL;
    ATTRBLOCK        *pAttrBlock = &pAddArg->AttrBlock;
    CREATENCINFO     *pCreateNC = pAddArg->pCreateNC;

    pCC = NULL;
    *ppCC = NULL;
    memset(pGuid,0,sizeof(GUID));
    memset(pSid,0,sizeof(SID));
    *pFoundGuid = FALSE;
    *pSidLen = 0;
    
    for(i=0;i<pAttrBlock->attrCount;i++) {

        switch(pAttrBlock->pAttr[i].attrTyp) {
        case ATT_OBJECT_CLASS:
            
            if (fFoundClass) {
                // we don't allow multiple objectClass assignments
                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   ERROR_DS_ILLEGAL_MOD_OPERATION);
            }

            usedPos = 0xffffffff;   //an invalid position
            
            // try to find the first abstract or structural class value 
            // keep adding the auxClasses to the list

            // find the first structural class, so as to have something to work with
            // we consider that this struct class belongs to the object structural 
            // hierarchy, since auxClasses cannot subclass from structural
            for (j=0; j<pAttrBlock->pAttr[i].AttrVal.valCount;j++) {
                oclass = *(ULONG *)pAttrBlock->pAttr[i].AttrVal.pAVal[j].pVal;
                if(!(pCC = SCGetClassById(pTHS, oclass))) {
                    DPRINT1(2, "Object class 0x%x undefined.\n", oclass);
                    return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                       ERROR_DS_OBJ_CLASS_NOT_DEFINED);
                }

                if (pCC->ClassCategory == DS_88_CLASS || 
                    pCC->ClassCategory == DS_STRUCTURAL_CLASS) {

                    // keep the pos, so as not to check it again later
                    usedPos = j;
                    break;
                }
            }

            // Now, look at all the object classes.  Make sure they describe a
            // (possibly incomplete) inheritence chain, not a web.
            for(j=0 ; j<pAttrBlock->pAttr[i].AttrVal.valCount; j++) {
                if (j == usedPos) {
                    // we have seen this position
                    continue;
                }
                oclass = *(ULONG *)pAttrBlock->pAttr[i].AttrVal.pAVal[j].pVal;
                if(!(pCCNew = SCGetClassById(pTHS, oclass))) {
                    DPRINT1(2, "Object class 0x%x undefined.\n", oclass);
                    return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                       ERROR_DS_OBJ_CLASS_NOT_DEFINED);
                }

                // make sure pCCNew inherits from pCC or vice versa
                pCCtemp = FindMoreSpecificClass(pCC, pCCNew);
                if(!pCCtemp) {
                    // Ooops, pCCNew is not in the chain for objectClass.
                    // It might be an auxClass, or a chain for an auxClass
                    // We don't care for a chain of an auxCLass, since we will
                    // check this later. We just add it for now if it is ok
                    if (pCCNew->ClassCategory != DS_STRUCTURAL_CLASS) {

                        DPRINT1 (1, "Found auxClass (%s) while creating object\n", pCCNew->name);

                        // only do this if we are told so
                        if (ppClassInfo) {
                            // we do this only once
                            if (!pClassInfo) {
                                if (*ppClassInfo==NULL) {
                                    pClassInfo = ClassStateInfoCreate (pTHS);
                                    if (!pClassInfo) {
                                        return pTHS->errCode;
                                    }
                                    *ppClassInfo = pClassInfo;
                                }
                                else {
                                    pClassInfo = *ppClassInfo;
                                }

                                ClassInfoAllocOrResizeElement(pClassInfo->pNewObjClasses, 
                                                               pAttrBlock->pAttr[i].AttrVal.valCount, 
                                                               pClassInfo->cNewObjClasses_alloced, 
                                                               pClassInfo->cNewObjClasses);

                                // we copy the whole thing over
                                pClassInfo->cNewObjClasses = pAttrBlock->pAttr[i].AttrVal.valCount;
                                for (k=0; k<pClassInfo->cNewObjClasses; k++) {
                                    pClassInfo->pNewObjClasses[k] = *(ULONG *)pAttrBlock->pAttr[i].AttrVal.pAVal[k].pVal;
                                }
                                pClassInfo->fObjectClassChanged = TRUE;
                            }
                        }
                    }
                    else {
                        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                           ERROR_DS_OBJ_CLASS_NOT_SUBCLASS);
                    }
                }
                else {
                    pCC = pCCtemp;
                }
            }

            // so we found one class that we consider it to belong on
            // the structural objectClass hierarchy. we will check the type later.
            *ppCC = pCC;
            fFoundClass=TRUE;

            // No structural class, the schema reuse feature may generate an object
            // without any structural class. If this call is an original write, it will 
            // be rejected; but if this is DRA, then we have to live with it, but tell
            // SetClassInheritance() not to process it any further.
            if (pTHS->fDRA && 0xffffffff == usedPos && ppClassInfo && pClassInfo) {
                pClassInfo->fObjectClassChanged = FALSE;
            }
            
            break;

        case ATT_OBJECT_GUID:
            // Get the first GUID value.  The add will fail later if there are
            // more than one GUID values specified.
            if(pAttrBlock->pAttr[i].AttrVal.pAVal->valLen == sizeof(GUID)) {
                memcpy(pGuid,
                       pAttrBlock->pAttr[i].AttrVal.pAVal->pVal,
                       sizeof(GUID));
                *pFoundGuid = TRUE;
            }
            // else size is wrong, just ignore.  This will cause a failure
            // later. 
            break;

        case ATT_OBJECT_SID:
            if(pAttrBlock->pAttr[i].AttrVal.pAVal->valLen <= sizeof(NT4SID)) {
                *pSidLen = pAttrBlock->pAttr[i].AttrVal.pAVal->valLen;
                memcpy(pSid,
                       pAttrBlock->pAttr[i].AttrVal.pAVal->pVal,
                       pAttrBlock->pAttr[i].AttrVal.pAVal->valLen);
            }
            // else size is wrong, just ignore.  This will cause a failure
            // later. 
            break;

        default:
            break;
        }
    }
    
    // We had to have found the class, we didn't necessarily find a guid or sid
    if(!fFoundClass) {
        DPRINT(2, "Couldn't find Object class \n");

        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           DIRERR_OBJECT_CLASS_REQUIRED);
    }
    else {
        return 0;
    }
}


int
StripAttsFromDelObj(THSTATE *pTHS,
                    DSNAME *pDN)
{
    DBPOS *pDB = pTHS->pDB;
    ULONG valLen;
    BOOL Deleted, fNeedsCleaning;
    UCHAR syntax;
    ATTRTYP aType;
    ULONG   attrCount=0,i;
    ATTR    *pAttr;
    DWORD dwFindStatus = DBFindDSName(pDB, pDN);

    if (dwFindStatus == DIRERR_OBJ_NOT_FOUND)
        return 0;       // no dead object to strip

    if (dwFindStatus != DIRERR_NOT_AN_OBJECT) {
        if(!DBGetSingleValue(pDB, ATT_IS_DELETED, &Deleted,
                             sizeof(Deleted), NULL) &&
           Deleted) {
            dwFindStatus = DIRERR_NOT_AN_OBJECT;

        }
    }
    Assert(dwFindStatus == DIRERR_NOT_AN_OBJECT);

    // If object needs cleaning, we must delay
    if(!DBGetSingleValue(pDB, FIXED_ATT_NEEDS_CLEANING, &fNeedsCleaning,
                         sizeof(fNeedsCleaning), NULL) &&
       fNeedsCleaning)
    {
        DSNAME *pPhantomDN = DBGetDSNameFromDnt( pDB, pDB->DNT );
        DPRINT1( 0, "Phantom promotion of %ls delayed because it needs cleaning.\n",
                 pPhantomDN ? pPhantomDN->StringName : L"no name" );
        return SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_OBJECT_BEING_REMOVED );
    }

    // Call DBGetMultipleAtts to get a list of all attrtyp's on the object.

    if(!DBGetMultipleAtts(pDB, 0, NULL, NULL, NULL,
                          &attrCount, &pAttr, 0, 0)) {
        // Got some attributes.
        for(i=0;i<attrCount;i++) {
            ATTCACHE *pAC;
            pAC = SCGetAttById(pTHS, pAttr[i].attrTyp);
            Assert(pAC != NULL);

            if(!FIsBacklink(pAC->ulLinkID)
               && pAC->id != ATT_RDN
               && pAC->id != ATT_OBJECT_GUID
               ) {
                DBRemAtt(pDB, pAttr[i].attrTyp);
            }
        }

        DBUpdateRec(pDB);
    }

    return 0;
}

DWORD
fVerifyRDN(
        WCHAR *pRDN,
        ULONG ulRDN
        )
{
    DWORD i;
    for(i=0;i<ulRDN;i++)
        if(pRDN[i]==BAD_NAME_CHAR || pRDN[i]==L'\0')
            return 1;

    return 0;
}


/*++ AddAutoSubRef
 *
 * This routine will create a real subref object if and only if the object
 * being added is a crossref whose NC-Name describes an NC that is an
 * immediate child of an object that is in a writable NC instantiated on
 * this machine.  This will cause the ATT_SUBREFS attribute on the head
 * of the NC that's growing the new subref to properly get the value of
 * the new NC.
 *
[Don Hacherl] When you create the CR, the object has a couple choices.  It can
either exist as an NC head (based on instance type), or be totally outside the
hierarchical scope of any instantiated NC held by this DSA, or not exist, but
identify the immediate child of an instantiated object which does exist.  If
none of those conditions are true, the CR creation will be rejected.

[Don Hacherl] AddAutoSubref is triggered during CR creation, and may or may
not take any action depending on which of the conditions in the previour
paragraph were true.

 * Please also see our sister routine, mdmod.c::ModAutoSubRef().
 *
 * INPUT:
 *  id     - class ID of the object being added
 *  pObj   - DSNAME of the oject being added
 * RETURN VALUE:
 *  0      - no error
 *  non-0  - error
 */
int
AddAutoSubRef(THSTATE *pTHS,
              ULONG id,
              ADDARG *pAddArg,
              BOOL fAddingDeleted)
{
    DSNAME *pObj = pAddArg->pObject;
    DBPOS  *pDBTmp, *pDBSave;
    ULONG   err;
    DSNAME *pNCName;
    BOOL    fDsaSave;
    BOOL    fDraSave;
    BOOL    fCommit;
    DSNAME *pNCParent = NULL;
    ULONG   len;
    SYNTAX_INTEGER iType;

    // We only need to do something if we're adding a cross ref
    if (id != CLASS_CROSS_REF) {
        return 0;
    }

    // We enter this routine pre-positioned on the cross-ref object
    // being added, so we can read the NC-Name directly.
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_NC_NAME,
                      0,
                      0,
                      &len,
                      (UCHAR**) &pNCName);
    if (err) {
        SetAttError(pObj,
                    ATT_NC_NAME,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_MISSING_REQUIRED_ATT);
        return pTHS->errCode;
    }

    LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
              DS_EVENT_SEV_MINIMAL,
              DIRLOG_ADD_AUTO_SUBREF,
              szInsertDN(pObj),
              szInsertDN(pNCName),
              szInsertUUID(&(pNCName->Guid)),
              szInsertUL( 0 ),
              NULL, NULL, NULL, NULL);

    fDsaSave = pTHS->fDSA;
    fDraSave = pTHS->fDRA;
    pTHS->fDSA = TRUE;  // suppress checks
    pTHS->fDRA = FALSE; // not a replicated add
    pDBSave = pTHS->pDB;
    fCommit = FALSE;

    DBOpen(&pDBTmp);
    pTHS->pDB = pDBTmp; // make temp DBPOS the default
    __try {
        // Check to see if there's an object to hang the subref off of
        pNCParent = THAllocEx(pTHS, pNCName->structLen);
        TrimDSNameBy(pNCName, 1, pNCParent);
        if (IsRoot(pNCParent)) {
            // Either the parent of the NC name doesn't exist here, or the
            // NC is a direct parent of the (semi-present everywhere) root,
            // which means that this NC is off in space and we don't
            // have anything to create a subref off of.
            goto leave_actions;
        }
        err = DBFindDSName(pDBTmp, pNCParent);
        // Parent should be either an object or a phantom
        if (err == DIRERR_NOT_AN_OBJECT) {
            LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_ADD_AUTO_SUBREF_NO_PARENT,
                      szInsertDN(pObj),
                      szInsertDN(pNCName),
                      szInsertUUID(&(pNCName->Guid)),
                      szInsertDN(pNCParent),
                      NULL, NULL, NULL, NULL);
            err = 0;
            goto leave_actions;
        } else if (err) {
            // Error finding parent
            Assert( !"Unexpected error locating parent of nc" );
            SetSvcErrorEx(SV_PROBLEM_UNABLE_TO_PROCEED,
                          DIRERR_OBJ_NOT_FOUND, err);
            __leave;
        }

        // Check the parent's instance type.  If the parent is uninstantiated,
        // then we don't want a subref under a subref and can bail.
        if ( err = DBGetSingleValue(pDBTmp, ATT_INSTANCE_TYPE, &iType,
                                    sizeof(iType),NULL) ) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_CANT_RETRIEVE_INSTANCE, err);
            __leave;
        }
        else if ( iType & IT_UNINSTANT ) {
            // No subref required.
            goto leave_actions;
        }
    
        // See if the named NC exists
        // If we are adding a deleted cross ref, we don't want the subref to show up on the
        // ATT_SUB_REF list, and if we are adding a live cross ref, we do want the subref
        // to show up on the list. This is independent from whether the name is mangled,
        // which is handled below.
        Assert(err == 0);
        err = DBFindDSName(pDBTmp, pNCName);
        if (err == 0) {
            // The subref object already exists, we don't need to add it.
            // We should, however, ensure that it is in the NC above's SUBREF
            // list.
            //
            // This is specifically to handle the case where a cross-ref for a
            // given NC is removed and then re-added before the KCC kicks in to
            // remove the NC.  In this case, we've already removed the DN for
            // this NC from the parent NC's subref list (see DelAutoSubRef()),
            // so we now need to add it back in.
            if (!fAddingDeleted) {
                err = AddSubToNC(pTHS, pNCName,DSID(FILENO,__LINE__));
            }
        } else if ( (err == DIRERR_OBJ_NOT_FOUND) ||
                    (err == DIRERR_NOT_AN_OBJECT) ) {
            // Subref does not exist
            err = AddPlaceholderNC(pDBTmp, pNCName, SUBREF);
            if ( (!err) && fAddingDeleted ) {
                // Turn the placeholder nc into a tombstone
                // This has the effect of removing the nc from the parent's subref list
                REMOVEARG removeArg;
                memset( &removeArg, 0, sizeof( removeArg ) );
                removeArg.pResObj = CreateResObj(pDBTmp, pNCName);
                if (!removeArg.pResObj) {
                    /*Couldn't create a resobj when we're on the object? Bogus */
                    err = SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, DIRERR_OBJ_NOT_FOUND);
                } else {
                    removeArg.pObject = pNCName;
                    removeArg.fPreserveRDN = FALSE;
                    err = LocalRemove(pTHS, &removeArg);
                    THFreeEx(pTHS, removeArg.pResObj);
                }
            }
        } else {
            // Error
            err = SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_DATABASE_ERROR );
        }

    leave_actions:

        if ( (!err) && (!fAddingDeleted) ) {
            err = CheckNcNameForMangling( pTHS, pAddArg->pObject, pNCParent, pNCName );
        }

        Assert(!err || pTHS->errCode);
        fCommit = (0 == pTHS->errCode);
    }
     __finally {
         if (pNCParent) {
             THFreeEx(pTHS, pNCParent);
         }
         DBClose(pDBTmp, fCommit);
         pTHS->pDB = pDBSave;

         pTHS->fDSA = fDsaSave;
         pTHS->fDRA = fDraSave;
     }

     return pTHS->errCode;
}


int
AddPlaceholderNC(
    IN OUT  DBPOS *         pDBTmp,
    IN OUT  DSNAME *        pNCName,
    IN      SYNTAX_INTEGER  it
    )
/*++

Routine Description:

    Creates a placeholder NC object with the given name and instance type.  This
    object does not hold the properties of the real NC head (other than its DN,
    GUID, and SID).  It is a placeholder in the namespace that will be replaced
    by the real NC object if it is ever replicated in.

Arguments:

    pDBTmp (IN/OUT)

    pNCName (IN/OUT) - Name of the NC for which to create the placeholder.  If
        no GUID is supplied in the DSNAME, one will be generated and added to
        it.

    it (IN) - Instance type to assign to the NC.

Return Values:

    0 - Success.
    other THSTATE error code - Failure.

--*/
{
    THSTATE *               pTHS = pDBTmp->pTHS;
    ULONG                   oc;
    CLASSCACHE *            pCC;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    DWORD                   cbSD;
    BOOL                    fAddGuid;
    GUID                    Guid;
    DWORD                   err;

    // We need a very stripped down version of LocalAdd, because
    // there are lots of things we don't want to do when adding the
    // subref.  Among others, we don't want to check security, assign
    // a GUID (maybe), set the instance type normally, validate against
    // the schema, or even set a sensible object class.  We just want a
    // placeholder NC (e.g., a naked subref).
    //
    // Note that the reason we don't want to set a GUID or SID is rather
    // subtle.  Specifically, since the subref we're trying to add has
    // the name of the NC-Name attribute from the main object being added,
    // creating the subref here will *always* result in a phantom promotion
    // during the DBAddAttVal(OBJ_DIST_NAME), because a phantom of this
    // name would have already been created.  Since that phantom has
    // already been assigned whatever GUID or SID it deserves during
    // the main add, we do not need to redundantly set those now.
    //
    // However, if the NC-Name doesn't have a GUID, we want to make one
    // up now and slap it on, so that the subref can be name mangled
    // at deletion time, so that a new subref (or object) of the same
    // name can be added after the deletion.  Whew.
    //
    // Therefore the code that follows is a selected excerpt from the
    // normal add path, calling only those worker routines that we
    // think need to get invoked in this case, and skipping the
    // many others.

    oc = CLASS_TOP;     // gotta have something

    // Get classcache of Top. Must have some object-category, so
    // we will give the  default-object-category of Top
    if (!(pCC = SCGetClassById(pTHS, CLASS_TOP))) {
        // Can't even get the classcache for Top? Something is messed up,
        // no point going on
        DPRINT(0,"AddUninstantiatedNC: Cannot get Classcache for Top\n");
        SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE);
        return pTHS->errCode;
    }

    fAddGuid = fNullUuid(&pNCName->Guid);
    if (fAddGuid) {
        Assert(!"I believe the GUID should've been set by VerifyNcName");
        DsUuidCreate(&Guid);
    }

    if (!(IT_UNINSTANT & it)) {
        // Instantiated objects must have a security descriptor.  Add the
        // default SD for the domainDNS class.
        err = GetPlaceholderNCSD(pTHS, &pSD, &cbSD);
        if (err) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR, err);
        }
    }

    // Derive the NCDNT.
    if ( FindNcdntSlowly(
            pNCName,
            FINDNCDNT_DISALLOW_DELETED_PARENT,
            FINDNCDNT_ALLOW_PHANTOM_PARENT,
            &pDBTmp->NCDNT
            )
       )
    {
        // Failed to derive NCDNT.
        // This should never happen, as above we verified that a qualified
        // parent exists, and that should be the only reason we could fail.
        Assert(!"Failed to derive NCDNT for auto-generated SUBREF!");
        Assert(0 != pTHS->errCode);
        return pTHS->errCode;
    }

    if (ROOTTAG != pDBTmp->NCDNT) {
        // We hold a copy of the NC above this one; IT_NC_ABOVE should be set.
        it |= IT_NC_ABOVE;
    }

    DBInitObj(pDBTmp);

    if(pNCName->SidLen) {
        // We need to touch the metadata on the SID so it replicates out.
        ATTCACHE   *pACObjSid;
        pACObjSid = SCGetAttById(pTHS, ATT_OBJECT_SID);
        //
        // PREFIX: PREFIX complains that pACObjSid hasn't been checked to
        // make sure that it is not NULL.  This is not a bug.  Since
        // a predefined constant was passed to SCGetAttById, pACObjSid will
        // never be NULL.
        //

        Assert(pACObjSid);
        DBTouchMetaData(pDBTmp, pACObjSid);
    }

    if (
        DBAddAttVal(pDBTmp, ATT_INSTANCE_TYPE, sizeof(it), &it)
        ||
        DBAddAttVal(pDBTmp, ATT_OBJECT_CLASS, sizeof(oc), &oc)
        ||
        DBAddAttVal(pDBTmp, ATT_OBJECT_CATEGORY, 
                    pCC->pDefaultObjCategory->structLen, 
                    pCC->pDefaultObjCategory)
        ||
        DBAddAttVal(pDBTmp, ATT_OBJ_DIST_NAME, pNCName->structLen, pNCName)
        ||
        (fAddGuid
         ? DBAddAttVal(pDBTmp, ATT_OBJECT_GUID, sizeof(GUID), &Guid)
         : 0)
        ||
        (pSD
         ? DBAddAttVal(pDBTmp, ATT_NT_SECURITY_DESCRIPTOR, cbSD, pSD)
         : 0)
        ||
        DBRepl(pDBTmp, pTHS->fDRA, DBREPL_fADD | DBREPL_fKEEP_WAIT, 
                NULL, META_STANDARD_PROCESSING)
        ||
        AddCatalogInfo(pTHS, pNCName)
        ||
        AddObjCaching(pTHS, pCC, pNCName, FALSE, FALSE)) {
        // Something failed.
        if (0 == pTHS->errCode) {
            // One of the DB operations failed.
            SetSvcError(SV_PROBLEM_BUSY, DIRLOG_DATABASE_ERROR);
        }
    }
    else {
        Assert(0 == pTHS->errCode); // all went well
    }

    if (NULL != pSD) {
        THFreeEx(pTHS, pSD);
    }

    return pTHS->errCode;
}


int
SetShowInAdvancedViewOnly(
    THSTATE *pTHS,
    CLASSCACHE *pCC)

/*++

Description:

    Sets the Show_in_Advanced_View_Only attribute iff it wasn't provided by the
    caller and Default-Hiding-Value is TRUE for the class of object added.
    Assumes we are positioned at the object being added.

Arguments:

    pCC - Pointer to CLASSCACHE for the class of object being added.

Return value:

    0 on success.  !0 otherwise and sets pTHStls->errCode as well.


--*/
{
    BOOL    tmp;
    BOOL    *pTmp = &tmp;
    ULONG   len;
    DWORD   dwErr;

    if ( !pCC->bHideFromAB || pTHS->fDRA )
    {
        return(0);
    }

    // We can't just do DBAddAttVal because it will add a second value
    // if a FALSE has already been written.  So read first, then write
    // if there is no value.

    dwErr = DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_SHOW_IN_ADVANCED_VIEW_ONLY,
                        DBGETATTVAL_fCONSTANT,
                        sizeof(tmp),
                        &len,
                        (PUCHAR *) &pTmp);

    switch ( dwErr )
    {
    case 0:

        // Caller supplied his own value - no need for ours.
        return(0);

    case DB_ERR_NO_VALUE:

        // We need to set a value.
        break;

    default:

        // All problems are assumed to be temporary. (record locks, etc.)
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

    // CLASSCACHE.bHideFromAB is a bit field, thus we can't write the field
    // from the CLASSCACHE entry.  Need a TRUE local instead.
    tmp = TRUE;

    Assert(sizeof(SYNTAX_BOOLEAN) == sizeof(tmp));

    dwErr = DBAddAttVal(pTHS->pDB,
                        ATT_SHOW_IN_ADVANCED_VIEW_ONLY,
                        sizeof(tmp),
                        &tmp);

    Assert(DB_ERR_VALUE_EXISTS != dwErr);

    switch ( dwErr )
    {
    case 0:

        // Success!
        break;

    default:

        // All other problems are assumed to be temporary. (record locks, etc.)
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

    return(0);
}

DWORD ProcessActiveContainerAdd(THSTATE *pTHS,
                                CLASSCACHE *pCC,
                ADDARG *pAddArg,
                DWORD ActiveContainerID)
{
    DWORD err;
    DWORD ulSysFlags = 0;
    ATTCACHE * pAC;

    Assert(ActiveContainerID);

    switch (ActiveContainerID) {
      case ACTIVE_CONTAINER_SCHEMA:
          switch (pCC->ClassId) {
            case CLASS_ATTRIBUTE_SCHEMA:
                SetAttrSchemaAttr(pTHS, pAddArg);
                break;

            case CLASS_CLASS_SCHEMA:
                SetClassSchemaAttr(pTHS, pAddArg);
                break;

            default:
                ; /* nothing to do */
          }
          break;

      case ACTIVE_CONTAINER_SITES:
      case ACTIVE_CONTAINER_SUBNETS:
          /* For these containers, make new children renameable */
          pAC = SCGetAttById(pTHS, ATT_SYSTEM_FLAGS);
          if (NULL == pAC) {
              SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR);
              break;
          }
          if (DBGetSingleValue(pTHS->pDB,
              ATT_SYSTEM_FLAGS,
              &ulSysFlags,
              sizeof(ulSysFlags),
              NULL)) {
              /* No value there */
              ulSysFlags = FLAG_CONFIG_ALLOW_RENAME;
              if (err = DBAddAttVal_AC(pTHS->pDB,
                  pAC,
                  sizeof(ulSysFlags),
                  &ulSysFlags)) {
                  SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,err);
              }
          }
          else if (!(ulSysFlags & FLAG_CONFIG_ALLOW_RENAME)){
              /* there is an existing value, so or our bits in */
              DBRemAttVal_AC(pTHS->pDB,
                  pAC,
                  sizeof(ulSysFlags),
                  &ulSysFlags);
              ulSysFlags |= FLAG_CONFIG_ALLOW_RENAME;
              if (err = DBAddAttVal_AC(pTHS->pDB,
                  pAC,
                  sizeof(ulSysFlags),
                  &ulSysFlags)) {
                  SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
              }
          }
          break;
      
      default:
          ;
    }

    return pTHS->errCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mappings.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       mappings.c
//
//--------------------------------------------------------------------------
/*++

Abstract:

    This file contains the Mappings from SAM Objects to DS Objects. It also
    contains routines to support SAM loopback, and DS notifications for SAM
    and  LSA notifications.


Author:

    Murlis 16-May-1996

Environment:

    User Mode - Win32

Revision History:

    MurliS      16-May-1996
        Created

    ChrisMay    14-Jun-96
        Added missing attributes and miscellaneous clean up, changed
        NextRid from LARGE_INTEGER to INTEGER to match the schema, re-
        moved superfluous attributes.

    ChrisMay    26-Jun-96
        Added work around so that SAMP_USER_FULL_NAME doesn't to the admin
        display name. Remapped SAMP_USER_GROUPS from zero to ATT_EXTENSION_ATTRIBUTE_2.

    DaveStr     11-Jul-96
        Added more attribute and class mapping information for SAM loopback.

    ColinBr     18-Jul-96
        Added 3 new mappings for membership relation SAM attributes. If
        a SAM object doesn't use these attributes(SAMP_USER_GROUPS,
        SAMP_ALIAS_MEMBERS, and SAMP_GROUP_MEMBERS), then they are mapped
        to a benign field (ATT_USER_GROUPS).

    Murlis      12-Jul-97
        Fixed loopback for single access check. Updated Comments.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <mappings.h>
#include <objids.h>
#include <direrr.h>
#include <mdlocal.h>
#include <mdcodes.h>
#include <dsatools.h>
#include <dsevent.h>
#include <dsexcept.h>
#include <debug.h>
#include <samwrite.h>
#include <anchor.h>
#include <sdprop.h>
#include <drautil.h>

#include <fileno.h>
#define  FILENO FILENO_MAPPINGS

#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <samisrv.h>
#include <samsrvp.h>
#include <nlrepl.h>
#include <windns.h>             /* DnsNameCompare_W */
#include "dstaskq.h"            /* task queue stuff */
#include <drameta.h>


#define NO_SAM_CHECKS 0

#define DEBSUB "MAPPINGS:"


//------------------------------------------------------------------------------
//
//                         GLOBALS defined and referenced in this file.
// Global flag to disable additional SAM loopback.
BOOL gfDoSamChecks = FALSE;
//
// Global LSA dll handle used for notification
//
HANDLE LsaDllHandle = NULL;
pfLsaIDsNotifiedObjectChange pfLsaNotify = NULL;

//-------------------------------------------------------------------------------


//--------------------------------------------------------------------------------
//++
//++  IMPORTANT NOTE REGARDING ATTRIBUTE MAPPINGS:
//++
//++   The Following SAM identifiers must map to the same attribute
//++   identifier in the DS. This is to facilitate Name and Rid based
//++   lookups, which often do not know the ObjectType in advance.
//++   These are
//++
//++    SAMP_UNKNOWN_OBJECTCLASS   -- Must map to the ATT_OBJECT_CLASS attribute
//++
//++
//++    SAMP_UNKNOWN_OBJECTRID  |
//++    SAMP_FIXED_GROUP_RID    |
//++    SAMP_FIXED_ALIAS_RID    |  -- Must Map to ATT_RID(or equiv)
//++    SAMP_FIXED_USERID       |     attribute. Note the we store the
//++                            |     Sid and not store the Rid in
//++                            |     the DS. To simplify switching
//++                            |     between the two implementations,
//++                            |     ATT_RID is always defined as an
//++                            |     attribute in the DS. Though it may
//++                            |     or may not be in an allowed attri-
//++                            |     bute in the schema. SAM always translates
//++                            |     ATT_RID to ATT_OBJECT_SID before making
//++                            |     the Directory Call
//++
//++    SAMP_UNKNOWN_OBJECTNAME |
//++    SAMP_ALIAS_NAME         |  -- Must Map to Unicode String Name Attribute
//++    SAMP_GROUP_NAME         |     (ATT_ADMIN_DISPLAY_NAME for now )
//++    SAMP_USER_ACCOUNT_NAME  |
//++
//++
//++
//++
//++    SAMP_UNKNOWN_OBJECTSID  |  -- Maps to SID Attribute
//++    SAMP_DOMAIN_SID         |     ATT_OBJECT_SID
//++                            |
//++
//--------------------------------------------------------------------------------



//-------------------------------------------------------------------------------
//++ On a per SAM object basis define SAM attribute to DS attribute mappings.
//++ The SAM constants are defined in mappings.h. Each mapping table entry consists
//++ of
//++    1. the SAM and corresponding DS attribute
//++    2. an identifier for the syntax of the attribute
//++    3. a constant describing whether loopback should allow non-SAM
//++       modification, SAM based modification or no modification.
//++    4. The types of operations that are allowed for the attribute.       
//++    5. A SAM access mask that identifies any SAM checks that need to be done
//++       on the domain object.
//++    6. A SAM access mask that identifies any SAM checks that need to be done
//++       on the account object.
//++    7. A boolean indicating whether an audit is generated upon modification.
//++    8. A SAM auditing mask indicating what types of audits are associated
//++       with the attribute. 
//++
//++    Fields #5 and #6 are used to perform SAM access checks over and above what
//++    the DS checks. The comments at the start of loopback.c give an overview of the
//++    loopback access check mechanism.
//++
//++ attribute to DS attribute mapping are done by the following mapping
//++ tables in the Ds interace wrapper.
//--------------------------------------------------------------------------------
// Define the mapping of server attributes.
SAMP_ATTRIBUTE_MAPPING ServerAttributeMappingTable[] =
{
    // Variable-Length Attributes

    // Security Descriptor on Server Object. Checks who can connect to this SAM
    // server

    { SAMP_SERVER_SECURITY_DESCRIPTOR,
      ATT_NT_SECURITY_DESCRIPTOR,
      OctetString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // Fixed-Length Attributes  [ Refer to _SAMP_V1_0A_FIXED_LENGTH_SERVER ]

    // Revision Level of SAM database
    { SAMP_FIXED_SERVER_REVISION_LEVEL,
      ATT_REVISION,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

      // Revision Level of SAM database
    { SAMP_FIXED_SERVER_USER_PASSWORD,
      ATT_USER_PASSWORD,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS }
};

ULONG cServerAttributeMappingTable =
    sizeof(ServerAttributeMappingTable) /
        sizeof(SAMP_ATTRIBUTE_MAPPING);

// Define the mapping of domain attributes.

SAMP_ATTRIBUTE_MAPPING DomainAttributeMappingTable[] =
{
    // Variable-Length Attributes

    // Security Descriptor on Domain Object
    { SAMP_DOMAIN_SECURITY_DESCRIPTOR,
      ATT_NT_SECURITY_DESCRIPTOR,
      OctetString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // Domain Sid identifying the domain, long
    { SAMP_DOMAIN_SID,
      ATT_OBJECT_SID,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // OEM information, UNICODE string attribute not really used,
    // by SAM, but other SAM clients may use it. Present for backwards
    // compatibility
    { SAMP_DOMAIN_OEM_INFORMATION,
      ATT_OEM_INFORMATION,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Unicode String Attribute, gives the list of NT4 Replication Domain
    // Controllers.
    { SAMP_DOMAIN_REPLICA,
      ATT_DOMAIN_REPLICA,
      UnicodeString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

      // Fixed-Length Attributes  [ Refer to _SAMP_V1_0A_FIXED_LENGTH_DOMAIN ]


    // Domain Creation Time maintained by SAM. Changing this will cause
    // Net Logon to Full Sync
    { SAMP_FIXED_DOMAIN_CREATION_TIME,
      ATT_CREATION_TIME,
      LargeInteger,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Net Logon Change Log Serial Number
    { SAMP_FIXED_DOMAIN_MODIFIED_COUNT,
      ATT_MODIFIED_COUNT,
      LargeInteger,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Domain Policy Attribute, Used to enforce the maximum Password
    // Age.
    { SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE,
      ATT_MAX_PWD_AGE,
      LargeInteger,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Domain Policy Attribute, Used to enforce time interval betweeen
    // password changes
    { SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE,
      ATT_MIN_PWD_AGE,
      LargeInteger,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Used in Computing the Kickoff time in SamIGetAccountRestrictions
    //
    { SAMP_FIXED_DOMAIN_FORCE_LOGOFF,
      ATT_FORCE_LOGOFF,
      LargeInteger,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Used By Account Lockout System. Time for which the account is
    // locked out
    { SAMP_FIXED_DOMAIN_LOCKOUT_DURATION,
      ATT_LOCKOUT_DURATION,
      LargeInteger,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // The "Observation window time", after a bad password attempt during which
    // the server increments bad password attempts, so that it may lockout the
    // account if the lockout threshold is reached
    { SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW,
      ATT_LOCK_OUT_OBSERVATION_WINDOW,
      LargeInteger,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // The Net Logon Change Log serial number at last promotion
    { SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION,
      ATT_MODIFIED_COUNT_AT_LAST_PROM,
      LargeInteger,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // The Next Rid Field used by the mixed mode allocator
    { SAMP_FIXED_DOMAIN_NEXT_RID,
      ATT_NEXT_RID,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Password Properties. Part of Domain Policy. A bit field to
    // indicate complexity / storage restrictions
    { SAMP_FIXED_DOMAIN_PWD_PROPERTIES,
      ATT_PWD_PROPERTIES,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Min Password Length. Part of Domain Policy
    { SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH,
      ATT_MIN_PWD_LENGTH,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Password History length -- Part of Domain Policy
    { SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH,
      ATT_PWD_HISTORY_LENGTH,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Used by Account Lockout. The Number of bad password attempts in
    // the Lockout observation window, that will cause the account to
    // be locked out. Part of Domain policy
    { SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD,
      ATT_LOCKOUT_THRESHOLD,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Enum indicating server enabled or disabled
    { SAMP_FIXED_DOMAIN_SERVER_STATE,
      ATT_SERVER_STATE,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },


    // Specifies Compatibility mode with LanMan 2.0 Servers
    { SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED,
      ATT_UAS_COMPAT,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },


    //
    // The Sam Account Type denotes the type of Sam Object
    //

    { SAMP_DOMAIN_ACCOUNT_TYPE,
      ATT_SAM_ACCOUNT_TYPE,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_DOMAIN_MIXED_MODE,
      ATT_NT_MIXED_DOMAIN,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES }, 

    { SAMP_DOMAIN_MACHINE_ACCOUNT_QUOTA,
      ATT_MS_DS_MACHINE_ACCOUNT_QUOTA,
      Integer,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },
   
    { SAMP_DOMAIN_BEHAVIOR_VERSION,
      ATT_MS_DS_BEHAVIOR_VERSION,
      Integer,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    { SAMP_DOMAIN_LASTLOGON_TIMESTAMP_SYNC_INTERVAL,
      ATT_MS_DS_LOGON_TIME_SYNC_INTERVAL,
      Integer,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_FIXED_DOMAIN_USER_PASSWORD,
      ATT_USER_PASSWORD,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS }

};

ULONG cDomainAttributeMappingTable =
    sizeof(DomainAttributeMappingTable) /
        sizeof(SAMP_ATTRIBUTE_MAPPING);

// Define the mapping of group attributes.

SAMP_ATTRIBUTE_MAPPING GroupAttributeMappingTable[] =
{
    // Variable-Length Attributes

    // EXISTING ATTRIBUTE(TOP): security Descriptor
    { SAMP_GROUP_SECURITY_DESCRIPTOR,
      ATT_NT_SECURITY_DESCRIPTOR,
      OctetString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // EXISTING ATTRIBUTE (TOP)
    { SAMP_GROUP_NAME,
      ATT_SAM_ACCOUNT_NAME,
      UnicodeString,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // EXISTING ATTRIBUTE (TOP)
    { SAMP_GROUP_ADMIN_COMMENT,
      ATT_DESCRIPTION,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_GROUP_MEMBERS,
      ATT_MEMBER,
      Dsname,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT },

    // Membership lists are manipulated using Arrays of RIDS in
    // in SAM. So some mappings from DS names to RIDS must exisit
    // when asking for Membership lists. Personal favourite: Ds interface
    // layer automatically maps a Dsname syntax stuff to a RID.

    // Fixed-Length Attributes [ Refer to SAMP_V1_0A_FIXED_LENGTH_GROUP ]


    // Rid, can some higher object have this ( like a SAM account object
    { SAMP_FIXED_GROUP_RID,
      ATT_RID,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },  

    { SAMP_FIXED_GROUP_OBJECTCLASS,
      ATT_OBJECT_CLASS,
      Integer,
      // Technically speaking, one can not write the object class attribute.
      // But this is insured by the core DS code, so we mark it as writable
      // here so that Samp*LoopbackRequired() don't reject legitimate add
      // and modify attempts.
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES }, 

    { SAMP_GROUP_SID_HISTORY,
      ATT_SID_HISTORY,
      Integer,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    { SAMP_GROUP_ACCOUNT_TYPE,
      ATT_SAM_ACCOUNT_TYPE,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_GROUP_TYPE,
      ATT_GROUP_TYPE,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    { SAMP_FIXED_GROUP_IS_CRITICAL,
      ATT_IS_CRITICAL_SYSTEM_OBJECT,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_GROUP_MEMBER_OF,
      ATT_IS_MEMBER_OF_DL,
      Dsname,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_GROUP_SID,
      ATT_OBJECT_SID,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_GROUP_NON_MEMBERS,
      ATT_MS_DS_NON_MEMBERS,
      Dsname,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_FIXED_GROUP_USER_PASSWORD,
      ATT_USER_PASSWORD,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS }
};

ULONG cGroupAttributeMappingTable =
    sizeof(GroupAttributeMappingTable) /
        sizeof(SAMP_ATTRIBUTE_MAPPING);

// Define the mapping of alias attributes.

SAMP_ATTRIBUTE_MAPPING AliasAttributeMappingTable[] =
{
    // Variable-Length Attributes

    // ?
    { SAMP_ALIAS_SECURITY_DESCRIPTOR,
      ATT_NT_SECURITY_DESCRIPTOR,
      OctetString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // ?
    { SAMP_ALIAS_NAME,
      ATT_SAM_ACCOUNT_NAME,
      UnicodeString,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // ?
    { SAMP_ALIAS_ADMIN_COMMENT,
      ATT_DESCRIPTION,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // ?
    { SAMP_ALIAS_MEMBERS,
      ATT_MEMBER,
      Dsname,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT },

    // Fixed-Length Attributes  [ Refer to SAMP_V1_FIXED_LENGTH_ALIAS ]

    // RId of Alias
    { SAMP_FIXED_ALIAS_RID,
      ATT_RID,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_ALIAS_OBJECTCLASS,
      ATT_OBJECT_CLASS,
      Integer,
      // Technically speaking, one can not write the object class attribute.
      // But this is insured by the core DS code, so we mark it as writable
      // here so that Samp*LoopbackRequired() don't reject legitimate add
      // and modify attempts.
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_ALIAS_SID_HISTORY,
      ATT_SID_HISTORY,
      Integer,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    { SAMP_ALIAS_ACCOUNT_TYPE,
      ATT_SAM_ACCOUNT_TYPE,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_ALIAS_TYPE,
      ATT_GROUP_TYPE,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    { SAMP_FIXED_ALIAS_SID,
      ATT_OBJECT_SID,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_ALIAS_NON_MEMBERS,
      ATT_MS_DS_NON_MEMBERS,
      Dsname,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },
    
    { SAMP_ALIAS_LDAP_QUERY,
      ATT_MS_DS_AZ_LDAP_QUERY,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_FIXED_ALIAS_IS_CRITICAL,
      ATT_IS_CRITICAL_SYSTEM_OBJECT,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS },

    { SAMP_FIXED_ALIAS_USER_PASSWORD,
      ATT_USER_PASSWORD,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT }
  
};

ULONG cAliasAttributeMappingTable =
    sizeof(AliasAttributeMappingTable) /
        sizeof(SAMP_ATTRIBUTE_MAPPING);

// Define the mapping of user attributes.

SAMP_ATTRIBUTE_MAPPING UserAttributeMappingTable[] =
{
    // Variable-Length Attributes

    // EXISTING ATTRIBUTE
    { SAMP_USER_SECURITY_DESCRIPTOR,
      ATT_NT_SECURITY_DESCRIPTOR,
      OctetString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // EXISTING ATTRIBUTE (TOP) ( for now ) limit of 256 chars--needs a fix
    { SAMP_USER_ACCOUNT_NAME,
      ATT_SAM_ACCOUNT_NAME,
      UnicodeString,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // BUG: Mapping SAMP_USER_FULL_NAME to ATT_ADMIN_DISPLAY_NAME is broken.
    // The temporary work around is to re-map it to ATT_USER_FULL_NAME, which
    // in turn maps to one of the available extended attributes (131495), a
    // mail-recipient extended attribute. This way, the user account name and
    // the full name attributes will not overwrite each other.

    { SAMP_USER_FULL_NAME,
      ATT_DISPLAY_NAME,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // EXISITING ATTRIBUTE(TOP): Admin comment already defined in DS
    // schema in top object
    { SAMP_USER_ADMIN_COMMENT,
      ATT_DESCRIPTION,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },
      
    // NEW: User Coment
    { SAMP_USER_USER_COMMENT,
      ATT_USER_COMMENT,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // NEW: User Parameters. Don't have any clue
    { SAMP_USER_PARAMETERS,
      ATT_USER_PARAMETERS,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // NEW
    { SAMP_USER_HOME_DIRECTORY,
      ATT_HOME_DIRECTORY,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // NEW
    { SAMP_USER_HOME_DIRECTORY_DRIVE,
      ATT_HOME_DRIVE,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // NEW Script path
    { SAMP_USER_SCRIPT_PATH,
      ATT_SCRIPT_PATH,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // NEW Profile Path
    { SAMP_USER_PROFILE_PATH,
      ATT_PROFILE_PATH,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // NEW ?? Multivalued
    { SAMP_USER_WORKSTATIONS,
      ATT_USER_WORKSTATIONS,
      UnicodeString,
      SamWriteRequired,
      SamAllowReplaceAndRemove,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // NEW Attribute routines will need to map this to binary blob etc
    { SAMP_USER_LOGON_HOURS,
      ATT_LOGON_HOURS,
      OctetString,
      SamWriteRequired,
      SamAllowReplaceAndRemove,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // This lists which groups the user is a member of. Needs further work.
    { SAMP_USER_GROUPS,
      ATT_IS_MEMBER_OF_DL,
      Dsname,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // NEW contains the DBCS password of the user
    { SAMP_USER_DBCS_PWD,
      ATT_DBCS_PWD,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      USER_CHANGE_PASSWORD,
      SAMP_AUDIT_TYPE_OBJ_ACCESS  |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT },

    // NEW contains Unicode password. All passwords are binary as
    // they should be encrypted ( or hashed )

    { SAMP_USER_UNICODE_PWD,
      ATT_UNICODE_PWD,
      OctetString,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT },

    // NEW, Multivalued giving last x passwords stored, in order to enforce
    // new passwords
    { SAMP_USER_NT_PWD_HISTORY,
      ATT_NT_PWD_HISTORY,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // NEW Same as above for LAN Man passwords -- Why concept of NT
    // and LAN man passwords
    { SAMP_USER_LM_PWD_HISTORY,
      ATT_LM_PWD_HISTORY,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },


    // Fixed-Length Attributes [ Refer to SAMP_V1_0A_FIXED_LENGTH_USER ]



    // Last logon time
    { SAMP_FIXED_USER_LAST_LOGON,
      ATT_LAST_LOGON,
      LargeInteger,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Last Logoff time
    { SAMP_FIXED_USER_LAST_LOGOFF,
      ATT_LAST_LOGOFF,
      LargeInteger,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // password last set time
    { SAMP_FIXED_USER_PWD_LAST_SET,
      ATT_PWD_LAST_SET,
      LargeInteger,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,  
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Account expiry time
    { SAMP_FIXED_USER_ACCOUNT_EXPIRES,
      ATT_ACCOUNT_EXPIRES,
      LargeInteger,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Last bad password time
    { SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME,
      ATT_BAD_PASSWORD_TIME,
      LargeInteger,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Don't know what this is. This is field in the fixed blob for the
    // user. Maybe Rid but need to explore.
    { SAMP_FIXED_USER_USERID,
      ATT_RID,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Rid of group ???
    { SAMP_FIXED_USER_PRIMARY_GROUP_ID,
      ATT_PRIMARY_GROUP_ID,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // ?????
    { SAMP_FIXED_USER_ACCOUNT_CONTROL,
      ATT_USER_ACCOUNT_CONTROL,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // Country code of user
    { SAMP_FIXED_USER_COUNTRY_CODE,
      ATT_COUNTRY_CODE,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // Code page of user
    { SAMP_FIXED_USER_CODEPAGE,
      ATT_CODE_PAGE,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    // bad password count, reset upon successful logon ?
    { SAMP_FIXED_USER_BAD_PWD_COUNT,
      ATT_BAD_PWD_COUNT,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // ?
    { SAMP_FIXED_USER_LOGON_COUNT,
      ATT_LOGON_COUNT,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_OBJECTCLASS,
      ATT_OBJECT_CLASS,
      Integer,
      // Technically speaking, one can not write the object class attribute.
      // But this is insured by the core DS code, so we mark it as writable
      // here so that Samp*LoopbackRequired() don't reject legitimate add
      // and modify attempts.
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_USER_ACCOUNT_TYPE,
      ATT_SAM_ACCOUNT_TYPE,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_LOCAL_POLICY_FLAGS,
      ATT_LOCAL_POLICY_FLAGS,
      Integer,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
      ATT_SUPPLEMENTAL_CREDENTIALS,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_USER_SID_HISTORY,
      ATT_SID_HISTORY,
      Integer,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,       
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    { SAMP_FIXED_USER_LOCKOUT_TIME,
      ATT_LOCKOUT_TIME,
      Integer,
      SamWriteRequired,
      SamAllowReplaceOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,               
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_IS_CRITICAL,
      ATT_IS_CRITICAL_SYSTEM_OBJECT,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_UPN,
      ATT_USER_PRINCIPAL_NAME,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,         
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES }, 

    { SAMP_USER_CREATOR_SID,
      ATT_MS_DS_CREATOR_SID,
      Integer,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },

    { SAMP_FIXED_USER_SID,
      ATT_OBJECT_SID,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_SITE_AFFINITY,
      ATT_MS_DS_SITE_AFFINITY,
      OctetString,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,
      ATT_LAST_LOGON_TIMESTAMP,
      LargeInteger,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_CACHED_MEMBERSHIP,
      ATT_MS_DS_CACHED_MEMBERSHIP,
      OctetString,
      SamWriteRequired,
      SamAllowDeleteOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_CACHED_MEMBERSHIP_TIME_STAMP,
      ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP,
      LargeInteger,
      SamWriteRequired,
      SamAllowDeleteOnly,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_FIXED_USER_ACCOUNT_CONTROL_COMPUTED,
      ATT_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED,
      Integer,
      SamReadOnly,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_USER_PASSWORD,
      ATT_USER_PASSWORD,
      UnicodeString,
      SamWriteRequired,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT },

    {
      SAMP_USER_A2D2LIST,
      ATT_MS_DS_ALLOWED_TO_DELEGATE_TO,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    {
      SAMP_USER_SPN,
      ATT_SERVICE_PRINCIPAL_NAME,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    {
      SAMP_USER_KVNO,
      ATT_MS_DS_KEYVERSIONNUMBER,
      Integer,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES },
    
    {
      SAMP_USER_DNS_HOST_NAME,
      ATT_DNS_HOST_NAME,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      NO_SAM_CHECKS,
      NO_SAM_CHECKS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

};

ULONG cUserAttributeMappingTable =
    sizeof(UserAttributeMappingTable) /
        sizeof(SAMP_ATTRIBUTE_MAPPING);

//
//  The Unknown Attribute Mapping table is used when the SAM object
//  class is before hand not known, but must locate an object with
//  a given name or rid and find out its class. See important note a
//  above.
//

SAMP_ATTRIBUTE_MAPPING UnknownAttributeMappingTable[] =
{
    // Object Class
    { SAMP_UNKNOWN_OBJECTCLASS,
      ATT_OBJECT_CLASS,
      Integer,
      // Technically speaking, one can not write the object class attribute.
      // But this is insured by the core DS code, so we mark it as writable
      // here so that Samp*LoopbackRequired() don't reject legitimate add
      // and modify attempts.
      NonSamWriteAllowed,
      SamAllowAll,
      DOMAIN_ALL_ACCESS,
      DOMAIN_ALL_ACCESS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Rid of Object
    { SAMP_UNKNOWN_OBJECTRID,
      ATT_RID,
      Integer,
      SamReadOnly,
      SamAllowAll,
      DOMAIN_ALL_ACCESS,
      DOMAIN_ALL_ACCESS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    // Name of Object
    { SAMP_UNKNOWN_OBJECTNAME,
      ATT_SAM_ACCOUNT_NAME,
      UnicodeString,
      SamReadOnly,
      SamAllowAll,
      DOMAIN_ALL_ACCESS,
      DOMAIN_ALL_ACCESS,        
      SAMP_AUDIT_TYPE_OBJ_ACCESS | 
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT |
      SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES },

    // SID of Object
    { SAMP_UNKNOWN_OBJECTSID,
      ATT_OBJECT_SID,
      OctetString,
      SamReadOnly,
      SamAllowAll,
      DOMAIN_ALL_ACCESS,
      DOMAIN_ALL_ACCESS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_UNKNOWN_COMMON_NAME,
      ATT_COMMON_NAME,
      UnicodeString,
      NonSamWriteAllowed,
      SamAllowAll,
      DOMAIN_ALL_ACCESS,
      DOMAIN_ALL_ACCESS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_UNKNOWN_ACCOUNT_TYPE,
      ATT_SAM_ACCOUNT_TYPE,
      Integer,
      SamReadOnly,
      SamAllowAll,
      DOMAIN_ALL_ACCESS,
      DOMAIN_ALL_ACCESS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS },

    { SAMP_UNKNOWN_GROUP_TYPE,
      ATT_GROUP_TYPE,
      Integer,
      SamWriteRequired,
      SamAllowAll,
      DOMAIN_ALL_ACCESS,
      DOMAIN_ALL_ACCESS,
      SAMP_AUDIT_TYPE_OBJ_ACCESS |
      SAMP_AUDIT_TYPE_DEDICATED_AUDIT }
};

// ++
// ++  Define Sam Object-to-DS class mappings
// ++

//
// Do not change order in this table without
// updating SampSamClassReferenced and logic
// in loopback.c -- special case
// for builtin domain hard codes it. Opening
// objects through loopback hardcodes the fact
// that local groups are the next entry after
// groups
//

#define CLASS_MAIL_RECIPIENT  196654

SAMP_CLASS_MAPPING ClassMappingTable[] =
{
    { CLASS_SAM_SERVER,
      SampServerObjectType,
      NON_SAM_CREATE_ALLOWED,
      &cServerAttributeMappingTable,
      ServerAttributeMappingTable,
      DOMAIN_ALL_ACCESS,                // domainAddRightsRequired
      DOMAIN_ALL_ACCESS,                // domainRemoveRightsRequired
      NO_SAM_CHECKS,                    // objectAddRightsRequired
      NO_SAM_CHECKS },                  // objectRemoveRightsRequired

    { CLASS_SAM_DOMAIN,
      SampDomainObjectType,
      NON_SAM_CREATE_ALLOWED,
      &cDomainAttributeMappingTable,
      DomainAttributeMappingTable,
      NO_SAM_CHECKS,                // domainAddRightsRequired
      NO_SAM_CHECKS,                // domainRemoveRightsRequired
      NO_SAM_CHECKS,                // objectAddRightsRequired
      NO_SAM_CHECKS },              // objectRemoveRightsRequired

    { CLASS_GROUP,
      SampGroupObjectType,
      SAM_CREATE_ONLY,
      &cGroupAttributeMappingTable,
      GroupAttributeMappingTable,
      NO_SAM_CHECKS,                    // domainAddRightsRequired
      NO_SAM_CHECKS,                    // domainRemoveRightsRequired
      NO_SAM_CHECKS,                    // objectAddRightsRequired
      NO_SAM_CHECKS },                  // objectRemoveRightsRequired

    { CLASS_GROUP,
      SampAliasObjectType,
      SAM_CREATE_ONLY,
      &cAliasAttributeMappingTable,
      AliasAttributeMappingTable,
      NO_SAM_CHECKS,                      // domainAddRightsRequired
      NO_SAM_CHECKS,                      // domainRemoveRightsRequired
      NO_SAM_CHECKS,                      // objectAddRightsRequired
      NO_SAM_CHECKS },                    // objectRemoveRightsRequired

    { CLASS_USER,
      SampUserObjectType,
      SAM_CREATE_ONLY,
      &cUserAttributeMappingTable,
      UserAttributeMappingTable,
      NO_SAM_CHECKS,                      // domainAddRightsRequired
      NO_SAM_CHECKS,                      // domainRemoveRightsRequired
      NO_SAM_CHECKS,                      // objectAddRightsRequired
      NO_SAM_CHECKS }                     // objectRemoveRightsRequired
};

ULONG cClassMappingTable =
    sizeof(ClassMappingTable) /
        sizeof(ClassMappingTable[0]);



ULONG
SampGetDsAttrIdByName(
    UNICODE_STRING AttributeIdentifier
    )

/*++

Routine Description:

Arguments:

Return Values:

--*/

{

    UCHAR   *name = NULL;
    ULONG   nameLen;
    ULONG   DsAttrId = (ULONG) DS_ATTRIBUTE_UNKNOWN;
    THSTATE *pTHS = pTHStls;
    ATTCACHE *pAC = NULL;


    if (0 == AttributeIdentifier.Length || NULL == AttributeIdentifier.Buffer)
    {
        goto Error;
    }

    name = MIDL_user_allocate( AttributeIdentifier.Length + sizeof(UCHAR) );

    if (name == NULL)
    {
        goto Error;
    }

    RtlZeroMemory(name, AttributeIdentifier.Length + sizeof(UCHAR));

    nameLen = WideCharToMultiByte(
                             CP_UTF8,
                             0,
                             (LPCWSTR) AttributeIdentifier.Buffer,
                             AttributeIdentifier.Length / sizeof(WCHAR),
                             name,
                             AttributeIdentifier.Length,
                             NULL,
                             NULL
                             );

    if (nameLen == 0)
    {
        goto Error;
    }

    pAC = SCGetAttByName(pTHS, nameLen, name);

    if (pAC == NULL)
    {
        goto Error;
    }

    DsAttrId = pAC->id;

Error:

    if (name != NULL)
    {
        MIDL_user_free(name);
    }

    return DsAttrId;
}


ULONG
SampGetSamAttrIdByName(
    SAMP_OBJECT_TYPE ObjectType,
    UNICODE_STRING AttributeIdentifier
    )

/*++

Routine Description:

Arguments:

Return Values:

--*/

{

    UCHAR   *name = NULL;
    ULONG   nameLen;
    ULONG   DsAttrId = (ULONG) DS_ATTRIBUTE_UNKNOWN;
    ULONG   SamAttrId = (ULONG) SAM_ATTRIBUTE_UNKNOWN;
    THSTATE *pTHS = pTHStls;
    ATTCACHE *pAC = NULL;


    if (0 == AttributeIdentifier.Length ||
        NULL == AttributeIdentifier.Buffer)
    {
        goto Error;
    }
    name = MIDL_user_allocate( AttributeIdentifier.Length + sizeof(UCHAR) );

    if (name == NULL)
    {
        goto Error;
    }

    RtlZeroMemory(name, AttributeIdentifier.Length + sizeof(UCHAR));

    nameLen = WideCharToMultiByte(
                             CP_UTF8,
                             0,
                             (LPCWSTR) AttributeIdentifier.Buffer,
                             AttributeIdentifier.Length / sizeof(WCHAR),
                             name,
                             AttributeIdentifier.Length,
                             NULL,
                             NULL
                             );

    if (nameLen == 0)
    {
        goto Error;
    }

    pAC = SCGetAttByName(pTHS, nameLen, name);

    if (pAC == NULL)
    {
        goto Error;
    }

    DsAttrId = pAC->id;

    if (DS_ATTRIBUTE_UNKNOWN == DsAttrId)
    {
        goto Error;
    }

    SamAttrId = SampSamAttrFromDsAttr(ObjectType, DsAttrId);

Error:

    if (name != NULL)
    {
        MIDL_user_free(name);
    }

    return SamAttrId;
}


//++
//++  Mapping functions
//++
ULONG
SampDsAttrFromSamAttr(SAMP_OBJECT_TYPE ObjectType, ULONG SamAttributeType)
/*++

Routine Description:

    Get a DS attribute from a SAM attribute

Arguments:

    ObjectType -- specifies the SAM object type
    SamAttributeType Specifies the SAM atribute

Return Values:

    Ds Attribute if one exisits
    DS_ATTRUBUTE_UNKNOWN other wise. Will assert if cannot map

--*/

{
    ULONG Index;
    ULONG DsAttributeId = (ULONG) DS_ATTRIBUTE_UNKNOWN;
    SAMP_ATTRIBUTE_MAPPING * MappingTable;
    ULONG MappingTableSize;

    // Determine the Mapping table to use
    switch(ObjectType)
    {
    case SampServerObjectType:
        MappingTable = ServerAttributeMappingTable;
        MappingTableSize = sizeof(ServerAttributeMappingTable)/sizeof(ServerAttributeMappingTable[0]);
        break;
    case SampDomainObjectType:
        MappingTable = DomainAttributeMappingTable;
        MappingTableSize = sizeof(DomainAttributeMappingTable)/sizeof(DomainAttributeMappingTable[0]);
        break;
    case SampGroupObjectType:
        MappingTable = GroupAttributeMappingTable;
        MappingTableSize = sizeof(GroupAttributeMappingTable)/sizeof(GroupAttributeMappingTable[0]);
        break;
    case SampAliasObjectType:
        MappingTable = AliasAttributeMappingTable;
        MappingTableSize = sizeof(AliasAttributeMappingTable)/sizeof(AliasAttributeMappingTable[0]);
        break;
    case SampUserObjectType:
        MappingTable = UserAttributeMappingTable;
        MappingTableSize = sizeof(UserAttributeMappingTable)/sizeof(UserAttributeMappingTable[0]);
        break;
    case SampUnknownObjectType:
        MappingTable = UnknownAttributeMappingTable;
        MappingTableSize = sizeof(UnknownAttributeMappingTable)/sizeof(UnknownAttributeMappingTable[0]);
        break;
    default:
        goto Error;
    }

    // Walk through the Mapping table
    for (Index=0; Index<MappingTableSize; Index++ )
    {
        if (MappingTable[Index].SamAttributeType == SamAttributeType)
        {
            DsAttributeId = MappingTable[Index].DsAttributeId;
            goto Found;
        }
    }

    // Assert as we did not find match
    Assert(FALSE);

Found:
    return DsAttributeId;

Error:
    // Assert as we did not find table match
    Assert(FALSE);
    goto Found;
}


ULONG
SampSamAttrFromDsAttr(SAMP_OBJECT_TYPE ObjectType, ULONG DsAttributeId)
/*++
Routine Description:

    Get a SAM attribute from a DS attribute

Arguments:

    ObjectType -- specifies the SAM object type
    DSAttributeId Specifies the DS atribute

Return Values:

    SAM Attribute if one exisits
    SAM_ATTRUBUTE_UNKNOWN other wise. Will assert if cannot map
--*/

{
    ULONG Index;
    ULONG SamAttributeType = (ULONG) SAM_ATTRIBUTE_UNKNOWN;
    SAMP_ATTRIBUTE_MAPPING * MappingTable;
    ULONG MappingTableSize;

    // Determine the Mapping table to use
    switch(ObjectType)
    {
    case SampServerObjectType:
        MappingTable = ServerAttributeMappingTable;
        MappingTableSize = sizeof(ServerAttributeMappingTable)/sizeof(ServerAttributeMappingTable[0]);
        break;
    case SampDomainObjectType:
        MappingTable = DomainAttributeMappingTable;
        MappingTableSize = sizeof(DomainAttributeMappingTable)/sizeof(DomainAttributeMappingTable[0]);
        break;
    case SampGroupObjectType:
        MappingTable = GroupAttributeMappingTable;
        MappingTableSize = sizeof(GroupAttributeMappingTable)/sizeof(GroupAttributeMappingTable[0]);
        break;
    case SampAliasObjectType:
        MappingTable = AliasAttributeMappingTable;
        MappingTableSize = sizeof(AliasAttributeMappingTable)/sizeof(AliasAttributeMappingTable[0]);
        break;
    case SampUserObjectType:
        MappingTable = UserAttributeMappingTable;
        MappingTableSize = sizeof(UserAttributeMappingTable)/sizeof(UserAttributeMappingTable[0]);
        break;
    case SampUnknownObjectType:
        MappingTable = UnknownAttributeMappingTable;
        MappingTableSize = sizeof(UnknownAttributeMappingTable)/sizeof(UnknownAttributeMappingTable[0]);
        break;
    default:
        goto Error;
    }

    // Walk through the Mapping table
    for (Index=0; Index<MappingTableSize; Index++ )
    {
        if (MappingTable[Index].DsAttributeId == DsAttributeId)
        {
            SamAttributeType = MappingTable[Index].SamAttributeType;
            goto Found;
        }
    }

    // Assert as we did not find match
    Assert(FALSE);

Found:
    return SamAttributeType;

Error:
    // Assert as we did not find table match
    Assert(FALSE);
    goto Found;
}

ULONG
SampDsClassFromSamObjectType(ULONG SamObjectType)
/*++

Routine Description:

    Get a DS class from a SAM object type

Arguments:
    ObjectType -- specifies the SAM object type

Return Values:

    Ds class if one exisits
    DS_CLASS_UNKNOWN other wise. Will assert if cannot map

 --*/

{
    ULONG Index;
    ULONG DsClass = (ULONG) DS_CLASS_UNKNOWN;

    for (Index=0; Index<sizeof(ClassMappingTable)/sizeof(ClassMappingTable[0]); Index++ )
    {
        if ((ULONG) ClassMappingTable[Index].SamObjectType == SamObjectType)
        {
            DsClass = ClassMappingTable[Index].DsClassId;
            goto Found;
        }
    }

    // Assert as we did not find match
    Assert(FALSE);

Found:
    return DsClass;
}




ULONG
SampSamObjectTypeFromDsClass(ULONG  DsClass)
/*++

Routine Description:

    Get a SAM object type  from a DS class

Arguments:

    DsClass  -- Specifies the DS class

Return Values:
    SAM object type if one exisits
    SampUnknownObjectType other wise. Will assert if cannot map

  BUG:

  This routines makes the assumption that there is a 1:1 mapping between SAM objects and
  DS classes. This is not true for Group / Alias Objects. So something needs to be done
  about this later.

--*/

{
    int Index;
    ULONG SamObjectType = SampUnknownObjectType;

    for (Index=0; Index<sizeof(ClassMappingTable)/sizeof(ClassMappingTable[0]); Index++ )
    {
        if (ClassMappingTable[Index].DsClassId == DsClass)
        {
            SamObjectType = ClassMappingTable[Index].SamObjectType;
            goto Found;
        }
    }

    // Assert as we did not find match
    Assert(FALSE);

Found:
    return SamObjectType;
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// SAM Transactioning Routines                                             //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// The default DSA operation is that each Dir* call is individually
// transacted.  This is insufficient when SAM is calling the DS for
// two reasons.
//
// 1)   A single Samr* operation (eg: SamrSetInformationUser) may result
//      in multiple Dir* calls.  All these calls together should constitute
//      a single transaction.  This is achieved by giving SAM control over
//      the transaction.  Transactions are started as late as possible by
//      calling SampMaybeTransactionBegin in newsam2\server\dslayer.c just
//      before making the Dir* call.  The "maybe" aspect of the call is
//      that a new transaction is started only if one doesn't exist.  SAM
//      explicitly calls SampMaybeTransactionEnd(fAbort = FALSE) in its
//      normal commit path and SampMaybeTransactionEnd(fAbort = TRUE) when
//      it frees the global read/write lock.  This latter is a no-op if the
//      transaction has already been terminated.
//
// 2)   A single Dir* call which references both SAM and !SAM attributes
//      may result in multiple Samr* calls to handle the SAM attributes.
//      All these calls together should constitute a single transaction.
//      In this case we want the transactioning of the original Dir* call
//      to be the real thing and SAM to not perform any transactioning at
//      all.  This is achieved via logic in SampMaybeBeginTransaction and
//      the THSTATE.fSamDoCommit flag.  If a THSTATE already exists, then
//      SampMaybeBeginTransaction is a no-op - i.e. an existing transaction
//      is already open.  If THSTATE.fSamDoCommit is FALSE, then
//      SampMaybeEndTransaction is a no-op as well.  Thus multiple Samr*
//      calls can be made within the transaction context of an existing
//      Dir* call.

NTSTATUS
SampMaybeBeginDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL ReadOrWrite
    )

/*++

Routine Description:

    Conditionally initializes a thread state and begins a new transaction.
    This routine is called by SAM just before performing a DS operation.
    If the thread began life in the DS and is looping back through SAM,
    then this method is a no-op as a thread state and open transaction
    already exist. In case only a thread state exists and no open transaction
    exists SampMaybeBeginTransaction, will use that thread state and open a
    transaction on that thread state. In no circumstance will this routine
    return a success and not have an open transaction. Upon Failure the caller
    is assured that everything is cleaned up and the thread state is NULL and
    there is no open transaction.

Arguments:

    ReadOrWrite - flag indicating the type of transaction.

Return Values:

    STATUS_NO_MEMORY or STATUS_UNSUCCESSFUL if unsuccessful
    STATUS_SUCCESS otherwise

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    USHORT      transType;
    THSTATE     *pTHS = NULL;
    ULONG  dwException, ulErrorCode, dsid;
    PVOID dwEA;
    DWORD err = 0;

    Assert((TransactionRead == ReadOrWrite) ||
                    (TransactionWrite == ReadOrWrite));

    __try {

        //
        // Create a thread state; routine is no op if thread state
        // already exists.
        //
        err = THCreate(CALLERTYPE_SAM);
        if ( err )
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
        pTHS=pTHStls;
        Assert(NULL != pTHS);

        //
        // Begin Transaction if Required
        //

        if (NULL==pTHS->pDB)
        {
            // Thread State Exists, but Database pointer is NULL,
            // so no transaction exists. Proceed on opening
            // a new transaction
            //

            // Indicate to DS who the caller is.
            pTHS->fSAM = TRUE;
    

            //
            // Murlis 10/10/96. SAM must call into the DS
            // with fDSA flag set as DS must not perform
            // access checks for calls initiated by SAM
            //
            pTHS->fDSA = TRUE;

            // Indicate whether SAM should commit DS or not.

            pTHS->fSamDoCommit = TRUE;

            // Open database and start read or write transaction.

            transType = ((TransactionWrite == ReadOrWrite)
                         ? SYNC_WRITE
                         : SYNC_READ_ONLY);

            if ( 0 != SyncTransSet(transType) )
            {
                Status = STATUS_UNSUCCESSFUL;
            }
        } // End of NULL==pTHS->pDB
    } // End of Try
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid))
    {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            Status = STATUS_UNSUCCESSFUL;
    }

Error:

    //
    // If we did not succeed and if we created a thread state , then free it.
    //

    if (!NT_SUCCESS(Status))
    {
        if (NULL!=pTHS)
        {
            //
            // The only way we have a thread state, but not a open DB is
            // when SyncTransSet failed.
            //

            Assert(pTHS->pDB==NULL);
            THDestroy();
        }
    }

    return(Status);
}

NTSTATUS
SampMaybeEndDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL CommitOrAbort
    )

/*++

Routine Description

    Conditionally commits the DS transaction and cleans up the thread state.
    This routine is called by SAM and performs the commit and cleanup iff
    this thread state corresponds to a single Samr* call which originated
    in SAM.  If the call originated in the DS, then the routine is a no-op
    thereby allowing multiple Samr* calls to be treated as a single transaction.

Arguments:

    CommitOrAbort - flag indicating whether to commit or abort the transaction.
                    Valid values are
                         TransactionCommit --- Commits a transaction
                         TransactionAbort  --- Aborts a transaction
                         TransactionCommitAndKeepThreadState -- Commit transaction
                                        and keep the thread state, so that further
                                        processing can continue. SampMaybeBeginDsTransaction
                                        can be used to start another DS transaction on this
                                        thread state.

                        TransactionAbortAndKeepThreadState --
                        This aborts the current transaction and keeps the
                        thread state

Return Values:

    STATUS_SUCCESSFUL on success.
    STATUS_UNSUCCESSFUL on error.

--*/
{
    THSTATE  *pTHS=pTHStls;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     fAbort;
    ULONG    dwException, ulErrorCode, dsid;
    PVOID    dwEA;
    int      iErr;
    BOOL     fFreeThreadState = FALSE;

    Assert((TransactionCommit == CommitOrAbort) ||
            (TransactionCommitAndKeepThreadState == CommitOrAbort) ||
             (TransactionAbortAndKeepThreadState == CommitOrAbort) ||
                    (TransactionAbort == CommitOrAbort));

    // The only case in which we don't have a thread state is when an earlier
    // commit removed it and we're being called from the cleanup path in SAM.
    // In this case, SAM may not ask for a commit.

    __try {
        fAbort = ((TransactionAbort == CommitOrAbort)||
                    (TransactionAbortAndKeepThreadState == CommitOrAbort));

        if ( (NULL != pTHS)&&(pTHS->fSamDoCommit)&&(NULL!=pTHS->pDB)) {


            //
            // This is a case where a thread state exists, an open data
            // base exists ( which this routine interprets as an open
            // transaction ) and fSamDoCommit is set. This means that the
            // the transaction is to be committed or aborted and the thread
            // state freed.
            //

            fFreeThreadState = TRUE;

            // In the original DS usage, one passed an existing error
            // code as the second argument to CleanReturn and it would
            // be returned as CleanReturn's status.  I.e. CleanReturn
            // merely re-affirmed that your return from a Dir* call was
            // not clean.  It throws an exception if the actual commit
            // fails.  We have no error code from SAM - all we have is
            // the abort/commit flag.  So pass in a 0 and assert that
            // CleanReturn returns 0 in case it ever changes behaviour.

            // Nuke the GC verification Cache
            pTHS->GCVerifyCache = NULL;

            iErr = CleanReturn(pTHS, 0, fAbort);
            Assert(0 == iErr);
            
        } else if ((NULL!=pTHS)&&(NULL==pTHS->pDB)&&(pTHS->fSamDoCommit)) {
            
            //
            // This is the case where only a thread state exists. This happens
            // in cleanup paths, where a transaction was not begun. In this case
            // free the thread state
            //

            fFreeThreadState = TRUE;
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        Status = STATUS_UNSUCCESSFUL;
    }

    // Perform THDestroy here because CleanReturn can throw an
    // exception and we need to insure that the thread state is cleaned
    // up on both the success and exception handled cases.

    if (   (fFreeThreadState)
        && (CommitOrAbort!=TransactionCommitAndKeepThreadState)
        && (CommitOrAbort!=TransactionAbortAndKeepThreadState))
    {
        THDestroy();
    }

    return(Status);
}

BOOL
SampExistsDsTransaction(
    void
    )

/*++

Routine Description

    Helper to determine whether a SAM transaction is in effect.

Arguments:

    None

Return Values:

    TRUE if transaction is in effect, FALSE otherwise.

--*/

{
    THSTATE *pTHS;
    // There are code paths (WKSTA and Server) where SAM will
    // call SampIsWriteLockHeldByDs() which in turn calls this routine
    // when the DSA is not initialized.  In that case dwTSindex is
    // uninitialized and we should not reference it.

    return((dwTSindex != (DWORD)-1) && (NULL != (pTHS = pTHStls)) &&
           (NULL!=pTHS->pDB) && (pTHS->transactionlevel>0));
}

VOID
SampSplitNT4SID(
    IN NT4SID       *pAccountSid,
    IN OUT NT4SID   *pDomainSid,
    OUT ULONG       *pRid
    )

/*++

Routine Description:

    DaveStr - 7/17/96 - Copied from newsam2\server\utility.c to avoid new
    exports from samsrv.dll and converted to be NT4SID based - i.e. SID
    sizes are all sizeof(NT4SID) - therefore no allocations required.

    This function splits a sid into its domain sid and rid.

Arguments:

    pAccountSid - Specifies the Sid to be split.  The Sid is assumed to be
        syntactically valid.  Sids with zero subauthorities cannot be split.

    pDomainSid - Pointer to output NT4SID representing the domain SID.

    pRid - Pointer to ULONG to hold the RID on output.

Return Value:

    None.

--*/

{
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;

    //
    // Calculate the size of the domain sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(pAccountSid);


    Assert(AccountSubAuthorityCount >= 1);

    AccountSidLength = RtlLengthSid(pAccountSid);

    if (AccountSidLength > MAX_NT4_SID_SIZE) {
        // This is not a valid NT4 sid. DB must be corrupt?
        Assert(!"Invalid SID");
        // We don't want to continue, or we are going to
        // overrun the pDomainSid buffer. Except now.
        DsaExcept(DSA_DB_EXCEPTION, ERROR_INVALID_SID, 0);
    }

    //
    // Copy the Account sid into the Domain sid
    //

    RtlMoveMemory(pDomainSid, pAccountSid, AccountSidLength);

    //
    // Decrement the domain sid sub-authority count
    //

    (*RtlSubAuthorityCountSid(pDomainSid))--;

    //
    // Copy the rid out of the account sid
    //

    *pRid = *RtlSubAuthoritySid(pAccountSid, AccountSubAuthorityCount-1);
}

NTSTATUS
SampDsCtrlOpUpdateUserSupCreds(
    SAMP_SUPPLEMENTAL_CREDS SuppCreds
    )
/*++

Routine Description:

    Will update the Supplment creds

Arguments:

    SuppCreds - Supp creds struct contains unicode password and DSNAME of user.

Return Value:

    STATUS_SUCESS

--*/

{
    DWORD err = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ATTRBLOCK attrBlockIn, attrBlockOut;
    ULONG i;
    THSTATE *pTHS=NULL;
    BOOL fCommit = FALSE;

    // The extra attributes required by the attribute ATT_USER_PASSWORD when 
    // a modify is noticed
    ULONG samUserPasswordRequiredAttrs[] =
    {
        ATT_SAM_ACCOUNT_NAME,
        ATT_OBJECT_SID, 
        ATT_USER_PRINCIPAL_NAME, 
        ATT_USER_ACCOUNT_CONTROL,
        ATT_SUPPLEMENTAL_CREDENTIALS
    };

    #define NELEMENTS(x) (sizeof(x)/sizeof((x)[0]))

    RtlZeroMemory(&attrBlockIn, sizeof(attrBlockIn));
    RtlZeroMemory(&attrBlockOut, sizeof(attrBlockOut));

    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus)) {
        goto Exit;
    }

    pTHS=pTHStls;

    try {
    
        err = DBFindDSName(pTHS->pDB,
                           SuppCreds.pUserName);
    
        if (err) {
            err = pTHS->errCode;
            _leave;
        }

        // obtain requested input parameters
        attrBlockIn.pAttr = THAllocEx(pTHS, 
                                      NELEMENTS(samUserPasswordRequiredAttrs) * sizeof(ATTR));
        attrBlockIn.attrCount = NELEMENTS(samUserPasswordRequiredAttrs);
        for (i = 0; i < NELEMENTS(samUserPasswordRequiredAttrs); i++) {
    
            ATTCACHE *pAC = SCGetAttById(pTHS, samUserPasswordRequiredAttrs[i]);
            ATTR  *pAttr = NULL;
            ULONG  attrCount = 0;
            Assert(NULL != pAC);
    
            err = DBGetMultipleAtts(pTHS->pDB,
                                    1,
                                    &pAC,
                                    NULL, // no range
                                    NULL,
                                    &attrCount,
                                    &pAttr,
                                    DBGETMULTIPLEATTS_fEXTERNAL,
                                    0);
            if (err) {
                err = pTHS->errCode;
                _leave;
            }
            if (0 == attrCount) {
                // This is handled
                attrBlockIn.pAttr[i].attrTyp = samUserPasswordRequiredAttrs[i];
                attrBlockIn.pAttr[i].AttrVal.valCount = 0;
            } else {
                attrBlockIn.pAttr[i] = *pAttr;
            }
        }
    
        NtStatus = SamIHandleObjectUpdate(eSamObjectUpdateOpCreateSupCreds,
                                          SuppCreds.UpdateInfo,        
                                          &attrBlockIn,
                                          &attrBlockOut);
    
        if ( !NT_SUCCESS(NtStatus) ) {

            err = pTHS->errCode;
            _leave;
        }
    
        // apply the attributes sent back
        for (i = 0; i < attrBlockOut.attrCount; i++) {
    
            // update the object
            ATTCACHE *pAC = SCGetAttById(pTHS, attrBlockOut.pAttr[i].attrTyp);
            Assert(NULL != pAC);
    
            err = DBReplaceAtt_AC(pTHS->pDB,
                                  pAC,
                                  &attrBlockOut.pAttr[i].AttrVal,
                                  NULL);
    
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_BUSY,
                              DIRERR_DATABASE_ERROR,
                              err);
                err = pTHS->errCode;
                _leave;
            }
        }

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) {
            _leave;
        }

        fCommit = TRUE;

    }
    __finally {

        NTSTATUS NtStatus2;

        if (!fCommit) {
            // only resource errors are expected here
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DBCancelRec(pTHS->pDB);
        }

        NtStatus2 = SampMaybeEndDsTransaction(fCommit?
                                              TransactionCommitAndKeepThreadState:
                                              TransactionAbortAndKeepThreadState
                                              );
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = NtStatus2;
        }
    }

    Exit:

    return NtStatus;

}


NTSTATUS
SampDsCtrlOpFillGuidAndSid(
    IN OUT DSNAME *DSName
    )
/*++

Routine Description:

    This routine improves a DSName by attempting to find the object or 
    corresponding phantom and intialize the Guid and Sid.  A thread state
    must exist and a transaction must be open.
        
    This routine exists to give callers from SAM access to DB API semantics
    when initializing DSNAMEs with Guids and Sids.  Dir Apis do not find 
    Sids on phantoms but DB APIs do.
    
    This routine changes database currency and exceptions can be thrown 
    from DB/Jet.

Arguments:

    DSName - The DSNAME to be improved.
    
Return Value:

    STATUS_SUCCESS -- If the routine successfully filled the Guid, the Sid, 
                      or both.
                      
    STATUS_UNSUCCESSFUL -- A called routine failed.  A service error is logged.

--*/
{
    THSTATE *pTHS=pTHStls;
    DWORD dwErr;
    COMMRES CommRes;
    
    //
    // Attempt to improve the DSNAME by resolving either the Guid and/or Sid.
    //    
        
    //
    // Changes currency to position on the object
    //
    dwErr = DBFindDSName(pTHS->pDB, DSName);
    
    if ((0 == dwErr) || (DIRERR_NOT_AN_OBJECT == dwErr))
    {
        //
        // Either the object or a corresponding phantom was found
        //
        dwErr = DBFillGuidAndSid(pTHS->pDB, DSName);
    }   
    
    //
    // Initialize COMMRES to map the error to an NTSTATUS
    //
    RtlZeroMemory(&CommRes, sizeof(COMMRES));
    CommRes.aliasDeref = FALSE;
    CommRes.errCode = pTHS->errCode;
    CommRes.pErrInfo = pTHS->pErrInfo;        
    
    return DirErrorToNtStatus(dwErr, &CommRes);
    
}   

                         
SAMP_AUDIT_NOTIFICATION*
SampAuditFindNotificationToUpdate(
    IN PSID Sid
    )
/*++

Routine Description:

    This routine attempts to find an existing audit notification for the 
    object associated with Sid.
    
    An audit notification is considered a match if the Sid is equal and
    the existing notification is not for a delete.  Deletion notifications
    are not merged with modifications as they preclude the need to audit
    the modification.  
    
Arguments:

    Sid - Object Sid to match.
    
Return Value:

    Pointer to the matching audit notification if found.
    
    Otherwise, NULL.

--*/
{
    THSTATE *pTHS = pTHStls; 
    SAMP_AUDIT_NOTIFICATION *NotificationList = pTHS->pSamAuditNotificationHead;
    SAMP_AUDIT_NOTIFICATION *NotificationToUpdate = NULL;

    //
    // Search the notification list for an audit entry for this object.
    //      
    for (; NotificationList; NotificationList = NotificationList->Next)
    {
        if (RtlEqualSid(Sid, NotificationList->Sid)) {
            
            if (SecurityDbDelete == NotificationList->DeltaType) {
                //
                // This entry has a matching Sid but is a delete which obviates
                // the need for any information about modifications.
                //
                goto Cleanup;
            
            } else { 
                //
                // This entry has a matching Sid and isn't a delete,
                // we'll update this entry.
                //
                NotificationToUpdate = NotificationList;
                break;
            }         
        }             
    } 
    
Cleanup:

    return NotificationToUpdate;

}
 

VOID
SampAuditInitNotification(
    IN ULONG iClass,
    IN DS_DB_OBJECT_TYPE ObjectType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID Sid,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountControl,          
    IN ULONG GroupType,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG AuditType,
    IN OUT SAMP_AUDIT_NOTIFICATION **AuditNotification
    )
/*++

    Routine Description:

       This routine encapsulates the allocation and generic initialization
       of a new audit notification.  Type specific initialization is left
       to the caller.
       
       This routine will throw exceptions if memory allocations fail.
       
    Parameters:
    
       iClass - Object class index into SAM object mapping table.
        
       ObjectType - The type of object associated with this audit.
       
       DeltaType - The type of change being made.
       
       Sid - The object sid of the object being audited.
       
       AccountName - The SAM account name of the object being audited.
       
       AccountControl - The account control, if any, of the object being
                        audited.  This value is ignored until the object 
                        is a user/computer.
                        
       GroupType - The type of group, if the object is a group.  This value
                   is ignored if the object is not a group.
                   
       Privileges - Privilege set
        
       AuditType - This value should have only one bit set indicating the type
                   of audit notification to create.
       
       AuditNotification - Points to a pointer to an audit notification.  If
                           this points to NULL then the notification will 
                           be allocated. 
               
    Return Value

       None.                                                  

--*/
{
    THSTATE *pTHS = pTHStls;
    ULONG cbSid = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    //
    // Verify we're not passing ourselves invalid inputs
    //
    Assert(NULL != AuditNotification);
    Assert(NULL != Sid);
    
    //
    //
    // Allocate and initialize a new audit notification
    //
    if (NULL == *AuditNotification) {
        *AuditNotification = THAllocEx(pTHS, sizeof(SAMP_AUDIT_NOTIFICATION));    
        
        cbSid = RtlLengthSid(Sid);
        
        (*AuditNotification)->Sid = THAllocEx(pTHS, cbSid);  
                    
        NtStatus = RtlCopySid(cbSid, (*AuditNotification)->Sid, Sid);
        Assert(STATUS_SUCCESS == NtStatus);
    }                                                    
    
    //
    // We rely on THAllocEx to zero memory here providing expected defaults
    // like LsapAuditSamAttrNoValue for each LSAP_SAM_AUDIT_ATTR_DELTA_TYPE
    //
    (*AuditNotification)->iClass = iClass;
    (*AuditNotification)->ObjectType = ObjectType;
    (*AuditNotification)->DeltaType = DeltaType;
    (*AuditNotification)->AccountName = AccountName;
    (*AuditNotification)->AccountControl = AccountControl;
    (*AuditNotification)->GroupType = GroupType;
    
    //
    // Preserve any privileges already present
    //
    if (NULL == (*AuditNotification)->Privileges) {
        (*AuditNotification)->Privileges = Privileges;
    }
    
    (*AuditNotification)->AuditType |= AuditType;
    
    return;

}


VOID
SampAuditQueueNotification(
    IN SAMP_AUDIT_NOTIFICATION *AuditNotification
    )
/*++

    Routine Description:

       This routine queue an audit notification to the THSTATE.
       
    Parameters:
    
       AuditNotification - Fully initialized audit notification to queue.
                      
    Return Value

       None.                                                  

--*/  
{   
    THSTATE *pTHS = pTHStls;
       
    if (pTHS->pSamAuditNotificationTail)
    {
        pTHS->pSamAuditNotificationTail->Next = AuditNotification;
    }

    pTHS->pSamAuditNotificationTail = AuditNotification;

    if (NULL==pTHS->pSamAuditNotificationHead)
    {
        pTHS->pSamAuditNotificationHead = AuditNotification;
    }
    
}  
          

VOID
SampAuditValidateNotificationList(
    VOID
    )
/*++

Routine Description:

    This routine validates the current thread's audit notification queue.
    
    This routine should only be called in debug builds.
    
Arguments:

    None.
    
Return Value:

    None.

--*/
{
    THSTATE *pTHS = pTHStls; 
    SAMP_AUDIT_NOTIFICATION *NotificationList;
    SAMP_AUDIT_NOTIFICATION *Notification;;

    //
    // Scan the notification list performing validations
    //
    for (NotificationList = pTHS->pSamAuditNotificationHead; 
         NotificationList; 
         NotificationList = NotificationList->Next) {
        
        Assert(NULL != NotificationList->Sid);
        
        //
        // Compare the current notification's Sid with all other notification's
        // Sids to ensure there is never more than one notification per
        // object per transaction.
        //
        for (Notification = pTHS->pSamAuditNotificationHead;
             Notification;
             Notification = Notification->Next) {
            
            if (NotificationList == Notification) {
                continue;
            }
            
            Assert(!RtlEqualSid(NotificationList->Sid, Notification->Sid));
        }
    }
    
    return;
    
}


NTSTATUS
SampDsCtrlOpUpdateAuditNotification(
    IN OUT PSAMP_UPDATE_AUDIT_NOTIFICATION Update
    )
/*++

Routine Description:

    This routine searches the current thread's audit notification queue
    for an appropriate entry to update.  If an appropriate entry is not
    found, one is created.  
    
    The field that is updated is determined by the value of Update->UpdateType.

    There is no output returned aside from the error status.              
              
Arguments:

    Update - The audit notification update information structure.
    
Return Value:

    STATUS_SUCCESS -- If the routine successfully updates/creates the audit 
                      notification.
                      
    STATUS_UNSUCCESSFUL -- A called routine failed.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    THSTATE *pTHS = pTHStls; 
    SAMP_AUDIT_NOTIFICATION *NotificationList = pTHS->pSamAuditNotificationHead;
    SAMP_AUDIT_NOTIFICATION *NotificationToUpdate = NULL;
    PLSAP_AUDIT_USER_ATTR_VALUES UserInfo = NULL;
    
#if DBG
    SampAuditValidateNotificationList();
#endif
    
    NotificationToUpdate = SampAuditFindNotificationToUpdate(Update->Sid);
                   
    //
    // Create a new template notification entry if a suitable one wasn't found.
    // This notification's initialization will be completed later by
    // SampAuditAddNotifications
    //
    if (NULL == NotificationToUpdate) {
        
        SampAuditInitNotification(
            0,
            0,
            0,
            Update->Sid,
            NULL,
            0,          
            0,
            NULL,
            SAMP_AUDIT_TYPE_PRE_CREATED,
            &NotificationToUpdate
            );  
                               
        SampAuditQueueNotification(NotificationToUpdate);
    }
    
    Assert(NotificationToUpdate);
        
    //
    // We have a valid notification, lets store the requested state information.
    //
    switch (Update->UpdateType) {
        
        case SampAuditUpdateTypePrivileges:
            //
            // Do not overwrite previous state, we always keep the original.
            //
            if (NULL == NotificationToUpdate->Privileges) {
                
                NotificationToUpdate->Privileges = 
                    THAllocEx(
                        pTHS,
                        sizeof(PRIVILEGE_SET)
                        );
                
                RtlCopyMemory(
                    NotificationToUpdate->Privileges,
                    Update->UpdateData.Privileges,
                    sizeof(*(Update->UpdateData.Privileges))
                    );
            }        
            
            break;
        
        case SampAuditUpdateTypeUserAccountControl:          
            //
            // Create the attribute info structure if necessary
            //
            if (NULL == NotificationToUpdate->TypeSpecificInfo) {
                
                NotificationToUpdate->TypeSpecificInfo = 
                    THAllocEx(
                        pTHS,
                        sizeof(LSAP_AUDIT_USER_ATTR_VALUES)
                        );
            }
            
            UserInfo = NotificationToUpdate->TypeSpecificInfo;
            
            //
            // Do not overwrite previous state, we always keep the original.
            //
            if (NULL == UserInfo->PrevUserAccountControl) {
                
                UserInfo->PrevUserAccountControl =
                    THAllocEx(
                        pTHS,
                        sizeof(ULONG)
                        );  
                
                *(UserInfo->PrevUserAccountControl) = 
                    Update->UpdateData.IntegerData;
            }
            
            break;
        
        default:
            Assert(FALSE && "Undefined audit notification update type");
            break;
    }
    
#if DBG
    SampAuditValidateNotificationList();
#endif

    return NtStatus;
    
}   


NTSTATUS        
SampDsControl(
    IN PSAMP_DS_CTRL_OP RequestedOp,
    OUT PVOID *Result
    )
/*++

Routine Description:

    This routine is a generic in process interface for SAM to call into the DS.
    
    The requested operation indicated in RequestedOp will be performed and any
    result will be returned through Result.  The RequestedOp->OpData depends
    on RequestedOp->OpType as does the type of Result.
    
    See SAMP_DS_CTRL_OP for operation specific usage.
    
    A thread state should exist and a transaction must be open when 
    calling this routine.
    
    If Result is allocated, the allocation is performed with THAlloc.
        
Arguments:

    RequestedOp - Points to a SAMP_DS_CTRL_OP and determines what operation
                  will be performed as well as the type of Result.

    Result - Points the the address of the result.
    
Return Value:

    STATUS_SUCCESS -- The requested operation succeeded and Result is valid.
    
    STATUS_INSUFFICIENT_RESOURCES -- A resource contraint prevented success.
    
    Operation specific errors returned from called routines.
    
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    
    //
    // Validate inputs
    //
    Assert(NULL != RequestedOp);
    Assert(NULL != Result);    
    
    //
    // Verify callers are honoring the THS and open transaction requirement.
    //
    Assert(SampExistsDsTransaction());
    
    //
    // Initialize operation result
    //
    *Result = NULL;
    
    __try {
        //
        // Call operation specific worker routine
        //
        switch (RequestedOp->OpType) {
            
            case SampDsCtrlOpTypeFillGuidAndSid:
                
                NtStatus = SampDsCtrlOpFillGuidAndSid(
                               RequestedOp->OpBody.FillGuidAndSid.DSName
                               );
                
                if (NT_SUCCESS(NtStatus)) {
                    *Result = RequestedOp->OpBody.FillGuidAndSid.DSName;
                }
                
                break;

            case SampDsCtrlOpTypeClearPwdForSupplementalCreds:

                NtStatus = SampDsCtrlOpUpdateUserSupCreds(
                               RequestedOp->OpBody.UpdateSupCreds
                               );

                break;  
                
            case SampDsCtrlOpTypeUpdateAuditNotification:
                
                NtStatus = SampDsCtrlOpUpdateAuditNotification(
                               &RequestedOp->OpBody.UpdateAuditNotification
                               );
                
                break;

            default:
                //
                // Was a new operation control type added but not handled here?
                //
                Assert(FALSE && "Undefined DS operation control type");
                break;
                
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid))
    {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        NtStatus = STATUS_UNSUCCESSFUL;
    }
    
    return NtStatus;
    
}


BOOL
SampSamClassReferenced(
    CLASSCACHE  *pClassCache,
    ULONG       *piClass
    )

/*++

Routine Description:

    Determines whether the CLASSCACHE entry provided refers to a
    class SAM manages.

Arguments:

    pClassCache - pointer to a valid CLASSCACHE entry.

    piClass - ULONG pointer which is filled on output to reflect the
        index of the SAM class in ClassMappingTable if the class indeed
        is a SAM class.

Return Value:

    TRUE if arguments reflect a SAM class, FALSE otherwise.

--*/

{
    ULONG objClass;
    ULONG AuxClass;
    ULONG samClass;

    //
    // Special case out the Builtin Domain. The object of class Builtin
    // domain actually maps to DomainObjectType in SAM. However the mapping
    // table defined in this file maps the SAM DomainObjectType to 
    // Domain DNS which is the object class of the (account) domain object.
    // Therefore special case the builtin domain case.
    //

    if (CLASS_BUILTIN_DOMAIN==pClassCache->ClassId)
    {
        *piClass = 1;
        return (TRUE);
    }

    //
    // Walk through the class table
    //
    //

    for ( samClass = 0; samClass < cClassMappingTable; samClass++ )
    {
        if ( ClassMappingTable[samClass].DsClassId == pClassCache->ClassId )
        {
            *piClass = samClass;

            return(TRUE);
        }

        // Iterate over all classes in the class inheritance chain.

        for ( objClass = 0; objClass < pClassCache->SubClassCount; objClass++ )
        {
            if ( pClassCache->pSubClassOf[objClass] ==
                        ClassMappingTable[samClass].DsClassId )
            {
                *piClass = samClass;

                return(TRUE);
            }
        }

       // Iterate over all the auxillary classes in the class inheritance

       for ( AuxClass = 0; AuxClass < pClassCache->AuxClassCount; AuxClass++ )
       {
           if ( pClassCache->pAuxClass[AuxClass] ==
                       ClassMappingTable[samClass].DsClassId )
           {
               *piClass = samClass;

               return(TRUE);
           }
       }



    }

    return(FALSE);
}

BOOL
SampSamAttributeModified(
    ULONG       iClass,
    MODIFYARG   *pModifyArg
    )

/*++

Routine Description:

    Determines if any of the MODIFYARGs refer to attributes which are
    Sam Related.

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

    pModifyArg - pointer to MODIFYARG representing attributes being modified.


Return Value:

    TRUE if a SAM attribute is referenced on success
    FALSE otherwise

--*/

{
    ATTRMODLIST             *pAttrMod;
    ULONG                   objAttr;
    ULONG                   samAttr;
    ULONG                   cAttrMapTable;
    SAMP_ATTRIBUTE_MAPPING  *rAttrMapTable;



    cAttrMapTable = *ClassMappingTable[iClass].pcSamAttributeMap;
    rAttrMapTable = ClassMappingTable[iClass].rSamAttributeMap;
    pAttrMod = &pModifyArg->FirstMod;

    // Iterate over attributes in MODIFYARG.

    for ( objAttr = 0; objAttr < pModifyArg->count; objAttr++ )
    {
        // Iterate over this SAM class' mapped attributes.

        for ( samAttr = 0; samAttr < cAttrMapTable; samAttr++ )
        {
            if ( pAttrMod->AttrInf.attrTyp ==
                                rAttrMapTable[samAttr].DsAttributeId )
            {
                // A Sam Attribute has been referenced
                return TRUE;
            }
        }

        pAttrMod = pAttrMod->pNextMod;
    }

    return FALSE;
}

ATTRTYP
SamNonReplicatedAttrs[]=
{
    ATT_LAST_LOGON,
    ATT_LAST_LOGOFF,
    ATT_BAD_PWD_COUNT,
    ATT_LOGON_COUNT,
    ATT_MODIFIED_COUNT,
    ATT_BAD_PASSWORD_TIME
};

BOOL
SampSamReplicatedAttributeModified(
    ULONG       iClass,
    MODIFYARG   *pModifyArg
    )

/*++

Routine Description:

    Determines if any of the MODIFYARGs refer to attributes which are
    Sam Related and also are to be replicated. Currently the only attribute
    that this routine includes in this list are the Logon statistics
    attribute ( LAST_LOGON, LAST_LOGOFF, BAD_PWD_COUNT, LOGON_COUNT )

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

    pModifyArg - pointer to MODIFYARG representing attributes being modified.


Return Value:

    TRUE if a SAM attribute is referenced on success
    FALSE otherwise

--*/

{
    ATTRMODLIST             *pAttrMod;
    ULONG                   objAttr;
    ULONG                   samAttr;
    ULONG                   cAttrMapTable;
    SAMP_ATTRIBUTE_MAPPING  *rAttrMapTable;



    cAttrMapTable = *ClassMappingTable[iClass].pcSamAttributeMap;
    rAttrMapTable = ClassMappingTable[iClass].rSamAttributeMap;
    pAttrMod = &pModifyArg->FirstMod;

    // Iterate over attributes in MODIFYARG.

    for ( objAttr = 0; objAttr < pModifyArg->count; objAttr++ )
    {
        // Iterate over this SAM class' mapped attributes.

        for ( samAttr = 0; samAttr < cAttrMapTable; samAttr++ )
        {
            if ( pAttrMod->AttrInf.attrTyp ==
                                rAttrMapTable[samAttr].DsAttributeId )
            {
                //
                // A Sam Attribute has been referenced
                // Check to see if it is replicated
                //

                BOOLEAN NonReplicatedAttribute = FALSE;
                ULONG i;

                for (i=0;i<ARRAY_COUNT(SamNonReplicatedAttrs);i++)
                {
                    if (pAttrMod->AttrInf.attrTyp == SamNonReplicatedAttrs[i])
                    {
                        NonReplicatedAttribute = TRUE;
                    }
                }

                //
                // If the attribute is not replicated then return TRUE
                //

                if (!NonReplicatedAttribute)
                {
                    return TRUE;
                }
            }
        }

        pAttrMod = pAttrMod->pNextMod;
    }

    return FALSE;
}

ULONG
SampAddLoopbackRequired(
    ULONG       iClass,
    ADDARG      *pAddArg,
    BOOL        *pfLoopbackRequired,
    BOOL        *pfUserPasswordSupport
    )

/*++

Routine Description:

    Determines if any of the ADDARGS refer to attributes which are
    SamWriteRequired.  Returns an error if ADDARGS reference
    attributes which are SamReadOnly.

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

    pAddArg - pointer to ADDARG representing attributes being added.

    pfLoopbackRequired - pointer to BOOL which is set to TRUE iff no errors
        and SamWriteRequired attributes are in the ADDARG.

Return Value:

    0 on success, error code otherwise.  Sets pTHStls->errCode on error.

--*/

{
    ATTR                    *rAttr;
    ULONG                   objAttr;
    ULONG                   samAttr;
    ULONG                   cAttrMapTable;
    SAMP_ATTRIBUTE_MAPPING  *rAttrMapTable;

    *pfUserPasswordSupport = gfUserPasswordSupport;

    // Special case the Non Domain NC creation case

    if (SampDomainObjectType==ClassMappingTable[iClass].SamObjectType)
    {
        CROSS_REF * pCR;
        COMMARG     Commarg;

        //
        // Find the cross ref for the domain in which the object is purported
        // to reside
        //

        pCR = FindBestCrossRef(pAddArg->pObject,&Commarg);

        if  ((NULL!=pCR) &&
            (NameMatched(pCR->pNC, pAddArg->pObject)) &&
            (!(pCR->flags & FLAG_CR_NTDS_DOMAIN ))) 
        {
            //
            // Creating a non domain NC
            //

            *pfLoopbackRequired = FALSE;
            return(0);

        }

        //
        // Fall through the default creation of domains path, any failure
        // in FindBestCrossRef (e.g no matching cross ref )
        // will also make the code fallback into the default loopback check
        // which will prevent the creation of a domain
        //

        THClearErrors();
    }

    // By definition, an add of a SAM object must be looped back.

    *pfLoopbackRequired = TRUE;

    cAttrMapTable = *ClassMappingTable[iClass].pcSamAttributeMap;
    rAttrMapTable = ClassMappingTable[iClass].rSamAttributeMap;
    rAttr = pAddArg->AttrBlock.pAttr;

    // Iterate over attributes in ADDARG.

    for ( objAttr = 0; objAttr < pAddArg->AttrBlock.attrCount; objAttr++ )
    {
        // Iterate over this SAM class' mapped attributes.

        for ( samAttr = 0; samAttr < cAttrMapTable; samAttr++ )
        {
            if ( rAttr[objAttr].attrTyp ==
                                rAttrMapTable[samAttr].DsAttributeId )
            {
                switch ( rAttrMapTable[samAttr].writeRule )
                {
                case SamWriteRequired:

                    //
                    // We only treat ATT_USER_PASSWORD as a loopback arg
                    // if the heuristic gfUserPasswordSupport is true
                    //

                    if ( !((rAttr[objAttr].attrTyp == ATT_USER_PASSWORD) &&
                        !*pfUserPasswordSupport) ) {

                        *pfLoopbackRequired = TRUE;
                    
                    } 
                    // Don't return immediately since we want to process
                    // the rest of the ADDARG looking for SamReadOnly
                    // cases since that requires us to return an error.

                    break;

                case SamReadOnly:


                    SetSvcError(
                            SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_ATTRIBUTE_OWNED_BY_SAM);

                    return(pTHStls->errCode);

                case NonSamWriteAllowed:

                    break;

                default:

                    LogUnhandledError(STATUS_UNSUCCESSFUL);
                    Assert(!"Missing SAMP_WRITE_RULES case");
                }
            }
        }
    }

    return(0);
}

ULONG
SampModifyLoopbackRequired(
    ULONG       iClass,
    MODIFYARG   *pModifyArg,
    BOOL        *pfLoopbackRequired,
    BOOL        *pfUserPasswordSupport
    )

/*++

Routine Description:

    Determines if any of the MODIFYARGs refer to attributes which are
    SamWriteRequired.  Returns an error if MODIFYARGs reference
    attributes which are SamReadOnly.

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

    pModifyArg - pointer to MODIFYARG representing attributes being modified.

    pfLoopbackRequired - pointer to BOOL which is set to TRUE iff no errors
        and SamWriteRequired attributes are in the MODIFYARGs.

Return Value:

    0 on success, error code otherwise.  Sets pTHStls->errCode on error.

--*/

{
    ATTRMODLIST             *pAttrMod;
    ULONG                   objAttr;
    ULONG                   samAttr;
    ULONG                   cAttrMapTable;
    SAMP_ATTRIBUTE_MAPPING  *rAttrMapTable;

    *pfLoopbackRequired = FALSE;
    *pfUserPasswordSupport = gfUserPasswordSupport;

    cAttrMapTable = *ClassMappingTable[iClass].pcSamAttributeMap;
    rAttrMapTable = ClassMappingTable[iClass].rSamAttributeMap;
    pAttrMod = &pModifyArg->FirstMod;

    // Iterate over attributes in MODIFYARG.

    for ( objAttr = 0; objAttr < pModifyArg->count; objAttr++ )
    {
        // Iterate over this SAM class' mapped attributes.

        for ( samAttr = 0; samAttr < cAttrMapTable; samAttr++ )
        {
            if ( pAttrMod->AttrInf.attrTyp ==
                                rAttrMapTable[samAttr].DsAttributeId )
            {
                switch ( rAttrMapTable[samAttr].writeRule )
                {
                case SamWriteRequired:

                    //
                    // We only treat ATT_USER_PASSWORD as a loopback arg
                    // if the heuristic gfUserPasswordSupport is true
                    //

                    if ( !((pAttrMod->AttrInf.attrTyp == ATT_USER_PASSWORD) &&
                        !*pfUserPasswordSupport) ) {

                        *pfLoopbackRequired = TRUE;

                    }

                    // Don't return immediately since we want to process
                    // the rest of the MODIFYARG looking for SamReadOnly
                    // cases since that requires us to return an error.

                    break;

                case SamReadOnly:

                    SetSvcError(
                            SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_ATTRIBUTE_OWNED_BY_SAM);

                    return(pTHStls->errCode);

                case NonSamWriteAllowed:

                    break;

                default:

                    LogUnhandledError(STATUS_UNSUCCESSFUL);
                    Assert(!"Missing SAMP_WRITE_RULES case");
                }
            }
        }

        pAttrMod = pAttrMod->pNextMod;
    }

    return(0);
}

VOID
SampBuildAddCallMap(
    ADDARG              *pArg,
    ULONG               iClass,
    ULONG               *pcCallMap,
    SAMP_CALL_MAPPING   **prCallMap,
    ACCESS_MASK         *pDomainModifyRightsRequired,
    ACCESS_MASK         *pObjectModifyRightsRequired,
    BOOL                fUserPasswordSupport
    )

/*++

Routine Description:

    Converts an ADDARG to a SAMP_CALL_MAPPING array.

Arguments:

    pArg - pointer to ADDARG to convert.

    iClass - index of the SAM class in ClassMappingTable.

    pcCallMap - pointer to ULONG which holds size of call mapping on return.

    prCallMap - pointer to call mapping array which is allocated and filled
        on return.

Return Value:

    None.

--*/

{
    THSTATE                *pTHS=pTHStls;
    ULONG                   i;
    ULONG                   cCallMap;
    SAMP_CALL_MAPPING       *rCallMap;
    ULONG                   cAttributeMap;
    SAMP_ATTRIBUTE_MAPPING  *rAttributeMap;
    ULONG                   iMappedAttr;

    *pDomainModifyRightsRequired = 0;
    *pObjectModifyRightsRequired = 0;

    // Allocate return data.

    cCallMap = pArg->AttrBlock.attrCount;
    rCallMap = (SAMP_CALL_MAPPING *) THAllocEx(pTHS,
                            (cCallMap) * sizeof(SAMP_CALL_MAPPING));

    // Fill in the return data.

    cAttributeMap = *ClassMappingTable[iClass].pcSamAttributeMap;
    rAttributeMap = ClassMappingTable[iClass].rSamAttributeMap;

    for ( i = 0; i < cCallMap; i++ )
    {
        rCallMap[i].fSamWriteRequired = FALSE;
        rCallMap[i].choice = AT_CHOICE_ADD_ATT;
        rCallMap[i].attr = pArg->AttrBlock.pAttr[i];

        // Determine if this is a SAM attribute.
        // Iterate over each attribute mapped by this SAM class.

        for ( iMappedAttr = 0; iMappedAttr < cAttributeMap; iMappedAttr++ )
        {
            if (   (pArg->AttrBlock.pAttr[i].attrTyp ==
                                    rAttributeMap[iMappedAttr].DsAttributeId)
                && (rAttributeMap[iMappedAttr].writeRule != NonSamWriteAllowed)
                // Test for special cross domain move case so as to allow
                // IDL_DRSRemoteAdd to write the SID history.
                && !(    (ATT_SID_HISTORY == pArg->AttrBlock.pAttr[i].attrTyp)
                      && (pTHS->fCrossDomainMove) ) )
            {

                //
                // We only treat ATT_USER_PASSWORD as a loopback arg
                // if the heuristic gfUserPasswordSupport is true
                //

                if ( !((pArg->AttrBlock.pAttr[i].attrTyp == ATT_USER_PASSWORD) &&
                    !fUserPasswordSupport) ) {
                
                    // This is a mapped attribute.
    
                    rCallMap[i].fSamWriteRequired = TRUE;
                    rCallMap[i].iAttr = iMappedAttr;
    
                    // Add in any new access rights required.
    
                    *pDomainModifyRightsRequired |=
                            rAttributeMap[iMappedAttr].domainModifyRightsRequired;
                    *pObjectModifyRightsRequired |=
                            rAttributeMap[iMappedAttr].objectModifyRightsRequired;
    
                    // By the time the loopback code makes Samr calls
                    // to write the mapped attribute, the object will
                    // already have been added via SamrCreate<type>InDomain.
                    // SAM writes all mapped properties on creation to insure
                    // that they have a legal default value.  Thus we tag
                    // the choice as AT_CHOICE_REPLACE_ATT since that is
                    // the corresponding legal operation to perform on an
                    // existing value.  Except in the case of group membership
                    // where the desired operator is AT_CHOICE_ADD_VALUES as
                    // per SampWriteGroupMembers in samwrite.c.
    
                    if ( ATT_MEMBER == pArg->AttrBlock.pAttr[i].attrTyp )
                    {
                        rCallMap[i].choice = AT_CHOICE_ADD_VALUES;
                    }
                    else
                    {
                        rCallMap[i].choice = AT_CHOICE_REPLACE_ATT;
                    }

                }

                break;
            }
        }
    }

    // Assign return values.

    *pcCallMap = cCallMap;
    *prCallMap = rCallMap;
}

VOID
SampBuildModifyCallMap(
    MODIFYARG           *pArg,
    ULONG               iClass,
    ULONG               *pcCallMap,
    SAMP_CALL_MAPPING   **prCallMap,
    ACCESS_MASK         *pDomainModifyRightsRequired,
    ACCESS_MASK         *pObjectModifyRightsRequired,
    BOOL                fUserPasswordSupport
    )

/*++

Routine Description:

    Converts a MODIFYARG to a SAMP_CALL_MAPPING array.

Arguments:

    pArg - pointer to MODIFYARG to convert.

    iClass - index of the SAM class in ClassMappingTable.

    pcCallMap - pointer to ULONG which holds size of call mapping on return.

    prCallMap - pointer to call mapping array which is allocated and filled
        on return.

Return Value:

    None.

--*/

{
    THSTATE                *pTHS=pTHStls;
    ULONG                   i;
    ULONG                   cCallMap;
    SAMP_CALL_MAPPING       *rCallMap;
    ULONG                   cAttributeMap;
    SAMP_ATTRIBUTE_MAPPING  *rAttributeMap;
    ULONG                   iMappedAttr;
    ATTRMODLIST             *pAttrMod;

    *pDomainModifyRightsRequired = 0;
    *pObjectModifyRightsRequired = 0;

    // Allocate return data.

    cCallMap = pArg->count;
    rCallMap = (SAMP_CALL_MAPPING *) THAllocEx(pTHS,
                            (cCallMap) * sizeof(SAMP_CALL_MAPPING));

    // Fill in the return data.

    cAttributeMap = *ClassMappingTable[iClass].pcSamAttributeMap;
    rAttributeMap = ClassMappingTable[iClass].rSamAttributeMap;

    pAttrMod = &pArg->FirstMod;

    for ( i = 0; i < cCallMap; i++ )
    {
        rCallMap[i].fSamWriteRequired = FALSE;
        rCallMap[i].choice = pAttrMod->choice;
        rCallMap[i].attr = pAttrMod->AttrInf;

        // Determine if this is a SAM attribute.
        // Iterate over each attribute mapped by this SAM class.

        for ( iMappedAttr = 0; iMappedAttr < cAttributeMap; iMappedAttr++ )
        {
            if (( pAttrMod->AttrInf.attrTyp ==
                        rAttributeMap[iMappedAttr].DsAttributeId ) &&
                (NonSamWriteAllowed!=rAttributeMap[iMappedAttr].writeRule))
            {

                //
                // We only treat ATT_USER_PASSWORD as a loopback arg
                // if the heuristic gfUserPasswordSupport is true
                //

                if ( !((pAttrMod->AttrInf.attrTyp == ATT_USER_PASSWORD) &&
                    !fUserPasswordSupport) ) {

                    // This is a mapped attribute.
    
                    rCallMap[i].fSamWriteRequired = TRUE;
                    rCallMap[i].iAttr = iMappedAttr;
    
                    // Add in any new access rights required.
    
                    *pDomainModifyRightsRequired |=
                            rAttributeMap[iMappedAttr].domainModifyRightsRequired;
                    *pObjectModifyRightsRequired |=
                            rAttributeMap[iMappedAttr].objectModifyRightsRequired;

                }

                break;
            }
        }

        pAttrMod = pAttrMod->pNextMod;
    }

    // Assign return values.

    *pcCallMap = cCallMap;
    *prCallMap = rCallMap;
}

BOOL
SampExistsDsLoopback(
    DSNAME  **ppLoopbackName OPTIONAL
    )

/*++

Routine Description:

    Determines if this thread in SAM is part of a loopback operation,
    and if so, returns the DN of the looped back object.

Arguments:

    ppLoopbackName - pointer to pointer to DSNAME which represents the
        looped back object DN.

Return Value:

    TRUE if loopback case, false otherwise.

--*/

{
    THSTATE *pTHS=pTHStls;
    SAMP_LOOPBACK_ARG *pSamLoopback;

    if ( SampExistsDsTransaction() &&
         (NULL != pTHS->pSamLoopback) )
    {
        pSamLoopback = (SAMP_LOOPBACK_ARG *) pTHS->pSamLoopback;

        Assert(NULL != pSamLoopback->pObject);

        if ( ARGUMENT_PRESENT( ppLoopbackName ) )
        {
            *ppLoopbackName = pSamLoopback->pObject;
        }

        return(TRUE);
    }

    return(FALSE);
}

VOID
SampMapSamLoopbackError(
    NTSTATUS status
    )

/*++

Routine Description:

    Calls looped back through SAM may return an error.  This error
    may have originated in SAM or in the DS.  In the latter (DS) case,
    pTHStls->errCode is already set and there is nothing more to do.
    In the SAM case, we need to generate a DS error.

Arguments:

    status - an NTSTATUS returned by SAM.

Return Value:

    None

--*/

{
    THSTATE *pTHS=pTHStls;

    if ( NT_SUCCESS(status) )
    {
        // No SAM error.  We still should clear pTHStls->errCode
        // because the DS may have returned a missing attribute
        // error for a group membership operation (for example)
        // which set pTHStls->errCode but which SAM treated as
        // a successful empty membership.

        pTHS->errCode = 0;
    }
    else if ( 0 != pTHS->errCode )
    {
        // Error originated in DS - nothing to do as pTHStls->errCode
        // is already set.

        NULL;
    }
    else
    {
        // Error originated SAM - map it as best we can.

        switch ( status )
        {
        case STATUS_ACCESS_DENIED:
        case STATUS_INVALID_DOMAIN_ROLE:
        case STATUS_ACCOUNT_RESTRICTION:
        case STATUS_INVALID_WORKSTATION:
        case STATUS_INVALID_LOGON_HOURS:
        case STATUS_PRIVILEGE_NOT_HELD:

            SetSecError(
                SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                RtlNtStatusToDosError(status));
            break;

        case STATUS_ALIAS_EXISTS:
        case STATUS_GROUP_EXISTS:
        case STATUS_USER_EXISTS:
        case STATUS_MEMBER_IN_GROUP:
        case STATUS_MEMBER_IN_ALIAS:

            SetUpdError(
                UP_PROBLEM_ENTRY_EXISTS,
                RtlNtStatusToDosError(status));
            break;

        case STATUS_BUFFER_OVERFLOW:
        case STATUS_BUFFER_TOO_SMALL:
        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:

            SetSysError(
                ENOMEM,
                RtlNtStatusToDosError(status));
            break;

        case STATUS_DISK_FULL:
            SetSysError(
                ENOSPC,
                RtlNtStatusToDosError(status));
            break;

        case STATUS_DS_BUSY:

            SetSvcError(SV_PROBLEM_BUSY,RtlNtStatusToDosError(status));
            break;

        case STATUS_DS_UNAVAILABLE:

            SetSvcError(SV_PROBLEM_UNAVAILABLE,RtlNtStatusToDosError(status));
            break;

        case STATUS_DS_ADMIN_LIMIT_EXCEEDED:

            SetSvcError(SV_PROBLEM_ADMIN_LIMIT_EXCEEDED,DS_ERR_ADMIN_LIMIT_EXCEEDED);
            break;

        case STATUS_NO_SUCH_ALIAS:
        case STATUS_NO_SUCH_DOMAIN:
        case STATUS_NO_SUCH_GROUP:
        case STATUS_NO_SUCH_MEMBER:
        case STATUS_NO_SUCH_USER:
        case STATUS_OBJECT_NAME_NOT_FOUND:

            // Could pass pTHS->pSamLoopback->pObject as 2nd parameter
            // but no guarantee that this is the name which failed.  I.e.
            // failing name could have been a member being added/removed.
            // So use NULL since SetNamError() is coded to accept it.

            SetNamError(
                NA_PROBLEM_NO_OBJECT,
                NULL,
                RtlNtStatusToDosError(status));
            break;

        case STATUS_OBJECT_NAME_INVALID:
             SetNamError(
                NA_PROBLEM_BAD_NAME,
                NULL,
                RtlNtStatusToDosError(status));
            break;


        case STATUS_DS_OBJ_CLASS_VIOLATION:
             SetUpdError(
                 UP_PROBLEM_OBJ_CLASS_VIOLATION,
                 RtlNtStatusToDosError(status));
             break;
        case STATUS_DS_CANT_ON_NON_LEAF:
             SetUpdError(
                 UP_PROBLEM_CANT_ON_NON_LEAF,
                 RtlNtStatusToDosError(status));

             break;
        case STATUS_DS_CANT_MOD_OBJ_CLASS:
             SetUpdError(
                 UP_PROBLEM_CANT_MOD_OBJ_CLASS,
                 RtlNtStatusToDosError(status));
             break;

        case STATUS_INVALID_DOMAIN_STATE:
        case STATUS_INVALID_SERVER_STATE:
        case STATUS_CANNOT_IMPERSONATE:

            SetSysError(
                EBUSY,
                RtlNtStatusToDosError(status));
            break;

        case STATUS_BAD_DESCRIPTOR_FORMAT:
        case STATUS_DATA_ERROR:
        case STATUS_ILL_FORMED_PASSWORD:
        case STATUS_INVALID_ACCOUNT_NAME:
        case STATUS_INVALID_HANDLE:
        case STATUS_INVALID_ID_AUTHORITY:
        case STATUS_INVALID_INFO_CLASS:
        case STATUS_INVALID_OWNER:
        case STATUS_INVALID_PARAMETER:
        case STATUS_INVALID_SID:
        case STATUS_NO_MORE_ENTRIES:
        case STATUS_OBJECT_TYPE_MISMATCH:
        case STATUS_SPECIAL_ACCOUNT:
        case STATUS_INVALID_MEMBER:

            SetSysError(
                EINVAL,
                RtlNtStatusToDosError(status));
            break;

        case STATUS_UNSUCCESSFUL:
        case STATUS_NOT_IMPLEMENTED:
        case STATUS_INTERNAL_ERROR:
        default:

            SetSvcError(
                SV_PROBLEM_WILL_NOT_PERFORM,
                RtlNtStatusToDosError(status));
            break;
        }
    }
}

ULONG
SampDeriveMostBasicDsClass(
    ULONG   DerivedClass
    )

/*++

Routine Description:

    Returns the most basic DS class which SAM knows about that
    the presented class is derived from.

Arguments:

    DerivedClass - A CLASS_* value which may or may not be derived
        from a more basic class SAM knows how to handle.

Return Value:

    A valid CLASS_* value.  If no derivation is discovered, this
        is the same as the DerivedClass input value.


--*/

{
    THSTATE     *pTHS=pTHStls;
    CLASSCACHE  *pCC = NULL;
    ULONG       iClass;

    if ( !(pCC = SCGetClassById(pTHS, DerivedClass)) ||
         !SampSamClassReferenced(pCC, &iClass) )
    {
        // We should always be able to look up the class since
        // SAM read it from the DS to begin with.  And it should
        // be a class SAM knows about since SAM is handling the
        // operation.  I.e. If the call originated in SAM it
        // it should know what it is dealing with.  If the call
        // originated in the DS we should only be looping things
        // back which derive from a basic SAM class.
        //
        // No longer true because addsid.c reads the object specified
        // by the user. It can be anything. addsid.c calls this function
        // to decide if the object is or is not an acceptable basic class.
        // So, don't assert. Return the DerivedClass and addsid.c will
        // error off. All of the other callers of this function will
        // assert on their own when they notice DerivedClass is not a
        // most basic SAM class.
        // Assert(!"Should not happen");
        return(DerivedClass);
    }

    return(ClassMappingTable[iClass].DsClassId);
}

VOID
SampSetDsa(
    BOOLEAN DsaFlag
   )
/*++
  Routine Description

     This routine sets/resets the fDSA flag in pTHStls based on the
     passed in DsaFlag. pTHStls->fDSA is used to indicate to the DS
     that this is the DS itself that is doing the operation and therefore
     proceed with the operation without any access checks. This is
     used by in process clients like to SAM to perform certain privileged
     operations.

  Parameters:
     DsaFlag -- pTHS->fDSA is set to this.

  Return Values


    None
--*/
{
    THSTATE *pTHS=pTHStls;

    if (NULL!=pTHS)
        pTHS->fDSA = DsaFlag;
}


VOID
SampSetLsa(
    BOOLEAN LsaFlag
   )
/*++
  Routine Description

     This routine sets/resets the fLSA flag in pTHStls based on the
     passed in DsaFlag. pTHStls->fLSA is used to indicate to the DS
     that this is the LSA itself that is doing the operation and therefore
     proceed with the operation without any access checks. This is
     used by in process clients like to the LSA to perform certain privileged
     operations.

  Parameters:
     LsaFlag -- pTHSTls->fLsa is set to this.

  Return Values


    None
--*/
{
    THSTATE *pTHS=pTHStls;

    if (NULL!=pTHS)
        pTHS->fLsa = LsaFlag;
}

DWORD
SampCheckForDomainMods(
   IN   THSTATE   *pTHS,                    
   IN   DSNAME    *pObject,
   IN   ULONG      cModAtts,
   IN   ATTRTYP   *pModAtts,
   OUT  BOOL      *fIsMixedModeChange,
   OUT  BOOL      *fRoleChange,
   OUT  DOMAIN_SERVER_ROLE *NewRole
   )
/*++

  Routine Description

    This routine determines the new role (BDC or PDC) for the local DC, 
    if the fsmo attribute on the domain object changed.

  Parameters:
                            
    pObject -- the object being modified
    
    cModAttrs -- the count of (replicatable) attributes that were changed                                        
    
    pModAtts  -- the (replicatable) attributes that were changed.

    fIsMixedModeChange -- did the mixed mode change
        
    fRoleChange -- if a role change occured
                                    
    NewRole   -- the new role of the server

  Return Values

    0 on success, !0 on fatal error                  
    
--*/
{
    ULONG   i;
    DWORD   err = 0;
    DSNAME *pRoleOwner = NULL;
    DWORD  ntMixedDomain = 1;
    ULONG   len = 0;

    *fIsMixedModeChange = FALSE;
    *fRoleChange = FALSE;
    *NewRole = DomainServerRoleBackup;

    if ( DsaIsInstalling() ) {
        return 0;
    }

    if (NameMatched(pObject,gAnchor.pDomainDN)) {
        for (i = 0; i < cModAtts; i++) {
            if (pModAtts[i] == ATT_FSMO_ROLE_OWNER) {
                // Read the new value
                err = DBGetAttVal(pTHS->pDB, 
                                  1, 
                                  ATT_FSMO_ROLE_OWNER,
                                  0, 
                                  0, 
                                  &len, 
                                  (UCHAR **) &pRoleOwner);
                if (err) {
                    SetSvcError(SV_PROBLEM_DIR_ERROR,err);
                    goto exit;
                } else {
                    *fRoleChange = TRUE;
                    if (NameMatched(gAnchor.pDSADN, pRoleOwner) ) {
                        *NewRole = DomainServerRolePrimary;
                    } else {
                        *NewRole = DomainServerRoleBackup;
                    }
                    THFreeEx(pTHS, pRoleOwner);
                }
            } else if (pModAtts[i] == ATT_NT_MIXED_DOMAIN) {


                err = DBGetSingleValue(pTHS->pDB,
                                       ATT_NT_MIXED_DOMAIN,
                                       &ntMixedDomain,
                                       sizeof(ntMixedDomain),
                                       NULL);
                if (err) {
                    SetSvcError(SV_PROBLEM_DIR_ERROR,err);
                    goto exit;
                }
                if (ntMixedDomain == 0) {
                    *fIsMixedModeChange = TRUE;
                }

            }
        }
    }

exit:

    return err;
}

VOID
SampAuditFailedAbortTransaction( 
    IN ULONG DsaException,
    IN DWORD Error,
    IN ULONG Location
    )
/*++

    Routine Description:

       This routine throws DsaException to cause a transaction to fail and
       roll back when a required audit can not be written for some reason.
        
       This wrapper for DsaException exists to encapsulate the audit failure
       behavior for SAM in DS mode.  Future plans currently include an LSA
       exported handler for failed audits that will honor crash on audit
       failure configurations for the auditing component.  This routine will
       serve as a single source for update such a mechanism or change be
       required.

    Parameters:

       DsaException - The exception to throw.
       
       Error - The error code associated with the exception.            
            
       Location - This ULONG is encoded file and line information for
                  DsaException.  Typically, DSID(FILENO, __LINE__).
                      
    Return Value

       None.                                                    

--*/
{
    RaiseDsaExcept(DsaException, 
                   Error, 
                   0, 
                   Location, 
                   DS_EVENT_SEV_MINIMAL
                   );   
    
}    


//
// Data types of attributes audited 
//
typedef enum _AUDIT_ATTR_DATATYPE {
    
    AuditDatatypeString = 0,
    AuditDatatypeMultivaluedString,
    AuditDatatypeUlong,
    AuditDatatypeLargeInteger,
    AuditDatatypeDeltaTime,
    AuditDatatypeFileTime,
    AuditDatatypeBitfield,
    AuditDatatypeSid,
    AuditDatatypeSidList,
    AuditDatatypeLogonHours,
    AuditDatatypeSecret,
    AuditDatatypeUndefined
    
} AUDIT_ATTR_DATATYPE;


//
// A table for each object type maps the ATTRTYP to the correct offset in
// the object specific structure
//    
                   

//
// Audit attribute information lookup table entry
//
typedef struct _SAMP_AUDIT_ATTR_INFO {
    
    ATTRTYP AttrId;
    AUDIT_ATTR_DATATYPE AttributeDataType;
    ULONG AttrFieldOffset;
        
} SAMP_AUDIT_ATTR_INFO;


//
// Table of attribute offset information for SAMP_AUDIT_GROUP_ATTR_VALUES
//
SAMP_AUDIT_ATTR_INFO SampAuditUserAttributeInfo[] = {
    
    { ATT_SAM_ACCOUNT_NAME,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, SamAccountName) },
    
    { ATT_DISPLAY_NAME,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, DisplayName) },
      
    { ATT_USER_PRINCIPAL_NAME,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserPrincipalName) },
    
    { ATT_HOME_DIRECTORY,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, HomeDirectory) },

    { ATT_HOME_DRIVE,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, HomeDrive) },

    { ATT_SCRIPT_PATH,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, ScriptPath) },

    { ATT_PROFILE_PATH,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, ProfilePath) },

    { ATT_USER_WORKSTATIONS,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserWorkStations) },

    { ATT_PWD_LAST_SET,
      AuditDatatypeFileTime,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, PasswordLastSet) },

    { ATT_ACCOUNT_EXPIRES,
      AuditDatatypeFileTime,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, AccountExpires) },

    { ATT_PRIMARY_GROUP_ID,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, PrimaryGroupId) },
    
    { ATT_MS_DS_ALLOWED_TO_DELEGATE_TO,
      AuditDatatypeMultivaluedString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, AllowedToDelegateTo) },

    { ATT_USER_ACCOUNT_CONTROL,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserAccountControl) },
    
    { ATT_USER_PARAMETERS,
      AuditDatatypeSecret,                         
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserParameters) },
    
    { ATT_SID_HISTORY,
      AuditDatatypeSidList,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, SidHistory) },

    { ATT_LOGON_HOURS,
      AuditDatatypeLogonHours,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, LogonHours) },
     
    { ATT_DNS_HOST_NAME,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, DnsHostName) },
    
    { ATT_SERVICE_PRINCIPAL_NAME,
      AuditDatatypeMultivaluedString,
      LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, ServicePrincipalNames) }
    
};

ULONG cSampAuditUserAttributeInfo =
    sizeof(SampAuditUserAttributeInfo) /
        sizeof(SAMP_AUDIT_ATTR_INFO);


//
// Table of attribute offset information for SAMP_AUDIT_GROUP_ATTR_VALUES
//
SAMP_AUDIT_ATTR_INFO SampAuditGroupAttributeInfo[] = {
    
    { ATT_SAM_ACCOUNT_NAME,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_GROUP_ATTR_VALUES, SamAccountName) },
    
    { ATT_SID_HISTORY,
      AuditDatatypeSidList,
      LSAP_FIELD_PTR(LSAP_AUDIT_GROUP_ATTR_VALUES, SidHistory) }
      
};     

ULONG cSampAuditGroupAttributeInfo =
    sizeof(SampAuditGroupAttributeInfo) /
        sizeof(SAMP_AUDIT_ATTR_INFO);
                        

//
// Table of attribute offset information for SAMP_AUDIT_DOMAIN_ATTR_VALUES
//
SAMP_AUDIT_ATTR_INFO SampAuditDomainAttributeInfo[] = {
    
    { ATT_MIN_PWD_AGE,
      AuditDatatypeDeltaTime,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MinPasswordAge) },
    
    { ATT_MAX_PWD_AGE,
      AuditDatatypeDeltaTime,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MaxPasswordAge) },
      
    { ATT_FORCE_LOGOFF,
      AuditDatatypeDeltaTime,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, ForceLogoff) },
    
    { ATT_LOCKOUT_THRESHOLD,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, LockoutThreshold) },
    
    { ATT_LOCK_OUT_OBSERVATION_WINDOW,
      AuditDatatypeDeltaTime,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, LockoutObservationWindow) },
      
    { ATT_LOCKOUT_DURATION,
      AuditDatatypeDeltaTime,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, LockoutDuration) },
    
    { ATT_PWD_PROPERTIES,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, PasswordProperties) },
    
    { ATT_MIN_PWD_LENGTH,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MinPasswordLength) },
      
    { ATT_PWD_HISTORY_LENGTH,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, PasswordHistoryLength) },
    
    { ATT_MS_DS_MACHINE_ACCOUNT_QUOTA,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MachineAccountQuota) },
    
    { ATT_NT_MIXED_DOMAIN,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MixedDomainMode) },
      
    { ATT_MS_DS_BEHAVIOR_VERSION,
      AuditDatatypeUlong,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, DomainBehaviorVersion) },
    
    { ATT_OEM_INFORMATION,
      AuditDatatypeString,
      LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, OemInformation) }

};

ULONG cSampAuditDomainAttributeInfo =
    sizeof(SampAuditDomainAttributeInfo) /
        sizeof(SAMP_AUDIT_ATTR_INFO);


//
// Used by qsort to sort ATTCACHE array for efficient search
//
extern
int __cdecl
CmpACByAttType(
    const void * keyval, 
    const void * datum
    );


int __cdecl
CmpByAttType(
    IN const void * keyval, 
    IN const void * datum
    )
/*++

    Routine Description:

        A simple function to be used with qsort to sort ATTRTYP. 
        
    Parameters:
    
       keyval - ATTRTYPE left
       
       datum - ATTRTYP right
        
    Return Value

       < 0 - Less than
       0   - equal
       > 0 - Greater than                                                     

--*/

{
    ATTRTYP *ppAttrTypKey = (ATTRTYP*)keyval;
    ATTRTYP *ppAttrTypDatum = (ATTRTYP*)datum;

    return (*ppAttrTypKey - *ppAttrTypDatum);
} 
        

VOID
SampAuditGetChangeInfo(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG cModAtts,
    IN ATTRTYP *pModAtts,
    IN OUT PVOID *NewValueInfo, OPTIONAL
    IN ULONG cAttributeMappingTable,
    IN SAMP_ATTRIBUTE_MAPPING *pAttributeMappingTable
    )
/*++

    Routine Description:

       This routine gathers new value information for all audited attributes
       that were modified as part of the transaction.
       
       1) Examine transaction metadata and determine which attribute changes 
       need to be audited.  
       
       2) The new values are read from the database.
        
       3) An ObjectType specific structure is allocated and then referenced
       through a generic pointer.
       
       4) Table lookups determine an offset into the structure for storing
       a pointer to the attribute value and the type of change made.
       
       NewValueInfo points the newly allocated structure upon return.  The
       memory for this structure as well as the attribute values come from
       the thread's heap and will be be freed then the THSTATE is cleaned up.
       
       This routine can throw exceptions, THAllocEx is used.

    Parameters:
    
       ObjectType - The type of the SAM object

       cModAtts - Count of attributes in the metadata vector
        
       pModAtts - The metadata vector attribute types
        
       NewValueInfo - PVOID pointing to an object speficic structure that
                      holds the new values for all modified attributes.  If 
                      this points to a non-NULL value then the pointer is
                      assumed valid and the existing NewValueInfo structure
                      will be updated.
                             
       cAttributeMappingTable - Count of items in pAttributeMappingTable
        
       pAttributeMappingTable - SAM attribute mapping table for the object
                                type being modified in this transaction.
        
    Return Value

       Nothing.
       
       Exception is throw on failure.                                                     

--*/
{    
    DWORD dwError = ERROR_SUCCESS;
    THSTATE *pTHS = pTHStls;
    ATTRVAL       *pAV = NULL;
    ATTRVALBLOCK  *pAValBlock = NULL;
    ULONG NextModIndex = 0;
    ULONG i, j, k;
    ULONG CurrentReturnedAttr = 0;
    ULONG cAttrInfo = 0;
    BOOL AuditedAttributesWereChanged = FALSE;
    BOOL AttributeFound = FALSE;
    SAMP_AUDIT_ATTR_INFO *AttrInfo = NULL;
    PLSA_ADT_STRING_LIST StringList = NULL;
    UINT_PTR Value = 0;
    PUINT_PTR ValueOffset = NULL;
    PLSA_ADT_SID_LIST SidList = NULL;
    USHORT Length = 0;
    PUNICODE_STRING String = NULL;
    BOOLEAN fAttrNoValue = FALSE;
    ULONG AttrCount = 0;
    ATTR *Attrs = NULL;
    ATTRTYP *AttrTypes = NULL;
    ATTCACHE **AttCache = NULL;
    ULONG AttrCountReturned = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    //
    // Allocate memory for the request block, it's based on all attributes
    // so there may be some extra space but we don't need to make multiple
    // passes through the array to save a small amount of memory that will
    // be freed shortly.  We do not free this memory in this routine
    // as it is referenced by the notification and will be needed for the audit.
    // It will be freed when the thread state is cleaned up.
    //     
    AttrTypes = (ATTRTYP*)THAllocEx(pTHS, sizeof(ATTRTYP) * cModAtts );
    
    //
    // Initialize the attribute request block with metadata attribute type
    // info - only including modified attributes that we audit.
    //
    for(i = 0; i < cModAtts; i++)
    { 
        //
        // Determine if the current attribute is audited
        //   
        for (j = 0; j < cAttributeMappingTable; j++) {
                
            if (pModAtts[i] == pAttributeMappingTable[j].DsAttributeId &&
                ((SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES) & 
                 pAttributeMappingTable[j].AuditTypeMask)) {
                
                AuditedAttributesWereChanged = TRUE;
                AttrTypes[AttrCount++] = pModAtts[i]; 
            }
        }
    } 
    
    //
    // Ensure the list of audited attributes is sorted as well as the
    // list of returned values.  This way we can walk the list and notice
    // any "holes" or values not returned from the search and set
    // LsapAuditSamAttrNoValue appropriately.
    //
    qsort(AttrTypes, AttrCount, sizeof(AttrTypes[0]), CmpByAttType); 
               
    AttCache = (ATTCACHE**)THAllocEx(pTHS, AttrCount * sizeof(ATTCACHE*));
    
    //
    // Populate the ATTCACHE list from the ATTRTYP list
    //
    for (i = 0; i < AttrCount; i++) {
        
        AttCache[i] = SCGetAttById(pTHS, AttrTypes[i]);
    }
    
    qsort(AttCache, AttrCount, sizeof(AttCache[0]), CmpACByAttType);
    
    //
    // Do the DB read
    //
    // We do not free the result block memory in this routine as it is 
    // referenced by the notification and will be needed for the audit.
    // It will be freed when the thread state is cleaned up.
    // 
    dwError = DBGetMultipleAtts(
                  pTHS->pDB,
                  AttrCount,
                  AttCache,
                  NULL,       
                  NULL,
                  &AttrCountReturned,
                  &Attrs,
                  DBGETMULTIPLEATTS_fEXTERNAL,
                  0
                  );    
    
    //
    // A failure to read is likely a resource constraint as our database  
    // view is consistent with the metadata vector supplied.
    //     
    if (dwError)
    {   
        //
        // We must except because we can not audit completely.  This will role
        // back the transaction.
        //
        SampAuditFailedAbortTransaction(
                DSA_DB_EXCEPTION,
                dwError,
                DSID(FILENO, __LINE__)
                ); 
    }
    THClearErrors();
   
    //
    // Based on the type of object we need to create and initialize the correct
    // structure with all of the values changed as part of this transaction.
    // If NewValueInfo is non-NULL it is assumed a valid structure which is
    // simply updated preserving anything that isn't overwritten explicitly.
    //
    switch (ObjectType) {
        
        case SampUserObjectType:
            
            if (NULL == *NewValueInfo) {
                
                *NewValueInfo = THAllocEx(
                                pTHS,
                                sizeof(LSAP_AUDIT_USER_ATTR_VALUES)
                                );
            }   
            
            AttrInfo = SampAuditUserAttributeInfo;
            cAttrInfo = cSampAuditUserAttributeInfo;
            
            break;
            
        case SampGroupObjectType:
        case SampAliasObjectType: 
            
            if (NULL == *NewValueInfo) {

                *NewValueInfo = THAllocEx(
                                    pTHS,
                                    sizeof(LSAP_AUDIT_GROUP_ATTR_VALUES)
                                    );
            }
            
            AttrInfo = SampAuditGroupAttributeInfo;
            cAttrInfo = cSampAuditGroupAttributeInfo;
                                                           
            break;
            
        case SampDomainObjectType: 

            if (NULL == *NewValueInfo) {
                
                *NewValueInfo = THAllocEx(
                                    pTHS,
                                    sizeof(LSAP_AUDIT_DOMAIN_ATTR_VALUES)
                                    );
            }
            
            AttrInfo = SampAuditDomainAttributeInfo;
            cAttrInfo = cSampAuditDomainAttributeInfo;

            break;
            
        default:
            //
            // If the object type is unknown in producation we had best 
            // quietly fail the audit.
            //
            Assert(FALSE && 
                   "Attempted to collect audit values for unsupported object");
            goto Cleanup;
    }                                  
                                                                                 
    //
    // Process every modified attribute
    //
    for (i = 0; i < AttrCount; i++) {
        
        AttributeFound = FALSE;
        
        //
        // Lookup the attribute's offset into it's value structure.
        //
        // Note: Because the search vector and result vector are sorted this
        // lookup could be made more efficient by defining the table in 
        // sorted order by ATTRTYP and always resuming the search from the
        // next index from where the previous attribute was found.
        //
        for (j = 0; j < cAttrInfo; j++) {
            
            if (AttrTypes[i] == AttrInfo[j].AttrId) {
                
                AttributeFound = TRUE; 
                fAttrNoValue = FALSE;                         
                Value = 0;
                
                //
                // Compute a pointer to the relevant field in the structure
                //
                ValueOffset = (PUINT_PTR)((UINT_PTR)(*NewValueInfo) +
                                (AttrInfo[j].AttrFieldOffset * 
                                 sizeof(UINT_PTR)));             
                
                //
                // Attributes not returned from the search are implicitly 
                // deleted
                //
                if (CurrentReturnedAttr >= AttrCountReturned ||
                    Attrs[CurrentReturnedAttr].attrTyp != AttrTypes[i]) {
                    
                    fAttrNoValue = TRUE;   
                
                } else { 
                    
                    pAValBlock = &Attrs[CurrentReturnedAttr].AttrVal;
                    
                    //
                    // This attribute was returned, index the next returned
                    // attribute if there are any more.
                    //
                    if (CurrentReturnedAttr <= AttrCountReturned) {
                        CurrentReturnedAttr++;
                    }
                    
                    //
                    // Collect the value depending on its type
                    //
                    switch (AttrInfo[j].AttributeDataType) {
                        
                    //
                    // Simple single valued entries
                    //
                    case AuditDatatypeUlong:
                    case AuditDatatypeLargeInteger:
                    case AuditDatatypeDeltaTime:
                    case AuditDatatypeFileTime:
                    case AuditDatatypeSid:
                    case AuditDatatypeLogonHours: 
                        
                        Assert(pAValBlock->valCount == 1);
                              
                        //
                        // If this is the UAC we need to convert the 
                        // LM flags to SAM UAC bits to match the
                        // representation in PrevAccountControl
                        //
                        if (ATT_USER_ACCOUNT_CONTROL == AttrInfo[j].AttrId) {
                            
                            ULONG *UserAccountControl = THAllocEx(
                                                            pTHS,
                                                            sizeof(ULONG)
                                                            );

                            //
                            // Ignore the status, the flags came from the DB
                            // and therefore have already been validated.  
                            //
                            SampFlagsToAccountControl(
                                *((PULONG)(pAValBlock->pAVal[0].pVal)),           
                                UserAccountControl
                                );
                            
                            Value = (UINT_PTR)UserAccountControl;
                            
                        } else {
                            
                            Value = (UINT_PTR)pAValBlock->pAVal[0].pVal;    
                        }   
                        
                        break;
                        
                    //
                    // Secret data we only indicate a change, no value.
                    //
                    case AuditDatatypeSecret:
                            
                            Assert(pAValBlock->valCount == 1);
                            
                            break;
                        
                    //
                    // Single valued string requires UNICODE_STRING construct
                    //     
                    case AuditDatatypeString:               
                            
                        Assert(pAValBlock->valCount == 1);
                                
                        //
                        // Allocate the UNICODE_STRING
                        //
                        String = (PUNICODE_STRING)THAllocEx(
                                      pTHS,
                                      sizeof(UNICODE_STRING)
                                      );
                        
                        //
                        // Truncate the buffer to prevent overflow
                        //
                        if (pAValBlock->pAVal[0].valLen > MAXUSHORT) {
                            
                            Length = MAXUSHORT;    
                        } else {
                            
                            Length = (USHORT)pAValBlock->pAVal[0].valLen;     
                        }
                        
                        String->Length = Length;
                        String->MaximumLength = Length;
                        String->Buffer = (PWSTR)pAValBlock->pAVal[0].pVal;
                                        
                        Value = (UINT_PTR)String;
                        
                        break;
                        
                    //
                    // Multivalued string 
                    //
                    case AuditDatatypeMultivaluedString:
                            
                        Assert(pAValBlock->valCount >= 1);
                        
                        //
                        // Allocate and initialize the STRING_LIST
                        //
                        StringList = (PLSA_ADT_STRING_LIST)THAllocEx(
                                         pTHS,
                                         sizeof(LSA_ADT_STRING_LIST)
                                         );
                                        
                        StringList->cStrings = pAValBlock->valCount;
                        
                        //
                        // Allocate enough memory to store each string as a 
                        // UNICODE_STRING
                        //
                        StringList->Strings = (PLSA_ADT_STRING_LIST_ENTRY)THAllocEx(
                                                  pTHS,
                                                  StringList->cStrings * sizeof(LSA_ADT_STRING_LIST_ENTRY)
                                                  );
                        
                        //
                        // Initialize every UNICODE_STRING
                        //
                        for (k = 0; k < StringList->cStrings; k++) {
                            
                            //
                            // Truncate the buffer to prevent overflow
                            //
                            if (pAValBlock->pAVal[k].valLen > MAXUSHORT) {
                                
                                Length = MAXUSHORT;    
                            } else {
                                
                                Length = (USHORT)pAValBlock->pAVal[k].valLen;     
                            }

                            StringList->Strings[k].Flags = 0;
                            StringList->Strings[k].String.Length = Length;
                            StringList->Strings[k].String.MaximumLength = Length;
                            StringList->Strings[k].String.Buffer = (PWSTR)pAValBlock->pAVal[k].pVal;
                        }
                        
                        Value = (UINT_PTR)StringList;
                        
                        break;
                        
                    //
                    // Sid list
                    //
                    case AuditDatatypeSidList:
                            
                        Assert(pAValBlock->valCount >= 1);
                        
                        SidList = (PLSA_ADT_SID_LIST)THAllocEx(
                                      pTHS,
                                      sizeof(LSA_ADT_SID_LIST)
                                      );
                        
                        SidList->cSids = pAValBlock->valCount;
                        
                        //
                        // Allocate enough memory to store each PLSA_ADT_SID_LIST_ENTRY
                        //
                        SidList->Sids = (PLSA_ADT_SID_LIST_ENTRY)THAllocEx(
                                            pTHS,
                                            SidList->cSids * sizeof(LSA_ADT_SID_LIST_ENTRY)
                                            );
                        
                        //
                        // Initialize every PLSA_ADT_SID_LIST_ENTRY
                        //
                        for (k = 0; k < SidList->cSids; k++) {
                            
                            SidList->Sids[k].Flags = 0;
                            SidList->Sids[k].Sid = (PSID)pAValBlock->pAVal[k].pVal;
                        }   
                         
                        Value = (UINT_PTR)SidList;
                        
                        break;
                        
                    //
                    // Report and/or handle entropy
                    //
                    default:
                                
                        //
                        // This could happen only if an attribute category is
                        // added to the AttrInfo table but this switch isn't 
                        // updated to implement the type category.
                        //
                        Assert(FALSE && "Unknown attribute category!");
                    }                
                }
                                    
                //
                // Copy the pointer to the value into this field.
                //
                *ValueOffset = Value;  
                
                //
                // Set the value information flag, by default these are all
                // LsapAuditSamAttrUnchanged
                //
                switch (ObjectType) {
                    
                    case SampUserObjectType: 
                        //
                        // Secrets are tagged so they are never displayed.
                        //
                        if (AuditDatatypeSecret == AttrInfo[j].AttributeDataType) {
                            ((PLSAP_AUDIT_USER_ATTR_VALUES)
                                *NewValueInfo)->AttrDeltaType[AttrInfo[j].AttrFieldOffset] 
                                    = LsapAuditSamAttrSecret;
                                
                        } else {
                            ((PLSAP_AUDIT_USER_ATTR_VALUES)
                                *NewValueInfo)->AttrDeltaType[AttrInfo[j].AttrFieldOffset] =
                                    fAttrNoValue ? LsapAuditSamAttrNoValue :
                                                   LsapAuditSamAttrNewValue;        
                        }
                        
                        break;
                        
                    case SampGroupObjectType:
                    case SampAliasObjectType:
                        ((PLSAP_AUDIT_GROUP_ATTR_VALUES)
                         *NewValueInfo)->AttrDeltaType[AttrInfo[j].AttrFieldOffset] =
                            fAttrNoValue ? LsapAuditSamAttrNoValue :
                                           LsapAuditSamAttrNewValue;
                        break;
                        
                    case SampDomainObjectType:
                        ((PLSAP_AUDIT_DOMAIN_ATTR_VALUES)
                         *NewValueInfo)->AttrDeltaType[AttrInfo[j].AttrFieldOffset] =
                            fAttrNoValue ? LsapAuditSamAttrNoValue :
                                           LsapAuditSamAttrNewValue;
                        break;
                        
                    default:
                        //
                        // This will not happen as we've already bailed if the
                        // object type was unkown.
                        //
                        Assert(FALSE && "Unknown object type");
                        break;
                }     
            }
            
            //
            // Shortcircuit the search once we've processed the attribute
            //
            if (AttributeFound) {
                break;
            }
        }   
    } 
    
Cleanup:

    return;
    
}   

    
BOOLEAN
SampAuditDetermineRequiredAudits(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN ULONG cModAtts,
    IN ATTRTYP *pModAtts,
    IN ULONG cSamAttributeMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap,
    OUT ULONG *AuditTypeMask
    )
/*++

    This routine determines if any audits are required for the change defined
    by the DeltaType and meta data vector.  
    
    Bits will be set in AuditTypeMask for each required audit type.
    
    Parameters

        DeltaType - The type of database change.
        
        cModAtts - Count of metadata vector attributes.
        
        pModAtts - Attributes of the metadata vector.
        
        cSamAttributeMap - Count of entries in the mapping table.
        
        rSamAttributeMap - SAM attribute mapping table.
        
        AuditTypeMask - A bit field indicating required audit types.
        
    Return Values

        TRUE - One or more audits are required and specified in the the
               audit mask.
        
        FALSE - An audit is not required.  The audit mask is 
                SAMP_AUDIT_TYPE_NONE.
        
--*/
{   
    ULONG i, j;
    
    *AuditTypeMask = SAMP_AUDIT_TYPE_NONE; 
        
    //
    // Determine what audits to generate based intially on DeltaType
    // If other audit types are introduced/moved from loopback auditing
    // we may want to categorize this determination differently.
    //
    switch (DeltaType) {
        
        case SecurityDbNew:
        case SecurityDbChange:  
            //
            // For create and change operations the metadata is interesting to
            // determine what audits need to written.
            //
            for(i = 0; i < cModAtts; i++)
            {
                //
                // Lookup each attribute in the mapping table
                //
                for (j = 0; j < cSamAttributeMap; j++) {  
                    //
                    // For each audited attribute record the type of audit required
                    // by setting the appropriate bit in the audit type mask and
                    // incrementing the count.  Do not record the same audit type
                    // more than once, and ignore SACL based audits which are
                    // processed elsewhere.
                    //
                    if (pModAtts[i] == rSamAttributeMap[j].DsAttributeId) {
                        
                        *AuditTypeMask |= rSamAttributeMap[j].AuditTypeMask;
                    }
                }
            }    
            
            break;
            
        case SecurityDbDelete:
            
            *AuditTypeMask |= SAMP_AUDIT_TYPE_OBJ_DELETED;
            
            break;
            
            
        default:
            
            //
            // No other audit type supported at this time
            //  
            break;
    }  
    
    //
    // Object access audits are SACL based and not processed by this mechanism.
    // We should remove this bit if it was set above.
    //
    *AuditTypeMask &= (~SAMP_AUDIT_TYPE_OBJ_ACCESS);
    
    //
    // If any bits set then audits are required.  
    //
    return !(SAMP_AUDIT_TYPE_NONE == *AuditTypeMask);
    
}


NTSTATUS
SampAuditAddNotifications(
    IN DSNAME *Object,
    IN ULONG iClass,
    IN ULONG LsaClass,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN ULONG cModAtts,
    IN ATTRTYP *pModAtts
    )
/*++

    Routine Description:

       This routine adds a notification for SAM to generate an audit.
        
       If auditing is not enabled a notification is not added and this
       routine returns immediately.
       
       The audit queue may have more than one notification present during
       a transaction.  Likewise, there are rules for merging incoming 
       notifications with those already queued.  This is necessary because 
       of how loopback can make multiple calls during a creation operation 
       (an initial add of the object and subsequent modifications).  By 
       merging audit notifications from secondary change operations with 
       any previously queued create notifications the result is a single 
       properly ordered audit notification for the object's creation with 
       any and all the new value information. 
       
       SampProcessAuditNotifications is invoked when the transaction completes 
       and it processes all audit notifications by dispatching calls to the 
       auditing interface.
          
       This routine can throw exceptions and is designed to do so if 
       an audit notification should be generated but not succeed.  
       This will force a rollback of the transaction.
       
       Note: This routine assumes that the DS does not support nested 
       transactions for SAM object types.  For this reason the audit 
       notification list is kept on the THSTATE not the DBPOS and the merge
       algorithm doesn't consider the possibility that more than one object
       can be modified in the same (top level) transaction.  That is, all
       operations are considered to occur in the same top level transaction.
       
       See samaudit.c file header for more on the SAM auditing model.
       

    Parameters:
    
       Object    - DSNAME of the object associated with the audit.
       
       iClass    - Object class index into SAM object mapping table.
       
       LsaClass  - Lsa's notion of the object class type
       
       DeltaType - The type of change being made.
                                                     
       cModAtts  - Count of attributes in the metadata vector.
        
       pModAtts  - The metadata vector attribute types.
                      
    Return Value

       STATUS_SUCCESS - NewValueInfoString is valid.
       
       DSA_MEM_EXCEPTION - Thrown if resource constraints prevent a 
                           required notification.                                                     .

--*/

{
    NTSTATUS Status = ERROR_SUCCESS;
    DWORD Err;
    THSTATE *pTHS = pTHStls;
    PVOID NewValueInfo = NULL;
    SAMP_AUDIT_NOTIFICATION *AuditNotification = NULL;
    SAMP_OBJECT_TYPE SamObjectType;
    ULONG cSamAttributeMap;
    SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap;
    ULONG  GroupType = 0;
    PULONG pGroupType = &GroupType;
    ULONG  cbGroupType = 0;
    PSID   Sid = NULL;
    SAMP_AUDIT_NOTIFICATION *pElement;
    PUNICODE_STRING AccountName = NULL;
    ULONG AccountControl = 0;    
    ULONG AuditTypeMask = SAMP_AUDIT_TYPE_NONE;
    SECURITY_DB_DELTA_TYPE EffectiveDeltaType = DeltaType;
    BOOLEAN fIsAuditWithValues = FALSE;
    BOOLEAN fIsNewOrChangeAudit = FALSE;
    BOOLEAN fIsPreCreatedAudit = FALSE;
    BOOLEAN fIsChangeOp = FALSE;
    BOOLEAN fMerging = FALSE;
    
    //
    // Short circuit if auditing isn't enabled or this is a replicated change.
    //
    if (LsaClass != 0 || 
        pTHS->fDRA    || 
        !SampIsAuditingEnabled(0, STATUS_SUCCESS)) {
   
        goto Cleanup;
    }
    
    //
    // Do not audit during DC installation
    //
    if (DsaIsInstalling()) {
        goto Cleanup;
    }
    
    //
    // Collect information from the Class Mapping Table
    //
    SamObjectType = 
        ClassMappingTable[iClass].SamObjectType;
    
    cSamAttributeMap = 
        *ClassMappingTable[iClass].pcSamAttributeMap;
    
    rSamAttributeMap =
        ClassMappingTable[iClass].rSamAttributeMap;
    
    //
    // Server objects have no audits processed by this mechanism at this time.
    //
    if (SampServerObjectType == SamObjectType) {
        
        goto Cleanup;
    } 
                  
    //
    // We don't audit changes to tombstoned objects.
    //
    if (DeltaType != SecurityDbDelete && DBIsObjDeleted(pTHS->pDB)) {
        
        goto Cleanup;
    }
    
    //
    // At this point we must be dealing with a security principal
    //
    
    //
    // The DS Name must have a Sid.  The exception is if this is a new object 
    // creation, in which case, we'll read the Sid from the database.
    // No SAM object audit can be processed without a Sid.
    // 
    if (0 == Object->SidLen) {
        
        ULONG cbSid = 0;

        //
        // New object creations can legally not have a Sid in the DSName yet.
        //
        if (DeltaType == SecurityDbNew) {                   
            //
            // No nesting trx support, if present, an add should always be first. 
            //
            Assert(pTHS->pSamAuditNotificationHead == NULL);
        }
        
        //
        // Do the DB read
        //
        // We do not free the result block memory in this routine as it is 
        // referenced by the notification and will be needed for the audit.
        // It will be freed when the thread state is cleaned up.
        //   
        Err = DBGetAttVal(
                  pTHS->pDB,
                  1,
                  ATT_OBJECT_SID,
                  DBGETATTVAL_fREALLOC,
                  0,
                  &cbSid,
                  (PUCHAR*)&Sid
                  );            
                    
        if (0 != Err) { 
            //
            // If the Sid is not present we may be allowing non-security
            // principal cases into the audit notification logic.
            //
            Assert(DB_ERR_NO_VALUE != Err && 
                   "Security principals must have a Sid");    
            
            //                                                                          
            // We must except because we can not audit properly without the Sid.  
            // This will role back the transaction.
            //
            SampAuditFailedAbortTransaction(
                DSA_DB_EXCEPTION,
                Err,
                DSID(FILENO, __LINE__)
                );                               
        }         
        
    } else {
        
        //
        // Make a working copy of the Sid.  We will modify this Sid when the
        // notification is processed but it doesn't belong to us, it belongs
        // to the owner of the AddArg/ModifyArg associated with the change.
        // Additionally, we can't allocate the memory when we process the audit
        // because if that fails we have no way to roll back the transaction.
        // The other option would be to use static stack storage in the 
        // processing routine.
        //
        Sid = THAllocEx(pTHS, RtlLengthSid((PSID)&Object->Sid));
        
        RtlCopySid(RtlLengthSid((PSID)&Object->Sid), Sid, (PSID)&Object->Sid);
    }
    Assert(Sid != NULL && RtlValidSid(Sid));
    
    //
    // Determine what audit notifications we need to queue or update
    //
    if (!SampAuditDetermineRequiredAudits(
             DeltaType,
             cModAtts,
             pModAtts,
             cSamAttributeMap,
             rSamAttributeMap,
             &AuditTypeMask
             )
        ) {
        //
        // If there are none, our work is through here.
        //
        goto Cleanup;    
    }
    
    //
    // OK, there is no reason we should not queue the audit, lets now
    // obtain all necessary information to perform the audit.
    // 
    
    //
    // All object types but domain require AccountName
    //
    if (SampDomainObjectType != SamObjectType) {
            
        WCHAR *AccountNameBuffer;
        ULONG cbAccountName;

        Err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_SAM_ACCOUNT_NAME,
                          DBGETATTVAL_fREALLOC,
                          0,
                          &cbAccountName,
                          (PUCHAR *)&AccountNameBuffer
                          );
        
        if (Err == 0) {
            
            AccountName = THAllocEx(pTHS, sizeof(UNICODE_STRING));
            
            //
            // Memory Allocs in DS take Exceptions. And will cause a rollback.
            // So don't bother checking return from THAllocEx
            //           
            AccountName->Length = (USHORT)cbAccountName;
            AccountName->MaximumLength = (USHORT)cbAccountName;
            AccountName->Buffer = AccountNameBuffer;
            
        } else { 
            //
            // Non domain security principals should always have a 
            // Sam account name.  If not we may be allowing non-security
            // principal cases into the audit notification logic.
            //
            Assert(DB_ERR_NO_VALUE != Err && 
                   "Non-domain security principals must have a Sam account name");
              
            //                                                                          
            // We must except because we can not audit properly without the  
            // account name.  This will role back the transaction.
            //
            SampAuditFailedAbortTransaction(
                DSA_DB_EXCEPTION,
                Err,
                DSID(FILENO, __LINE__)
                ); 
        }
    }
    
    //
    // Obtain required information to perform audits on groups.
    //   
    if (SampGroupObjectType == SamObjectType) {   
        //
        // All group audits require the group type
        //
        Err = DBGetAttVal(
                  pTHS->pDB,
                  1,
                  ATT_GROUP_TYPE,
                  DBGETATTVAL_fCONSTANT,
                  sizeof(ULONG),
                  &cbGroupType,
                  (PUCHAR *)&pGroupType
                  );

        if (0 == Err) {
            
            Assert(sizeof(ULONG)==cbGroupType);

            //
            // If this is a resource group then increment iClass by one
            // so that we point into the alias object mapping table rather
            // than the group object mapping table
            //   
            if (GroupType & GROUP_TYPE_RESOURCE_BEHAVOIR) {
                iClass++;
            }
            
        } else {
            //
            // A group will always have a group type.
            //
            Assert(DB_ERR_NO_VALUE != Err && 
                   "Group security principals must have a group type");
                       
            //                                                                          
            // We must except because we can not audit properly without the  
            // group type.  This will role back the transaction.
            //
            SampAuditFailedAbortTransaction(
                DSA_DB_EXCEPTION,
                Err,
                DSID(FILENO, __LINE__)
                );         
        }
    }
    
    //
    // User / Computer objects require the account control
    //
    if (SampUserObjectType == SamObjectType) {
        
        BOOLEAN fReadAccountControl = FALSE;

        Err = DBGetSingleValue(
                  pTHS->pDB, 
                  ATT_USER_ACCOUNT_CONTROL,  
                  &AccountControl,
                  sizeof(AccountControl), 
                  NULL
                  );
                        
        if (0 == Err) {                
            
            Status = SampFlagsToAccountControl(
                         AccountControl,
                         &AccountControl 
                         );
            
            Assert(NT_SUCCESS(Status));
            
            if (NT_SUCCESS(Status)) {
                fReadAccountControl = TRUE;
            }
        }
        
        if (!fReadAccountControl) {
            //
            // A user/group will always have a user account control.
            //
            Assert(DB_ERR_NO_VALUE != Err && 
                   "User/Computers must have an user account control");

            //                                                                          
            // We must except because we can not audit properly without the  
            // account control.  This will role back the transaction.
            //  
            SampAuditFailedAbortTransaction(
                DSA_DB_EXCEPTION,
                Err,
                DSID(FILENO, __LINE__)
                );    
        }   
    }

#if DBG
    SampAuditValidateNotificationList();
#endif
    
    //
    // All required items that are common to all audit notification types
    // have been collected.  Now process each based on type.
    //
    
    //
    // Create and change audits that might require new value information
    //
    if ((SecurityDbNew == DeltaType || SecurityDbChange == DeltaType) &&
        ((AuditTypeMask & SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES) ||
         (AuditTypeMask & SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES))) {
         
        AuditNotification = SampAuditFindNotificationToUpdate(Sid);
          
        //
        // If we found a match prepare the notification for merging.
        //
        if (NULL != AuditNotification) {
                
            Assert(RtlEqualSid(Sid, AuditNotification->Sid));
        
            if ((SAMP_AUDIT_TYPE_PRE_CREATED & 
                 AuditNotification->AuditType) != 0) {
                //
                // Clear the pre-created bit as we will shortly
                // initialize this notification.
                //    
                AuditNotification->AuditType &= (~SAMP_AUDIT_TYPE_PRE_CREATED);
            }
            
            //
            // This flag is set if a previous audit notification is found 
            // 
            //
            fMerging = TRUE;
                    
            //
            // Ensure merging a SecurityDbChange with a previous
            // notification of type SecurityDbNew doesn't clobber
            // the change type.
            //
            if (SecurityDbNew == AuditNotification->DeltaType) {
                EffectiveDeltaType = SecurityDbNew;
            }
        }
    
        //
        // If this routine fails we'll rollback the transaction via exception.
        //
        SampAuditInitNotification(
            iClass,
            SamObjectType,
            EffectiveDeltaType,
            Sid,
            AccountName,
            AccountControl,          
            GroupType,
            NULL,
            AuditTypeMask,
            &AuditNotification
            );    
        
        //
        // We've either merged information with an existing notification or
        // created and intialized a new notification by now.
        //
        Assert(AuditNotification);
        
        if (AuditTypeMask & SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES) {
            //
            // Collect any new value information for the audit  
            //
            switch (SamObjectType) {  
                // 
                // Only these object types supported
                //
                case SampDomainObjectType:
                case SampUserObjectType:
                case SampGroupObjectType:
                case SampAliasObjectType:
                    
                    SampAuditGetChangeInfo(
                        SamObjectType,           
                        cModAtts,
                        pModAtts,
                        &AuditNotification->TypeSpecificInfo,
                        cSamAttributeMap,
                        rSamAttributeMap
                        );  
                    
                    //                                                                          
                    // The above routine will either succeed or throw an
                    // exception to roll back the transaction.
                    //
                    
                    break;
                    
                default:         
                    //
                    // No value information required for this object type
                    //
                    Assert(FALSE && "Invalid object type");
                    break; 
            }
        }
            
        if (!fMerging) {
            SampAuditQueueNotification(AuditNotification);  
        }
        
        AuditNotification = NULL;
    }
    
    //
    // Object deletion audits
    //
    if (SecurityDbDelete == DeltaType &&
        (AuditTypeMask & SAMP_AUDIT_TYPE_OBJ_DELETED)) {
        
        //
        // If this routine fails we'll rollback the transaction via exception.
        //
        SampAuditInitNotification(
            iClass,
            SamObjectType,
            DeltaType,
            Sid,
            AccountName,
            AccountControl,          
            GroupType,
            NULL,
            SAMP_AUDIT_TYPE_OBJ_DELETED,
            &AuditNotification
            );
        
        Assert(AuditNotification);
        
        SampAuditQueueNotification(AuditNotification); 
    }
    
#if DBG
    SampAuditValidateNotificationList();
#endif
        
Cleanup:    
    
    return Status;

}


ULONG
SampAddNetlogonAndLsaNotification(
    DSNAME      * Object,
    ULONG         iClass,
    ULONG         LsaClass,
    SECURITY_DB_DELTA_TYPE  DeltaType,
    BOOL          MixedModeChange,
    BOOL          RoleTransfer,
    DOMAIN_SERVER_ROLE NewRole,
    BOOL          UserAccountControlChanged
    )
/*++

    Routine Description:

       Given the object Name and the class of the object, this routine
       tries to find out if a notification is required and if so will 
       add a notification structure to pTHStls to communicate interesting
       changes to Netlogon and Lsa.

    Parameters:

        Object       -- DS Name of the Object
        iClass       -- Indicates the Object Class
        LsaClass     -- Lsa's notion of the object class type
        DeltaType    -- Indicates the Type of Change
        MixedModeChange -- Indicates the mixed mode state is changing
        RoleTransfer -- Indicates that the Role is changing
        NewRole      -- The New Server Role
        
    Return Value

        pTHS->errCode: 0 succeed
                       Non Zero, service error, DbGetAttVal failed.

--*/
{
    DWORD Err;
    HANDLE Token;
    //
    // This buffer holds both the TOKEN_USER and TOKEN_STATISTICS structures
    BYTE Buffer [ sizeof( NT4SID ) + sizeof( TOKEN_STATISTICS ) ];
    ULONG Size;
    NAMING_CONTEXT *CurrentNamingContext;
    COMMARG CommArg;
    ATTRBLOCK *pObjAttrBlock=NULL;
    BOOLEAN AddLsaNotification = FALSE;
    THSTATE   *pTHS = pTHStls;

    ULONG  GroupType = 0;
    PULONG pGroupType = &GroupType;
    ULONG  cbGroupType = 0;
    

    if (LsaClass == 0)
    {
        BOOL fNotifySam = TRUE;
        PSID  pSid = NULL;
        ULONG cbSid = 0;
        DWORD  dwError;

        //
        // SAM notifications ......
        //

        //
        // Don't bother if we are installing
        //

        if (DsaIsInstalling())
        {
            return(0);
        }

        //
        // Don't bother if we are not running in lsa
        //

        if (!gfRunningInsideLsa)
        {
            return(0);
        }

        //
        // If it is the SAM server object, then no notification is required,
        // just return
        //

        if (SampServerObjectType==ClassMappingTable[iClass].SamObjectType)
        {
            return(0);
        }

        //
        // Ignore domains without a SID. These are NDNC's
        //
        if ( (SampDomainObjectType==ClassMappingTable[iClass].SamObjectType)
          && (0 == Object->SidLen)) {

            return(0);
        }

        //
        // Obtain the SID of the object
        //

        if (0!=Object->SidLen)
        {
            pSid = &Object->Sid;
            cbSid = Object->SidLen;
        }
        else
        {
            
            dwError = DBGetAttVal(
                        pTHS->pDB,
                        1,
                        ATT_OBJECT_SID,
                        DBGETATTVAL_fREALLOC,
                        0,
                        &cbSid,
                        (PUCHAR *)&pSid
                        );

            if (0!=dwError)
            {
                //
                // Its a security principal , better have a SID
                //
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_MISSING_REQUIRED_ATT,
                              dwError);

               return pTHS->errCode;
            }

            Assert(cbSid <=sizeof(NT4SID));
        }

        //
        // This is a SAM class. Apply a sequence of tests to figure out whether
        // we need to notify SAM.
        //
        if ((!RoleTransfer ) &&(!SampNetLogonNotificationRequired(
                                        pSid,
                                        ClassMappingTable[iClass].SamObjectType)))
        {
            //
            // if Sam says no and it is not a role transfer bail
            //

            fNotifySam = FALSE;
        }



        //
        // If the change is not a delete, then check if the object is deleted
        // Avoid useless notifications on Tombstones.
        //

        if ((fNotifySam) && (DeltaType != SecurityDbDelete)
                && (DBIsObjDeleted(pTHS->pDB)))
        {
             fNotifySam=FALSE;
        }

        //
        // Groups require security enabled-ness for notifications.
        //

        if ((fNotifySam) && (SampGroupObjectType==ClassMappingTable[iClass].SamObjectType))
        {

            //
            // if the previous test succeeded and it is a group object
            // then check if it is a security enabled group
            //

            dwError = DBGetAttVal(pTHS->pDB,
                                    1,
                                    ATT_GROUP_TYPE,
                                    DBGETATTVAL_fCONSTANT,
                                    sizeof(ULONG),
                                    &cbGroupType,
                                    (PUCHAR *)&pGroupType
                                    );

            if (0==dwError)
            {
                // 
                // no error 
                // 
                Assert(sizeof(ULONG)==cbGroupType);

                //
                // If this is a resource group then increment iClass by one
                // so that we point into the alias object mapping table rather
                // than the group object mapping table
                //

                if (GroupType & GROUP_TYPE_RESOURCE_BEHAVOIR)
                {
                    iClass++;
                }
                fNotifySam = TRUE;
            }
            else
            {
                //
                // handle error. In most cases, DBGetAttVal failed  
                // because of resource shortage. so use 
                // error_not_enough_memory as the error. 
                // 

                SetSvcError(SV_PROBLEM_BUSY, 
                            ERROR_NOT_ENOUGH_MEMORY
                            );

                return pTHS->errCode;
            }
        }


        if (fNotifySam)
        {
            //
            // Notification is Required
            //

            SAMP_NOTIFICATION_INFORMATION * pNewSamNotification = NULL;
            
            //
            // Compose a New Notification Structure
            //

            pNewSamNotification = THAllocEx(pTHS, sizeof(SAMP_NOTIFICATION_INFORMATION));
            
            //
            // Memory Allocs in DS take Exceptions. And will cause a rollback.
            // So don't bother checking return from THAllocEx
            //   
            
            RtlCopyMemory(&pNewSamNotification->Sid, pSid, cbSid);
            pNewSamNotification->DeltaType = DeltaType;
            pNewSamNotification->iClass = iClass;
            pNewSamNotification->ObjectType = DsDbObjectSam;
            pNewSamNotification->RoleTransfer = RoleTransfer;
            pNewSamNotification->NewRole      = NewRole;
            pNewSamNotification->MixedModeChange = MixedModeChange;
            pNewSamNotification->GroupType = GroupType;
            pNewSamNotification->UserAccountControlChange = UserAccountControlChanged;
            
            if (SampDomainObjectType!=ClassMappingTable[iClass].SamObjectType)
            {
                //
                // If its not a domain object that has changed, we will supply the
                // SAM account Name. Even though Netlogon can live without the account
                // Name there are a lot of 3d party notification packages, synchronizing
                // the SAM database with security systems in other foreign operating systems.
                // It is quite possible that they may rely on the account Name, hence we
                // should try to supply this.
                //

                DWORD dwError=0;
                WCHAR *AccountNameBuffer;
                ULONG cbAccountName;

                dwError = DBGetAttVal(pTHS->pDB,
                                        1,
                                        ATT_SAM_ACCOUNT_NAME,
                                        DBGETATTVAL_fREALLOC,
                                        0,
                                        &cbAccountName,
                                        (PUCHAR *)&AccountNameBuffer
                                        );
                if (dwError==0)
                {
                    PUNICODE_STRING AccountName;

                    AccountName = THAllocEx(pTHS, sizeof(UNICODE_STRING));
                    
                    //
                    // Memory Allocs in DS take Exceptions. And will cause a rollback.
                    // So don't bother checking return from THAllocEx
                    //                 

                    AccountName->Length = (USHORT) cbAccountName;
                    AccountName->MaximumLength = (USHORT) cbAccountName;
                    AccountName->Buffer = AccountNameBuffer;

                    //
                    // Set the account name in the notification structure
                    //

                    pNewSamNotification->AccountName = AccountName;
                }
                else
                {
                    //
                    // handle error. In most cases, DBGetAttVal failed  
                    // because of resource shortage. so use 
                    // error_not_enough_memory as the error. 
                    // 
                    
                    SetSvcError(SV_PROBLEM_BUSY, 
                                ERROR_NOT_ENOUGH_MEMORY
                                );

                    return pTHS->errCode;
                }
            }

            //
            // For User Accounts, CliffV states that we also need the User account Control
            // Therefore Grab it from the database. Soldier on if we could not read the
            // property from the database
            //

            if (SampUserObjectType==ClassMappingTable[iClass].SamObjectType)
            {
                ULONG AccountControl = 0;

                if(0==DBGetSingleValue(pTHS->pDB, ATT_USER_ACCOUNT_CONTROL, &AccountControl,
                                sizeof(AccountControl), NULL))
                {
                     NTSTATUS NtStatus = SampFlagsToAccountControl(
                                                               AccountControl,
                                                              &AccountControl );
                     Assert( NT_SUCCESS( NtStatus ) );
                     if ( NT_SUCCESS( NtStatus ) )
                     {
                         pNewSamNotification->AccountControl = AccountControl;
                     }
                }
                else
                {
                    // 
                    // handle error. In most cases, DBGetSingleValue failed  
                    // because of resource shortage. so use 
                    // error_not_enough_memory as the error. 
                    // 
                    
                    SetSvcError(SV_PROBLEM_BUSY, 
                                ERROR_NOT_ENOUGH_MEMORY
                                );

                    return pTHS->errCode;
                }
            }
            
            //
            // Add this notification to the End of the List. I do not think it is advisable
            // to add it in the front, because this will reverse the order of notifications
            // to netlogon, which may cause problems. Pointer to both the Head as well as the
            // tail of the list is kept which allows easy addition to the end.
            //

            if (pTHS->pSamNotificationTail)
            {
                pTHS->pSamNotificationTail->Next = pNewSamNotification;
            }

            pTHS->pSamNotificationTail = pNewSamNotification;

            if (NULL==pTHS->pSamNotificationHead)
            {
                pTHS->pSamNotificationHead = pNewSamNotification;
            }
        }

    } else if ( LsaClass  ) {

        //
        // Do Lsa notification
        //



        if (Object->NameLen>0)
        {
            //
            // Make sure that we have a name within the current authoritative naming context
            //
            InitCommarg( &CommArg );

            /* ...and override some of them */
            CommArg.Svccntl.DerefAliasFlag          = DA_NEVER;
            CommArg.Svccntl.localScope              = TRUE;
            CommArg.Svccntl.SecurityDescriptorFlags = 0;
            CommArg.Svccntl.dontUseCopy             = FALSE;
            CommArg.ulSizeLimit                     = 0x20000;


            Err = DSNameToBlockName(pTHS,
                                    Object,
                                    &pObjAttrBlock,
                                    DN2BN_LOWER_CASE);
            if (Err) {
                //
                // set Error, so that the error code will be returned
                // when we finish
                // 
                SetNamError(NA_PROBLEM_BAD_NAME,
                            Object,
                            DIRERR_BAD_NAME_SYNTAX);

            } else {

                CurrentNamingContext = FindNamingContext(pObjAttrBlock, &CommArg);

                if ( CurrentNamingContext ) {

                    if( NameMatched( CurrentNamingContext, gAnchor.pDomainDN ) ||
                        ( gAnchor.pConfigDN != NULL && NameMatched( CurrentNamingContext, gAnchor.pConfigDN ) ) ) {

                        AddLsaNotification = TRUE;
                    }
                }
            }
        }
        else if (Object->SidLen>0)
        {

            //
            // The object has a SID but no name. This should happen only for user objects
            // currently. User objects have an account SID
            //

            Assert(CLASS_USER==LsaClass);

            //
            // Decrement the subauthority count to get the domain sid
            //

            (*RtlSubAuthorityCountSid(&Object->Sid))--;

            //
            // If the SID now matches the domain sid add to the notification
            //

            if (RtlEqualSid(&gAnchor.pDomainDN->Sid,&Object->Sid))
            {
                AddLsaNotification = TRUE;
            }

            //
            // Increment the subauthority to get back the account SID
            //

            (*RtlSubAuthorityCountSid(&Object->Sid))++;

        }




        if( AddLsaNotification ) {

            SAMP_NOTIFICATION_INFORMATION * pNewSamNotification = NULL;

            //
            // Compose a New Notification Structure
            //

            pNewSamNotification = THAllocEx(pTHS, sizeof(SAMP_NOTIFICATION_INFORMATION));

            //
            // Memory Allocs in DS take Exceptions. And will cause a rollback.
            // So don't bother checking return from THAllocEx
            //

            pNewSamNotification->Sid = Object->Sid;
            pNewSamNotification->DeltaType = DeltaType;
            pNewSamNotification->iClass = LsaClass;
            pNewSamNotification->ObjectType = DsDbObjectLsa;

            pNewSamNotification->Object = THAllocEx(pTHS,  Object->structLen );



            // Memory Allocs in DS take Exceptions. And will cause a rollback.
            // So don't bother checking return from THAllocEx
            //
            RtlCopyMemory( pNewSamNotification->Object,
                           Object,
                           DSNameSizeFromLen( Object-> NameLen ) );

            //
            // Now, if possible, get the sid of the current user if its an object we need to audit...
            //
            switch( LsaClass ) {

            case CLASS_TRUSTED_DOMAIN:
            case CLASS_SECRET:
            case CLASS_DOMAIN_POLICY:
                if ( !pTHS->fDRA ) {

                    Err = ImpersonateAnyClient();

                    if ( Err == 0 ) {

                        //
                        // Open the client token
                        //
                        if (!OpenThreadToken( GetCurrentThread(),
                                              TOKEN_QUERY,
                                              TRUE,
                                              &Token)) {

                            Err = GetLastError();

                        } else {

                            Size = sizeof( Buffer );
                            if ( !GetTokenInformation( Token,
                                                       TokenUser,
                                                       Buffer,
                                                       Size,
                                                       &Size ) ) {

                                Err = GetLastError();

                                Assert( Err != ERROR_INSUFFICIENT_BUFFER );

                            } else {

                                Assert( Size <= sizeof ( Buffer ) );

                                RtlCopyMemory( ( PBYTE )&pNewSamNotification->UserSid,
                                               ( ( PTOKEN_USER )Buffer)->User.Sid,
                                               RtlLengthSid( ( ( PTOKEN_USER )Buffer)->User.Sid ) );

                                Size = sizeof( Buffer );
                                if ( !GetTokenInformation( Token,
                                                           TokenStatistics,
                                                           Buffer,
                                                           Size,
                                                           &Size ) ) {

                                    Err = GetLastError();

                                    Assert( Err != ERROR_INSUFFICIENT_BUFFER );

                                } else {

                                    Assert( Size <= sizeof ( Buffer ) );

                                    pNewSamNotification->UserAuthenticationId =
                                                            ( ( PTOKEN_STATISTICS )Buffer )->AuthenticationId;

                                }
                            }

                            CloseHandle( Token );
                        }


                        UnImpersonateAnyClient();
                    }
                }
                break;

            default:
                break;

            }

            //
            // Add this notification to the End of the List. I do not think it is advisable
            // to add it in the front, because this will reverse the order of notifications
            // to netlogon, which may cause problems. Pointer to both the Head as well as the
            // tail of the list is kept which allows easy addition to the end.
            //

            if (pTHS->pSamNotificationTail)
            {
                pTHS->pSamNotificationTail->Next = pNewSamNotification;
            }

            pTHS->pSamNotificationTail = pNewSamNotification;

            if (NULL==pTHS->pSamNotificationHead)
            {
                pTHS->pSamNotificationHead = pNewSamNotification;
            }


        }
    }


    return pTHS->errCode;

}


ULONG
SampQueueNotifications(                
    DSNAME      * Object,
    ULONG         iClass,
    ULONG         LsaClass,
    SECURITY_DB_DELTA_TYPE  DeltaType,
    BOOL          MixedModeChange,
    BOOL          RoleTransfer,
    DOMAIN_SERVER_ROLE NewRole,
    ULONG         cModAtts,
    ATTRTYP      *pModAtts
    )
/*++

    Routine Description:

       Given the object Name and the class of the object and the notifiction type, this routine
       tries to find out if a notification is required and if so, will add a notification structure
       to pTHStls

    Parameters:

        Object       -- DS Name of the Object
        iClass       -- Indicates the Object Class
        LsaClass     -- Lsa's notion of the object class type
        DeltaType    -- Indicates the Type of Change
        MixedModeChange -- Indicates the mixed mode state is changing
        RoleTransfer -- Indicates that the Role is changing
        NewRole      -- The New Server Role
    Return Value

        pTHS->errCode: 0 succeed
                       Non Zero, service error, DbGetAttVal failed.

--*/
{
    THSTATE   * pTHS = pTHStls;
    BOOL      UserAccountControlChanged = FALSE;
    ULONG     i=0;

    //
    // If we're not part of LSA, don't bother
    //
    if (!gfRunningInsideLsa)
        return 0; 

    //
    // Ignore domains without a SID. These are NDNC's
    //
    if ( (LsaClass == 0)
      && (SampDomainObjectType==ClassMappingTable[iClass].SamObjectType)
      && (0 == Object->SidLen)) {

        return(0);
    }

    //
    // Queue a notification for generating an audit on transasction commit
    //
    SampAuditAddNotifications(
        Object,             
        iClass,             
        LsaClass,         
        DeltaType,
        cModAtts,
        pModAtts
        ); 
    

    //
    // Check if user account control changed as part of this transaction
    //

    for (i=0;i<cModAtts;i++)
    {
        if (ATT_USER_ACCOUNT_CONTROL==pModAtts[i])
        {
            UserAccountControlChanged = TRUE;
            break;
        }
    }
    
    //
    // Queue a notification for the Netlogon replicator and Lsa if needed.
    // The error code is ignored, pTHS->errCode will be set.
    //
    SampAddNetlogonAndLsaNotification(
        Object,             
        iClass,             
        LsaClass,           
        DeltaType,
        MixedModeChange,    
        RoleTransfer,       
        NewRole,
        UserAccountControlChanged
        );

    return pTHS->errCode;
    
}


BOOLEAN IsEqualNotificationNode(
            IN SAMP_NOTIFICATION_INFORMATION *LeadingNode,
            IN SAMP_NOTIFICATION_INFORMATION *TrailingNode
            )
/*++

    Given 2 notification nodes, this routine checks to see
    if they represent changes to the same object

    Parameters

        LeadingNode, TailingNode -- two notification nodes in the notification
        list. LeadingNode is the Node that is ahead in the notification list, and
        TrailingNode is the one that is behind in the notification list.

    Return Values

        TRUE -- Yes they are equal
        FALSE -- No they are not
--*/
{
    //
    // Compare if the 2 nodes are the same. Never compare the same for
    // role transfer or mixed mode change as we do not want to collapse
    // multiple of these into a single notification --> every one of these
    // are different. Further perform the optimization that an Add followed by a Modify
    // is simply equal to an Add ie If Leading node had an add operation, and tailing node
    // had a modify operation, then tailing node need not be used for the notification.
    //
    if ((LeadingNode->iClass == TrailingNode->iClass)
        && ( LeadingNode->ObjectType == TrailingNode->ObjectType)
        && (( LeadingNode->DeltaType == TrailingNode->DeltaType) || 
            ((LeadingNode->DeltaType == SecurityDbNew ) 
            &&  (TrailingNode->DeltaType ==SecurityDbChange)))
        && ( RtlEqualSid(&LeadingNode->Sid,&TrailingNode->Sid))
        && ( LeadingNode->UserAuthenticationId.LowPart==TrailingNode->UserAuthenticationId.LowPart)
        && ( LeadingNode->UserAuthenticationId.HighPart==TrailingNode->UserAuthenticationId.HighPart)
        &&  (!LeadingNode->RoleTransfer ) && (!TrailingNode->RoleTransfer)
        && (!LeadingNode->MixedModeChange) && (!TrailingNode->MixedModeChange)
        && (!LeadingNode->ObjectType==DsDbObjectLsa) 
        && (!TrailingNode->ObjectType==DsDbObjectLsa))
    {
        return(TRUE);
    }

    return(FALSE);
}


VOID
SampProcessAuditNotifications(
    SAMP_AUDIT_NOTIFICATION *NotificationList
    )
/*++

    This Routine Walks through the Linked list of notification structures, 
    writing the any audit events queued.

    Parameters

       NotificationList    List of Notifications that must be given to SAM / LSA

    Return Values

        None -- Void Function

--*/
{   
    THSTATE *pTHS = pTHStls;
    
    for (; NotificationList; NotificationList = NotificationList->Next)
    {
        //
        // Pre-created notifications can be queued but never fully initialized.
        // This happens when the sum of all changes amounts to no delta to
        // the object and the DS optimizes out the writes.  Such orphaned
        // notifications are discarded here.
        //
        if (NotificationList->AuditType & SAMP_AUDIT_TYPE_PRE_CREATED) {
            continue;
        }
        
        SampNotifyAuditChange(
            NotificationList->Sid,
            NotificationList->DeltaType,
            ClassMappingTable[NotificationList->iClass].SamObjectType,
            NotificationList->AccountName,
            NotificationList->AccountControl,
            NotificationList->GroupType,
            pTHS->CallerType,
            NotificationList->Privileges,
            NotificationList->AuditType,
            NotificationList->TypeSpecificInfo
            );
    }
}


VOID
SampProcessReplicatedInChanges(
    SAMP_NOTIFICATION_INFORMATION * NotificationList
    )
/*++

    This Routine Walks through the Linked list of notification structures, issuing a
    Notification to SAM / Netlogon.


    Parameters

       NotificationList    List of Notifications that must be given to SAM / LSA

    Return Values

        None -- Void Function

--*/
{
    THSTATE *pTHS = pTHStls;
    SAMP_NOTIFICATION_INFORMATION * OriginalList = NULL;
    

    for (OriginalList=NotificationList;NotificationList;NotificationList=NotificationList->Next)
    {
        SAMP_NOTIFICATION_INFORMATION * TmpList = NULL;
        BOOLEAN                         fNotifiedBefore = FALSE;

        //
        // Make a pass over the list to see if the item has been notified  
        //

        for (TmpList = OriginalList;((TmpList!=NULL) && (TmpList!=NotificationList));TmpList = TmpList->Next)
        {
            if (IsEqualNotificationNode(TmpList,NotificationList))
            {
                fNotifiedBefore = TRUE;
                break;
            }
        }

        //
        // If notified before then skip to next item
        //

        if (fNotifiedBefore)
        {
            continue;
        }

        if ( NotificationList->ObjectType == DsDbObjectSam ) {
                    
            SampNotifyReplicatedInChange(
                (PSID) &(NotificationList->Sid),
                pTHS->fSamWriteLockHeld?TRUE:FALSE,
                NotificationList->DeltaType,
                ClassMappingTable[NotificationList->iClass].SamObjectType,
                NotificationList->AccountName,
                NotificationList->AccountControl,
                NotificationList->GroupType,
                pTHS->CallerType,
                NotificationList->MixedModeChange,
                NotificationList->UserAccountControlChange
                );
            
            //
            // If the Role is changing , then give a role transfer notification
            //          
            
            if (NotificationList->RoleTransfer)
            {
                THSTATE * pTHSSaved;

                //
                // Always THSave and Restore before SamINotifyRoleChange.
                // This is because LSA calls are involved, which might
                // potentially write into the database.
                //

                pTHSSaved = THSave();

                SamINotifyRoleChange(
                    &(NotificationList->Sid),
                    NotificationList->NewRole
                    );

                THRestore(pTHSSaved);

            }
            
        } else {

            if ( pfLsaNotify ) {

                ( *pfLsaNotify )( NotificationList->iClass,
                                  NotificationList->Object,
                                  NotificationList->DeltaType,
                                  &NotificationList->UserSid,
                                  NotificationList->UserAuthenticationId,
                                  (BOOLEAN) pTHS->fDRA, // Used to distinguish between
                                             // a replicated in and originating
                                             // change
                                  (BOOLEAN) (pTHS->CallerType == CALLERTYPE_LSA)  // Used to distinguish between
                                             // LSA and DS/LDAP-originating changes
                                  );
            }
        }
    }
}

VOID
SampNotifyLsaOfXrefChange(
    IN DSNAME * pObject
    )
/*++

  Routine Description
  
   Calls the LSA change notification routine to notify the LSA of a cross
   ref change. This is called everytime the core updates its own cross ref
   list. Cross ref changes are important for LSA/Security to maintain the
   correct enterprise tree picture and also for knowing about new domains
   as they come and leave

  Parameters

    pObject - DSNAME of the Xref Object

  Return Values 

   None 
--*/
{
   LUID id={0,0};

   if (pfLsaNotify)
   {
       ( *pfLsaNotify )(
            (ULONG) CLASS_CROSS_REF,
            pObject,
            SecurityDbChange,
            NULL,
            id,
            (BOOLEAN) TRUE,
            (BOOLEAN) FALSE
            );
   }
}

   
   
NTSTATUS
SampGetClassAttribute(
    IN ULONG    ClassId,
    IN ULONG    AttributeId,
    IN OUT PULONG  attLen,
    OUT PVOID   pattVal
    )
/*++

    This routine gets the requested property of the class schema object, for the Class
    specified in ClassId.


    Parameters:

        ClassId  The ClassId of the class that we are interseted in
        AttributeId The attribute of the class schema object that we want
        attLen       The length of the attribute value is present in here .
                     Caller allocates the buffer in pAttVal and passes its length
                     in attLen. If the buffer required is less than the buffer supplied
                     then the data is returned in pattVal. Else  the required size is
                     returned in attLen.
        pattVal      The value of the attribute is returned in here.


    Secuirty Descriptors returned by this routine are always in a format that can be used
    by the RTL routines.

    Return Values

        STATUS_SUCCESS
        STATUS_NOT_FOUND
        STATUS_BUFFER_TOO_SMALL
--*/
{
    THSTATE     *pTHS=pTHStls;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    CLASSCACHE  *pClassCache;

    Assert(NULL!=pTHS);


    if (pClassCache = SCGetClassById(pTHS, ClassId))
    {
        //
        // Found the Class cache.
        //

        switch(AttributeId)
        {
        case ATT_SCHEMA_ID_GUID:
                if (*attLen >= sizeof(GUID))
                {
                    RtlCopyMemory(pattVal,&(pClassCache->propGuid),sizeof(GUID));
                    *attLen = sizeof(GUID);
                }
                else
                {
                    *attLen = sizeof(GUID);
                    NtStatus = STATUS_BUFFER_TOO_SMALL;
                }
                break;
                case ATT_DEFAULT_SECURITY_DESCRIPTOR:
                    if (*attLen >= pClassCache->SDLen)
                {
                    UCHAR   * NtSecurityDescriptorStart;
                    ULONG     NtSecurityDescriptorLength;

                    Assert(pClassCache->SDLen>0);

                    //
                    // Security descriptors in the class cache have a DWORD prepended to them,
                    // So take care of that in order to return a SD usable by NT RTL routines.
                    //

                    NtSecurityDescriptorStart = (PUCHAR)pClassCache->pSD;
                    NtSecurityDescriptorLength = pClassCache->SDLen;
                    RtlCopyMemory(pattVal,
                                  NtSecurityDescriptorStart,
                                  NtSecurityDescriptorLength);
                    *attLen = pClassCache->SDLen;
                }
                else
                {
                    *attLen = pClassCache->SDLen;
                    NtStatus = STATUS_BUFFER_TOO_SMALL;
                }
                break;
        default:
                        //
                        // We do not as yet have support for these other properties
                        //
                        Assert(FALSE);
            NtStatus = STATUS_NOT_FOUND;
            break;
        }


    }
    else
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }

    return NtStatus;
}

VOID
SampGetLoopbackObjectClassId(
    PULONG ClassId
    )
/*++

    For a Loopback Add Call, gets the object class of the object to be
    added.

    ClassId -- The Object Class is returned in this Parameter

--*/
{
    SAMP_LOOPBACK_ARG  *pSamLoopback;
    ULONG               i;
    DSNAME              *LoopbackObject;

    Assert(SampExistsDsTransaction());
    Assert(SampExistsDsLoopback(&LoopbackObject));

    pSamLoopback = pTHStls->pSamLoopback;

    Assert(pSamLoopback->type==LoopbackAdd);

    *ClassId = pSamLoopback->MostSpecificClass;

}
//
// SAM attributes that SAM prefers to be unique
//
// Attributes in this table cannot be modified by out-of-process callers.
// Note that this only applies to classes that are not known to SAM.
//
// ATT_SAM_ACCOUNT_NAME - Sam needs to enforce uniqueness
// ATT_OBJECT_SID - ditto
// ATT_IS_CRITICAL_SYSTEM_OBJECT - Controls what objects get replicated at
// dcpromo-time. Only internal callers can set this.
// Encrypted attributes such as SUPPLEMENTAL_CREDENTIALS, UNICODE_PWD etc
// can be written only by the system. Else a denial of service attack can
// take place because a client can give us potentially very large data to
// encrypt
//
ULONG   SamUniqueAttributes[] =
{
        ATT_USER_PASSWORD,
        ATT_SAM_ACCOUNT_NAME,
        ATT_OBJECT_SID,
        ATT_IS_CRITICAL_SYSTEM_OBJECT,
        ATT_SAM_ACCOUNT_TYPE,
        ATT_SUPPLEMENTAL_CREDENTIALS,
        ATT_UNICODE_PWD,
        ATT_NT_PWD_HISTORY,
        ATT_LM_PWD_HISTORY

};

BOOLEAN
SampSamUniqueAttributeAdded(
        ADDARG * pAddarg
        )
/*++

        This Routine Checks, wether Attributes like SAM_ACCOUNT_NAME, OBJECT_SID
        etc which should be unique are present in the given addarg

        Parameters

                pAddarg -- Add arg to be checked

    Return Values

                TRUE   -- If Unique Attribute is referenced
                FALSE  -- If Not
--*/
{
        ULONG i,j;

        for (i=0;i<pAddarg->AttrBlock.attrCount;i++)
        {
                for (j=0;j<ARRAY_COUNT(SamUniqueAttributes);j++)
                {
                        if (pAddarg->AttrBlock.pAttr[i].attrTyp == SamUniqueAttributes[j])
                                return TRUE;
                }
        }

        return FALSE;
}

BOOLEAN
SampSamUniqueAttributeModified(
        MODIFYARG * pModifyArg
        )
/*++

        This Routine Checks, wether Attributes like SAM_ACCOUNT_NAME, OBJECT_SID
        etc which should be unique are present in the given modifyarg

        Parameters

                pModifyArg -- Modify arg to be checked

    Return Values

                TRUE   -- If Unique Attribute is referenced
                FALSE  -- If Not
--*/
{
    ULONG j;
    ATTRMODLIST *Mod;

    for (Mod=&(pModifyArg->FirstMod); Mod!=NULL;Mod=Mod->pNextMod)
    {
        for (j=0;j<ARRAY_COUNT(SamUniqueAttributes);j++)
        {
            if (Mod->AttrInf.attrTyp == SamUniqueAttributes[j])
                return TRUE;
        }
    }

    return FALSE;
}

VOID
SampGetEnterpriseSidList(
   IN   PULONG pcSids,
   IN OPTIONAL PSID * rgSids
   )
/*++

    Routine Description

        This Routine Walks through the anchor data structure and
        obtains the Sids of all the domains in the enterprise
        Caller allocates the memory for the array of pointers in
        rgSids. The Pointer's to the Sids are in DS Memory space.
        The delayed memory free model is used, to provide safety
        if the gAnchor structure is modified. The caller should not
        use the pointers returned in rgSids for a long time, but
        should rather use it immediately and then forget the list.

    Parameters

        pcSids -- Count  of Sids
        rgSids --  Pointer to a Buffer that holds an array of pointers to Sids.


    Return Values

        STATUS_SUCCESS
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    CROSS_REF_LIST * pCRL;


    *pcSids=0;
    for (pCRL=gAnchor.pCRL;pCRL!=NULL;pCRL=pCRL->pNextCR)
    {
        if (pCRL->CR.pNC->SidLen>0)
        {
            if (ARGUMENT_PRESENT(rgSids))
            {
                rgSids[*pcSids] = &(pCRL->CR.pNC->Sid);
            }
            (*pcSids)++;
        }
    }


}

NTSTATUS
MatchCrossRefBySid(
   IN PSID           SidToMatch,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   )
/*++

    Routine Description

       This routine walks the gAnchor matching the SID specified to 
       that of any domain in that we may know about in the Xref list


    Parameters

       SidToMatch  The SID to match
       XrefDsName  The DSNAME of the Xref that matched 
       XrefNameLen The length of the Xref DSNAME that matched

    Return Values
       STATUS_SUCCESS
       STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    CROSS_REF_LIST * pCRL;


    for (pCRL=gAnchor.pCRL;pCRL!=NULL;pCRL=pCRL->pNextCR)
    {
        if ((pCRL->CR.pNC->SidLen>0) 
            && (RtlEqualSid(SidToMatch,(PSID)&pCRL->CR.pNC->Sid)))
        {
            ULONG LengthRequired = pCRL->CR.pObj->structLen;

       
            NtStatus = STATUS_SUCCESS;    

            if (ARGUMENT_PRESENT(XrefDsName))
            {
                if (*XrefNameLen>=LengthRequired)
                {
                    RtlCopyMemory(XrefDsName,pCRL->CR.pObj,LengthRequired);
                }
                else
                {
                    NtStatus = STATUS_BUFFER_TOO_SMALL;
                }
            }
            *XrefNameLen = LengthRequired;
            break;

        
         }
     }


     return(NtStatus);

}


   
   

VOID
SampSetSam(
    IN BOOLEAN fSAM
    )
/*++
   This Routine is used to Indicate "SAM" in
   thread state. This is called by SAM, when it
   has to create a thread state but not begin a
   transaction

--*/
{
    THSTATE *pTHS=pTHStls;

    Assert(NULL!=pTHS);
    pTHS->fSAM = fSAM;
    pTHS->fSamDoCommit = fSAM;
}




VOID
SampSignalStart(
        VOID
        )
/*++
    This Routine is used by SAM to signal to the core that it is finished
    initializing and that taks which can conflict with SAM initialization may
    now be started.
--*/
{
    SetEvent(hevSDPropagatorStart);
}







NTSTATUS
InitializeLsaNotificationCallback(
    VOID
    )
/*++

        This routine loads the lsasrv.dll and initializes a global function pointer used
    to do Lsa object change notificaiton

        Parameters

                VOID

    Return Values

                STATUS_SUCCESS -- Success
        STATUS_DLL_NOT_FOUND -- The lsasrv.dll could not be loaded
        STATUS_PROCEDURE_NOT_FOUND -- The notification producre entry point not found in
                                      the lsasrv.dll
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Load the Lsa
    LsaDllHandle = LoadLibraryA( "lsasrv" );

    if ( LsaDllHandle == NULL ) {

        Status = STATUS_DLL_NOT_FOUND;

    } else {

        pfLsaNotify = ( pfLsaIDsNotifiedObjectChange )
                            GetProcAddress( LsaDllHandle, "LsaIDsNotifiedObjectChange" );

        if ( !pfLsaNotify ) {

            Status = STATUS_PROCEDURE_NOT_FOUND;
        }
    }


    return( Status );
}


NTSTATUS
UnInitializeLsaNotificationCallback(
    VOID
    )
/*++

        This routine unloads the lsasrv.dll

        Parameters

                VOID

    Return Values

                STATUS_SUCCESS -- Success
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // NULL out the function pointer, and unload the dll
    //
    pfLsaNotify = NULL;
    if (NULL!=LsaDllHandle)
        FreeLibrary(LsaDllHandle);
    LsaDllHandle = NULL;

    return( Status );
}



BOOL
SampIsClassIdLsaClassId(
    THSTATE *pTHS,
    IN ULONG Class,
    IN ULONG cModAtts,
    IN ATTRTYP *pModAtts,
    OUT PULONG LsaClass
    )
/*++

        This routine determines if the specified object class is one that corresponds
    to an object Lsa cares about

        Parameters

                Class -- The class id of the object in question.
        LsaClass -- 0 if not an Lsa object, non-zero otherwise.

    Return Values

                FALSE -- Not an LSA object
        TRUE -- Lsa object
--*/
{
    BOOL Return = FALSE;
    unsigned i;

    *LsaClass = 0;

    switch ( Class) {
    case CLASS_CROSS_REF:
    case CLASS_TRUSTED_DOMAIN:
    case CLASS_SECRET:

        if( !pTHS->fLsa && !pTHS->fSAM) {
           *LsaClass = Class;
            Return = TRUE;
        }
        break;
    }

    return( Return );
}


BOOL
SampIsClassIdAllowedByLsa(
    THSTATE  *pTHS,
    IN ULONG Class
    )
/*++
Routine Description:

    This routine determine if the specific object Class is OK for manipulating 
    according to LSA

Arguments:

    Class - object class ID

Return Values:

    TRUE - This object is OK for manipulating through LDAP
    
    FALSE - This object can't be manipulated by LDAP directly. So only 
            in-process client (such as LSA) can add/del/modify. 

--*/
{
    BOOL Result = TRUE;

    if (pTHS->fDSA || pTHS->fDRA || pTHS->fLsa ||
        (pTHS->CallerType == CALLERTYPE_LSA) )
    {
        return TRUE; 
    }

    //
    // Support for manipulating Trusted Doamin and Secret Object other than LSA,
    // or one of the trusted callers above should be disabled. Because LSA assumes 
    // that it is the only code that modifies TDO and secret objects.
    // 
    switch (Class) {
    case CLASS_TRUSTED_DOMAIN:
    case CLASS_SECRET:
        Result = FALSE;
        break;
    default:
        ;
    }

    return (Result);
}




NTSTATUS
SampGetServerRoleFromFSMO(
    DOMAIN_SERVER_ROLE * ServerRole)
/*++

    This routine looks at the FSMO for PDCness and
    determines the server Role


    Parameters

        ServerRole -- The server role is returned in here


    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    err=0;
    THSTATE  *pTHS;
    DWORD    dwException;
    PVOID    dwEA;
    ULONG    ulErrorCode,
             dsid;
    ULONG    len;
    DSNAME   *pOwner;


    //
    // Should not have an open transaction while
    // calling this routine
    //

    if (SampExistsDsTransaction())
    {
        return STATUS_INVALID_PARAMETER;
    }

    __try
    {

        NtStatus = SampMaybeBeginDsTransaction(
                        TransactionRead);

        if (!NT_SUCCESS(NtStatus))
        {
            __leave;
        }

        pTHS = pTHStls;

        //
        // Position on the domain object
        //

        err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN);

        if (0!=err)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            __leave;
        }

        //
        // Get the FSMO role owner property
        //

        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_FSMO_ROLE_OWNER,
                          0,
                          0,
                          &len,
                          (UCHAR **)&pOwner);
        if (err)
        {
             NtStatus = STATUS_UNSUCCESSFUL;
                __leave;
        }

        //
        // We have everything we want
        //

        NtStatus = STATUS_SUCCESS;

        //
        // Is it own NTDS Dsa Object
        //

        if (NameMatched(pOwner,gAnchor.pDSADN)) {
                /* This DSA is  the role owner */

            *ServerRole = DomainServerRolePrimary;

        }
        else
        {
            *ServerRole = DomainServerRoleBackup;
        }
    }
     __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid))
    {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            NtStatus = STATUS_UNSUCCESSFUL;
    }


    //
    // End any open transactions
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    return NtStatus;
}

NTSTATUS
SampComputeGroupType(
    ULONG  ObjectClass,
    ULONG  GroupType,
    NT4_GROUP_TYPE *pNT4GroupType,
    NT5_GROUP_TYPE *pNT5GroupType,
    BOOLEAN        *pSecurityEnabled
   )
/*++
    Routine Description

        Given the object class ATTR and Group Type, this routine computes the
        correct NT4 and NT5 group types. The object class parameter is currently
        not required but making this routine take the object class parameter
        allows easy transitioniong to a scheme whereby, the NT5 group types are
        determined by object type rather than group type.

    Parameters:

        ObjectClass      -- Specifies the object class.
        GroupType        -- The group type property
        pNT4GroupType    -- The NT4 Group type is returned in here
        pNT5GroupType    -- The NT5 Group type is returned in here
        pSecurityEnabled -- boolean indicates wether group is security enabled

    Return Values

        STATUS_SUCCESS
--*/
{
    Assert(SampGroupObjectType==SampSamObjectTypeFromDsClass(
                                            SampDeriveMostBasicDsClass(ObjectClass) ) );


    *pNT4GroupType = NT4GlobalGroup;

    if (GroupType & GROUP_TYPE_SECURITY_ENABLED)
        *pSecurityEnabled = TRUE;
    else
        *pSecurityEnabled = FALSE;

    if (GroupType & GROUP_TYPE_RESOURCE_GROUP)
    {
        *pNT5GroupType = NT5ResourceGroup;
        *pNT4GroupType = NT4LocalGroup;
    }
    else if (GroupType & GROUP_TYPE_ACCOUNT_GROUP)
    {
        *pNT5GroupType = NT5AccountGroup;
    }
    else if (GroupType & GROUP_TYPE_UNIVERSAL_GROUP)
    {
        *pNT5GroupType = NT5UniversalGroup;
    }
    else if (GroupType & GROUP_TYPE_APP_BASIC_GROUP)
    {
        *pNT5GroupType = NT5AppBasicGroup;
        *pNT4GroupType = NT4LocalGroup;
    }
    else if (GroupType & GROUP_TYPE_APP_QUERY_GROUP)
    {
        *pNT5GroupType = NT5AppQueryGroup;
        *pNT4GroupType = NT4LocalGroup;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
SampAddLoopbackTask(
    IN PVOID TaskInfo
    )
/*++

Routine Description:

    This routine is called by SAM to add an entry in the LoopbackTaskInfo so
    that when the transaction is finally committed, SAM will be notified
    of the commit and then can take action.  For example, notify
    external packages about password changes.

    The element is placed in the outermost transaction info so it can be
    rolled back properly.

Arguments:

    TaskInfo - an opaque blob for SAM

Return Value:

    TRUE if the entry is put in the list; FALSE otherwise

--*/
{
    THSTATE *pTHS = pTHStls;
    PLOOPBACKTASKINFO pItem = NULL;
    NESTED_TRANSACTIONAL_DATA *pNTD = NULL;

    // We should have a thread state
    Assert( VALID_THSTATE(pTHS) );

    // We are in loopback, we should have a transaction
    Assert( SampExistsDsTransaction() );

    // We should a parameter, too
    Assert( TaskInfo );

    if ( !pTHS
      || !SampExistsDsTransaction()
      || !TaskInfo )
    {
        return FALSE;
    }

    pNTD = pTHS->JetCache.dataPtr;

    //
    // There should always be at least one entry
    //
    Assert( pNTD );

    //
    // Prepare the element
    //
    pItem = THAlloc( sizeof(LOOPBACKTASKINFO) );
    if ( !pItem )
    {
        return FALSE;
    }
    memset( pItem, 0, sizeof(LOOPBACKTASKINFO) );

    pItem->Next = NULL;
    pItem->TaskInfo = TaskInfo;

    //
    // Put the element in the list
    //
    if ( pNTD->pLoopbackTaskInfo )
    {
        pItem->Next = pNTD->pLoopbackTaskInfo;
    }
    pNTD->pLoopbackTaskInfo = pItem;

    return TRUE;

}

VOID
SampProcessLoopbackTasks(
    VOID
    )
/*++

Routine Description:

    This routine is called once a transaction has been end (either Commit or
    aborted ) and the SAM lock has been released.  It calls into SAM with 
    whatever items SAM put into the threadstate during the transaction.

    We will let SAM make the decision (whether do this item or ignore)
     based on fCommit field in each Loopback task item. 


Arguments:

    None.

Return Value:

    None.

--*/
{
    THSTATE *pTHS = pTHStls;
    PLOOPBACKTASKINFO Item, Temp;

    // We should have a thread state
    Assert( VALID_THSTATE(pTHS) );

    Item = pTHS->SamTaskList;

    while ( Item )
    {
        SampProcessSingleLoopbackTask( Item->TaskInfo );

        Temp = Item;
        Item = Item->Next;
        THFreeEx(pTHS, Temp );

    }

    pTHS->SamTaskList = NULL;

    return;
}



VOID
AbortLoopbackTasks(
    PLOOPBACKTASKINFO List
    )
/*++

Routine Description:

    This routine is called once a transaction has aborted.


Arguments:

    List - pointer points to the SAM Lookback Tasks.

Return Value:

    None.

--*/
{
    PLOOPBACKTASKINFO Item;

    Item = List;

    while ( Item )
    {
        SampAbortSingleLoopbackTask( Item->TaskInfo );
        Item = Item->Next;
    }

    return;
}

BOOL
LoopbackTaskPreProcessTransactionalData(
        BOOL fCommit
        )
/*++

Routine Description:

Arguments:

    fCommit: Whether the routine is committing or not

Return Value:

    True/False for Success/Fail.

--*/
{

    THSTATE          *pTHS = pTHStls;

    Assert( VALID_THSTATE(pTHS) );

    Assert( pTHS->transactionlevel > 0 );
    Assert( pTHS->JetCache.dataPtr );

    if( !pTHS->JetCache.dataPtr->pLoopbackTaskInfo )
    {
        // No data to process
        NOTHING;
    }
    else if ( !fCommit )
    {
        //
        // Aborted transaction, abort the SAM Loopback tasks
        // by marking fCommit (in easy task item structure)
        // field to FALSE.
        //
        AbortLoopbackTasks( pTHS->JetCache.dataPtr->pLoopbackTaskInfo );
    }
    // ELSE we will actually deal with this in the post process phase.


    return TRUE;

}

void
LoopbackTaskPostProcessTransactionalData(
    IN THSTATE *pTHS,
    IN BOOL fCommit,
    IN BOOL fCommitted
    )
/*++

Routine Description:

Arguments:

    pTHS: The threadstate

    fCommit: Whether the routine is committing or not

    fCommitted:

Return Value:

    None.

--*/
{

    LOOPBACKTASKINFO *pItem = NULL;
    LOOPBACKTASKINFO *pTemp = NULL;

    Assert( VALID_THSTATE(pTHS) );

    //
    // Parameter sanity check
    //
    if ( fCommitted )
    {
        // fCommitted should only be set when fCommit is true
        Assert( fCommit );
    }

    if ( !pTHS->JetCache.dataPtr->pLoopbackTaskInfo )
    {
        // nothing to do.
        NOTHING;
    }
    else 
    {
        if ( !fCommitted )
        {
            //
            // The commit did not succeed; abort the SAM Loopback tasks
            // by marking fCommit (in easy task item structure)
            // field to FALSE.
            // 
            AbortLoopbackTasks( pTHS->JetCache.dataPtr->pLoopbackTaskInfo );
        }

        // 
        // regardless whether commit success or not, as long as 
        // pTHS->JetCache.dataPtr->pLoopbackTaskInfo is not NULL, 
        // we will do the following. Since we have already marked 
        // commit or not in each Task Item field, we will let
        // SAM decide whether the do each every task item or not 
        // when we finally let SAM process the Task Info. 
        // 

        if ( 0 == pTHS->transactionlevel )
        {
            //
            // This was the final commit - put the changes on the thread
            // state
            //
            Assert( NULL == pTHS->SamTaskList );
            pTHS->SamTaskList = pTHS->JetCache.dataPtr->pLoopbackTaskInfo;
            pTHS->JetCache.dataPtr->pLoopbackTaskInfo = NULL;
        }
        else
        {
            //
            // Put the changes on the parent transaction
            //
            NESTED_TRANSACTIONAL_DATA *pOuter = NULL;

            pOuter = pTHS->JetCache.dataPtr->pOuter;

            Assert( pOuter );

            //
            // Add the pending list to the beginning of the parent's
            // list
            //

            //
            // First, the end of the Pending task list
            //
            pItem = pTHS->JetCache.dataPtr->pLoopbackTaskInfo;
            Assert( pItem );
            while ( pItem->Next )
            {
                pItem = pItem->Next;
            }

            pItem->Next = pOuter->pLoopbackTaskInfo;
            pOuter->pLoopbackTaskInfo = pTHS->JetCache.dataPtr->pLoopbackTaskInfo;

        }
    }

    //
    // One way on another the Pending list has been taken care of
    //
    pTHS->JetCache.dataPtr->pLoopbackTaskInfo = NULL;

}


BOOLEAN
SampDoesDomainExist(
    IN PDSNAME pDN
    )
//
// This routine (exported from ntdsa.dll) determines if a particular domain
// (pDN) exists by walking through the cross ref list.
//
{
    BOOLEAN  fExists = FALSE;

    CROSS_REF_LIST *      pCRL;

    // quick parameter check
    Assert( pDN );
    if ( !pDN )
    {
        return FALSE;
    }

    // we are not really updating gAnchor but we don't it
    // to change either
    EnterCriticalSection( &gAnchor.CSUpdate );
    _try
    {
        for ( pCRL = gAnchor.pCRL; NULL != pCRL; pCRL = pCRL->pNextCR )
        {
            if ( NameMatched( (DSNAME*)pCRL->CR.pNC, pDN ) )
            {
                fExists = TRUE;
                break;
            }
        }

    }
    _finally
    {
        LeaveCriticalSection( &gAnchor.CSUpdate );
    }


    return fExists;
}

extern
NTSTATUS
MatchCrossRefByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   )
/*++

    Routine Description

       This routine walks the gAnchor matching the Netbios domain
       name specified to that of any domain in that we may know 
       about in the Xref list

    Parameters

       NetbiosName  The Netbios name to match
       XrefDsName   The DSNAME of the Xref that matched 
       XrefNameLen  The length of the Xref DSNAME that matched

    Return Values
       STATUS_SUCCESS
       STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG       crFlags = (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);
    CROSS_REF_LIST * pCRL;
    UNICODE_STRING XrefNetbiosDomainName;
    UNICODE_STRING NetbiosDomainName;

    for (pCRL=gAnchor.pCRL;pCRL!=NULL;pCRL=pCRL->pNextCR)
    {
        if ( pCRL->CR.NetbiosName 
            && ((pCRL->CR.flags & crFlags) == crFlags))
        {
            RtlInitUnicodeString(&XrefNetbiosDomainName, 
                                 pCRL->CR.NetbiosName);
            
            RtlInitUnicodeString(&NetbiosDomainName, 
                                 NetbiosName);

            if ( RtlEqualDomainName(&XrefNetbiosDomainName,
                                    &NetbiosDomainName ))
            {            
                ULONG LengthRequired = pCRL->CR.pObj->structLen;

                NtStatus = STATUS_SUCCESS;    

                if (ARGUMENT_PRESENT(XrefDsName))
                {
                    if (*XrefNameLen>=LengthRequired)
                    {
                        RtlCopyMemory(XrefDsName,pCRL->CR.pObj,LengthRequired);
                    }
                    else
                    {
                        NtStatus = STATUS_BUFFER_TOO_SMALL;
                    }
                }
                *XrefNameLen = LengthRequired;
                break;
            }
         }
     }

     return(NtStatus);

}

extern
NTSTATUS
MatchDomainDnByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   )
/*++

    Routine Description

       This routine walks the gAnchor matching the Netbios domain
       name specified to that of any domain in that we may know 
       about in the Xref list

    Parameters

       NetbiosName     The Netbios domain name to match
       DomainDsName    The DSNAME of the Domain that matched 
       DomainDsNameLen The length of the Domain DSNAME that matched

    Return Values
       STATUS_SUCCESS
       STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG       crFlags = (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);
    CROSS_REF_LIST * pCRL;
    UNICODE_STRING XrefNetbiosDomainName;
    UNICODE_STRING NetbiosDomainName;

    for (pCRL=gAnchor.pCRL;pCRL!=NULL;pCRL=pCRL->pNextCR)
    {
        if ( pCRL->CR.NetbiosName 
            && ((pCRL->CR.flags & crFlags) == crFlags))            
       {
            RtlInitUnicodeString(&XrefNetbiosDomainName,
                                 pCRL->CR.NetbiosName);

            RtlInitUnicodeString(&NetbiosDomainName,
                                 NetbiosName);

            if ( RtlEqualDomainName(&XrefNetbiosDomainName,
                                    &NetbiosDomainName ))
            {        
                ULONG LengthRequired = pCRL->CR.pNC->structLen;

                NtStatus = STATUS_SUCCESS;    

                if (ARGUMENT_PRESENT(DomainDsName))
                {
                    if (*DomainDsNameLen>=LengthRequired)
                    {
                        RtlCopyMemory(DomainDsName,pCRL->CR.pNC,LengthRequired);
                    }
                    else
                    {
                        NtStatus = STATUS_BUFFER_TOO_SMALL;
                    }
                }
                *DomainDsNameLen = LengthRequired;
                break;
            }
         }
     }

     return(NtStatus);

}

extern
NTSTATUS
MatchDomainDnByDnsName(
   IN LPWSTR         DnsName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   )
/*++

    Routine Description

       This routine walks the gAnchor matching the Dns domain name
       specified to that of any domain in that we may know about 
       in the Xref list

    Parameters

       DnsName         The Dns domain name to match
       DomainDsName    The DSNAME of the Domain that matched 
       DomainDsNameLen The length of the Domain DSNAME that matched

    Return Values
       STATUS_SUCCESS
       STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG       crFlags = (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);
    CROSS_REF_LIST * pCRL;
    
    for (pCRL=gAnchor.pCRL;pCRL!=NULL;pCRL=pCRL->pNextCR)
    {
        if (    pCRL->CR.DnsName 
            && ((pCRL->CR.flags & crFlags) == crFlags)
            && DnsNameCompare_W(pCRL->CR.DnsName, DnsName ))
        {                   
            ULONG LengthRequired = pCRL->CR.pNC->structLen;

            NtStatus = STATUS_SUCCESS;    

            if (ARGUMENT_PRESENT(DomainDsName))
            {
                if (*DomainDsNameLen>=LengthRequired)
                {
                    RtlCopyMemory(DomainDsName,pCRL->CR.pNC,LengthRequired);
                }
                else
                {
                    NtStatus = STATUS_BUFFER_TOO_SMALL;
                }
            }
            *DomainDsNameLen = LengthRequired;
            break;            
         }
     }

     return(NtStatus);

}

extern
NTSTATUS
FindNetbiosDomainName(
   IN DSNAME*        DomainDsName,
   OUT LPWSTR        NetbiosName OPTIONAL,
   IN OUT PULONG     NetbiosNameLen
   )
{

    NTSTATUS    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    CROSS_REF_LIST * pCRL;


    for (pCRL=gAnchor.pCRL;pCRL!=NULL;pCRL=pCRL->pNextCR)
    {
        if ( NameMatched( (DSNAME*)pCRL->CR.pNC, DomainDsName ) )
        {
            if ( pCRL->CR.NetbiosName ) {
                
                ULONG LengthRequired = (wcslen( pCRL->CR.NetbiosName ) + 1) * sizeof(WCHAR);
           
                NtStatus = STATUS_SUCCESS;    
        
                if (ARGUMENT_PRESENT(NetbiosName))
                {
                    if (*NetbiosNameLen>=LengthRequired)
                    {
                        wcscpy( NetbiosName, pCRL->CR.NetbiosName );
                    }
                    else
                    {
                        NtStatus = STATUS_BUFFER_TOO_SMALL;
                    }
                }
                *NetbiosNameLen = LengthRequired;

            } else {

                NtStatus = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
            }

            break;

        }
    }


    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\loopback.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       loopback.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains most of the routines related to DS calls which
    loop back through SAM.  As indicated by the tables in mappings.c,
    SAM owns certain attributes on a handful of object classes - user,
    domain, server, alias and group.  SAM performs three key operations
    on these attributes:

        1) Semantic validation - eg: Logon hours must conform to some
           SAM-defined format.

        2) Auditing - SAM is the security accounts manager and thus must
           insure that access to security related attributes is audited.
           This auditing is the account management category audit and is
           different from the object audting done by the Nt Access Check
           and AuditAlarm functions, based on SACLS.

        3) Netlogon notification - SAM notifies the local netlogon service
           which replicates data via <= NT4 PDS/BDC replication protocols.

    Now that the DS is the underlying repository for account information
    and that the DS provides access via means other than SAM (eg: XDS or
    LDAP), we need to insure that the same 3 sets of operations are 
    performed even if access is via non-SAM means.  Duplicating the 
    SAM logic in the DS was deemed undesirable due to its difficulty and
    the net result of two distant pieces of code trying to apply the same
    semantic rules.  Excising the logic from SAM so that it could be shared
    by both SAM and the DS proved to be equally difficult as the logic is
    sprinkled all throughout the SAM sources.

    This leaves the current approach where the DS detects who and what are
    being accessed.  If the access is by a non-SAM mechanism yet SAM 
    attributes are referenced, then the SAM attributes are split out and
    re-written via 'Samr' APIs.  The recursed Samr API call is detected as
    it comes into the DS, the original non-SAM attributes are merged back
    in to the DS write, and the write proceeds to completion.

    The diagram below shows in the context of an operation via LDAP.

    1) The client performs a write via LDAP.

    2) LDAP passes the write on to the core DS via (eg:) DirModifyEntry.
       DirModifyEntry detects that SAM attributes are being referenced
       and splits them out from the !SAM attributes.

    3) The write of the SAM attributes is funnelled back to SAM via
       same number of Samr calls like SamrSetInformationUser.

    4) SAM maps the contents of the USER_*_INFORMATION struct back to
       DS attributes and makes yet another DirModifyEntry call.  SAM
       is unaware that the SamrSetInformation call originated in the
       DS vs at some other client.  DirModifyEntry detects the recursion
       via some hooks in the THSTATE block, and merges the original 
       !SAM attributes back in to the write data.

    5) The original, unmodified !SAM attributes and the SAM-checked
       SAM attributes are written via LocalModify.


                   original write
                        |              <----------
                      1 |              |          ^
                        v              |          |
                    +--------+     +-------+      |
                    |  LDAP  |     |  SAM  |      |
                    +--------+     +-------+      |   (SAM)
                        |              |          | 3 (attrs)
                      2 |            4 |          |   (only)
                        |              |          |
                        v              v          |
                    +----------------------+      |
                    | split          merge |      |
                    |       CORE DS        |------>
                    |                      |
                    +----------------------+
                                |
                              5 | (all attrs)
                                v
                          +------------+
                          |  DB Layer  |
                          +------------+

    Note that in this model the first, LDAP-originated DirModifyEntry call
    never proceeds to LocalModify.

    Transactions are handle as described in comments in mappings.c.  See
    SampMaybeBeginDsTransaction and SampMaybeEndDsTransasction.

    Any routine which returns an error either sets pTHS->errCode or
    expects that a routine *it* called has set pTHS->errCode.

   6) Access Check Architecture: Most access checks are performed by the DS 
      in the loopback check routines ( ie before the calls to SAM are started ). 
      This check is the same as the DS will do on a normal ( ie non looped back )
      DS operation. The DS can then request additional access checking by SAM 
      when doing the SAM calls. This is done by opening the SAM handles with the
      desired access set to the values that sam needs to check. This is done typically
      to enforce control access rights, which only SAM knows how to enforce.
      For loopback, SAM always access checks the desired access, but grants all access
      if the check for desired access succeeds. 

Author:

    DaveStr     11-Jul-1996

Environment:

    User Mode - Win32

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <anchor.h>
#include <permit.h>
#include <mdlocal.h>

// SAM interoperability headers
#include <mappings.h>
#include <samsrvp.h>            // for SampAcquireWriteLock()
#include <lmaccess.h>           // UF_ACCOUNT_TYPE_MASK

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "drameta.h"
#include "objids.h"             // Defines for selected atts
#include "debug.h"              // standard debugging header
#define DEBSUB "LOOPBACK:"      // define the subsystem for debugging

                                // function
#include <fileno.h>
#define  FILENO FILENO_LOOPBACK

// SAM headers
#include <ntseapi.h>
#include <ntsam.h>
#include <samrpc.h>
#include <crypt.h>
#include <ntlsa.h>
#include <samisrv.h>
#include <samclip.h>

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Prototypes for local functions                                       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


ULONG
SampGetObjectGuid(
    THSTATE *pTHS,
    GUID *pGuid);

ULONG
SampGetDSName(
    THSTATE  *pTHS,
    DSNAME  **ppDSName);

ULONG
SampAddLoopback(
    ULONG       iClass,
    ACCESS_MASK domainModifyRightsRequired,
    ACCESS_MASK objectModifyRightsRequired,
    ULONG       GroupType
    );

VOID
SampAddLoopbackMerge(
    SAMP_LOOPBACK_ARG   *pSamLoopback,
    ADDARG              *pAddArg);

ULONG
SampModifyLoopback(
    THSTATE     *pTHS,
    ULONG       iClass,
    ACCESS_MASK domainModifyRightsRequired,
    ACCESS_MASK objectModifyRightsRequired);

VOID
SampModifyLoopbackMerge(
    THSTATE             *pTHS,
    SAMP_LOOPBACK_ARG   *pSamLoopback,
    MODIFYARG           *pModifyArg);

ULONG
SampRemoveLoopback(
    THSTATE *pTHS,
    DSNAME  *pObject,
    ULONG   iClass);

ULONG
SampOpenObject(
    THSTATE             *pTHS,
    DSNAME              *pObject,
    ULONG               iClass,
    ACCESS_MASK         domainAccess,
    ACCESS_MASK         objectAccess,
    SAMPR_HANDLE        *phSam,
    SAMPR_HANDLE        *phDom,
    SAMPR_HANDLE        *phObj);

VOID
SampCloseObject(
    THSTATE         *pTHS,
    ULONG           iClass,
    SAMPR_HANDLE    *phSam,
    SAMPR_HANDLE    *phDom,
    SAMPR_HANDLE    *phObj);

ULONG
SampWriteSamAttributes(
    THSTATE             *pTHS,
    SAMP_LOOPBACK_TYPE  op,
    SAMPR_HANDLE        hObj,
    ULONG               iClass,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap);

BOOL
SampExistsAttr(
    THSTATE             *pTHS,
    SAMP_CALL_MAPPING   *pMapping,
    BOOL                *pfValueMatched);

ULONG
SampHandleLoopbackException(
    ULONG   ulExceptionCode
    );

ULONG
SampModifyPassword(
    THSTATE             *pTHS,
    SAMPR_HANDLE        hObj,
    DSNAME              *pObject,
    SAMP_CALL_MAPPING   *rCallMap
    );

ULONG
SampDoLoopbackAddSecurityChecks( 
    THSTATE    *pTHS,
    ADDARG * pAddArg,
    CLASSCACHE * pCC,
    GUID*       pNewObjectGuid,
    PULONG      pSamDomainChecks,
    PULONG      pSamObjectChecks
    );

ULONG
SampDoLoopbackModifySecurityChecks(
    THSTATE    *pTHS,
    MODIFYARG * pModifyArg,
    CLASSCACHE * pCC,
    PULONG      pSamDomainChecks,
    PULONG      pSamObjectChecks,
    BOOL        fIsUndelete
    );

ULONG
SampDoLoopbackRemoveSecurityChecks(
    THSTATE    *pTHS,
    REMOVEARG * pRemoveArg,
    CLASSCACHE * pCC,
    PULONG      pSamDomainChecks,
    PULONG      pSamObjectChecks
    );

ULONG
SampGetGroupTypeForAdd(
    ADDARG * pAddArg,
    PULONG   GroupType
    );

ULONG 
SampGetGroupType(
    THSTATE *pTHS,
    PULONG pGroupType
    );

BOOLEAN
IsChangePasswordOperation(MODIFYARG * pModifyArg);

BOOLEAN
IsSetPasswordOperation(MODIFYARG * pModifyArg);

typedef struct LoopbackTransState
{
    DirTransactionOption    transControl;
    BOOL                    fDSA;
} LoopbackTransState;

ULONG
SampBeginLoopbackTransactioning(
    THSTATE                 *pTHS,
    LoopbackTransState      *pTransState,
    BOOLEAN                 fAcquireSamLock);

VOID
SampEndLoopbackTransactioning(
    THSTATE                 *pTHS,
    LoopbackTransState      *pTransState);

BOOLEAN
SampDetectPasswordChangeAndAdjustCallMap(
    IN   SAMP_LOOPBACK_TYPE  op,
    IN   ULONG  iClass,
    IN   ULONG  cCallMap,
    IN   SAMP_CALL_MAPPING   *rCallMap,
    OUT  SAMP_CALL_MAPPING   *AdjustedCallMap
    );

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Miscellaneous helper function implementations                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
SampHandleLoopbackException(
    ULONG ulExceptionCode
    )
/*++

  Routine Description:

     Handles an exception while in the loopback code, and sets an
     appropriate error

  Parameters:

     ulExceptionCode -- The exception code indicating the type of exception

  Return Values:

     An error code returning the type of the error that was set, depending
     upon the exception
--*/
{
    if (DSA_MEM_EXCEPTION==ulExceptionCode)
    {
         SetSysError(ENOMEM,0);
    }
    else
    {
        SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE, DIRERR_UNKNOWN_ERROR,
                      ulExceptionCode); 
    }

    return pTHStls->errCode;
}

ULONG
SampOpenObject(
    THSTATE         *pTHS,
    DSNAME          *pObject,
    ULONG           iClass,
    ACCESS_MASK     domainAccess,
    ACCESS_MASK     objectAccess,
    SAMPR_HANDLE    *phSam,
    SAMPR_HANDLE    *phDom,
    SAMPR_HANDLE    *phObj
    )

/*++

Routine Description:

    Opens the SAM object corresponding to the object pTHS->pDB is
    currently positioned at.

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

    phSam - pointer to handle for SAM.

    phDom - pointer to handle for this object's domain.

    phObj - pointer to handle for this object.

Return Value:

    0 on success, !0 otherwise.  Sets pTHS->errCode on error.

--*/

{
    NTSTATUS        status;
    NT4SID          domSid;
    ULONG           objRid;
    PNT4SID         pSid = NULL;
    ULONG           cbSid = 0;
    DWORD           dbErr;
    BOOL            fLogicErr;

    // Initialize output parameters.

    *phSam = NULL;
    *phDom = NULL;
    *phObj = NULL;

    // Position DB at the object of interest.

    __try
    {
        dbErr = DBFindDSName(pTHS->pDB, pObject);
    }
    __except (HandleMostExceptions(GetExceptionCode()))
    {
        dbErr = DIRERR_OBJ_NOT_FOUND;
    }

    if ( 0 != dbErr )
    {
        SetNamError(
            NA_PROBLEM_NO_OBJECT, 
            pObject, 
            DIRERR_OBJ_NOT_FOUND);

        return(pTHS->errCode);
    }

    // We're now positioned on the object, so we can just read
    // the SID/RID attribute. 

    dbErr = DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_OBJECT_SID,
                DBGETATTVAL_fREALLOC, 
                0,
                &cbSid, 
                (PUCHAR *) &pSid);

    // Handle error conditions.  To get to this point at all the object must
    // have been local and must be managed by SAM, thus it must have a valid
    // Sid.  Furthermore, all Sids are expected to be <= sizeof(NT4SID).

    fLogicErr = TRUE;
  
    if ( (DB_ERR_NO_VALUE == dbErr) 
                ||
        (DB_ERR_BUFFER_INADEQUATE == dbErr)
                ||
         ((0 == dbErr) && (cbSid > sizeof(NT4SID)))
                ||
         (fLogicErr = FALSE, (DB_ERR_UNKNOWN_ERROR == dbErr)) )
    {
        Assert(!fLogicErr);

        SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
        return(pTHS->errCode);
    }

    Assert(RtlValidSid(pSid));


    if ( SampDomainObjectType!=ClassMappingTable[iClass].SamObjectType )
    {
        // Split SID into domain identifier and object RID.

        SampSplitNT4SID(pSid, &domSid, &objRid);
    }
    else
    {
        memcpy(&domSid, pSid, cbSid);
    }

    // Get SAM handle.  Go as trusted client in cross domain move case
    // so that SAM knows to skip certain validation checks - eg: no
    // checks on membership in the cross domain move case.

    status = SamILoopbackConnect(
                    NULL,               // server name
                    phSam,
                    ( SAM_SERVER_CONNECT |
                      SAM_SERVER_ENUMERATE_DOMAINS |
                      SAM_SERVER_LOOKUP_DOMAIN ),
                    (BOOLEAN) (pTHS->fCrossDomainMove ? 1 : 0)
                    );        
    
    if ( NT_SUCCESS(status) )
    {
        // SAM does its own impersonation so call SAM immediately.

        status = SamrOpenDomain(
                        *phSam,
                        domainAccess,
                        (RPC_SID *) &domSid,
                        phDom);

        if ( NT_SUCCESS(status) )
        {
            // Seems to be some condition where we get back success but
            // not a valid domain handle.  Trap via an assert.

            Assert(NULL != *phDom);

            // Get object handle.

            switch (ClassMappingTable[iClass].SamObjectType)
            {
            case SampDomainObjectType:

                // *phDom already obtained.  Copy it to *phObj so
                // subsequent routines don't need to detect special case.

                *phObj = *phDom;

                break;

            case SampAliasObjectType:

                status = SamrOpenAlias(
                                *phDom,
                                objectAccess,
                                objRid,
                                phObj);
                break;

            case SampGroupObjectType:

                status = SamrOpenGroup(
                                *phDom,
                                objectAccess,
                                objRid,
                                phObj);
                break;

            case SampUserObjectType:

                status = SamrOpenUser(
                                *phDom,
                                objectAccess,
                                objRid,
                                phObj);
                break;

            default:

                Assert(!"Logic error");
                status = (ULONG) STATUS_UNSUCCESSFUL;
                break;

            }

            // Make sure SAM isn't reporting success but returning
            // bogus object handles.

            if ( NT_SUCCESS(status) )
            {
                Assert(NULL != *phObj);
            }
        }
    }

    if ( !NT_SUCCESS(status) )
    {
        // Close whatever is open.

        SampCloseObject(pTHS, iClass, phSam, phDom, phObj);
        SampMapSamLoopbackError(status);
    }

    return(pTHS->errCode);
}
    
VOID
SampCloseObject(
    THSTATE         *pTHS,
    ULONG           iClass,
    SAMPR_HANDLE    *phSam,
    SAMPR_HANDLE    *phDom,
    SAMPR_HANDLE    *phObj
    )

/*++

Routine Description:

    Closes an object opened by SampOpenObject.

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

    phSam - pointer to handle for SAM.

    phDom - pointer to handle for this object's domain.

    phObj - pointer to handle for this object.

Return Value:

    None.

--*/

{
    // Save the Error Information As Close Handle can clear them
    ULONG   SavedErrorCode = pTHS->errCode;
    DIRERR  *pSavedErrInfo = pTHS->pErrInfo;

    if ( (NULL != *phObj) &&
         (SampDomainObjectType != ClassMappingTable[iClass].SamObjectType) )
    {
        SamrCloseHandle(phObj);
    }

    if ( NULL != *phDom )
    {
        SamrCloseHandle(phDom);
    }

    if ( NULL != *phSam )
    {
        SamrCloseHandle(phSam);
    }

    pTHS->pErrInfo = pSavedErrInfo;
    pTHS->errCode  = SavedErrorCode;

}

ULONG
SampDetermineObjectClass(
    THSTATE     *pTHS,
    CLASSCACHE **ppClassCache
    )

/*++

Routine Description:

    Reads the object's class property and then maps it to a CLASSCACHE
    entry.  Assumes the database is already positioned at the object.

Arguments:

    ppClassCache - pointer to pointer to CLASSCACHE entry which is filled
        in on successful return.

Return Value:

    0 on success, !0 otherwise.  Sets pTHS->errCode on error.

--*/

{
    ATTRTYP attrType;

    if ( 0 == DBGetSingleValue(
                    pTHS->pDB, 
                    ATT_OBJECT_CLASS, 
                    &attrType,
                    sizeof(attrType), 
                    NULL) )
    {
        if (*ppClassCache =  SCGetClassById(pTHS, attrType) )
        {
            return(0);
        }
    }

    SetUpdError( 
        UP_PROBLEM_OBJ_CLASS_VIOLATION,
        DIRERR_OBJECT_CLASS_REQUIRED);

    return(pTHS->errCode);
}

ULONG
SampGetObjectGuid(
    THSTATE *pTHS,
    GUID *pGuid
    )

/*++

Routine Description:

    Retrieves an object's GUID.  Assumes DB is already positioned at
    the object.

Arguments:

    pGuid - pointer to GUID which is filled on return.

Return Value:

    0 on success, !0 otherwise.  Sets pTHS->errCode on error.

--*/

{
    DWORD   dbErr;
    BOOL    fLogicErr;
    ULONG   cbGuid;

    dbErr = DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_OBJECT_GUID,
                DBGETATTVAL_fCONSTANT,
                sizeof(GUID),
                &cbGuid,
                (PUCHAR *) &pGuid);

    fLogicErr = TRUE;
  
    if ( (DB_ERR_NO_VALUE == dbErr)
                ||
         (DB_ERR_BUFFER_INADEQUATE == dbErr)
                ||
         ((0 == dbErr) && (cbGuid != sizeof(GUID)))
                ||
         (fLogicErr = FALSE, (DB_ERR_UNKNOWN_ERROR == dbErr)) )
    {
        Assert(!fLogicErr);
  
        SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
        return(pTHS->errCode);
    }

    return(0);
}

ULONG
SampGetDSName(
    THSTATE  *pTHS,
    DSNAME  **ppDSName
    )

/*++

Routine Description:

    Retrieves an object's DSNAME.  Assumes DB is already positioned at
    the object.

Arguments:

    ppDSName - pointer to pointer to DSNAME which is filled on return.

Return Value:

    0 on success, !0 otherwise.  Sets pTHS->errCode on error.

--*/

{
    DWORD   dbErr;
    ULONG   cbDSName;

    dbErr = DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_OBJ_DIST_NAME,
                DBGETATTVAL_fREALLOC,
                0,
                &cbDSName,
                (PUCHAR *) ppDSName);

    if ( 0 != dbErr )
    {
        SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
        return(pTHS->errCode);
    }

    return(0);
}

ULONG
SampValidateSamAttribute(
    THSTATE             *pTHS,
    DSNAME              *pObject,
    ULONG               iClass,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
/*++
Routine Description:

    This routine iterates ove a SAMP_CALL_MAPPING and 
    check each SAM attributes modification type are valid.

    for example, only replace is allowed on User Account Name attribute.
    
Arguments:

    hTHS - thread state 

    pObject - object DS name

    iClass - index into ClassMappingTable representing class of object.

    cCallMap - number of elements in rCallMap.

    rCallMap - array of SAMP_CALL_MAPPING which represent all the attributes
        being operated on.

Return Value:

    0 on success, !0 otherwise.

--*/

{
    SAMP_ATTRIBUTE_MAPPING      *rAttrMap;
    BOOLEAN                     fCheckValLength = FALSE;
    ULONG                       SamAttrValLength = 0;
    ULONG                       i = 0;

    //
    // Check the LDAP attribute modification type is allowed by SAM
    // 

    rAttrMap = ClassMappingTable[iClass].rSamAttributeMap;

    for ( i = 0; i< cCallMap; i++ )
    {
        if (!rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }

        //
        // calculate whether we need to check the val length
        // 
        switch( rAttrMap[ rCallMap[i].iAttr ].AttributeSyntax)
        {
        case Integer:

            fCheckValLength = TRUE;
            SamAttrValLength = sizeof(ULONG);
            break;

        case LargeInteger:
            fCheckValLength = TRUE;
            SamAttrValLength = sizeof(LARGE_INTEGER);
            break;

        default:
            fCheckValLength = FALSE;
            ;
        }

        //
        // based on SampAllowedModType and Attribute Syntax, 
        // do some sanity checking
        // 
        switch( rAttrMap[ rCallMap[i].iAttr ].SampAllowedModType )
        {
        case SamAllowAll:
            break;

        case SamAllowReplaceAndRemove:

            //
            // allowed opeartions
            // 1) replace attribute some value
            // 2) replace attribute by NULL value ( equal to remove ) 
            // 3) remove attribute
            // 

            if (!( ((AT_CHOICE_REPLACE_ATT == rCallMap[i].choice) &&
                    (1 == rCallMap[i].attr.AttrVal.valCount) &&
                    (!fCheckValLength || (SamAttrValLength == rCallMap[i].attr.AttrVal.pAVal[0].valLen)) )
                        ||
                   ((AT_CHOICE_REPLACE_ATT == rCallMap[i].choice) &&
                    (0 == rCallMap[i].attr.AttrVal.valCount))
                        ||
                   ((AT_CHOICE_REMOVE_ATT == rCallMap[i].choice) &&
                    (0 == rCallMap[i].attr.AttrVal.valCount)) ) )
            {
                SetAttError(
                        pObject,
                        rCallMap[i].attr.attrTyp,
                        PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                        NULL,
                        DIRERR_SINGLE_VALUE_CONSTRAINT);
            }
            break;

        case SamAllowReplaceOnly:

            if ( !((AT_CHOICE_REPLACE_ATT == rCallMap[i].choice) &&
                   (1 == rCallMap[i].attr.AttrVal.valCount) &&
                   (0 != (rCallMap[i].attr.AttrVal.pAVal[0].valLen))) )
            {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_ILLEGAL_MOD_OPERATION);
            }
            break;

        case SamAllowDeleteOnly:

            // 
            // allowed operations
            // 1) remove attribute
            // 2) remove value
            // 3) replace attribute by NULL value (equal to remove attribute)
            // 


            if ( !( (AT_CHOICE_REMOVE_VALUES == rCallMap[i].choice)
                        || 
                    (AT_CHOICE_REMOVE_ATT    == rCallMap[i].choice) 
                        ||
                    ((AT_CHOICE_REPLACE_ATT == rCallMap[i].choice) && 
                     (0 == rCallMap[i].attr.AttrVal.valCount)) 
                  )
               )
            {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_ILLEGAL_MOD_OPERATION);
            }
            break;

        default:
            ; 
        }

        if (pTHS->errCode)
            break;
    }


    return( pTHS->errCode );
}



ULONG
SampReconstructUserOrGroup(
    THSTATE*        pTHS,
    DSNAME*         pObject,
    ULONG           iClass
    )
/*++

Routine Description:

    Reconstruct missing SAM attributes for tombstone reanimation.

Arguments:

    pObject - object being modified
    iClass - index into ClassMappingTable representing class of object.
    
Return Value:

    0 on success, !0 otherwise.

--*/
{
    DWORD dwErr;
    DWORD dwValue = 0;
    DSTIME dstValue = 0;
    DWORD dwUserAccountControl;
    DWORD dwSamAccountType;
    DWORD dwPrimaryGroupID;
    DWORD dwGroupType;
    DWORD cb;

    __try {

        // locate the object
        dwErr = DBFindDSName(pTHS->pDB, pObject);
        if (dwErr) __leave;

        __try {
            switch(ClassMappingTable[iClass].SamObjectType) {
            case SampUserObjectType:
                // default a bunch of attributes to zero
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_LAST_LOGON, sizeof(dstValue), &dstValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_LAST_LOGOFF, sizeof(dstValue), &dstValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_PWD_LAST_SET, sizeof(dstValue), &dstValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_ACCOUNT_EXPIRES, sizeof(dstValue), &dstValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_BAD_PASSWORD_TIME, sizeof(dstValue), &dstValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_COUNTRY_CODE, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_CODE_PAGE, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_BAD_PWD_COUNT, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_LOGON_COUNT, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_ADMIN_COUNT, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_OPERATOR_COUNT, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;

                // In order to compute samAccountType and primaryGroupID, we need userAccountControl,
                // which is preserved during delete operation. Get it now.
                dwErr = DBGetSingleValue(pTHS->pDB, ATT_USER_ACCOUNT_CONTROL, &dwUserAccountControl, sizeof(dwUserAccountControl), &cb);
                if (dwErr) __leave;

                if (dwUserAccountControl & UF_NORMAL_ACCOUNT) {
                    dwSamAccountType = SAM_NORMAL_USER_ACCOUNT;
                    dwPrimaryGroupID = DOMAIN_GROUP_RID_USERS;
                }
                else if (dwUserAccountControl & UF_WORKSTATION_TRUST_ACCOUNT) {
                    dwSamAccountType = SAM_MACHINE_ACCOUNT;
                    dwPrimaryGroupID = DOMAIN_GROUP_RID_COMPUTERS;
                }
                else if (dwUserAccountControl & UF_SERVER_TRUST_ACCOUNT) {
                    dwSamAccountType = SAM_MACHINE_ACCOUNT;
                    dwPrimaryGroupID = DOMAIN_GROUP_RID_CONTROLLERS;
                }
                else if (dwUserAccountControl & UF_INTERDOMAIN_TRUST_ACCOUNT) {
                    dwSamAccountType = SAM_TRUST_ACCOUNT;
                    dwPrimaryGroupID = DOMAIN_GROUP_RID_USERS;
                }
                else {
                    dwErr = DIRERR_UNKNOWN_ERROR;
                    __leave;
                }

                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_PRIMARY_GROUP_ID, sizeof(dwPrimaryGroupID), &dwPrimaryGroupID);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_SAM_ACCOUNT_TYPE, sizeof(dwSamAccountType), &dwSamAccountType);
                if (dwErr) __leave;

                // disable the account, since a password might not be set, it can otherwise open a security hole
                dwUserAccountControl |= UF_ACCOUNTDISABLE;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_USER_ACCOUNT_CONTROL, sizeof(dwUserAccountControl), &dwUserAccountControl);
                if (dwErr) __leave;

                break;

            case SampGroupObjectType:
                // default a bunch of attributes to zero
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_ADMIN_COUNT, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;
                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_OPERATOR_COUNT, sizeof(dwValue), &dwValue);
                if (dwErr) __leave;

                // In order to compute samAccountType, we need groupType,
                // which is preserved during delete operation. Get it now.
                dwErr = DBGetSingleValue(pTHS->pDB, ATT_GROUP_TYPE, &dwGroupType, sizeof(dwGroupType), &cb);
                if (dwErr) __leave;

                if (dwGroupType & GROUP_TYPE_RESOURCE_BEHAVOIR) {                                     
                    if (dwGroupType & GROUP_TYPE_SECURITY_ENABLED) {
                        dwSamAccountType = SAM_ALIAS_OBJECT;
                    } 
                    else {
                        dwSamAccountType = SAM_NON_SECURITY_ALIAS_OBJECT;
                    }
                }
                else if (dwGroupType & GROUP_TYPE_SECURITY_ENABLED) {
                    dwSamAccountType = SAM_GROUP_OBJECT;
                }
                else {
                    dwSamAccountType = SAM_NON_SECURITY_GROUP_OBJECT;
                }

                dwErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_SAM_ACCOUNT_TYPE, sizeof(dwSamAccountType), &dwSamAccountType);
                if (dwErr) __leave;

                break;

            default:
                dwErr = ERROR_DS_ILLEGAL_MOD_OPERATION;
            }
        }
        __finally {
            if (dwErr || AbnormalTermination()) {
                // an error occured, roll back changes (if any)
                DBCancelRec(pTHS->pDB);
            }
            else {
                // all is fine, flush changes to the DB
                dwErr = InsertObj(pTHS, pObject, NULL, TRUE, META_STANDARD_PROCESSING);
            }
        }

    }
    __except (HandleMostExceptions(dwErr = GetExceptionCode()))
    {
        ;
    }

    if (dwErr) {
        SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
    }
    return dwErr;
}


ULONG
SampWriteSamAttributes(
    THSTATE             *pTHS,
    SAMP_LOOPBACK_TYPE  op,
    SAMPR_HANDLE        hObj,
    ULONG               iClass,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )

/*++

Routine Description:

    Iterates over a SAMP_CALL_MAPPING and calls the appropriate SampWrite*
    routine for each attribute marked as fSamWriteRequired.

Arguments:

    hObj - open SAMP_HANDLE for the object of interest.

    iClass - index into ClassMappingTable representing class of object.

    cCallMap - number of elements in rCallMap.

    rCallMap - array of SAMP_CALL_MAPPING which represent all the attributes
        being operated on.
        
Return Value:

    0 on success, !0 otherwise.

--*/
{
    ULONG                       i, j;
    DWORD                       dwErr;
    SAMP_ATTRIBUTE_MAPPING      *rAttrMap;
    BOOL                        fValueMatched;
    NTSTATUS                    status = STATUS_SUCCESS;
    SAMP_CALL_MAPPING           AdjustedCallMap[2];
    BOOL                        fPermissiveModify = TRUE;

    Assert((LoopbackAdd == op) || (LoopbackModify == op));

    // Fill in the ATTCACHE pointers so we can do some schema based
    // analysis of the call map.

    for ( i = 0; i < cCallMap; i++ )
    {   
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        // ATTCACHE pointers should not have been assigned before now.

        Assert(NULL == rCallMap[i].pAC);
        Assert(!rCallMap[i].fIgnore);

        // Since we think this is a SAM attribute, we certainly
        // expect to be able to find the attribute in the cache.

        rCallMap[i].pAC = SCGetAttById(pTHS,
                                       rCallMap[i].attr.attrTyp);

        Assert(rCallMap[i].pAC);
    }

    // Should be able to position DB at the object in all cases - even
    // LoopbackAdd since by the time we get here, the base object has 
    // been created.

    __try
    {
        dwErr = DBFindDSName(pTHS->pDB, pObject);
    }
    __except (HandleMostExceptions(GetExceptionCode()))
    {
        dwErr = DIRERR_OBJ_NOT_FOUND;
    }

    if ( 0 != dwErr )
    {
        SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
        goto Error;
    }

    // Detect change password case.  Password can only be modified 
    // 1) if this is a user and there are only two sub-operations,
    // one to remove the old password and another to add the new password.
    // SampModifyPassword verifies the secure connection.  AT_CHOICEs
    // are dependent on how the LDAP head maps LDAP add/delete attribute
    // operations.  LDAP add always maps to AT_CHOICE_ADD_VALUES.  LDAP
    // delete maps to AT_CHOICE_REMOVE_ATT if no value is supplied
    // (eg: old password is NULL) and AT_CHOICE_REMOVE_VALUES if a value
    // is supplied.  We allow the operations in either order.
    //
    // 2) if the attribute specified is Userpassword, and if only a single
    //    remove value is provided, the value corresponding to the old 
    //    password. In this case the password is being changed to a blank
    //  password.
    //
    // SampModifyPassword always expects 2 paramaters in the callmap, one
    // corresponding to the old password and one for the new password.
    // SampDetectAndAdjustCallMap modifies the call map for this purpose.
    //

    if (SampDetectPasswordChangeAndAdjustCallMap(
            op, iClass, cCallMap, rCallMap,AdjustedCallMap))
    {

        dwErr = SampModifyPassword(pTHS, hObj, pObject, AdjustedCallMap);
        if (0!=dwErr)
        {
            goto Error;
        }
        // we succeeded so flush writes
        goto Flush;
    }



    //
    // SAM doesn't always have a counterpart to all the core modification 
    // choices like AT_CHOICE_ADD_VALUES, etc.  So we pre-process the call 
    // mapping applying some basic rules in order map down to the SAM 
    // operational model. We will try to map down to just AT_CHOICE_REPLACE_ATT
    // and AT_CHOICE_REMOVE_ATT. Note this generally applies to single valued
    // attributes only .... SAM generally knows to handle add value and 
    // remove value for multi valued attributes.
    //

    //
    // Scan forward to map any
    // 
    // 1. Replace with a null value to a remove att.
    //
    // 2. Ignore previous mods to the attribute  if they are followed
    //    by a remove att.
    //
    // 3. Add Value, Remove Value pair ( or vice versa ), with the remove 
    //    value matching the database value to a replace att for single
    //    valued attribute.
    //
    // 4. The first add value after a remove att to a replace for single 
    //    valued attributes ( SAM knows to handle add value and remove value 
    //    correctly for multi valued attributes.
    // 
    // 5. Add att is not so interesting because the LDAP head never issues it.
    //
    // The above chances are applied in strict order -- ie we'll first do 1.
    // completely and then 2. completely and then 3. completely and then 4.
    
    
    // This type of processing works well with ldap 
    // compliance in most common situations ( applications modifying single 
    // valued attributes by either a single replace or a single add/remove 
    // pair or a single remove/add pair ). We expect these to the common form 
    // of modifications by applications.
    //
    // Applications may issue more complicated types of modifications e.g 
    // multiple add  remove pairs ( e.g removing some values just added ) and 
    // that may result in  differnt results. The only provable way to be 
    // compliant is to update the database in the order supplied by the 
    // application and then checking the database. This is not currently 
    // possible in the current loopback architecture. Therefore we will mini-
    // mize cases where we are not interoperable by i) the strategy above to
    // take care of simple cases and ii) minimizing the set of attributes that
    // really require validation by SAM ( this is a small subset of attributes
    // on a small subset of classes ).
    //
    //

    
    //
    // Step 1. Map replace with null value to remove att.
    //

    for ( i = 0; i < cCallMap; i++ )
    {
        //
        // according to RFC-2251 (ldap v3.0 spec)
        // A replace with no value will delete the entire attribute if 
        // it exists, and is ignored if the attribute does not exist
        //

        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        if ((AT_CHOICE_REPLACE_ATT== rCallMap[i].choice) 
           && (0 == rCallMap[i].attr.AttrVal.valCount))
        {
           
            rCallMap[i].choice = AT_CHOICE_REMOVE_ATT;
        }
    }

    //
    // Step 2. prune all modifications on attributes that's followed
    // by a remove att.
    //

    for ( i = 0; i < cCallMap; i++ )
    {
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        if (AT_CHOICE_REMOVE_ATT== rCallMap[i].choice) 
        {
            // Scan backwards other mods on the same attribute

            for ( j = 0; j < i; j++ )
            {
                if ( rCallMap[j].attr.attrTyp == rCallMap[i].attr.attrTyp) {
                     rCallMap[j].fIgnore = TRUE;
                }
            }
        }
     }

    //
    // Step 3. reduce matching add value, remove value pairs to replace
    // for single valued attributes
    //

    for ( i = 0; i < cCallMap; i++ )
    {
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        if ( (AT_CHOICE_REMOVE_VALUES == rCallMap[i].choice) &&
             (rCallMap[i].pAC->isSingleValued) &&
             (1 == rCallMap[i].attr.AttrVal.valCount) )
        {
            // Scan forward for matching add.

            for ( j = (i+1); j < cCallMap; j++ )
            {
                if ( !rCallMap[j].fSamWriteRequired || rCallMap[j].fIgnore )
                {
                    continue;
                }

                if ( (rCallMap[i].attr.attrTyp == rCallMap[j].attr.attrTyp) &&
                     (AT_CHOICE_ADD_VALUES == rCallMap[j].choice) &&
                     (1 == rCallMap[j].attr.AttrVal.valCount) &&
                     (SampExistsAttr(pTHS, &rCallMap[i], &fValueMatched)) &&
                     fValueMatched )
                {
                    rCallMap[i].fIgnore = TRUE;
                    rCallMap[j].choice = AT_CHOICE_REPLACE_ATT;
                    break;
                }
            }
        }
        else if ( (AT_CHOICE_ADD_VALUES == rCallMap[i].choice) &&
                  (rCallMap[i].pAC->isSingleValued) &&
                  (1 == rCallMap[i].attr.AttrVal.valCount) )
        {
            // Scan forward for matching remove.

            for ( j = (i+1); j < cCallMap; j++ )
            {
                if ( !rCallMap[j].fSamWriteRequired || rCallMap[j].fIgnore )
                {
                    continue;
                }

                if ( (rCallMap[i].attr.attrTyp == rCallMap[j].attr.attrTyp) &&
                     (AT_CHOICE_REMOVE_VALUES == rCallMap[j].choice) &&
                     (1 == rCallMap[j].attr.AttrVal.valCount) &&
                     (SampExistsAttr(pTHS, &rCallMap[j], &fValueMatched)) &&
                     fValueMatched )
                {
                    rCallMap[j].fIgnore = TRUE;
                    rCallMap[i].choice = AT_CHOICE_REPLACE_ATT;
                    break;
                }
            }
        }
    }

    //
    // Step 4: For single valued attributes, reduce remove att, add value 
    // combinations to replace att.
    //

    for ( i = 0; i < cCallMap; i++ )
    {
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        if ( (AT_CHOICE_REMOVE_ATT== rCallMap[i].choice) &&
             (rCallMap[i].pAC->isSingleValued))
        {
            // Scan forward for matching add value

            for ( j = (i+1); j < cCallMap; j++ )
            {
                if ( !rCallMap[j].fSamWriteRequired || rCallMap[j].fIgnore )
                {
                    continue;
                }

                if ( (rCallMap[i].attr.attrTyp == rCallMap[j].attr.attrTyp) &&
                     (AT_CHOICE_ADD_VALUES == rCallMap[j].choice) &&
                     (1 == rCallMap[j].attr.AttrVal.valCount))
                {
                    rCallMap[i].fIgnore = TRUE;
                    rCallMap[j].choice = AT_CHOICE_REPLACE_ATT;
                    break;
                }
            }
        }
    }

    //
    // Note the value of the permissive modify flag
    //

    if (NULL != pTHS->pSamLoopback)
    {
        fPermissiveModify = ((SAMP_LOOPBACK_ARG *) pTHS->pSamLoopback)->fPermissiveModify;
    }

    //
    // At this time matching add value, remove value pairs have been 
    // mapped to replace and the remove is ignored.
    //


    for ( i = 0; i < cCallMap; i++ )
    {
       
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        switch ( rCallMap[i].choice )
        {
        case AT_CHOICE_ADD_ATT:

            //
            // Map ADD_ATT to REPLACE_ATT if the attribute did not
            // already exist.
            //

            if (SampExistsAttr(pTHS, &rCallMap[i], &fValueMatched))
            {
                //
                // Attribute exists. check fPermissiveModify flag
                // 

                if (fPermissiveModify)
                {
                    rCallMap[i].fIgnore = TRUE;
                }
                else
                {
                    SetAttError(pObject,
                                rCallMap[i].attr.attrTyp,
                                PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                ERROR_DS_ATT_ALREADY_EXISTS);

                    goto Error;
                }
            }
            else
            {
                //
                // Attribute does not exist
                // 

                rCallMap[i].choice = AT_CHOICE_REPLACE_ATT;
            }
            break;

        case AT_CHOICE_REMOVE_ATT:
            // leave as is

            break;

        case AT_CHOICE_REPLACE_ATT:

            if ((rCallMap[i].pAC->isSingleValued) &&
                (1!=rCallMap[i].attr.AttrVal.valCount)) {

                SetAttError(pObject,
                    rCallMap[i].attr.attrTyp,
                    PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                    ERROR_DS_ATT_ALREADY_EXISTS);

                goto Error;
            }

            // leave as is.
            break;

        case AT_CHOICE_ADD_VALUES:

            //
            // Map to replace if single valued constraint is not
            // being violated. This is to be done as follows.
            //   1. There is no value currently on the database
            //   2. There is no previous replace on the same attribute
            //

            if (rCallMap[i].pAC->isSingleValued)
            {
                if (SampExistsAttr(pTHS, &rCallMap[i], &fValueMatched))
                {
                    //
                    // Value exists in the database .... 
                    // 
                    if (fValueMatched && fPermissiveModify && 
                        (1==rCallMap[i].attr.AttrVal.valCount))
                    {
                        rCallMap[i].fIgnore = TRUE;
                    }
                    else
                    {
                        SetAttError(pObject,
                                    rCallMap[i].attr.attrTyp,
                                    PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                    ERROR_DS_ATT_ALREADY_EXISTS);

                        goto Error;
                    }
                }
                else    // attribute does not exist in database
                {
                    //
                    //  Scan backwards for a replace value on the 
                    //  same attribute

                    for ( j = 0; j < i; j++ )
                    {
                       if((rCallMap[j].attr.attrTyp == rCallMap[i].attr.attrTyp)
                           && (rCallMap[j].choice==AT_CHOICE_REPLACE_ATT)
                           && (!rCallMap[j].fIgnore))
                       {
                              
                         if  (fPermissiveModify && 
                             (1==rCallMap[i].attr.AttrVal.valCount) &&
                             (1==rCallMap[j].attr.AttrVal.valCount) &&
                             (rCallMap[i].attr.AttrVal.pAVal[0].valLen ==
                             rCallMap[j].attr.AttrVal.pAVal[0].valLen)&&
                             (0==memcmp(rCallMap[i].attr.AttrVal.pAVal[0].pVal,
                                        rCallMap[j].attr.AttrVal.pAVal[0].pVal,
                                     rCallMap[j].attr.AttrVal.pAVal[0].valLen)))
                         {

                             rCallMap[j].fIgnore = TRUE;
                         }
                         else
                         {
                              SetAttError(pObject,
                                    rCallMap[i].attr.attrTyp,
                                    PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                    ERROR_DS_ATT_ALREADY_EXISTS);

                              goto Error;
                         }

                       }
                    }

                    //
                    // if we are here it means there is no value on the 
                    // database and there is no previous mod on the attribute
                    // that would have placed a value. As long this operation
                    // purpots to place only a single value, change to replace
                    // att.
                    //

                    if (1==rCallMap[i].attr.AttrVal.valCount)
                    {
                        rCallMap[i].choice = AT_CHOICE_REPLACE_ATT;
                    }
                    else
                    {
                        SetAttError(pObject,
                                    rCallMap[i].attr.attrTyp,
                                    PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                    ERROR_DS_ATT_ALREADY_EXISTS);

                        goto Error;
                    }
                }
            }

            break;

        case AT_CHOICE_REMOVE_VALUES:

            if (rCallMap[i].pAC->isSingleValued)
            {
                if ( SampExistsAttr(pTHS, &rCallMap[i], &fValueMatched) &&
                     fValueMatched )
                {
                    rCallMap[i].choice = AT_CHOICE_REMOVE_ATT;
                    rCallMap[i].attr.AttrVal.valCount = 0;
                    rCallMap[i].attr.AttrVal.pAVal = NULL;
                }
                else
                {
                    // No value to remove.

                    if (fPermissiveModify)
                    {
                        rCallMap[i].fIgnore = TRUE;
                    }
                    else
                    {
                        SetAttError(pObject,
                                    rCallMap[i].attr.attrTyp,
                                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, 
                                    rCallMap[i].attr.AttrVal.pAVal,
                                    ERROR_DS_CANT_REM_MISSING_ATT_VAL);

                        goto Error;
                    }
                }
            }

            break;

        default:

            Assert(!"Unknown attribute choice");
            break;
        }
    }

    //
    // Validate all these SAM attributes
    // 

    dwErr = SampValidateSamAttribute(pTHS,
                                     pObject,
                                     iClass,
                                     cCallMap,
                                     rCallMap
                                     );

    if (dwErr)
    {
        goto Error;
    }
                            

    // 
    // pass everything to SAM, let SAM update the attributes which need it.
    // 

    rAttrMap = ClassMappingTable[iClass].rSamAttributeMap;

    status = SamIDsSetObjectInformation(
                        hObj,       // Object Handle
                        pObject,    // Object DS Name
                        ClassMappingTable[iClass].SamObjectType, // obj type
                        cCallMap,   // number of attributes
                        rCallMap,   // attributes need to be modified
                        rAttrMap    // SAM attribute mapping table
                        );

    if (!NT_SUCCESS(status))
    {
        SampMapSamLoopbackError(status);
        goto Error;
    }

Flush:

   //
   // Turn off fDSA so that the DS may perform any check.
   //

   SampSetDsa(FALSE);

   status = SampCommitBufferedWrites(
                 hObj
                );

   if (!NT_SUCCESS(status))
   {
       SampMapSamLoopbackError(status);
       dwErr = pTHS->errCode;
   }

Error:

    return(pTHS->errCode);
}
                                        
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DirAddEntry loopback routines                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
SampAddLoopbackCheck(
    ADDARG      *pAddArg,
    BOOL        *pfContinue
    )

/*++

Routine Description:

    Determines whether a SAM class is being added and if so, recurses
    back through SAM to perform the object creation and to write any SAM
    attributes.  Also traps the first DirAddEntry call looped back through 
    SAM and merges any non-SAM attributes into the create.

Arguments:

    pAddArg - pointer to ADDARGs representing either the arguments to 
        the original DirAddEntry or the SAM-only arguments of a 
        SAM-recursed add.

    pfContinue - pointer to BOOL which is set on return to indicate whether
        the caller should continue processing the add down to the DB layer
        or not.

Return Value:

    0 on success, !0 otherwise.

--*/
{
    THSTATE                 *pTHS=pTHStls;
    ULONG                   iClass;
    ULONG                   ulErr;
    CLASSCACHE              *pClassCache;
    SAMP_LOOPBACK_ARG       *pSamLoopback;
    SAMP_CALL_MAPPING       *rCallMap;
    ULONG                   cCallMap;
    GUID                    guid;
    ACCESS_MASK             domainModifyRightsRequired;
    ACCESS_MASK             objectModifyRightsRequired;
    BOOL                    fLoopbackRequired = FALSE;
    BOOL                    fUserPasswordSupport = FALSE;
    NTSTATUS                status;
    ULONG                   GroupType=0;
    GUID                    ObjGuid;
    BOOL                    FoundGuid;
    NT4SID                  ObjSid;
    DWORD                   cbObjSid;
    LoopbackTransState      transState;

    *pfContinue = TRUE;

    if ( !gfDoSamChecks || !gfRunningInsideLsa )
    {
        return(0);
    }

    // See if this is pass 1 (original call via some agent other than SAM) 
    // or pass N (loopback call via SAM).

    if ( !pTHS->fDRA && !pTHS->fDSA && !pTHS->fSAM )
    {
        // This is a call from some agent other than SAM and is also
        // not an internal operation.  Get the object's class so
        // we can determine if this is a class SAM manages.

        if(0 != FindValuesInEntry(pTHS,
                                  pAddArg,
                                  &pClassCache,
                                  &ObjGuid,
                                  &FoundGuid,
                                  &ObjSid,
                                  &cbObjSid,
                                  NULL)) {
            return(CheckObjDisclosure(pTHS,pAddArg->pResParent,FALSE));
        }


        if ( SampSamClassReferenced(pClassCache, &iClass) )
        {
            ULONG domainRightsFromAccessCheck=0;
            ULONG objectRightsFromAccessCheck=0;

            //
            // if this is a group object creation then fish out
            // the group type property out of the Add Arg
            //

            if (SampGroupObjectType==
                        ClassMappingTable[iClass].SamObjectType)
            {
            
                if (0!=SampGetGroupTypeForAdd(
                        pAddArg,
                        &GroupType))
                {
                    return(CheckObjDisclosure(pTHS,pAddArg->pResParent,FALSE));
                }

                //
                // if the group type specifies an NT4
                // local group then adjust the sam object
                // type and class mapping table entry
                // to be the alias class.
                //

                if (GroupType & GROUP_TYPE_RESOURCE_BEHAVOIR)
                {
                    iClass++;
                }
            }

            if ( 0 != SampAddLoopbackRequired(
                                    iClass, 
                                    pAddArg, 
                                    &fLoopbackRequired,
                                    &fUserPasswordSupport) )
            {
                Assert(0 != pTHS->errCode);

                 return(CheckObjDisclosure(pTHS,pAddArg->pResParent,FALSE));
            }


            // loopback is required to add a SAM owned
            // object, except a domain object when creating a non
            // domain naming context
            
            if (fLoopbackRequired)
            {

                //
                // Peform security checks upfront, allows calling
                // SAM as a trusted client bypassing SAM's security
                // checks. This results in a single check upfront.
                //

                if ( 0 != SampDoLoopbackAddSecurityChecks(
                                pTHS,
                                pAddArg,
                                pClassCache,
                                FoundGuid ? &ObjGuid : NULL,
                                &domainRightsFromAccessCheck,
                                &objectRightsFromAccessCheck) )
                {
                     return(CheckObjDisclosure(pTHS,pAddArg->pResParent,TRUE));
                }

           
                // This is a class SAM wants to handle adds for - let it.
                // Generate/save loop back arguments and recurse through SAM.

                SampBuildAddCallMap(
                                pAddArg, 
                                iClass, 
                                &cCallMap, 
                                &rCallMap,
                                &domainModifyRightsRequired,
                                &objectModifyRightsRequired,
                                fUserPasswordSupport);

                domainModifyRightsRequired |= domainRightsFromAccessCheck;
                objectModifyRightsRequired |= objectRightsFromAccessCheck;

                pSamLoopback = THAllocEx(pTHS, sizeof(SAMP_LOOPBACK_ARG));
                pSamLoopback->type = LoopbackAdd;
                pSamLoopback->pObject = pAddArg->pObject;
                pSamLoopback->cCallMap = cCallMap;
                pSamLoopback->rCallMap = rCallMap;
                pSamLoopback->MostSpecificClass = pClassCache->ClassId;

                // Indicate that calling DirAddEntry routine should
                // not continue in its normal path.  Ie: SampAddLoopback
                // is essentially a surrogate for the DirModifyEntry call.

                *pfContinue = FALSE;

                if ( SampBeginLoopbackTransactioning(pTHS, &transState, FALSE) )
                {
                    return(pTHS->errCode);
                }

                pTHS->pSamLoopback = pSamLoopback;

                //
                // We must execute under an execption handler in here,
                // otherwise exceptions in inside SampAddLoopback, while 
                // not actually inside SAM, will be handled by the top 
                // level handler which will not release the SAM lock.
                //

                __try
                {
                    // Add the object via SAM.

                    ulErr = SampAddLoopback(
                                    iClass,
                                    domainModifyRightsRequired,
                                    objectModifyRightsRequired,
                                    GroupType
                                    );
                }
                __except (HandleMostExceptions(GetExceptionCode()))
                {
                    //
                    // Set the correct error based on the exception code
                    //

                    ulErr = SampHandleLoopbackException(GetExceptionCode());

                }

                SampEndLoopbackTransactioning(pTHS, &transState);

                if (0!=ulErr)
                {

                    Assert((0!=pTHS->errCode) &&"Error not set in thread state");
                    ulErr = CheckObjDisclosure(pTHS,pAddArg->pResParent,FALSE);
                }

                return(ulErr);
            }
        }

        if ((!fLoopbackRequired) &&
           (SampSamUniqueAttributeAdded(pAddArg)))
        {
            //
            // If an Attribute like ObjectSid or Account Name is referenced
            // and the call is not going through loopback then the fail the
            // call.
            //
                        
            SetSvcError(
                SV_PROBLEM_WILL_NOT_PERFORM,
                DIRERR_ILLEGAL_MOD_OPERATION);
            
             return(CheckObjDisclosure(pTHS,pAddArg->pResParent,FALSE));;
        }

    }
    else if ( pTHS->fSAM && (NULL != pTHS->pSamLoopback) 
               && (LoopbackAdd==((SAMP_LOOPBACK_ARG *)pTHS->pSamLoopback)->type) )
    {
        // This is the loopback case.  I.e. A call came in to the DSA
        // via some agent other than SAM but referenced SAM attributes.
        // The 'SAM-owned' attributes were split off and looped back
        // through SAM resulting in getting to this point.  We now need
        // to merge the 'non-SAM-owned' attributes back in and let the 
        // normal write path complete.

        pSamLoopback = (SAMP_LOOPBACK_ARG *) pTHS->pSamLoopback;

        if ( NameMatched(pAddArg->pObject, pSamLoopback->pObject) )
        {
            // NULL out pTHS->pSamLoopback so we don't re-merge on 
            // subsequent calls in case the original operation results
            // in multiple SAM calls.

            pTHS->pSamLoopback = NULL;
    
            SampAddLoopbackMerge(pSamLoopback, pAddArg);
        }
    }

    return(0);
}

ULONG
SampAddLoopback(
    ULONG       iClass,
    ACCESS_MASK domainModifyRightsRequired,
    ACCESS_MASK objectModifyRightsRequired,
    ULONG       GroupType
    )

/*++

Routine Description:

    Surrogate for a DirAddEntry call which is adding a SAM class of
    object.  

Arguments:

    iClass - index into ClassMappingTable representing the kind of
        object being added.

    domainModifyRightsRequired - rights required on the domain to modify
        the properties of interest.

    objectModifyRightsRequired - rights required on the object to modify
        the properties of interest.

    GroupType -- For Group Creation specifies the Group Type

Return Value:

    0 on success, !0 otherwise.

--*/

{
    THSTATE             *pTHS=pTHStls;
    SAMP_LOOPBACK_ARG   *pSamLoopback = pTHS->pSamLoopback;
    PDSNAME             pParent;
    PDSNAME             pErrName;
    NT4SID              domainSid;
    ULONG               parentRid;
    ULONG               objectRid=0; // must initialize to 0
    DWORD               dwErr;
    NTSTATUS            status = STATUS_SUCCESS;
    SAMPR_HANDLE        hSam;
    SAMPR_HANDLE        hDom;
    SAMPR_HANDLE        hDomObj;
    SAMPR_HANDLE        hObj;
    RPC_UNICODE_STRING  rpcString;
    ULONG               writeErr = 0;
    ULONG               iDom;
    ULONG               iAccount;
    ATTRTYP             accountNameAttrTyp;
    ULONG               cBytes;
    DIRERR              *pSavedErrInfo;
    ULONG               SavedErrorCode;
    ATTR                *pAttr;
    ULONG               grantedAccess;
    CROSS_REF           *pCR;
    COMMARG             commArg;
    ULONG               desiredAccess;
    ULONG               userAccountType = 0;
    ATTRBLOCK           * pObjB;

   

    // We only support addition of groups, aliases and users via
    // the loopback mechanism.  Domains and servers, for example,
    // are disallowed.

    //
    // We are running as the DS at this point
    //

    SampSetDsa(TRUE);

    if ( (SampGroupObjectType != ClassMappingTable[iClass].SamObjectType) &&
         (SampAliasObjectType != ClassMappingTable[iClass].SamObjectType) &&
         (SampUserObjectType != ClassMappingTable[iClass].SamObjectType) )
    {
        SetSvcError(
                SV_PROBLEM_WILL_NOT_PERFORM,
                DIRERR_ILLEGAL_MOD_OPERATION);
        return(pTHS->errCode);
    }

    // Derive the domain this object will reside in and verify that
    // its parent exists.  In product 1, there is only one authoritive
    // domain per DC so the derivation is trivial.

    // RAID - 72412 - Prevent adding security principals to config and
    // schema containers.  If we support arbitrary partitoning within the
    // domain in the future, then a better check which identifies the
    // exact naming context may be required.

    // RAID - 99891 - Don't compare client's string name directly against 
    // gAnchor DSNAMEs as client's string name may have embedded spaces and
    // NamePrefix() handles only syntacticaly identical string names, not
    // semantically identical string names.

    pErrName = NULL;
    InitCommarg(&commArg);


    dwErr = DSNameToBlockName(pTHS, pSamLoopback->pObject, &pObjB, DN2BN_LOWER_CASE); 
    if ( dwErr )
    {
        SetNamErrorEx(NA_PROBLEM_BAD_NAME,
                      pSamLoopback->pObject,
                      DIRERR_BAD_NAME_SYNTAX,
                      dwErr);
        return (pTHS->errCode);
    }

    pCR = FindCrossRef(pObjB, &commArg);
    FreeBlockName( pObjB );
    
    // Now compare the naming context found against the domain for which
    // this DC is authoritive.  Expectation is that DSNAMEs in pCR->pNC and
    // gAnchor.pDomainDN have GUIDs, thus NameMatched will mach on GUID.

    if ( pCR && NameMatched(pCR->pNC, gAnchor.pDomainDN) )
    {
        pParent = THAllocEx(pTHS, pSamLoopback->pObject->structLen);

        if ( 0 == TrimDSNameBy(pSamLoopback->pObject, 1, pParent) )
        {
            __try
            {
                dwErr = DBFindDSName(pTHS->pDB, pParent);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( 0 == dwErr )   // we find the parent object
            {
                //
                // if gulUnlockSystemSubtree == 0, meaning system
                // container is locked, do not allow object creation
                // under system container.
                //

                if (!gulUnlockSystemSubtree &&
                    IsUnderSystemContainer(pTHS, pTHS->pDB->DNT)
                    )
                {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER);

                    return( pTHS->errCode );
                }
            }
            else
            {
                // Parent doesn't exist.

                pErrName = pParent;
            }
        }
        else
        {
            // Object name is either malformed or had only one component,
            // i.e. was not the child of some other object.

            pErrName = pSamLoopback->pObject;
        }
    }
    else
    {
        // Domain DN is not a prefix of object DN or we dislike where
        // the object is being created.

        pErrName = pSamLoopback->pObject;
    }

    if ( NULL != pErrName )
    {
        SetSvcError(
                SV_PROBLEM_WILL_NOT_PERFORM,
                ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC);

        return(pTHS->errCode);
    }

    // Find the domain class entry in the class mapping table.

    for ( iDom = 0; iDom < cClassMappingTable; iDom++ )
    {
        if ( SampDomainObjectType == ClassMappingTable[iDom].SamObjectType )
        {
            break;
        }
    }

    Assert(iDom < cClassMappingTable);

    // We also know we're going to need the account name property to
    // do the create so find it in the ADDARGs now.  The account name
    // property is the same for all SAM objects so we can pick any
    // object type to derive the mapping the DS attribute.

    accountNameAttrTyp = SampDsAttrFromSamAttr(
                                    SampUserObjectType,
                                    SAMP_USER_ACCOUNT_NAME);

    for ( iAccount = 0; iAccount < pSamLoopback->cCallMap; iAccount++ )
    {
        if ( accountNameAttrTyp ==
                        pSamLoopback->rCallMap[iAccount].attr.attrTyp )
        {
            break;
        }
    }

    if ( iAccount >= pSamLoopback->cCallMap )
    {
        // Account name wasn't supplied -- Set the account name to NULL.
        // SAM will default the account name to a value that uses the name
        // and the RID of the account

        rpcString.Length = 0;
        rpcString.MaximumLength = 0;
        rpcString.Buffer = NULL;

    }
    else
    {

        if ( 1 != pSamLoopback->rCallMap[iAccount].attr.AttrVal.valCount )
        {
            SetAttError(
                    pSamLoopback->pObject,
                    accountNameAttrTyp,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, 
                    NULL,
                    DIRERR_SINGLE_VALUE_CONSTRAINT);

            return(pTHS->errCode);
        }

        // Add the right kind of object.  SamrCreate<type>InDomain
        // will come back to the DS as another DirAddEntry call.
        // SAM creation routine expects the account name, not the
        // DN or even RDN.

        rpcString.Length = (USHORT) 
            pSamLoopback->rCallMap[iAccount].attr.AttrVal.pAVal[0].valLen;
        rpcString.MaximumLength = rpcString.Length;
        rpcString.Buffer = (PWCH)
            pSamLoopback->rCallMap[iAccount].attr.AttrVal.pAVal[0].pVal;
    }

    //
    // Open the domain. Do not ask for Add rights as the parent is not necessarily
    // the domain object. When the DS access checks again for the Create, then
    // as part of the creation it will check the rights on the parent object
    //

    if ( 0 != SampOpenObject(
                    pTHS,
                    gAnchor.pDomainDN,
                    iDom,
                    domainModifyRightsRequired,
                    objectModifyRightsRequired,
                    &hSam,
                    &hDom,
                    &hDomObj) )
    {
        Assert(0 != pTHS->errCode);
        return(pTHS->errCode);
    }
    

    

    switch (ClassMappingTable[iClass].SamObjectType)
    {
    case SampAliasObjectType:

        desiredAccess = ALIAS_ALL_ACCESS;

        break;

    case SampGroupObjectType:

        desiredAccess = GROUP_ALL_ACCESS;

        break;

    case SampUserObjectType:

        // Derive the proper account type if possible so that we can 
        // optimize the SAM create call.

        desiredAccess = USER_ALL_ACCESS;
        userAccountType = USER_NORMAL_ACCOUNT;  // default value

        for ( iAccount = 0; iAccount < pSamLoopback->cCallMap; iAccount++ )
        {
            ULONG *pUF_flags;

            pAttr = &pSamLoopback->rCallMap[iAccount].attr;
            
            if (    (ATT_USER_ACCOUNT_CONTROL == pAttr->attrTyp)
                 && (1 == pAttr->AttrVal.valCount)
                 && (NULL != pAttr->AttrVal.pAVal)
                 && (sizeof(ULONG) == pAttr->AttrVal.pAVal[0].valLen)
                 && (NULL != pAttr->AttrVal.pAVal[0].pVal) )
            {
                pUF_flags = (ULONG *) pAttr->AttrVal.pAVal[0].pVal;

                status = SampFlagsToAccountControl(
                                *pUF_flags & UF_ACCOUNT_TYPE_MASK,
                                &userAccountType);

                // SAM defaults various bits in the ATT_USER_ACCOUNT_CONTROL
                // during SampCreateUserInDomain() below.  So we need to
                // leave pSamLoopback->rCallMap[iAccount].fIgnore as FALSE
                // so as to reset them to EXACTLY what the client specified
                // in the original ADDARG.

                Assert(!pSamLoopback->rCallMap[iAccount].fIgnore);
                    
                break;
            }
        }

        break;

    default:

        Assert(!"Logic error");
        status = STATUS_UNSUCCESSFUL;
        break;

    }

    if (NT_SUCCESS(status))
    {
        status = SamIDsCreateObjectInDomain(
                                    hDom,           // Domain Handle
                                    ClassMappingTable[iClass].SamObjectType,
                                                    // ObjectType
                                    &rpcString,     // Account Name,
                                    userAccountType,// User Account Type
                                    GroupType,      // Group Type
                                    desiredAccess,  // Desired Access
                                    &hObj,          // Account Handle
                                    &grantedAccess, // Granted Access
                                    &objectRid      // Object Rid
                                    );
    }

    // Save Error Information from pTHS. SAM close
    // handles can clear error information
    SavedErrorCode = pTHS->errCode;
    pSavedErrInfo  = pTHS->pErrInfo;

    if ( NT_SUCCESS(status) )
    {
        // The new object has been successfully created.  Now
        // set any required attributes.

        writeErr = SampWriteSamAttributes(
                                pTHS,
                                LoopbackAdd,
                                hObj,
                                iClass,
                                pSamLoopback->pObject,
                                pSamLoopback->cCallMap,
                                pSamLoopback->rCallMap);

        // Save Error Information from pTHS. SAM close
        // handles can clear error information
        SavedErrorCode = pTHS->errCode;
        pSavedErrInfo  = pTHS->pErrInfo;

        SamrCloseHandle(&hObj);
    }

    SampCloseObject(pTHS, iDom, &hSam, &hDom, &hDomObj);

    // Restore Saved Error codes from pTHS
    pTHS->errCode = SavedErrorCode ;
    pTHS->pErrInfo = pSavedErrInfo;
    
    // Map NTSTATUS error if there was one.

    if ( !NT_SUCCESS(status) )
    {
        SampMapSamLoopbackError(status);
        return(pTHS->errCode);
    }

    // SampWriteSamAttributes should have set pTHS->errCode.

    Assert(0 == writeErr ? 0 == pTHS->errCode : 0 != pTHS->errCode);
    
    return(pTHS->errCode);
}

VOID
SampAddLoopbackMerge(
    SAMP_LOOPBACK_ARG   *pSamLoopback,
    ADDARG              *pAddArg
    )

/*++

Routine Description:

    Merges all NonSamWriteAllowed attributes from the original call
    back into the current call. 

Arguments:

    pSamLoopback - pointer to SAMP_LOOPBACK_ARG arguments.

    pAddArg - pointer to current ADDARGs.

Return Value:

    None.

--*/

{
    THSTATE *pTHS=pTHStls;
    ULONG   i;
    ULONG   cExtend;
    int     iAddArgSid = -1;
    int     iAddArgClass = -1;
    int     iAddArgAccountName = -1;
    int     iAddArgAccountType = -1;
#if DBG == 1
    ULONG   valCount1, valCount2;
    ULONG   valLen1, valLen2;
    UCHAR   *pVal1, *pVal2;
#endif

    // By the time we get here there are two DirAddEntry calls in the
    // call stack.  The oldest is from a non-SAM interface like LDAP.
    // The most recent is from SAM in response to a SamrCreate<type>InDomain
    // call made by this module.  The contract with SAM is that it 
    // provides  at least 4 attributes when initially creating an
    // object in the DS, and optionally the user account control field
    // These four properties are:
    //
    // 1) Object SID.  The RID component of the SID should be unique within
    //    the domain and the domain component of the SID should match that
    //    of the containing/owning domain.  We trust SAM to get this right.
    //
    // 2) Object class.  SAM always hands in one of User/Group/Alias/etc.
    //    since it doesn't know anything about the inheritance hierarchy.
    //    So we need to whack the object class property back to what the
    //    user wanted.  We only got donw this path originally because 
    //    SampSamClassReferenced() returned TRUE, thus we know the originally
    //    desired object class is available in the loopback arguments.
    //    
    // 3) SAM account name.  This should be the same as the account name
    //    provided by the original caller.  Its existence was verified
    //    earlier thus we know it is available in the loopback arguments.
    //
    // 4) SAM account Type   This is the account Type attribute set by SAM
    //    to speed up display cache changes
    //


    // Figure out the location of the three required properties.

    for ( i = 0; i < pAddArg->AttrBlock.attrCount; i++ )
    {
        switch ( pAddArg->AttrBlock.pAttr[i].attrTyp )
        {
        case ATT_OBJECT_SID:

            Assert(-1 == iAddArgSid);
            iAddArgSid = (int) i;
            break;

        case ATT_OBJECT_CLASS:

            Assert(-1 == iAddArgClass);
            iAddArgClass = (int) i;
            break;

        case ATT_SAM_ACCOUNT_NAME:

            Assert(-1 == iAddArgAccountName);
            iAddArgAccountName = (int) i;
            break;

        case ATT_SAM_ACCOUNT_TYPE:
            Assert(-1 == iAddArgAccountType);
            iAddArgAccountType = (int) i;
            break;

        default:

            break;
        }
    }

    // Assert that all required properties were found.

    Assert((-1 != iAddArgSid) &&
           (-1 != iAddArgClass) &&
           (-1 != iAddArgAccountName)&&
           (-1 != iAddArgAccountType));

    // Patch up the object class and verify the account name.

    for ( i = 0; i < pSamLoopback->cCallMap; i++ )
    {
        if ( ATT_OBJECT_CLASS == pSamLoopback->rCallMap[i].attr.attrTyp )
        {
            // Replace SAM class with original caller's desired class.

            pAddArg->AttrBlock.pAttr[iAddArgClass].AttrVal = 
                                pSamLoopback->rCallMap[i].attr.AttrVal;

            // Mark this entry in the call mapping so that we do not
            // process it again when we're merging in properties.

            pSamLoopback->rCallMap[i].fIgnore = TRUE;
        }
        else if ( ATT_SAM_ACCOUNT_NAME == 
                                pSamLoopback->rCallMap[i].attr.attrTyp )
        {
#if DBG == 1
            // Verify SAM didn't change the account name on us.

            valCount1 = 
                pAddArg->AttrBlock.pAttr[iAddArgAccountName].AttrVal.valCount;
            valCount2 = 
                pSamLoopback->rCallMap[i].attr.AttrVal.valCount;
            valLen1 = 
                pAddArg->AttrBlock.pAttr[iAddArgAccountName].AttrVal.pAVal[0].valLen;
            valLen2 =
                pSamLoopback->rCallMap[i].attr.AttrVal.pAVal[0].valLen;
            pVal1 = 
                pAddArg->AttrBlock.pAttr[iAddArgAccountName].AttrVal.pAVal[0].pVal;
            pVal2 =
                pSamLoopback->rCallMap[i].attr.AttrVal.pAVal[0].pVal;

            Assert((valCount1 == valCount2) &&
                   (valLen1 == valLen2) &&
                   (0 == memcmp(pVal1, pVal2, valLen1)));
#endif

            // Mark this entry in the call mapping so that we do not
            // process it again when we're merging in properties.

            pSamLoopback->rCallMap[i].fIgnore = TRUE;
        }
    }

    // By now, pAddArg has been sanity checked and references the
    // originally desired object class.  We now marge in all the non-SAM
    // properties which the caller originally specified so that the
    // create doesn't fail due to the lack of mandatory properties.

    cExtend = 0;

    for ( i = 0; i < pSamLoopback->cCallMap; i++ )
    {
        if ( !pSamLoopback->rCallMap[i].fSamWriteRequired &&
             !pSamLoopback->rCallMap[i].fIgnore )
        {
            cExtend++;
        }
    }

    if ( cExtend > 0 )
    {
        // Extend the existing ATTR array.  Assume for now that SAM
        // allocated its DirAddEntry arguments on the thread heap.

        pAddArg->AttrBlock.pAttr = (ATTR *) THReAllocEx(pTHS,
                    pAddArg->AttrBlock.pAttr,
                    ((pAddArg->AttrBlock.attrCount + cExtend) * sizeof(ATTR)));

        for ( i = 0; i < pSamLoopback->cCallMap; i++ )
        {
            if ( !pSamLoopback->rCallMap[i].fSamWriteRequired &&
                 !pSamLoopback->rCallMap[i].fIgnore )
            {
                pAddArg->AttrBlock.pAttr[pAddArg->AttrBlock.attrCount++] =
                        pSamLoopback->rCallMap[i].attr;
            }
        }
    }


    //
    // Turn off fDSA so that the DS may check access on the Non SAM properties 
    //
    SampSetDsa(FALSE);

}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DirRemoveEntry loopback loopback routines                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
SampRemoveLoopbackCheck(
    REMOVEARG   *pRemoveArg,
    BOOL        *pfContinue
    )

/*++

Routine Description:

    Determines whether a SAM class is being referenced and if so, 
    recurses back through SAM to delete the object.

Arguments:

    pRemoveArg - pointer to original DirRemoveEntry REMOVEARGs.

    pfContinue - pointer to BOOL which is set on return to indicate whether
        the caller should continue processing the modify down to the DB layer
        or not.

Return Value:

    0 on success, !0 otherwise.

--*/
{
    THSTATE                 *pTHS=pTHStls;
    ULONG                   iClass;
    ULONG                   ulErr;
    CLASSCACHE              *pClassCache;
    GUID                    guid;
    NTSTATUS                status;
    ULONG                   GroupType;
    LoopbackTransState      transState;

    *pfContinue = TRUE;

    if ( !gfDoSamChecks || !gfRunningInsideLsa )
    {
        return(FALSE);
    }

    // See if this is pass 1 (original call via some agent other than SAM) 
    // or pass N (loopback call via SAM).

    if ( !pTHS->fDRA && !pTHS->fDSA && !pTHS->fSAM )
    {
        // This is a call from some agent other than SAM and is also
        // not an internal operation.  If any 'SAM-owned' attributes are
        // being referenced, they need to be split off and looped back
        // through SAM who will perform various semantic checks on them.

        // First get the object's class.

        if ( 0 != SampDetermineObjectClass(pTHS, &pClassCache) )
        {
            return(CheckObjDisclosure(pTHS,pRemoveArg->pResObj,FALSE));;
        }

        if ( SampSamClassReferenced(pClassCache, &iClass) )
        {
            ULONG domainRightsFromAccessCheck=0;
            ULONG objectRightsFromAccessCheck=0;

            // Indicate that calling DirRemoveEntry routine should
            // not continue in its normal path.  Ie: SampRemoveLoopback
            // is essentially a surrogate for the DirRemoveEntry call.

            *pfContinue = FALSE;

            //
            // if the object is a group object, adjust the right 
            // SAM class depending upon its group type
            //

            if (SampGroupObjectType==
                    ClassMappingTable[iClass].SamObjectType)
            {
                if (0!=SampGetGroupType(pTHS, &GroupType))
                {
                    return (CheckObjDisclosure(pTHS,pRemoveArg->pResObj,FALSE));
                }

                if (GroupType & GROUP_TYPE_RESOURCE_BEHAVOIR)
                {
                    iClass++;
                }
            }

            if (0!= SampDoLoopbackRemoveSecurityChecks(
                            pTHS,
                            pRemoveArg,
                            pClassCache,
                            &domainRightsFromAccessCheck,
                            &objectRightsFromAccessCheck
                            ))
            {
                return (CheckObjDisclosure(pTHS,pRemoveArg->pResObj,TRUE));
            }

            if ( SampBeginLoopbackTransactioning(pTHS, &transState, FALSE) )
            {
                return(CheckObjDisclosure(pTHS,pRemoveArg->pResObj,FALSE));
            }

            //
            // We must execute under an execption handler in here,
            // otherwise exceptions in inside SampAddLoopback, while 
            // not actually inside SAM, will be handled by the top 
            // level handler which will not release the SAM lock.
            //

            __try 
            {
                // Loop back through SAM to remove the object.

                ulErr = SampRemoveLoopback(pTHS, pRemoveArg->pObject, iClass);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                //
                // Set the correct error based on the exception code
                //

                ulErr = SampHandleLoopbackException(GetExceptionCode());

            }

            SampEndLoopbackTransactioning(pTHS, &transState);

            return(ulErr);
        }
    }

    return(0);
}

ULONG
SampRemoveLoopback(
    THSTATE *pTHS,
    DSNAME  *pObject,
    ULONG   iClass)

/*++

Routine Description:

    Loops back through SAM to remove an object which SAM manages.

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

Return Value:

    0 on success, !0 otherwise.

--*/

{
    SAMPR_HANDLE            hSam;
    SAMPR_HANDLE            hDom;
    SAMPR_HANDLE            hObj;
    SAMP_OBJECT_TYPE        SamObjectType;
    NTSTATUS                status = STATUS_SUCCESS;


    SamObjectType = ClassMappingTable[iClass].SamObjectType;

    //
    // Turn on the fDSA flag as we  are going to make SAM calls and
    // SAM will do the access Validation
    //

    SampSetDsa(TRUE);


    // We only support removeal of groups, aliases and users via
    // the loopback mechanism.  Domains and servers, for example,
    // are disallowed.

    if ( (SampGroupObjectType != ClassMappingTable[iClass].SamObjectType) &&
         (SampAliasObjectType != ClassMappingTable[iClass].SamObjectType) &&
         (SampUserObjectType != ClassMappingTable[iClass].SamObjectType) )
    {
        SetSvcError(
                SV_PROBLEM_WILL_NOT_PERFORM,
                DIRERR_ILLEGAL_MOD_OPERATION);
        return(pTHS->errCode);
    }

    if ( 0 == SampOpenObject(
                        pTHS,
                        pObject,
                        iClass, 
                        ClassMappingTable[iClass].domainRemoveRightsRequired,
                        ClassMappingTable[iClass].objectRemoveRightsRequired,
                        &hSam, 
                        &hDom, 
                        &hObj) )
    {
        switch (SamObjectType )
        {
        case SampAliasObjectType:
    
            status = SamrDeleteAlias(&hObj);
            break;
    
        case SampGroupObjectType:
    
            status = SamrDeleteGroup(&hObj);
            break;
    
        case SampUserObjectType:
    
            status = SamrDeleteUser(&hObj);
            break;
    
        default:
    
            Assert(!"Logic error");
            status = STATUS_UNSUCCESSFUL;
            break;
    
        }
    
        if ( !NT_SUCCESS(status) )
        {
            SampMapSamLoopbackError(status);
        }

        SampCloseObject(pTHS, iClass, &hSam, &hDom, &hObj);
    }

    return(pTHS->errCode);
}

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// DirModifyEntry loopback routines                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
SampModifyLoopbackCheck(
    MODIFYARG   *pModifyArg,
    BOOL        *pfContinue,
    BOOL        fIsUndelete
    )

/*++

Routine Description:

    Determines whether SAM class and attributes are being referenced,
    and if so, recurses back through SAM.  Similarly, the routine
    detects if this is the recursion case and merges back the original,
    non-SAM attributes.

Arguments:

    pModifyArg - pointer to MODIDFYARGs representing either the arguments
        or an original write or the SAM-only arguments of a SAM-recursed 
        write.

    pfContinue - pointer to BOOL which is set on return to indicate whether
        the caller should continue processing the modify down to the DB layer
        or not.
        
    fIsUndelete - is this an undelete operation?        

Return Value:

    0 on success, !0 otherwise

--*/
{
    THSTATE                 *pTHS=pTHStls;
    ULONG                   ulErr;
    ULONG                   iClass;
    CLASSCACHE              *pClassCache;
    SAMP_LOOPBACK_ARG       *pSamLoopback;
    GUID                    guid;
    BOOL                    fLoopbackRequired;
    BOOL                    fUserPasswordSupport;
    ULONG                   cCallMap;
    SAMP_CALL_MAPPING       *rCallMap;
    ACCESS_MASK             domainModifyRightsRequired;
    ACCESS_MASK             objectModifyRightsRequired;
    NTSTATUS                status;
    ULONG                   GroupType;
    LoopbackTransState      transState;
    
    *pfContinue = TRUE;

    if ( !gfDoSamChecks || !gfRunningInsideLsa )
    {
        return(FALSE);
    }

    // See if this is pass 1 (original call via some agent other than SAM) 
    // or pass N (loopback call via SAM).

    if ( !pTHS->fDRA && !pTHS->fDSA && !pTHS->fSAM )
    {
        // This is a call from some agent other than SAM and is also
        // not an internal operation.  If any 'SAM-owned' attributes are
        // being referenced, they need to be split off and looped back
        // through SAM who will perform various semantic checks on them.

        // First get the object's class.

        if ( 0 != SampDetermineObjectClass(pTHS, &pClassCache) )
        {
             return(CheckObjDisclosure(pTHS,pModifyArg->pResObj,FALSE));
        }

        if ( SampSamClassReferenced(pClassCache, &iClass) )
        {

            //
            // if the object is a group object, adjust the right 
            // SAM class depending upon its group type
            //

            if (SampGroupObjectType==
                    ClassMappingTable[iClass].SamObjectType)
            {
                if (0!=SampGetGroupType(pTHS, &GroupType))
                {
                    return(CheckObjDisclosure(pTHS,pModifyArg->pResObj,FALSE));
                }

                if (GroupType & GROUP_TYPE_RESOURCE_BEHAVOIR)
                {
                    iClass++;
                }
            }

            if ( 0 != SampModifyLoopbackRequired(
                                    iClass, 
                                    pModifyArg, 
                                    &fLoopbackRequired,
                                    &fUserPasswordSupport) )
            {
                Assert(0 != pTHS->errCode);

                return(CheckObjDisclosure(pTHS,pModifyArg->pResObj,FALSE));
            }

            if ( fLoopbackRequired )
            {
                ULONG domainRightsFromAccessCheck=0;
                ULONG objectRightsFromAccessCheck=0;

                
                //
                // Do Access Checks
                //

                if (0 != SampDoLoopbackModifySecurityChecks(
                            pTHS,
                            pModifyArg,
                            pClassCache,
                            &domainRightsFromAccessCheck,
                            &objectRightsFromAccessCheck,
                            fIsUndelete
                            ))
                {
                      return(CheckObjDisclosure(pTHS,pModifyArg->pResObj,TRUE));
                }

             

                // This is a class SAM wants to handle adds for - let it.
                // Generate/save loop back arguments and recurse through SAM.
    
                SampBuildModifyCallMap(
                                pModifyArg, 
                                iClass, 
                                &cCallMap, 
                                &rCallMap,
                                &domainModifyRightsRequired,
                                &objectModifyRightsRequired,
                                fUserPasswordSupport);

                pSamLoopback = THAllocEx(pTHS, sizeof(SAMP_LOOPBACK_ARG));
                pSamLoopback->type = LoopbackModify;

                // grab the flag from the original request
                pSamLoopback->fPermissiveModify = pModifyArg->CommArg.Svccntl.fPermissiveModify;
                pSamLoopback->MostSpecificClass = pClassCache->ClassId;

                domainModifyRightsRequired |= domainRightsFromAccessCheck;
                objectModifyRightsRequired |= objectRightsFromAccessCheck;

                ulErr = SampGetDSName(pTHS, &pSamLoopback->pObject);

                if ( 0 != ulErr )
                {
                    Assert(0 != pTHS->errCode);

                    return(CheckObjDisclosure(pTHS,pModifyArg->pResObj,TRUE));
                }

                pSamLoopback->cCallMap = cCallMap;
                pSamLoopback->rCallMap = rCallMap;
                
                // Indicate that calling DirModifyEntry routine should
                // not continue in its normal path.  Ie: SampModifyLoopback
                // is essentially a surrogate for the DirModifyEntry call.

                *pfContinue = FALSE;
    
                if ( SampBeginLoopbackTransactioning(pTHS, &transState, FALSE) )
                {
                    return(pTHS->errCode);
                }

                pTHS->pSamLoopback = pSamLoopback;

                //
                // We must execute under an execption handler in here,
                // otherwise exceptions in inside SampAddLoopback, while 
                // not actually inside SAM, will be handled by the top 
                // level handler which will not release the SAM lock.
                //

                __try
                {
                    if (fIsUndelete) {
                        ulErr = SampReconstructUserOrGroup(pTHS, pSamLoopback->pObject, iClass);
                        if (ulErr) __leave;
                    }

                    // Map modification of SAM properties to Samr* calls.
                    ulErr = SampModifyLoopback(
                                    pTHS,
                                    iClass,
                                    domainModifyRightsRequired,
                                    objectModifyRightsRequired);
                }
                __except (HandleMostExceptions(GetExceptionCode()))
                {
                    //
                    // Set the correct error based on the exception code
                    //

                    ulErr = SampHandleLoopbackException(GetExceptionCode());

                }

                SampEndLoopbackTransactioning(pTHS, &transState);

                if (0!=ulErr)
                {

                    Assert((0!=pTHS->errCode) &&"Error not set in thread state");
                    ulErr = CheckObjDisclosure(pTHS,pModifyArg->pResObj,FALSE);
                }


                return(ulErr);
            }
            else if (fIsUndelete) {
                // we are doing an undelete of a sam object, but not touching any
                // sam attributes. Just reconstruct the missing required attributes.
                return SampReconstructUserOrGroup(pTHS, pModifyArg->pObject, iClass);
            }
        }
        else if (SampSamUniqueAttributeModified(pModifyArg))
        {
            //
            // If an Attribute like ObjectSid or Account Name is referenced
            // and it is not a 
            //
                        
            SetSvcError(
                SV_PROBLEM_WILL_NOT_PERFORM,
                DIRERR_ILLEGAL_MOD_OPERATION);

            return(CheckObjDisclosure(pTHS,pModifyArg->pResObj,FALSE));
        }
    }
    else if ( pTHS->fSAM && (NULL != pTHS->pSamLoopback) 
            && (LoopbackModify==((SAMP_LOOPBACK_ARG *)pTHS->pSamLoopback)->type) )
    {
        // This is the loopback case.  I.e. A call came in to the DSA
        // via some agent other than SAM but referenced SAM attributes.
        // The 'SAM-owned' attributes were split off and looped back
        // through SAM resulting in getting to this point.  We now need
        // to merge the 'non-SAM-owned' attributes back in and let the 
        // normal write path complete.

        if ( 0 != SampGetObjectGuid(pTHS, &guid) )
        {
            return(pTHS->errCode);
        }

        pSamLoopback = (SAMP_LOOPBACK_ARG *) pTHS->pSamLoopback;

        if ( 0 == memcmp(&guid, &pSamLoopback->pObject->Guid, sizeof(GUID)) )
        {
            // NULL out pTHS->pSamLoopback so we don't re-merge on
            // subsequent calls in case the original operation results
            // in multiple SAM calls.

            pTHS->pSamLoopback = NULL;
    
            SampModifyLoopbackMerge(pTHS, pSamLoopback, pModifyArg);
        }
    }

    return(0);
}

ULONG
SampModifyLoopback(
    THSTATE     *pTHS,
    ULONG       iClass,
    ACCESS_MASK domainModifyRightsRequired,
    ACCESS_MASK objectModifyRightsRequired
    )

/*++

Routine Description:

    Writes all SAM-owned properties via the required Samr* calls.

Arguments:

    iClass - index of the SAM class in ClassMappingTable.

    domainModifyRightsRequired - rights required on the domain to modify the 
        properties of interest.

    objectModifyRightsRequired - rights required on the object to modify the 
        properties if interest.
        
Return Value:

    0 on success, !0 otherwise.

--*/

{
    SAMP_LOOPBACK_ARG   *pSamLoopback = pTHS->pSamLoopback;
    SAMPR_HANDLE        hSam;
    SAMPR_HANDLE        hDom;
    SAMPR_HANDLE        hObj;
    ULONG               err;

    
    //
    // Turn on the fDSA flag as we are about to make SAM calls
    //

    SampSetDsa(TRUE);

    err = SampOpenObject(
                    pTHS,
                    pSamLoopback->pObject,
                    iClass, 
                    domainModifyRightsRequired,
                    objectModifyRightsRequired,
                    &hSam, 
                    &hDom, 
                    &hObj);

    if ( 0 == err )
    {
        err = SampWriteSamAttributes(
                                pTHS,
                                LoopbackModify,
                                hObj,
                                iClass,
                                pSamLoopback->pObject,
                                pSamLoopback->cCallMap,
                                pSamLoopback->rCallMap);
        
        SampCloseObject(
                    pTHS,
                    iClass, 
                    &hSam, 
                    &hDom, 
                    &hObj);
    }

    return(err);
}

VOID
SampModifyLoopbackMerge(
    THSTATE             *pTHS,
    SAMP_LOOPBACK_ARG   *pSamLoopback,
    MODIFYARG           *pModifyArg
    )

/*++

Routine Description:

    Merges original !SAM attributes with the looped back SAM attributes.

Arguments:

    pSamLoopback - pointer to SAMP_LOOPBACK_ARG representing saved loopback
        arguments.

    pModifyArg - pointer to MODIFYARGs of looped back SAM call.

Return Value:

    None.

--*/

{
    ULONG       i;
    USHORT      index;
    USHORT      cExtend;
    ATTRMODLIST *rNewAttrModList;

    // Count how many new attributes we need to extend by.

    cExtend = 0;

    for ( i = 0; i < pSamLoopback->cCallMap; i++ )
    {
        if ( !pSamLoopback->rCallMap[i].fSamWriteRequired )
        {
            cExtend++;
        }
    }

    if ( 0 == cExtend )
    {
        return;
    }

    // Allocate a new ATTRMODLIST.  We allocate it as an array and then
    // patch up the pointers to make it look like a linked list.

    rNewAttrModList = THAllocEx(pTHS, cExtend * sizeof(ATTRMODLIST));

    // Fill in the new ATTRMODLIST.

    index = 0;

    for ( i = 0; i < pSamLoopback->cCallMap; i++ )
    {
        if ( !pSamLoopback->rCallMap[i].fSamWriteRequired )
        {
            rNewAttrModList[index].choice = pSamLoopback->rCallMap[i].choice;
            rNewAttrModList[index].AttrInf = pSamLoopback->rCallMap[i].attr;

            if ( ++index == cExtend )
            {
                rNewAttrModList[index-1].pNextMod = NULL;
            }
            else
            {
                rNewAttrModList[index-1].pNextMod = 
                                &rNewAttrModList[index];
            }
        }
    }

    Assert(index == cExtend);

    // Extend the Sam modify args by the new ATTRMODLIST.  We stick it
    // in between the first and second elements because this is easy
    // and it seems no one cares about their ordering.

    pModifyArg->count += cExtend;
    rNewAttrModList[cExtend-1].pNextMod = pModifyArg->FirstMod.pNextMod;
    pModifyArg->FirstMod.pNextMod = rNewAttrModList;

    // set the flag from the original request
    if (pSamLoopback->fPermissiveModify) {
        pModifyArg->CommArg.Svccntl.fPermissiveModify = TRUE;
    }

    //
    // Turn off fDSA so that the DS may check access on the Non SAM properties 
    //
    SampSetDsa(FALSE);
}

BOOL
SampExistsAttr(
    THSTATE             *pTHS,
    SAMP_CALL_MAPPING   *pMapping,
    BOOL                *pfValueMatched
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD   dwErr;
    VOID    *pv;
    ULONG   outLen;

    *pfValueMatched = FALSE;

    dwErr = DBGetAttVal_AC(
                    pTHS->pDB,              // DBPos
                    1,                      // which value to get
                    pMapping->pAC,          // which attribute
                    DBGETATTVAL_fREALLOC,   // DB layer should alloc
                    0,                      // initial buffer size
                    &outLen,                // output buffer size
                    (UCHAR **) &pv);

    if ( 0 != dwErr )
    {
        return(FALSE);
    }

    // Value exists - now see if it matches.  Don't need to worry about
    // NULL terminators on string syntaxes because inside the core, string
    // syntax values are not terminated.

    if ( (pMapping->attr.AttrVal.valCount != 0) &&
         (pMapping->attr.AttrVal.pAVal[0].valLen == outLen) &&
         (0 == memcmp(pMapping->attr.AttrVal.pAVal[0].pVal, pv, outLen)) )
    {
        *pfValueMatched = TRUE;
    }

    return(TRUE);
}
        
BOOL
SampIsWriteLockHeldByDs()

/*++

Routine Description:

    Indicates whether the SAM write lock is held by the DS.  This function is
    to support a hook in SampAcquireWriteLock()/SampReleaseWriteLock() that
    allows the DS to acquire and hold the SAM write lock across multiple
    transactions.  When the DS holds this lock, the former SAM calls translate
    into no-ops, deferring control of the locks to the DS.

Arguments:

    None.

Return Value:

    TRUE if the SAM write lock is held by the DS, FALSE otherwise.

--*/

{
    return (    SampExistsDsTransaction()
             && pTHStls->fSamWriteLockHeld );
}

NTSTATUS
SampConvertPasswordFromUTF8ToUnicode(
    IN THSTATE * pTHS,
    IN PVOID Utf8Val,
    IN ULONG Utf8ValLen,
    OUT PUNICODE_STRING Password
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Length;

    //
    // Don't simply convert arbitarily long lengths
    // supplied by the client -- be cautious -- anonymous
    // by default has rights to a password change.
    //

    if (Utf8ValLen > PWLEN)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Blank Password is a special case
    // 

    if (0 == Utf8ValLen)
    {
        Password->Length = 0;
        Password->Buffer = NULL;
        Password->MaximumLength = 0;
        return( STATUS_SUCCESS );
    }

    Length =  MultiByteToWideChar(
                 CP_UTF8,
                 0,
                 Utf8Val,
                 Utf8ValLen,
                 NULL,
                 0
                 );


    if ((0==Length) || (Length > PWLEN))
    {
      //
      // Indicates that the function failed in some way
      // or that the password is too long
      //

      NtStatus = STATUS_INVALID_PARAMETER;
      goto Cleanup;
    }
    else
    {

      Password->Length = (USHORT) Length * sizeof(WCHAR);
      Password->Buffer = THAllocEx(pTHS,Password->Length);
      Password->MaximumLength = Password->Length;

      if (!MultiByteToWideChar(
                  CP_UTF8,
                  0,
                  Utf8Val,
                  Utf8ValLen,
                  Password->Buffer,
                  Length
                  ))
      {
          //
          // Some error occured in the conversion. Return
          // invalid parameter for now.
          //

          NtStatus = STATUS_INVALID_PARAMETER;
          goto Cleanup;
      }
    }

Cleanup:

    return(NtStatus);
}


ULONG
SampModifyPassword(
    THSTATE             *pTHS,
    SAMPR_HANDLE        hObj,
    DSNAME              *pObject,
    SAMP_CALL_MAPPING   *rCallMap)

/*++

Description:

    Morphs the old and new password and calls the appropriate SAM 
    routine to really do the job.

Arguments:

    hObj - Handle to open SAM object being modified.

    pObject - Pointer to DSNAME of object being modified.

    rCallMap - SAMP_CALL_MAPPING with two entries.  0th entry represents
        the old password while 1st entry represents the new password.

Return value:

    0 on success.
    Sets and returns pTHS->errCode on return.

--*/

{
    NTSTATUS                        status;
    ULONG                           cb0 = 0;
    ULONG                           cb1 = 0;
    UNICODE_STRING                  OldPassword;
    UNICODE_STRING                  NewPassword;
    ULONG                           cbAccountName;
    WCHAR                           *pAccountName;
    UNICODE_STRING                  UserName;
    SAMPR_ENCRYPTED_USER_PASSWORD   NewEncryptedWithOldNt;
    ENCRYPTED_NT_OWF_PASSWORD       OldNtOwfEncryptedWithNewNt;
    BOOLEAN                         LmPresent;
    SAMPR_ENCRYPTED_USER_PASSWORD   NewEncryptedWithOldLm;
    ENCRYPTED_NT_OWF_PASSWORD       OldLmOwfEncryptedWithNewNt;
    ULONG                           AttrTyp = rCallMap[0].attr.attrTyp;
    BOOLEAN                         fFreeOldPassword = FALSE;
    BOOLEAN                         fFreeNewPassword = FALSE;

    RtlSecureZeroMemory(&OldPassword,sizeof(UNICODE_STRING));
    RtlSecureZeroMemory(&NewPassword,sizeof(UNICODE_STRING));

    // Verify that this is a secure enough connection - one of the 
    // requirements for accepting passwords sent over the wire.

    if ( pTHS->CipherStrength < 128 )
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, 
                    DIRERR_ILLEGAL_MOD_OPERATION);

        return(pTHS->errCode);
    }

    // Construct parameters for SamrUnicodeChangePasswordUser2().
    // Get SAM account name - recall that our caller, SampWriteSamAttributes,
    // already postioned us at pObject.

    if ( DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_SAM_ACCOUNT_NAME,
                DBGETATTVAL_fREALLOC,
                0,
                &cbAccountName,
                (PUCHAR *) &pAccountName) )
    {
        SetAttError(
                pObject,
                ATT_SAM_ACCOUNT_NAME,
                PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                NULL,
                DIRERR_MISSING_REQUIRED_ATT);
        return(pTHS->errCode);
    }

    // Morph into UNICODE_STRING for SAM.

    UserName.Length = (USHORT) cbAccountName;
    UserName.MaximumLength = (USHORT) cbAccountName;
    UserName.Buffer = (PWSTR) pAccountName;


    // Validate arguments.  SampWriteSamAttributes already checked for
    // proper combination of top level and property operations.  About
    // the only thing left to verify is that the property values represent
    // UNICODE strings - i.e. their length is a multiple of sizeof(WCHAR).
    // Also for User password attribute verify that the domain behaviour 
    // version is at the right level
    //

    if (ATT_UNICODE_PWD == AttrTyp)
    {
        if ((rCallMap[0].attr.AttrVal.valCount > 1)
             || (    (1 == rCallMap[0].attr.AttrVal.valCount) 
                  && (    (NULL == rCallMap[0].attr.AttrVal.pAVal)
                       || (    (rCallMap[0].attr.AttrVal.pAVal[0].valLen > 0)
                            && (    (cb0 = rCallMap[0].attr.AttrVal.pAVal[0].valLen,
                                     cb0 % sizeof(WCHAR))
                                 || (NULL == rCallMap[0].attr.AttrVal.pAVal[0].pVal)
                               )
                          )
                     )
                )
           )
        {
            SetAttError(
                    pObject,
                    AttrTyp,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL,
                    DIRERR_SINGLE_VALUE_CONSTRAINT);
            return(pTHS->errCode);
        }

        if ((rCallMap[1].attr.AttrVal.valCount > 1)
             || (    (1 == rCallMap[1].attr.AttrVal.valCount) 
                  && (    (NULL == rCallMap[1].attr.AttrVal.pAVal)
                       || (    (rCallMap[1].attr.AttrVal.pAVal[0].valLen > 0)
                            && (    (cb1 = rCallMap[1].attr.AttrVal.pAVal[0].valLen,
                                     cb1 % sizeof(WCHAR))
                                 || (NULL == rCallMap[1].attr.AttrVal.pAVal[0].pVal)
                               )
                          )
                     )
                )
           ) 
        {
            SetAttError(
                    pObject,
                    AttrTyp,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL,
                    DIRERR_SINGLE_VALUE_CONSTRAINT);
            return(pTHS->errCode);
        }

        if ( cb0 > 0 )
        {
            OldPassword.Buffer = (PWSTR) rCallMap[0].attr.AttrVal.pAVal[0].pVal;

            // Make sure the password is quoted.
            if (    (cb0 < (2 * sizeof(WCHAR)))
                 || (L'"' != OldPassword.Buffer[0])
                 || (L'"' != OldPassword.Buffer[(cb0 / sizeof(WCHAR)) - 1])
               )
            {
                SetAttError(
                        pObject,
                        ATT_UNICODE_PWD,
                        PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                        NULL,
                        ERROR_DS_UNICODEPWD_NOT_IN_QUOTES);
                    return(pTHS->errCode);
            }

            // Strip the quotes off.
            cb0 -= (2 * sizeof(WCHAR));
            OldPassword.Length = (USHORT) cb0;
            OldPassword.MaximumLength = (USHORT) cb0;
            OldPassword.Buffer += 1;
        }
        else
        {
            OldPassword.Length = 0;
            OldPassword.MaximumLength = 0;
            OldPassword.Buffer = NULL;
        }

        if ( cb1 > 0 )
        {
            NewPassword.Buffer = (PWSTR) rCallMap[1].attr.AttrVal.pAVal[0].pVal;
            // Make sure the password is quoted.
            if (    (cb1 < (2 * sizeof(WCHAR)))
                 || (L'"' != NewPassword.Buffer[0])
                 || (L'"' != NewPassword.Buffer[(cb1 / sizeof(WCHAR)) - 1])
               )
            {
                SetAttError(
                        pObject,
                        ATT_UNICODE_PWD,
                        PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                        NULL,
                        ERROR_DS_UNICODEPWD_NOT_IN_QUOTES);
                    return(pTHS->errCode);
            }

            // Strip the quotes off.
            cb1 -= (2 * sizeof(WCHAR));
            NewPassword.Length = (USHORT) cb1;
            NewPassword.MaximumLength = (USHORT) cb1;
            NewPassword.Buffer += 1;
        }
        else
        {
            NewPassword.Length = 0;
            NewPassword.MaximumLength = 0;
            NewPassword.Buffer = NULL;
        }
    }
    else
    {
        Assert( ATT_USER_PASSWORD == AttrTyp );


        if (gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET)
        {
            //
            // Behaviour version of the domain is less than whistler
            // then fail the call as w2k does not support userpassword
            //

            SetAttError(
                    pObject,
                    AttrTyp,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL,
                    ERROR_NOT_SUPPORTED);
            return(pTHS->errCode);
        }



        if ((rCallMap[0].attr.AttrVal.valCount > 1)
            || ( (1 == rCallMap[0].attr.AttrVal.valCount) 
                 && (NULL == rCallMap[0].attr.AttrVal.pAVal[0].pVal) ) 
            )
        {
            SetAttError(
                    pObject,
                    AttrTyp,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL,
                    DIRERR_SINGLE_VALUE_CONSTRAINT);
            return(pTHS->errCode);
        }

        if ((rCallMap[1].attr.AttrVal.valCount > 1) 
            || ( (1 == rCallMap[1].attr.AttrVal.valCount) 
                 && (NULL == rCallMap[1].attr.AttrVal.pAVal[0].pVal) )
            )
        {
            SetAttError(
                    pObject,
                    AttrTyp,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL,
                    DIRERR_SINGLE_VALUE_CONSTRAINT);
            return(pTHS->errCode);
        }

        if (0 == rCallMap[0].attr.AttrVal.valCount)
        {
            OldPassword.Length = 0;
            OldPassword.MaximumLength = 0;
            OldPassword.Buffer = NULL;
        }
        else
        {
            status = SampConvertPasswordFromUTF8ToUnicode(
                            pTHS,
                            rCallMap[0].attr.AttrVal.pAVal[0].pVal,
                            rCallMap[0].attr.AttrVal.pAVal[0].valLen,
                            &OldPassword
                            );

            if (!NT_SUCCESS(status))
            {
                goto Error;
            }

            RtlSecureZeroMemory(
                 rCallMap[0].attr.AttrVal.pAVal[0].pVal,
                 rCallMap[0].attr.AttrVal.pAVal[0].valLen
                 );

            fFreeOldPassword = TRUE;
        }

        if (0 == rCallMap[1].attr.AttrVal.valCount)
        {
            NewPassword.Length = 0;
            NewPassword.MaximumLength = 0;
            NewPassword.Buffer = NULL;
        }
        else
        {
            status = SampConvertPasswordFromUTF8ToUnicode(
                            pTHS,
                            rCallMap[1].attr.AttrVal.pAVal[0].pVal,
                            rCallMap[1].attr.AttrVal.pAVal[0].valLen,
                            &NewPassword
                            );

            if (!NT_SUCCESS(status))
            {
                goto Error;
            }

            //
            // Zero out the UTF8 representation
            //

            RtlSecureZeroMemory(
                 rCallMap[1].attr.AttrVal.pAVal[0].pVal,
                 rCallMap[1].attr.AttrVal.pAVal[0].valLen
                 );

            fFreeNewPassword = TRUE;
        }
    }

    // 
    // Note: we are passing the clear text password to SAM
    // 

    status = SampDsChangePasswordUser(hObj, // User Handle
                                      &OldPassword,
                                      &NewPassword
                                      );


Error:

    //
    // Password Data is sensitive -- zero all passwords to 
    // prevent passwords from getting into the pagefile
    //

    if ((NULL!=OldPassword.Buffer) && (0!=OldPassword.Length))
    {
        RtlSecureZeroMemory(OldPassword.Buffer,OldPassword.Length);
    }

    if ((NULL!=NewPassword.Buffer) && (0!=NewPassword.Length))
    {
        RtlSecureZeroMemory(NewPassword.Buffer,NewPassword.Length);
    }
    
    if (fFreeOldPassword)
    {
         THFree(OldPassword.Buffer);
    }

    if (fFreeNewPassword)
    {
         THFree(NewPassword.Buffer);
    }

    // Bail on error.

    if ( !NT_SUCCESS(status) )
    {
        if ( 0 == pTHS->errCode )
        {
            SetAttError(
                    pObject,
                    ATT_UNICODE_PWD,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL,
                    RtlNtStatusToDosError(status));
        }

        return(pTHS->errCode);
    }

    return(0);
}

BOOLEAN
IsChangePasswordOperation(MODIFYARG * pModifyArg)
{
    if (  (2==pModifyArg->count)
        && (
              (AT_CHOICE_REMOVE_ATT==pModifyArg->FirstMod.choice)
            ||(AT_CHOICE_REMOVE_VALUES==pModifyArg->FirstMod.choice)
           )
        && ((ATT_UNICODE_PWD==pModifyArg->FirstMod.AttrInf.attrTyp) ||
              (ATT_USER_PASSWORD==pModifyArg->FirstMod.AttrInf.attrTyp))
        &&(
            (AT_CHOICE_ADD_ATT==pModifyArg->FirstMod.pNextMod->choice)
           ||(AT_CHOICE_ADD_VALUES==pModifyArg->FirstMod.pNextMod->choice)
          )
        &&((ATT_UNICODE_PWD==pModifyArg->FirstMod.pNextMod->AttrInf.attrTyp) ||
             (ATT_USER_PASSWORD==pModifyArg->FirstMod.pNextMod->AttrInf.attrTyp))
        && (pModifyArg->FirstMod.AttrInf.attrTyp 
               == pModifyArg->FirstMod.pNextMod->AttrInf.attrTyp)
        )
    {
        return TRUE;
    }

    if ( (1==pModifyArg->count)
        && (
              (AT_CHOICE_REMOVE_ATT==pModifyArg->FirstMod.choice)
            ||(AT_CHOICE_REMOVE_VALUES==pModifyArg->FirstMod.choice)
           )
        && (ATT_USER_PASSWORD==pModifyArg->FirstMod.AttrInf.attrTyp)
        )
    {
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
IsSetPasswordOperation(MODIFYARG * pModifyArg)
{
    ATTRMODLIST *CurrentMod = &(pModifyArg->FirstMod);

    do
    {
        if ( (AT_CHOICE_REPLACE_ATT==CurrentMod->choice)
          && ((ATT_UNICODE_PWD==CurrentMod->AttrInf.attrTyp) ||
             (ATT_USER_PASSWORD==CurrentMod->AttrInf.attrTyp))
          )
        {
            return TRUE;
        }
        CurrentMod = CurrentMod->pNextMod;
    } while (CurrentMod != NULL);

    return FALSE;
}

ULONG
SampDoLoopbackAddSecurityChecks(
    THSTATE    *pTHS,
    ADDARG * pAddArg,
    CLASSCACHE * pCC,
    GUID*       pNewObjectGuid,
    PULONG      pSamDomainChecks,
    PULONG      pSamObjectChecks
    )
/*++

    Routine Description

            This routine does all the security Checks that
            need to be performed on an Add. The security Check
            is performed up front, as this reduces the number of
            access checks and also results in correct object auditing

    Parameters:

        pAddArg -- Pointer to the Add Arg
        pCC     -- Pointer to the class cache
        pNewObjectGuid -- new object guid, if user has specified one in add arguments
        SamDomainChecks
        SamObjectChecks -- Any Addtional Sam Checks can be requested by
                               this routine
--*/
{
   
    ULONG                i,j;


    //
    // Initialize Requested SAM checks
    //

    *pSamDomainChecks = 0;
    *pSamObjectChecks = 0;

    if (0!=DoSecurityChecksForLocalAdd(
            pAddArg,
            pCC,
            pNewObjectGuid,
            FALSE // fAdding Deleted
            ))
    {
        return pTHS->errCode;
    }

    //
    // Indicate to the core DS that Access Checks have completed
    //

    pTHS->fAccessChecksCompleted = TRUE;

    return pTHS->errCode;
}


ULONG
SampDoLoopbackModifySecurityChecks(
    THSTATE    *pTHS,
    MODIFYARG * pModifyArg,
    CLASSCACHE * pCC,
    PULONG      pSamDomainChecks,
    PULONG      pSamObjectChecks,
    BOOL        fIsUndelete
    )
/*++

    Routine Description

            This routine does all the security Checks that
            need to be performed on an Modify. The security Check
            is performed up front, as this reduces the number of
            access checks and also results in correct object auditing

    Parameters:

        pRemoveArg -- Pointer to the Remove Arg
        pCC        -- Pointer to the class cache
        SamDomainChecks
        SamObjectChecks -- Any Addtional Sam Checks can be requested by
                               this routine
        fIsUndelete -- is this an undelete operation?                               
--*/
{

     //
     // Initialize Requested SAM checks
     //

    *pSamDomainChecks = 0;
    *pSamObjectChecks = 0;

     if (IsChangePasswordOperation(pModifyArg))
     {
         *pSamDomainChecks = DOMAIN_READ_PASSWORD_PARAMETERS; 
         *pSamObjectChecks = USER_CHANGE_PASSWORD;
          // DS should not do any security check
          pTHS->fAccessChecksCompleted = TRUE;
     }
     else if (IsSetPasswordOperation(pModifyArg))
     {
         //
         // For Sam Classes the DS knows correctly to 
         // ignore the ATT_UNICODE_PWD attribute. So access
         // check any remaining bits. SAM will access check
         // for Set Password
         //

         if (0==CheckModifySecurity(pTHS, pModifyArg, NULL, NULL, NULL, fIsUndelete))
         {
            *pSamObjectChecks = USER_FORCE_PASSWORD_CHANGE;
            // Ds Should not do any security check
             pTHS->fAccessChecksCompleted = TRUE;
         }
     }
     else
     {
        if (0==CheckModifySecurity (pTHS, pModifyArg, NULL, NULL, NULL, fIsUndelete))
        {
            // Security Check Succeeded 
            pTHS->fAccessChecksCompleted = TRUE;

        }
     }

     return (pTHS->errCode);
}


ULONG
SampDoLoopbackRemoveSecurityChecks(
    THSTATE    *pTHS,
    REMOVEARG * pRemoveArg,
    CLASSCACHE * pCC,
    PULONG      pSamDomainChecks,
    PULONG      pSamObjectChecks
    )
/*++

    Routine Description

            This routine does all the security Checks that
            need to be performed on an Remove. The security Check
            is performed up front, as this reduces the number of
            access checks and also results in correct object auditing

    Parameters:

        pRemoveArg -- Pointer to the Remove Arg
        pCC        -- Pointer to the class cache
        SamDomainChecks
        SamObjectChecks -- Any Addtional Sam Checks can be requested by
                               this routine
--*/
{
    //
    // Initialize Requested SAM checks
    //

    *pSamDomainChecks = 0;
    *pSamObjectChecks = 0;

    if (0==CheckRemoveSecurity(FALSE,pCC, pRemoveArg->pResObj))
    {
        pTHS->fAccessChecksCompleted = TRUE;
    }

    return (pTHS->errCode);
} 

ULONG
SampGetGroupTypeForAdd(
    ADDARG * pAddArg,
    PULONG   GroupType
    )
/*++
    Routine Description 

        This routine checks the add arg to see if a group type
        is specified. if not defaults the group type to universal
        group. Else returns the group type property. 

        PERFORMANCE: This routine makes yet another pass of the entire
        addarg ( others to my knowledge are the loopback check,
        and the access check ). Today performance bottlenecks are
        Jet Related bottlenecks, but if performance warrants it 
        we may need to revisit the issue of walking addargs

   Parameters:

        pAddArg -- Pointer to an Addarg
        GroupType -- Value of the group type attribute

   Return Values
        0 for success
        Other Error codes set in pTHS.
--*/
{
    ULONG iGroupType;
    ULONG GroupTypeAttrTyp;
   
    GroupTypeAttrTyp = SampDsAttrFromSamAttr(
                          SampGroupObjectType,
                          SAMP_FIXED_GROUP_TYPE);


    for ( iGroupType = 0; iGroupType < pAddArg->AttrBlock.attrCount; iGroupType++ )
    {
        if (GroupTypeAttrTyp ==
                    pAddArg->AttrBlock.pAttr[iGroupType].attrTyp )
        {
            break;
        }
    }

    //
    // If Group type is not present then substitute a default group type
    //

    if ( iGroupType >= pAddArg->AttrBlock.attrCount )
    {
         // Group Type then default it

        *GroupType = GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_ACCOUNT_GROUP;
        return 0;
    }

    // Group type should be single valued
    if (( 1 != pAddArg->AttrBlock.pAttr[iGroupType].AttrVal.valCount )
          || (sizeof(ULONG)!=pAddArg->AttrBlock.pAttr[iGroupType].AttrVal.pAVal[0].valLen))
    {
        return SetAttError(
            pAddArg->pObject,
            GroupTypeAttrTyp,
            PR_PROBLEM_CONSTRAINT_ATT_TYPE, 
            NULL,
            DIRERR_SINGLE_VALUE_CONSTRAINT);

    }


    //
    // Validation of the actual bits of the group type is performed
    // by SAM
    //

    *GroupType = *((ULONG*) 
    (pAddArg->AttrBlock.pAttr[iGroupType].AttrVal.pAVal[0].pVal));
    
    return 0;
    
}

ULONG 
SampGetGroupType(THSTATE *pTHS,
                 PULONG pGroupType)
/*++

    Routine Description
        
          Retrieves the group type property from
          the database.

    Parameters:

        pGroupType -- pointer to a ULONG that holds the
                      group type

    Return Values

        0 --- Upon Success
        Other error codes , with pTHS->errCode set
        accordingly
--*/
{

    ULONG  outLen;
    BOOLEAN fLogicErr;
    ULONG   dbErr;


     // Retrieve the group type property from the
     // database

     dbErr = DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_GROUP_TYPE,
                DBGETATTVAL_fCONSTANT, 
                sizeof(ULONG),
                &outLen, 
                (PUCHAR *) &pGroupType);

    fLogicErr = TRUE;

    if ( (DB_ERR_NO_VALUE == dbErr) 
            ||
         (DB_ERR_BUFFER_INADEQUATE == dbErr)
            ||
         ((0 == dbErr) && (outLen > sizeof(ULONG)))
            ||
        (fLogicErr = FALSE, (DB_ERR_UNKNOWN_ERROR == dbErr)) )
    {
        Assert(!fLogicErr);

        // Assuming that our logic is consistent,
        // the only legal way this can happen is a resource
        // failure of some sort. 

        SampMapSamLoopbackError(STATUS_INSUFFICIENT_RESOURCES);
        return(pTHS->errCode);
    }

    return 0;

}

ULONG
SampBeginLoopbackTransactioning(
    THSTATE                 *pTHS,
    LoopbackTransState      *pTransState,
    BOOLEAN                 fAcquireSamLock
    )
/*++

  Routine Description:

    Synchronizes SAM caches with DS transactions and also handles
    mixing of loopback with DirTransactionControl usage.

  Parameters:

    pTHS - THSTATE pointer - this routine reads/updates various fields.

    pTransState - Pointer to state variable client should use on 
        subsequent SampEndLoopbackTransactioning call.

    fAcquireSamLock - Indicate whether we should acquire SAM Lock 
        during this Loopback operation. Right now, all caller 
        should not acquire SAM lock, but just in case something bad
        happened. We will need use this boolean to switch back to 
        our original SAM Locking model.

  Return Values:

    0 on Success, pTHS->errCode on error

--*/
{
    NTSTATUS    status;
    ULONG       retVal = 0;

    pTransState->transControl = pTHS->transControl;
    pTransState->fDSA = pTHS->fDSA;

    // DirTransactControl may only be combined with loopback if
    // caller acquired the SAM write lock himself.  I.e. If caller
    // is doing something other than TRANSACT_BEGIN_END then there
    // is the possibility he has already written something and thus
    // the subsequent DBTransOut/DBTransIn sequence will split
    // what caller thinks is one transaction into two - which of
    // course is undesirable.  See use of fBeginDontEndHoldsSamLock
    // in SYNC_TRANS_* for how we catch callers who try something
    // like the following:
    //
    //      DirTransactControl(TRANSACT_BEGIN_DONT_END);
    //      some Dir* call which does not loop back
    //      SampAcquireWriteLock()
    //      pTHS->fSamWriteLockHeld = TRUE;
    //      some Dir* call which does loop back

    Assert((TRANSACT_BEGIN_END == pTransState->transControl)
                ? TRUE
                : (    pTHS->fSamWriteLockHeld
                    && pTHS->fBeginDontEndHoldsSamLock));


    // Do not acquire SAM write lock if we are told to do so. 
    // 

    if ( !pTHS->fSamWriteLockHeld && fAcquireSamLock )
    {
        // End the Existing DS transaction. This is necessary because
        // SAM has various caches which refresh depending upon the operation
        // being performed. Beginning the transaction before acquiring the
        // lock causes the caches to be possibly refreshed using Stale Data.
        // Also waiting on a lock with an open transaction is a bad thing
        // for performance.

        _try
        {
            // Do lazy commit - fastest way to end a transaction.

            DBTransOut(pTHS->pDB, TRUE, TRUE); 

            // Acquire the SAM write lock for the duration of the loopback.
            // The lock is freed by CLEAN_FOR_RETURN() after committing or
            // aborting the DS transaction.
    
            status = SampAcquireWriteLock();
    
            if ( !NT_SUCCESS( status ) )
            {
                Assert( !"Loopback code failed to acquire SAM write lock!" );
                SampMapSamLoopbackError( status );
                retVal = pTHS->errCode;
            }
            else
            {
                pTHS->fSamWriteLockHeld = TRUE;
            }

            // Always do a DBTransIn to match the DBTransOut earlier - even
            // in error case so that transaction levels in DBPOS are as other
            // components expect.

            DBTransIn(pTHS->pDB);

            // Do all thread close paths, eg: free_thread_state,
            //          work right if DBTransIn fails?
        }
        __except (HandleMostExceptions(GetExceptionCode()))
        {
            //
            // Set the correct error based on the exception code
            //

            retVal = SampHandleLoopbackException(GetExceptionCode());
        }
    }

    if ( 0 == retVal )
    {
        // Set up thread state variables.  Convert this thread into 
        // a SAM thread, but turn off SAM commits so that the N Samr* 
        // calls we're about to make are treated as a single transaction.
        // Clear transaction control so that loopback runs as pure SAM.
        // Caller has obligation to reset transaction control and fSAM
        // when loopback returns to him.

        pTHS->fSAM = TRUE;
        pTHS->fSamDoCommit = FALSE;
        pTHS->transControl = TRANSACT_BEGIN_END;
    }

    return(retVal);
}

VOID
SampEndLoopbackTransactioning(
    THSTATE                 *pTHS,
    LoopbackTransState      *pTransState
    )
/*++

  Routine Description:

    Reset items which we may have changed in the original caller's
    transaction/environment when we realized we had to loop back through SAM.

  Parameters:

    pTHS - THSTATE pointer - this routine reads/updates various fields.

    pTransState - Pointer to state variable client provided on orignal
        SampBeginLoopbackTransactioning call.

  Return Values:

    None.

--*/
{
    pTHS->fSAM = FALSE;
    pTHS->fDSA = pTransState->fDSA;
    pTHS->transControl = pTransState->transControl;

    // We only clear the pSamLoopback pointer in the success case.  Clear
    // it unlaterally here - regardless of success or failure - so that 
    // people doing DirTransactControl don't hit asserts which required
    // pSamLoopback to be null.

    if ( pTHS->pSamLoopback )
    {
        THFreeEx(pTHS, pTHS->pSamLoopback);
    }

    pTHS->pSamLoopback = NULL;
}

 
 
BOOLEAN
SampDetectPasswordChangeAndAdjustCallMap(
    IN   SAMP_LOOPBACK_TYPE  op,
    IN   ULONG  iClass,
    IN   ULONG  cCallMap,
    IN   SAMP_CALL_MAPPING   *rCallMap,
    OUT  SAMP_CALL_MAPPING   *AdjustedCallMap
    )
/* Detect change password case.  Password can only be modified 
    // 1) if this is a user and there are only two sub-operations,
    // one to remove the old password and another to add the new password.
    // SampModifyPassword verifies the secure connection.  AT_CHOICEs
    // are dependent on how the LDAP head maps LDAP add/delete attribute
    // operations.  LDAP add always maps to AT_CHOICE_ADD_VALUES.  LDAP
    // delete maps to AT_CHOICE_REMOVE_ATT if no value is supplied
    // (eg: old password is NULL) and AT_CHOICE_REMOVE_VALUES if a value
    // is supplied.  We allow the operations in either order.
    //
    // 2) if the attribute specified is Userpassword, and if only a single
    //    remove value is provided, the value corresponding to the old 
    //    password. In this case the password is being changed to a blank
    //  password.
    //
    // SampModifyPassword always expects 2 paramaters in the callmap, one
    // corresponding to the old password and one for the new password.
    // SampDetectAndAdjustCallMap modifies the call map for this purpose.
    //

    Parameters:
        
            op -- indicates the type of operation
            iClass -- indicates the clas of the object
            cCallMap, rCallMap -- the current call mapping
            AdjustedCallMap -- adjusted call mapping, with exactly 2 entries
                               -- a new password and a old password
*/

{
      if (    (LoopbackModify == op)
         && (SampUserObjectType == ClassMappingTable[iClass].SamObjectType)
         && (2 == cCallMap)
         && !rCallMap[0].fIgnore
         && !rCallMap[1].fIgnore
         && rCallMap[0].fSamWriteRequired
         && rCallMap[1].fSamWriteRequired
         && ((ATT_UNICODE_PWD == rCallMap[0].attr.attrTyp)
               || (ATT_USER_PASSWORD == rCallMap[0].attr.attrTyp))
         && ((ATT_UNICODE_PWD == rCallMap[1].attr.attrTyp)
               || (ATT_USER_PASSWORD == rCallMap[1].attr.attrTyp))
         && ( rCallMap[0].attr.attrTyp == rCallMap[1].attr.attrTyp) 
         && (    (    (    (AT_CHOICE_REMOVE_ATT == rCallMap[0].choice)
                        || (AT_CHOICE_REMOVE_VALUES == rCallMap[0].choice))
                   && (AT_CHOICE_ADD_VALUES == rCallMap[1].choice))
              || (    (    (AT_CHOICE_REMOVE_ATT == rCallMap[1].choice)
                        || (AT_CHOICE_REMOVE_VALUES == rCallMap[1].choice))
                   && (AT_CHOICE_ADD_VALUES == rCallMap[0].choice))))
    {
        // SampModifyPassword expects the old password first, new second.

        if ( AT_CHOICE_ADD_VALUES == rCallMap[0].choice )
        {


            AdjustedCallMap[0] = rCallMap[1];
            AdjustedCallMap[1] = rCallMap[0];
        }
        else
        {
            AdjustedCallMap[0] = rCallMap[0];
            AdjustedCallMap[1] = rCallMap[1];
        }

        return(TRUE);
      }

    if (    (LoopbackModify == op)
         && (SampUserObjectType == ClassMappingTable[iClass].SamObjectType)
         && (1 == cCallMap)
         && !rCallMap[0].fIgnore
         && rCallMap[0].fSamWriteRequired
         && (ATT_USER_PASSWORD == rCallMap[0].attr.attrTyp)
         && ((AT_CHOICE_REMOVE_ATT == rCallMap[0].choice)
             || (AT_CHOICE_REMOVE_VALUES == rCallMap[0].choice)) )
    {
        
        AdjustedCallMap[0] = rCallMap[0];
        AdjustedCallMap[1].choice = AT_CHOICE_ADD_VALUES;
        AdjustedCallMap[1].fIgnore = FALSE;
        AdjustedCallMap[1].attr.attrTyp = ATT_USER_PASSWORD;
        AdjustedCallMap[1].attr.AttrVal.valCount = 0;
        AdjustedCallMap[1].attr.AttrVal.pAVal = NULL;

        return(TRUE);
    }

    return(FALSE);
    
 }
                
ULONG
SampWriteNotAllowed(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )
{
    // We should not get here in the typical case because
    // SampAddLoopbackRequired and SampModifyLoopbackRequired should
    // have returned an error back when we first detectd that the client
    // was trying to write a mapped attribute whose writeRule is SamReadOnly.
    // This function exists mostly to avoid dereferencing a NULL function
    // pointer in the mapping table.  The exception is the case of password
    // modification where SampModifyLoopbackRequired lets ATT_UNICODE_PWD
    // writes through so that we can detect the special change password
    // condition in SampWriteSamAttributes.  However, if the condition is
    // not met, we'll end up here at which time we should return an error.

    SampMapSamLoopbackError(STATUS_UNSUCCESSFUL);
    return(pTHStls->errCode);
}

BOOLEAN
SampIsSecureLdapConnection(
    VOID
    )
/*++

Routine Description:

    Verify that this is a secure enough connection - one of the 
    requirements for accepting passwords sent over the wire.

Parameter:

    None:
    
Return Value:

    TRUE  - yes, it is a secure connection

    FALSE - no

--*/

{
    return( pTHStls->CipherStrength >= 128 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mapspn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       mapspn.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    SPNs have several components the first of which is a service class.
    The intent is to have many service classes representing many kinds of
    services - eg: http, alerter, appmgmt, cisvc, clipsrv, browser, dhcp,
    dnscache, replicator, eventlog - you get the idea.  Clients should
    always use the most specific service class appropriate.  However, to
    eliminate the clutter of registering umpteen SPNs on an object which
    only differ by their service class, we support a mapping function
    which maps specific service clases to a more generic ones.  This file
    implementents that mapping mechanism.

Author:

    DaveStr     30-Oct-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <dstrace.h>
#include <dsevent.h>            // header Audit\Alert logging
#include <dsexcept.h>
#include <mdcodes.h>            // header for error codes
#include <anchor.h>
#include <cracknam.h>           // Tokenize
#include <debug.h>              // standard debugging header
#define DEBSUB "MAPSPN:"        // define the subsystem for debugging
#include <fileno.h>
#define  FILENO FILENO_MAPSPN   
#include <ntrtl.h>              // generic table package
#include <objids.h>

//
// Globals
//

RTL_GENERIC_TABLE       SpnMappings;
DWORD                   cSpnMappings = 0;

CRITICAL_SECTION        csSpnMappings;

//
// Structs and helpers for generic table package.
//

typedef struct _ServiceClass
{
    struct _ServiceClass    *pMapping;  // NULL if target of a mapping
    int                     cChar;      // does not include NULL terminator
    WCHAR                   name[1];    // service class value - eg: LDAP
} ServiceClass;

PVOID
ServiceClassAllocate(
    RTL_GENERIC_TABLE   *table,
    CLONG               cBytes)
{
    VOID *pv = malloc(cBytes);

    if ( !pv )
    {
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0, 
                       DSID(FILENO, __LINE__), DS_EVENT_SEV_MINIMAL);
    }

    return(pv);
}

VOID
ServiceClassFree(
    RTL_GENERIC_TABLE   *table,
    PVOID               buffer)
{
    free(buffer);
}

RTL_GENERIC_COMPARE_RESULTS
ServiceClassCompare(
    RTL_GENERIC_TABLE   *table,
    PVOID               pv1,
    PVOID               pv2)
{
    int diff = ((ServiceClass *) pv1)->cChar - ((ServiceClass *) pv2)->cChar;

    if ( 0 == diff )
    {
        diff = CompareStringW(
                        DS_DEFAULT_LOCALE,
                        DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                        ((ServiceClass *) pv1)->name, 
                        ((ServiceClass *) pv1)->cChar, 
                        ((ServiceClass *) pv2)->name,
                        ((ServiceClass *) pv2)->cChar);

        switch ( diff )
        {
        case 1:
            diff = -1;
            break;
        case 2:
            diff = 0;
            break;
        case 3:
            diff = 1;
            break;
        default:
            RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0, 
                           DSID(FILENO, __LINE__), DS_EVENT_SEV_MINIMAL);
            break;
        }
    }

    if ( 0 == diff )
        return(GenericEqual);
    else if ( diff > 0 )
        return(GenericGreaterThan);

    return(GenericLessThan);
}

DWORD
MapSpnLookupKey(
    ServiceClass    *pKey,
    ServiceClass    **ppFoundKey
    )
/*++

  Description:

    Wrapper around RtlLookupElementGenericTable which will catch 
    allocation and CompareStringW exceptions.

  Arguments:

    pKey - Pointer to key to find.

    ppFoundKey - OUT arg holding address of found key.

  Return Values:

    WIN32 error code.

--*/
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    // Exclusive access because RtlLookupElementGenericTable splays the tree
    EnterCriticalSection(&csSpnMappings);
    __try
    {
        __try
        {
            *ppFoundKey = RtlLookupElementGenericTable(&SpnMappings, pKey);
        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                  &dwEA, &ulErrorCode, &dsid)) 
        {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    __finally {
        LeaveCriticalSection(&csSpnMappings);
    }


    return(dwErr);
}

DWORD
MapSpnAddServiceClass(
    ServiceClass    *pKey,
    DWORD           cBytes,
    BOOLEAN         *pfNewKey,
    ServiceClass    **ppFoundKey
    )
/*++

  Description:

    Wrapper around RtlInsertElementGenericTable which will catch
    allocation and CompareStringW exceptions.

  Arguments:

    pKey - Pointer to key to add.

    cBytes - Byte count of key to add.

    pfNewKey - OUT arg indicating if new key was added or not.

    ppFoundKey - OUT arg holding address either found or added key.

  Return Values:

    WIN32 error code.

--*/
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    
    EnterCriticalSection(&csSpnMappings);
    __try {
        __try
        {
            *ppFoundKey = RtlInsertElementGenericTable(&SpnMappings, pKey, 
                                                       cBytes, pfNewKey);
        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                  &dwEA, &ulErrorCode, &dsid)) 
        {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    __finally {
        LeaveCriticalSection(&csSpnMappings);
    }



    if ( !dwErr && !*ppFoundKey )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return(dwErr);
}

DWORD
MapSpnParseMapping(
    THSTATE     *pTHS,
    ULONG       len,
    UCHAR       *pVal
    )
/*++

  Description:

    This routine parses a mapping definition string of the form
    "aaa=xxx,yyy,zzz..." and adds elements to the SpnMappings table
    appropriately.

  Arguments:

    pTHS - THSTATE pointer.

    len - Length in bytes of the string.

    pVal - Pointer to value as read form the DB - i.e. not NULL terminated.

  Return Values:

    0 on success, !0 otherwise.

--*/
{
    DWORD           dwErr = 0;
    WCHAR           *pSave, *pCurr, *pTmp, *pNextToken;
    ServiceClass    *pKey, *pFoundKey, *plValueKey;
    CLONG           keySize;
    BOOLEAN         fNewKey;
    BOOL            fDontCare;

    // Realloc as null terminated string.
    pSave = THAllocEx(pTHS, len + sizeof(WCHAR));
    pCurr = pSave;
    memcpy(pCurr, pVal, len);

    // Allocate a key of the same size - thus we know it can hold any value.
    pKey = (ServiceClass *) THAllocEx(pTHS, sizeof(ServiceClass) + len);

    // Each value is of the form "aaa=xxx,yyy,zzz,..." where aaa represented
    // a mapped to service class and xxx, etc. represent mapped from service
    // classes.  In the following code, we use 'lValue' when referring to the
    // 'aaa' component and 'rValue' when refering to one of xxx,yyy,zzz,...

    if (    !(pTmp = wcschr(pCurr, L'='))   // '=' separator not found
         || (pTmp && !*(pTmp + 1)) )        // nothing after the separator
    {
        // Mal-formed value - ignore.
        dwErr = 0;
        goto ParseExit;
    }

    // Null terminate lValue.
    *pTmp = L'\0';

    // Lookup/insert lValue.
    pKey->pMapping = NULL;
    pKey->cChar = wcslen(pCurr);
    wcscpy(pKey->name, pCurr);
    keySize = sizeof(ServiceClass) + (sizeof(WCHAR) * pKey->cChar);

    if ( dwErr = MapSpnAddServiceClass(pKey, keySize, 
                                       &fNewKey, &pFoundKey) )
    {
        goto ParseExit;
    }

    if ( !fNewKey )
    {
        // Key pre-existed in the table.  We don't much care if it is there
        // as an lValue or rValue as we had intended to insert is as an lValue
        // and they should not pre-exist.  I.e. The SPN-Mappings property
        // is bogus.  Make an event log entry and ignore this value.

        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DUPLICATE_SPN_MAPPING_VALUE,
                 szInsertWC(pKey->name),
                 szInsertWC(gAnchor.pDsSvcConfigDN ? gAnchor.pDsSvcConfigDN->StringName : L""),
                 NULL);
        dwErr = 0;
        goto ParseExit;
    }

    // Remember where the lValue key is.
    plValueKey = pFoundKey;

    // Advance pCurr to first rValue and process each one.
    pCurr = pTmp + 1;
    while ( pCurr = Tokenize(pCurr, L",", &fDontCare, &pNextToken) )
    {
        // Lookup/insert rValue - map it to lValue in case insert succeeds.
        pKey->pMapping = plValueKey;
        pKey->cChar = wcslen(pCurr);
        wcscpy(pKey->name, pCurr);
        keySize = sizeof(ServiceClass) + (sizeof(WCHAR) * pKey->cChar);

        if ( dwErr = MapSpnAddServiceClass(pKey, keySize, 
                                           &fNewKey, &pFoundKey) )
        {
            goto ParseExit;
        }

        // No need to check whether this is a new rValue or not.  OK if it is.
        // If it isn't, then RtlInsertElementGenericTable didn't make a new
        // one, it just returned the existing one.  If we continue it means
        // that the duplicate rValue is ignored.  I.e. The prior mapping for
        // this rValue to an lValue will win.  However, need to bump count and
        // need to inform administrator.

        if ( fNewKey )
        {
            cSpnMappings++;
        }
        else
        {
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DUPLICATE_SPN_MAPPING_VALUE,
                     szInsertWC(pKey->name),
                     szInsertWC(gAnchor.pDsSvcConfigDN ? gAnchor.pDsSvcConfigDN->StringName : L""),
                     NULL);
        }

        pCurr = pNextToken;
    }
    
ParseExit:

    THFreeEx(pTHS, pSave);
    THFreeEx(pTHS, pKey);
    return(dwErr);
}

int
MapSpnInitialize(
    THSTATE     *pTHS
    )
/*++

  Description:

    Reads the SPN-Mappings property (a multi-value of UNICODE strings) and 
    parses each one so its information is added to the SpnMappings table.

  Arguments:

    pTHS - Active THSTATE pointer.

  Return Values:

    0 on success, !0 otherwise.

--*/
{
    DWORD       i, dwErr = 0;
    UCHAR       *pVal;
    ULONG       len;
    ATTCACHE    *pAC;
    DWORD       dwExcept = 0;

    Assert(VALID_THSTATE(pTHS));

    
    EnterCriticalSection(&csSpnMappings);
    __try {
        RtlInitializeGenericTable(  &SpnMappings,
                                    ServiceClassCompare,
                                    ServiceClassAllocate,
                                    ServiceClassFree,
                                    NULL);
    }
    __finally {
        LeaveCriticalSection(&csSpnMappings);
    }



    if (    !gAnchor.pDsSvcConfigDN
         || !(pAC = SCGetAttById(pTHS, ATT_SPN_MAPPINGS)) )
    {
        return(0);
    }

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
    
        __try 
        {
            // Position at DS service configuration object.
            if ( DBFindDSName(pTHS->pDB, gAnchor.pDsSvcConfigDN) ) {
                // we failed to find the service configuration object.
                // Just pretend that we have no SPN mappings and
                // don't return an error.
                DPRINT1(0, "DS Service object %ws is not found. Assume no SPN mappings exist.\n", 
                        gAnchor.pDsSvcConfigDN->StringName);
                __leave;
            }
            
            // Read all values of the SPN mappings property and parse them.
        
            for ( i = 1; TRUE; i++ )
            {
                dwErr = DBGetAttVal_AC(pTHS->pDB, i, pAC, 0, 0, &len, &pVal);
        
                if ( 0 == dwErr )
                {
                    dwErr = MapSpnParseMapping(pTHS, len, pVal);
                    THFreeEx(pTHS, pVal);
        
                    if ( dwErr )
                    {
                        __leave;
                    }
                }
                else if ( DB_ERR_NO_VALUE == dwErr )
                {
                    dwErr = 0;
                    break;      // for loop
                }
                else
                {
                    LogUnhandledError(dwErr);
                    __leave;
                }
            }
        }
        __finally {
            DBClose(pTHS->pDB, 0 == dwErr && !AbnormalTermination());
        }
    }
    __except (HandleMostExceptions(GetExceptionCode()))
    {
        dwExcept = GetExceptionCode();

        if ( !dwErr )
        {
            dwErr = DB_ERR_EXCEPTION;
        }
    }
    
    if ( 0 != dwExcept )
    {
        return(dwExcept);
    }

    return(dwErr);
}

LPCWSTR
MapSpnServiceClass(
    WCHAR   *pwszClass
    )
/*++

  Description:

    Maps a given SPN service class to its aliased value if it exists.

  Arguments:

    pwszClass - SPN service class to map.

  Return Values:

    Pointer to const string if mapping found, NULL otherwise.

--*/
{
    THSTATE         *pTHS = pTHStls;
    ServiceClass    *key = NULL;
    ServiceClass    *pTmp;
    int             cChar;
    LPCWSTR         Retname = NULL;

    Assert(VALID_THSTATE(pTHS));

    if ( cSpnMappings )
    {
        cChar = wcslen(pwszClass);
        key = (ServiceClass *) THAllocEx(pTHS,
                                         sizeof(ServiceClass) + (cChar * sizeof(WCHAR)));
        wcscpy(key->name, pwszClass);
        key->cChar = cChar;

        if (    !MapSpnLookupKey(key, &pTmp)    // no errors on call
             && pTmp                            // an entry was found
             && pTmp->pMapping )                // it is a "mapped from" entry
        {
            // All entries should have a name field.
            Assert(0 != pTmp->cChar);
            Assert(0 != pTmp->pMapping->cChar);

            // Since pTmp->Mapping is non-NULL, entry it points to should
            // be a "mapped to" entry, not a "mapped from" entry.
            Assert(NULL == pTmp->pMapping->pMapping);
            Retname = (LPCWSTR) pTmp->pMapping->name;
        }
    }
    if (key) {
        THFreeEx(pTHS, key);
    }

    return(Retname);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdbind.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdbind.c
//
//--------------------------------------------------------------------------


/*

Description:
    
    Implements the DirBind and DirUnBind API.
    
*/


#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h> 
#include <scache.h>			// schema cache 
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header 
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>			// needed for output allocation 
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <attids.h>
#include <dsexcept.h>

// Logging headers.
#include "dsevent.h"			// header Audit\Alert logging 
#include "mdcodes.h"			// header for error codes 

// Assorted DSA headers.
#include "anchor.h"
#include <permit.h>
#include "debug.h"			// standard debugging header 
#define DEBSUB  "DBMD:"                 // define the subsystem for debugging 

#include <fileno.h>
#define  FILENO FILENO_MDBIND


/* MACROS */

const char gszVersion[] = "v1988";    /*The software version number */
#define VERSION gszVersion
#define VERSIONSIZE (sizeof(gszVersion)-1)

ULONG
DirBind(
    BINDARG*    pBindArg,       /* Bind  argument */
    BINDRES **  ppBindRes
)
{
    THSTATE*     pTHS;
    DWORD err, len;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    BINDRES *pBindRes;

    //
    // Initialize the THSTATE anchor and set a read sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.
    //

    DPRINT(1,"DirBind entered\n");

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    *ppBindRes = NULL;

    __try {
        *ppBindRes = pBindRes = (BINDRES *)THAllocEx(pTHS, sizeof(BINDRES));
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

	SYNC_TRANS_READ();   /*Identify a reader trans*/
	__try {
	    if (pBindArg->Versions.len != VERSIONSIZE ||
		memcmp(pBindArg->Versions.pVal, VERSION, VERSIONSIZE ) != 0) {
		// The comment claims that we should return an error
		// if the caller didn't pass in the right version string,
		// but the code didn't enfore it, so the odds of anyone having
		// gotten the argument right are miniscule.  Just let it go by.  
		DPRINT1(2,"Wrong Version <%s> rtn security error\n",
			asciiz(pBindArg->Versions.pVal,
			       pBindArg->Versions.len));
	    }

	    // Note: In Exchange, we used to check access here because the 
	    // right to do a ds_bind was protected (the right was 
	    // MAIL_ADMIN_AS).  NT5 puts the access check on individual 
	    // objects in the directory instead.
	  
	    pBindRes->Versions.pVal = THAllocEx(pTHS, VERSIONSIZE);
	    memcpy(pBindRes->Versions.pVal, VERSION, VERSIONSIZE);
	    pBindRes->Versions.len = VERSIONSIZE;
	
	    /* Return the DSA name.  We don't just copy the value in
	     * case the DSA has recently been renamed and the string values
	     * in the anchor are temporarily wrong or missing.
	     */
	    err = DBFindDSName(pTHS->pDB,
			       gAnchor.pDSADN);
	    if (!err) {
		err = DBGetAttVal(pTHS->pDB,
				  1,
				  ATT_OBJ_DIST_NAME,
				  0,
				  0,
				  &len,
				  (UCHAR**)&(pBindRes->pCredents));
	    }
	    if (err) {
		SetSvcError(SV_PROBLEM_UNAVAILABLE,
			    DIRERR_GENERIC_ERROR);
	    }

	}
	__finally {
	    CLEAN_BEFORE_RETURN (pTHS->errCode);
	}
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
	HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pBindRes) {
	pBindRes->CommRes.errCode = pTHS->errCode;
	pBindRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

   return pTHS->errCode;

}/*S_DirBind*/



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirUnBind(
)
{

    /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
    is required on every API transaction.  First the state DS is initialized
    and then either a read or a write sync point is established.
    */

    /* This routine appears to have no net effect */
        
    DPRINT(1,"DirUnBind entered\n");


    return 0;
}   /*DSA_DirUnBind*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mddebug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mddebug.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

    01/20/97    Jeff Parham (jeffparh)
                Moved functions over from dscommon to avoid linking
                problems.  (These functions use the core and thus
                are only useful inside executable that also link
                with the core.)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include "debug.h"
#define DEBSUB "MDDEBUG:"

#include <dsconfig.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsevent.h>
#include <ntrtl.h>
#include <fileno.h>
#define  FILENO FILENO_MDDEBUG

DWORD gulHideDSID = DSID_REVEAL_ALL;

//
// We want the following Table both in Free and Checked Build
//
typedef struct
{
    char* ErrStr;
    ULONG ErrNo;
}ERRINFOSTRUCT;


static ERRINFOSTRUCT ProblemTable[]=
{
{"NO_ATTRIBUTE_OR_VAL", PR_PROBLEM_NO_ATTRIBUTE_OR_VAL},
{"INVALID_ATT_SYNTAX", PR_PROBLEM_INVALID_ATT_SYNTAX },
{"UNDEFINED_ATT_TYPE", PR_PROBLEM_UNDEFINED_ATT_TYPE },
{"WRONG_MATCH_OPER", PR_PROBLEM_WRONG_MATCH_OPER},
{"CONSTRAINT_ATT_TYPE", PR_PROBLEM_CONSTRAINT_ATT_TYPE},
{"ATT_OR_VALUE_EXISTS", PR_PROBLEM_ATT_OR_VALUE_EXISTS},
{"NO_OBJECT", NA_PROBLEM_NO_OBJECT},
{"NO_OBJ_FOR_ALIAS", NA_PROBLEM_NO_OBJ_FOR_ALIAS },
{"BAD_ATT_SYNTAX", NA_PROBLEM_BAD_ATT_SYNTAX},
{"ALIAS_NOT_ALLOWED", NA_PROBLEM_ALIAS_NOT_ALLOWED},
{"NAMING_VIOLATION", NA_PROBLEM_NAMING_VIOLATION},
{"BAD_NAME", NA_PROBLEM_BAD_NAME},
{"INAPPROPRIATE_AUTH", SE_PROBLEM_INAPPROPRIATE_AUTH},
{"INVALID_CREDENTS", SE_PROBLEM_INVALID_CREDENTS},
{"INSUFF_ACCESS_RIGHTS", SE_PROBLEM_INSUFF_ACCESS_RIGHTS},
{"INVALID_SIGNATURE", SE_PROBLEM_INVALID_SIGNATURE},
{"PROTECTION_REQUIRED", SE_PROBLEM_PROTECTION_REQUIRED},
{"NO_INFORMATION", SE_PROBLEM_NO_INFORMATION},
{"BUSY", SV_PROBLEM_BUSY},
{"UNAVAILABLE", SV_PROBLEM_UNAVAILABLE},
{"WILL_NOT_PERFORM", SV_PROBLEM_WILL_NOT_PERFORM},
{"CHAINING_REQUIRED", SV_PROBLEM_CHAINING_REQUIRED},
{"UNABLE_TO_PROCEED", SV_PROBLEM_UNABLE_TO_PROCEED},
{"INVALID_REFERENCE", SV_PROBLEM_INVALID_REFERENCE},
{"TIME_EXCEEDED", SV_PROBLEM_TIME_EXCEEDED},
{"ADMIN_LIMIT_EXCEEDED", SV_PROBLEM_ADMIN_LIMIT_EXCEEDED},
{"LOOP_DETECTED", SV_PROBLEM_LOOP_DETECTED},
{"UNAVAIL_EXTENSION", SV_PROBLEM_UNAVAIL_EXTENSION},
{"OUT_OF_SCOPE", SV_PROBLEM_OUT_OF_SCOPE},
{"DIR_ERROR", SV_PROBLEM_DIR_ERROR},
{"NAME_VIOLATION", UP_PROBLEM_NAME_VIOLATION},
{"OBJ_CLASS_VIOLATION", UP_PROBLEM_OBJ_CLASS_VIOLATION},
{"CANT_ON_NON_LEAF", UP_PROBLEM_CANT_ON_NON_LEAF},
{"CANT_ON_RDN", UP_PROBLEM_CANT_ON_RDN},
{"ENTRY_EXISTS", UP_PROBLEM_ENTRY_EXISTS},
{"AFFECTS_MULT_DSAS", UP_PROBLEM_AFFECTS_MULT_DSAS},
{"CANT_MOD_OBJ_CLASS", UP_PROBLEM_CANT_MOD_OBJ_CLASS},
{"unknown problem", 0}};

char * GetProblemString(USHORT problem)
{
    ERRINFOSTRUCT * pEI = ProblemTable;

    while (pEI->ErrNo != problem && pEI->ErrNo)
      ++pEI;

    return pEI->ErrStr;
}

static char * pUnknown = "Not in cache!";

#if DBG

void DumpErrorInfo(UCHAR * pDebSub, unsigned line)
{
    UCHAR *pString=NULL;
    DWORD cbString=0;
    if(!CreateErrorString(&pString, &cbString)) {
        // couldn't create an error string
	DebPrint(0,"Unable to create an error info string.\n",
                 pDebSub, line);
    }
    else {
	DebPrint(0,pString,
                 pDebSub, line);
        THFree(pString);
    }
}

#endif /*DBG*/


//
// This is the same function as above except its output goes to a Debugger.
// and is available on Free Builds.
//
void DbgPrintErrorInfo()
{
    UCHAR *pString=NULL;
    DWORD cbString=0;
    if(!CreateErrorString(&pString, &cbString)) {
        // couldn't create an error string
        DbgPrint("Unable to create an error info string.\n");
    }
    else {
        DbgPrint(pString);
        THFree(pString);
    }
}

//
// Create a THAlloc'ed string describing the error in the pTHStls.
// Returns NULL if no string could be created. 
//
BOOL
CreateErrorString(UCHAR **ppBuf, DWORD *pcbBuf)
{
    THSTATE *pTHS = pTHStls;
    PROBLEMLIST *ppl;
    DSA_ADDRESS_LIST *pdal;
    unsigned long u;
    ATTCACHE * pAC;
    char * pName;
    char * pNoError = "No Error.\n";
    char * pString;
    DWORD  cbString = 256;
    DWORD  cbUsedString = 1;
    char   pTempBuff[1025];
    DWORD  cbTempBuff;
    BOOL   fDsidHideOnName = (gulHideDSID >= DSID_HIDE_ON_NAME_ERR) ? TRUE : FALSE;
    BOOL   fDsidHideAll    = (gulHideDSID >= DSID_HIDE_ALL) ? TRUE : FALSE;


    *ppBuf = NULL;
    *pcbBuf = 0;

    // Set the last character of pTempBuff to NULL to act as a sentinal
    // in case any of the snprintf call below fail to null terminate the 
    // string
    pTempBuff[1024] = '\0';

    if(!pTHS) {
        // No thread state
        return FALSE;
    }
        
    pString = THAlloc(cbString);
    
    if(!pString)
        return FALSE;

    switch(pTHS->errCode) {
    case attributeError:
        if(pTHS->pErrInfo->AtrErr.count) {
            // OK, at least one problem is here.  Use the error from the first
            // problem as the main error to return.
            ppl =  &pTHS->pErrInfo->AtrErr.FirstProblem;
            _snprintf(pTempBuff, 1024,
                      "%08X: AtrErr: DSID-%08X, #%u:\n",
                      ppl->intprob.extendedErr,
                      fDsidHideAll ? 0 : ppl->intprob.dsid,
                      pTHS->pErrInfo->AtrErr.count);
            cbTempBuff = strlen(pTempBuff);
            if(cbTempBuff+cbUsedString > cbString) {
                cbString = 2 * (cbTempBuff + cbUsedString);
                pString = THReAlloc(pString, cbString);
                if(!pString)
                    return FALSE;
                
            }
            
            strcat(pString, pTempBuff);
            cbUsedString += cbTempBuff;
            
            for (u=0; u<pTHS->pErrInfo->AtrErr.count; u++) {
                if (pAC = SCGetAttById(pTHS, ppl->intprob.type)) {
                    pName = pAC->name;
                } else {
                    pName = pUnknown;
                }
                
                if (ppl->intprob.valReturned) {
                    _snprintf(pTempBuff, 1024,
                              "\t%u: %08X: DSID-%08X, problem %u (%s), data %d,"
                              " Att %x (%s):len %u\n",
                              u,
                              ppl->intprob.extendedErr,
			      fDsidHideAll ? 0 : ppl->intprob.dsid,
                              ppl->intprob.problem,
                              GetProblemString(ppl->intprob.problem),
                              ppl->intprob.extendedData,
                              ppl->intprob.type,
                              pName,
                              ppl->intprob.Val.valLen);
                }
                else {
                    _snprintf(pTempBuff, 1024,
                              "\t%u: %08X: DSID-%08X, problem %u (%s), data %d,"
                              " Att %x (%s)\n",
                              u,
                              ppl->intprob.extendedErr,
			      fDsidHideAll ? 0 : ppl->intprob.dsid,
                              ppl->intprob.problem,
                              GetProblemString(ppl->intprob.problem),
                              ppl->intprob.extendedData,
                              ppl->intprob.type,
                              pName);
                }
                
                cbTempBuff = strlen(pTempBuff);
                if(cbTempBuff+cbUsedString > cbString) {
                    cbString = 2 * (cbTempBuff + cbUsedString);
                    pString = THReAlloc(pString, cbString);
                    if(!pString)
                        return FALSE;
                }
                strcat(pString, pTempBuff);
                cbUsedString += cbTempBuff;
                ppl = ppl->pNextProblem;
            }
        } 
        else {
            // No specific problems where set
            _snprintf(pTempBuff, 1024,"00000001: AtrErr: DSID-00000000, #0:\n");
        }
        break;
         
    case nameError:
        _snprintf(pTempBuff, 1024,
                  "%08X: NameErr: DSID-%08X, problem %u (%s), data %d, best"
                  " match of:\n\t'%S'\n",
                  pTHS->pErrInfo->NamErr.extendedErr,
                  fDsidHideOnName ? 0 :pTHS->pErrInfo->NamErr.dsid,
                  pTHS->pErrInfo->NamErr.problem,
                  GetProblemString(pTHS->pErrInfo->NamErr.problem),
                  pTHS->pErrInfo->NamErr.extendedData,
                  pTHS->pErrInfo->NamErr.pMatched->StringName);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case updError:
        _snprintf(pTempBuff, 1024,
                  "%08X: UpdErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->UpdErr.extendedErr,
		  fDsidHideAll ? 0 : pTHS->pErrInfo->UpdErr.dsid,
                  pTHS->pErrInfo->UpdErr.problem,
                  GetProblemString(pTHS->pErrInfo->UpdErr.problem),
                  pTHS->pErrInfo->UpdErr.extendedData);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case systemError:
        // Note that problems are from a different space
        _snprintf(pTempBuff, 1024,
                  "%08X: SysErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->SysErr.extendedErr,
		  fDsidHideAll ? 0 : pTHS->pErrInfo->SysErr.dsid,
                  pTHS->pErrInfo->SysErr.problem,
                  strerror(pTHS->pErrInfo->SysErr.problem),
                  pTHS->pErrInfo->SysErr.extendedData);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case referralError:
        _snprintf(pTempBuff, 1024,
                  "%08X: RefErr: DSID-%08X, data %d, %u access points\n",
                  pTHS->pErrInfo->RefErr.extendedErr,
 		  fDsidHideAll ? 0 : pTHS->pErrInfo->RefErr.dsid,
                  pTHS->pErrInfo->RefErr.extendedData,
                  pTHS->pErrInfo->RefErr.Refer.count);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;

        pdal = pTHS->pErrInfo->RefErr.Refer.pDAL;
        for (u=0; u<pTHS->pErrInfo->RefErr.Refer.count; u++) {
            _snprintf(pTempBuff, 1024,
                      "\tref %u: '%.*S'\n",
                      u+1,
                      pdal->Address.Length/sizeof(WCHAR),
                      pdal->Address.Buffer);

            cbTempBuff = strlen(pTempBuff);
            if(cbTempBuff+cbUsedString > cbString) {
                cbString = 2 * (cbTempBuff + cbUsedString);
                pString = THReAlloc(pString, cbString);
                if(!pString)
                  return FALSE;
            }
            strcat(pString, pTempBuff);
            cbUsedString += cbTempBuff;

            pdal = pdal->pNextAddress;
        }
        break;
        
    case securityError:
        _snprintf(pTempBuff, 1024,
                  "%08X: SecErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->SecErr.extendedErr,
 		  fDsidHideAll ? 0 : pTHS->pErrInfo->SecErr.dsid,
                  pTHS->pErrInfo->SecErr.problem,
                  GetProblemString(pTHS->pErrInfo->SecErr.problem),
                  pTHS->pErrInfo->SecErr.extendedData);
        
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
        
    case serviceError:
        _snprintf(pTempBuff, 1024,
                  "%08X: SvcErr: DSID-%08X, problem %u (%s), data %d\n",
                  pTHS->pErrInfo->SvcErr.extendedErr,
 		  fDsidHideAll ? 0 : pTHS->pErrInfo->SvcErr.dsid,
                  pTHS->pErrInfo->SvcErr.problem,
                  GetProblemString(pTHS->pErrInfo->SvcErr.problem),
                  pTHS->pErrInfo->SvcErr.extendedData);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;

    case 0:
        /* no error */
        cbTempBuff = strlen(pNoError);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString = 2 * (cbTempBuff + cbUsedString);
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pNoError);
        cbUsedString += cbTempBuff;
        break;       
        
    default:
        _snprintf(pTempBuff, 1024,
                "Invalid error code of %u\n",
                pTHS->errCode);
        cbTempBuff = strlen(pTempBuff);
        if(cbTempBuff+cbUsedString > cbString) {
            cbString *= 2;
            pString = THReAlloc(pString, cbString);
            if(!pString)
                return FALSE;
        }
        strcat(pString, pTempBuff);
        cbUsedString += cbTempBuff;
        break;
    }

    if(cbUsedString) {
        pString = THReAlloc(pString, cbUsedString);
        if(!pString)
            return FALSE;
        *ppBuf = pString;
        *pcbBuf = cbUsedString;
    }
    else {
        THFree(pString);
    }

    return TRUE;
}

LPSTR
THGetErrorString()
/*++

Routine Description:

    Return error string associated with THSTATE error; free with THFree().
    
    EXPORTED TO EX-MODULE, IN-PROCESS CALLERS.

Arguments:

    None.
    
Return Values:

    Non-NULL error string on success, NULL on failure.

--*/
{
    LPSTR pszError;
    DWORD cbError;

    if (!CreateErrorString(&pszError, &cbError)) {
        pszError = NULL;
    }

    return pszError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdcomp.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdcomp.c
//
//--------------------------------------------------------------------------

/*

Description:
    
    Implements the DirCompare API.
    
    DSA_DirCompare() is the main function exported from this module.
    
*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h> 
#include <scache.h>			// schema cache 
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header 
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>			// needed for output allocation 
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"			// header Audit\Alert logging 
#include "dsexcept.h"
#include "mdcodes.h"			// header for error codes 

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include <filtypes.h>                   // Def for FI_CHOICE_???
#include "debug.h"			// standard debugging header 
#define DEBSUB "MDCOMPARE:"             // define the subsystem for debugging 

#include <fileno.h>
#define  FILENO FILENO_MDCOMP


/* Internal functions */

int LocalCompare(THSTATE *pTHS, COMPAREARG *pCompareArg,
		 COMPARERES *pCompareRes);


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirCompare(
    COMPAREARG* pCompareArg,    /* Compare  argument */
    COMPARERES **ppCompareRes
    ){
      
    THSTATE*     pTHS;
    COMPARERES *pCompareRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirCompare entered\n");

    /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
       is required on every API transaction.  First the state DS is initialized
       and then either a read or a write sync point is established.
       */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppCompareRes = pCompareRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppCompareRes = pCompareRes = THAllocEx(pTHS, sizeof(COMPARERES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if ((eServiceShutdown >= eSecuringDatabase) ||
                ((eServiceShutdown >= eRemovingClients) && !pTHS->fDSA)) {
                ErrorOnShutdown();
                __leave;
            }
        }
        SYNC_TRANS_READ();   /*Identify a reader trans*/
        __try {

            /* Perform name resolution to locate object.  If it fails, just 
            * return an error, which may be a referral.
            */

            if (0 == DoNameRes(pTHS,
                               NAME_RES_QUERY_ONLY,
                               pCompareArg->pObject,
                               &pCompareArg->CommArg,
                               &pCompareRes->CommRes,
                               &pCompareArg->pResObj)){

               /* Local compare operation */
	   
                LocalCompare(pTHS, pCompareArg, pCompareRes);
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pCompareRes) {
        pCompareRes->CommRes.errCode = pTHS->errCode;
        pCompareRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;
}/*DirCompare*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the Distname if an alias was dereferenced.  Determine if the object
   is a master or replica.  Match the user attribute and value against the
   object.  If a match is found return TRUE, if not return FALSE.

   NOTE that we use the attribute type to determine the type of
   comparison, via the DBEval call (the same call is used in evaluating
   filter items in a ds_search call.)
*/

int LocalCompare(THSTATE *pTHS,
		 COMPAREARG *pCompareArg,
		 COMPARERES *pCompareRes)
{

    DWORD   err;
    SYNTAX_INTEGER       iType;
    ATTCACHE             *pAC;
    ULONG                ulLen;
    PSECURITY_DESCRIPTOR pSecurity = NULL;
    BOOL                 fSDIsGlobalSDRef;
    DSNAME TempDN;
    CLASSCACHE *pCC=NULL;
    BOOL                 fNoAtt = FALSE;
    DWORD       cInAtts = 1;
    DWORD classP;
    PUCHAR pVal=(PUCHAR)&classP;
    TRIBOOL     retfil;
    
    //
    // Log Event for tracing
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_COMPARE,
                     EVENT_TRACE_TYPE_START,
                     DsGuidCompare,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertUL(pCompareArg->Assertion.type),
                     szInsertDN(pCompareArg->pObject),
                     NULL, NULL, NULL, NULL, NULL);

    /*Get and set the DN if an alias was dereferenced*/

    //
    // check to see if the object is visible at all
    //
    if (!IsObjVisibleBySecurity(pTHS, TRUE)) {
        CheckObjDisclosure(pTHS, pCompareArg->pResObj, FALSE);
        goto exit;
    }

    if (pCompareRes->CommRes.aliasDeref){

        if (err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                            0,
                            0,
                            &ulLen, (UCHAR **)&pCompareRes->pObject)){
          
            DPRINT(2,"Problem retrieving DN attribute\n");
          
          
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                   DS_EVENT_SEV_MINIMAL,
                   DIRLOG_CANT_RETRIEVE_DN,
                   szInsertDN(pCompareArg->pObject),
                   szInsertUL(err),
                   NULL);

            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_DN,
                                err);
            goto exit;
        }
    }
    else {
        pCompareRes->pObject = NULL;
    }

    /* Determine of the object is a master or a replica */
    if(err = DBGetSingleValue(pTHS->pDB, ATT_INSTANCE_TYPE, &iType,
                       sizeof(iType), NULL)) {
        DPRINT(2, "Can't retrieve instance type\n");
        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_RETRIEVE_INSTANCE,
                szInsertDN(GetExtDSName(pTHS->pDB)),
                szInsertUL(err),
                szInsertHex(DSID(FILENO, __LINE__)));
       
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                      DIRERR_CANT_RETRIEVE_INSTANCE, err);
        goto exit;
    }
   
    DPRINT1(2,"Instance type is <%lx>\n",iType);

    if ( iType & IT_WRITE ) {
        pCompareRes->fromMaster = TRUE;
    } else {
        pCompareRes->fromMaster = FALSE;
    }

    pAC = SCGetAttById(pTHS, pCompareArg->Assertion.type);
    Assert(pAC != NULL);

    /* Check if the attribute type and value exists on this object*/

    if(!(pAC && DBHasValues_AC(pTHS->pDB, pAC))) {
       
        DPRINT1(2,"No Att, No match%lu\n", pCompareArg->Assertion.type);
        fNoAtt = TRUE;
    }
   
    if (!fNoAtt) {

        if (pCompareArg->Assertion.Value.valLen == 0){

            DPRINT1(2,"No Att value provided, No match%lu\n", pCompareArg->Assertion.type); 

            pCompareRes->matched = FALSE;
            goto exit;
        }

        //
        // See whether the client has read access to the attribute.
        //

        // Get the SD, GUID, SID and class cache ptr
        // Now, an abbreviated form the the DSNAME.
        TempDN.structLen = DSNameSizeFromLen(0);
        TempDN.NameLen = 0;
        
        err = DBGetObjectSecurityInfo(pTHS->pDB, pTHS->pDB->DNT,
                                      &ulLen, &pSecurity, &pCC, &TempDN, NULL,
                                      DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                                      &fSDIsGlobalSDRef
                                     );

        Assert(!err);
                                      
        // Finally do the security check.  If the check fails then pAC will
        // be NULL'ed out.
        CheckReadSecurity(pTHS,
                          0,               // no SD flags
                          pSecurity,
                          &TempDN,
                          pCC,
                          NULL,
                          &cInAtts,
                          &pAC); 

        if (!pAC) {
            //
            // Failed the access check
            //
            fNoAtt = TRUE;
        }
        if (pSecurity && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pSecurity);
        }
    }
    
    if (fNoAtt) {
        //
        // Set this error here so that the case where the att doesn't exist, and
        // the case where the user doesn't have permission to see that att can't
        // be distuinguished by DSID
        //
        pCompareRes->matched = FALSE;
        SetAttError(pCompareArg->pObject,
                          pCompareArg->Assertion.type,
                          PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                          DIRERR_CANT_ADD_ATT_VALUES);
        goto exit;
    }

    //
    // Finally do the comparison.
    //
    if(!FLegalOperator(pAC->syntax,FI_CHOICE_EQUALITY)) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_GENERIC_ERROR);
        goto exit;
    }
   
    retfil = DBEval(pTHS->pDB, FI_CHOICE_EQUALITY, 
                                  pAC,
                                  pCompareArg->Assertion.Value.valLen,
                                  pCompareArg->Assertion.Value.pVal);
    Assert(VALID_TRIBOOL(retfil));
    pCompareRes->matched = (eTRUE == retfil);

    if(pCompareRes->matched) {
        DPRINT1(2,"Att value matched %lu\n", pCompareArg->Assertion.type);
    } else {
        DPRINT1(2,"No Att value match,%lu\n", pCompareArg->Assertion.type);
    }


exit:
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_COMPARE,
                     EVENT_TRACE_TYPE_END,
                     DsGuidCompare,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL,
                     NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;
   
}/*LocalCompare*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdctrl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdctrl.c
//
//--------------------------------------------------------------------------

/*
Description:

    Implements functions that control the operation of the DSA, independent
    of the directory data
*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <dsjet.h>
#include <ntdsa.h>
#include <filtypes.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "hiertab.h"
#include "sdprop.h"
#include "dstaskq.h"                    /* task queue stuff */
#include "debug.h"                      // standard debugging header
#define DEBSUB "MDCTRL:"                // define the subsystem for debugging

// MD layer headers.
#include "drserr.h"

#include "drautil.h"
#include "draasync.h"
#include "drarpc.h"
#include "drancrep.h"

// RID Manager header.
#include <ridmgr.h>                     // RID FSMO access in SAM

#include <NTDScriptExec.h>

#include <winsock.h>

#include <fileno.h>
#define  FILENO FILENO_MDCTRL

#define DIRERR_INVALID_RID_MGR_REF  DIRERR_GENERIC_ERROR
#define DIRERR_RID_ALLOC_FAILED     DIRERR_GENERIC_ERROR
#define PDC_CHECKPOINT_RETRY_COUNT  10

/* globals */

BOOL gbFsmoGiveaway;

/* forward declarations */

void
RefreshUserMembershipsMain(DWORD *, BOOL);


ULONG
BecomeInfrastructureMaster(OPRES *pOpRes);

ULONG
BecomeSchemaMaster(OPRES *pOpRes);

ULONG
SchemaCacheUpdate(OPRES *pOpRes);

ULONG
RecalcHier (
        OPRES *pOpRes
        );

ULONG
CheckPhantoms (
        OPRES *pOpRes
        );

ULONG
FixupSecurityInheritance (
        OPARG *pOpArg,
        OPRES *pOpRes
        );

ULONG
GarbageCollectionControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        );

ULONG
OnlineDefragControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        );

#if DBG
ULONG
DynamicObjectControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        );

#endif DBG

void
LinkCleanupControl (
    OPRES *pOpRes
    );

ULONG
UpdateCachedMemberships(
    OPARG * pOpArg,
    OPRES *pOpRes
    );

ULONG
BecomeRidMaster(
    OPRES *pOpRes
    );

ULONG
ReplicateSingleObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    );

ULONG
RequestRidAllocation(
    OPRES *pOpRes
    );

ULONG
BecomePdc(OPARG * pOpArg, OPRES *pOpRes, BOOL fFailOnNoCheckPoint);

ULONG
BecomeDomainMaster(OPARG * pOpArg, OPRES *pOpRes);

ULONG
GiveawayAllFsmoRoles(OPARG * pOpArg, OPRES *pOpRes);

ULONG
InvalidateRidPool(OPARG *pOpArg, OPRES *pOpRes);

ULONG
DumpDatabase(OPARG *pOpArg, OPRES *pOpRes);

ULONG
DraTakeCheckPoint(
            IN ULONG RetryCount,
            OUT PULONG RescheduleInterval
            );

ULONG
SchemaUpgradeInProgress(
    OPARG *pOpArg,
    OPRES *pOpRes
    );


ULONG
RemoveSingleLingeringObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    );

#if DBG
void DbgPrintErrorInfo();

ULONG
DraTestHook(
    IN  THSTATE *   pTHS,
    IN  OPARG *     pOpArg
    );

DWORD
dsaEnableLinkCleaner(
    BOOL fEnable
    );
#endif

#ifdef INCLUDE_UNIT_TESTS
void
TestReferenceCounts(void);
void
TestCheckPoint(void);
void
RoleTransferStress(void);
void
AncestorsTest(void);
void
BHCacheTest(void);
void
SCCheckCacheConsistency (void);
void
phantomizeForOrphanTest (
    THSTATE *pTHS,
    OPARG   * pOpArg
    );
VOID
RemoveObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    );

ULONG
GenericControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        );

VOID
ProtectObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    );

#endif INCLUDE_UNIT_TESTS


BOOL
isFsmoOwnedAndValid(
    THSTATE *pTHS,
    DSNAME *pFSMO
    )

/*++

Routine Description:

    Helper functon to test whether we own the given fsmo and it is valid.

    We are called with an open DBPOS and currency is changed.

Arguments:

    pTHS - thread state
    pFSMO - Fsmo to check

Return Value:

    BOOL - we own it & valid

    No errors are returned or raised.

--*/

{
    ULONG err;
    DSNAME *pOwner = NULL;
    ULONG len;
    BOOL fResult = FALSE;

    if (!pFSMO) {
        return FALSE;
    }

    err = DBFindDSName(pTHS->pDB, pFSMO);
    if (err) {
        goto cleanup;
    }

    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_FSMO_ROLE_OWNER,
                      0,
                      0,
                      &len,
                      (UCHAR **)&pOwner);
    if (err) {
        goto cleanup;
    }

    if (NameMatched(pOwner,gAnchor.pDSADN) &&
        IsFSMOSelfOwnershipValid( pFSMO )) {
        fResult = TRUE;
    }

 cleanup:
    if (pOwner) {
        THFreeEx(pTHS, pOwner);
        pOwner = NULL;
    }

    return fResult;
} /* isFsmoOwnedAndValid */


VOID
DsaGetValidFSMOs(
    THSTATE *pTHS,
    LPSTR **ppszValidFsmos,
    DWORD *pcValidFsmos
    )

/*++

Routine Description:

    Generate a list of fsmos that are valid

    The primary dbpos is assumed to be closed. One is opened for the
    duration of this function

Arguments:

    pTHS - thread state, primary dbpos closed
    ppszValidFsmos - pointer to receive array of LPSTRs
                     Returns NULL if none.
    pcValidFsmos - pointer to receive dword count of LPSTRs
                   Returns zero if none.

Return Value:

    None

--*/

{
    LPSTR *pszValidFsmos = NULL;
    DWORD cValidFsmos = 0;
    ULONG Length = 0;
    DSNAME *pRidManager = NULL;

#define MAX_VALID_FSMOS 5

#define INSERT_FSMO( pdn ) \
        if (isFsmoOwnedAndValid( pTHS, (pdn) )) { \
            Assert( cValidFsmos < MAX_VALID_FSMOS ); \
            pszValidFsmos[cValidFsmos++] = String8FromUnicodeString( \
                    TRUE, CP_ACP, \
                    (pdn)->StringName,(pdn)->NameLen, \
                    NULL, NULL ); \
        }

    Assert( ppszValidFsmos && pcValidFsmos );

    pszValidFsmos = (LPSTR *) THAllocEx( pTHS, sizeof(LPSTR) * MAX_VALID_FSMOS );

    // This code is designed to come in without primary DBPOS open
    Assert( pTHS->pDB == NULL );
    DBOpen2(TRUE, &(pTHS->pDB));
    __try {
        // Enterprise:Schema
        INSERT_FSMO( gAnchor.pDMD );
        // Enterprise:Naming
        INSERT_FSMO( gAnchor.pPartitionsDN );
        // Domain:PDC
        INSERT_FSMO( gAnchor.pDomainDN );
        // Domain:Infrastructure
        INSERT_FSMO (gAnchor.pInfraStructureDN );
        // Domain:Rid
        if ( (0 == DBFindDSName(pTHS->pDB, gAnchor.pDomainDN)) &&
             (0 == DBGetAttVal(pTHS->pDB, 1, ATT_RID_MANAGER_REFERENCE,
                               0, 0, &Length, (UCHAR **)&pRidManager)) ) {
            INSERT_FSMO( pRidManager );
        }
    }
    __finally {
	DBClose( pTHS->pDB, TRUE); 
        pTHS->pDB = NULL;

        if (pRidManager) {
            THFreeEx(pTHS, pRidManager);
        }

        if (!cValidFsmos) {
            THFreeEx( pTHS, pszValidFsmos );
            pszValidFsmos = NULL;
        }
        *pcValidFsmos = cValidFsmos;
        *ppszValidFsmos = pszValidFsmos;
    }

} /* GetValidFSMOs */

/*++ ParseInput
 *
 * Description:
 *    This function takes an input string, a delimiter and an index value
 *    and returns a pointer to a substring.  The index value
 *    describes which string to return.  For example:
 *    
 *    	"gregjohndomain" == ParseInput("gregjohndomain.nttest.microsoft.com", '.', 0);
 *    	"nttest" == ParseInput("gregjohndomain.nttest.microsoft.com", '.', 1)
 *    	NULL == ParseInput("gregjohndomain.nttest.microsoft.com", '.', 4) 
 *	"ain.nttest." = ParseInput("gregjohndomain.nttest.microsoft.com", 'm', 1)
 *
 * Arguments:
 *    
 *    pszInput - the string to parse
 *    chDelim  - the delimiter to parse with
 *    dwInputIndex - the index of the item to parse
 * 
 * Return Value:
 *    a pointer to the requested index within pszInput (ThAlloced), NULL if not found
 */
LPSTR
ParseInput(
    LPSTR pszInput,
    int   chDelim,
    DWORD dwInputIndex
    )
{
    DWORD i = 0;
    LPSTR pszOutputBegin = pszInput;
    LPSTR pszOutputEnd = NULL;
    LPSTR pszOutput = NULL;
    ULONG cchOutput = 0;

    for (i=0; (i<dwInputIndex) && (pszOutputBegin!=NULL); i++) {
        pszOutputBegin = strchr(pszOutputBegin,chDelim);
        if (pszOutputBegin) {
            pszOutputBegin++;
        }
    }
    if (pszOutputBegin==NULL) {
        return NULL;
    }

    pszOutputEnd = strchr(pszOutputBegin,chDelim);
    cchOutput = pszOutputEnd ? (ULONG) (pszOutputEnd-pszOutputBegin) : (strlen(pszOutputBegin));
    pszOutput = THAlloc((cchOutput+1)*sizeof(CHAR));
    if (pszOutput==NULL) {
        return NULL;
    }

    memcpy(pszOutput, pszOutputBegin, cchOutput*sizeof(CHAR));
    pszOutput[cchOutput] = '\0';

    return pszOutput;
}

ULONG
DirOperationControl(
                    OPARG   * pOpArg,
                    OPRES  ** ppOpRes
)
{
    THSTATE * const pTHS = pTHStls;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    OPRES * pOpRes;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->transControl == TRANSACT_BEGIN_END);
    *ppOpRes = pOpRes = NULL;

    __try {
        *ppOpRes = pOpRes = THAllocEx(pTHS, sizeof(OPRES));
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

        switch (pOpArg->eOp) {

#ifdef INCLUDE_UNIT_TESTS
        // These are tests only, and therefore don't have defined security
        // mechanisms.  In general, anyone can request these controls
        case OP_CTRL_REFCOUNT_TEST:
            TestReferenceCounts();
            pTHS->errCode = 0;
            pTHS->pErrInfo = NULL;
            break;

        case OP_CTRL_TAKE_CHECKPOINT:
            TestCheckPoint();
            pTHS->errCode = 0;
            pTHS->pErrInfo = NULL;
            break;

        case OP_CTRL_ROLE_TRANSFER_STRESS:
            RoleTransferStress();
            pTHS->errCode=0;
            pTHS->pErrInfo=NULL;
            break;

        case OP_CTRL_ANCESTORS_TEST:
            AncestorsTest();
            pTHS->errCode = 0;
            pTHS->pErrInfo = NULL;
            break;

        case OP_CTRL_BHCACHE_TEST:
            BHCacheTest();
            pTHS->errCode = 0;
            pTHS->pErrInfo = NULL;
            break;

        case OP_SC_CACHE_CONSISTENCY_TEST:
            SCCheckCacheConsistency();
            pTHS->errCode = 0;
            pTHS->pErrInfo = NULL;
            break;

        case OP_CTRL_PHANTOMIZE:
            phantomizeForOrphanTest( pTHS, pOpArg );
            break;

        case OP_CTRL_REMOVE_OBJECT:
            RemoveObject(pOpArg,pOpRes);
            break;

        case OP_CTRL_PROTECT_OBJECT:
            ProtectObject(pOpArg,pOpRes);
            break;

        case OP_CTRL_GENERIC_CONTROL:
            GenericControl(pOpArg,pOpRes);
            break;
#endif INCLUDE_UNIT_TESTS

#if DBG
        // These only have effect in debug builds, and are therefore not
        // access controlled.
        case OP_CTRL_REPL_TEST_HOOK:
            DraTestHook(pTHS, pOpArg);
            break;

        case OP_CTRL_DYNAMIC_OBJECT_CONTROL:
            DynamicObjectControl(pOpArg,pOpRes);
            break;

        case OP_CTRL_EXECUTE_SCRIPT:
            ExecuteScriptLDAP(pOpArg,pOpRes);
            break;

#endif DBG

        case OP_CTRL_ENABLE_LVR:
            DsaEnableLinkedValueReplication( pTHS, TRUE );
            break;

            // These are FSMO based controls.  They are access controlled based
            // on the object holding the FSMO attribute
        case OP_CTRL_BECOME_INFRASTRUCTURE_MASTER:
            BecomeInfrastructureMaster(pOpRes);
            break;

        case OP_CTRL_BECOME_SCHEMA_MASTER:
            BecomeSchemaMaster(pOpRes);
            break;

        case OP_CTRL_BECOME_RID_MASTER:
            BecomeRidMaster(pOpRes);
            break;

	case OP_CTRL_REPLICATE_OBJECT:
	    ReplicateSingleObject(pOpArg,pOpRes);
	    break;

        case OP_CTRL_BECOME_PDC:
            BecomePdc(pOpArg,pOpRes,FALSE);
            break;

        case OP_CTRL_BECOME_PDC_WITH_CHECKPOINT:
            BecomePdc(pOpArg,pOpRes,TRUE);
            break;

        case OP_CTRL_BECOME_DOM_MASTER:
            BecomeDomainMaster(pOpArg,pOpRes);
            break;

        case OP_CTRL_FSMO_GIVEAWAY:
            // NOT ACCESS CONTROLLED - exposed as operational control through
            // LDAP only in debug builds (but always exposed to internal
            // clients).
            GiveawayAllFsmoRoles(pOpArg,pOpRes);
            break;

        case OP_CTRL_INVALIDATE_RID_POOL:
            // Access controlled the same as become rid master.
            InvalidateRidPool(pOpArg,pOpRes);
            break;

        case OP_CTRL_RID_ALLOC:
            // This one should only be called by internal clients.  No security
            // is checked.
            Assert(pTHS->fDSA);
            RequestRidAllocation(pOpRes);
            break;


            // These are requests for a specific action, not based on FSMOs.
            // They are individually access controlled.
        case OP_CTRL_SCHEMA_UPDATE_NOW:
            SchemaCacheUpdate(pOpRes);
            break;

        case OP_CTRL_FIXUP_INHERITANCE:
            FixupSecurityInheritance(pOpArg,pOpRes);
            break;

        case OP_CTRL_RECALC_HIER:
            RecalcHier(pOpRes);
            break;

        case OP_CTRL_CHECK_PHANTOMS:
            CheckPhantoms(pOpRes);
            break;

        case OP_CTRL_DUMP_DATABASE:
            DumpDatabase(pOpArg,pOpRes);
            break;

        case OP_CTRL_GARB_COLLECT:
            GarbageCollectionControl(pOpArg,pOpRes);
            break;

        case OP_CTRL_ONLINE_DEFRAG:
            OnlineDefragControl(pOpArg,pOpRes);
            break;

        case OP_CTRL_LINK_CLEANUP:
            LinkCleanupControl( pOpRes );
            break;

        case OP_CTRL_UPDATE_CACHED_MEMBERSHIPS:
            UpdateCachedMemberships(pOpArg,pOpRes);
            break;

        case OP_CTRL_SCHEMA_UPGRADE_IN_PROGRESS:
            SchemaUpgradeInProgress(pOpArg,pOpRes);
            break;

	case OP_CTRL_REMOVE_LINGERING_OBJECT:
	    RemoveSingleLingeringObject(pOpArg,pOpRes);
	    break;

        case OP_CTRL_INVALID:
        default:
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        DIRERR_UNKNOWN_OPERATION);
        }

    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pOpRes) {
        pOpRes->CommRes.errCode = pTHS->errCode;
        pOpRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }
    return pTHS->errCode;
}

ULONG
GenericBecomeMaster(DSNAME *pFSMO,
                    ATTRTYP ObjClass,
                    GUID    RightRequired,
                    OPRES  *pOpRes)
{
    THSTATE * pTHS = pTHStls;
    ULONG err;
    DSNAME *pOwner = NULL;
    ULONG len;
    CLASSCACHE *pCC;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    BOOL fSDIsGlobalSDRef;
    unsigned RetryCount = 0;

    if (gbFsmoGiveaway) {
        pOpRes->ulExtendedRet = EXOP_ERR_FSMO_REFUSING_ROLES;
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           DS_ERR_REFUSING_FSMO_ROLES);
    }

  retry:
    SYNC_TRANS_READ();

    __try {
        err = DBFindDSName(pTHS->pDB, pFSMO);
        if (err) {
            LogUnhandledError(err);
            pOpRes->ulExtendedRet = EXOP_ERR_DIR_ERROR;
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DS_ERR_INVALID_ROLE_OWNER, err);
            __leave;
        }

         /*  Before we do anything, we need to make sure that the caller 
          *  should be allowed to do FSMO transfer operation.
         */

        if (!pTHS->fDSA) {
            // Get the Security Descriptor and class
            err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pTHS->pDB->DNT,
                    &len,
                    &pNTSD,
                    &pCC,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef);
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
            }
            // Every object should have an SD.
            Assert(len > 0 || !DBCheckObj(pTHS->pDB));

            if (!IsControlAccessGranted(pNTSD,
                                        pFSMO,
                                        pCC,
                                        RightRequired,
                                        TRUE)) { // fSetError
                pOpRes->ulExtendedRet = EXOP_ERR_ACCESS_DENIED;
                Assert(pTHS->errCode);
                __leave;
            }
        }


        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_FSMO_ROLE_OWNER,
                          0,
                          0,
                          &len,
                          (UCHAR **)&pOwner);
        if (err) {
            pOpRes->ulExtendedRet = EXOP_ERR_FSMO_MISSING_SETTINGS;
            SetSvcErrorEx(SV_PROBLEM_UNAVAIL_EXTENSION,
                          DS_ERR_INVALID_ROLE_OWNER, err);
            __leave;
        }
        if (NameMatched(pOwner,gAnchor.pDSADN) &&
            IsFSMOSelfOwnershipValid( pFSMO )) {
            /* This DSA is already the role owner */
            pOpRes->ulExtendedRet = EXOP_ERR_SUCCESS;
            __leave;
        }

        
        /* Ok, we're allowed to try, so request a role transfer */
        err = ReqFSMOOp(pTHS,
                        pFSMO,
                        DRS_WRIT_REP,
                        EXOP_FSMO_REQ_ROLE,
                        0,
                        &pOpRes->ulExtendedRet);

        if (err) {
            SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                          DIRERR_COULDNT_CONTACT_FSMO, err);

            pOpRes->ulExtendedRet = EXOP_ERR_COULDNT_CONTACT;

            __leave;
        }
    }
    __finally {
        // We may or may not have a transaction here, as ReqFSMOOp closes
        // its transaction in a success path.  If an error has occurred,
        // though, it's anyone's guess.
        // Also, the transaction may be open if the current role owner
        // called this by mistake. The call to NameMatched finds this,
        // and leaves without closing the transaction
        if (pTHS->pDB) {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        Assert(NULL == pTHS->pDB);

        if (pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
        pNTSD = NULL;
        if (pOwner) {
            THFreeEx(pTHS, pOwner);
            pOwner = NULL;
        }
    }

    // If the extended error code in the OpRes is not EXOP_ERROR_SUCCESS,
    // and the thread state error code is not set (possible, since the
    // thread state error code is set at this point based on the success
    // of the underlying ReqFSMOOp call, which just guarantees the success
    // of the underlying replication calls, and not if any non-replication
    // related fsmo error occured (for ex., if the other side is no longer
    // the current fsmo-role owner; the call will still succeed with no
    // errors, but the extended error code will contain the error
    // EXOP_ERR_FSMO_NOT_OWNER), we should not be proclaimg success, since
    // this DC may then go on to make schema changes and fail.

    if ((pOpRes->ulExtendedRet == EXOP_ERR_FSMO_NOT_OWNER) &&
        (RetryCount < 2)) {
        // We went to the wrong server, but that server should have now
        // updated us with its knowledge of the correct owner.  Thus we
        // can go up and start a new transaction (to read the updated info)
        // and try again.
        ++RetryCount;
        DPRINT1(1, "Retrying role transfer from new server, retry # %u\n",
                RetryCount);
        goto retry;
    }

    if ( (pOpRes->ulExtendedRet != EXOP_ERR_SUCCESS) && !pTHS->errCode ) {
        DPRINT1(3,"Fsmo Transfer failed %d\n", pOpRes->ulExtendedRet);
        SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                      DIRERR_COULDNT_CONTACT_FSMO, pOpRes->ulExtendedRet);
    }

    return pTHS->errCode;
}

ULONG
BecomeSchemaMaster(OPRES *pOpRes)
{
    ULONG err;

    err = GenericBecomeMaster(gAnchor.pDMD,
                              CLASS_DMD,
                              RIGHT_DS_CHANGE_SCHEMA_MASTER,
                              pOpRes);
    // the schema fsmo cannot be transferred for a few seconds after
    // it has been transfered or after a schema change (excluding
    // replicated or system changes). This gives the schema admin a
    // chance to change the schema before having the fsmo pulled away
    // by a competing schema admin who also wants to make schema
    // changes.
    if (!err) {
        SCExtendSchemaFsmoLease();
    }


    return err;
}

ULONG
BecomeInfrastructureMaster (
        OPRES *pOpRes
        )
{
    ULONG err;

    if(!gAnchor.pInfraStructureDN) {
        // No role present.
        err = SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                            ERROR_DS_MISSING_EXPECTED_ATT,
                            0);
        return err;
    }

    err = GenericBecomeMaster(gAnchor.pInfraStructureDN,
                              CLASS_INFRASTRUCTURE_UPDATE,
                              RIGHT_DS_CHANGE_INFRASTRUCTURE_MASTER,
                              pOpRes);

    return err;
}

ULONG
InvalidateRidPool(OPARG *pOpArg, OPRES *pOpRes)
{
    THSTATE * pTHS = pTHStls;
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    DSNAME    *pDomain;
    ULONG     err;
    DSNAME    *pRidManager = NULL;
    PVOID     pNTSD = NULL;
    CLASSCACHE *pCC;
    ULONG     len;
    BOOL      fSDIsGlobalSDRef;
    ATTCACHE* pAC;

     SYNC_TRANS_READ();

    __try
    {

        //
        // Verify the Sid, SID should be the size of a domain SID,
        // and should be structurally valid
        //

        if ((NULL==pOpArg->pBuf)
         || (RtlLengthSid((PSID)pOpArg->pBuf)>=sizeof(NT4SID))
            || (!RtlValidSid((PSID)pOpArg->pBuf)))
        {
            SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);

            __leave;
        }


        //
        // Walk the cross ref list and find the Domain, to which the given sid
        // corresponds to
        //

        if (!FindNcForSid(pOpArg->pBuf,&pDomain))
        {
            SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
            __leave;
        }


        //
        // Today we are authoritative for exactly one domain
        //

        if (!NameMatched(pDomain,gAnchor.pDomainDN))
        {
            SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
            __leave;
        }


        err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN);

        if (err)
        {
            LogUnhandledError(err);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err);
            __leave;
        }

        // grab the security descriptor
        if (err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pTHS->pDB->DNT,
                    &len,
                    &pNTSD,
                    &pCC,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
        }
        Assert(len > 0 || !DBCheckObj(pTHS->pDB));
        // can we read RID_MANAGER_REFERENCE?
        pAC = SCGetAttById(pTHS, ATT_RID_MANAGER_REFERENCE);
        Assert(pAC);
        if (!IsAccessGrantedAttribute(pTHS, pNTSD, gAnchor.pDomainDN, 1, pCC, &pAC, RIGHT_DS_READ_PROPERTY, TRUE)) {
            Assert(pTHS->errCode);
            __leave;
        }
        if (pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
        pNTSD = NULL;

        err = DBGetAttVal_AC(pTHS->pDB,
                             1,
                             pAC,
                             0,
                             0,
                             &len,
                             (UCHAR **)&pRidManager);


        // KdPrint(("DSA: FSMO RID Mgr = %ws\n", pRidManager->StringName));

        if (err)
        {
            SetSvcErrorEx(SV_PROBLEM_UNAVAIL_EXTENSION,
                          DIRERR_INVALID_RID_MGR_REF, err);
            __leave;
        }

        err = DBFindDSName(pTHS->pDB, pRidManager);

        if (err) {
            LogUnhandledError(err);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err);
            __leave;
        }

        // Do a security check.  Check for the control acces
        // RIGHT_DS_CHANGE_RID_MASTER on the RID_MANAGER object.


        // Get the Security Descriptor and the class
        if (err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pTHS->pDB->DNT,
                    &len,
                    &pNTSD,
                    &pCC,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
        }
        // Every object should have an SD.
        Assert(len > 0 || !DBCheckObj(pTHS->pDB));

        if (!IsControlAccessGranted(pNTSD,
                                    pRidManager,
                                    pCC,
                                    RIGHT_DS_CHANGE_RID_MASTER,
                                    TRUE)) { // fSetError
            Assert(pTHS->errCode);
            __leave;
        }
        //
        // Invalidate the RID range
        //

        NtStatus = SampInvalidateRidRange(FALSE);
        if (!NT_SUCCESS(NtStatus))
        {
            SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
            __leave;
        }

    }
    __finally
    {

        //
        // Commit any and all changes
        //
        if ( pTHS->pDB )
        {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        if (pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
        if (pRidManager) {
            THFreeEx(pTHS, pRidManager);
        }

    }

    return pTHS->errCode;

}


ULONG
BecomePdc(OPARG * pOpArg, OPRES *pOpRes, IN BOOL fFailOnNoCheckPoint)
{
    THSTATE * pTHS = pTHStls;
    ULONG err;
    DSNAME *pOwner;
    DSNAME *pDomain;
    ULONG len;
    CLASSCACHE *pCC;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    BOOL fSDIsGlobalSDRef;
    NTSTATUS    IgnoreStatus;
    ULONG       RescheduleInterval;
    unsigned RetryCount = 0;

  retry:
    SYNC_TRANS_READ();

    __try {

        //
        // Verify the Sid, SID should be the size of a domain SID,
        // and should be structurally valid
        //

        if ((NULL==pOpArg->pBuf)
             || (RtlLengthSid((PSID)pOpArg->pBuf)>=sizeof(NT4SID))
                || (!RtlValidSid((PSID)pOpArg->pBuf)))
        {
            SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);

            __leave;
        }


        //
        // Walk the cross ref list and find the Domain, to which the given sid
        // corresponds to
        //

        if (!FindNcForSid(pOpArg->pBuf,&pDomain))
        {
            SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
            __leave;
        }


        //
        // Today we are authoritative for exactly one domain
        //

        if (!NameMatched(pDomain,gAnchor.pDomainDN))
        {
            SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
            __leave;
        }

        //
        // Seek to the domain object
        //

        err = DBFindDSName(pTHS->pDB, pDomain);
        if (err) {
                LogUnhandledError(err);
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              DIRERR_OBJ_NOT_FOUND, err);
                __leave;
        }

        // check if the user has right, before
        // doing anything else

        // grab the security descriptor
        if (err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pTHS->pDB->DNT,
                    &len,
                    &pNTSD,
                    &pCC,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
        }
        Assert(len > 0 || !DBCheckObj(pTHS->pDB));
        
        if (!IsControlAccessGranted(pNTSD,
                                    pDomain,
                                    pCC,
                                    RIGHT_DS_CHANGE_PDC,
                                    TRUE)) { // fSetError
            Assert(pTHS->errCode);
            __leave;
        }


        /* Ok, we're allowed to try, so see if the dsa
         * is already the owner */
        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_FSMO_ROLE_OWNER,
                          0,
                          0,
                          &len,
                          (UCHAR **)&pOwner);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_UNAVAIL_EXTENSION,
                          DIRERR_INVALID_ROLE_OWNER, err);
            __leave;
        }
        if (NameMatched(pOwner,gAnchor.pDSADN)) {
            /* This DSA is already the role owner */
            pOpRes->ulExtendedRet = EXOP_ERR_SUCCESS;
            __leave;
        }

        /* There's an owner, but it's not us, so we need to contact
         * the current owner to request a transfer.
         */
        
        //
        // Ideally DRS_WRIT_REP, should not need to be passed in.
        // This flag, is an artifact of the replication logic, that
        // ReqFSMOOp uses, that causes FSMO's on NC heads to not get
        // updated, unless the flag is specified.
        //


        //
        // Further, during a promotion, we must check, wether the
        // the new PDC is off the old PDC by just one promotion
        // count. If this is not so, we must force a full sync of
        // NT4 domain controllers in the domain. This requires us
        // to retrieve Serial Number and Creation time at the PDC,
        // as part of the FSMO process. If this cannot be accomplished
        // because of the work involved, then we can make the
        // IDL_DRSGetNT4ChangeLog call to retrieve everything.
        //


        //
        // Before going off machine end transactions
        //

        Assert(pTHS->pDB);
        DBClose(pTHS->pDB,TRUE);

        //
        // Try Hard for a check point before promotion
        //

        err = DraTakeCheckPoint(
                PDC_CHECKPOINT_RETRY_COUNT,
                &RescheduleInterval
                );

        if ((0!=err) && (fFailOnNoCheckPoint))
        {
             SetSvcError(
                    SV_PROBLEM_WILL_NOT_PERFORM,
                    err);
             __leave;
        }

        //
        // Begin a Fresh Transaction Again to request a FSMO Op
        //


        DBOpen(&pTHS->pDB);

        err = ReqFSMOOp(pTHS,
                        pDomain,
                        DRS_WRIT_REP,
                        EXOP_FSMO_REQ_PDC,
                        0,
                        &pOpRes->ulExtendedRet);

        if (err)
        {
            SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                          DIRERR_COULDNT_CONTACT_FSMO, err);
            __leave;
        }

    }
    __finally {
        // We may or may not have a transaction here, as ReqFSMOOp closes
        // its transaction in a success path.  If an error has occurred,
        // though, it's anyone's guess.
        // Also, the transaction may be open if the current role owner
        // called this by mistake. The call to NameMatched finds this,
        // and leaves without closing the transaction
        if (pTHS->pDB) {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        Assert(NULL == pTHS->pDB);

        if(pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
        pNTSD = NULL;

    }

    if ((pOpRes->ulExtendedRet == EXOP_ERR_FSMO_NOT_OWNER) &&
        (RetryCount < 2)) {
        // We went to the wrong server, but that server should have now
        // updated us with its knowledge of the correct owner.  Thus we
        // can go up and start a new transaction (to read the updated info)
        // and try again.
        ++RetryCount;
        DPRINT1(1, "Retrying PDC transfer from new server, retry # %u\n",
                RetryCount);
        goto retry;
    }

    // If the extended error code in the OpRes is not EXOP_ERROR_SUCCESS,
    // and the thread state error code is not set (possible, since the
    // thread state error code is set at this point based on the success
    // of the underlying ReqFSMOOp call, which just guarantees the success
    // of the underlying replication calls, and not if any non-replication
    // related fsmo error occured (for ex., if the other side is no longer
    // the current fsmo-role owner; the call will still succeed with no
    // errors, but the extended error code will contain the error
    // EXOP_ERR_FSMO_NOT_OWNER), we should not be proclaimg success.

    if ( (pOpRes->ulExtendedRet != EXOP_ERR_SUCCESS) && !pTHS->errCode ) {
        DPRINT1(3,"PDC Fsmo Transfer failed %d\n", pOpRes->ulExtendedRet);
        SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                      DIRERR_COULDNT_CONTACT_FSMO, pOpRes->ulExtendedRet);
    }

    return pTHS->errCode;
}

DWORD
CheckControlAccessOnObject (
        THSTATE *pTHS,
        DSNAME *pDN,
        GUID right
        )
{
    DBPOS* pDB = NULL;
    DWORD err;
    DWORD len;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    CLASSCACHE *pCC=NULL;
    DWORD access = FALSE;
    BOOL fSDIsGlobalSDRef;

    DBOpen(&pDB);
    __try
    {
        err = DBFindDSName(pDB, pDN);

        if (err) {
            LogUnhandledError(err);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err);
            __leave;
        }

        // Do a security check.  Check for the control access right asked for

        // grab the security descriptor
        if (err = DBGetObjectSecurityInfo(
                    pDB,
                    pDB->DNT,
                    &len,
                    &pNTSD,
                    &pCC,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
        }
        Assert(len > 0 || !DBCheckObj(pDB));
        
        access = IsControlAccessGranted(pNTSD,
                                        pDN,
                                        pCC,
                                        right,
                                        TRUE);
    }
    __finally
    {
        // Transaction is read-only. It's faster to commit.
        DBClose(pDB, TRUE);
        if(pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
    }

    return access;
}

ULONG
RecalcHier (
        OPRES *pOpRes
        )
{
    void *dummy1;
    DWORD dummy2;
    BOOL granted;
    THSTATE *pTHS=pTHStls;

    granted = CheckControlAccessOnObject(pTHS,
                                         gAnchor.pDSADN,
                                         RIGHT_DS_RECALCULATE_HIERARCHY);
    if (!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    BuildHierarchyTableMain((void *)HIERARCHY_DO_ONCE,
                            &dummy1,
                            &dummy2);
    Assert(NULL == pTHS->pDB);
    return 0;
}

ULONG
CheckPhantoms (
        OPRES *pOpRes
        )
{
    THSTATE *pTHS=pTHStls;
    BOOL  granted;
    BOOL  dummy1;

    granted = CheckControlAccessOnObject(pTHS,
                                         gAnchor.pDSADN,
                                         RIGHT_DS_CHECK_STALE_PHANTOMS);
    if (!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }


    Assert(NULL == pTHS->pDB);
    PhantomCleanupLocal(NULL, &dummy1);
    Assert(NULL == pTHS->pDB);
    return 0;
}


// used when testing CHK builds
BOOL fGarbageCollectionIsDisabled;
ULONG
GarbageCollectionControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        )
{
    THSTATE *pTHS = pTHStls;
    ULONG NextPeriod;
    BOOL granted;
    DWORD ret;


    // Garbage collect everything deleted till tombstone lifetime back

    granted =
        CheckControlAccessOnObject(pTHS,
                                   gAnchor.pDSADN,
                                   RIGHT_DS_DO_GARBAGE_COLLECTION);
    if (!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    // Disable garbage collection task
    if (   pOpArg
        && pOpArg->cbBuf == 1
        && pOpArg->pBuf
        && pOpArg->pBuf[0] == '0') {
        fGarbageCollectionIsDisabled = TRUE;
    } else {
        fGarbageCollectionIsDisabled = FALSE;
    }

    // garbage collect
    //GarbageCollection(&NextPeriod);
    ret = TriggerTaskSynchronously( TQ_GarbageCollection, NULL );
    if (ret) {
        DPRINT1( 0, "Failed to trigger Garbage Collection task, error = %d\n", ret );
        LogUnhandledError(ret);
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ret );
    }

    return pTHS->errCode;
}


ULONG
OnlineDefragControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        )
{
    THSTATE *pTHS = pTHStls;
    BOOL granted;
    DBPOS   *pDB;
    ULONG   dwException, ulErrorCode, dsid;
    PVOID   dwEA;
    LONG lPasses=1, lSeconds;
    PCHAR pTmp;



    // Garbage collect everything deleted till tombstone lifetime back

    granted =
        CheckControlAccessOnObject(pTHS,
                                   gAnchor.pDSADN,
                                   RIGHT_DS_DO_GARBAGE_COLLECTION);
    if (!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    if ( !pOpArg || !pOpArg->cbBuf || !pOpArg->pBuf )
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION );
        return pTHS->errCode;
    }



    __try {

        // convert it to a number, the nubmer is the number 
        // of seconds that online defrag will run. 

        pTmp = THAllocEx(pTHS,pOpArg->cbBuf+1);
        memcpy(pTmp,pOpArg->pBuf,pOpArg->cbBuf);
        lSeconds = atol(pTmp);
        THFreeEx(pTHS,pTmp);
           
        if(lSeconds<0)
        {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION );
            return pTHS->errCode;
        }

        DBOpen(&pDB);
        __try {
            if (lSeconds){
                 
                // invoke Jet online defrag rountine,
                // we don't need to wait till it finishes.
            
                if (!eServiceShutdown) {
                    DBDefrag(pDB, (ULONG)lSeconds);
                }
             
            } else {
                // stop online defrag

                DBDefrag(pDB, 0);
            }
         
        } __finally {
             DBClose( pDB, TRUE);
        }
     
    } __except(GetExceptionData(GetExceptionInformation(),
                       &dwException,
                       &dwEA,
                       &ulErrorCode,
                       &dsid)) {
         
          DPRINT3(0, "OnlineDefrag() EXCEPTION: %08x (%d) ulErrorCode; %08x dsid\n",
                     ulErrorCode, ulErrorCode, dsid);
          SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ulErrorCode );  
    }
    
    return pTHS->errCode;
}


// used when testing CHK builds
BOOL fDeleteExpiredEntryTTLIsDisabled;
#if DBG
ULONG
DynamicObjectControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        )
{
    THSTATE *pTHS = pTHStls;
    BOOL    Granted;
    ULONG   ulNextSecs = 0;

    // Garbage collect expired dynamic objects (entryTTL == 0)

    // Check permissions
    Granted =
        CheckControlAccessOnObject(pTHS,
                                   gAnchor.pDSADN,
                                   RIGHT_DS_DO_GARBAGE_COLLECTION);
    if (!Granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    // Disable garbage collection task
    if (   pOpArg
        && pOpArg->cbBuf == 1
        && pOpArg->pBuf
        && pOpArg->pBuf[0] == '0') {
        // disable scheduled task and run delete expired objects from here
        fDeleteExpiredEntryTTLIsDisabled = TRUE;
        DeleteExpiredEntryTTL(&ulNextSecs);
    } else {
        // enable the scheduled task and reschedule it to run immediately
        fDeleteExpiredEntryTTLIsDisabled = FALSE;
        // remove any pending calls so that we don't end up with multiple
        // recurring entries in the task queue (since each instance of
        // DeleteExpiredEntryTTLMain will reschedule itself regardless
        // of whether other such entries are already scheduled).
        CancelTask(TQ_DeleteExpiredEntryTTLMain, NULL);
        // and reschedule at right now
        InsertInTaskQueue(TQ_DeleteExpiredEntryTTLMain, NULL, 0);
    }

    return 0;
}
#endif DBG

VOID
LinkCleanupControl(
    OPRES *pOpRes
    )
/*++
Routine Description:

    This routine is called because our client made a request through
    LDAP explicitly.

    This code is used by dc-demote to verify that all cleaning has been
    accomplished.

Parameters:

    Input arguments not used at present

    pOpRes - OUT, extended result

Return Values:

    Set pTHS->errCode and pTHS->ErrInfo

--*/
{
    THSTATE     *pTHS = pTHStls;
    DWORD       DirErr = 0, ret;
    BOOL granted, fMoreData = TRUE;
    DWORD dwNextTime;

    pOpRes->ulExtendedRet = ERROR_SUCCESS;

    granted =
        CheckControlAccessOnObject(pTHS,
                                   gAnchor.pDSADN,
                                   RIGHT_DS_DO_GARBAGE_COLLECTION);

    if (!granted) {
        Assert(pTHS->errCode);
        return;
    }

    THClearErrors();

    Assert(NULL == pTHS->pDB);

//    fMoreData = LinkCleanup( pTHS );
    ret = TriggerTaskSynchronously( TQ_LinkCleanup, &fMoreData );
    if (ret) {
        DPRINT1( 0, "Failed to trigger link cleanup task, error = %d\n", ret );
        LogUnhandledError(ret);
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ret );
    }

    Assert(NULL == pTHS->pDB);

    // Indicate whether there is more work to be done.

    if (!fMoreData) {
        pOpRes->ulExtendedRet = ERROR_NO_MORE_ITEMS;
    }

} /* LinkCleanupControl */


// global flag controlling how SDs are stored (defined in dbsyntax.c)
extern BOOL gStoreSDsInMainTable;

#define STRING_LITERAL_LEN(str) sizeof(str)-1

CHAR strForceUpdate[] = "forceupdate";
ULONG cbStrForceUpdate = STRING_LITERAL_LEN(strForceUpdate);

CHAR strDowngradeSDs[] = "downgrade";
ULONG cbStrDowngradeSDs = STRING_LITERAL_LEN(strDowngradeSDs);

CHAR strDNT[] = "dnt:";
ULONG cbStrDNT = STRING_LITERAL_LEN(strDNT);

#ifdef DBG
// global flag to turn on SD hash collision modeling
extern BOOL gfModelSDCollisions;

CHAR strModelSDCollisionsOn[] = "modelsdcollisionson";
ULONG cbStrModelSDCollisionsOn = STRING_LITERAL_LEN(strModelSDCollisionsOn);

CHAR strModelSDCollisionsOff[] = "modelsdcollisionsoff";
ULONG cbStrModelSDCollisionsOff = STRING_LITERAL_LEN(strModelSDCollisionsOff);
#endif

ULONG
FixupSecurityInheritance (
        OPARG *pOpArg,
        OPRES *pOpRes
        )
{
    BOOL granted;
    THSTATE *pTHS = pTHStls;
    DWORD dwFlags = 0;
    ULONG err;
    DWORD rootDNT = ROOTTAG;

    granted =
        CheckControlAccessOnObject(pTHS,
                                   gAnchor.pDSADN,
                                   RIGHT_DS_RECALCULATE_SECURITY_INHERITANCE);

    if (!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    if (pOpArg) {
        if (pOpArg[0].cbBuf == cbStrForceUpdate && _memicmp(pOpArg[0].pBuf, strForceUpdate, cbStrForceUpdate) == 0) {
            gStoreSDsInMainTable = FALSE;
            dwFlags = SD_PROP_FLAG_FORCEUPDATE;
            DPRINT(0, "SD single instancing is ON. Scheduling full SD propagation\n");
        }
        else if (pOpArg[0].cbBuf == cbStrDowngradeSDs && _memicmp(pOpArg[0].pBuf, strDowngradeSDs, cbStrDowngradeSDs) == 0) {
            gStoreSDsInMainTable = TRUE;
            dwFlags = SD_PROP_FLAG_FORCEUPDATE;
            DPRINT(0, "SD single instancing is OFF. Scheduling full SD propagation\n");
        }
#ifdef DBG
        else if (pOpArg[0].cbBuf == cbStrModelSDCollisionsOn && _memicmp(pOpArg[0].pBuf, strModelSDCollisionsOn, cbStrModelSDCollisionsOn) == 0) {
            gfModelSDCollisions = TRUE;
            DPRINT(0, "SD collision modeling is ON\n");
            return 0;
        }
        else if (pOpArg[0].cbBuf == cbStrModelSDCollisionsOff && _memicmp(pOpArg[0].pBuf, strModelSDCollisionsOff, cbStrModelSDCollisionsOff) == 0) {
            gfModelSDCollisions = FALSE;
            DPRINT(0, "SD collision modeling is OFF\n");
            return 0;
        }
#endif
        else if (pOpArg[0].cbBuf > cbStrDNT && _memicmp(pOpArg[0].pBuf, strDNT, cbStrDNT) == 0) {
            // try to convert the argument to a DNT
            rootDNT = atol(pOpArg[0].pBuf+cbStrDNT);
            if (rootDNT == 0) {
                // no luck converting
                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    Assert(NULL == pTHS->pDB);
    err = SDPEnqueueTreeFixUp(pTHS, rootDNT, dwFlags);
    Assert(NULL == pTHS->pDB);

    return err;
}

ULONG
SchemaCacheUpdate(
    OPRES *pOpRes
    )
{
    BOOL granted;
    DWORD err;
    THSTATE *pTHS = pTHStls;

    granted = CheckControlAccessOnObject(pTHS,
                                         gAnchor.pDSADN,
                                         RIGHT_DS_UPDATE_SCHEMA_CACHE);
    if (!granted) {
        granted = CheckControlAccessOnObject(pTHS,
                                             gAnchor.pDMD,
                                             RIGHT_DS_UPDATE_SCHEMA_CACHE);
    }

    if(!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    err = SCUpdateSchemaBlocking();
    if (err) {
      SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_SCHEMA_NOT_LOADED, err);
    }

    return pTHS->errCode;
}

ULONG
RemoveSingleLingeringObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    )
{
    THSTATE *pTHS = pTHStls;
    LPSTR pszInput = NULL;
    LPSTR pszSource = NULL;
    LPWSTR pszSourceW = NULL;
    LPSTR pszDN = NULL;
    LPWSTR pszDNW = NULL;
    DSNAME * pSource = NULL;
    DSNAME * pDN = NULL;
    DSNAME * pNC = NULL;
    DBPOS * pDB = NULL;
    DWORD err = 0;

    // The argument isn't neccessarily null terminated.  Copy it off and make it so.

    pszInput = THAllocEx(pTHS, pOpArg->cbBuf + 1);
    memcpy(pszInput, pOpArg->pBuf, pOpArg->cbBuf);
    pszInput[pOpArg->cbBuf]='\0';

    // parse input in the form DN_OF_THE_SOURCE_NTDS_SETTINGS_OBJECT:DN_OF_THE_OBJECT_TO_REMOVE
    pszSource = ParseInput(pszInput, ':', 0);
    pszDN     = ParseInput(pszInput, ':', 1);

    if (pszInput) {
	THFreeEx(pTHS, pszInput);
    }

    BeginDraTransaction(SYNC_WRITE);
    pDB = pTHS->pDB;
    __try {

	if (!pszSource || !pszDN) {
	    // bad input - we can't find null objects
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, 0);
	    __leave;
	}

	// convert input to wide characters
	pszSourceW = UnicodeStringFromString8(CP_UTF8, pszSource, strlen(pszSource) + 1);
	if (!pszSourceW) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, GetLastError());
	    __leave;
	}
	
	pszDNW = UnicodeStringFromString8(CP_UTF8, pszDN, strlen(pszDN) + 1);
	if (!pszDNW) { 
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, GetLastError());
	    __leave;
	}

	// lookup source
	err = UserFriendlyNameToDSName(pszSourceW, wcslen(pszSourceW), &pSource);
	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
	    __leave;
	}

	err = DBFindDSName(pDB,  pSource); 
	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err);
	    __leave;
	}

	err = DBFillDSName(pDB, &pSource, TRUE);
	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
	    __leave;
	}

	// lookup object
	err = UserFriendlyNameToDSName(pszDNW, wcslen(pszDNW), &pDN);
	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
	    __leave;
	}

	err = DBFindDSName(pDB,  pDN); 
	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
	    __leave;
	}

	err = DBFillDSName(pDB, &pDN, TRUE);
	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
	    __leave;
	}

	// old school function, requires pTHS->pDB to be open and current.
	if (!IsObjVisibleBySecurity(pTHS, TRUE)) {
	    SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND); 
	    __leave;
	}

	// first locate which NC they want to delete this object out of...
	pNC = FindNCParentDSName(pDN, FALSE, FALSE);	
	if (!pNC) {
	    // whoa, we don't have the NC that this object is on at all - deny the request 
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, ERROR_INVALID_PARAMETER); 
	    __leave;
	}

	err = FindNC(pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, NULL);

	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_EXPECTED_NC, ERROR_INVALID_PARAMETER);   
	    __leave;
	}

	// security check
    if (!CheckControlAccessOnObject(pTHS, pNC, RIGHT_DS_REPL_SYNC)) {
        Assert(pTHS->errCode);
        __leave;
    }

	err = DraRemoveSingleLingeringObject(pTHS, pDB, pSource, pDN);
	if (err) {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, err); 
	}
	
    }
    __finally {

	if (pszSource) {
	    THFreeEx(pTHS, pszSource);
	}
	if (pszSourceW) {
	    THFreeEx(pTHS, pszSourceW);
	}
	if (pszDN) {
	    THFreeEx(pTHS, pszDN);
	}
	if (pszDNW) {
	    THFreeEx(pTHS, pszDNW);
	}
	if (pDN) {
	    THFreeEx(pTHS, pDN);
	}
	if (pSource) {
	    THFreeEx(pTHS, pSource);
	}

	EndDraTransaction(TRUE);
    }

    return pTHS->errCode;
}

ULONG
ReplicateSingleObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    )
{
    // we don't pass this in because all the other similar calls also don't pass this in.
    // I'm not sure that's a good reason, but...
    THSTATE *pTHS = pTHStls;
    
    LPSTR pszSource = NULL;
    LPSTR pszDN = NULL;
    LPSTR pszInput = NULL;
    DWORD err = 0;
    ULONG ulLength = 0;
    DSNAME * pSource = NULL;
    DSNAME * pDN = NULL;
    DBPOS * pDB = NULL;
    LPWSTR pszSourceW = NULL;
    LPWSTR pszDNW = NULL;
    DSNAME * pNC = NULL;

    pOpRes->ulExtendedRet = EXOP_ERR_EXCEPTION;

    // The argument isn't neccessarily null terminated.  Copy it off and make it so.
    __try {
        
        pszInput = THAllocEx(pTHS, pOpArg->cbBuf + 1);
        memcpy(pszInput, pOpArg->pBuf, pOpArg->cbBuf);
        pszInput[pOpArg->cbBuf]='\0';
        
        // parse input in the form DN_OF_THE_SOURCE_NTDS_SETTINGS_OBJECT:DN_OF_THE_OBJECT_TO_REPL
        pszSource = ParseInput(pszInput, ':', 0);
        pszDN     = ParseInput(pszInput, ':', 1);
        
        // prepare input to internal call DraReplicateSingleObject
        DBOpen2(TRUE, &pDB);
        __try {
            
            if (!pszSource || !pszDN) {
                // bad input - we can't find null objects
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, 0);
                pOpRes->ulExtendedRet = EXOP_ERR_PARAM_ERR;
                err = ERROR_OBJECT_NOT_FOUND;
                __leave;
            }
            
            // convert input to wide characters
            pszSourceW = UnicodeStringFromString8(CP_UTF8, pszSource, strlen(pszSource) + 1);
            if (!pszSourceW) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, GetLastError());
                pOpRes->ulExtendedRet = EXOP_ERR_EXCEPTION;
                err = ERROR_OUTOFMEMORY;
                __leave;
            }
            
            pszDNW = UnicodeStringFromString8(CP_UTF8, pszDN, strlen(pszDN) + 1);
            if (!pszDNW) { 
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, GetLastError());
                pOpRes->ulExtendedRet = EXOP_ERR_EXCEPTION;
                err = ERROR_OUTOFMEMORY;
                __leave;
            }
            
            // lookup source
            err = UserFriendlyNameToDSName(pszSourceW, wcslen(pszSourceW), &pSource);
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
                pOpRes->ulExtendedRet = EXOP_ERR_PARAM_ERR;
                __leave;
            }
            
            err = DBFindDSName(pDB,  pSource); 
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
                pOpRes->ulExtendedRet = EXOP_ERR_PARAM_ERR;
                __leave;
            }
            
            err = DBFillGuidAndSid(pDB, pSource);
            
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
                pOpRes->ulExtendedRet = EXOP_ERR_PARAM_ERR;
                __leave;
            }
            
            // now create a DSNAME for the object, but don't worry about looking up
            // since it might not exist here.  
            
            err = UserFriendlyNameToDSName(pszDNW, wcslen(pszDNW), &pDN);
            if (err || (pDN==NULL)) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err); 
                pOpRes->ulExtendedRet = EXOP_ERR_PARAM_ERR;
                err = err ? err : ERROR_OBJECT_NOT_FOUND;
                __leave;
            }
            
            // locate which NC they want to repl this object out of...
            pNC = FindNCParentDSName(pDN, FALSE, FALSE);	
            if (!pNC) {
                // whoa, we don't have the NC that this object is on at all - deny the request 
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, ERROR_INVALID_PARAMETER); 
                pOpRes->ulExtendedRet = EXOP_ERR_PARAM_ERR;
                err = ERROR_OBJECT_NOT_FOUND;
                __leave;
            }
            
            err = FindNC(pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, NULL);
            
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_EXPECTED_NC, ERROR_INVALID_PARAMETER);  
                pOpRes->ulExtendedRet = EXOP_ERR_PARAM_ERR;
                __leave;
            }
            
            // security check
            if (!CheckControlAccessOnObject(pTHS, pNC, RIGHT_DS_REPL_SYNC)) {
                Assert(pTHS->errCode);
                err = ERROR_DS_DRA_ACCESS_DENIED;
                __leave;
            }
            
        }
        __finally {
            DBClose(pDB, TRUE); 
        }
        
        // if the input was parsed and prepared succesfully, and everything checks out 
        // (including the caller's right to call this function), then err==ERROR_SUCCESS.  Otherwise
        // don't make the call and return a failure.
        if (err==ERROR_SUCCESS) {
            err = DraReplicateSingleObject(pTHS, pSource, pDN, pNC, &(pOpRes->ulExtendedRet));
            
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, err);
            } else if (pOpRes->ulExtendedRet!=EXOP_ERR_SUCCESS) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_GENERIC_ERROR, 0);
            }
        }
    }
    __finally {
        if (pszInput) {
            THFreeEx(pTHS, pszInput);
        }
        if (pszSource) {
            THFreeEx(pTHS, pszSource);
        }
        if (pszDN) {
            THFreeEx(pTHS, pszDN);
        }
        if (pszSourceW) {
            THFreeEx(pTHS, pszSourceW);
        }
        if (pszDNW) {
            THFreeEx(pTHS, pszDNW);
        }
        if (pSource) {
            THFreeEx(pTHS, pSource);
        }
        if (pDN) {
            THFreeEx(pTHS, pDN);
        }
    }
    
    return pTHS->errCode;
}

ULONG
BecomeRidMaster(
    OPRES *pOpRes
    )
{
    THSTATE *pTHS = pTHStls;
    ULONG err = 0;
    DSNAME *pRidManager = NULL;
    DSNAME *pRoleOwner = NULL;
    ULONG Length = 0;
    CLASSCACHE *pCC = NULL;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    DWORD len;
    BOOL      fSDIsGlobalSDRef;
    ATTCACHE* pAC;

    SYNC_TRANS_READ();


    __try
    {
        // KdPrint(("DSA: FSMO Domain = %ws\n", gAnchor.pDomainDN->StringName));

        err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN);

        if (err)
        {
            LogUnhandledError(err);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err);
            __leave;
        }

        // grab the security descriptor
        if (err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pTHS->pDB->DNT,
                    &len,
                    &pNTSD,
                    &pCC,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
        }
        Assert(len > 0 || !DBCheckObj(pTHS->pDB));
        // can we read RID_MANAGER_REFERENCE?
        pAC = SCGetAttById(pTHS, ATT_RID_MANAGER_REFERENCE);
        Assert(pAC);
        if (!IsAccessGrantedAttribute(pTHS, pNTSD, gAnchor.pDomainDN, 1, pCC, &pAC, RIGHT_DS_READ_PROPERTY, TRUE)) {
            Assert(pTHS->errCode);
            __leave;
        }
        if (pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
        pNTSD = NULL;

        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_RID_MANAGER_REFERENCE,
                          0,
                          0,
                          &Length,
                          (UCHAR **)&pRidManager);


        // KdPrint(("DSA: FSMO RID Mgr = %ws\n", pRidManager->StringName));

        if (err)
        {
            SetSvcErrorEx(SV_PROBLEM_UNAVAIL_EXTENSION,
                          DIRERR_INVALID_RID_MGR_REF, err);
            __leave;
        }

        err = DBFindDSName(pTHS->pDB, pRidManager);

        if (err)
            {
                LogUnhandledError(err);
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_OBJ_NOT_FOUND, err);
                __leave;
            }

        // Do a security check.  Check for the control acces
        // RIGHT_DS_CHANGE_RID_MASTER on the RID_MANAGER object.


        // Get the Security Descriptor and the class
        if (err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pTHS->pDB->DNT,
                    &len,
                    &pNTSD,
                    &pCC,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
        }
        // Every object should have an SD.
        Assert(len > 0 || !DBCheckObj(pTHS->pDB));
        
        if (!IsControlAccessGranted(pNTSD,
                                    pRidManager,
                                    pCC,
                                    RIGHT_DS_CHANGE_RID_MASTER,
                                    TRUE)) { // fSetError
            Assert(pTHS->errCode);
            __leave;
        }

        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_FSMO_ROLE_OWNER,
                          0,
                          0,
                          &Length,
                          (UCHAR **)&pRoleOwner);

        if (err)
        {
            SetSvcErrorEx(SV_PROBLEM_UNAVAIL_EXTENSION,
                          DIRERR_INVALID_ROLE_OWNER, err);
            __leave;
        }

        if (NameMatched(pRoleOwner, gAnchor.pDSADN)
            && IsFSMOSelfOwnershipValid( pRidManager )) {
            // This DSA is already the role owner, so close the DB handle
            // and return.

            pOpRes->ulExtendedRet = EXOP_ERR_SUCCESS;

            __leave;
        }

        err = ReqFSMOOp(pTHS,
                        pRidManager,
                        DRS_WRIT_REP,
                        EXOP_FSMO_RID_REQ_ROLE,
                        0,
                        &pOpRes->ulExtendedRet);


        if (err) {
            SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                          DIRERR_COULDNT_CONTACT_FSMO, err);
            __leave;
        }

        // If the extended error code in the OpRes is not EXOP_ERROR_SUCCESS,
        // and the thread state error code is not set (possible, since the
        // thread state error code is set at this point based on the success
        // of the underlying ReqFSMOOp call, which just guarantees the success
        // of the underlying replication calls, and not if any non-replication
        // related fsmo error occured (for ex., if the other side is no longer
        // the current fsmo-role owner; the call will still succeed with no
        // errors, but the extended error code will contain the error
        // EXOP_ERR_FSMO_NOT_OWNER), we should not be proclaimg success.

        if ( (pOpRes->ulExtendedRet != EXOP_ERR_SUCCESS) && !pTHS->errCode ) {
            DPRINT1(3,"Rid Fsmo Transfer failed %d\n",
                    pOpRes->ulExtendedRet);
            SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                          DIRERR_COULDNT_CONTACT_FSMO, pOpRes->ulExtendedRet);
        }

    }
    __finally
    {
        // We may or may not have a transaction here, as ReqFSMOOp closes
        // its transaction in a success path.  If an error has occurred,
        // though, it's anyone's guess.
        //
        // Also, the transaction may be open if the current role owner
        // called this by mistake. The call to NameMatched finds this,
        // and leaves without closing the transaction

        if (pTHS->pDB)
        {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        // If NT-Mixed-Domain is set to zero at any time, this will trigger
        // the creation and initialization of the RID Manager (to address
        // the longer-term issue of reducing the number of reboots). Because
        // this occurs in the context of a SAM loopback call, so that every-
        // thing happens in one transaction, the thread-state and DBPOS will
        // have been setup by SAM transactioning. So, if the SAM write lock
        // is held, skip the sanity check.

        if (!pTHS->fSamWriteLockHeld)
        {
            Assert(NULL == pTHS->pDB);
        }

        if(pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
        if (pRidManager) {
            THFreeEx(pTHS, pRidManager);
        }
    }

    return pTHS->errCode;
}

ULONG
RequestRidAllocation(
    OPRES *pOpRes
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    THSTATE *pTHS = pTHStls;
    ULONG err;
    DSNAME *pRidManager = NULL;
    DSNAME *pRoleOwner = NULL;
    ULONG Length = 0;
    ULARGE_INTEGER FsmoInfo = {0, 0};
    PDSNAME pServer = NULL, pMachineAccount = NULL, pRidSetReference = NULL;
    BOOL fNoRidSetObject = FALSE;
    ULONG NextRid = 0;

    // This routine is for internal callers only, no security is checked.
    Assert(pTHS->fDSA);

    SYNC_TRANS_READ();

    __try
    {
        // Start the process of locating the current FSMO Role Owner by
        // retrieving the RID Manager Reference (the DSNAME of the RID
        // Manager) from the domain object. Once the RID Manager has been
        // located, read its Role Owner attribute (the DSNAME of a DSA)
        // and compare it to the name of this DSA (gAnchor.pDSADN). If
        // they are the same, just perform the RID allocation directly
        // on this DSA, otherwise call ReqFSMOOp in order to contact the
        // current Role Owner DSA with the request for more RIDs.

        err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN);
        if ( 0 == err )
        {
            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_RID_MANAGER_REFERENCE,
                              0,
                              0,
                              &Length,
                              (UCHAR **)&pRidManager);

        }

        if ( 0 != err )
        {
            LogUnhandledError( err );
            SetSvcErrorEx( SV_PROBLEM_DIR_ERROR,
                           DIRERR_INVALID_RID_MGR_REF,
                           err );
            __leave;
        }
        DPRINT1( 1, "DSA: FSMO RID Mgr = %ws\n", pRidManager->StringName);

        err = DBFindDSName(pTHS->pDB, pRidManager);
        if ( 0 == err )
        {
            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_FSMO_ROLE_OWNER,
                              0,
                              0,
                              &Length,
                              (UCHAR **)&pRoleOwner);
        }

        if ( 0 != err )
        {
            SetSvcErrorEx( SV_PROBLEM_UNAVAIL_EXTENSION,
                           DIRERR_INVALID_ROLE_OWNER,
                           err );
            __leave;
        }
        DPRINT1( 1, "DSA: FSMO Role Owner = %ws\n", pRoleOwner->StringName);
        DPRINT1( 1, "DSA: FSMO DSA DN = %ws\n", gAnchor.pDSADN->StringName);

        // Obtain the current allocated pool attribute, if possible
        pServer = THAllocEx( pTHS, gAnchor.pDSADN->structLen);
        TrimDSNameBy(gAnchor.pDSADN, 1, pServer);

        err = DBFindDSName(pTHS->pDB, pServer);
        if ( 0 == err ) {
            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_SERVER_REFERENCE,
                              0,
                              0,
                              &Length,
                              (UCHAR **)&pMachineAccount);
        }


        // We should have a server reference
        if ( err ) {
            LogUnhandledError( err );
            SetSvcError( SV_PROBLEM_DIR_ERROR, err );
            __leave;
        }

        //
        // We may not have a rid set reference
        //
        err = DBFindDSName(pTHS->pDB, pMachineAccount);
        if ( 0 == err ) {
            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_RID_SET_REFERENCES,
                              0,
                              0,
                              &Length,
                              (UCHAR **)&pRidSetReference);

            if ( DB_ERR_NO_VALUE == err ) {
                //
                // This is ok
                //
                err = 0;
                fNoRidSetObject = TRUE;

            }
        }

        if ( err ) {

            //
            // We should have a machine account and/or the read of
            // the rid set reference should have been a success.
            //
            LogUnhandledError( err );
            SetSvcErrorEx( SV_PROBLEM_DIR_ERROR,
                           ERROR_NO_TRUST_SAM_ACCOUNT,
                           err );
            __leave;
        }

        if ( !fNoRidSetObject ) {

            BOOL Deleted;

            err = DBFindDSName(pTHS->pDB, pRidSetReference);

            if (err != DIRERR_NOT_AN_OBJECT) {
                if(!DBGetSingleValue(pTHS->pDB, ATT_IS_DELETED, &Deleted,
                                     sizeof(Deleted), NULL) &&
                   Deleted) {
                    err = DIRERR_NOT_AN_OBJECT;
                }
            }

            if ( 0 == err )
            {
                //
                // Get the next RID to see if we are in an invalidated
                // state. If the RID is zero that means that the pool
                // has been invalidated -- don't read the AllocationPool
                // since it is invalid, too.
                //
                err = DBGetSingleValue(pTHS->pDB,
                                       ATT_RID_NEXT_RID,
                                       (UCHAR **)&NextRid,
                                       sizeof(NextRid),
                                       NULL );
                if (  (0 == err)
                   &&  NextRid != 0 ) {

                    err = DBGetSingleValue(pTHS->pDB,
                                           ATT_RID_ALLOCATION_POOL,
                                           (UCHAR **)&FsmoInfo,
                                           sizeof(FsmoInfo),
                                           NULL );
                }

                if ( DB_ERR_NO_VALUE == err ) {
                    //
                    // This attribute has been removed.
                    // We need another rid pool.
                    //
                    err = 0;
                }

            } else if ( (DIRERR_OBJ_NOT_FOUND == err)
                    ||  (DIRERR_NOT_AN_OBJECT == err) ) {

                //
                // The rid set reference is not pointing to a readable
                // value; request a new rid pool.
                //
                err = 0;

            }

            if ( err ) {

                //
                // This is an unexpected error
                //
                LogUnhandledError( err );
                SetSvcError( SV_PROBLEM_DIR_ERROR, err );
                __leave;
            }

        }

        if ( NameMatched(pRoleOwner, gAnchor.pDSADN)
         &&  IsFSMOSelfOwnershipValid( pRidManager ) )
        {
            // This DSA is already the role owner.

            //
            // End the transaction
            //
            _CLEAN_BEFORE_RETURN(pTHS->errCode, FALSE);

            pOpRes->ulExtendedRet = EXOP_ERR_SUCCESS;

            NtStatus = SamIFloatingSingleMasterOpEx(pRidManager,
                                                    pRoleOwner,
                                                    SAMP_REQUEST_RID_POOL,
                                                    &FsmoInfo, // ignored since calling on self
                                                    NULL );


            if ( !NT_SUCCESS(NtStatus) )
            {

                DPRINT1( 0, "DSA: SamIFloatingSingleMasterOp status = 0x%lx\n",
                         NtStatus );

                SetSvcErrorEx( SV_PROBLEM_UNAVAIL_EXTENSION,
                               DIRERR_INVALID_ROLE_OWNER,
                               err );
            }

            //
            // We shouldn't have a transaction open
            //
            Assert( !pTHS->pDB );

        }
        else
        {
            err = ReqFSMOOp(pTHS,
                            pRidManager,
                            DRS_WRIT_REP,
                            EXOP_FSMO_REQ_RID_ALLOC,
                            &FsmoInfo,
                            &pOpRes->ulExtendedRet);

            if (err)
            {
                SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                              DIRERR_COULDNT_CONTACT_FSMO, err);
                __leave;
            }

            // If the extended error code in the OpRes is not EXOP_ERROR_SUCCESS,
            // and the thread state error code is not set (possible, since the
            // thread state error code is set at this point based on the success
            // of the underlying ReqFSMOOp call, which just guarantees the success
            // of the underlying replication calls, and not if any non-replication
            // related fsmo error occured (for ex., if the other side is no longer
            // the current fsmo-role owner; the call will still succeed with no
            // errors, but the extended error code will contain the error
            // EXOP_ERR_FSMO_NOT_OWNER), we should not be proclaimg success, since
            // this DC may then go on to make schema changes and fail.

            if ( (pOpRes->ulExtendedRet != EXOP_ERR_SUCCESS) && !pTHS->errCode ) {
                DPRINT1(3,"Schema Fsmo Transfer failed %d\n", pOpRes->ulExtendedRet);
                SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE,
                              DIRERR_COULDNT_CONTACT_FSMO, pOpRes->ulExtendedRet);
            }


        }
    }
    __finally
    {

        //
        // Commit any and all changes
        //
        if ( pTHS->pDB )
        {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        if (pRidSetReference) {
            THFreeEx(pTHS, pRidSetReference);
        }
        if (pMachineAccount) {
            THFreeEx(pTHS, pMachineAccount);
        }
        if (pServer) {
            THFreeEx(pTHS, pServer);
        }
    }

    return pTHS->errCode;
}

ULONG
BecomeDomainMaster(OPARG * pOpArg, OPRES *pOpRes)
{
    // We used to check that we were a GC here, but starting with
    // Whistler, we can put the Domain Naming Master on any DC.

    return GenericBecomeMaster(gAnchor.pPartitionsDN,
                               CLASS_CROSS_REF_CONTAINER,
                               RIGHT_DS_CHANGE_DOMAIN_MASTER,
                               pOpRes);
}

typedef enum _FtsPhase {
    eThisSite = 0,
    eRPC = 1,
    eMail = 2,
    eDone = 3
} FtsPhase;

typedef struct _FSMO_TARGET_SEARCH {
    // Surely there's something more?
    SEARCHARG      SearchArg;
    FtsPhase       SearchPhase;
} FSMO_TARGET_SEARCH;

static ATTRTYP NtdsDsaClass = CLASS_NTDS_DSA;

unsigned
AdjustFtsPhase(FSMO_TARGET_SEARCH *pFTSearch)
{
    if (pFTSearch->SearchPhase == eThisSite) {
        // Rebase search to cover all sites
        TrimDSNameBy(gAnchor.pDSADN,
                     4,
                     pFTSearch->SearchArg.pObject);
        // Discard any old restart
        pFTSearch->SearchArg.CommArg.PagedResult.fPresent = TRUE;
        pFTSearch->SearchArg.CommArg.PagedResult.pRestart = NULL;
        pFTSearch->SearchPhase = eRPC;
        return 0;
    }
    else {
        // out of search strategies
        pFTSearch->SearchPhase = eDone;
        return 1;
    }
}


ULONG
FsmoTargetSearch(THSTATE *pTHS,
                 DSNAME *  pdnThisNC,
                 FSMO_TARGET_SEARCH **ppFTSearch,
                 DSNAME  **ppTarget)
{
    SEARCHRES * pSearchRes;
    FSMO_TARGET_SEARCH *pFTSearch = *ppFTSearch;
    FILTER NewHasNcFilter;
    FILTER OldHasNcFilter;
    ULONG err;

    if (NULL == pFTSearch) {
        // We need to build our search arguments
        FILTER * pf;
        DSNAME * dsaLocal;
        Assert(NULL == *ppTarget);

        dsaLocal = THAllocEx(pTHS, gAnchor.pDSADN->structLen);
        memcpy(dsaLocal, gAnchor.pDSADN, gAnchor.pDSADN->structLen);

        *ppFTSearch = pFTSearch = THAllocEx(pTHS, sizeof(FSMO_TARGET_SEARCH));

        // Perform a subtree search, based at our site root, asking for
        // results to be paged back one at a time.
        InitCommarg(&(pFTSearch->SearchArg.CommArg));
        pFTSearch->SearchArg.pObject = THAllocEx(pTHS, gAnchor.pDSADN->structLen);
        pFTSearch->SearchPhase = 0;  // This site
        TrimDSNameBy(gAnchor.pDSADN,
                     2,
                     pFTSearch->SearchArg.pObject);
        pFTSearch->SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
        pFTSearch->SearchArg.bOneNC = TRUE;
        pFTSearch->SearchArg.searchAliases = FALSE;
        pFTSearch->SearchArg.CommArg.PagedResult.fPresent = TRUE;
        pFTSearch->SearchArg.CommArg.PagedResult.pRestart = NULL;
        pFTSearch->SearchArg.CommArg.ulSizeLimit = 1;

        // Ask for no attributes (i.e., DN only)
        pFTSearch->SearchArg.pSelectionRange = NULL;
        pFTSearch->SearchArg.pSelection = THAllocEx(pTHS, sizeof(ENTINFSEL));
        pFTSearch->SearchArg.pSelection->attSel = EN_ATTSET_LIST;
        pFTSearch->SearchArg.pSelection->infoTypes = EN_INFOTYPES_TYPES_VALS;
        pFTSearch->SearchArg.pSelection->AttrTypBlock.attrCount = 0;
        pFTSearch->SearchArg.pSelection->AttrTypBlock.pAttr = NULL;

        // Build a filter to find NTDS-DSA objects

        // initial choice object
        pFTSearch->SearchArg.pFilter = pf = THAllocEx(pTHS, sizeof(FILTER));
        pf->choice = FILTER_CHOICE_AND;
        pf->FilterTypes.And.pFirstFilter = THAllocEx(pTHS, sizeof(FILTER));

        // first predicate:  the right object class
        pf = pf->FilterTypes.And.pFirstFilter;
        pf->choice = FILTER_CHOICE_ITEM;
        pf->pNextFilter = NULL;
        pf->FilterTypes.Item.choice =  FI_CHOICE_EQUALITY;
        pf->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
        pf->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ATTRTYP);
        pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR*)&NtdsDsaClass;
        pFTSearch->SearchArg.pFilter->FilterTypes.And.count = 1;

        // second predicate:  ignore the local machine
        pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
        pf = pf->pNextFilter;
        pf->pNextFilter = NULL;
        pf->choice = FILTER_CHOICE_ITEM;
        pf->FilterTypes.Item.choice = FI_CHOICE_NOT_EQUAL;
        pf->FilterTypes.Item.FilTypes.ava.type = ATT_OBJ_DIST_NAME;
        pf->FilterTypes.Item.FilTypes.ava.Value.valLen =
          dsaLocal->structLen;
        pf->FilterTypes.Item.FilTypes.ava.Value.pVal =
          (UCHAR *)dsaLocal;
        pFTSearch->SearchArg.pFilter->FilterTypes.And.count = 2;

        // If we're only looking for candidates in our domain, add a clause
        // that will restrict us to finding only the right DSAs.
        if (pdnThisNC) {

            pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
            pf = pf->pNextFilter;

            FillHasMasterNCsFilters(pdnThisNC,
                                    pf,
                                    &NewHasNcFilter,
                                    &OldHasNcFilter);
            pf->pNextFilter = NULL;

            pFTSearch->SearchArg.pFilter->FilterTypes.And.count = 3;
        }

    }
    else if (pFTSearch->SearchPhase >= eDone) {
        return 1;
    }


    pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));
  SearchAgain:
    SearchBody(pTHS,
               &pFTSearch->SearchArg,
               pSearchRes,
               0);

    if (pSearchRes->count == 0) {
        // This search returned no objects, time to change strategies.
        if (AdjustFtsPhase(pFTSearch)) {
            // out of search strategies
            return 1;
        }
        else {
            // we're prepared for another try
            THClearErrors();
            goto SearchAgain;
        }
    }

    if (pSearchRes->PagedResult.fPresent) {
        // There's more after this, so save the restart
        Assert(pSearchRes->PagedResult.pRestart);
        pFTSearch->SearchArg.CommArg.PagedResult.pRestart =
          pSearchRes->PagedResult.pRestart;
    }
    else {
        // This strategy is exhausted, so prepare to try the next one
        AdjustFtsPhase(pFTSearch);
    }

    Assert(pSearchRes->count == 1);
    *ppTarget = pSearchRes->FirstEntInf.Entinf.pName;
    Assert(*ppTarget);
    if (pSearchRes->FirstEntInf.Entinf.AttrBlock.pAttr)
      THFreeEx(pTHS, pSearchRes->FirstEntInf.Entinf.AttrBlock.pAttr);
    THFreeEx(pTHS, pSearchRes);

    return 0;
}



/*++ GiveawayOneFsmoRole
 *
 * Description:
 *    This routine attempts to get rid of the FSMO role indicated by the
 *    object pFSMO by contacting another server and having that server
 *    call back to transfer the FSMO away in the normal FSMO transfer
 *    mechanism.  If the flag bThisDomain is true then the role can only
 *    be transferred to another DC in the same domain as this DC.  If false,
 *    the role can be transferred to any DC in the enterprise.  When trying
 *    to locate a server to which to give the role, we attempt to find
 *    server(s) in our site first, then any server(s) to which we have
 *    RPC connectivity, and lastly resort to servers that we can only
 *    reach asynchronously.  Note that if we resort to async communications
 *    then this routine will return failure, but will in fact eventually
 *    succeed, because we have an outstanding request to transfer the role
 *    that should eventually succeed.  This means that a later re-invocation
 *    of GiveawayAllFsmoRoles should succeed, because we will have transferred
 *    all roles away.
 *
 *    Note well the unusual transaction structure of this routine.  We enter
 *    with an open read transaction, and we leave with an open read
 *    transaction, but they're not the same one.  We can't hold transactions
 *    open for long periods of time (such as when we go off machine), so
 *    we must close our read transaction before making the FSMO request.  We
 *    re-open a new transaction to make it possible to repeatedly invoke this
 *    routine without a lot of repeated setup code.  Note that this DSA is
 *    the role holder in the inbound transaction, and is NOT the role holder
 *    in the outbound transaction (assuming success).
 *
 * Arguments:
 *    pTHS        - THSTATE pointer
 *    pFSMO       - name of object whose FSMO role this DSA holds
 *    bThisNC     - flag indicating that the role can only be transferred
 *                  to another DSA with the same NC.
 * Return Value:
 *    TRUE        - transfer has succeeded
 *    FALSE       - transfer either failed entirely or has not completed.
 */
BOOL
GiveawayOneFsmoRole(THSTATE *pTHS,
                    DSNAME  *pFSMO,
                    DSNAME  *pdnThisNC,
                    DSNAME   *pSuggestedTarget,
                    OPRES   *pOpRes)
{
    ULONG err;
    FSMO_TARGET_SEARCH *pFTSearch = NULL;
    DSNAME *pTarget = NULL;

    if ( pSuggestedTarget ) {

        err = ReqFsmoGiveaway(pTHS,
                              pFSMO,
                              pSuggestedTarget,
                              &pOpRes->ulExtendedRet);

        pTarget = pSuggestedTarget;

        SYNC_TRANS_READ();

    } else {

        while (0 == (err = FsmoTargetSearch(pTHS,
                                            pdnThisNC,
                                            &pFTSearch,
                                            &pTarget))) {
            err = ReqFsmoGiveaway(pTHS,
                                  pFSMO,
                                  pTarget,
                                  &pOpRes->ulExtendedRet);
            THFreeEx(pTHS, pTarget);
            SYNC_TRANS_READ();
            if (   !err
                && (EXOP_ERR_SUCCESS == pOpRes->ulExtendedRet )) {
                break;
            }
            pTarget = NULL;
        }

    }

    if ( !err && (EXOP_ERR_SUCCESS == pOpRes->ulExtendedRet) ) {

        return TRUE;

    }

    return FALSE;
}


/*++ GiveawayAllFsmoRoles
 *
 * Description:
 *    This routine determines what roles this server is holding and attempts
 *    to give all of them away to other servers.  Returns success if no roles
 *    are held at the end of the routine.  Note that we can go through
 *    multiple level-0 transactions during the proces of shedding the roles.
 *
 *    NOT ACCESS CONTROLLED - exposed as operational control through LDAP only
 *    in debug builds (but always exposed to internal clients).
 *
 * ARGUMENTS:
 *    pOpArg - pointer to operation argument
 *    pOpRes - pointer to operation result to be filled in
 */
ULONG
GiveawayAllFsmoRoles(OPARG *pOpArg, OPRES *pOpRes)
{
    THSTATE *pTHS = pTHStls;
    DSNAME *pTarget = NULL;
    ULONG OpFlags = 0;
    ATTCACHE *pACfsmo;
    ULONG cbDN = 0;
    ULONG cbRet;
    DSNAME *pDN = NULL, *pDNObj = NULL;
    ULONG err;
    BOOL bFailed = FALSE;
    LPWSTR pTargetDn = NULL;
    ULONG len, size;
    unsigned i;
    FSMO_GIVEAWAY_DATA *FsmoGiveawayData;
    DSNAME *pNC = NULL;

    // This function is not access controlled and is exposed to LDAP
    // clients in DBG builds only.
    if (!pTHS->fDSA && !pTHS->fDRA) {
        // check that the user has DEBUG privilege
        BOOL fPrivilegeHeld = FALSE;
        if ((err = CheckPrivilegeAnyClient(SE_DEBUG_PRIVILEGE, &fPrivilegeHeld)) != 0 || !fPrivilegeHeld) {
            SetSecErrorEx(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_PRIVILEGE_NOT_HELD, err);
            return ERROR_PRIVILEGE_NOT_HELD;
        }
    }

    // Pre versioned data
    if ( pOpArg->cbBuf < 4 )
    {
        // Parse command args to see which roles we need to dump.
        for (i=0; i<pOpArg->cbBuf; i++) {
            switch (pOpArg->pBuf[i]) {
              case 'd':
              case 'D':
                OpFlags |= FSMO_GIVEAWAY_DOMAIN;
                break;

              case 'e':
              case 'E':
                OpFlags |= FSMO_GIVEAWAY_ENTERPRISE;
                break;

              default:
                ;
            }
        }
    }
    else
    {
        // This is versioned data
        FsmoGiveawayData = (PFSMO_GIVEAWAY_DATA) pOpArg->pBuf;
        if ( !FsmoGiveawayData ) {
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        DIRERR_UNKNOWN_OPERATION);
            return pTHS->errCode;
        }

        switch (FsmoGiveawayData->Version) {
        case 1:
            // Win2k-compatible structure.
            if (pOpArg->cbBuf
                < offsetof(FSMO_GIVEAWAY_DATA, V1)
                  + offsetof(FSMO_GIVEAWAY_DATA_V1, StringName)) {
                // Buffer's not big enough to hold the structure.
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            DIRERR_UNKNOWN_OPERATION);
                return pTHS->errCode;
            }

            if (pOpArg->cbBuf
                < offsetof(FSMO_GIVEAWAY_DATA, V1)
                  + offsetof(FSMO_GIVEAWAY_DATA_V1, StringName)
                  + sizeof(WCHAR) * (1 + FsmoGiveawayData->V1.NameLen)) {
                // Buffer's not big enough to hold the structure + name string.
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            DIRERR_UNKNOWN_OPERATION);
                return pTHS->errCode;
            }

            if ((FsmoGiveawayData->V1.StringName[FsmoGiveawayData->V1.NameLen]
                 != L'\0')
                || (wcslen(FsmoGiveawayData->V1.StringName)
                    != FsmoGiveawayData->V1.NameLen)) {
                // Malformed DSA DN parameter.
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            DIRERR_UNKNOWN_OPERATION);
                return pTHS->errCode;
            }

            // Use the suggestion, if one was passed in
            if (FsmoGiveawayData->V1.NameLen > 0) {
                pTargetDn = &FsmoGiveawayData->V1.StringName[0];
            }

            // Extract the flags
            OpFlags = FsmoGiveawayData->V1.Flags;

            break;

        case 2:
            // >= Whistler structure that additionally supports specification
            // of an NC name.
            if (pOpArg->cbBuf
                < offsetof(FSMO_GIVEAWAY_DATA, V2)
                  + offsetof(FSMO_GIVEAWAY_DATA_V2, Strings)) {
                // Buffer's not big enough to hold the structure.
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            DIRERR_UNKNOWN_OPERATION);
                return pTHS->errCode;
            }

            if (pOpArg->cbBuf
                < offsetof(FSMO_GIVEAWAY_DATA, V2)
                  + offsetof(FSMO_GIVEAWAY_DATA_V2, Strings)
                  + sizeof(WCHAR) * (1 + FsmoGiveawayData->V2.NameLen)
                  + sizeof(WCHAR) * (1 + FsmoGiveawayData->V2.NCLen)) {
                // Buffer's not big enough to hold the structure + strings.
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            DIRERR_UNKNOWN_OPERATION);
                return pTHS->errCode;
            }

            if ((FsmoGiveawayData->V2.Strings[FsmoGiveawayData->V2.NameLen]
                 != L'\0')
                || (wcslen(FsmoGiveawayData->V2.Strings)
                    != FsmoGiveawayData->V2.NameLen)
                || (FsmoGiveawayData->V2.Strings[FsmoGiveawayData->V2.NameLen
                        + 1 + FsmoGiveawayData->V2.NCLen] != L'\0')
                || (wcslen(&FsmoGiveawayData->V2.Strings[
                                            FsmoGiveawayData->V2.NameLen + 1])
                    != FsmoGiveawayData->V2.NCLen)) {
                // Malformed DSA DN and/or NC parameter.
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            DIRERR_UNKNOWN_OPERATION);
                return pTHS->errCode;
            }

            // Use the DSA DN suggestion, if one was passed in.
            if (FsmoGiveawayData->V2.NameLen > 0) {
                pTargetDn = &FsmoGiveawayData->V2.Strings[0];
            }

            // Use the NC parameter, if one was passed in.
            if (FsmoGiveawayData->V2.NCLen > 0) {
                pNC = THAllocEx(pTHS,
                                DSNameSizeFromLen(FsmoGiveawayData->V2.NCLen));
                pNC->structLen = DSNameSizeFromLen(FsmoGiveawayData->V2.NCLen);
                pNC->NameLen = FsmoGiveawayData->V2.NCLen;
                wcscpy(pNC->StringName,
                       &FsmoGiveawayData->V2.Strings[
                                            FsmoGiveawayData->V2.NameLen + 1]);
            }

            // Extract the flags.
            OpFlags = FsmoGiveawayData->V2.Flags;

            break;

        default:
            // Unknown structure version.
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        DIRERR_UNKNOWN_OPERATION);
            return pTHS->errCode;
        }
    }

    // Validation of the parameters passed in
    if (OpFlags & FSMO_GIVEAWAY_NONDOMAIN) {
        // Not valid in conjunction with domain flag.
        if (OpFlags & FSMO_GIVEAWAY_DOMAIN) {
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, DIRERR_UNKNOWN_OPERATION);
            return pTHS->errCode;
        }

        // NC name must be given and must be that of a non-domain NC.
        if ((NULL == pNC) || !fIsNDNC(pNC)) {
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, DIRERR_UNKNOWN_OPERATION);
            return pTHS->errCode;
        }
    } else if (OpFlags & FSMO_GIVEAWAY_DOMAIN) {
        // Local domain is assumed.
        if (NULL != pNC) {
            if (!NameMatched(gAnchor.pDomainDN, pNC)) {
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            DIRERR_UNKNOWN_OPERATION);
                return pTHS->errCode;
            }

            THFreeEx(pTHS, pNC);
        }

        pNC = gAnchor.pDomainDN;
    } else if (!(OpFlags & FSMO_GIVEAWAY_ENTERPRISE)) {
        // Bad flags.
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, DIRERR_UNKNOWN_OPERATION);
        return pTHS->errCode;
    }

    if (OpFlags & (FSMO_GIVEAWAY_DOMAIN | FSMO_GIVEAWAY_ENTERPRISE)) {
        // set a global flag that will keep us from acquiring new roles
        gbFsmoGiveaway = TRUE;
    }

    pACfsmo = SCGetAttById(pTHS, ATT_FSMO_ROLE_OWNER);

    SYNC_TRANS_READ();
    try {

        if ( pTargetDn ) {

            // Make sure this is a real ntdsa object and in the case of domain
            // or NDNC FSMO transfer that the dsa hosts the NC.
            ATTCACHE *pACobjClass;
            ULONG     ulNewOrOldHasMasterNCs;
            ATTCACHE *pACmsDSHasMasterNcs;
            DWORD     objClass;

            pACobjClass = SCGetAttById(pTHS, ATT_OBJECT_CLASS);

            len = wcslen( pTargetDn );
            size = DSNameSizeFromLen( len );
            pTarget = THAllocEx( pTHS, size );
            pTarget->structLen = size;
            pTarget->NameLen = len;
            wcscpy( pTarget->StringName, pTargetDn );

            // Position on the object
            err = DBFindDSName(pTHS->pDB, pTarget);
            if (err) {
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            ERROR_DS_CANT_FIND_DSA_OBJ);
                leave;
            }

            // Get the object class
            err = DBGetSingleValue(pTHS->pDB, ATT_OBJECT_CLASS, &objClass,
                                   sizeof(objClass), NULL);
            if (err) {
                goto Failure;
            }

            // Make sure we are an ntdsa object
            if (objClass != CLASS_NTDS_DSA) {
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            ERROR_DS_CLASS_NOT_DSA);
                leave;
            }

            // FSMO operations later on will assume that the guid and sid
            // are filled in
            DBFillGuidAndSid( pTHS->pDB, pTarget );

            // Make sure the suggestion has a copy of the NC owning the FSMOs
            // we're giving away
            if (OpFlags & (FSMO_GIVEAWAY_DOMAIN | FSMO_GIVEAWAY_NONDOMAIN)) {

                BOOL fValid = FALSE;
                int count = 1;
                
                pACmsDSHasMasterNcs = SCGetAttById(pTHS, GetRightHasMasterNCsAttr(pTHS->pDB));
                Assert(pACmsDSHasMasterNcs);

                do {
                    err = DBGetAttVal_AC(pTHS->pDB,
                                         count,
                                         pACmsDSHasMasterNcs,
                                         DBGETATTVAL_fREALLOC,
                                         cbDN,
                                         &cbRet,
                                         (UCHAR**)&pDN);

                    if (0 == err) {
                        cbDN = max(cbDN, cbRet);

                        if (NameMatched(pDN, pNC)) {
                            fValid = TRUE;
                            break;
                        }
                    }

                    count++;
                } while (0 == err);


                // Nice try
                if (!fValid) {
                    SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                                ERROR_DS_CANT_FIND_EXPECTED_NC);
                    leave;
                }
            }
        }

        //
        // Ok - we are ready to give the FSMO's away
        //

        if (OpFlags & FSMO_GIVEAWAY_DOMAIN) {

            // ridmgr, infrastructure,  and PDC
            err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN);
            if (err) {
                goto Failure;
            }
            err = DBGetAttVal_AC(pTHS->pDB,
                                 1,
                                 pACfsmo,
                                 DBGETATTVAL_fREALLOC,
                                 cbDN,
                                 &cbRet,
                                 (UCHAR**)&pDN);
            if (err) {
                goto Failure;
            }
            cbDN = max(cbDN, cbRet);
            if(NameMatched(pDN, gAnchor.pDSADN)) {
                // We're holding the rid manager role
                if (!GiveawayOneFsmoRole(pTHS,
                                         gAnchor.pDomainDN,
                                         gAnchor.pDomainDN,
                                         pTarget,
                                         pOpRes)) {
                    bFailed = TRUE;
                }
            }

            if(gAnchor.pInfraStructureDN) {
                // stale phantom master
                err = DBFindDSName(pTHS->pDB, gAnchor.pInfraStructureDN);
                if (err) {
                    goto Failure;
                }
                err = DBGetAttVal_AC(pTHS->pDB,
                                     1,
                                     pACfsmo,
                                     DBGETATTVAL_fREALLOC,
                                     cbDN,
                                     &cbRet,
                                     (UCHAR**)&pDN);
                if (err) {
                    goto Failure;
                }
                cbDN = max(cbDN, cbRet);
                if(NameMatched(pDN, gAnchor.pDSADN)) {
                    // We're holding the infrastructure manager role
                    if (!GiveawayOneFsmoRole(pTHS,
                                             gAnchor.pInfraStructureDN,
                                             gAnchor.pDomainDN,
                                             pTarget,
                                             pOpRes)) {
                        bFailed = TRUE;
                    }
                }
            }

            // Reposition on the domain object to find the rid object...
            err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN);
            if (err) {
                goto Failure;
            }

            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_RID_MANAGER_REFERENCE,
                              0,
                              0,
                              &cbRet,
                              (UCHAR**)&pDNObj);
            if (err) {
                goto Failure;
            }
            err = DBFindDSName(pTHS->pDB, pDNObj);
            if (err) {
                goto Failure;
            }
            err = DBGetAttVal_AC(pTHS->pDB,
                                 1,
                                 pACfsmo,
                                 DBGETATTVAL_fREALLOC,
                                 cbDN,
                                 &cbRet,
                                 (UCHAR**)&pDN);
            if (err) {
                goto Failure;
            }
            cbDN = max(cbDN, cbRet);
            if (NameMatched(pDN, gAnchor.pDSADN)) {
                // we're holding the PDC role
                if (!GiveawayOneFsmoRole(pTHS,
                                         pDNObj,
                                         gAnchor.pDomainDN,
                                         pTarget,
                                         pOpRes)) {
                    bFailed = TRUE;
                }
            }
            THFreeEx(pTHS, pDNObj);
        }

        if (OpFlags & FSMO_GIVEAWAY_NONDOMAIN) {

            // infrastructure only
            SYNTAX_INTEGER it;
            ULONG dntInfraObj;
            DSNAME *pInfraObjDN;

            // Seek to/verify NC object.
            if (DBFindDSName(pTHS->pDB, pNC)
                || DBGetSingleValue(pTHS->pDB, ATT_INSTANCE_TYPE, &it,
                                    sizeof(it), NULL)
                || !FPrefixIt(it)
                || (it & IT_NC_GOING)) {
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            ERROR_DS_NCNAME_MUST_BE_NC);
                __leave;
            }

            // Find infrastructure object (acceptable if none).
            if (GetWellKnownDNT(pTHS->pDB,
                                (GUID *)GUID_INFRASTRUCTURE_CONTAINER_BYTE,
                                &dntInfraObj)
                && (dntInfraObj != INVALIDDNT)) {

                if (DBFindDNT(pTHS->pDB, dntInfraObj)
                    || DBGetAttVal_AC(pTHS->pDB,
                                      1,
                                      pACfsmo,
                                      DBGETATTVAL_fREALLOC,
                                      cbDN,
                                      &cbRet,
                                      (UCHAR**)&pDN)) {
                    goto Failure;
                }

                cbDN = max(cbDN, cbRet);

                if (NameMatched(pDN, gAnchor.pDSADN)) {
                    // We're holding the infrastructure manager role.
                    pInfraObjDN = GetExtDSName(pTHS->pDB);

                    if (NULL == pInfraObjDN) {
                        goto Failure;
                    } else {
                        if (!GiveawayOneFsmoRole(pTHS,
                                                 pInfraObjDN,
                                                 pNC,
                                                 pTarget,
                                                 pOpRes)) {
                            bFailed = TRUE;
                        }

                        THFreeEx(pTHS, pInfraObjDN);
                    }
                }
            } else {
                DPRINT1(0, "No infrastructure container for NDNC %ls.\n",
                        pNC->StringName);
            }
        }

        if (OpFlags & FSMO_GIVEAWAY_ENTERPRISE) {
            // partitions
            err = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
            if (err) {
                goto Failure;
            }
            err = DBGetAttVal_AC(pTHS->pDB,
                                 1,
                                 pACfsmo,
                                 DBGETATTVAL_fREALLOC,
                                 cbDN,
                                 &cbRet,
                                 (UCHAR**)&pDN);
            if (err) {
                goto Failure;
            }
            cbDN = max(cbDN, cbRet);
            if (NameMatched(pDN, gAnchor.pDSADN)) {
                // we're holding the domain master role
                if (!GiveawayOneFsmoRole(pTHS,
                                         gAnchor.pPartitionsDN,
                                         NULL,
                                         pTarget,
                                         pOpRes)) {
                    bFailed = TRUE;
                }
            }

            // DMD
            err = DBFindDSName(pTHS->pDB, gAnchor.pDMD);
            if (err) {
                goto Failure;
            }
            err = DBGetAttVal_AC(pTHS->pDB,
                                 1,
                                 pACfsmo,
                                 DBGETATTVAL_fREALLOC,
                                 cbDN,
                                 &cbRet,
                                 (UCHAR**)&pDN);
            if (err) {
                goto Failure;
            }
            cbDN = max(cbDN, cbRet);
            if (NameMatched(pDN, gAnchor.pDSADN)) {
                // we're holding the schema master role
                if (!GiveawayOneFsmoRole(pTHS,
                                         gAnchor.pDMD,
                                         NULL,
                                         pTarget,
                                         pOpRes)) {
                    bFailed = TRUE;
                }
            }
        }

        //
        // Report error if one or more calls failed
        //
        if ( bFailed ) {

            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        ERROR_DS_UNABLE_TO_SURRENDER_ROLES);

            __leave;

        }

        __leave;

      Failure:
        DPRINT1(0, "Error %u getting FSMO info\n", err);
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    DS_ERR_MISSING_FSMO_SETTINGS);
    } finally {

        if (pTHS->pDB) {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        if ( pTarget ) {
            THFreeEx( pTHS, pTarget );
        }

    }
    return pTHS->errCode;
}


ULONG
UpdateCachedMemberships(
    OPARG * pOpArg,
    OPRES *pOpRes
    )
/*++

Routine Description:

    This routine initiates a refresh of group memberships for
    users that have affinity for the current site.  See
    RefreshUserMembershipsMain() for more details.

Parameters:

    pOpArg -- the input parameters for DirOperationControl

    pOpRes -- the output error structure -- set to success

Return Values

        Success

 --*/
{
    ULONG secsTillNextIter;
    BOOL granted;
    DWORD err;
    THSTATE *pTHS = pTHStls;

    memset(pOpRes, 0, sizeof(*pOpRes));

    Assert(NULL == pTHS->pDB);
    granted = CheckControlAccessOnObject(pTHS,
                                         gAnchor.pDSADN,
                                         RIGHT_DS_REFRESH_GROUP_CACHE);
    Assert(NULL == pTHS->pDB);
    if(!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    RefreshUserMembershipsMain( &secsTillNextIter, TRUE );


    return 0;
}


ULONG
SchemaUpgradeInProgress(
    OPARG *pOpArg,
    OPRES *pOpRes
    )
/*++

Routine Description:
    Enable or disable fSchemaUpgradeInProgress (schupgr.exe is running)

Parameters:

    pOpArg -- the input parameters for DirOperationControl

    pOpRes -- the output error structure -- set to success

Return Values

        Success

 --*/
{
    THSTATE *pTHS = pTHStls;
    BOOL granted;

    // Permission to become schema master is sufficient to set
    // fSchemaUpgradeInProgress
    Assert(NULL == pTHS->pDB);
    granted =
        CheckControlAccessOnObject(pTHS,
                                   gAnchor.pDMD,
                                   RIGHT_DS_CHANGE_SCHEMA_MASTER);
    if (!granted) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    // If the first and only byte is ASCII 1, then enable fSchemaUpgradeInProgress
    // Otherwise, disable fSchemaUpgradeInProgress
    if (   pOpArg
        && pOpArg->cbBuf == 1
        && pOpArg->pBuf
        && pOpArg->pBuf[0] == '1') {
        gAnchor.fSchemaUpgradeInProgress = TRUE;
    } else {
        gAnchor.fSchemaUpgradeInProgress = FALSE;
    }
    return 0;
}



#if DBG

ULONG
DraTestHook(
    IN  THSTATE *   pTHS,
    IN  OPARG *     pOpArg
    )
/*++

Routine Description:

    Modify replication subsystem state at the request of a test program.

Arguments:

    pTHS (IN) -

    pOpArg (IN) - Contains control string.  Valid control strings are made up of
        zero or more keywords.  Each keyword has an optional '+' or '-' prefix;
        if no prefix is supplied, '+' is assumed.  Valid keywords are:

            lockqueue - Lock (or unlock, with '-' prefix) the replication
                operation queue.  While the queue is locked no operations
                in the queue will be performed or removed (although additional
                operations can be added).

            link_cleaner - Enable or Disable the link cleaner

            rpctime - Enable with + prefix and input:
                            <rpccall>
                            <hostname or ip>
                            <seconds for call>
                      When this is enabled, any call to <rpccall> from client
                      <hostname or ip> will take <seconds for call> longer to execute,
                      all enabled calls use the same client (of last enable)
                            example:  +rpctime:executekcc,172.26.220.42,100

                      Disable with - prefix
                            example: -rpctime

            rpcsync - Enable with + prefix and input:
                            <rpccall>
                            <hostname or ip>
                      When this is enabled, any call to <rpccall> from client
                      <hostname or ip> will wait until another thread enters the same
                      barrier from another call to any other rpc call from this same
                      client which is enabled (could be <rpccall>)
                            example:  +rpcsync:unbind,testmachine1
                      these waiting periods have a 1 minute timeout.  after 1 minute
                      if nothing happens the threads waiting reset the barrier and exit

                      Disable with - prefix
                            example:  -rpcsync
Return Values:

    pTHS->errCode

--*/
{
    LPSTR pszInitialCmdStr;
    LPSTR pszCmdStr;
    DWORD err = 0;
    ULONG ulPosition;
    BOOL fPrivilegeHeld;

    if ((err = CheckPrivilegeAnyClient(SE_DEBUG_PRIVILEGE, &fPrivilegeHeld)) != 0 || !fPrivilegeHeld) {
        SetSecErrorEx(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_PRIVILEGE_NOT_HELD, err);
        return ERROR_PRIVILEGE_NOT_HELD;
    }

    // Copy and null-terminate command string.
    pszInitialCmdStr = pszCmdStr = THAllocEx(pTHS, 1 + pOpArg->cbBuf);
    memcpy(pszCmdStr, pOpArg->pBuf, pOpArg->cbBuf);
    pszCmdStr[pOpArg->cbBuf] = '\0';

    for (pszCmdStr = strtok(pszCmdStr, " \t\r\n");
         !err && (NULL != pszCmdStr);
         pszCmdStr = strtok(NULL, " \t\r\n")
         )
        {
        BOOL fEnable = TRUE;
        DWORD iKeyword = 0;

        switch (pszCmdStr[0]) {
        case '-':
            fEnable = FALSE;
            // fall through...

        case '+':
            // Ignore this character (i.e., "+keyword" is same as "keyword").
            iKeyword++;
            // fall through...

        default:
            if (0 == _strcmpi(&pszCmdStr[iKeyword], "lockqueue")) {
                err = DraSetQueueLock(fEnable);
            } else if (0 == _strcmpi(&pszCmdStr[iKeyword], "link_cleaner")) {
                err = dsaEnableLinkCleaner(fEnable);
            } else if (0 == _strnicmp(&pszCmdStr[iKeyword], "rpctime:", 7)) {
                if (!fEnable) {
                    // disable the test (ignore any extra input)
                    RpcTimeReset();
                }
                else {
                    // enable the test
                    LPSTR pszDSAFrom = ParseInput(&pszCmdStr[iKeyword + 8], ',',1);
                    LPSTR pszRpcCall = ParseInput(&pszCmdStr[iKeyword + 8], ',',0);
                    LPSTR pszRunTime = ParseInput(&pszCmdStr[iKeyword + 8], ',',2);
                    ULONG ulRunTime = pszRunTime ? atoi(pszRunTime) : 0;
                    ULONG IPAddr;
                    RPCCALL rpcCall;

                    IPAddr = GetIPAddrA(pszDSAFrom);
                    rpcCall = GetRpcCallA(pszRpcCall);

                    if ((IPAddr!=INADDR_NONE) && (rpcCall!=0)) {
                        RpcTimeSet(IPAddr,rpcCall, ulRunTime);
                    }
                    else {
                        DPRINT(0,"RPCTIME:  Illegal Parameter.\n");
                        err = ERROR_INVALID_PARAMETER;
                    }
                    if (pszDSAFrom) {
                        THFree(pszDSAFrom);
                    }
                    if (pszRpcCall) {
                        THFree(pszRpcCall);
                    }
                    if (pszRunTime) {
                        THFree(pszRunTime);
                    }
                }
            } else if (0 == _strnicmp(&pszCmdStr[iKeyword], "rpcsync:", 7)) {
                // parse input to rpcsync
                if (!fEnable) {
                    // disable the test for all RPC Calls
                    RpcSyncReset();
                }
                else {
                    // enable the test
                    LPSTR pszDSAFrom = ParseInput(&pszCmdStr[iKeyword + 8], ',',1);
                    LPSTR pszRpcCall = ParseInput(&pszCmdStr[iKeyword + 8], ',',0);
                    ULONG IPAddr;
                    RPCCALL rpcCall;

                    IPAddr = GetIPAddrA(pszDSAFrom);
                    rpcCall = GetRpcCallA(pszRpcCall);
                    if ((IPAddr!=INADDR_NONE) && (rpcCall!=0)) {
                        RpcSyncSet(IPAddr,rpcCall);
                    }
                    else {
                        DPRINT(0,"RPCSYNC:  Illegal Parameter.\n");
                        err = ERROR_INVALID_PARAMETER;
                    }
                    if (pszDSAFrom) {
                        THFree(pszDSAFrom);
                    }
                    if (pszRpcCall) {
                        THFree(pszRpcCall);
                    }
                }
            } else {
                DPRINT1(0,"Error, invalid parameter %s\n", &pszCmdStr[iKeyword]);
                err = ERROR_INVALID_PARAMETER;
            }
        }
    }

    if (err) {
        DPRINT2(0, "TEST ERROR: Failed to process repl test hook request \"%s\", error %d.\n",
                pszCmdStr, err);
        SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, err);
    }

    THFreeEx(pTHS, pszInitialCmdStr);

    return pTHS->errCode;
}
#endif


#ifdef INCLUDE_UNIT_TESTS
void
phantomizeForOrphanTest(
    THSTATE *pTHS,
    OPARG   * pOpArg
    )

/*++

Routine Description:

    Description

Arguments:

    pTHS -
    pOpArg -

Return Value:

    None

--*/

{
    LPWSTR pszWideDN = NULL;
    DWORD dwRet;
    DSNAME *pDN = NULL;

    pszWideDN = UnicodeStringFromString8( CP_UTF8, pOpArg->pBuf, pOpArg->cbBuf );
    Assert( pszWideDN );

    dwRet = UserFriendlyNameToDSName( pszWideDN, wcslen( pszWideDN ), &pDN );
    if (dwRet) {
        DPRINT1( 0, "DSNAME conversion failed, string=%ws\n", pszWideDN );
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    ERROR_DS_INVALID_DN_SYNTAX);
        return;
    }

    SYNC_TRANS_WRITE();
    try {
        dwRet = DBFindDSName(pTHS->pDB, pDN);
        if (dwRet) {
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        ERROR_DS_NO_SUCH_OBJECT);
            return;
        }
        dwRet = DBPhysDel( pTHS->pDB, TRUE, NULL );
        if (dwRet) {
            DPRINT1( 0, "DBPhysDel failed with status %d\n", dwRet );
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        ERROR_DS_DATABASE_ERROR);
        }

        DPRINT1( 0, "Successfull phantomized %ws\n", pDN->StringName );
    } finally {
        if (pTHS->pDB) {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }
    }
    return ;

} /* phantomizeForOrphanTest */

VOID
RemoveObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    )

/*++

Routine Description:

    A routine to remove an object, becoming a tombstone. The deletion time is set so that
    the object is a candidate for immediate garbage collection, without waiting for a
    tombstone lifetime.

    This routine exercises the object->tombstone->phantom->deleted life cycle.

Arguments:

    pOpArg -
    pOpRes -

Return Value:

    None

--*/

{
    THSTATE *pTHS = pTHStls;
    LPWSTR pszWideDN = NULL;
    DWORD dwRet;
    DSNAME *pDN = NULL;
    REMOVEARG removeArg;

    pszWideDN = UnicodeStringFromString8( CP_UTF8, pOpArg->pBuf, pOpArg->cbBuf );
    Assert( pszWideDN );

    dwRet = UserFriendlyNameToDSName( pszWideDN, wcslen( pszWideDN ), &pDN );
    if (dwRet) {
        DPRINT1( 0, "DSNAME conversion failed, string=%ws\n", pszWideDN );
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    ERROR_DS_INVALID_DN_SYNTAX);
        return;
    }

    SYNC_TRANS_WRITE();

    // Become replicator
    // This allows us to delete parents with live children
    Assert( !pTHS->fDRA );
    pTHS->fDRA = TRUE;

    try {
        dwRet = DBFindDSName(pTHS->pDB, pDN);
        if (dwRet) {
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        ERROR_DS_NO_SUCH_OBJECT);
            return;
        }

        memset(&removeArg, 0, sizeof(removeArg));
        removeArg.pObject = pDN;
        removeArg.pResObj = CreateResObj(pTHS->pDB, pDN);

        // Security is checked in this call
        LocalRemove(pTHS, &removeArg);

        THFreeEx(pTHS, removeArg.pResObj);

        if (pTHS->errCode) {
            DbgPrintErrorInfo();
            __leave;
        }

        // Set the deletion time in the past so that it will be considered for
        // garbage collection immediately

        DBAddDelIndex( pTHS->pDB, TRUE );

        DPRINT1( 0, "Successfully removed %ws\n", pDN->StringName );
    } finally {
        pTHS->fDRA = FALSE;

        if (pTHS->pDB) {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }
    }
    return ;


} /* RemoveObject */

// unit-test globals
DWORD dwUnitTestSchema;
DWORD dwUnitTestIntId;

// unit-test functions
extern int SCCheckSchemaCache(IN THSTATE *pTHS, IN PCHAR pBuf);
extern int SCCheckRdnOverrun(IN THSTATE *pTHS, IN PCHAR pBuf);
extern int SCCopySchema(IN THSTATE *pTHS, IN PCHAR pBuf);
extern int SCSchemaPerf(IN THSTATE *pTHS, IN PCHAR pBuf);
extern int SCSchemaStats(IN THSTATE *pTHS, IN PCHAR pBuf);

extern int CorruptDB(THSTATE* pTHS, IN PCHAR pBuf);

// Generic controls are table driven
//     If non-NULL, the global dword is set.
//     If non-NULL, the function is called.
struct _GenericControl {
    DWORD cbBuf;
    PCHAR pBuf;
    DWORD *pdwGlobal;
    int   (*Func)(IN THSTATE *pTHS, IN PCHAR pBuf);
} aGenericControls[] = {
    { sizeof("schema=") - 1    , "schema="    , &dwUnitTestSchema, NULL },
    { sizeof("intid=") - 1     , "intid="     , &dwUnitTestIntId, NULL },
    { sizeof("schemastats") - 1, "schemastats", NULL, SCSchemaStats },
    { sizeof("checkSchema") - 1, "checkSchema", NULL, SCCheckSchemaCache },
    { sizeof("rdnoverrun") - 1 , "rdnoverrun" , NULL, SCCheckRdnOverrun },
    { sizeof("copySchema") - 1,  "copySchema",  NULL, SCCopySchema },
    { sizeof("schemaperf") - 1,  "schemaperf",  NULL, SCSchemaPerf },
    { sizeof("CorruptDB:") - 1,  "CorruptDB:",  NULL, CorruptDB },
    { 0, NULL, NULL, NULL }
};
ULONG
GenericControl (
        OPARG *pOpArg,
        OPRES *pOpRes
        )
{
    THSTATE *pTHS = pTHStls;
    struct _GenericControl *pGC;
    PCHAR pBuf;

    // coded for just 1 arg
    if (!pOpArg || !pOpArg->pBuf) {
        return SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, DIRERR_UNKNOWN_OPERATION);
    }

    // null-terminate the argument
    pBuf = THAllocEx(pTHS, pOpArg->cbBuf+1);
    memcpy(pBuf, pOpArg->pBuf, pOpArg->cbBuf);

    // Locate the corresponding table entry
    for (pGC = aGenericControls; pGC->cbBuf; ++pGC) {
        if (0 == _strnicmp(pBuf, pGC->pBuf, pGC->cbBuf)) {
            // set a global
            if (pGC->pdwGlobal) {
                *(pGC->pdwGlobal) = atoi(pBuf + pGC->cbBuf);
                DPRINT2(0, "%s %d\n", pGC->pBuf, *(pGC->pdwGlobal));
            }
            // call a function and return
            if (pGC->Func) {
                DPRINT1(0, "%s function call\n", pBuf);
                return (pGC->Func)(pTHS, pBuf + pGC->cbBuf);
            }
            // return success
            return 0;
        }
    }
    return SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, DIRERR_UNKNOWN_OPERATION);
} /* GenericControl */


VOID
ProtectObject(
    OPARG *pOpArg,
    OPRES *pOpRes
    )

/*++

Routine Description:

    A test routine to call DirProtectEntry on an object

Arguments:

    pOpArg -
    pOpRes -

Return Value:

    None

--*/

{
    THSTATE *pTHS = pTHStls;
    LPWSTR pszWideDN = NULL;
    DWORD dwRet;
    DSNAME *pDN = NULL;

    pszWideDN = UnicodeStringFromString8( CP_UTF8, pOpArg->pBuf, pOpArg->cbBuf );
    Assert( pszWideDN );

    dwRet = UserFriendlyNameToDSName( pszWideDN, wcslen( pszWideDN ), &pDN );
    if (dwRet) {
        DPRINT1( 0, "DSNAME conversion failed, string=%ws\n", pszWideDN );
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    ERROR_DS_INVALID_DN_SYNTAX);
        return;
    }

    DirProtectEntry( pDN );

    return;
} /* ProtectObject */

#endif INCLUDE_UNIT_TESTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mddel.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mddel.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirRemoveEntry API.

    DirRemoveEntry() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <ntdsctr.h>                    // Perf Hook
#include <ntdsa.h>
#include <cracknam.h>
#include <quota.h>

// SAM interoperability headers
#include <mappings.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"
#include "dstaskq.h"
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include "permit.h"
#include "debug.h"                      // standard debugging header
#include "drameta.h"
#define DEBSUB "MDDEL:"                 // define the subsystem for debugging

#define _AVOID_REPL_API
#include "nlrepl.h"

#include <fileno.h>
#define  FILENO FILENO_MDDEL

#include <dnsapi.h>                     // DnsValidateDnsName
#include <dsgetdc.h>                    // DsValidateSubnetNameW


ULONG gulDecoupleDefragFromGarbageCollection = 0;

int
PrivateLocalRemoveTree (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        );

/* Internal functions */
int
MakeNameForDeleted(
        THSTATE *pTHS,
        DSNAME *pObject,
        DSNAME *pDeletedName,
        ULONG  cbDeletedBuf,
        ATTR *pNewRDN
        );

DWORD
PossiblyMoveDeletedObject (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        );

int NoDelCriticalSystemObjects(REMOVEARG *pRemoveArg);
int SetDelAtt(RESOBJ *pObj, ATTRTYP rdnType);
int CheckCatalogd(THSTATE *pTHS, DSNAME *pDN);

extern DWORD GetConfigParam(char * parameter, void * value, DWORD dwSize);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirRemoveEntry(
    REMOVEARG  * pRemoveArg,     /* RemoveEntry  argument */
    REMOVERES ** ppRemoveRes
){

    THSTATE*     pTHS;
    REMOVERES * pRemoveRes;
    BOOL           fContinue;
    BOOL           fDidPrivateLocalRemoveTree = FALSE;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirRemoveEntry entered\n");


    // This operation should not be performed on read-only objects.
    pRemoveArg->CommArg.Svccntl.dontUseCopy = TRUE;

    /* Initialize the THSTATE anchor and set a write sync-point.  This sequence
       is required on every API transaction.  First the state DS is initialized
       and then either a read or a write sync point is established.
       */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    pTHS->fLazyCommit |=  pRemoveArg->CommArg.fLazyCommit;
    *ppRemoveRes = pRemoveRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppRemoveRes = pRemoveRes = THAllocEx(pTHS, sizeof(REMOVERES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

        if( pRemoveArg->fTreeDelete ) {

            if (  (TRANSACT_BEGIN_END != pTHS->transControl)
               || (NULL != pTHS->pSamLoopback) )
            {
                //
                // N.B. Due to the transaction scheme used for
                // our tree delete, clients cannot expect thier current
                // transaction to live beyond this call, hence the
                // "dont_end" restriction.  Furthermore, the tree delete
                // routine ends the transaction independent of success
                // hence allowing dont_begin_end would be misleading.
                // Thus, there is only one kind of transControl allowed.
                //
                // Since SAM controls its own transactioning, this should
                // not be used during loopback either.
                //
                // This is an internal error, since the system controls how DirXxx
                // api are called and should never program this combination.
                //
                Assert( TRANSACT_BEGIN_END == pTHS->transControl );
                Assert( NULL == pTHS->pSamLoopback );
                SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM, DS_ERR_INTERNAL_FAILURE );
                __leave;
            }

            // This is a legal operation

            SYNC_TRANS_READ();
        }
        else {
            SYNC_TRANS_WRITE();       /* Set Sync point*/
        }
        __try {
            /* Inhibit update operations if the schema hasen't been loaded yet
               or if we had a problem loading.
               */

            if (!gUpdatesEnabled){
                DPRINT(2, "Returning BUSY because updates are not enabled yet\n");
                SetSvcError(SV_PROBLEM_BUSY, DIRERR_SCHEMA_NOT_LOADED);
                __leave;
            }

            // Perform name resolution to locate object.  If it fails,
            // just return an error, which may be a referral. Note that
            // we must demand a writable copy of the object.
            pRemoveArg->CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               NAME_RES_IMPROVE_STRING_NAME,
                               pRemoveArg->pObject,
                               &pRemoveArg->CommArg,
                               &pRemoveRes->CommRes,
                               &pRemoveArg->pResObj)){

                if(pRemoveArg->fTreeDelete) {
                    // Local Remove Tree operation
                    pRemoveArg->fTreeDelete = FALSE;
                    pRemoveArg->fDontDelCriticalObj = TRUE;
                    fDidPrivateLocalRemoveTree = TRUE;
                    PrivateLocalRemoveTree(pTHS, pRemoveArg);
                }
                else {
                    /* Local Remove operation */

                    if (!SampRemoveLoopbackCheck(pRemoveArg, &fContinue) &&
                        fContinue ) {
                        LocalRemove(pTHS, pRemoveArg);
                    }
                }
            }
        }
        __finally {
            // Security errors are logged separately
            if (pTHS->errCode != securityError) {
                BOOL fFailed = (BOOL)(pTHS->errCode || AbnormalTermination());

                LogEventWithFileNo(
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         fFailed ?
                            DS_EVENT_SEV_VERBOSE :
                            DS_EVENT_SEV_INTERNAL,
                         fFailed ?
                            DIRLOG_PRIVILEGED_OPERATION_FAILED :
                            DIRLOG_PRIVILEGED_OPERATION_PERFORMED,
                         szInsertSz(""),
                         szInsertDN(pRemoveArg->pObject),
                         NULL,
                         FILENO);
            }

            if(!fDidPrivateLocalRemoveTree) {
                // If we didn't do a localremovetree, then we have yet to do
                // this. PrivateLocalRemoveTree does this for itself.
                CLEAN_BEFORE_RETURN (pTHS->errCode);
            }
            else {
                // If we did do a localremovetree, then we need to reset the
                // flag in the remove arg.  This is just to be consistent to our
                // callers.
                pRemoveArg->fTreeDelete = TRUE;
            }

        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pRemoveRes) {
        pRemoveRes->CommRes.errCode = pTHS->errCode;
        pRemoveRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;
}                               /*S_DirRemoveEntry*/

int
GetRdnTypeForDeleteOrRename (
    IN THSTATE      *pTHS,
    IN DSNAME       *pObj,
    OUT ATTRTYP     *pRdnType
    )
/*++
Routine Description:
    Retrieve the rdnType (msDS-IntId) needed for checks in
    LocalRemove and LocalModifyDn. The rdnType is read from the object.
    If no value for rdnType is present (what?), the rdnType
    is found from the most-specific component of the object's DN.

Arguments:
    pTHS - thread state
    pObj - object to be removed (pRemoveArg->pResObj->pObj)
    pRdnType - returned rdnType

Return Value:
    0 if all went well and *pRdnType will be set, an error otherwise and
    *pRdnType will be unchanged. If an error is returned, a Set???Error
    will already have been called.
--*/
{
    ULONG   dwErr;

    // Use the object's rdnType, not the rdnattid from its class definition
    // A superceding class may have a different rdnattid than the
    // the superceded class in effect when this object was created.
    if(dwErr = DBGetSingleValue(pTHS->pDB,
                              FIXED_ATT_RDN_TYPE,
                              pRdnType,
                              sizeof(*pRdnType),
                              NULL)) {
        if (DB_ERR_NO_VALUE == dwErr) {
            // Hmmm... the object doesn't have an rdnType? No matter. Simply
            // retrieve the RDN type of the old name.  Note that this value may be
            // different from that specified in the CLASSCACHE for this object's
            // object class; specifically, they will likely differ if we're deleting
            // an auto-generated subref, in which case the class is CLASS_TOP, the
            // class-specific RDN type for CLASS_TOP is ATT_COMMON_NAME, but the subref
            // likely corresponds to, e.g., DC=Child,DC=Root,DC=Microsoft,....
            // In this case the RDN type in the DSNAME must be "DC", not "CN".
            if ( !pObj->StringName || !pObj->NameLen) {
                dwErr = DIRERR_NAME_TYPE_UNKNOWN;
            } else {
                dwErr = GetRDNInfo(pTHS, pObj, NULL, NULL, pRdnType);
            }
            if (dwErr) {
                return SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pObj, DIRERR_BAD_NAME_SYNTAX);
            }
        } else {
            // We shouldn't be here.  Assume a temporary problem.
            // (record locks, etc.)
            return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                 DIRERR_DATABASE_ERROR, dwErr);
        }
    }
    return 0;
}

/*++
Routine Description
    Remove an object from the directory.  Actually, mark object as deleted, but
    leave row in database alone (needed for tombstone replication)

    Unless fPreserveRDN is set in the REMOVEARG, this routine will delete-mangle
    both the "true" RDN (ATT_RDN) and the class-specific RDN, changing them to
    the stringized object GUID plus an invalid character.  This avoids name
    conflicts between deleted objects and new objects with the same RDN.

Arguments
   pTHS - Threadstate pointer

   pRemoveArg - REMOVEARG structure containing the name of the object to remove.

 --*/

int
LocalRemove (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        )
{
    CLASSCACHE *pClassSch = NULL;
    ATTR       NewRDN;
    ATTRVAL    NewRDNAV;
    DSNAME    *pDeletedName = NULL;
    ULONG      cbDeletedBuf = 0;
    ULONG      iClass, LsaClass;
    DSNAME     *pObjToRemove;
    ULONG      len;
    DWORD      err;
    DSA_DEL_INFO *pDsaDelInfo = NULL;
    ATTRTYP    AttLsaLikes = ATT_USER_ACCOUNT_CONTROL;
    DWORD      ActiveContainerID;
    BOOL       fSuccess = FALSE;

    extern BOOL gfRunningAsMkdit;       //from dsamain.c

    DPRINT(1,"LocalRemove entered\n");

    PERFINC(pcTotalWrites);
    INC_WRITES_BY_CALLERTYPE( pTHS->CallerType );

    Assert(pRemoveArg->pResObj);

    //
    // Trace event
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_REMOVE,
                     EVENT_TRACE_TYPE_START,
                     DsGuidDelete,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertDN(pRemoveArg->pObject),
                     NULL, NULL, NULL, NULL, NULL, NULL);

    // We should be positioned on the object by now.  Since the client
    // might have passed in a GUID or SID only name, use the fully prepped
    // name in the resobj
    pObjToRemove = pRemoveArg->pResObj->pObj;
    Assert(pObjToRemove->NameLen);

    pClassSch = SCGetClassById(pTHS,
                               pRemoveArg->pResObj->MostSpecificObjClass);
    Assert(pClassSch);

    if (!pClassSch) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        goto exit;
    }

    //
    // Check Remove Security
    //

    if (CheckRemoveSecurity(
            FALSE,
            pClassSch,
            pRemoveArg->pResObj))
    {
        goto exit;
    }

    // Don't allow re-deletions of tombstones, except if caller is the
    // replicator.
    if (pRemoveArg->pResObj->IsDeleted && !pTHS->fDRA) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);

        goto exit;
    }

    // Check to see if this is an update in an active container
    CheckActiveContainer(pRemoveArg->pResObj->PDNT, &ActiveContainerID);
    if(ActiveContainerID) {
        if(PreProcessActiveContainer(pTHS,
                                     ACTIVE_CONTAINER_FROM_DEL,
                                     pObjToRemove,
                                     pClassSch,
                                     ActiveContainerID)) {
            goto exit;
        }
    }

    cbDeletedBuf = pObjToRemove->structLen + MAX_RDN_SIZE * sizeof(WCHAR);
    pDeletedName= THAllocEx(pTHS, cbDeletedBuf);

    // RDNs should be preserved only when the DRA is tearing down a
    // read-only NC, or if the DSA really wants to
    Assert( !pRemoveArg->fPreserveRDN || pTHS->fDRA || pTHS->fDSA);

    // lock the DN against someone adding children to this object.

    err = DBLockDN(pTHS->pDB, DB_LOCK_DN_WHOLE_TREE, pObjToRemove);
    if(err && !(err & DB_LOCK_DN_CONFLICT_TREE_ABOVE) &&
       !(err & DB_LOCK_DN_CONFLICT_STICKY))

    if (    err
            // and not the tree delete case
         && (    !(err & DB_LOCK_DN_CONFLICT_TREE_ABOVE)
              && !(err & DB_LOCK_DN_CONFLICT_STICKY) )
            // and not the CreateProxyObject case - three flags required
         && (    !(err & DB_LOCK_DN_CONFLICT_NODE)
              && !(err & DB_LOCK_DN_CONFLICT_TREE_BELOW)
              && !pTHS->fCrossDomainMove ) )
    {
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
        goto exit;
    }

    NewRDN.AttrVal.pAVal = &NewRDNAV;
    // Null this, since we might have to free it later, and we'd rather not free
    // stack noise.
    NewRDN.AttrVal.pAVal->pVal = NULL;

    if (pClassSch->ClassId == CLASS_NTDS_DSA) {
        // If someone's deleting a DSA, we need to gather some info from
        // the object before it gets stripped, so that we can later tell
        // NetLogon about the deletion, but only if this is an originating
        // write.
        if (!pTHS->fDRA) {
            pDsaDelInfo = GatherDsaDelInfo(pTHS, pRemoveArg->pResObj);
        }
        if (gAnchor.ForestBehaviorVersion == DS_BEHAVIOR_WIN2000) {
            // when a w2k ntdsa object is deleted, we should check if
            // all the w2k dcs are gone, if so, we may need to publish
            // ntMixedDomain onto the crossRef.
            pTHS->fBehaviorVersionUpdate = TRUE;
        }
    }

    if (!pTHS->fDRA && !pTHS->fSingleUserModeThread) {
        DWORD dwSamAccountType = 0;
        DWORD cb;

        // check for domain rename constraints
        switch (pClassSch->ClassId) {
        case CLASS_USER:
            // We don't allow removing inter-domain trust account (ITA)
            // objects when domain rename is in progress. These can be
            // identified by samAccountType == SAM_TRUST_ACCOUNT
            err = DBGetSingleValue(pTHS->pDB, ATT_SAM_ACCOUNT_TYPE, &dwSamAccountType, sizeof(dwSamAccountType), &cb);
            if (err) {
                if (err == DB_ERR_NO_VALUE) {
                    // No sam account type? weird. Anyway, this is not an ITA object, just go on.
                    err = 0;
                    break;
                }
                // some other error
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, err);
                goto exit;
            }
            if (dwSamAccountType != SAM_TRUST_ACCOUNT) {
                // this is not an ITA, go on as usual
                break;
            }
            // this is an ITA, fall through to check for domain rename in progress

        case CLASS_CROSS_REF:
        case CLASS_TRUSTED_DOMAIN:
        case CLASS_NTDS_DSA:
            // these objects can not be added if a rename domain operation is in progress
            if (err = VerifyDomainRenameNotInProgress(pTHS)) {
                // Most probably, err is ERROR_DS_DOMAIN_RENAME_IN_PROGRESS
                // (but it could be another error too, such as a DB error)
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, err);
                goto exit;
            }
            break;
        }
    }

    // Retrieve the rdnType (msDS-IntId) needed for the checks below.
    // Don't bother if none of the functions requiring rdnType will be
    // called. The rdnType is read from the object. If no value for
    // rdnType is present, the rdnType is found from the most-specific
    // component of the object's DN.
    //
    // The rdnattid in the object's class cannot be used because
    // a superceding class may have a different rdnattid than the
    // superceded class in effect when the object was created.
    NewRDN.attrTyp = INVALID_ATT;
    if (!pRemoveArg->fPreserveRDN || !pRemoveArg->fGarbCollectASAP) {
        if (GetRdnTypeForDeleteOrRename(pTHS, pObjToRemove, &NewRDN.attrTyp)) {
            goto exit;
        }
    }

    /* The order of these validations are important */

    // Note that we don't go through SetDelAtt() when we're going to try to
    // garbage collect this object ASAP.  SetDelAtt() simply sets the
    // is-deleted attribute and removes a bunch of attributes.  We need not
    // set is-deleted since we're going to immediately remove it in DBPhysDel()
    // along with most of the other attributes, EXCLUDING backlinks.  Backlinks
    // should be maintained, as presumably fGarbCollectASAP is only set when
    // we're tearing down a read-only NC, in which case we don't want to remove
    // forward links to this object from objects in other NCs.


    if (   (   pRemoveArg->fPreserveRDN
             ? (memcpy(pDeletedName,
                       pObjToRemove,
                       pObjToRemove->structLen), 0)
             : MakeNameForDeleted(pTHS,
                                  pObjToRemove,
                                  pDeletedName,
                                  cbDeletedBuf,
                                  &NewRDN)
           )
        || NoDelCriticalObjects(pRemoveArg->pResObj->pObj, pRemoveArg->pResObj->DNT)
        || NoDelCriticalSystemObjects(pRemoveArg)
        || (pTHS->fDRA      // if not DRA, make sure there are no children
            ? 0
            : NoChildrenExist(pTHS, pRemoveArg->pResObj))
        || (pRemoveArg->fGarbCollectASAP
            ? 0
            : SetDelAtt(pRemoveArg->pResObj, NewRDN.attrTyp))
        || (  pRemoveArg->fPreserveRDN
            ? 0
            : ReSetNamingAtts(pTHS,
                              pRemoveArg->pResObj,
                              NULL,
                              &NewRDN,
                              FALSE,
                              FALSE,
                              pClassSch)
            )
        || PossiblyMoveDeletedObject(pTHS, pRemoveArg)
        || InsertObj(pTHS, pObjToRemove, pRemoveArg->pMetaDataVecRemote, TRUE,
                    META_STANDARD_PROCESSING)
        ){

        // Clean up some memory we might have allocated.
        THFreeEx(pTHS,NewRDN.AttrVal.pAVal->pVal);
        goto exit;
    }

    // Clean up some memory we might have allocated.
    THFreeEx(pTHS,NewRDN.AttrVal.pAVal->pVal);

    if (pTHS->SchemaUpdate!=eNotSchemaOp) {
        //
        // On Schema updates we want to resolve conflicts, and we want to
        // do so without losing database currency, which would cause operations
        // a few lines below to fail.

        ULONG dntSave = pTHS->pDB->DNT;

        if (!pTHS->fDRA) {
            if(WriteSchemaObject()) {
                goto exit;
            }
        }

        //  A schema object cannot be deleted except for through schupgr.exe,
        if (     !pTHS->fDSA
              && !pTHS->fDRA
              && !gAnchor.fSchemaUpgradeInProgress
              && !gfRunningAsMkdit
              && !DsaIsInstalling()
              && (   pTHS->SchemaUpdate==eSchemaAttDel
                  || pTHS->SchemaUpdate==eSchemaClsDel ) ) {

            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_CANT_DELETE );
            goto exit;
        }


        if (ValidSchemaUpdate()) {
            goto exit;
        }

        // Now restore currency
        DBFindDNT(pTHS->pDB, dntSave);
    }

    if (
        //    The original data record is replaced by the new record
        //    with the Logical Flag set. This new record is the one
        //    to be entered into the deletion index. So the data record
        //    pos to be used should be the one setup by InsertObj.

           DBAddDelIndex(pTHS->pDB, pRemoveArg->fGarbCollectASAP)
        || CheckCatalogd(pTHS, pRemoveArg->pResObj->pObj)
        || DelObjCaching(pTHS, pClassSch, pRemoveArg->pResObj, TRUE)){

        if (0 == pTHS->errCode) {
            // Only case where this could happen is if DBAddDelIndex() failed,
            // in which case the failure is the inability to find either the
            // metadata vector or an entry in the vector for ATT_IS_DELETED
            // (which _should_ never happen).

            SetAttError(
                pObjToRemove,
                ATT_IS_DELETED,
                PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                NULL,
                DIRERR_MISSING_REQUIRED_ATT
                );
        }

        goto exit;
    }



    if (pRemoveArg->fGarbCollectASAP) {
        // Go ahead and try to physically delete this object.
        // At minimum this will strip the remaining attributes from the object
        // (most importantly all those that reference other objects) and
        // demote the object to a phantom.

        err = DBPhysDel(pTHS->pDB, TRUE, NULL);
        if(err){
            SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
        }
    }
    else
    {
        if (!pTHS->fDRA) {

            // Only notify replicas if this is not the DRA thread. If it is,
            // then we will notify replicas near the end of DRA_replicasync.
            // We can't do it now as NC prefix is in inconsistent state

            // Currency of DBPOS must be at the target object
            DBNotifyReplicasCurrDbObj(pTHS->pDB,
                         pRemoveArg->CommArg.Svccntl.fUrgentReplication );
        }


        //
        // We need to inform SAM and NetLogon of
        // changes to SAM objects to support downlevel replication
        //

        if (SampSamClassReferenced(pClassSch,&iClass)) {
                if ( SampQueueNotifications(
                         pObjToRemove,
                         iClass,
                         0,
                         SecurityDbDelete,
                         FALSE,
                         FALSE,
                         DomainServerRoleBackup,  // Place holder value
                                                  // for server role. Will
                                                  // not be used as the
                                                  // Role transfer parameter
                                                  // is set to FALSE
                         0,
                         NULL
                         ) )
                {
                    //
                    // the above routine failed
                    //
                    Assert(pTHS->errCode);
                    goto exit;
                }
        }

        //
        // We want to notify Lsa
        //

        if (SampIsClassIdLsaClassId(pTHS,
                                    pClassSch->ClassId,
                                    1,
                                    &AttLsaLikes,
                                    &LsaClass)) {

             if ( SampQueueNotifications(
                      pObjToRemove,
                      iClass,
                      LsaClass,
                      SecurityDbDelete,
                      FALSE,
                      FALSE,
                      DomainServerRoleBackup,
                      0,
                      NULL) )
             {
                 //
                 // the above routine failed.
                 //
                 Assert(pTHS->errCode);
                 goto exit;
             }
        }
    }

    if (pDsaDelInfo) {
        if (0 == pTHS->errCode) {
            // On commit, we will need to tell NetLogon that we deleted a DSA.
            // Append structure to the transactional data list.
            pDsaDelInfo->pNext = pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo;
            pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo = pDsaDelInfo;
        }
        else {
            // failure. Destroy the struct
            FreeDsaDelInfo(pTHS, pDsaDelInfo);
        }
    }

    // Cheaper to free stuff here than later.
    THFreeEx(pTHS, pDeletedName);

    fSuccess = TRUE;

exit:
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_REMOVE,
                     EVENT_TRACE_TYPE_END,
                     DsGuidDelete,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL,
                     NULL, NULL, NULL, NULL, NULL);

    Assert(fSuccess || pTHS->errCode);
    return (pTHS->errCode);  /*incase we have an attribute error*/

}/*LocalRemove*/

/* fDNTInProtectedList - Checks to see if the supplied DNT exists in the list
*       of DNTs whose deletion we should not allow.
*
*  Returns:
*       TRUE if DNT in list.
*
*  Note: Any changes in logic here should be mirrored in NoDelCriticalObjects
*        in src\mddel.c
*/
BOOL
fDNTInProtectedList(
    ULONG DNT,
    BOOL *pfNtdsaAncestorWasProtected
    )
{
    ULONG uli;

    if (pfNtdsaAncestorWasProtected) {
        *pfNtdsaAncestorWasProtected = FALSE;
    }

    // Can't delete NTDS-DSA object for this machine. Note that pAncestors is
    // ordered from the bottom of the tree toward the top, and we protect things
    // at the level of the Config container and above using other mechanisms
    for (uli=0;
         (uli<gAnchor.AncestorsNum &&
          gAnchor.pAncestors[uli] != gAnchor.ulDNTConfig); uli++) {
        if (DNT == gAnchor.pAncestors[uli]) {
            if (pfNtdsaAncestorWasProtected) {
                *pfNtdsaAncestorWasProtected = TRUE;
            }
            return TRUE;
        }
    }
    // Can't delete protected objects
    for (uli=0; uli < gAnchor.UnDeletableNum; uli++) {
        if (DNT == gAnchor.pUnDeletableDNTs[uli]) {
            return TRUE;
        }
    }
    // Can't delete protected objects ancestors
    for (uli=0; uli<gAnchor.UnDelAncNum; uli++) {
        if (DNT == gAnchor.pUnDelAncDNTs[uli]) {
            return TRUE;
        }
    }

    return FALSE;
}


/*++ NoDelCriticalObjects
 *
 * Set an error if the object is one of those this DSA refuses to delete.
 *
 *  Note that there are two separate definitions of "critical objects" floating
 *  around.  One is that list of objects marked in the Anchor as being
 *  ancestors of the DSA or otherwise undeletable, and these objects are
 *  not deletable by anyone.  These objects are protected by
 *  NoDelCriticalObjects.  The second definition is those objects stamped
 *  with the attribute criticalSystemObject.  Those objects can normally be
 *  deleted, except if the removearg explicitly asks to avoid stomping on
 *  them, which is usually the case only during tree deletes.  These objects
 *  are protected by NoDelCriticalSystemObjects
 */
int NoDelCriticalObjects(DSNAME *pObj,
                         ULONG  DNT)
{
    unsigned i;
    BOOL fNtdsaAncestorWasProtected;

    DPRINT(1,"NoDelCriticalObjects entered\n");

    if (fDNTInProtectedList( DNT, &fNtdsaAncestorWasProtected )) {

        if (fNtdsaAncestorWasProtected) {
            DPRINT(2,"Can't delete the DSA object for this service\n");
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_CANT_DELETE_DSA_OBJ);
        } else {
            DPRINT(2,"Can't delete protected objects\n");
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_CANT_DELETE);
        }
    }

    // Can't delete Cross-Ref objects corresponding to local master
    // config/schem/domain NCs.
    if (IsCrossRefProtectedFromDeletion(pObj)) {

        DPRINT(2,"Can't delete master cross-refs\n");
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_CANT_DEL_MASTER_CROSSREF);
    }

    return 0;    /*Not a critical object*/

}/*NoDelCriticalObjects*/

/*++ NoDelCriticalSystemObjects
 *
 * Set an error if the object is one of those this DSA refuses to delete,
 * unless you want to.
 *
 *  Note that there are two separate definitions of "critical objects" floating
 *  around.  One is that list of objects marked in the Anchor as being
 *  ancestors of the DSA or otherwise undeletable, and these objects are
 *  not deletable by anyone.  These objects are protected by
 *  NoDelCriticalObjects.  The second definition is those objects stamped
 *  with the attribute criticalSystemObject.  Those objects can normally be
 *  deleted, except if the removearg explicitly asks to avoid stomping on
 *  them, which is usually the case only during tree deletes.  These objects
 *  are protected by NoDelCriticalSystemObjects.
 */
int NoDelCriticalSystemObjects(REMOVEARG *pRemoveArg)
{
    ULONG IsCritical;

    if (pRemoveArg->fDontDelCriticalObj) {

        if ((0 == DBGetSingleValue(pTHStls->pDB,
                                   ATT_IS_CRITICAL_SYSTEM_OBJECT,
                                   &IsCritical,
                                   sizeof(IsCritical),
                                   NULL))
            && IsCritical) {
            // This object is marked as critical.  Fail the delete.
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ);
        }
    }

    return 0;    /*Not a critical object*/

}/*NoDelCriticalSystemObjects*/


/*++ GatherDsaDelInfo
 *
 * This routine gathers enough information about a DSA object to notify
 * NetLogon about the DSA's deletion.  This consists of GUIDs and DNS
 * addresses, which are scattered all over the place.  The GUID of the DSA
 * is embedded in the DSNAME of the DSA object.  The DNS address of the
 * host is on the DSA's parent (the server), stored as an attribute.  From
 * the DSA object we can also get a list of its master NCs, one of which
 * will be domain.  From the DSNAME of the domain we can extract both the
 * GUID of the domain and (separately) the DNS name of the domain.
 *
 * INPUT:
 *   pResObj - resolved object of the DSA being deleted
 * RETURN VALUE:
 *   pointer to information block
 */
DSA_DEL_INFO *
GatherDsaDelInfo(THSTATE *pTHS,
                 RESOBJ * pResObj)
{
    DSA_DEL_INFO *pInfo = NULL;
    unsigned cbCur, cbMax;
    DSNAME *pNC = NULL;
    unsigned err;
    unsigned iTagSequence;
    ATTCACHE *pAC;
    PDS_NAME_RESULTW pResults=NULL;
    WCHAR * apwc[1];
    UCHAR * pBuf = NULL;

    __try {
        // Use org heap, because this structure might overlive the current
        // transaction. And DRA likes to reset normal heap.
        pInfo = THAllocOrgEx(pTHS, sizeof(DSA_DEL_INFO));

        pInfo->DsaGuid = pResObj->pObj->Guid;

        cbMax = 0;
        cbCur = 0;
        iTagSequence = 0;
        pAC = SCGetAttById(pTHS, GetRightHasMasterNCsAttr(pTHS->pDB));
        Assert(pAC != NULL);

        do {
            ++iTagSequence;
            cbMax = max(cbMax, cbCur);

            //
            // PREFIX: PREFIX complains that pAC hasn't been checked to
            // make sure that it is not NULL.  This is not a bug.  Since
            // a predefined constant was passed to SCGetAttById, pAC will
            // never be NULL.
            //
            err = DBGetAttVal_AC(pTHS->pDB,
                                 iTagSequence,
                                 pAC,
                                 DBGETATTVAL_fREALLOC,
                                 cbMax,
                                 &cbCur,
                                 (UCHAR**)&pNC);
        } while (!err &&
                 NamePrefix(gAnchor.pConfigDN,
                            pNC));

        if (0 == err) {
            pInfo->DomainGuid = pNC->Guid;

            // Convert the name into a DNS address.
            apwc[0] = pNC->StringName;
            err = DsCrackNamesW((HANDLE) -1,
                                (DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC |
                                 DS_NAME_FLAG_SYNTACTICAL_ONLY),
                                DS_FQDN_1779_NAME,
                                DS_CANONICAL_NAME,
                                1,
                                apwc,
                                &pResults);
            if ( err                                // error from the call
                || !(pResults->cItems)            // no items returned
                || (pResults->rItems[0].status)   // DS_NAME_ERROR returned
                || !(pResults->rItems[0].pDomain) // No domain returned
                ) {
                // We couldn't crack the name?  Bad.  Assert for debugging and
                // continue for production.
                Assert(err == 0);
                err = RtlNtStatusToDosError(pResults->rItems[0].status);
                __leave;
            }
            cbCur = sizeof(WCHAR)*(1+wcslen(pResults->rItems[0].pDomain));
            pInfo->pDnsDomainName = THAllocOrgEx(pTHS, cbCur);

            memcpy(pInfo->pDnsDomainName,
                   pResults->rItems[0].pDomain,
                   cbCur);

        }
        else {
            // We ran out of NCs held by the DSA before we found one that wasn't
            // a child of the config container, i.e., before we found a domain NC.
            // That's unexpected, as every DSA should have a domain NC.  Assert
            // for debugging, and return nothing (so that NetLogon won't be
            // notified) for production.

            // DonH 7/9/98 - Due to a recent change in link attribute behavior,
            // we can now end up with NTDS-DSA objects with no domain listed (if
            // the domain is deleted before the NTDS-DSA object is).  In that case
            // we leave the DEL_INFO partially populated, with a NULL domain DNS
            // address and GUID.
            pInfo->pDnsDomainName = NULL;
        }

        DBFindDNT(pTHS->pDB, pResObj->PDNT);
        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_DNS_HOST_NAME,
                          0,
                          0,
                          &cbCur,
                          &pBuf);

        if (err) {
            // Dang.  Something must have failed.
            __leave;
        }

        // Now have to NULL terminate the host name
        pInfo->pDnsHostName = THAllocOrgEx(pTHS, cbCur + sizeof(WCHAR));
        memcpy(pInfo->pDnsHostName, pBuf, cbCur);
    }
    __finally {
        if (AbnormalTermination() || err) {
            FreeDsaDelInfo(pTHS, pInfo);
            pInfo = NULL;
        }
        THFreeEx(pTHS, pNC);
        THFreeEx(pTHS, pBuf);

        // Have to reposition where we were
        DBFindDNT(pTHS->pDB, pResObj->DNT);
    }

    return pInfo;
}


/*++ FreeDsaDelInfo
 *
 * Frees a DsaDelInfo structure that has been created with GatherDsaDelInfo.
 */
VOID FreeDsaDelInfo(THSTATE *pTHS, DSA_DEL_INFO *pDsaDelInfo) {
    if (pDsaDelInfo) {
        THFreeOrg(pTHS, pDsaDelInfo->pDnsDomainName);
        THFreeOrg(pTHS, pDsaDelInfo->pDnsHostName);
        THFreeOrg(pTHS, pDsaDelInfo);
    }
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int
SetDelAtt (RESOBJ *pResObj, ATTRTYP rdnType)
{
    THSTATE *              pTHS = pTHStls;
    DBPOS * const          pDB = pTHS->pDB;
    SYNTAX_BOOLEAN         true = TRUE;
    DWORD                  rtn = 0;
    ATTR *                 pAttr;
    unsigned               count, i, j;
    CLASSCACHE            *pCC;
    ATTCACHE              *pAC;
    BOOL                   fHasSD = FALSE;

    DPRINT(1,"SetDelAtt entered\n");

    // Remove all attributes that aren't marked as vital to keep.
    if (0 ==  DBGetMultipleAtts(pDB,
                                0,
                                NULL,
                                NULL,
                                NULL,
                                &count,
                                &pAttr,
                                0,
                                0)) {

        for(i=0;i<count;i++) {

            Assert( ATT_IS_DELETED != pAttr[i].attrTyp
                || pResObj->IsDeleted );

            switch (pAttr[i].attrTyp) {
              case ATT_NT_SECURITY_DESCRIPTOR:
                  // flag as having seen an SD (should only see one)
                  Assert( !fHasSD );
                  fHasSD = TRUE;
                  break;

              case ATT_ATTRIBUTE_ID:
              case ATT_ATTRIBUTE_SYNTAX:
              case ATT_DN_REFERENCE_UPDATE:
              case ATT_FLAT_NAME:               // For trust relationships
              case ATT_GOVERNS_ID:
              case ATT_GROUP_TYPE:              // downlevel BDC sync
              case ATT_INSTANCE_TYPE:
              case ATT_LDAP_DISPLAY_NAME:
              case ATT_LEGACY_EXCHANGE_DN:
              case ATT_MSMQ_OWNER_ID:           // for MSMQ NT4/NT5 sync
              case ATT_NC_NAME:
              case ATT_OBJECT_CLASS:
              case ATT_OBJ_DIST_NAME:
              case ATT_OBJECT_GUID:
              case ATT_OBJECT_SID:
              case ATT_OM_SYNTAX:
              case ATT_PROXIED_OBJECT_NAME:     // cross domain move
              case ATT_RDN:
              case ATT_REPL_PROPERTY_META_DATA:
              case ATT_SAM_ACCOUNT_NAME:        // downlevel BDC sync
              case ATT_SECURITY_IDENTIFIER:     // For trust relationships
              case ATT_SUB_CLASS_OF:
              case ATT_SYSTEM_FLAGS:
              case ATT_TRUST_PARTNER:           // For trust relationships
              case ATT_TRUST_DIRECTION:         // For trust relationships
              case ATT_TRUST_TYPE:              // For trust relationships
              case ATT_TRUST_ATTRIBUTES:        // For trust relationships
              case ATT_USER_ACCOUNT_CONTROL:    // downlevel BDC sync
              case ATT_USN_CHANGED:
              case ATT_USN_CREATED:
              case ATT_WHEN_CREATED:
              case ATT_MS_DS_CREATOR_SID:

                // Preserve these attributes no matter what.  Please keep
                // the list ordered, it's hard enough to find things as is.
                break;

              case ATT_LAST_KNOWN_PARENT:
                  // Preserve on replicated delete; remove on originating
                  if (!pTHS->fDRA) {
                      DBRemAtt(pDB, pAttr[i].attrTyp);
                  }
                  break;

              default:
                // preserve the att if the schema says to, or if it's the RDN,
                // or if it's a link or backlink attribute, which are handled
                // separately below
                pAC = SCGetAttById(pTHS, pAttr[i].attrTyp);
                Assert(pAC != NULL);
                if (   (pAttr[i].attrTyp == rdnType)
                    || (pAC->fSearchFlags & fPRESERVEONDELETE)
                    || (0 != pAC->ulLinkID)) {
                    break;
                }
                // Didn't make the test? Fall through to the delete case

              case ATT_IS_DELETED:
              case ATT_OBJECT_CATEGORY:
              case ATT_SAM_ACCOUNT_TYPE:
                // These atts (and others who failed the test) get removed
                DBRemAtt(pDB, pAttr[i].attrTyp);
            }

            // No values were actually fetched, so we don't have to free them

        }
        THFreeEx( pTHS, pAttr );
    }

    // QUOTA_UNDONE: LocalRemove() guarantees that this object is not already
    // tombstoned, except for replication, which will typically first call
    // LocalModify() to set ATT_IS_DELETED to TRUE and then call LocalRemove
    // to perform everything else associated with tombstoning an object
    //
	Assert( !pResObj->IsDeleted || pTHS->fDRA );

    // QUOTA_UNDONE: when would there not be an SD? Phantoms?
    //
	// QUOTA_UNDONE: should I also retrieve obj_col to verify this is truly an object,
	// or is checking for a non-null SD an equivalent check?
	//
    if ( fHasSD ) {
        SYNTAX_INTEGER  insttype;

        // must retrieve instance type to check if
        // if we're tracking quota for this object
        //
        rtn = GetExistingAtt(
                    pDB,
                    ATT_INSTANCE_TYPE,
                    &insttype,
                    sizeof(insttype) );
        if ( 0 != rtn ) {
            return rtn;
        }

        // quota only tracked for writable instantiated objects
        //
        if ( FQuotaTrackObject( insttype ) ) {
            // retrieve the SD so we can find the object
            // in the Quota table
            //
            PSECURITY_DESCRIPTOR   pSD = NULL;
            ULONG cbSD;

            rtn = DBGetAttVal(
                        pDB,
                        1,
                        ATT_NT_SECURITY_DESCRIPTOR,
                        0,
                        0,
                        &cbSD,
                        (UCHAR **)&pSD );
            if ( 0 != rtn ) {
                return SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, rtn );
            }

            Assert( NULL != pSD );

            // update quota for tombstoned object
            //
            rtn = ErrQuotaTombstoneObject( pDB, pResObj->NCDNT, pSD );
            THFreeEx( pTHS, pSD );
            if ( 0 != rtn ) {
                return rtn;
            }
        }
    }

    if ( (rtn = DBAddAtt(pDB, ATT_IS_DELETED, SYNTAX_BOOLEAN_TYPE))
       || (rtn =DBAddAttVal(pDB, ATT_IS_DELETED,
                            sizeof(SYNTAX_BOOLEAN),(UCHAR *) &true))) {
        DPRINT(1, "Couldn't add deletion flag\n");

        Assert(DB_ERR_VALUE_EXISTS != rtn);

        // All problems are assumed to be temporary (record locks, etc.)
        return SetSvcErrorEx(SV_PROBLEM_BUSY,
                             DIRERR_DATABASE_ERROR, rtn);
    }

    // Delete the member/is member attributes. We handle these differently
    // than other attributes so that we can remove backlinks, which are
    // not normally writable on objects.
    if (DBRemoveLinks(pDB) == DB_ERR_SYSERROR)
    {
        DPRINT(1,"Error removing links\n");
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,
                             DB_ERR_SYSERROR);
    }

    // Help folks find the original location of a deleted object
    // by setting ATT_LAST_KNOWN_PARENT. Originating delete only.
    // RAID 261208 in Windows Bugs.
    if (!pTHS->fDRA) {
        DSNAME *pLastKnownParent = THAllocEx(pTHS, pResObj->pObj->structLen);
        if (TrimDSNameBy(pResObj->pObj, 1, pLastKnownParent)
            || DBAddAtt(pDB, ATT_LAST_KNOWN_PARENT, SYNTAX_DISTNAME_TYPE)
            || DBAddAttVal(pDB, ATT_LAST_KNOWN_PARENT,
                           pLastKnownParent->structLen, pLastKnownParent)) {
            DPRINT(0,"Error while adding lastKnownParent (ignored)\n");
        }
        THFreeEx(pTHS, pLastKnownParent);
        pLastKnownParent = NULL;
    }

    return 0;

}/*SetDelAtt*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function removes any possible entries from the system catalog,  It
   also validates that no children exist for this object.
*/

int CheckCatalogd(THSTATE *pTHS,
                  DSNAME *pDN)
{

   SYNTAX_INTEGER instance;

   DPRINT(1,"CheckCatalogd entered\n");

   /* Position on the attribute instance.  */

   if (GetExistingAtt(pTHS->pDB, ATT_INSTANCE_TYPE, (void *) &instance,
                      sizeof(instance))){
          DPRINT(2,"Couldn't retrieve INSTANCE type error already set\n");
          return pTHS->errCode;
   }

   DPRINT1(2,"Instance type is <%lu>.\n", instance);


   if (DelCatalogInfo(pTHS, pDN, instance)){
      DPRINT(2,"Error while deleting global object info\n");
      return pTHS->errCode;
   }

   return 0;

}/*CheckCatalogd*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/


int
ReSetNamingAtts (
        THSTATE *pTHS,
        RESOBJ *pResObj,
        DSNAME *pNewParent,
        ATTR *pNewRDN,
        BOOL fCheckRDNConstraints,
        BOOL fAllowPhantomParent,
        CLASSCACHE *pClassSch
        )
{
    ULONG         code = 0;
    ATTCACHE      *pAC;
    WCHAR         *pwszRDN;
    DWORD         cb;
    DWORD         dnsErr;
    HVERIFY_ATTS  hVerifyAtts;

    // Use the new RDNs attrTyp and not the object's class rdnattid
    // because a superceding class may have a different rdnattid
    // than the superceded class in effect when this object was
    // created.
    pAC = SCGetAttById(pTHS, pNewRDN->attrTyp);
    if (!pAC) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_MISSING_REQUIRED_ATT);
    }

    // Replace the current RDN attribute with the new one.  Except, of
    // course, for auto-generated subrefs, which don't have their
    // class-specific RDN column set.  Auto-generated subrefs are
    // most easily detected by their object class:
    if (pResObj->MostSpecificObjClass != CLASS_TOP) {
        // not an auto-generated subref
        hVerifyAtts = VerifyAttsBegin(pTHS, pResObj->pObj, pResObj->NCDNT, NULL);

        __try {
            if (code = ReplaceAtt(pTHS,
                                  hVerifyAtts,
                                  pAC,
                                  &(pNewRDN->AttrVal),
                                  fCheckRDNConstraints)) {
                Assert(pTHS->errCode);
            }
        } __finally {
            VerifyAttsEnd(pTHS, &hVerifyAtts);
        }

        if (code) {
            return code;
        }
    }
    else {
        // We think this is a auto-gen subref, so it had better look like one.
        Assert(IT_NC_HEAD & pResObj->InstanceType || pTHS->fSingleUserModeThread );
    }

    // Reset the true RDN column (ATT_RDN)
    if(code = DBResetRDN(pTHS->pDB, pNewRDN->AttrVal.pAVal)) {
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             DIRERR_ILLEGAL_MOD_OPERATION,
                             code);
    }

    if(pNewParent) {
        // Drat, gotta change the parentage
        if(code = DBResetParent(pTHS->pDB, pNewParent, fAllowPhantomParent ? DBRESETPARENT_CreatePhantomParent : 0)) {
            return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                 DIRERR_ILLEGAL_MOD_OPERATION,
                                 code);
        }
    }

    // Validate site names - RAID 145341.
    // Validate subnet names - RAID 200090.
    Assert(pNewRDN->AttrVal.valCount < 2);
    if (    !pTHS->fDRA
         && fCheckRDNConstraints
         && (    (CLASS_SITE == pClassSch->ClassId)
              || (CLASS_SUBNET == pClassSch->ClassId) ) )
    {
        cb = pNewRDN->AttrVal.pAVal[0].valLen + sizeof(WCHAR);
        pwszRDN = (WCHAR *) THAllocEx(pTHS,cb);
        memcpy(pwszRDN,
               pNewRDN->AttrVal.pAVal[0].pVal,
               pNewRDN->AttrVal.pAVal[0].valLen);

        if (    (    (CLASS_SITE == pClassSch->ClassId)
                  && (    // Check for legal characters
                          (    (dnsErr = DnsValidateName_W(pwszRDN, DnsNameDomainLabel))
                            && (DNS_ERROR_NON_RFC_NAME != dnsErr) ) ) )
             || (    (CLASS_SUBNET == pClassSch->ClassId)
                  && (NO_ERROR != DsValidateSubnetNameW(pwszRDN)) ) )
        {
            THFreeEx(pTHS,pwszRDN);
            return SetNamError(NA_PROBLEM_BAD_NAME,
                               NULL,
                               DIRERR_BAD_NAME_SYNTAX);
        }
        THFreeEx(pTHS,pwszRDN);
    }

    // We are not allowed to change the name of any naming context,
    // so we don't need to worry about updating the NC name cache
    // in the anchor.

    return 0;
}

/*++
Description:
    Creates a new name for a deleted object based on the undeleted name.  This
    new name is unique among all objects.  We do this by creating a GUID,
    stringizing it, and adding a "bad" unicode character after it.  We also make
    sure that the name is unique by looking up the name in the directory and
    making sure it is not there.

    Locks the newly deleted name.

    Moves DB currency, but puts it back.

    Assumes that position is on pObject, and that pObject is a valid,
    'DBFindDSName'able object.

Arguments

    pObject - the undeleted name

    pDeletedName - space for the deleted name, must be big enough to hold an
       arbitrary DSNAME.

    pNewRDn - An allocated ATTR and ATTRVALBLOCK for holding the new RDN.  The
        val pointer will be THAlloc()'ed.

Return Vals:
    0 if all went well, an error otherwise.  If an error is returned, a
    Set???Error will already have been called.

--*/
int
MakeNameForDeleted(
        THSTATE *pTHS,
        DSNAME *pObject,
        DSNAME *pDeletedName,
        ULONG cbDeletedBuf,
        ATTR *pNewRDN
        )
{
    BOOL       fOK;
    unsigned   len = 0;
    GUID       guid;
    ULONG      dbError;
    ULONG      ReasonForLock;
    WCHAR      *pNewRDNVal;
    ATTRTYP     IgnoreRdnType;
    DSNAME     *pParentName = (DSNAME *) THAllocEx(pTHS, pObject->structLen);

    // Set up some values for the new RDN
    pNewRDN->AttrVal.valCount = 1;
    pNewRDN->AttrVal.pAVal->pVal = THAllocEx(pTHS, sizeof(WCHAR)*MAX_RDN_SIZE);
    pNewRDNVal = (WCHAR *) pNewRDN->AttrVal.pAVal->pVal;
    len = 0;

    fOK=FALSE;

    // Start setting up the new DN by copying all but the RDN of the
    // original object.
    TrimDSNameBy(pObject, 1, pParentName);

    // Retrieve the RDN of the old name. Ignore the rdnType returned
    // by GetRDNInfo. The rdnType stored in ATT_FIXED_RDN_TYPE is
    // used instead (set by the caller in pNewRDN->attrtyp).
    GetRDNInfo(pTHS, pObject, pNewRDNVal, &len, &IgnoreRdnType);

    // Get the object GUID.
    dbError = DBGetSingleValue(
                    pTHS->pDB,
                    ATT_OBJECT_GUID,
                    &guid,
                    sizeof( guid ),
                    NULL
                    );

    Assert(DB_ERR_NO_VALUE != dbError);

    if ( 0 != dbError ) {
        LogUnhandledError( DIRERR_MISSING_REQUIRED_ATT );
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_NO_DELETED_NAME, dbError );
    }

    // Mangle the RDN into the appropriate tombstone name.
    MangleRDN(MANGLE_OBJECT_RDN_FOR_DELETION, &guid, pNewRDNVal, &len);

    pNewRDN->AttrVal.pAVal->valLen = len * sizeof(WCHAR);

    // Now append the new RDN.
    if (AppendRDN(pParentName,
                  pDeletedName,
                  cbDeletedBuf,
                  pNewRDNVal,
                  len,
                  pNewRDN->attrTyp)) {
        LogUnhandledError(DIRERR_NO_DELETED_NAME);
        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_NO_DELETED_NAME);
    }

    // See if we can lock this new name and if we fail to find it already in
    // the dit.  Note that we don't attempt to lock the deleted name if it's
    // the same as the object name (as occurs during replication of a
    // tombstone), as the object name has already been locked by LocalRemove().
    // Also we don't lock the dn if the tree above is locked, since it will be
    // locked during tree delete
    if ( NameMatched(pObject, pDeletedName) )
    {
        fOK = TRUE;
    }
    else
    {
        ReasonForLock = DBLockDN(pTHS->pDB, 0, pDeletedName);
        if (  (ReasonForLock == 0)
           || (ReasonForLock & DB_LOCK_DN_CONFLICT_TREE_ABOVE) )
        {
            if ( DIRERR_OBJ_NOT_FOUND == DBFindDSName(pTHS->pDB, pDeletedName) )
            {
                fOK = TRUE;
            }
        }
    }

    THFreeEx(pTHS,pParentName);

    if(!fOK) {
        // Couldn't come up with a decent name.
        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_NO_DELETED_NAME);
    }

    // Copy over GUID for DN comparisons.
    memcpy(&pDeletedName->Guid, &guid, sizeof(GUID));

    // Ok, set currency back to the correct object
    DBFindDSName(pTHS->pDB, pObject);

    return 0;
}

/*++ DelAutoSubRef
 *
 * If appropriate, removes an automatically generated subref object
 *
 * INPUT
 *   pCR - name of cross ref object being deleted
 * RETURN VALUE
 *   non-zero on error
 */
int DelAutoSubRef(DSNAME *pCR)
{
    THSTATE *pTHS = pTHStls;
    int err;
    DSNAME *pNC = 0;
    int it = 0;
    DBPOS *pDB, *pDBSave;
    ULONG len;
    REMOVEARG removeArg;
    BOOL fDSASave;
    BOOL fCommit = FALSE;

    memset( &removeArg, 0, sizeof( removeArg ) );

    fDSASave = pTHS->fDSA;
    pDBSave = pTHS->pDB;
    DBOpen(&pDB);
    pTHS->pDB = pDB;
    __try {
        if (err = DBFindDSName(pDB, pCR)) {
            /* couldn't find the CR?  bogus  It's got to be there */
            SetSvcErrorEx(SV_PROBLEM_UNABLE_TO_PROCEED,
                          DIRERR_OBJ_NOT_FOUND,
                          err);
            __leave;
        }
        if (err = DBGetAttVal(pDB, 1, ATT_NC_NAME, 0, 0, &len, (UCHAR**)&pNC)) {
            // Required attribute must be present
            SetAttError( pCR, ATT_NC_NAME, PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL, err );
            __leave;
        }

        if (err = DBFindDSName(pDB, pNC)) {
            if (err == DIRERR_NOT_AN_OBJECT) {
                GUID phantomGuid;
                err = DBGetSingleValue(pDB, ATT_OBJECT_GUID, &phantomGuid,
                                       sizeof(phantomGuid), NULL);
                if (err == DB_ERR_NO_VALUE) {
                    memset( &phantomGuid, 0, sizeof(GUID) );
                    err = 0;
                } else if (err) {
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
                    __leave;
                }

                LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_DEL_AUTO_SUBREF,
                          szInsertDN(pCR),
                          szInsertDN(pNC),
                          szInsertUUID(&(pNC->Guid)),
                          szInsertUUID( &phantomGuid ),
                          NULL, NULL, NULL, NULL);
            } else {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
            }
            /* not there? nothing to delete! */
            __leave;
        }
        removeArg.pResObj = CreateResObj(pDB, pNC);
        if (!removeArg.pResObj) {
            /*Couldn't create a resobj when we're on the object? Bogus */
            err = 1;
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        DIRERR_OBJ_NOT_FOUND);
            __leave;
        }
        it = removeArg.pResObj->InstanceType;


        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DEL_AUTO_SUBREF,
                  szInsertDN(pCR),
                  szInsertDN(pNC),
                  szInsertUUID(&(pNC->Guid)),
                  szInsertUL( it ),
                  NULL, NULL, NULL, NULL);

        if (it == SUBREF) {
            removeArg.pObject = pNC;
            Assert( !fNullUuid(&pNC->Guid) ); // SUBREFs now always have GUIDS
            removeArg.fPreserveRDN = FALSE;
            pTHS->fDSA = TRUE;

            err = LocalRemove(pTHS, &removeArg);
            if (!err) {
                CheckNCRootNameOwnership( pTHS, pNC );

                LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_DRA_DELETE_NC_ROOT,
                          szInsertDN(pNC),
                          szInsertUUID(&(pNC->Guid)),
                          szInsertUL(FALSE),
                          szInsertUL(FALSE),
                          szInsertHex(DSID(FILENO,__LINE__)),
                          NULL, NULL, NULL);
            }
        }
        else if (it & IT_NC_ABOVE) {
            // We're removing a cross-ref for which we locally have an
            // instantiated NC with an NC above it.  This typically happens
            // when a domain is removed from the enterprise and this is a GC.
            //
            // In this case we want to remove the NC from the parent NC's
            // SUBREF list to prevent referrals from being generated for the
            // NC whose cross-ref is being deleted.  (A live cross-ref is
            // required to generate a referral.)  The KCC will come along later
            // to remove the NC.

            err = DelSubFromNC(pTHS, pNC, DSID(FILENO,__LINE__));
            Assert(!err || pTHS->errCode);
        }
        fCommit = (0 == err);
    }
    __finally {
        DBClose(pDB, fCommit);
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASave;
    }
    if (pNC)
      THFreeEx(pTHS, pNC);
    if (removeArg.pResObj)
      THFreeEx(pTHS, removeArg.pResObj);

    return err;
}

/*++
  IMPORTANT NOTE!!!!! This routine violates the normal transaction rules of the
  various LocalFoo routines, hence the name "Private".  It expects to be called
  inside a SYNC_TRANS_READ.  Furthermore, IT DOES THE CLEAN_BEFORE_RETURN
  itself!! Don't call this routine unless you can handle that!!!  After closing
  the transaction it was in when it was called, it may call DirRemove, which
  opens and closes transactions that are completely separate.  No matter what,
  when you leave this routine, you are one transaction level lower than you were
  when you called.

Routine Description
    Remove a sub tree from the directory.  Finds all children of the root of the
    delete first (or as many as will fit in memory) via DBLayer call, the calls
    DirRemoveEntry on them.

    NOTE that if not all children fit in memory, we will delete children from
    the bottom up, but we make no guarantees about which children are reoved.

    NOTE that we return an error if we didn't finish the whole tree, even though
    we may have committed deletions.  Yes, this does somewhat violate the normal
    transaction model.

    Passes the pRemoveArg on to DirRemoveEntry, but turns off the TreeDelete
    flag.

Arguments
   pTHS - Threadstate pointer

   pRemoveArg - REMOVEARG structure containing the name of the object to remove.

 --*/

int
PrivateLocalRemoveTree (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        )
{
    ULONG       cNamesMax, iLastName, i;
    PDSNAME     *pNames;
    REMOVEARG   SingleRemoveArg;
    REMOVERES  *pSingleRemoveRes;
    BOOL        bWholeTree;
    BOOL        fWrapped;
    CLASSCACHE *pClassSch = NULL;
    BOOL        fLockedDN = FALSE;
    ATTRBLOCK  *pObjB=NULL;
    DWORD       rtn;
    PDSNAME     pParent;
    BOOL        fPassedSec = FALSE;

    DPRINT(1,"LocalRemove entered\n");

    __try {
        // Now, do a security check.
        pClassSch = SCGetClassById(pTHS,
                                   pRemoveArg->pResObj->MostSpecificObjClass);
        Assert(pClassSch);

        if (CheckRemoveSecurity(
                TRUE,
                pClassSch,
                pRemoveArg->pResObj)) {

            __leave;
        }

        // We are located on the root of the deletion.  The first step is to
        // lock the tree.
        if (rtn = DBLockDN(pTHS->pDB,
                           (DB_LOCK_DN_WHOLE_TREE | DB_LOCK_DN_STICKY),
                           pRemoveArg->pResObj->pObj)) {
            // Someone's trying to muck with this object (primarily adding
            // children)
            SetSvcErrorEx(SV_PROBLEM_BUSY,
                          ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE,
                          rtn);
            __leave;
        }

        fLockedDN = TRUE;

        // Final preliminary: make sure there are no NC's beneath us.
        if(DSNameToBlockName(pTHS,
                             pRemoveArg->pResObj->pObj,
                             &pObjB,
                             DN2BN_LOWER_CASE)) {
            SetNamError(NA_PROBLEM_BAD_NAME,
                        pRemoveArg->pObject,
                        DIRERR_BAD_NAME_SYNTAX);
            __leave;
        }
        if (fHasDescendantNC(pTHS, pObjB, &pRemoveArg->CommArg)) {
            // Whoops, there is an NC beneath us. Bail
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_NO_TREE_DELETE_ABOVE_NC);
            FreeBlockName(pObjB);
            __leave;
        }

        // we don't need this anymore...
        FreeBlockName(pObjB);

        // OK, now build an array of objects to delete.  The array holds objects
        // in depth first traversal order.
        if(rtn = DBGetDepthFirstChildren(pTHS->pDB, &pNames, &iLastName,
                                         &cNamesMax, &fWrapped, FALSE)) {
            // Failed to get the children.
            SetSvcErrorEx(SV_PROBLEM_UNABLE_TO_PROCEED,
                          ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE,
                          rtn);
            __leave;
        }
    }
    __finally {
        if(fLockedDN && (AbnormalTermination() || pTHS->errCode)) {
            // we either excepted or errored out. We are not going to
            // go into the second try, so unlock the dn now.
            DBUnlockStickyDN (pRemoveArg->pResObj->pObj);
        }

        // This routine needs to leave it's transaction, as DirRemoveTree
        // expects it.
        CLEAN_BEFORE_RETURN (pTHS->errCode);
    }

    if (pTHS->errCode) {
        // we did not have permission, or were not able to lock DN
        // or to get children. So, we can not continue.
        return pTHS->errCode;
    }

    __try {
        // Before we start, see if the whole tree is being deleted.
        // If it is AND we successfully delete all the objects in the
        // list, then we succeeded in deleting the tree.
        //
        // The whole tree is being deleted if the array didn't
        // wrap or if the array wrapped but didn't overwrite
        // the first entry containing the root of tree.
        //
        // The latter is found by checking that the wrapped
        // array may not have overwrite the first entry
        // (iLastName == 0) and that the first entry contains the
        // root of the tree. The check for the root of the tree is
        // needed because the array may have wrapped more than once,
        // meaning iLastName may be 0 but the first entry was still
        // overwritten.
        if (!fWrapped
            || ((0 == iLastName)
                && NameMatched(pRemoveArg->pObject, pNames[0]))) {
            bWholeTree = TRUE;
        } else {
            bWholeTree = FALSE;
        }

        // set deleting tree flag so that only audits are generated (no actual security checks)
        pTHS->fDeletingTree = TRUE;
        __try {
            memset(&SingleRemoveArg, 0, sizeof(REMOVEARG));
            SingleRemoveArg.CommArg = pRemoveArg->CommArg;
            SingleRemoveArg.fDontDelCriticalObj = TRUE;
            i = iLastName;
            while(!pTHS->errCode) {
                // OK, loop through the objects, calling DirRemove on them

                if (0 == i) {
                    if (fWrapped) {
                        // need to wrap around
                        i = cNamesMax;
                    } else {
                        // last entry (first in the array) was deleted, done.
                        break;
                    }
                }
                i--;

                // Lazy commit all deletes except for the last one (the
                // root node) when an "all done" status is returned to
                // the user and the user can reasonably expect that the
                // deleted objects will not reappear after an unexpected
                // shutdown.
                if ((i == 0) && bWholeTree) {
                    SingleRemoveArg.CommArg.fLazyCommit = pRemoveArg->CommArg.fLazyCommit;
                } else {
                    SingleRemoveArg.CommArg.fLazyCommit = TRUE;
                }

                SingleRemoveArg.pObject = pNames[i];
                DirRemoveEntry(&SingleRemoveArg, &pSingleRemoveRes );

                THFreeEx(pTHS, pNames[i]);
                THFreeEx(pTHS, pSingleRemoveRes);
                THFreeEx(pTHS, SingleRemoveArg.pResObj);
                pSingleRemoveRes = NULL;

                if (fWrapped && (i == iLastName)) {
                    // ok, last entry was deleted, done.
                    break;
                }
            }
        }
        __finally {
            pTHS->fDeletingTree = FALSE;
        }
    }
    __finally {
        if(fLockedDN) {
            DBUnlockStickyDN (pRemoveArg->pResObj->pObj);
        }
    }

    if(!pTHS->errCode && !bWholeTree) {
        // We finished off the deletions we knew about, but we didn't delete the
        // root of the tree.
        SetSvcErrorEx(SV_PROBLEM_ADMIN_LIMIT_EXCEEDED,
                      DIRERR_TREE_DELETE_NOT_FINISHED,
                      pTHS->errCode);
    }

    return pTHS->errCode;
}

/*++ DirProtectEntry
 *
 * This routine, callable only by in-process clients, registers an object as
 * being undeletable on this DSA.  The registration lasts only for the current
 * boot cycle (i.e., it must be renewed each time the DSA starts), and is
 * effective only on this DSA.  That is, these objects can still be deleted
 * on other DSAs in the enterprise, but when that deletion replicates to this
 * server it will be rejected and the object re-animated.
 *
 * Note that the ancestors of the protected object are also protected. The ancestors
 * are automatically recalculated if the protected object is moved.
 *
 * INPUT:
 *   pObj - name of object to be protected from deletion
 * RETURN VALUE:
 *   0 on success, error in pTHS->errCode if the object could not be found
 */
ULONG
DirProtectEntry(DSNAME *pObj)
{
    THSTATE *pTHS;
    COMMARG CommArg;
    COMMRES CommRes;
    RESOBJ  *pResObj;
    ULONG   *pDNTs, *pOld;
    unsigned i;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    ULONG UnDelAncNum, *pUnDelAncDNTs, *pOldUnDelAncDNTs = NULL;

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));

    __try {

        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

        SYNC_TRANS_READ();

        __try {
            InitCommarg(&CommArg);
            // We can't protect what we can't write, so no copies allowed
            CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               0,
                               pObj,
                               &CommArg,
                               &CommRes,
                               &pResObj)) {
                // Got the object, so add it
                pOld = NULL;
                EnterCriticalSection(&gAnchor.CSUpdate);
                __try {
                    pDNTs = malloc((gAnchor.UnDeletableNum + 1) * sizeof(ULONG));
                    if (!pDNTs) {
                        SetSysError(ENOMEM, ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    for (i=0; i< gAnchor.UnDeletableNum; i++) {
                        if (gAnchor.pUnDeletableDNTs[i] == pResObj->DNT) {
                            // Already present
                            pOld = pDNTs;
                            __leave;
                        }
                        else {
                            pDNTs[i] = gAnchor.pUnDeletableDNTs[i];
                        }
                    }
                    pDNTs[gAnchor.UnDeletableNum] = pResObj->DNT;

                    // Update anchor atomically
                    pOld = gAnchor.pUnDeletableDNTs;
                    gAnchor.pUnDeletableDNTs = pDNTs;
                    gAnchor.UnDeletableNum++;

                    // Update undeletable ancestors
                    if (ERROR_SUCCESS ==
                        MakeProtectedAncList( gAnchor.pUnDeletableDNTs,
                                              gAnchor.UnDeletableNum,
                                              &pUnDelAncDNTs,
                                              &UnDelAncNum )) {

                        pOldUnDelAncDNTs = gAnchor.pUnDelAncDNTs;

                        // Order updates against other readers
                        if (gAnchor.UnDelAncNum <= UnDelAncNum) {
                            gAnchor.pUnDelAncDNTs = pUnDelAncDNTs;
                            gAnchor.UnDelAncNum = UnDelAncNum;
                        }
                        else {
                            gAnchor.UnDelAncNum = UnDelAncNum;
                            gAnchor.pUnDelAncDNTs = pUnDelAncDNTs;
                        }
                        pUnDelAncDNTs = NULL;
                    }
                }
                __finally {
                    LeaveCriticalSection(&gAnchor.CSUpdate);
                }
                if (pOld) {
                    DELAYED_FREE(pOld);
                }
                if (pOldUnDelAncDNTs) {
                    DELAYED_FREE(pOldUnDelAncDNTs);
                }
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    return pTHS->errCode;
}

DWORD
PossiblyMoveDeletedObject (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        )
/*++
  Description:
      Check to see if any of the exceptions to moving are found.  If not,
      move a deleted object to the deleted object container for the NC it's in.
      Note that if no deleted container is found, this is a no-op.  Further, the
      dblayer routine we call here DOES NOT QUEUE an SD propagation.  This is OK
      since we've already verified that this object has no children, and we've
      already written the default SD.  The dblayer routine fixes the ancestry,
      though.

    NOTE: in the case where we decide not to move the object, or no deleted
    objects container is found, we simply return 0 and do nothing.  We are just
    not moving the object and not returning an error.  We only return an error
    in the case where we decide to move the object, but the move fails.

--*/
{
    NAMING_CONTEXT_LIST *pNCL;
    DWORD dwDeletedContainerDNT;
    ULONG ulSysFlags;
    DWORD err;

    // First, check for the reasons we don't move based on the thread state.
    if(
       // Don't move objects if we're just replicating this deletion.  Only
       // originating deletions move objects
       pTHS->fDRA
       ) {
        return 0;
    }

    // Now, the reasons that we can check in the remove arg.
    if(
        // Don't move objects we're not renaming
          pRemoveArg->fPreserveRDN
        // Don't move NC heads.
       || (IT_NC_HEAD & pRemoveArg->pResObj->InstanceType)) {
        return 0;
    }


    // Finally, check the system flags.
    err = DBGetSingleValue(pTHS->pDB,
                           ATT_SYSTEM_FLAGS,
                           &ulSysFlags,
                           sizeof(ulSysFlags),
                           NULL);
    switch(err) {
    case 0:
        if (ulSysFlags & FLAG_DISALLOW_MOVE_ON_DELETE) {
            // Don't move this one.
            return 0;
        }
        break;

    case DB_ERR_NO_VALUE:
        // No system flags.  Allow the move.
        break;

    default:
        // Something wrong in getting the system flags.  Don't allow the move.
        return 0;
    }

    // OK, we think we can move this object.  See if we can find a destination
    // for the move. Find the deleted objects container for the NC this object
    // is in

    // We shouldn't be deleting things that move during cross domain move.
    // Assert this.
    Assert(!pTHS->fCrossDomainMove );

    pNCL = FindNCLFromNCDNT(pTHS->pDB->NCDNT, TRUE);
    if(pNCL) {
        dwDeletedContainerDNT = pNCL->DelContDNT;
    }
    else {
        dwDeletedContainerDNT = INVALIDDNT;
    }

    if(dwDeletedContainerDNT == INVALIDDNT) {
        // Couldn't find a deleted objects container.  Oh, well, we just don't
        // move this object.  No big deal.
        return 0;
    }

    if(err = DBResetParentByDNT(pTHS->pDB, dwDeletedContainerDNT, FALSE)) {
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             DIRERR_ILLEGAL_MOD_OPERATION,
                             err);
    }
    return 0;
}


/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_LinkVals(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount
    )
{
    DBPOS           *pDB;
    ULONG           ulCurrentTag  = 0; // initial key values or state information
    ULONG           ulCurrentValueTag  = 0; // initial key values or state information
    DSTIME          tCurrentTime = 0; // for  DBGetNextDelRecord
    ULONG           err;
    ULONG           dwException, ulErrorCode, dsid;
    PVOID           dwEA;

    DBOpen(&pDB);
    __try {

        //
        // Garbage collect absent values that have expired
        //

        tCurrentTime = 0;
        ulCurrentTag = 0;
        ulCurrentValueTag = 0;

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        while ((!DBGetNextDelLinkVal(pDB,
                                     AgeOutDate,
                                     &tCurrentTime,
                                     &ulCurrentTag,
                                     &ulCurrentValueTag )) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE))
        {
            err = 1;               // in case of exception

            if (err = DBPhysDelLinkVal(pDB, ulCurrentTag, ulCurrentValueTag)) {
                DPRINT( 1, "Failed physically removing value.\n" );

                dsid = 0;
            }

            // TODO: Flush the transaction every 100 values instead of each time
            __try {
                DBTransOut(pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = ulErrorCode;
                Assert(err);
            }
            DBTransIn(pDB);

            if (0 == err) {
                DPRINT(4,"Physically removed value successfully\n");

                // If we have succesfully removed an object, update
                // the success count

                (*pulSuccessCount)++;

                LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                         DS_EVENT_SEV_BASIC,
                         DIRLOG_GC_REMOVED_OBJECT_VALUE,
                         szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentValueTag ) ),
                         szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentTag ) ),
                         NULL);
            }
            else {
                (*pulFailureCount)++;

                LogEvent8(DS_EVENT_CAT_GARBAGE_COLLECTION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_GC_FAILED_TO_REMOVE_OBJECT_VALUE,
                          szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentValueTag ) ),
                          szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentTag ) ),
                          szInsertInt(err),
                          szInsertUL(dsid),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL);
            }
        }
    }
    __finally
    {
        DBClose(pDB, !AbnormalTermination());
    }
}

/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_EntryTTL(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount,
    IN OUT ULONG    *pulNextSecs
    )
{
    DSNAME          *pDelObj = NULL;
    DBPOS           *pDB = NULL;
    ULONG           err;
    BOOL            fObject;
    ULONG           dwException, ulErrorCode, dsid = 0;
    PVOID           dwEA;
    ATTCACHE        *pAC;
    ULONG           ulNoDelDnt = INVALIDDNT;
    DSTIME          tNoDelTime;
    ULONG           Dnt;
    DSTIME          tCurrentTime = 0;

    DBOpen(&pDB);
    __try {
        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        pAC = SCGetAttById(pDB->pTHS, ATT_MS_DS_ENTRY_TIME_TO_DIE);
        if (!pAC) {
            DPRINT1(0, "SCGetAttById(msDS-Entry-Time-To-Die(= %08x); not found\n",
                    ATT_MS_DS_ENTRY_TIME_TO_DIE);
            __leave;
        }

        // Loop over all DNs of records to be removed; allow for service
        // shutdown and for undeletable records (ulNoDelDnt). Undeletable
        // records are skipped.

        while ((!DBGetNextEntryTTLRecord(pDB,
                                         AgeOutDate,
                                         pAC,
                                         ulNoDelDnt,
                                         &pDelObj,
                                         &tCurrentTime,
                                         &fObject,
                                         pulNextSecs)) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE)) {

            // Dnt of record (in case pDB->DNT is altered by subsequent calls)
            Dnt = pDB->DNT;

            // Assume no problems
            err = 0;

            // Critical object, skip it
            if (fObject && NoDelCriticalObjects(pDelObj, pDB->DNT)) {
                DPRINT( 1, "Failed removing critical object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Can't lock, skip it. Unlocked by DBTransOut
            else if (fObject && DBLockDN(pDB, DB_LOCK_DN_WHOLE_TREE, pDelObj)) {
                DPRINT( 1, "Failed locking object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Can't delete; skip it
            // Keep in mind that a successful return doesn't mean it was
            // actually deleted. If it has children, its time is simply
            // adjusted to its child's time + 1 so that it can be
            // successfully deleted later. However, DBPhysDel returns TRUE
            // in this case so that the transaction will be committed.
            else if (DBPhysDel(pDB, FALSE, pAC)) {
                DPRINT( 1, "Failed physically removing object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Are we skipping a previously undeletable record?
            else if (ulNoDelDnt != INVALIDDNT) {
                // If so, stop if we have moved past its expiration time
                if (tNoDelTime != tCurrentTime) {
                    ulNoDelDnt = INVALIDDNT;
                }
            }

            __try {
                DBTransOut(pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = (ulErrorCode) ? ulErrorCode : 1;
            }

            if (0 == err) {
                DPRINT(4,"Physically removed object successfully\n");
                if (fObject) {
                    (*pulSuccessCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_GC_REMOVED_OBJECT,
                             szInsertDN( pDelObj ),
                             NULL,
                             NULL);
                }
            }
            else {
                if (fObject) {
                    (*pulFailureCount)++;

                    LogEvent8(DS_EVENT_CAT_GARBAGE_COLLECTION,
                              DS_EVENT_SEV_BASIC,
                              DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                              szInsertDN( pDelObj ),
                              szInsertInt(err),
                              szInsertUL(dsid),
                              szInsertWin32Msg(err),
                              NULL, NULL, NULL, NULL );
                }
            }
            THFreeEx(pDB->pTHS, pDelObj);
            DBTransIn(pDB);
        }
    } __finally {
        DBClose(pDB, !AbnormalTermination());
    }
}

/*-------------------------------------------------------------------------*/

//  OPTIMISATION: We know that the secondary key is always a fixed length,
//  so we can allocate an appropriately-sized buffer.  Otherwise, we would
//  have to allocate a buffer sized to JET_cbSecondaryKeyMost.
//
#define cbDeltimeSecondaryKey       ( sizeof(DSTIME) + 1 )  //  +1 for key prefix byte


VOID
Garb_Collect_DelTime(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount
    )
{
    DSNAME              *pDelObj = NULL;
    THSTATE             *pTHS = pTHStls;
    ULONG               err;
    BOOL                fObject;
    ULONG               dwException, ulErrorCode, dsid;
    PVOID               dwEA;
    BYTE                rgbSecondaryKey[cbDeltimeSecondaryKey];
    BYTE                rgbPrimaryBookmark[cbDNTPrimaryKey];

    //  initialise to all zeroes to force initial JetGotoSecondaryIndexBookmark
    //  to go to BeforeFirst
    //
    memset( rgbSecondaryKey, 0, cbDeltimeSecondaryKey );
    memset( rgbPrimaryBookmark, 0, cbDNTPrimaryKey );
    // The reason we use pTHS->pDB here is that some of our called routines expect it
    Assert( !pTHS->pDB );
    DBOpen(&pTHS->pDB);
    __try {

        // Loop over all DNs of records to be removed; allow for service
        // shutdown

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        while ((!DBGetNextDelRecord(pTHS->pDB,
                                    AgeOutDate,
                                    &pDelObj,
                                    rgbSecondaryKey,
                                    cbDeltimeSecondaryKey,
                                    rgbPrimaryBookmark,
                                    cbDNTPrimaryKey,
                                    &fObject)) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE)) {

            err = 1;               // in case of exception
            dsid = 0;

            // A deleted object should have no backlinks
            Assert( !DBCheckObj(pTHS->pDB) ||
                    !DBHasLinks( pTHS->pDB, pTHS->pDB->DNT, FALSE /*backlinks*/ ) );

            err = DBPhysDel(pTHS->pDB, FALSE, NULL);
            if (err == ERROR_DS_CHILDREN_EXIST) {

                // Move children to lost and found prior to object removal
                // DBMakeCurrent is needed because pDB->NCDNT not set
                if ( (err = DBMakeCurrent(pTHS->pDB)) ||
                     (err = PrePhantomizeChildCleanup(pTHS, TRUE /*fChildrenAllowed*/)) )
                {
                    DPRINT(0,"Garbage Collection child cleanup failed\n" );
                    DbgPrintErrorInfo();
                    THClearErrors();
                }
            } else if (err) {
                DPRINT( 1, "Failed physically removing object.\n" );
            }

            __try {
                DBTransOut(pTHS->pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = ulErrorCode;
                Assert(err);
            }

            if (0 == err) {
                DPRINT(4,"Physically removed object successfully\n");

                // If we have succesfully removed an object, update
                // the success count

                if (fObject) {
                    (*pulSuccessCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_GC_REMOVED_OBJECT,
                             szInsertDN( pDelObj ),
                             NULL,
                             NULL);
                }
            }
            else {
                if (fObject) {
                    (*pulFailureCount)++;

                    LogEvent8(DS_EVENT_CAT_GARBAGE_COLLECTION,
                              DS_EVENT_SEV_BASIC,
                              DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                              szInsertDN( pDelObj ),
                              szInsertInt(err),
                              szInsertUL(dsid),
                              szInsertWin32Msg(err),
                              NULL, NULL, NULL, NULL);
                }
            }
            THFreeEx(pTHS, pDelObj);
            DBTransIn(pTHS->pDB);
        }
    }
    __finally
    {
        DBClose(pTHS->pDB, !AbnormalTermination());
    }
}

/*-------------------------------------------------------------------------*/
USHORT
Garb_Collect(
             DSTIME    AgeOutDate )
{
    ULONG   ulSuccessCount = 0;
    ULONG   ulFailureCount = 0;
    ULONG   ulNextSecs = 0;
    DBPOS   *pDB;
    ULONG   dwException, ulErrorCode, dsid;
    PVOID   dwEA;

    DPRINT( 1, "Garbage Collector entered\n" );

    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_GC_STARTED,
             NULL,
             NULL,
             NULL);

    __try {
        // collect deleted objects
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_DelTime(AgeOutDate,
                                 &ulSuccessCount,
                                 &ulFailureCount);
        }

        // collect link vals
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_LinkVals(AgeOutDate,
                                 &ulSuccessCount,
                                 &ulFailureCount);
        }

        // collect expired dynamic objects (EntryTTL)
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_EntryTTL(DBTime(),
                                  &ulSuccessCount,
                                  &ulFailureCount,
                                  &ulNextSecs);
        }

        // Defrag
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            DBOpen(&pDB);
            __try {
                if (!eServiceShutdown) {
                    if (!gulDecoupleDefragFromGarbageCollection) {
                        DBDefrag(pDB, -1);
                    }
                    else {
                        // it is specified in the dsa heuristic
                        // that the defrag is detached from GC.
                        // We will log the free space anyway.
                        unsigned long ulFreeMB, ulAllocMB;
                        if (DBGetFreeSpace(pDB, &ulFreeMB, &ulAllocMB) == 0) {
                            // Log the event for free vs. allocated space
                            LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                                     DS_EVENT_SEV_MINIMAL,
                                     DIRLOG_DB_FREE_SPACE,
                                     szInsertUL(ulFreeMB),
                                     szInsertUL(ulAllocMB),
                                     NULL);
                        }
                    }

                }
            } __finally {
                DBClose( pDB, TRUE);
            }
        }
    } __except(GetExceptionData(GetExceptionInformation(),
                                &dwException,
                                &dwEA,
                                &ulErrorCode,
                                &dsid)) {
        DPRINT3(0, "Garb_Collect() EXCEPTION: %08x (%d) ulErrorCode; %08x dsid\n",
               ulErrorCode, ulErrorCode, dsid);
    }

    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_GC_COMPLETED,
             szInsertUL(ulSuccessCount),
             szInsertUL(ulFailureCount),
             NULL);

    DPRINT( 1, "Garbage Collector returning.\n");
    return (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdfind.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdfind.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirGetDomainHandle and DirFindEntry APIs.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                   // schema cache
#include <prefix.h>                   // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                 // MD global definition header
#include <mdlocal.h>                  // MD local definition header
#include <dsatools.h>                 // needed for output allocation
#include <samsrvp.h>                  // to support CLEAN_FOR_RETURN()
#include <sdprop.h>                   // Critical section for adds.
#include <gcverify.h>                 // GC DSNAME verification

// SAM interoperability headers
#include <mappings.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                  // header Audit\Alert logging
#include "mdcodes.h"                  // header for error codes

// Assorted DSA headers.
#include "objids.h"                   // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "drautil.h"
#include "debug.h"                    // standard debugging header
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#include "filtypes.h"
#define DEBSUB "MDFIND:"              // define the subsystem for debugging

// MD layer headers.
#include "drserr.h"

#include <fileno.h>
#define  FILENO FILENO_MDFIND

BOOL
dbEvalInt (
        DBPOS FAR *pDB,
        BOOL fUseSearchTbl,
        UCHAR Operation,
        ATTRTYP type,
        ULONG valLenFilter,
        UCHAR *pValFilter,
        BOOL *pbSkip
        );

 DWORD
CheckAndReturnObject(
    FINDARG *pFindArg,
    FINDRES *pFindRes,
    BOOL     fCheckValue,
    ATTRVAL *pIntVal,        
    DWORD   *pFoundDNT
    );



/*++
 *  Given an attribute value and a domain handle (i.e., an NCDNT), this
 *  routine returns the DSNAME of the one object in that domain for which
 *  that AVA is true.  Returns a simple error code if no such object exists
 *  or if multiple such objects do.
 *
 *  NOTE: This routine does not enforce security in any way, shape, or form,
 *        and is not to be called by any out-of-process callers.
 */
ULONG
DirFindEntry(FINDARG  * pFindArg,
             FINDRES ** ppFindRes)
{
    THSTATE*        pTHS;
    FINDRES *       pFindRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(2,"DirFindEntry entered\n");

    // Initialize the THSTATE anchor and set a read sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppFindRes = pFindRes = NULL;

    Assert(pTHS->fDSA || pTHS->fSAM || pTHS->fDRA);
    
    if (eServiceShutdown) {
        ErrorOnShutdown();
        return pTHS->errCode;
    }

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppFindRes = pFindRes = THAllocEx(pTHS, sizeof(FINDRES));
        if (pTHS->errCode) {
            __leave;
        }

        SYNC_TRANS_READ();       /* Set Sync point*/
        __try {
            LocalFind(pFindArg, pFindRes);
        }
        __finally {
            CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction

        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                  &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pFindRes) {
        pFindRes->CommRes.errCode = pTHS->errCode;
        pFindRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

} /*DirFindEntry*/

/*++ 
 *  Given an attribute value and a domain handle (i.e., an NCDNT), this
 *  routine returns the DSNAME of the one object in that domain for which
 *  that AVA is true.  Returns a simple error code if no such object exists
 *  or if multiple such objects do.
 *
 *  NOTE: This routine does not enforce security in any way, shape, or form,
 *        and is not to be called by any out-of-process callers.
 */
int
LocalFind(FINDARG *pFindArg,
          FINDRES *pFindRes)
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE *pAC;
    DWORD err=0;
    INDEX_VALUE IV;
    ULONG len;
    DWORD FoundDNT = INVALIDDNT;
    ATTRVAL IntVal;
    BOOL     fCheckValue;
    DWORD    cbKey=0;

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_FIND,
                     EVENT_TRACE_TYPE_START,
                     DsGuidFind,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertHex(pFindArg->AttId),
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pAC = SCGetAttById(pTHS, pFindArg->AttId);
    if (!pAC || !(pAC->fSearchFlags & fATTINDEX)) {
        SetAttError(gpRootDN,
                    pFindArg->AttId,
                    (USHORT)(pAC
                             ? PR_PROBLEM_WRONG_MATCH_OPER
                             : PR_PROBLEM_UNDEFINED_ATT_TYPE),
                    NULL,
                    DIRERR_GENERIC_ERROR);
        goto exit;
    }

    // Convert the given arg to internal value

    err = MakeInternalValue(pTHS->pDB,
                      pAC->syntax,
                      &pFindArg->AttrVal,
                      &IntVal);

    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }

    err = DBSetCurrentIndex(pTHS->pDB,
                            0,
                            pAC,
                            FALSE);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }

    IV.pvData = IntVal.pVal;
    IV.cbData = IntVal.valLen;
    err = DBSeek(pTHS->pDB,
                 &IV,
                 1,
                 DB_SeekEQ);
    if (err) {
        // No matches
        SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                      NULL,
                      DIRERR_UNKNOWN_ERROR,
                      err); 
        goto exit;
    }
    
    //
    // See if the key was too long.  If it was, then check and return objects
    // must also verify the value of the attribute we're searching on, in
    // addition to the rest of the checks it does.
    //
    
    DBGetKeyFromObjTable(pTHS->pDB, NULL, &cbKey);
    fCheckValue = (cbKey >= DB_CB_MAX_KEY);


    // Set an index range over the given value as we might need to
    // either iterate over the object or move one step further to
    // check for duplicates.

    err = DBSetIndexRange(pTHS->pDB,
                          &IV,
                          1);
    if (err) {
        SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                      NULL,
                      DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }

    while (0==err) {

        err = CheckAndReturnObject(pFindArg,
                                   pFindRes,
                                   fCheckValue,
                                   &IntVal,
                                   &FoundDNT);

        if (err)
        {
            // Some other error occured. 
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
            goto exit;
        }

        err = DBMove(pTHS->pDB, 
                     FALSE,
                     1);
    }

    if (FoundDNT == INVALIDDNT) {
       // Uh, oh.  We're out of candidates.
       SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                     NULL,
                     DIRERR_UNKNOWN_ERROR,
                     err);
       goto exit;
    }

    Assert(pTHS->errCode == 0);

exit:
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_FIND,
                     EVENT_TRACE_TYPE_END,
                     DsGuidFind,
                     szInsertUL(pTHS->errCode), 
                     NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;
}

/*++
 *  This routine will perform the following operations
 *  0. Check if the currently positioned record is an object
 *  1. Check if the currently positioned object is in the right NC
 *  2. Check if the currently positioned object is not deleted
 *     If any of the above fail, return success without setting pFoundDNT
 *  3. Check if no other object has been found before, if so fail
 *  4. If told to, check that the value looked up is equal to the value found.
 *     This solves problems with truncated jet keys.
 *  5. If all is well, retrieve the DSName of the object, set pFoundDNT to the
 *     DNT we found. return a success 
 *  This routine is called by LocalFind, after LocalFind thinks that
 *  it has positioned on an object. 
--*/
DWORD
CheckAndReturnObject(
    FINDARG *pFindArg,
    FINDRES *pFindRes,
    BOOL     fCheckValue,
    ATTRVAL *pIntVal,        
    DWORD   *pFoundDNT
    )
{
    THSTATE *pTHS=pTHStls;
    ULONG   isdel;
    ULONG   len;
    ULONG   err=0;
    DWORD   DNT;

    if (!DBCheckObj(pTHS->pDB)) {
        // This is a phantom, we are looking for an object
        return 0;
    }

    // We are positioned on an object at this time


    // Is it in the right NC ?
    if (pTHS->pDB->NCDNT != pFindArg->hDomain) {

        //Nope, do not touch the state of pFoundDNT
        return 0;
    }

    // Check wether it is deleted
    err = DBGetSingleValue(pTHS->pDB,
                   ATT_IS_DELETED,
                   &isdel,
                   sizeof(isdel),
                   NULL);
    if (err) {
        if (DB_ERR_NO_VALUE == err) {
            // Treat having no value the same as being false.
            isdel = 0;
            err = 0;
        }
        else {
            // I don't know what happened, but it isn't good.
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
            return pTHS->errCode;
        }
    }

    if (0!=isdel) {
       // object is deleted. Return without touch pFoundDNT
       return 0;
    }

    // Good! object is not deleted.  Get it's DNT
    DBGetSingleValue(pTHS->pDB,
                     FIXED_ATT_DNT,
                     &DNT,
                     sizeof(DNT),
                     NULL);

    
    if(fCheckValue && (DNT != *pFoundDNT)) {
        // Need to check that the value is actually a match.
        if(eTRUE != dbEvalInt(pTHS->pDB,
                              FALSE,
                              FI_CHOICE_EQUALITY,
                              pFindArg->AttId,
                              pIntVal->valLen,
                              pIntVal->pVal,
                              NULL)) {
            // Not really a match
            return 0;
        }
    }


    // Have we found an object before ?
    if ((*pFoundDNT != INVALIDDNT) && (*pFoundDNT != DNT)) {
        // this is a duplicate !
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        return pTHS->errCode;
    }
    
    // O.K get the DSNAME and set pFoundDNT to the DNT we've found.
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_OBJ_DIST_NAME,
                      pFindArg->fShortNames?DBGETATTVAL_fSHORTNAME:0,
                      0,
                      &len,
                      (UCHAR**)&pFindRes->pObject);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        return pTHS->errCode;
    }

    *pFoundDNT=DNT;

    return(0);
}



/*++
 *  This routine returns a "domain handle" for the specified domain, as needed
 *  by clients of DirFindEntry.  The domain handle is actually just the DNT 
 *  of the NC head, which is therefore the NCDNT of objects in that domain/NC.
 *  We verify that the name passed in is indeed the name of an NC head, but
 *  not that it is the name of a domain (as opposed to being the name of a
 *  non-domain NC, such as the schema NC).
 *
 *  INPUT:
 *     pDomainDN  - pointer to DSNAME of domain for which handle is desired
 *  RETURN VALUE
 *     non-0      - domain handle
 *     0          - name was not that of a domain
 */
DWORD DirGetDomainHandle(DSNAME *pDomainDN)
{
    THSTATE*        pTHS;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    DWORD err, it;
    DWORD handle = 0;


    // Initialize the THSTATE anchor and set a read sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));

    __try {
        SYNC_TRANS_READ();       /* Set Sync point*/
        __try {
            err = DBFindDSName(pTHS->pDB,
                               pDomainDN);
            if (err) {
                __leave;
            }
            err = DBGetSingleValue(pTHS->pDB,
                                   ATT_INSTANCE_TYPE,
                                   &it,
                                   sizeof(it),
                                   NULL);
            if (!err &&
                (it & IT_NC_HEAD)) {
                handle = pTHS->pDB->DNT;
            }
        }
        __finally {

            CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction

        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    return handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mddit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mddit.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Implements functions that manipulate the DIT structure of DS information.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <winsock.h>                    // for ntohl/htonl

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

#include <nlwrap.h>                     // for dsI_NetNotifyDsChange()

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "drs.h"
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "drancrep.h"
#include "drautil.h"
#include "quota.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "MDDIT:"                 // define the subsystem for debugging

// MD layer headers.
#include "drserr.h"

#include "drameta.h"

#include <fileno.h>
#define  FILENO FILENO_MDDIT

/* MACROS */
#define IS_INSTALL_DSA_DSNAME(x) \
    ( ((x)->NameLen == 0 && !fNullUuid(&((x)->Guid)) ) || \
      ((((x)->NameLen * sizeof(WCHAR)) \
        == sizeof(L"CN=BootMachine,O=Boot") - sizeof(WCHAR)) \
       && (0 == memcmp(L"CN=BootMachine,O=Boot", \
                       (x)->StringName, \
                       (x)->NameLen * sizeof(WCHAR)))) )


/* local prototypes */

//
// Has-InstantiatedNCs utils
//
DWORD
Dbg_ValidateInstantiatedNCs(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB
    );

#if DBG
#define ValidateInstantiatedNCs(x, y) Dbg_ValidateInstantiatedNCs(x,y)
#else
#define ValidateInstantiatedNCs(x, y)
#endif


/* Internal functions */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int APIENTRY
AddNCToDSA(
    THSTATE    *            pTHS,
    IN  ATTRTYP             listType,
    IN  DSNAME *            pDN,
    IN  SYNTAX_INTEGER      iType
    )
/*++

Routine Description:

    Add an NC name to the list of NCs in the given attribute of the local DSA
    object.

Arguments:

    listType (IN) - The attribute containing the list; one of
        ATT_MS_DS_HAS_MASTER_NCS or ATT_HAS_PARTIAL_REPLICA_NCS.

    pDN (IN) - The NC to add.

    iType (IN) - Instance type of added NC

Return Values:

    THSTATE error code.

--*/
{
    DBPOS *     pDBCat;
    DWORD       rtn;
    BOOL        fCommit = FALSE;
    ATTCACHE *  pAC;

    DPRINT(1, "AddNCToDSA entered\n");

    Assert((ATT_MS_DS_HAS_MASTER_NCS == listType)
           || (ATT_HAS_PARTIAL_REPLICA_NCS == listType));

    DBOpen(&pDBCat);
    __try {
        // PREFIX: dereferencing uninitialized pointer 'pDBCat'
        //         DBOpen returns non-NULL pDBCat or throws an exception

        if (DsaIsInstalling()) {
            // We are trying to write to the distribution DIT machine
            // object.  That is a complete waste of time.  It doesn't matter
            // that we failed.
            Assert(IS_INSTALL_DSA_DSNAME(gAnchor.pDSADN)); // Note this might
            // fail someday, if someone fixes gAnchor.pDSADN to the real DN before
            // we finish install.
        } else if (FIND_ALIVE_FOUND == FindAliveDSName(pDBCat, gAnchor.pDSADN)) {
            // Find the DSA object.  If the object doesn't exist we are in trouble.

            pAC = SCGetAttById(pTHS, listType);
            Assert(NULL != pAC);

            if (rtn = DBAddAttVal_AC(pDBCat, pAC, pDN->structLen, pDN)) {
                // All problems are assumed to be temporary (record locks, etc).
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRLOG_DATABASE_ERROR, rtn);
                DBCancelRec(pDBCat);
                __leave;
            }

            // Add the NC to the list of Instanciated NCs
            rtn = AddInstantiatedNC(
                      pTHS,
                      pDBCat,
                      pDN,
                      iType);
            if ( ERROR_SUCCESS != rtn ) {
                Assert(!"Failed to add NC to ms-ds-Has-InstantiatedNCs");
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRLOG_DATABASE_ERROR, rtn);
                __leave;
            }

            if (rtn = DBRepl(pDBCat, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING)) {
                DPRINT(2, "Couldn't replace the DSA object...\n");

                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                        DS_EVENT_SEV_MINIMAL,
                        DIRLOG_DATABASE_ERROR,
                        szInsertWC(pDN->StringName),
                        NULL,
                        NULL);
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRLOG_DATABASE_ERROR, rtn);
                __leave;
            }
        } else {
            DPRINT(0, "***Couldn't locate the DSA object\n");

            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CANT_FIND_DSA_OBJ,
                     NULL,
                     NULL,
                     NULL);

            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRLOG_CANT_FIND_DSA_OBJ);
            __leave;
        }

        // Add the NC name to the appropriate in-memory list (if any).
        switch (listType) {
        case ATT_MS_DS_HAS_MASTER_NCS:
            AddNCToMem(CATALOG_MASTER_NC, pDN);
            break;
        case ATT_HAS_PARTIAL_REPLICA_NCS:
            AddNCToMem(CATALOG_REPLICA_NC, pDN);
            break;
        default:
            Assert(FALSE && "Code logic error!");
            break;
        }
        fCommit = TRUE;
    } __finally {
        fCommit &= !AbnormalTermination();
        DBClose(pDBCat, fCommit);
    }

    return pTHS->errCode;

}/*AddNCToDSA*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/


DWORD
AddInstantiatedNC(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pDN,
    IN  SYNTAX_INTEGER      iType
    )
/*++

Routine Description:

    Add the NC given by DN w/ instance type iType to the list of
    instantiated NCs on the ntdsDsa object pointed by pDBCat.
    If the NC exist w/ diff iType, replace current entry.

Arguments:

    pTHS -- thread state
    pDB -- DB cursor pointing at the ntdsDsa object
    pDN -- the DN of the NC we're going to add
    iType -- the instance type of that NC

Return Value:

    success: ERROS_SUCCESS
    error: error in Win32 error space

remarks:
    - raises exception on out of mem conditions.

--*/
{
    DWORD                       dwErr = ERROR_SUCCESS;
    ATTCACHE *                  pAC;
    SYNTAX_DISTNAME_BINARY *    pNC = NULL;
    SYNTAX_ADDRESS *            pData = NULL;
    DWORD                       len = 0;
    DWORD                       iVal = 0;
    DWORD                       cbVal = 0;
    PUCHAR                      pVal;
    BOOL                        fBool;
    LONG                        lStoredIT;

    DPRINT(1, "AddInstantiatedNC entered\n");

    //
    // Debug consistency validation
    //
    ValidateInstantiatedNCs(pTHS, pDB);

    // get AttCache
    pAC = SCGetAttById(pTHS, ATT_MS_DS_HAS_INSTANTIATED_NCS);
    Assert(NULL != pAC);


    //
    // Search for entry. If it's there, remove it first
    //
    while( !DBGetAttVal_AC(
                pDB, ++iVal, pAC,
                DBGETATTVAL_fREALLOC,
                len, &cbVal, &pVal) ) {

        // we got data in ATT_MS_DS_HAS_INSTANTIATED_NCS att.
        len = max(len,cbVal);
        pNC = (SYNTAX_DISTNAME_BINARY *)pVal;
        Assert(pNC);

        fBool = NameMatched( pDN, NAMEPTR(pNC) );
        if ( fBool ) {
            //
            // This NC is already there:
            //  - if instance type is diff --> remove the entry & add below
            //  - otherwise, it's the same, bailout, no-op.
            //

            lStoredIT = (LONG)ntohl(*(SYNTAX_INTEGER*)(DATAPTR(pNC)->byteVal));
            if ( lStoredIT != iType ) {
                // diff instance type, remove entry.
                DPRINT2(1, "Removing NC %S w/ instanceType %4x\n",
                            NAMEPTR(pNC)->StringName, lStoredIT);

                dwErr = DBRemAttVal_AC(
                            pDB,
                            pAC,
                            cbVal,
                            pVal);
                Assert(!dwErr);
                break;
            }
            else {
                // identical entries, no-op.
                DPRINT2(1, "Skipping addition of NC %S w/ InstanceType %4x\n",
                            NAMEPTR(pNC)->StringName, lStoredIT );

                dwErr = ERROR_SUCCESS;
                goto cleanup;
            }
        }
        // else the NC isn't there, continue searching.
    }

    if ( pNC ) {
        THFree( pNC );
        pNC = NULL;
    }

    //
    // Ready to add the NC. Build data & add to DB.
    //

    // build NC data

    // data portion
    len = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(SYNTAX_INTEGER));
    pData = THAllocEx(pTHS, len);
    pData->structLen = len;
    *((SYNTAX_INTEGER*) &(pData->byteVal)) = htonl((ULONG)iType);
    // whole binary distname
    len = DERIVE_NAME_DATA_SIZE( pDN, pData );
    pNC = THAllocEx(pTHS, len);
    BUILD_NAME_DATA( pNC, pDN, pData );

    //
    // add data to ntdsDsa object
    //
    DPRINT2(1, "Adding NC %S w/ InstanceType %4x\n",
                NAMEPTR(pNC)->StringName, *(SYNTAX_INTEGER*)(DATAPTR(pNC)->byteVal) );
    if (dwErr = DBAddAttVal_AC(pDB, pAC, len, pNC)) {
        // map error to DIRERR space
        dwErr = ERROR_DS_DATABASE_ERROR;
        DBCancelRec(pDB);
    }


cleanup:

    if ( pData ) {
        THFree(pData);
    }
    if ( pNC ) {
        THFree( pNC );
        pNC = NULL;
    }

    return dwErr;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
DWORD
RemoveInstantiatedNC(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pDN
    )
/*++

Routine Description:

    Remove the NC given by DN from the list of
    instantiated NCs on the ntdsDsa object pointed by pDBCat.

Arguments:

    pTHS -- thread state
    pDB -- DB cursor pointing at the ntdsDsa object
    pDN -- the DN of the NC we're going to add

Return Value:

    success: ERROS_SUCCESS, removed
    No-op (nothing to remove): ERROR_OBJECT_NOT_FOUND
    error: error in Win32 error space

remarks:
    - raises exception on out of mem conditions.

--*/
{
    DWORD                       dwErr = ERROR_OBJECT_NOT_FOUND;
    ATTCACHE *                  pAC;
    SYNTAX_DISTNAME_BINARY *    pNC = NULL;
    DWORD                       len = 0;
    DWORD                       iVal = 0;
    DWORD                       cbVal = 0;
    PUCHAR                      pVal;
    BOOL                        fBool;

    DPRINT(1, "RemoveInstantiatedNC entered\n");

    // get AttCache
    pAC = SCGetAttById(pTHS, ATT_MS_DS_HAS_INSTANTIATED_NCS);
    Assert(NULL != pAC);


    //
    // Search for entry. If it's there, remove it.
    //
    while( !DBGetAttVal_AC(
                pDB, ++iVal, pAC,
                DBGETATTVAL_fREALLOC,
                len, &cbVal, &pVal) ) {

        // we got data in ATT_MS_DS_HAS_INSTANTIATED_NCS att.
        len = max(len,cbVal);
        pNC = (SYNTAX_DISTNAME_BINARY *)pVal;
        Assert(pNC);

        fBool = NameMatched( pDN, NAMEPTR(pNC) );
        if ( fBool ) {
            //
            // This is the NC.
            //

            DPRINT2(1, "Removing NC %S w/ instanceType %4x\n",
                        NAMEPTR(pNC)->StringName, *(SYNTAX_INTEGER*)(DATAPTR(pNC)->byteVal) );
            dwErr = DBRemAttVal_AC(
                        pDB,
                        pAC,
                        cbVal,
                        pVal);
            Assert(!dwErr);
            break;
        }
        // else the NC isn't there, continue searching.
    }

    if ( pNC ) {
        THFree( pNC );
    }

    return dwErr;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

DWORD
RemoveAllInstantiatedNCs(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB
    )
/*++

Routine Description:

    Delete all values in msds-HasInstantiatedNCs

Arguments:

    pTHS -- thread state
    pDB -- DB cursor pointing at the ntdsDsa object

Return Value:

    success: ERROS_SUCCESS
    error: error in Win32 error space

remarks:
    - raises exception on out of mem conditions.
    - Unused at the moment. Used for debugging
        - Consider exporting interface for management?

--*/
{
    DWORD                       dwErr = ERROR_SUCCESS;
    ATTCACHE *                  pAC;

    DPRINT(1, "RemoveAllInstantiatedNCs entered\n");

    // get AttCache
    pAC = SCGetAttById(pTHS, ATT_MS_DS_HAS_INSTANTIATED_NCS);
    Assert(NULL != pAC);

    dwErr = DBRemAtt_AC(pDB, pAC);

    DPRINT1(1, "DBRemAtt_AC retured %lu\n", dwErr);

    return dwErr;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

DWORD
Dbg_ValidateInstantiatedNCs(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB
    )
/*++

Routine Description:

    Conduct validations on msds-HasInstantiatedNCs attribute.
    *Currently only prints what we have relative to gAnchor*

    Ideas for the future if we encounter any issues w/ this:

      - test & assert:
         - all master & replica NCs are present w/ the correct
           instance type.
         - no duplicate entries.

Arguments:

    pTHS - thread state
    pDB  - DB cursor postion on ntdsDsa object


R:eturn Value:

    ERROR_SUCCESS: all is well
    failing error code

--*/
{
    DWORD                       dwErr = ERROR_SUCCESS;
    ATTCACHE *                  pAC;
    SYNTAX_DISTNAME_BINARY *    pNC = NULL;
    SYNTAX_ADDRESS *            pData = NULL;
    DWORD                       len = 0;
    DWORD                       iVal = 0;
    DWORD                       cbVal = 0;
    PUCHAR                      pVal;
    BOOL                        fBool;
    DWORD                       iValCount = 0;
    NCL_ENUMERATOR              nclMaster, nclReplica;
    DWORD                       iRONCs = 0, iRWNCs = 0, iNCs = 0;


    DPRINT(1, "Dbg_ValidateInstantiatedNC entered\n");

    // get AttCache
    pAC = SCGetAttById(pTHS, ATT_MS_DS_HAS_INSTANTIATED_NCS);
    Assert(NULL != pAC);

    // Count the NCs hosted by this machine.
    NCLEnumeratorInit(&nclMaster, CATALOG_MASTER_NC);
    NCLEnumeratorInit(&nclReplica, CATALOG_REPLICA_NC);
    for (NCLEnumeratorInit(&nclMaster, CATALOG_MASTER_NC), iRWNCs=0;
         NCLEnumeratorGetNext(&nclMaster);
         iRWNCs++);
    for (NCLEnumeratorInit(&nclReplica, CATALOG_REPLICA_NC), iRONCs=0;
         NCLEnumeratorGetNext(&nclReplica);
         iRONCs++);

    iNCs = iRWNCs + iRONCs;

    DPRINT2(1, "There are %d master & %d replica NCs\n", iRWNCs, iRONCs);

    // Count what we have in instantiated list
    iValCount = DBGetValueCount_AC(pDB, pAC);

    DPRINT1(1, "There are %d instantiatedNCs\n", iValCount);

    //
    // Search for entry. If it's there, remove it first
    //

    while( !DBGetAttVal_AC(
                pDB, ++iVal, pAC,
                DBGETATTVAL_fREALLOC,
                len, &cbVal, &pVal) ) {

        // we got data in ATT_MS_DS_HAS_INSTANTIATED_NCS att.
        len = max(len,cbVal);
        pNC = (SYNTAX_DISTNAME_BINARY *)pVal;
        Assert(pNC);

        //
        // TODO: Add validation for dup entries
        //
    }

    if ( pNC ) {
        THFree(pNC);
    }
    return dwErr;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int APIENTRY
DelNCFromDSA(
    IN  THSTATE *   pTHS,
    IN  ATTRTYP     listType,
    IN  DSNAME *    pDN
    )
/*++

Routine Description:

    Remove an NC name from the list of NCs in the given attribute of the local
    DSA object.

Arguments:

    listType (IN) - The attribute containing the list; one of
        ATT_MS_DS_HAS_MASTER_NCS, ATT_HAS_PARTIAL_REPLICA_NCS, or
        ATT_HAS_INSTANTIATED_NCS.

    pDN (IN) - The NC to remove.

Return Values:

    THSTATE error code.

--*/
{
    DBPOS *     pDBCat;
    ATTCACHE *  pAC;
    BOOL        fCommit = FALSE;
    DWORD       dwErr;

    DPRINT(1, "DelNCFromDSA entered\n");

    Assert((ATT_MS_DS_HAS_MASTER_NCS == listType)
           || (ATT_HAS_PARTIAL_REPLICA_NCS == listType));

    DBOpen(&pDBCat);
    __try {
        // PREFIX: dereferencing uninitialized pointer 'pDBCat'
        //         DBOpen returns non-NULL pDBCat or throws an exception

        // Find the DSA object.  If the object doesn't exist we are in trouble.
        if (FIND_ALIVE_FOUND == FindAliveDSName(pDBCat, gAnchor.pDSADN)) {
            pAC = SCGetAttById(pTHS, listType);
            Assert(NULL != pAC);

            /* Get the NC list and remove the value */
            if (!DBHasValues_AC(pDBCat, pAC) ||
                DBRemAttVal_AC(pDBCat, pAC, pDN->structLen, (void *)pDN)){

                DPRINT(2,"Couldn't find the NC on DSA...alert but continue!\n");

                // We don't need to modify anything, so cancel the update that
                // the call to DBRemAttVal may have prepared.
                DBCancelRec(pDBCat);
            } else {

                /* remove the NC from the instantiated NC list */
                if ( dwErr = RemoveInstantiatedNC(pTHS, pDBCat, pDN) ) {
                    //
                    // Trap inconsistencies:
                    //  - if failed not in dcpromo report to debugger & continue.
                    //  - if in dcpromo, then since some of the data is created from ini,
                    //    we expect some inconsistency which will be restored immediately
                    //    upon first boot.
                    //

                    DPRINT1(1, "Error <%lu>: Failed to remove NC from msds-HasInstantiatedNCs list\n",
                                dwErr);
                    //
                    // BUGBUG: We should assert here if we're in normal non-dcpromo run.
                    // However, we hit this a few times during dcpromo, so until we know
                    // exactly all the states in which it is valid to have inconsistency
                    // here, this is commented out.
                    // We should enable this later.
                    // Note 2: use of DsaIsInstalling() check failed cause dcpromo can be at
                    // dsaInitPhase == ePhaseRunning as well...
                    //
                    // Assert(!"Cannot remove InstantiatedNC\n");
                }

                /* Replace the updated object */
                if (dwErr = DBRepl(pDBCat, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING)) {
                    DPRINT(2,"Couldn't replace the DSA object...\n");
                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_MINIMAL,
                             DIRLOG_DATABASE_ERROR,
                             szInsertWC(pDN->StringName),
                             NULL,
                             NULL);

                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRLOG_DATABASE_ERROR, dwErr);
                    __leave;
                }
            }
        } else {
            if (DsaIsInstalling()) {
                // We are trying to write to the distribution DIT machine
                // object.  That is a complete waste of time.  It doesn't matter
                // that we failed.
                Assert(IS_INSTALL_DSA_DSNAME(gAnchor.pDSADN));
            } else {
                DPRINT(0, "***Couldn't locate the DSA object\n");

                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_CANT_FIND_DSA_OBJ,
                         NULL,
                         NULL,
                         NULL);

                SetSvcError(SV_PROBLEM_DIR_ERROR, DIRLOG_CANT_FIND_DSA_OBJ);
                __leave;
            }
        }

        // Remove the NC name from the appropriate in-memory list (if any).
        switch (listType) {
        case ATT_MS_DS_HAS_MASTER_NCS:
            DelNCFromMem(CATALOG_MASTER_NC, pDN);
            break;
        case ATT_HAS_PARTIAL_REPLICA_NCS:
            DelNCFromMem(CATALOG_REPLICA_NC, pDN);
            break;
        default:
            Assert(FALSE && "Code logic error!");
            break;
        }
        fCommit = TRUE;
    } __finally {
        fCommit &= !AbnormalTermination();
        DBClose(pDBCat, fCommit);
    }

    return pTHS->errCode;
}/*DelNCFromDSA*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
// Given an NC, calculate its parent and add this NC to the ATT_SUB_REFS
// attribute of its parent. The parent should already be known to exist.
// The instance type of this object should be NC_HEAD, IT_ABOVE and not
// IT_UNINSTANT.
//
// Callers are:
// mdadd.c:AddAutoSubref - parent exists and is instantiated
// mdupdate.c:AddCatalogInfo - parent exists, we are NC_HEAD and IT_ABOVE
// mdmod.c:ModAutoSubref - parent exists, we exist
/*
[Don Hacherl] There is absolutely no requirement that NC heads must be
immediate children of other NC heads.  You can have many interior objects in
the chain between NC heads.  Domains have an additional requirement that the
NC heads be immediate parent and child, but no such requirement exists for NCs
in general.

The [parent] object you name is an internal object, but not an
NC head at all.  The parent of an external reference can be anything.

The ATT_SUB_REFS attribute goes on the NC head above this NC
head.  That is, you can walk down the tree NC at a time by reading the
ATT_SUB_REFS values and then skipping to the named objects.  In fact, this is
how continuation referrals are generated.  Again, there is no requirement for
NC contiguity.  The node to receive the ATT_SUB_REFS attribute is the NC head
above.  That's why the routine AddSubToNC called FindNCParent, to find the
parent NC.

The attribute goes on the NC head, not on the immediate parent.
For domain NCs these are the same, but that is not true in general.
*/

int APIENTRY
AddSubToNC(THSTATE *pTHS,
           DSNAME *pDN,
           DWORD dsid)
{
   DBPOS *pDBCat;
   DSNAME *pMatchNC;     /* points to the NC of this subref*/
   DWORD  rtn;
   BOOL   fCommit=FALSE;
   ATTCACHE *pAC;

   DPRINT(1,"AddSubToNC entered\n");

   LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_ADD_SUB_TO_NC,
            szInsertDN(pDN),
            szInsertUUID(&pDN->Guid),
            szInsertHex(dsid) );


   if (IsRoot(pDN)){

      DPRINT(2,"The root object can not be a subref\n");
      return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                         DIRERR_ROOT_CANT_BE_SUBREF);
   }

   /* Find the naming context that matches the most RDN's of the reference.
   Check both the master and replica lists.  Check and don't count the case
   where this sub is also an NC (partsMatched == pDN->AVACount).
   */

   if ((pMatchNC = SearchNCParentDSName(pDN, FALSE, TRUE)) == NULL)
   {
        // This must have an instantiated parent
        return 0;
   }

   /* Find the NC object.  If the object doesn't exist we are in trouble.*/

   DPRINT(2,"Finding the NC object\n");

   DBOpen(&pDBCat);
   __try
   {
       if (rtn = FindAliveDSName(pDBCat, pMatchNC)){

          DPRINT(2,"***Couldn't locate the NC object\n");
          LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_EXPECTED_NC,
                szInsertWC(pMatchNC->StringName),
                NULL,
                NULL);

          SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_EXPECTED_NC,rtn);
          __leave;
       }

       /* Add the new SUBREF name to to NC object*/
       pAC = SCGetAttById(pTHS, ATT_SUB_REFS);

       if (!DBHasValues_AC(pDBCat, pAC)){

          DPRINT(2,"Couldnt find SUBREFS list attribute on NC...so add it!\n");

          if ( rtn = DBAddAtt_AC(pDBCat, pAC, SYNTAX_DISTNAME_TYPE) ){
             SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);
             __leave;
          }
       }

       rtn = DBAddAttVal_AC(pDBCat, pAC, pDN->structLen, pDN);

       switch (rtn)
       {
       case 0:
          // Value added; now replace the object.
          if (rtn = DBRepl(pDBCat, pTHStls->fDRA, 0, NULL, META_STANDARD_PROCESSING)){

             DPRINT(2,"Couldn't replace the NC object...\n");
             LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_DATABASE_ERROR,
                      szInsertWC(pDN->StringName),
                      NULL,
                      NULL);

             SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, rtn);
          }
          else {
#if DBG
             gdwLastGlobalKnowledgeOperationTime = GetTickCount();
#endif
             // Successfully added the DN to the subrefs list.
             fCommit = TRUE;
             // Rebuild the ATT_SUB_REFS cache in the global anchor.
             if (pDBCat->DNT == gAnchor.ulDNTDomain) {
                 pTHS->fAnchorInvalidated = TRUE;
             }
          }
          break;

       case DB_ERR_VALUE_EXISTS:
          // Value already exists; 'salright.
          break;

       default:  // all other problems are assumed
                 // to be temporary (record locks, etc.)
          SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);
          break;

       }
    }
    __finally
    {
        DBClose(pDBCat, fCommit);
    }

   return pTHS->errCode;

}/*AddSubToNC*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

/*
DelSubFromNC. The NC is being removed from this computer. Find the NC above us
and remove us from his ATT_SUB_REF attribute.

The DN should be a master or pure SUBREF.
As such, there should always be an instantiated nc above us.

Called from:
mdupdate.c:DelCatalogInfo (deletion, parenting change, instance type change)
mddel.c:DelAutoSubRef (cross ref deletion)

*/

int APIENTRY
DelSubFromNC(THSTATE *pTHS,
             DSNAME *pDN,
             DWORD dsid)
{
   DBPOS *pDBCat;
   NAMING_CONTEXT *pMatchNC;     /* points to the NC of this subref*/
   BOOL fCommit = FALSE;
   ATTCACHE *pAC;
   DWORD  rtn;

   DPRINT(1,"DelSubFromNC entered\n");

   Assert( !fNullUuid(&pDN->Guid) );

   LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_DEL_SUB_FROM_NC,
            szInsertDN(pDN),
            szInsertUUID(&pDN->Guid),
            szInsertHex(dsid) );

   /* Find the naming context that matches the most RDN's of the reference.
      Check both the master and replica lists.  Check and don't count
      the case where this sub is also an NC (partsMatched == pDN->AVACount).
   */

   DPRINT(2,"Finding the best NC match\n");

   if ((pMatchNC = SearchNCParentDSName(pDN, FALSE, TRUE)) == NULL){

       Assert( !"There should exist an instantiated nc above" );
       DPRINT1(1,"***Couldn't locate the NC %ws for this obj in memory\n",
               pDN->StringName);
       LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_NC_IN_CACHE,
                szInsertWC(pDN->StringName),
                NULL,
                NULL);

       return SetSvcError(SV_PROBLEM_DIR_ERROR
                           , DIRERR_CANT_FIND_NC_IN_CACHE);
   }

   DBOpen(&pDBCat);
   __try
   {
        // PREFIX: dereferencing uninitialized pointer 'pDBCat'
        //         DBOpen returns non-NULL pDBCat or throws an exception
       if (rtn = FindAliveDSName(pDBCat, pMatchNC)){

          DPRINT(2,"***Couldn't locate the NC object\n");
          LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_EXPECTED_NC,
                szInsertDN(pMatchNC),
                NULL,
            NULL);

          SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_EXPECTED_NC, rtn);
          __leave;
       }

       /* Delete the  SUBREF name from the NC object*/

       pAC = SCGetAttById(pTHS, ATT_SUB_REFS);

       if ( DBHasValues_AC(pDBCat, pAC) ) {
           DWORD dbError;

           dbError = DBRemAttVal_AC(pDBCat, pAC, pDN->structLen, pDN);

           switch ( dbError )
           {
           case DB_ERR_VALUE_DOESNT_EXIST:
               // Doesn't exist; 'salright.
              break;

           case 0:
              // Value removed; now replace the object.
              if ( 0 == (dbError = DBRepl(pDBCat, pTHStls->fDRA, 0,
                                NULL, META_STANDARD_PROCESSING) ) ) {
#if DBG
                 gdwLastGlobalKnowledgeOperationTime = GetTickCount();
#endif
                 fCommit = TRUE;
                 // Rebuild the ATT_SUB_REFS cache in the global anchor.
                 if (pDBCat->DNT == gAnchor.ulDNTDomain) {
                     pTHS->fAnchorInvalidated = TRUE;
                 }
                 break;
              }
              // else fall through...

           default:
              LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                       DS_EVENT_SEV_MINIMAL,
                       DIRLOG_DATABASE_ERROR,
                       szInsertWC(pDN->StringName),
                       NULL,
                       NULL);
              SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                            DIRERR_DATABASE_ERROR, dbError);
              break;
           }
       }
   }
   __finally
   {
       DBClose(pDBCat, fCommit);
   }
   return pTHS->errCode;

}/*DelSubFromNC*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function validates that the parent of the supplied object exists
   on this DSA.  The object and parent must be of the same type either
   both masters or both replicas.  This check is used by internal and
   subordinate objects.  (Note that a subordinate ref can
   exist under either a  master or  a replica.)

   Also the parent can never be an alias because aliases are ALWAYS leaf nodes
   in the directory tree.
*/

extern int APIENTRY
      ParentExists(ULONG requiredParent, DSNAME *pDN){

   THSTATE *pTHS = pTHStls;
   ULONG len;
   UCHAR *pVal;
   DBPOS *pDBCat;
   DSNAME *pParent = NULL;
   SYNTAX_INTEGER iType;
   BOOL fCommit = FALSE;
   DWORD rtn;

   DPRINT(1,"ParentExists entered\n");

   /* We should never want the parent of the root */

   if (IsRoot(pDN)){

      DPRINT(2,"The parent of the root can never exist\n");
      return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                         DIRERR_ROOT_MUST_BE_NC);
   }

   DBOpen(&pDBCat);
   __try
   {
       /* Find the parent object.  If the object doesn't exist it is a name err.*/
       // Use special db version of trim which is not affected if grandparents are deleted
       // (and their names changed) while this code is running.
       if ( (rtn = DBTrimDSNameBy(pDBCat, pDN, 1, &pParent))
          || (rtn = FindAliveDSName(pDBCat, pParent))){

          DPRINT(2,"***Couldn't locate the parent object\n");
          SetNamErrorEx(NA_PROBLEM_NO_OBJECT, pParent, DIRERR_NO_PARENT_OBJECT, rtn);
          goto ExitTry;
       }

       /* Validate that the parent is not an alias.  Aliases are leaf objects*/

       if (IsAlias(pDBCat)){

          DPRINT(2,"Alias parent is illegal\n");
          SetNamError(NA_PROBLEM_NO_OBJECT, pParent,
                      DIRERR_PARENT_IS_AN_ALIAS);
          goto ExitTry;
       }


       /* Get the parent's instance type.  */

        if(rtn = DBGetSingleValue(pDBCat, ATT_INSTANCE_TYPE, &iType,
                            sizeof(iType),NULL)) {

            DPRINT(2,"***Instance type of parent not found ERROR\n");

            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_INSTANCE,
                     szInsertSz(GetExtDN(pTHS,pDBCat)),
                     szInsertUL(rtn),
                     szInsertHex(DSID(FILENO, __LINE__)));

            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                            DIRERR_CANT_RETRIEVE_INSTANCE, rtn);
            goto ExitTry;
        }

        /* Validate that the parent's instance type matches.  For example you
           can't have a master parent for a replica child.
           */

        if (((PARENTMASTER & requiredParent) &&  ( iType & IT_WRITE)) ||
            ((PARENTFULLREP & requiredParent) && !( iType & (IT_WRITE |
                                                             IT_UNINSTANT)))) {
            DPRINT(2,"Parent instance type is appropriate for child\n");
        }
        else{
            DPRINT2(
                0,
                "Invalid parent instance type <%d> for child <reqParent=%d>\n",
                iType,
                requiredParent
                );
            SetNamError(NA_PROBLEM_NO_OBJECT, pDN,
                        DIRERR_CANT_MIX_MASTER_AND_REPS);
            goto ExitTry;
        }
        fCommit = TRUE;

ExitTry:;
   }
   __finally
   {
       DBClose(pDBCat, fCommit);
       if (pParent) {
           THFreeEx(pTHS,pParent);
       }
   }

   return pTHS->errCode;

}/*ParentExists*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function validates that no children exist for this object.
*/

int APIENTRY
NoChildrenExist(THSTATE * pTHS, RESOBJ *pRes){

    // Seems like a dumb function, but we need to set the error, and
    // the DB function shouldn't be setting thread state errors.

    if(DBHasChildren(pTHS->pDB, pRes->DNT, FALSE)){
        SetUpdError(UP_PROBLEM_CANT_ON_NON_LEAF,
                    DIRERR_CHILDREN_EXIST);
    }

    return(pTHS->errCode);
}/*NoChildrenExist*/

BOOL
IsNcGcReplicated(
    DSNAME *     pdnNC
    )
{
    CROSS_REF_LIST *  pCRL;
    for(pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR){
        if(NameMatched(pdnNC, pCRL->CR.pNC)){
            return( ! (pCRL->CR.flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) );
        }
    }

    return(FALSE);
}


int
ModNCDNT(
    THSTATE *pTHS,
    DSNAME *pNC,
    SYNTAX_INTEGER beforeInstance,
    SYNTAX_INTEGER afterInstance
    )

/*++

Routine Description:

    Modify the NCDNT on an NC HEAD after an instance type change

    This is important because replication finds objects by NCDNT. SUBREFs, by virtue
    of having the ABOVE flag, should and do travel with their superior NC by having
    their NCDNT set to that of their parent.  Inferior NCs, having non-instantiated parents,
    once their ABOVE bit has been cleared, should not be found while their parents are
    being torn down or built up.

    This call is coded to assume we come in with an open transaction on the default dbpos
    with currency on the NCHEAD, and we leave with the same currency.

Arguments:

    pTHS -
    pNC -
    beforeInstance -
    afterInstance -

Return Value:

    int - thread state error code
    On error, thread state is updated with error information

--*/

{
    ULONG ncdnt, ncdntOld;
    DWORD err;

    Assert(VALID_THSTATE(pTHS));

    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(CheckCurrency(pNC));

    Assert(pTHS->transactionlevel);
    Assert( !pTHS->errCode );

    Assert( (beforeInstance & IT_NC_ABOVE) != (afterInstance & IT_NC_ABOVE) );
    Assert( beforeInstance & IT_NC_HEAD );

    // Calculate what the NCDNT should be based on the ABOVE flag
    if (beforeInstance & IT_NC_ABOVE) {
        // NC will no longer have an instantiated parent
        ncdnt = ROOTTAG;
    } else {
        // NC now has an instantiated parent
        // Derive the NCDNT.
        // This call changes currency on pTHS->pDB.
        if ( err = FindNcdntSlowly(
                 pNC,
                 FINDNCDNT_DISALLOW_DELETED_PARENT,
                 FINDNCDNT_DISALLOW_PHANTOM_PARENT,
                 &ncdnt
                 )
            )
        {
            // Failed to derive NCDNT.
            Assert(!"Failed to derive NCDNT");
            Assert(0 != pTHS->errCode);
            LogUnhandledError( err );
            goto exit;
        }
        Assert( ncdnt != ROOTTAG );
    }

    // Position back on object
    err = DBFindDSName(pTHS->pDB, pNC);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRLOG_DATABASE_ERROR, err);
        goto exit;
    }

    err = DBGetSingleValue (pTHS->pDB, FIXED_ATT_NCDNT, &ncdntOld, sizeof(ncdntOld), NULL);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRLOG_DATABASE_ERROR, err);
        goto exit;
    }

    DBResetAtt(
        pTHS->pDB,
        FIXED_ATT_NCDNT,
        sizeof( ncdnt ),
        &ncdnt,
        SYNTAX_INTEGER_TYPE
        );

    DBUpdateRec(pTHS->pDB);

    DPRINT3( 1, "SUBREF change: Updated NCDNT on %ws from %d to %d\n",
             pNC->StringName, ncdntOld, ncdnt );
    LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
              DS_EVENT_SEV_MINIMAL,
              DIRLOG_DRA_SUBREF_SET_NCDNT,
              szInsertDN(pNC),
              szInsertUL(ncdntOld),
              szInsertUL(ncdnt),
              szInsertHex(DSID(FILENO,__LINE__)),
              NULL, NULL, NULL, NULL);

    Assert(CheckCurrency(pNC));

 exit:

   return pTHS->errCode;

} /* ModNCDNT */

// Free the old data from gAnchor in an hour
#define RebuildCatalogDelayedFreeSecs 60 * 60

// retry in 5 minutes if failed
#define RebuildCatalogRetrySecs 5 * 60

typedef struct _NC_SUBSET {
    NAMING_CONTEXT_LIST *   pNC;
    struct _NC_SUBSET *     pNext;
} NC_SUBSET;

int _cdecl CompareDNT(
        const void *pv1,
        const void *pv2
    )

/*++

Routine Description:

    Compares two DWORDs.

Arguments:

    pv1 - Pointer provided by qsort or bsearch to the first DWORD

    pv2 - Pointer to the second DWORD

Return Value:

    Integer representing how much less than, equal or greater the
        first DWORD is with respect to the second.

--*/

{
    DWORD dw1 = * ((DWORD *) pv1);
    DWORD dw2 = * ((DWORD *) pv2);

    if (dw1==dw2)
        return 0;

    if (dw1>dw2)
        return 1;

    return -1;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Reload the memory cached directory Catalog.  We delayed-free and reload
   the master and replica naming-contexts. NC are retrieved from the DSA.
*/

void
RebuildCatalog(void * fNotifyNetLogon,
              void ** ppvNext,
              DWORD * pcSecsUntilNextIteration )
{
    NAMING_CONTEXT_LIST *pNCL, *pLast;
    NAMING_CONTEXT_LIST *pMasterNC = NULL, *pReplicaNC = NULL;
    ULONG len = 0, cbRet = 0;
    UCHAR *pVal = NULL;
    DBPOS *pDBCat;
    int err = 0;
    ULONG NthValIndex = 0;
    ATTCACHE *pAC;
    DWORD cpapv, curIndex;
    DWORD_PTR *papv = NULL;
    THSTATE *pTHS = pTHStls;
    NC_SUBSET * pNonGCNcs = NULL;
    NC_SUBSET * pTemp = NULL;
    ULONG cNonGCNcs = 0;
    DWORD *  paNonGCNcDNTs = NULL; // DNTs
    COUNTED_LIST * pNoGCSearchList = NULL;
    ULONG i;
    BOOL fDsaInstalling;
    PVOID dwEA;
    ULONG dwException, dsid;

    Assert(pTHS);

    DPRINT(2,"RebuildCatalog entered\n");

    /* Find the DSA object.  If the object doesn't exist we are in trouble.*/

    DPRINT(2,"find the DSA object\n");

    __try {
        DBOpen(&pDBCat);
        __try
        {
            fDsaInstalling = DsaIsInstalling();

            //
            // Position on DSA object.
            //
            // PREFIX: dereferencing uninitialized pointer 'pDBCat'
            //         DBOpen returns non-NULL pDBCat or throws an exception
            if (FindAliveDSName(pDBCat, gAnchor.pDSADN)) {
                DPRINT(2,"***Couldn't locate the DSA object\n");

                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_CANT_FIND_DSA_OBJ,
                         NULL,
                         NULL,
                         NULL);

                err = 1;
                __leave;
            }

            //
            // Build new MasterNC list from msDS-HasMasterNcs attr.
            //
            pAC = SCGetAttById(pTHS, ATT_MS_DS_HAS_MASTER_NCS);
            Assert(pAC);
            DPRINT(2,"LOADING master NC's\n");
            NthValIndex = 0;
            pLast = NULL;
            while(!(err = DBGetAttVal_AC(pDBCat, ++NthValIndex,
                                         pAC,
                                         DBGETATTVAL_fREALLOC,
                                         len, &cbRet, &pVal))) {
                len = max(len,cbRet);

                // make the entry
                err = MakeNCEntry((DSNAME*)pVal, &pNCL);
                if (err != 0) {
                    __leave;
                }

                if(!fDsaInstalling &&
                   !IsNcGcReplicated(pNCL->pNC)){
                    // If this NC is not GC replicated, add to the
                    // subset of NCs to not include in a GC searchs
                    pTemp = pNonGCNcs;
                    pNonGCNcs = THAllocEx(pTHS, sizeof (NC_SUBSET));
                    pNonGCNcs->pNC = pNCL;
                    pNonGCNcs->pNext = pTemp;
                    cNonGCNcs++;
                }

    #if defined(DBG)
                // Note: we haven't updated our global knowledge yet.
                gdwLastGlobalKnowledgeOperationTime = GetTickCount();
    #endif

                // drop it into the end of the list
                if (pLast == NULL) {
                    // must be the first one
                    pMasterNC = pNCL;
                }
                else {
                    pLast->pNextNC = pNCL;
                }
                pNCL->pNextNC = NULL;
                pLast = pNCL;

            }
            if (err != DB_ERR_NO_VALUE) {
                DPRINT1(0, "Error reading db value: 0x%x\n", err);
                __leave;
            }
            err = 0;

            //
            // Build new ReplicaNC list from hasPartialReplicaNcs attr.
            //
            DPRINT(2,"LOADING Replica NC's\n");
            pAC = SCGetAttById(pTHS, ATT_HAS_PARTIAL_REPLICA_NCS);
            Assert(pAC);
            NthValIndex = 0;
            pLast = NULL;
            while(!(err = DBGetAttVal_AC(pDBCat,++NthValIndex, pAC,
                                         DBGETATTVAL_fREALLOC,
                                         len, &cbRet, &pVal))) {
                len = max(len,cbRet);

                // make entry
                // make the entry
                err = MakeNCEntry((DSNAME*)pVal, &pNCL);
                if (err != 0) {
                    __leave;
                }

                if(!fDsaInstalling &&
                   !IsNcGcReplicated(pNCL->pNC)){
                    // If this NC is not GC replicated, add to the
                    // subset of NCs to not include in a GC searchs
                    pTemp = pNonGCNcs;
                    pNonGCNcs = THAllocEx(pTHS, sizeof (NC_SUBSET));
                    pNonGCNcs->pNC = pNCL;
                    pNonGCNcs->pNext = pTemp;
                    cNonGCNcs++;
                }

    #if defined(DBG)
                // Note: we haven't updated our global knowledge yet.
                gdwLastGlobalKnowledgeOperationTime = GetTickCount();
    #endif

                // drop it into the end of the list
                if (pLast == NULL) {
                    // must be the first one
                    pReplicaNC = pNCL;
                }
                else {
                    pLast->pNextNC = pNCL;
                }
                pNCL->pNextNC = NULL;
                pLast = pNCL;
            }
            if (err != DB_ERR_NO_VALUE) {
                DPRINT1(0, "Error reading db value: 0x%x\n", err);
                __leave;
            }
            err = 0;

            //
            // Create list of Non GC Replicated NCs.
            //
            if(pNonGCNcs){
                // We've some NCs that aren't GC Replicated.
                Assert(cNonGCNcs >= 1);

                // First create the COUNTED_LIST structure, so
                // we can do a simultaneous update of the list
                // of DNTs and the count.
                pNoGCSearchList = (COUNTED_LIST *) malloc(sizeof(COUNTED_LIST));
                if(pNoGCSearchList == NULL){
                    err = ERROR_OUTOFMEMORY;
                    __leave;
                }

                // Second, allocate an array to hold the DNTs
                paNonGCNcDNTs = malloc(sizeof(DWORD) * cNonGCNcs);
                if(paNonGCNcDNTs == NULL){
                    err = ERROR_OUTOFMEMORY;
                    __leave;
                }

                // We were able to allocate the array, now fill it,
                // also while were here, we might as well tear down
                // the linked list of NCs that we used.
                for(i = 0; pNonGCNcs; i++){
                    paNonGCNcDNTs[i] = pNonGCNcs->pNC->NCDNT;
                    pTemp = pNonGCNcs;
                    pNonGCNcs = pNonGCNcs->pNext;
                    THFreeEx(pTHS, pTemp); // Don't need this anymore.
                }
                Assert(i == cNonGCNcs);
                Assert(pNonGCNcs == NULL);

                // Now sort it the array.
                qsort(paNonGCNcDNTs,
                      cNonGCNcs,
                      sizeof(paNonGCNcDNTs[0]),
                      CompareDNT);

                // Finally, make up the gAnchor cache item.
                pNoGCSearchList->cNCs = cNonGCNcs;
                pNoGCSearchList->pList = paNonGCNcDNTs;
            }

            // we don't need the pDBCat any more
            DBClose(pDBCat, err == ERROR_SUCCESS);
            pDBCat = NULL;

            if (err != 0) {
                __leave;
            }

            // replace the value in the gAnchor. Must grab the gAnchor.CSUpdate in order to do that!
            // no try-finally since no exception can be raised
            EnterCriticalSection(&gAnchor.CSUpdate);

            //
            // count the total number of entries to delay-free
            //
            cpapv = 0;
            for (pNCL = gAnchor.pMasterNC; pNCL != NULL; pNCL = pNCL->pNextNC) {
                cpapv++;
            }
            for (pNCL = gAnchor.pReplicaNC; pNCL != NULL; pNCL = pNCL->pNextNC) {
                cpapv++;
            }

            if (cpapv > 0) {
                cpapv *= 5; // 5 ptrs to free for each entry: pNC, pNCBlock, pAncestors, pNtdsQuotasDN and entry self
            }
            if(gAnchor.pNoGCSearchList){
                cpapv++;
                Assert(gAnchor.pNoGCSearchList->pList);
                if(gAnchor.pNoGCSearchList->pList){
                    cpapv++;
                }
            }

            //
            // Allocate the delayed free memory.
            //
            papv = (DWORD_PTR*)malloc((cpapv+1) * sizeof(DWORD_PTR)); // We add an extra one for the size.
            if (papv == NULL) {
                // we miserably failed! there is no memory left!
                err = ERROR_OUTOFMEMORY;
                LeaveCriticalSection(&gAnchor.CSUpdate);
                __leave;
            }

            //
            // Now add all the delayed free memory pointers to the delayed
            // memory free list/array.
            //
            papv[0] = (DWORD_PTR)cpapv; // First element is count of ptrs.
            curIndex = 1;
            for (pNCL = gAnchor.pMasterNC; pNCL != NULL; pNCL = pNCL->pNextNC) {
                papv[curIndex++] = (DWORD_PTR)pNCL->pNC;
                papv[curIndex++] = (DWORD_PTR)pNCL->pNCBlock;
                papv[curIndex++] = (DWORD_PTR)pNCL->pAncestors;
                papv[curIndex++] = (DWORD_PTR)pNCL->pNtdsQuotasDN;
                papv[curIndex++] = (DWORD_PTR)pNCL;
            }
            for (pNCL = gAnchor.pReplicaNC; pNCL != NULL; pNCL = pNCL->pNextNC) {
                papv[curIndex++] = (DWORD_PTR)pNCL->pNC;
                papv[curIndex++] = (DWORD_PTR)pNCL->pNCBlock;
                papv[curIndex++] = (DWORD_PTR)pNCL->pAncestors;
                papv[curIndex++] = (DWORD_PTR)pNCL->pNtdsQuotasDN;
                papv[curIndex++] = (DWORD_PTR)pNCL;
            }
            if(gAnchor.pNoGCSearchList){
                papv[curIndex++] = (DWORD_PTR)gAnchor.pNoGCSearchList;
                if(gAnchor.pNoGCSearchList->pList){
                    papv[curIndex++] = (DWORD_PTR)gAnchor.pNoGCSearchList->pList;
                }
            }

            //
            // now we can assign global vars
            //
            gAnchor.pMasterNC = pMasterNC;
            gAnchor.pReplicaNC = pReplicaNC;
            gAnchor.pNoGCSearchList = pNoGCSearchList;
            Assert(pNoGCSearchList == NULL || // sanity check
                   (pNoGCSearchList && pNoGCSearchList->pList));

            //
            // let go local ptrs so that they don't get released
            //
            pMasterNC = NULL;
            pReplicaNC = NULL;
            pNoGCSearchList = NULL;

        #if defined(DBG)
            gdwLastGlobalKnowledgeOperationTime = GetTickCount();
        #endif
            LeaveCriticalSection(&gAnchor.CSUpdate);

            if (fNotifyNetLogon) {
                dsI_NetNotifyDsChange(NlNdncChanged);
            }

            if (papv != NULL) {
                // it can actually be null in case both original lists were empty
                DelayedFreeMemoryEx(papv, RebuildCatalogDelayedFreeSecs);
                papv = NULL;
            }
        }
        __finally {
            if (pVal) {
                THFreeEx(pTHS, pVal);
            }
            // Free any of these left over from an error state.
            while(pNonGCNcs){
                pTemp = pNonGCNcs;
                pNonGCNcs = pNonGCNcs->pNext;
                THFreeEx(pTHS, pTemp);
            }

            // these vars were left non-NULL because of an error. Free them
            while (pNCL = pMasterNC) {
                pMasterNC = pMasterNC->pNextNC;
                FreeNCEntry(pNCL);
            }

            while (pNCL = pReplicaNC) {
                pReplicaNC = pReplicaNC->pNextNC;
                FreeNCEntry(pNCL);
            }

            if(pNoGCSearchList){
                if(pNoGCSearchList->pList){
                    free(pNoGCSearchList->pList);
                }
                free(pNoGCSearchList);
            }

            if (papv != NULL) {
                free(papv);
            }

            if (pDBCat) {
                DBClose(pDBCat, !AbnormalTermination());
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwEA,
                              &err,
                              &dsid)) {
        if (err == 0) {
            err = ERROR_DS_UNKNOWN_ERROR;
        }
        HandleDirExceptions(dwException, err, dsid);
    }
    if (err) {
        // We didn't succeed, so try again in a few minutes
        *ppvNext = NULL;
        *pcSecsUntilNextIteration = RebuildCatalogRetrySecs;
    }
}       /*RebuildCatalog*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Cache a naming context.
*/

VOID AddNCToMem(CATALOG_ID_ENUM catalogID, DSNAME *pDN)
{
    NAMING_CONTEXT_LIST *pNCL;
    DWORD err;

    Assert(pDN);

    // make the entry
    err = MakeNCEntry(pDN, &pNCL);
    if (err != 0) {
        RaiseDsaExcept(DSA_MEM_EXCEPTION, err, 0, DSID(FILENO, __LINE__), DS_EVENT_SEV_MINIMAL);
    }
    CatalogAddEntry(pNCL, catalogID);
}/*AddNCToMem*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Remove the naming context from the global cache.
*/

VOID DelNCFromMem(CATALOG_ID_ENUM catalogID, DSNAME *pDN) {

    NAMING_CONTEXT_LIST *pNCL;
    NCL_ENUMERATOR nclEnum;

    Assert(pDN);

    DPRINT1(1,"DelNCFromMem entered.. delete the NC with name %S\n",
           pDN->StringName);

    NCLEnumeratorInit(&nclEnum, catalogID);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, (PVOID)pDN);
    if (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
        // found it!

        // Remove entry
        CatalogRemoveEntry(pNCL, catalogID);

        // Don't free anything! All we've done so far is marked the entry as deleted
        // for current transaction only. The entry is still sitting in the global list
        // and is visible to other threads... The global catalog will get rebuilt on
        // transaction commit.

        // return happy
        return;
    }

    // did not find a match!
    DPRINT1(2, "NC %S not in NCLIST. Catalog problems...\n", pDN->StringName);
}/*DelNCFromMem*/
/*-------------------------------------------------------------------------*/


DSNAME *
SearchNCParentDSName(
    DSNAME *pDN,
    BOOL masterOnly,
    BOOL parentOnly
    )

/*++

Routine Description:

    Find the enclosing NC for this DN. The enclosing NC must be instantiated on this machine.

    The calculation is done in a transactional consistent manner from the database. It does
    not depend on the Anchor NCL list, which may be temporarily inconsistent.

    The reason that consistency is important is that this calculation is done by name, not
    guid. We may be in the midst of changing the name of this object, and the enclosing NCs
    may be having their names changed during this time as well.  We want a window where all
    the names are consistent so that they may be compared properly.

    Use this routine when inconsistent results are not acceptable.

Arguments:

    pDN - DN for which enclosing NC will be calculated
    masterOnly - Whether an enclosing readonly NC is acceptable
    parentOnly - If FALSE, an NC cannot match itself

Return Value:

    DSNAME * - enclosing NC, or NULL if not found
               A new, thread allocated copy is returned
--*/

{
    THSTATE *pTHS = pTHStls;
    ULONG maxMatch;
    DSNAME *pMatchNC = NULL;
    DBPOS *pDBCat;
    ATTCACHE *pAC;
    ULONG len = 0, cbRet = 0;
    ULONG NthValIndex = 0;
    DSNAME *pNC = NULL;
    DSNAME *pCurrentDN = NULL;
    int err = 0;

    maxMatch = 0;
    pMatchNC = NULL;

    if (DsaIsInstalling()) {
        // We are trying to use the distribution DIT machine object.
        // That is a complete waste of time.
        Assert(IS_INSTALL_DSA_DSNAME(gAnchor.pDSADN)); // Note this might
        // fail someday, if someone fixes gAnchor.pDSADN to the real DN before
        // we finish install.
        return FindNCParentDSName( pDN, masterOnly, parentOnly);
    }

    if (!(pDN->NameLen)) {
        Assert( !"FindNcParentDSName requires a DSNAME with a name!" );
        return NULL;
    }

    /* The root is handled as a special case.  it has no parent NC so return
     * if only a parent is desired
     */

    if (IsRoot(pDN) && parentOnly) {
        return NULL;
    }

    DBOpen(&pDBCat);
    __try
    {

        // Improve the name.
        // Guarantee that the name we are given is consistent with the database
        // Do not do this in single user mode for two reasons:
        // 1. In single user mode there are no other simultaneous changes
        // 2. During a domain rename, we want to use the unimproved name.  The post
        //    renamed name may be in a completely separate hierarchy and may be
        //    unusable for a syntactic nc containment match.
        //    See call to DelCatalogInfo in mdmoddn.c

        if (!(pTHS->fSingleUserModeThread)) {
            if (!DBRefreshDSName( pDBCat, pDN, &pCurrentDN )) {
#if DBG
                if (!NameMatchedStringNameOnly(pDN, pCurrentDN)) {
                    DPRINT2( 1, "DN refreshed from %S to %S.\n",
                             pDN->StringName, pCurrentDN->StringName );
                }
#endif
                pDN = pCurrentDN;
            }
        }

        //
        // Position on DSA object.
        //
        if (err = FindAliveDSName(pDBCat, gAnchor.pDSADN)) {
            DPRINT(2,"***Couldn't locate the DSA object\n");

            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_DSA_OBJ,
                     NULL,
                     NULL,
                     NULL);

            __leave;
        }

        // Find the closest matching NC.
        //
        // Basically an NC is a candidate if it has fewer AVA's (or the same number
        // if parentOnly is not specified), and all of its AVA's match the object.
        //
        // We select the candidate NC with the largets number of AVAs.

        pAC = SCGetAttById(pTHS, ATT_MS_DS_HAS_MASTER_NCS);
        Assert(pAC);
        NthValIndex = 0;

        while(!(err = DBGetAttVal_AC(pDBCat, ++NthValIndex,
                                     pAC,
                                     DBGETATTVAL_fREALLOC,
                                     len, &cbRet, (UCHAR **) &pNC))) {
            len = max(len,cbRet);


            if ((pNC->NameLen < pDN->NameLen ||
                 (!parentOnly && pNC->NameLen == pDN->NameLen)) &&
                NamePrefix(pNC, pDN) &&
                pNC->NameLen > maxMatch) {

                maxMatch = pNC->NameLen;

                // pMatchNC = pNC;
                if (pMatchNC) {
                    THFreeEx(pDBCat->pTHS, pMatchNC);
                }
                pMatchNC = THAllocEx(pTHS, pNC->structLen);
                memcpy(pMatchNC, pNC, pNC->structLen);
            }

            // The root might actually be an NC.. Check it

            if (pMatchNC == NULL && IsRoot(pNC)) {

                // pMatchNC = pNC;
                pMatchNC = THAllocEx(pTHS, pNC->structLen);
                memcpy(pMatchNC, pNC, pNC->structLen);
            }
        }
        if (err != DB_ERR_NO_VALUE) {
            DPRINT1(0, "Error reading db value: 0x%x\n", err);
            if (pMatchNC) {
                THFreeEx(pDBCat->pTHS, pMatchNC);
            }
            pMatchNC = NULL;
            __leave;
        }


        // Check the copy list if copies are allowed

        if (masterOnly) {
            __leave;
        }

        pAC = SCGetAttById(pTHS, ATT_HAS_PARTIAL_REPLICA_NCS);
        Assert(pAC);
        NthValIndex = 0;

        while(!(err = DBGetAttVal_AC(pDBCat,++NthValIndex, pAC,
                                     DBGETATTVAL_fREALLOC,
                                     len, &cbRet, (UCHAR **) &pNC))) {
            len = max(len,cbRet);

            if ((pNC->NameLen < pDN->NameLen ||
                 (!parentOnly && pNC->NameLen == pDN->NameLen)) &&
                NamePrefix(pNC, pDN) &&
                pNC->NameLen > maxMatch) {

                maxMatch = pNC->NameLen;

                // pMatchNC = pNC;
                if (pMatchNC) {
                    THFreeEx(pDBCat->pTHS, pMatchNC);
                }
                pMatchNC = THAllocEx(pTHS, pNC->structLen);
                memcpy(pMatchNC, pNC, pNC->structLen);
            }

            // The root might actually be an NC.. Check it

            if (pMatchNC == NULL && IsRoot(pNC)) {
                // pMatchNC = pNC;
                pMatchNC = THAllocEx(pTHS, pNC->structLen);
                memcpy(pMatchNC, pNC, pNC->structLen);
            }
        }
        if (err != DB_ERR_NO_VALUE) {
            DPRINT1(0, "Error reading db value: 0x%x\n", err);
            if (pMatchNC) {
                THFreeEx(pDBCat->pTHS, pMatchNC);
            }
            pMatchNC = NULL;
            __leave;
        }

    }
    __finally
    {
        if (pNC) {
            THFreeEx(pDBCat->pTHS, pNC);
        }
        DBClose(pDBCat, !AbnormalTermination());
    }

    if (pMatchNC == NULL) {

        DPRINT1(1,"No NC found for this object (%S).\n", pDN->StringName);
    }
    else {

        DPRINT2(1,"The NC for this object (%S) is %S\n", pDN->StringName, pMatchNC->StringName);
    }

    return pMatchNC;
} /* SearchNCParentDSName */

DSNAME *FindNCParentDSName(DSNAME *pDN, BOOL masterOnly, BOOL parentOnly)
{
    ULONG maxMatch;
    NAMING_CONTEXT *pMatchNC;     /* points to the NC of this subref*/
    NAMING_CONTEXT_LIST *pNCL;
    NCL_ENUMERATOR nclEnum;

    maxMatch = 0;
    pMatchNC = NULL;

    if (!(pDN->NameLen)) {
        Assert( !"FindNcParentDSName requires a DSNAME with a name!" );
        return NULL;
    }

    /* The root is handled as a special case.  it has no parent NC so return
     * if only a parent is desired
     */

    if (IsRoot(pDN) && parentOnly) {
        return NULL;
    }

    // Find the closest matching NC.
    //
    // Basically an NC is a candidate if it has fewer AVA's (or the same number
    // if parentOnly is not specified), and all of its AVA's match the object.
    //
    // We select the candidate NC with the largets number of AVAs.

    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {

        if ((pNCL->pNC->NameLen < pDN->NameLen ||
             (!parentOnly && pNCL->pNC->NameLen == pDN->NameLen)) &&
            NamePrefix(pNCL->pNC, pDN) &&
            pNCL->pNC->NameLen > maxMatch) {

            maxMatch = pNCL->pNC->NameLen;
            pMatchNC = pNCL->pNC;
        }

        // The root might actually be an NC.. Check it

        if (pMatchNC == NULL && IsRoot(pNCL->pNC)) {

            pMatchNC = pNCL->pNC;
        }
    }


    // Check the copy list if copies are allowed

    if (!masterOnly) {
        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {

            if ((pNCL->pNC->NameLen < pDN->NameLen ||
                 (!parentOnly && pNCL->pNC->NameLen == pDN->NameLen)) &&
                NamePrefix(pNCL->pNC, pDN) &&
                pNCL->pNC->NameLen > maxMatch) {

                maxMatch = pNCL->pNC->NameLen;
                pMatchNC = pNCL->pNC;
            }

            // The root might actually be an NC.. Check it

            if (pMatchNC == NULL && IsRoot(pNCL->pNC)) {
                pMatchNC = pNCL->pNC;
            }
        }
    }

    if (pMatchNC == NULL) {

        DPRINT(2,"No NC found for this object..\n");
    }
    else {

        DPRINT1(2,"The NC for this object is %S\n", pMatchNC->StringName);
    }

    return pMatchNC;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function handles a special case of changing instance types from
   an NC to an internal reference.  It copies all subref info from the
   current object to its parent NC and deletes the subref att from itself
*/

int
MoveSUBInfoToParentNC(THSTATE *pTHS,
                      DSNAME *pDN)
{
    DSNAME *pMatchNC;     /* points to the NC of this object*/
    ULONG len = 0, cbRet = 0;
    UCHAR *pVal = NULL;
    DBPOS *pDBCat;
    DWORD  rtn;
    BOOL   fCommit = FALSE;
    ULONG  NthValIndex;
    ATTCACHE *pAC;

    DPRINT(1,"MoveSUBInforToParentNC entered\n");

    /* If the parent NC does not exist on this DSA is is a name error
       because you can't add an intermediate object INT without a
       corresponding NC.
    */

    if ((pMatchNC = SearchNCParentDSName(pDN, FALSE, TRUE)) == NULL){
        DPRINT1(1,"***Couldn't locate the NC %ws for this obj in memory\n",
                pDN->StringName);
        Assert(FALSE && "Couldnt find subref's NC above in CR list");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_FIND_NC_IN_CACHE,
                 szInsertDN(pDN),
                 NULL,
                 NULL);
        return SetNamError(NA_PROBLEM_NO_OBJECT, pDN,
                           DIRERR_NO_PARENT_OBJECT);
    }

    pAC = SCGetAttById(pTHS, ATT_SUB_REFS);

    DBOpen(&pDBCat);
    __try {

        /* Find the NC object.  If the object doesn't exist we are in trouble.*/

        DPRINT(2,"find the NC object\n");

        // PREFIX: dereferencing uninitialized pointer 'pDBCat'
        //         DBOpen returns non-NULL pDBCat or throws an exception
        if (rtn = FindAliveDSName(pDBCat, pMatchNC)){

            DPRINT(2,"***Couldn't locate the NC object. catalog problem continue\n");

            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_EXPECTED_NC,
                     szInsertWC(pMatchNC->StringName),
                     NULL,
                     NULL);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_EXPECTED_NC, rtn);
            __leave;
        }


        /*Position on the SUBREFS attribute on the current object */
        if (!DBHasValues_AC(pTHS->pDB, pAC)) {
            DPRINT(2,"No SUBREFS on current object..Nothing to move return\n");
            __leave;
        }
        //Position on the SUBREFS attribute on the NC.  If it doesn't exist add

        if (!DBHasValues_AC(pDBCat, pAC)) {

            DPRINT(2,"NC Has no SUBREFS so add it!\n");

            if (rtn =  DBAddAtt_AC(pDBCat, pAC, SYNTAX_DISTNAME_TYPE) ){

                DPRINT(2,"Couldn't add SUBREFS att type to NC assume size err\n");
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);
                __leave;
            }
        }

        /* Move all subrefs to the parent NC */
        NthValIndex = 0;
        while (!DBGetAttVal_AC(pTHS->pDB, ++NthValIndex,
                               pAC,
                               DBGETATTVAL_fREALLOC,
                               len, &cbRet, &pVal)){
            len = max(len,cbRet);
            if (rtn=DBAddAttVal_AC(pDBCat, pAC, len, pVal)) {
                // All problems are assumed to be temporary (record locks, etc.).
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);
                __leave;
            }
        }/*while*/

        /* Replace the parent NC object*/

        DPRINT(2,"Replace the parent object\n");

        if (rtn = DBRepl(pDBCat, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING)){

            DPRINT(2,"Couldn't replace the NC object...\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DATABASE_ERROR,
                     szInsertWC(pDN->StringName),
                     NULL,
                     NULL);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, rtn);
            __leave;
        }
#if DBG
        gdwLastGlobalKnowledgeOperationTime = GetTickCount();
#endif
        fCommit = TRUE;
    } __finally {
        DBClose(pDBCat, fCommit);
        if (pVal) {
            THFreeEx(pTHS, pVal);
        }
    }

    if (pTHS->errCode) {
        return pTHS->errCode;
    }

    /* REmove the subrefs from the current obj and replace*/

    DPRINT(2,"Remove the subrefs from the current object and replace\n");
    if (rtn = DBRemAtt_AC(pTHS->pDB, pAC) == DB_ERR_SYSERROR) {
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);
    }

    if (rtn = DBRepl(pDBCat, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING)) {

        DPRINT(2,"Couldn't replace the CURRENT object...\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DATABASE_ERROR,
                 szInsertWC(pDN->StringName),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, rtn);
    }

    DPRINT(2,"Good return from MoveSUBInforToParentNC\n");

    return 0;

}/*MoveSUBToParentNC*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function handles a special case of changing instance types from
   an internal reference to an NC.  It copies all of its child subrefs from
   the parent NC ato itself,and deletes those refs from the parent
*/
int
MoveParentSUBInfoToNC(THSTATE *pTHS,
                      DSNAME *pDN)
{
    DSNAME *pMatchNC;     /* points to the NC of this object*/
    ULONG len = 0, cbRet = 0;
    UCHAR *pVal = NULL;
    DBPOS *pDBCat;
    DWORD  rtn;
    BOOL fCommit = FALSE;
    BOOL fEarlyReturn = FALSE;
    ULONG NthValIndex;
    ATTCACHE *pAC;

    DPRINT(1,"MoveParentSUBInforToNC entered\n");

    // If the parent NC does not exist on this DSA is is a DIR
    // because you can't have an intermediate object INT without a
    // corresponding NC.

    if ((pMatchNC = SearchNCParentDSName(pDN, FALSE, TRUE)) == NULL){

        DPRINT1(1,"***Couldn't locate the NC %ws for this obj in memory\n",
                pDN->StringName);
        Assert(FALSE && "Couldnt find subref's NC above in CR list");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_FIND_NC_IN_CACHE,
                 szInsertDN(pDN),
                 NULL,
                 NULL);

        return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_NC_IN_CACHE);
    }

    pAC = SCGetAttById(pTHS, ATT_SUB_REFS);

    DBOpen(&pDBCat);
    __try {
        // Find the NC object.  If the object doesn't exist we are in trouble.

        DPRINT(2,"find the NC object\n");

    // PREFIX: dereferencing uninitialized pointer 'pDBCat'
    //         DBOpen returns non-NULL pDBCat or throws an exception
        if (rtn =FindAliveDSName(pDBCat, pMatchNC)) {

            DPRINT(2,"***Couldn't locate the NC object. catalog problem \n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_EXPECTED_NC,
                     szInsertDN(pMatchNC),
                     NULL,
                     NULL);

            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_EXPECTED_NC, rtn);
            fEarlyReturn = TRUE;
            __leave;
        }

        /*Position on the SUBREFS attribute on the Parents sub refs */

        if (!DBHasValues_AC(pDBCat, pAC)){

            DPRINT(2,"No SUBREFS on parent..Nothing to move return\n");
            fEarlyReturn = TRUE;
            __leave;
        }

        /*Create a SUBREFS attribute on the current object.   */

        DPRINT(2,"Remove and create  subrefs on the current object\n");
        DBRemAtt_AC(pTHS->pDB, pAC);
        DBAddAtt_AC(pTHS->pDB, pAC, SYNTAX_DISTNAME_TYPE);

        // Move all subrefs that belong under this object from the parent NC
        // SUBREFS that contain the current obj DN in its name are subordinate
        // to this object and are moved

        NthValIndex = 0;

        while (!DBGetAttVal_AC(pDBCat,
                               ++NthValIndex,
                               pAC,
                               DBGETATTVAL_fREALLOC,
                               len,
                               &cbRet,
                               &pVal)) {
            len = max(len,cbRet);

            if (NamePrefix(pDN, (DSNAME*)pVal)) {
                // This needs to be moved, so delete it from the parent...

                if (rtn = DBRemAttVal_AC(pDBCat, pAC, len, pVal)) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,rtn);
                    fEarlyReturn = TRUE;
                    __leave;
                }

                // ...adjust our attribute count for the one we removed...

                --NthValIndex;

                // ...and add the value to the object.

                if (rtn=DBAddAttVal_AC(pTHS->pDB, pAC, len, pVal)) {
                    // All problems are assumed to be temporary (record locks, etc.).
                    SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);
                    __leave;
                }
            }
        } /*while*/

        // Replace the parent NC object

        DPRINT(2,"Replace the parent object\n");

        if (rtn = DBRepl(pDBCat, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING)){

            DPRINT(2,"Couldn't replace the NC object...\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DATABASE_ERROR,
                     szInsertDN(pMatchNC),
                     NULL,
                     NULL);

            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, rtn);
            fEarlyReturn = TRUE;
            __leave;
        }
#if DBG
        gdwLastGlobalKnowledgeOperationTime = GetTickCount();
#endif
        fCommit = TRUE;
    }
    __finally {
        DBClose(pDBCat, fCommit);
        if (pVal) {
            THFreeEx(pTHS, pVal);
        }
    }

    if (fEarlyReturn) {
        return pTHS->errCode;
    }

    // Replace the current obj

    if (rtn = DBRepl(pDBCat, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING)) {

        DPRINT(2,"Couldn't replace the CURRENT object...\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DATABASE_ERROR,
                 szInsertDN(pDN),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, rtn);
    }

    DPRINT(2,"Good return from MoveParentSUBInfotoNC\n");

    return 0;

}/*MoveParentSUBInfoToNC*/

NAMING_CONTEXT_LIST * FindNCLFromNCDNT(DWORD NCDNT, BOOL fMasterOnly)
{
    NAMING_CONTEXT_LIST * pNCL;
    NCL_ENUMERATOR nclEnum;

    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NCDNT, (PVOID)UlongToPtr(NCDNT));
    if (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
        return pNCL;
    }

    if(fMasterOnly) {
        // The caller only wants a master NC.
        return NULL;
    }

    NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NCDNT, (PVOID)UlongToPtr(NCDNT));
    if (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
        return pNCL;
    }

    /* No one should ever call this routine with an invalid NCDNT */
    LooseAssert(!"FindNCLFromNCDNT could not find NCDNT in list", GlobalKnowledgeCommitDelay);
    return NULL;
}

ULONG CheckRoleOwnership(THSTATE *pTHS,
                         DSNAME *pRoleObject,
                         DSNAME *pOperationTarget)
/*++
  Routine description

    This routine verifies that the current server is the holder of the
    specified role, and ensures that it stays so for the current
    transaction by taking a write lock on the FSMO object.

  Input:
    pRoleObject - the object on which the FSMO-Role-Owner attribute lives
    pOperationTarget - the target of the current operation, used only for
                       generating referrals.

  Return Values

    0 == yes, this server has mastery
    non-0 == no, this server is not the master.  Appropriate error in pTHS.
*/
{
    ULONG dntSave;
    ULONG err;
    DSNAME *pOwner;
    ULONG len;

    if (pTHS->fDSA || pTHS->fDRA || !DsaIsRunning()) {
        // The DSA itself can do whatever it wants, and if we're in one of
        // of those inexplicable not-running states, ignore everything.
        return 0;
    }

    dntSave = pTHS->pDB->DNT;
    pOwner = NULL;
    __try {

        err = DBFindDSName(pTHS->pDB, pRoleObject);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRLOG_DATABASE_ERROR, err);
            __leave;
        }

        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_FSMO_ROLE_OWNER,
                          0,
                          0,
                          &len,
                          (UCHAR **)&pOwner);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRLOG_DATABASE_ERROR, err);
            __leave;
        }

        if (!NameMatched(pOwner, gAnchor.pDSADN)) {
            // We don't own the role, and hence can't perform the operation
            DSA_ADDRESS da;
            NAMERESOP op;
            unsigned cb;

            op.nameRes = OP_NAMERES_NOT_STARTED;

            da.Buffer = DSaddrFromName(pTHS, pOwner);
            da.Length = da.MaximumLength = (1 + wcslen(da.Buffer)) * sizeof(WCHAR);

            SetRefError(pOperationTarget,
                        0,
                        &op,
                        0,
                        CH_REFTYPE_CROSS,
                        &da,
                        DIRERR_REFERRAL);
            __leave;
        }
        else if (!IsFSMOSelfOwnershipValid( pRoleObject )) {
            // We think we own the role, but can't be sure yet.
            // Send the user away to think for a while, and maybe when
            // he comes back we'll be more confident.
            SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_ROLE_NOT_VERIFIED);
            __leave;
        }
        else {
            // We own the role.  Take a write lock on the container, so that
            // we will conflict with any other updates, as well as with
            // anyone trying to migrate the role away.
            DBClaimWriteLock(pTHS->pDB);
        }

    }
    __finally {
        THFreeEx(pTHS, pOwner);
        DBFindDNT(pTHS->pDB, dntSave);
    }

    return pTHS->errCode;
}

DWORD MakeNCEntry(IN DSNAME *pDN, OUT NAMING_CONTEXT_LIST **ppNCL)
/*
  Description:

    create a NC entry for a given DN

  Arguments:

    pDN (IN) -- the DN
    ppNCL (OUT) -- ptr to the resulting pNCL

  Returns:

    0 on success, !0 otherwise

*/
{
    THSTATE *pTHS = pTHStls;
    NAMING_CONTEXT_LIST *pNCL = NULL;
    ATTRBLOCK *pBNtmp = NULL, *pBNperm = NULL;
    unsigned err = 0;
    DBPOS *pDB;
    DWORD cbAncestors, *pAncestors = NULL, numAncestors;
    DSNAME *pDSName=NULL;

    Assert(pDN && ppNCL);

    __try {
        /* Make the new cache element. */
        pNCL = calloc(1, sizeof(NAMING_CONTEXT_LIST));
        if(! pNCL) {
            err = ERROR_OUTOFMEMORY;
            __leave;
        }
        pNCL->pNC = malloc(pDN->structLen);
        if(! pNCL->pNC) {
            err = ERROR_OUTOFMEMORY;
            __leave;
        }
        memcpy(pNCL->pNC, pDN, pDN->structLen);

        err = DSNameToBlockName(pTHS, pDN, &pBNtmp, DN2BN_LOWER_CASE);
        if (err) {
            // donh 10/8/96
            // Memory errors would have raised an exception, so the only failure
            // that would return an error code is from an invalid name.  But any
            // name that we're adding to the in-memory catalog should have already
            // been tested for correctness, and should *not* be rejected here.
            // While we can continue from this point with the only ill effect
            // being that the catalog will have no record of the invalid NC name,
            // we would like to catch any such invalid name and figure out how
            // it got here, hence the following assert.
            Assert(!"Invalid NC name added to catalog");
            LogUnhandledError(err);
            __leave;
        }
        pBNperm = MakeBlockNamePermanent(pBNtmp);
        if (!pBNperm) {
            err = ERROR_OUTOFMEMORY;
            __leave;
        }

        pNCL->pNCBlock = pBNperm;

        /* Grab the NCDNT, DelContDNT, and LostAndFoundDNT if there is one. */
        DBOpen(&pDB);
        __try {
            DBFindDSName(pDB, pDN);
            pNCL->NCDNT = pDB->DNT;
            pNCL->fReplNotify = DBHasValues(pDB,
                                           ATT_REPS_TO);
            GetWellKnownDNT(pDB,
                           (GUID *)GUID_DELETED_OBJECTS_CONTAINER_BYTE,
                           &pNCL->DelContDNT);
            GetWellKnownDNT(pDB,
                           (GUID *)GUID_LOSTANDFOUND_CONTAINER_BYTE,
                           &pNCL->LostAndFoundDNT);
            if(GetWellKnownDN(pDB,
                              (GUID *)GUID_NTDS_QUOTAS_CONTAINER_BYTE,
                              &pDSName))
            {
                pNCL->pNtdsQuotasDN = malloc(pDSName->structLen);
				if( pNCL->pNtdsQuotasDN == NULL){
					err = ERROR_OUTOFMEMORY;
					__leave;
                }
                memcpy(pNCL->pNtdsQuotasDN, pDSName, pDSName->structLen);
            }

            // read the ancestors out of the current object
            //
            pNCL->cbAncestors = cbAncestors = 0;
            pNCL->pAncestors = pAncestors = NULL;
            numAncestors = 0;

            DBGetAncestors (pDB, &cbAncestors, &pAncestors, &numAncestors);

            pNCL->pAncestors = malloc (cbAncestors);
            if (pNCL->pAncestors == NULL) {
                err = ERROR_OUTOFMEMORY;
                __leave;
            }
            pNCL->cbAncestors = cbAncestors;
            memcpy (pNCL->pAncestors, pAncestors, cbAncestors);

            THFreeEx (pTHS, pAncestors);

            // if the ntds quotas container exists
            if(pNCL->pNtdsQuotasDN) 
            {
                DBFindDSName(pDB, pNCL->pNtdsQuotasDN);
            
                //default quota
                err = DBGetSingleValue (pDB, 
                                        ATT_MS_DS_DEFAULT_QUOTA, 
                                        &pNCL->ulDefaultQuota,
                                        sizeof(pNCL->ulDefaultQuota),
                                        NULL);
                if (err){
                    if(err == DB_ERR_NO_VALUE) {
                        err = 0;
                        pNCL->ulDefaultQuota = g_ulQuotaUnlimited;
                    }
                    else {
                        __leave;
                    }
                }

                //tombstone quota factor
                err = DBGetSingleValue (pDB, 
                                        ATT_MS_DS_TOMBSTONE_QUOTA_FACTOR, 
                                        &pNCL->ulTombstonedQuotaWeight,
                                        sizeof(pNCL->ulTombstonedQuotaWeight),
                                        NULL);
                if (err){
                    if(err == DB_ERR_NO_VALUE) {
                        err = 0;
                        pNCL->ulTombstonedQuotaWeight = 100;
                    } else {
                        __leave;
                    }
                } else {
                    // verify we don't exceed 100%
                    //
                    // QUOTA_UNDONE: is it desirable to have a tombstoned
                    // object quota weight greater than 100% (ie. tombstoned
                    // objects are weighted more than live objects, in order
                    // to discourage tombstoning of objects, for whatever
                    // unknown reason)
                    //
                    pNCL->ulTombstonedQuotaWeight = min( pNCL->ulTombstonedQuotaWeight, 100 );
                }
            } else {
                // the default values for default quota and
                // tombstone quota factor.
                pNCL->ulDefaultQuota = g_ulQuotaUnlimited;
                pNCL->ulTombstonedQuotaWeight = 100;
            }
        } __finally {
            DBClose(pDB, !AbnormalTermination());
        }

        if (err != 0) {
            __leave;
        }

        // set the estimated entries in this NC to zero
        pNCL->ulEstimatedSize = 0;
        *ppNCL = pNCL;
    }
    __finally {
        if (err) {
            if (pNCL) {
                if (pNCL->pNC) {
                    free(pNCL->pNC);
                }
                if (pNCL->pNCBlock) {
                    free(pNCL->pNCBlock);
                }
                if (pNCL->pAncestors) {
                    free(pAncestors);
                }
                free(pNCL);
            }
        }
    }

    return err;
}

VOID FreeNCEntry(NAMING_CONTEXT_LIST *pNCL)
/*
  Description:

    frees memory allocated to NC entry (by MakeNCEntry)

  Arguments:

    pNCL (IN) -- the NC entry to free

*/
{
    free(pNCL->pNC);
    free(pNCL->pNCBlock);
    free(pNCL->pAncestors);
    free(pNCL);
}


// catalog enumerator functions
VOID
__fastcall
NCLEnumeratorInit(
    NCL_ENUMERATOR *pEnum,
    CATALOG_ID_ENUM catalogID
    )
/*
  Description:

    initialize enumerator. Record the "base" pointer -- the original list head ptr
    from gAnchor. If the enumerator is reset and walked again, consistent info is
    then returned -- even if the global list has changed since then. This is useful
    when the list is traversed first to count the number of entries and then again
    to copy them (see, e.g. ldapconv.cxx:LDAP_GetDSEAtts).

  Arguments:

    pEnum -- catalog enumerator object

    catalogID -- catalog ID

*/
{
    Assert(pEnum);

    // initialize enumerator
    pEnum->catalogID = catalogID;
    switch (catalogID) {
    case CATALOG_MASTER_NC:
        pEnum->pBase = gAnchor.pMasterNC;
        break;
    case CATALOG_REPLICA_NC:
        pEnum->pBase = gAnchor.pReplicaNC;
        break;
    default:
        Assert(!"Invalid catalog ID");
        return;
    }
    pEnum->filter = NCL_ENUMERATOR_FILTER_NONE; // no filter by default
    pEnum->matchValue = NULL;
    pEnum->pTHS = pTHStls;
    NCLEnumeratorReset(pEnum);
}

VOID
__fastcall
NCLEnumeratorSetFilter(
    NCL_ENUMERATOR *pEnum,
    NCL_ENUMERATOR_FILTER filter,
    PVOID value
    )
/*
  Description:

    sets the filter for the enumerator. The value to match is passed in a PVOID argument.

  Arguments:

    pEnum -- an initialized catalog enumerator object
    filter -- filter type
    value -- value to match

*/
{
    Assert(pEnum);
    pEnum->filter = filter;
    pEnum->matchValue = value;
}


VOID
__fastcall
NCLEnumeratorReset(
    NCL_ENUMERATOR *pEnum
    )
/*
  Description:

    resets the catalog enumerator to the first element

*/
{
    pEnum->pCurEntry = NULL;
    pEnum->pCurTransactionalData = NULL;
    pEnum->bNewEnumerator = TRUE;
    pEnum->matchResult = 0;
}

__inline
BOOL
NCLValueMatches(
    NCL_ENUMERATOR *pEnum
    )
/*
  Description:

    checks if current enumerator value matches its filter

  Arguments:

    pEnum -- an initialized catalog enumerator object

  Returns:

    TRUE if matches
*/
{

    Assert(pEnum && pEnum->pCurEntry);

    switch (pEnum->filter) {
    case NCL_ENUMERATOR_FILTER_NONE:
        return TRUE;

    case NCL_ENUMERATOR_FILTER_NCDNT:
        return (PVOID)UlongToPtr(pEnum->pCurEntry->NCDNT) == pEnum->matchValue;

    case NCL_ENUMERATOR_FILTER_NC:
        return NameMatched(pEnum->pCurEntry->pNC, (DSNAME*)pEnum->matchValue);

    case NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX1:
        pEnum->matchResult = BlockNamePrefix(pEnum->pTHS, pEnum->pCurEntry->pNCBlock, (ATTRBLOCK*)pEnum->matchValue);
        return pEnum->matchResult > 0;

    case NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX2:
        pEnum->matchResult = BlockNamePrefix(pEnum->pTHS, (ATTRBLOCK*)pEnum->matchValue, pEnum->pCurEntry->pNCBlock);
        return pEnum->matchResult > 0;

    default:
        Assert(!"Invalid NCL_ENUMERATOR_FILTER value");
        return TRUE;
    }
}

NAMING_CONTEXT_LIST*
__fastcall
NCLEnumeratorGetNext(
    NCL_ENUMERATOR *pEnum
    )
/*
  Description:

    return the next entry in the catalog or NULL if at end

  Arguments:

    pEnum -- an initialized catalog enumerator object

  Returns:

    ptr to the next element in the catalog or NULL if at the end
*/
{
    Assert(pEnum && pEnum->pTHS);

    if (!pEnum->pTHS->fCatalogCacheTouched) {
        // special fast case for non-modified catalogs

        // search for a matching entry
        while (TRUE) {
            if (pEnum->bNewEnumerator) {
                pEnum->pCurEntry = pEnum->pBase;
                pEnum->bNewEnumerator = FALSE;
            }
            else if (pEnum->pCurEntry != NULL) {
                // switch to the next one
                pEnum->pCurEntry = pEnum->pCurEntry->pNextNC;
            }

            if (pEnum->pCurEntry == NULL) {
                return NULL; // got to the end
            }

            if (NCLValueMatches(pEnum)) {
                // got a matching value! return it
                return pEnum->pCurEntry;
            }

        }
    }
    else {
        /*
         * Each entry is checked for deletion. After the global
         * list, all local added lists are enumerated (in order
         * from inner transaction to outer transaction).
         */
        BOOL bIsDeleted;
        DWORD i;
        CATALOG_UPDATES *pCatUpdates;
        NESTED_TRANSACTIONAL_DATA *pCurNTD;


        // infinite loop to find a non-deleted entry
        while (TRUE) {
            if (pEnum->pCurEntry != NULL) {
                // just switch to the next one
                pEnum->pCurEntry = pEnum->pCurEntry->pNextNC;
            }
            else {
                // need to change the list we are currently looking at
                if (pEnum->bNewEnumerator) {
                    // newly initialized enumerator. Grab the global list first
                    pEnum->pCurEntry = pEnum->pBase;
                    pEnum->bNewEnumerator = FALSE;
                }
                else {
                    // not a new enumerator. Must have passed through some entries and got to the end of a list
                    // switch to the next list
                    if (pEnum->pCurTransactionalData == NULL) {
                        // went through the global list. Switch to transactional data.
                        if (pEnum->pTHS->JetCache.dataPtr == NULL) {
                            // no transactional data! can happen during dcpromo/initialization
                            return NULL;
                        }
                        // Switch to the first level of transactional data
                        pEnum->pCurTransactionalData = pEnum->pTHS->JetCache.dataPtr;
                    }
                    else {
                        // already went through some levels of transactional data. Switch to the outer level
                        if (pEnum->pCurTransactionalData->pOuter == NULL) {
                            // no more levels. That's it
                            return NULL;
                        }
                        // can not do this before the if: setting pCurTransactionalData to NULL essentially
                        // resets the enumerator to "got to the end of global list" state. We don't want this.
                        pEnum->pCurTransactionalData = pEnum->pCurTransactionalData->pOuter;
                    }
                    switch (pEnum->catalogID) {
                    case CATALOG_MASTER_NC:
                        pEnum->pCurEntry = pEnum->pCurTransactionalData->objCachingInfo.masterNCUpdates.pAddedEntries;
                        break;
                    case CATALOG_REPLICA_NC:
                        pEnum->pCurEntry = pEnum->pCurTransactionalData->objCachingInfo.replicaNCUpdates.pAddedEntries;
                        break;
                    default:
                        Assert(!"Invalid catalog ID");
                        return NULL;
                    }
                }
            }

            if (pEnum->pCurEntry == NULL) {
                continue; // got to the end of this list... will switch to the next list
            }

            // got an entry... before doing deleted check, figure out if it matches the filter!
            if (!NCLValueMatches(pEnum)) {
                // does not match the filter, will grab the next one
                continue;
            }

            // Entry matches the filter. Check that it has not been deleted.
            bIsDeleted = FALSE;
            // Scan deleted entries in transactional data.
            // If we are looking at a global entry, then pCurTransactionalData == NULL,
            // then we will check for deletion on all levels.
            // If we are looking at an added entry, i.e. pCurTransactionalData != NULL,
            // then we only need to check all levels from the lowest one to the level
            // immediately below the one where the entry was added. It could not have
            // been marked as deleted at the same level because deletions on the same level
            // are explicit. It could not have been deleted at any level above since it did
            // not exist back then.
            for (pCurNTD = pEnum->pTHS->JetCache.dataPtr;
                 pCurNTD != NULL && pCurNTD != pEnum->pCurTransactionalData;
                 pCurNTD = pCurNTD->pOuter) {

                switch (pEnum->catalogID) {
                case CATALOG_MASTER_NC:
                    pCatUpdates = &pCurNTD->objCachingInfo.masterNCUpdates;
                    break;
                case CATALOG_REPLICA_NC:
                    pCatUpdates = &pCurNTD->objCachingInfo.replicaNCUpdates;
                    break;
                default:
                    Assert(!"Invalid catalog ID");
                    return NULL;
                }

                for (i = 0; i < pCatUpdates->dwDelCount; i++) {
                    // Note: the catalog data might have been updated since we dropped
                    // the NCL element into the deleted array somewhere in the middle of
                    // this transaction. Thus, use NameMatched to compare entries.
                    if (NameMatched(pCatUpdates->pDeletedEntries[i]->pNC, pEnum->pCurEntry->pNC)) {
                        // yes, found this entry in deleted list
                        bIsDeleted = TRUE;
                        break;
                    }
                }
                if (bIsDeleted) {
                    break; // get out of the pCurNTD loop
                }
            }
            if (bIsDeleted) {
                continue; // nope, this one is deleted... keep iterating
            }

            // found a good one! return it
            return pEnum->pCurEntry;
        }
    }
}

// catalog modification functions
DWORD
CatalogAddEntry(
    NAMING_CONTEXT_LIST *pNCL,
    CATALOG_ID_ENUM catalogID
    )
/*
  Description:

    Add an entry to the catalog. This is added to the local transactional data list.

  Arguments:

    pNCL -- entry to add

    catalogID -- catalog ID

  Returns:

    0 on success

*/
{
    CATALOG_UPDATES *pCatUpdates;
    THSTATE *pTHS = pTHStls;
    NAMING_CONTEXT_LIST *pCurEntry;
    DWORD i;

    Assert(pNCL || pTHS);

    switch (catalogID) {
    case CATALOG_MASTER_NC:
        pCatUpdates = &pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates;
        break;
    case CATALOG_REPLICA_NC:
        pCatUpdates = &pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates;
        break;
    default:
        Assert(!"Invalid catalog ID");
        return 1;
    }

    // Insert into the end of the added list. At the same time check for duplicates...
    for (pCurEntry = pCatUpdates->pAddedEntries; pCurEntry != NULL; pCurEntry = pCurEntry->pNextNC) {
        if (pCurEntry == pNCL) {
            // duplicate found!
            DPRINT1(0, "Attempting to add a duplicate entry into the catalog, NC=%S\n", pNCL->pNC->StringName);
            return 0;
        }
        if (pCurEntry->pNextNC == NULL) {
            // found last entry
            break;
        }
    }
    // add entry
    if (pCurEntry == NULL) {
        // empty list -- add to the beginning
        pCatUpdates->pAddedEntries = pNCL;
    }
    else {
        // add after the last entry
        pCurEntry->pNextNC = pNCL;
    }
    pNCL->pNextNC = NULL;

    // set the flag that the cache was touched
    pTHS->fCatalogCacheTouched = TRUE;

    return 0;
}

// grow the deleted list this many entries at a time
#define DELETED_ARRAY_DELTA 5

DWORD
CatalogRemoveEntry(
    NAMING_CONTEXT_LIST *pNCL,
    CATALOG_ID_ENUM catalogID
    )
/*
  Description:

    Remove an entry from the catalog. It is added to the local transactional data
    deleted list. One exception is when deleting an entry that has been previously
    added. In this case, it is simply removed from the added list.

    WARNING! WARNING! Deleting an entry *may* cause an AV in a following CatalogGetNext
    if you are trying to enumerate catalog at the same time and the deleted item is
    current in this enumerator. This situation only happens if the deleted item was
    added previously in the same transaction (this is the only case when it will get
    immediately freed).

    To be on the safe side, delete the entry only after grabbing the next one with
    CatalogGetNext. Or simply don't call CatalogGetNext after deleting the current
    entry.

  Arguments:

    pNCL -- entry to delete

    catalogID -- catalog ID

  Returns:

    0 on success

*/
{
    CATALOG_UPDATES *pCatUpdates;
    THSTATE *pTHS = pTHStls;
    NAMING_CONTEXT_LIST *pCurEntry, *pPrevEntry;

    Assert(pNCL || pTHS);

    switch (catalogID) {
    case CATALOG_MASTER_NC:
        pCatUpdates = &pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates;
        break;
    case CATALOG_REPLICA_NC:
        pCatUpdates = &pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates;
        break;
    default:
        Assert(!"Invalid catalog ID");
        return 1;
    }

    if (pTHS->fCatalogCacheTouched) {
        // first, check in the added list. Need to keep ptr to the previous
        // entry to perform list deletion
        for (pCurEntry = pCatUpdates->pAddedEntries, pPrevEntry = NULL;
             pCurEntry != NULL;
             pPrevEntry = pCurEntry, pCurEntry = pCurEntry->pNextNC) {
            if (pCurEntry == pNCL) {
                // found in the added list!
                if (pPrevEntry == NULL) {
                    // must be the first one. Just move the list head ptr
                    pCatUpdates->pAddedEntries = pCurEntry->pNextNC;
                }
                else {
                    // we are somewhere in the middle of the list. Switch the prev ptr
                    pPrevEntry->pNextNC = pCurEntry->pNextNC;
                }
                // since this was our local addition, we should free the memory...
                FreeNCEntry(pNCL);

                // that's it
                return 0;
            }
        }
    }

    // not found in the transactional added list. So, insert into the deleted list
    if (pCatUpdates->dwDelCount == pCatUpdates->dwDelLength) {
        // need to make the array larger...
        if (pCatUpdates->pDeletedEntries == NULL) {
            // fresh new array
            pCatUpdates->pDeletedEntries =
                (NAMING_CONTEXT_LIST**) THAllocOrgEx(pTHS,
                                                     DELETED_ARRAY_DELTA * sizeof(NAMING_CONTEXT_LIST*));
        }
        else {
            // growing existing array, realloc it
            pCatUpdates->pDeletedEntries =
                (NAMING_CONTEXT_LIST**) THReAllocOrgEx(pTHS, pCatUpdates->pDeletedEntries,
                                                       (pCatUpdates->dwDelLength + DELETED_ARRAY_DELTA) * sizeof(NAMING_CONTEXT_LIST*));
        }
        pCatUpdates->dwDelLength += DELETED_ARRAY_DELTA;
    }
    // now add the ptr to the deleted list
    pCatUpdates->pDeletedEntries[pCatUpdates->dwDelCount] = pNCL;
    pCatUpdates->dwDelCount++;

    // set the flag that the cache was touched
    pTHS->fCatalogCacheTouched = TRUE;
    return 0;
}

VOID CatalogUpdatesInit(CATALOG_UPDATES *pCatUpdates)
/*
  Description:

    Initialize CATALOG_UPDATES structure

  Arguments:

    pCatUpdates - ptr to the struct to initialize

*/
{
    Assert(pCatUpdates);
    memset(pCatUpdates, 0, sizeof(CATALOG_UPDATES));
}

VOID CatalogUpdatesFree(CATALOG_UPDATES *pCatUpdates)
/*
  Description:

    free the memory allocated for catalog updates

  Arguments:

    pCatUpdates - ptr to the struct
*/
{
    THSTATE *pTHS = pTHStls;
    NAMING_CONTEXT_LIST *pNCL;

    Assert(pTHS);

    // first check for simple cases
    if (!pTHS->fCatalogCacheTouched) {
        // no modifications occured in this transaction!
        return;
    }

    THFreeOrg(pTHS, pCatUpdates->pDeletedEntries);
    pCatUpdates->pDeletedEntries = NULL;
    pCatUpdates->dwDelLength = 0;
    pCatUpdates->dwDelCount = 0;

    while (pNCL = pCatUpdates->pAddedEntries) {
        pCatUpdates->pAddedEntries = pNCL->pNextNC;
        FreeNCEntry(pNCL);
    }
}

VOID CatalogUpdatesMerge(CATALOG_UPDATES *pCUouter, CATALOG_UPDATES *pCUinner)
/*
  Description:

    append catalog updates in pCUinner to the ones in pCUouter. All memory allocated for
    inner is released (or moved into the outer as needed).

    This function is used when a nested transaction is commited and the changes
    must be appended to the outer NESTED_TRANSACTIONAL_DATA structure.

    We need to scan the added list in outer and deleted list in inner. If an entry that
    has been added in outer was deleted in inner, then they cancel each other.

    Then the lists of added and deleted entries remaining in inner are appended to outer.

  Arguments:

    pCUouter - outer updates list

    pCUinner - inner updates list

*/
{
    NAMING_CONTEXT_LIST *pCurEntry, *pPrevEntry, *pNCL;
    DWORD i;
    BOOL bIsDeleted;
    THSTATE *pTHS = pTHStls;

    Assert(pTHS && pCUouter && pCUinner);

    // first check for simple cases
    if (!pTHS->fCatalogCacheTouched) {
        // no modifications occured in this transaction!
        return;
    }

    if (pCUinner->dwDelCount == 0 && pCUinner->pAddedEntries == NULL) {
        // inner lists are empty, no changes to outer
        if (pCUinner->dwDelLength > 0) {
            THFreeOrg(pTHS, pCUinner->pDeletedEntries);
            pCUinner->dwDelLength = 0;
            pCUinner->pDeletedEntries = NULL;
        }
        return;
    }
    if (pCUouter->dwDelCount == 0 && pCUouter->pAddedEntries == NULL) {
        // outer is empty -- just inherit inner's data
        if (pCUouter->dwDelLength > 0) {
            // there was some memory allocated for deleted entries (but none used at the moment)
            // release it
            THFreeOrg(pTHS, pCUouter->pDeletedEntries);
        }
        pCUouter->dwDelCount = pCUinner->dwDelCount;
        pCUouter->dwDelLength = pCUinner->dwDelLength;
        pCUouter->pDeletedEntries = pCUinner->pDeletedEntries;
        pCUouter->pAddedEntries = pCUinner->pAddedEntries;

        // reset inner so that we can free it safely
        pCUinner->dwDelCount = 0;
        pCUinner->dwDelLength = 0;
        pCUinner->pDeletedEntries = NULL;
        pCUinner->pAddedEntries = NULL;

        // that's it
        return;
    }

    if (pCUinner->dwDelCount > 0) {
        // scan added list in outer and remove any entries that are marked as deleted in inner
        pCurEntry = pCUouter->pAddedEntries;
        pPrevEntry = NULL; // need to keep prevEntry pointer to perform deletes
        while (pCurEntry != NULL) {
            // scan deleted entries
            bIsDeleted = FALSE;
            for (i = 0; i < pCUinner->dwDelCount; i++) {
                if (pCurEntry == pCUinner->pDeletedEntries[i]) {
                    // it's been deleted!
                    bIsDeleted = TRUE;
                    break;
                }
            }
            if (bIsDeleted) {
                // cancel both entries

                // remove deleted entry
                pCUinner->dwDelCount--;
                pCUinner->pDeletedEntries[i] = pCUinner->pDeletedEntries[pCUinner->dwDelCount];

                // remove added entry
                if (pPrevEntry == NULL) {
                    // first in the added list!
                    pCUouter->pAddedEntries = pCurEntry->pNextNC;
                }
                else {
                    // non first, update prevEntry's next pointer
                    pPrevEntry->pNextNC = pCurEntry->pNextNC;
                }
                pNCL = pCurEntry;
                pCurEntry = pCurEntry->pNextNC;
                FreeNCEntry(pNCL);

                if (pCUinner->dwDelCount == 0) {
                    // no more non-cancelled entries left... Leave the loop
                    THFreeOrg(pTHS, pCUinner->pDeletedEntries);
                    pCUinner->pDeletedEntries = NULL;
                    pCUinner->dwDelLength = 0;

                    break;
                }
            }
            else {
                // not deleted, go on
                pPrevEntry = pCurEntry;
                pCurEntry = pCurEntry->pNextNC;
            }
        }
    }

    if (pCUinner->pAddedEntries != NULL) {
        // append inner added entries to the outer added list

        // find the end of the outer list
        for (pCurEntry = pCUouter->pAddedEntries; pCurEntry != NULL; pCurEntry = pCurEntry->pNextNC) {
            if (pCurEntry->pNextNC == NULL) {
                // found the end!
                break;
            }
        }
        if (pCurEntry == NULL) {
            // list was empty, adjust the head ptr
            pCUouter->pAddedEntries = pCUinner->pAddedEntries;
        }
        else {
            // non-empty list, append to the last entry
            pCurEntry->pNextNC = pCUinner->pAddedEntries;
        }
        // let go ptr in inner
        pCUinner->pAddedEntries = NULL;
    }

    if (pCUinner->dwDelCount > 0) {
        // append inner deleted entries list to outer deleted entries list
        if (pCUouter->dwDelCount == 0) {
            // no deleted in outer -- just move the list

            if (pCUouter->dwDelLength > 0) {
                // there was an alloced buffer, but no entries in it
                THFreeOrg(pTHS, pCUouter->pDeletedEntries);
            }

            pCUouter->pDeletedEntries = pCUinner->pDeletedEntries;
            pCUouter->dwDelCount = pCUinner->dwDelCount;
            pCUouter->dwDelLength = pCUinner->dwDelLength;

            pCUinner->pDeletedEntries = NULL;
            pCUinner->dwDelCount = 0;
            pCUinner->dwDelLength = 0;
        }
        else {
            // hardest case -- must append list
            if (pCUouter->dwDelCount + pCUinner->dwDelCount > pCUouter->dwDelLength) {
                // not enough memory, alloc more (we know that some was already alloced!)
                pCUouter->pDeletedEntries = (NAMING_CONTEXT_LIST**)
                    THReAllocOrgEx(pTHS,
                                   pCUouter->pDeletedEntries,
                                   (pCUouter->dwDelCount + pCUinner->dwDelCount) * sizeof(NAMING_CONTEXT_LIST*));
                pCUouter->dwDelLength = pCUouter->dwDelCount + pCUinner->dwDelCount;
            }
            // now we are ready to copy
            memcpy(pCUouter->pDeletedEntries + pCUouter->dwDelCount,
                   pCUinner->pDeletedEntries,
                   pCUinner->dwDelCount * sizeof(NAMING_CONTEXT_LIST*));
            pCUouter->dwDelCount += pCUinner->dwDelCount;

            // reset inner
            THFreeOrg(pTHS, pCUinner->pDeletedEntries);
            pCUinner->pDeletedEntries = NULL;
            pCUinner->dwDelCount = 0;
            pCUinner->dwDelLength = 0;
        }
    }
    else if (pCUinner->dwDelLength > 0) {
        // release empty buffer in inner
        THFreeOrg(pTHS, pCUinner->pDeletedEntries);
        pCUinner->pDeletedEntries = NULL;
        pCUinner->dwDelLength = 0;
    }

    // that's all folks!
    return;
}

#define DelayedFreeInterval 3600

BOOL
CatalogUpdatesApply(
    CATALOG_UPDATES *pCatUpdates,
    NAMING_CONTEXT_LIST **pGlobalList
    )
/*
  Description:

    Apply catalog updates stored in pUpdates to the global NC list pGlobalList.
    pGlobalList must be either gAnchor.pMasterNC or gAnchor.pReplicaNC.
    In order to update the list, gAnchor.CSUpdate is acquired. The unneeded memory
    allocated for updates list is freed.

    Note: this approach is not quite thread-safe. Since this operation is performed
    AFTER commit of a transaction and is not blocked with this commit, it is possible
    that the data will get out of sync if two simultaneous transactions are getting
    commited and the global data is updated in the wrong order (i.e. delete/add instead
    of add/delete). We are ensuring that we converge to the correct state by scheduling
    a CatalogRebuild in near future.

    Note: this is called from a post-process transactional data routine. WE CAN NOT FAIL!
    So, if we can not alloc memory for delayed freeing, we are going to LEAK memory.

  Arguments:

    pCatUpdates -- updates to apply

    pGlobalList -- either gAnchor.pMasterNC or gAnchor.pReplicaNC

  Returns:

    TRUE if catalog was, in fact, changed; FALSE otherwise

*/
{
    NAMING_CONTEXT_LIST *pNCL, *pPrevEntry, *pNewList, *pNewNCL;
    DWORD i, curIndex;
    BOOL bIsDeleted;
    DWORD cpapv;
    DWORD_PTR *papv = NULL;
    THSTATE *pTHS = pTHStls;

    Assert(pCatUpdates && pTHS);

    // first check for simple cases
    if (!pTHS->fCatalogCacheTouched || (pCatUpdates->dwDelCount == 0 && pCatUpdates->pAddedEntries == NULL)) {
        // no modifications occured in this transaction! nothing to do
        if (pCatUpdates->dwDelLength > 0) {
            // throw away empty buffer
            THFreeOrg(pTHS, pCatUpdates->pDeletedEntries);
            pCatUpdates->dwDelLength = 0;
            pCatUpdates->pDeletedEntries = NULL;
        }
        return FALSE;
    }

    Assert(pGlobalList && (*pGlobalList == gAnchor.pMasterNC || *pGlobalList == gAnchor.pReplicaNC) &&
           "CatalogUpdatesApply can only be called on gAnchor.pMasterNC or gAnchor.pReplicaNC");

    // we need to recreate the global list from scratch here. This is because some NCLEnumerators
    // might have aquired a ptr to the list and they want to get a consistent view.

    // no try-finally since no exception can be raised in this code
    EnterCriticalSection(&gAnchor.CSUpdate);

    // allocate buffer for delayed freeing entries
    cpapv = 0;
    for (pNCL = *pGlobalList; pNCL != NULL; pNCL = pNCL->pNextNC) {
        cpapv++;
    }
    // we will reuse internal data stored incide non-deleted NCLs, but for the deleted ones will
    // need to free the 3 internal data ptrs as well...
    cpapv += 3*pCatUpdates->dwDelCount;

    if (cpapv > 0) {
        papv = (DWORD_PTR*) malloc((cpapv+1) * sizeof(DWORD_PTR)); // extra one for the count
        if (papv == NULL) {
            MemoryPanic((cpapv+1) * sizeof(DWORD_PTR));
            // this is too bad... Ah well, let's leak memory. We will check papv before writing...
        }
    }

    curIndex = 0;
    pNewList = pPrevEntry = NULL;
    for (pNCL = *pGlobalList; pNCL != NULL; pNCL = pNCL->pNextNC) {
        // mark pNCL for delay-freeing
        if (papv != NULL) {
            Assert(curIndex+1 <= cpapv);
            papv[++curIndex] = (DWORD_PTR)pNCL;
        }

        // check if it was deleted
        bIsDeleted = FALSE;
        for (i = 0; i < pCatUpdates->dwDelCount; i++) {
            // Note: the catalog data might have been updated since we dropped
            // the NCL element into the deleted array somewhere in the middle of
            // this transaction. Thus, use NameMatched to compare entries.
            //
            // Note that a catalog could have been rebuilt between the time
            // this transaction was commited and CatalogUpdatesApply. In this
            // case we will not find the deleted NCL in the catalog.
            if (NameMatched(pCatUpdates->pDeletedEntries[i]->pNC, pNCL->pNC)) {
                // aha, deleted
                bIsDeleted = TRUE;
                break;
            }
        }
        if (bIsDeleted) {
            // we need to delay free internal data members
            if (papv) {
                Assert(curIndex + 3 <= cpapv);
                papv[++curIndex] = (DWORD_PTR)pNCL->pNC;
                papv[++curIndex] = (DWORD_PTR)pNCL->pNCBlock;
                papv[++curIndex] = (DWORD_PTR)pNCL->pAncestors;
            }
        }
        else {
            // this one is not deleted. Need to copy it into the new list
            pNewNCL = (NAMING_CONTEXT_LIST*)malloc(sizeof(NAMING_CONTEXT_LIST));
            if (pNewNCL != NULL) {
                // copy data
                memcpy(pNewNCL, pNCL, sizeof(NAMING_CONTEXT_LIST));
                pNewNCL->pNextNC = NULL;
                // and append it to the end of the new list
                if (pPrevEntry == NULL) {
                    // first one!
                    pNewList = pNewNCL;
                }
                else {
                    // not the first one
                    pPrevEntry->pNextNC = pNewNCL;
                }
                pPrevEntry = pNewNCL;
            }
            else {
                // this is too bad... we will have to go without the NC list then...
                MemoryPanic(sizeof(NAMING_CONTEXT_LIST));
            }
        }
    }

    // now, append added entries
    if (pCatUpdates->pAddedEntries != NULL) {
        if (pNewList == NULL) {
            // list was empty
            pNewList = pCatUpdates->pAddedEntries;
        }
        else {
            Assert(pPrevEntry != NULL);
            // append to the list
            pPrevEntry->pNextNC = pCatUpdates->pAddedEntries;
        }
        pCatUpdates->pAddedEntries = NULL;
    }

    // now we can update the global list ptr
    *pGlobalList = pNewList;

    LeaveCriticalSection(&gAnchor.CSUpdate);

    // now we can delay-free memory (if any)
    if (papv != NULL) {
        papv[0] = (DWORD_PTR)curIndex;
        DelayedFreeMemoryEx(papv, DelayedFreeInterval);
    }

    // and get rid of deleted array (if any)
    if (pCatUpdates->dwDelLength > 0) {
        THFreeOrg(pTHS, pCatUpdates->pDeletedEntries);
        pCatUpdates->pDeletedEntries = NULL;
        pCatUpdates->dwDelCount = 0;
        pCatUpdates->dwDelLength = 0;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdmod.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdmod.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirModifyEntry API.

    DirModifyEntry() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h> 
#include <scache.h>                     // schema cache 
#include <prefix.h>                     // prefix table
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header 
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation 
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <gcverify.h>                   // GC DSNAME verification
#include <ntdsctr.h>                    // Perf Hook
#include <dsconfig.h>

// SAM interoperability headers
#include <mappings.h>
                         
// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    // header Audit\Alert logging 
#include "dsexcept.h"
#include "mdcodes.h"                    // header for error codes 

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include <permit.h>                     // permission constants 
#include "debug.h"                      // standard debugging header 
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#include <filtypes.h>

#define DEBSUB "MDMOD:"                 // define the subsystem for debugging 

#include <fileno.h>
#define  FILENO FILENO_MDMOD

#include <NTDScriptExec.h>

/* MACROS */

/* Internal functions */

int InvalidIsDefunct(IN MODIFYARG *pModifyArg, 
                     OUT BOOL *fIsDefunctPresent,
                     OUT BOOL *fIsDefunct);
int CheckForSafeSchemaChange(THSTATE *pTHS, 
                             MODIFYARG *pModifyArg, 
                             CLASSCACHE *pCC);
int ModSetAtts(THSTATE *pTHS, 
               MODIFYARG *pModifyArg,
               CLASSCACHE **ppClassSch,
               CLASSSTATEINFO  **ppClassInfo,
               ATTRTYP rdnType,
               BOOL fIsUndelete,
               LONG *forestVersion,
               LONG *domainVersion,
               ULONG *pcNonReplAtts,
               ATTRTYP **ppNonReplAtts);

BOOL SysModReservedAtt(THSTATE *pTHS,
                       ATTCACHE *pAC,
                       CLASSCACHE *pClassSch);
int ApplyAtt(THSTATE *pTHS,
             DSNAME *pObj,
             HVERIFY_ATTS hVerifyAtts,
             ATTCACHE *pAC,
             ATTRMODLIST *pAttList,
             COMMARG *pCommArg);
int ModCheckSingleValue (THSTATE *pTHS,
                         MODIFYARG *pModifyArg,
                         CLASSCACHE *pClassSch);
int ModCheckCatalog(THSTATE *pTHS,
                    RESOBJ *pResObj);

BOOL IsValidBehaviorVersionChange(THSTATE * pTHS, 
                                  ATTRMODLIST *pAttrToModify,
                                  MODIFYARG *pModifyArg,
                                  CLASSCACHE *pClassSch,
                                  LONG *pNewForestVersion,
                                  LONG *pNewDomainVersion );

DWORD VerifyNoMixedDomain(THSTATE *pTHS);

DWORD VerifyNoOldDC(THSTATE * pTHS, LONG lNewVersion, BOOL fDomain, PDSNAME *ppDSA);

DWORD forestVersionRunScript(THSTATE *pTHS,DWORD oldVersion, DWORD newVersion);

DWORD ValidateDsHeuristics(
    DSNAME       *pObject,
    ATTRMODLIST  *pAttList
    );


int
ModAutoSubRef(
    THSTATE *pTHS,
    ULONG id,
    MODIFYARG *pModArg
    );

extern BOOL gfRestoring;

BOOL isModUndelete(MODIFYARG* pModifyArg);
DWORD UndeletePreProcess(THSTATE* pTHS, MODIFYARG* pModifyArg, DSNAME** pNewDN);
DWORD UndeletePostProcess(THSTATE* pTHS, MODIFYARG* pModifyArg, DSNAME* pNewDN);

ULONG AppendNonReplAttsToModifiedList(THSTATE *pTHS, 
                                      ULONG * pcModAtts,
                                      ATTRTYP **ppModAtts, 
                                      ULONG * pcNonReplAtts, 
                                      ATTRTYP **ppNonReplAtts);

BOOL isModSDChangeOnly(MODIFYARG* pModifyArg);

BOOL isWellKnownObjectsChangeAllowed(    
    THSTATE*        pTHS, 
    ATTRMODLIST*    pAttrModList,
    MODIFYARG*      pModifyArg,
    HVERIFY_ATTS    hVerifyAtts
    );



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirModifyEntry(
    MODIFYARG*  pModifyArg,     /* ModifyEntry  argument */
    MODIFYRES** ppModifyRes
    )
{

    THSTATE*     pTHS;
    MODIFYRES *  pModifyRes;
    BOOL           fContinue;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    BOOL  RecalcSchemaNow=FALSE;
    BOOL  fIsUndelete;


    DPRINT1(1,"DirModifyEntry(%ws) entered\n",pModifyArg->pObject->StringName);


    // This operation should not be performed on read-only objects.
    pModifyArg->CommArg.Svccntl.dontUseCopy = TRUE;

    /* Initialize the THSTATE anchor and set a write sync-point.  This sequence
       is required on every API transaction.  First the state DS is initialized
       and then either a read or a write sync point is established.
       */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    pTHS->fLazyCommit |= pModifyArg->CommArg.fLazyCommit;
    *ppModifyRes = pModifyRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppModifyRes = pModifyRes = THAllocEx(pTHS, sizeof(MODIFYRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

        // GC verification intentially performed outside transaction scope.
        if ( GCVerifyDirModifyEntry(pModifyArg) )
            leave;
        SYNC_TRANS_WRITE();       /* Set Sync point*/
        __try {

            // Inhibit update operations if the schema hasen't been loaded yet
            // or if we had a problem loading.

            if (!gUpdatesEnabled){
                DPRINT(2, "Returning BUSY because updates are not enabled yet\n");
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_SCHEMA_NOT_LOADED);
                __leave;
            }

            // Perform name resolution to locate object.  If it fails, just 
            // return an error, which may be a referral. Note that we must
            // demand a writable copy of the object.
            pModifyArg->CommArg.Svccntl.dontUseCopy = TRUE;

            fIsUndelete = isModUndelete(pModifyArg);
            // if we are doing undelete, then we need to improve
            // the name to be the string name. This is required
            // to do the move in UndeletePostProcess.
            if (0 == DoNameRes(pTHS,
                               fIsUndelete ? NAME_RES_IMPROVE_STRING_NAME : 0,
                               pModifyArg->pObject,
                               &pModifyArg->CommArg,
                               &pModifyRes->CommRes,
                               &pModifyArg->pResObj)){

                DSNAME* pNewDN;
                 
                if (fIsUndelete) {
                    // do the undelete pre-processing: check security,
                    // reset isDeleted flag, etc.
                    if (UndeletePreProcess(pTHS, pModifyArg, &pNewDN) != 0) {
                        __leave;
                    }
                }

                /* Local Modify operation */
                if ( (0 == SampModifyLoopbackCheck(pModifyArg, &fContinue, fIsUndelete)) &&
                    fContinue ) {
                    LocalModify(pTHS, pModifyArg);
                }
                
                if (fIsUndelete && pTHS->errCode == 0) {
                    // modify was successful, finish the undelete operation:
                    // do the move to the final destination
                    UndeletePostProcess(pTHS, pModifyArg, pNewDN);
                }
            }
        }
        __finally {
            if (pTHS->errCode != securityError) {
                /* Security errors are logged separately */
                BOOL fFailed = (BOOL)(pTHS->errCode || AbnormalTermination());

                LogEventWithFileNo(
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         fFailed ? 
                            DS_EVENT_SEV_EXTENSIVE :
                            DS_EVENT_SEV_INTERNAL,
                         fFailed ? 
                            DIRLOG_PRIVILEGED_OPERATION_FAILED :
                            DIRLOG_PRIVILEGED_OPERATION_PERFORMED,
                         szInsertSz(""),
                         szInsertDN(pModifyArg->pObject),
                         NULL,
                         FILENO);
            }

            CLEAN_BEFORE_RETURN (pTHS->errCode);

            // Check if we need to enque an immediate schema update or not.
            if (pTHS->errCode==0 && pTHS->RecalcSchemaNow)
            {
                RecalcSchemaNow = TRUE;
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pModifyRes) {
        pModifyRes->CommRes.errCode = pTHS->errCode;
        pModifyRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    if (RecalcSchemaNow)
    {
        SCSignalSchemaUpdateImmediate();
        //
        // [rajnath][4/22/1997]: This will be the place to 
        // syncronize this call with the completion of the schema
        // cache update using an event which is set by the above 
        // call.
        //
    }

    return pTHS->errCode;

} /*DirModifyEntry*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Find the base object.  If the object already exists or if the object
   name has a syntax problem, return an error.
*/

int LocalModify(THSTATE *pTHS, MODIFYARG *pModifyArg){

    CLASSCACHE     *pClassSch;
    PROPERTY_META_DATA_VECTOR *pMetaData = NULL;
    USN usnChange;
    int aliveStatus;
    ULONG ulRet;
    ULONG iClass, LsaClass=0;
    DWORD ActiveContainerID=0;
    BOOL  RoleTransferInvolved;
    BOOL  IsMixedModeChange;
    BOOL  SamClassReferenced;
    DOMAIN_SERVER_ROLE NewRole;
    DWORD dwMetaDataFlags = META_STANDARD_PROCESSING;
    ULONG cModAtts;
    ATTRTYP *pModAtts = NULL;
    ULONG cNonReplAtts;
    ATTRTYP *pNonReplAtts = NULL;
    ULONG err;
    BOOL fCheckSPNValues = FALSE;
    BOOL fCheckDNSHostNameValues = FALSE;
    BOOL fCheckAdditionalDNSHostNameValues = FALSE;
    CLASSSTATEINFO  *pClassInfo = NULL;
    ATTRTYP rdnType;
    BOOL fIsUndelete;
    LONG newForestVersion=0, newDomainVersion=0;

    DPRINT(2,"LocalModify entered \n");

    PERFINC(pcTotalWrites);
    INC_WRITES_BY_CALLERTYPE( pTHS->CallerType );

    Assert(pModifyArg->pResObj);

    //
    // Log Event for tracing
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_MODIFY,
                     EVENT_TRACE_TYPE_START,
                     DsGuidModify,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertDN(pModifyArg->pObject),
                     NULL, NULL, NULL, NULL, NULL, NULL);

    // is this an undelete operation?
    fIsUndelete = isModUndelete(pModifyArg);

    // Verify write rights for all attributes being modified.
    if (CheckModifySecurity(pTHS,
                            pModifyArg,
                           &fCheckDNSHostNameValues,
                           &fCheckAdditionalDNSHostNameValues,
                           &fCheckSPNValues,
                           fIsUndelete)) {
        goto exit;
    }

    if (pTHS->fDRA) {
        // beyond CheckModifySecurity() (where quota counts get updated)
        // replication doesn't need knowledge of whether this is an
        // Undelete, so unequivocally reset the flag
        fIsUndelete = FALSE;
    }

    // Determine object's class by checking attributes offered
    // (replication only) or reading from object in database.
    if (!(pClassSch = SCGetClassById(pTHS, 
                                     pModifyArg->pResObj->MostSpecificObjClass))){
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           ERROR_DS_OBJECT_CLASS_REQUIRED);
        goto exit;

    }

    // Check if the class is defunct. We don't allow
    // modification of instances of defunct classes, except for DRA 
    // or DSA thread
    if ((pClassSch->bDefunct)  && !pTHS->fDRA && !pTHS->fDSA) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           ERROR_DS_OBJECT_CLASS_REQUIRED);
        goto exit;
    }

    switch(pClassSch->ClassId) {
    case CLASS_LOST_AND_FOUND:
        // Don't allow modifications to Lost And Found containers
        if (!pTHS->fDRA && !pTHS->fSDP)
        {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_ILLEGAL_MOD_OPERATION);
            goto exit;
        }
        break;

    case CLASS_SUBSCHEMA:
        // Don't allow modification to the subschema object
        if (   pTHS->fDRA
            || pTHS->fDSA 
            || pTHS->fSDP 
            || gAnchor.fSchemaUpgradeInProgress) 
        {
            // except for internal callers
            break;
        }
        if (isModSDChangeOnly(pModifyArg)) {
            // allow modifying SD on this object, subject to regular
            // permission checks. By default only SchemaAdmins can 
            // write it.
            break;
        }
        // otherwise, not allowed
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // Don't allow modifications to tombstones, except if target is a
    // DeletedObjects container (e.g. to allow SD to be set) or if caller is
    // the replicator.
    // Also, allow modifying SDs on deleted objects if the caller has 
    // reanimation right on this object.
    if (pModifyArg->pResObj->IsDeleted && !pTHS->fDRA) {
        NAMING_CONTEXT_LIST *pNCL;
        BOOL fModIsOk = FALSE;

        pNCL = FindNCLFromNCDNT(pModifyArg->pResObj->NCDNT, TRUE);
        if (pNCL != NULL && pModifyArg->pResObj->DNT == pNCL->DelContDNT) {
            // allow modifying DeletedObjects container.
            fModIsOk = TRUE;
        }
        else if (   isModSDChangeOnly(pModifyArg) 
                 && CheckUndeleteSecurity(pTHS, pModifyArg->pResObj) == ERROR_SUCCESS) 
        {
            // User is modifying the SD and he also has undelete rights on this object
            // This mod is allowed.
            fModIsOk = TRUE;
        }

        if (!fModIsOk) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_ILLEGAL_MOD_OPERATION);
            goto exit;
        }
    }

#ifndef DBG // leave a back door for checked build

    // Only LSA can modify TrustedDomainObject and SecretObject
    if (!SampIsClassIdAllowedByLsa(pTHS, pClassSch->ClassId))
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

#endif // ifndef

    // Check to see if this is an update in an active container

    // Since the schema container object itself doesn't belong
    // to any active container, we should make sure to set the
    // thread state's SchemaUpdate field appropriately for this
    // in case this is the DRA thread, since it may hold a wrong value
    // from a previous schema object add/modify (since for DRA, the
    // entire schema NC is replicated in one thread state), which can cause
    // it to go in for schema validation etc. which should not be done
    // for schema container object itself

    if (pTHS->fDRA && (pModifyArg->pResObj->DNT==gAnchor.ulDNTDMD) ) {
        pTHS->SchemaUpdate = eNotSchemaOp;
    }

    CheckActiveContainer(pModifyArg->pResObj->PDNT, &ActiveContainerID);
    
    if(ActiveContainerID) {
        if(PreProcessActiveContainer(
                pTHS,
                ACTIVE_CONTAINER_FROM_MOD,
                pModifyArg->pObject,
                pClassSch,
                ActiveContainerID)) {
            goto exit;
        }
    }

    // if this is a schema update, we need to check various
    // things to ensure that schema updates are upward compatible

    if (pTHS->SchemaUpdate!=eNotSchemaOp) {
       err = CheckForSafeSchemaChange(pTHS, pModifyArg, pClassSch);
       if (err) {
          // not an allowed change. Error code is set in
          // thread state already, just leave
          goto exit;
       }

        // Signal a urgent replication. We want schema changes to
        // replicate out immediately to reduce the chance of a schema
        // change not replicating out before the Dc where the change is
        // made crashes

        pModifyArg->CommArg.Svccntl.fUrgentReplication = TRUE;
    }

    // If it is a schema object modification, we need to check if
    // Is-Defunct is the attribute being modified. If yes, we need
    // an additional check (Is-Defunct can be the only attribute
    // in the modifyarg) and reset type of schema operation
    // appropriately for subsequent schema validations
    // (since setting Is-Defunct to TRUE on a non-defunt schema 
    // object is really a delete and setting it to FALSE or removing 
    // it on a defunct object is really an add as far as their 
    // effects on further schema updates go)
    // [ArobindG: 10/28/98]: Merge this code into 
    //                              CheckForSafeSchemaChange in future
    
    // DSA and DRA threads are exempt from this check

    if ((pTHS->SchemaUpdate!=eNotSchemaOp) && 
              !pTHS->fDRA && !pTHS->fDSA) {

        
        BOOL fObjDefunct = FALSE, fIsDefunctPresent = FALSE, fIsDefunct = FALSE;

        // Check if the object is currently defunct or not
        err = DBGetSingleValue(pTHS->pDB, ATT_IS_DEFUNCT, &fObjDefunct,
                             sizeof(fObjDefunct), NULL); 

        switch (err) {

          case DB_ERR_NO_VALUE:
             // Value does not exist. Object is not defunct.
              fObjDefunct = FALSE;
              break;
          case 0:
             // Value exists. fObjDefunct is set to the value already
              break;
          default:
               // some other error. return
              SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR, err);
              goto exit;
        } /* switch */

        // If Is-Defunct is there on the modifyarg, it should be the
        // only one in there. Otherwise, raise appropriate error 
        // depending on if the object is currently defunct or not

        if (InvalidIsDefunct(pModifyArg, &fIsDefunctPresent, &fIsDefunct)) {
            // Is-Defunct is there in the modifyarg, and 
            // it is not the only one
            if (fObjDefunct) {
                // Defunct object. Set object_not_found error
                SetNamError(NA_PROBLEM_NO_OBJECT, NULL,
                            ERROR_DS_OBJ_NOT_FOUND);
                goto exit;
            }
            else {
                // Object is not defunct. Set illegal_modify error
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_ILLEGAL_MOD_OPERATION);
                goto exit;
            }
        }

        // Either Is-Defunct is not there on the modifyarg, or it
        // is the only one there. If it is not there, we are done
        // and let things go on for usual modification, provided
        // the object is not defunct
        //
        // Modifying defunct schema objects is allowed after
        // schema-reuse is enabled

        if (!fIsDefunctPresent 
            && fObjDefunct && !ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
               SetNamError(NA_PROBLEM_NO_OBJECT, NULL,
                           ERROR_DS_OBJ_NOT_FOUND);
               goto exit;
        }               

        // If Is-Defunct is there, reset type of schema update 
        // appropriately to ensure that proper schema validation 
        // checks occur at the end. Note that the call to
        // InvalidIsDefunct sets fIsDefunctPresent correctly on success

        if (fIsDefunctPresent) {
            if (fObjDefunct && !fIsDefunct) {
                // changing state to not-defunct. Do validations for add.
                if (pTHS->SchemaUpdate == eSchemaClsMod) {
                    pTHS->SchemaUpdate = eSchemaClsAdd;
                }
                else if (pTHS->SchemaUpdate == eSchemaAttMod) {
                    pTHS->SchemaUpdate = eSchemaAttUndefunct;
                }
            }
            else if (!fObjDefunct && fIsDefunct) {
                // changing state to defunct. Do validations for delete.
                if (pTHS->SchemaUpdate == eSchemaClsMod) {
                    pTHS->SchemaUpdate = eSchemaClsDel;
                }
                else if (pTHS->SchemaUpdate == eSchemaAttMod) {
                    pTHS->SchemaUpdate = eSchemaAttDel;
                }
            } // else not changing state; validate as regular schema mod
        }

        // All set. Go on with rest of modification as usual
    }

    /* Set the dwMetaDataFlags appropriately */
    if (pModifyArg->CommArg.Svccntl.fAuthoritativeModify)
    {
        Assert(gfRestoring); // currently fAuthoritativeModify
                             // should be specified only by HandleRestore()                             

        dwMetaDataFlags |= META_AUTHORITATIVE_MODIFY;
    }
    
    /* The order of these validations are important. When adding a
     * validation that may result in an update, ensure the update 
     * occurs prior to collecting the metadata with DBMetaDataModifiedList 
     */

    if ( // get the object's rdnType
         GetObjRdnType(pTHS->pDB, pClassSch, &rdnType)
            ||
         // Verify schema restrictions and modify each attribute in database.
         ModSetAtts(pTHS, pModifyArg, &pClassSch, &pClassInfo, rdnType, fIsUndelete,
                    &newForestVersion, &newDomainVersion,
                    &cNonReplAtts, &pNonReplAtts)
            ||
         // validate Dns updates and potentially update SPNs
         ValidateSPNsAndDNSHostName(pTHS,
                                    pModifyArg->pObject,
                                    pClassSch,
                                    fCheckDNSHostNameValues,
                                    fCheckAdditionalDNSHostNameValues,
                                    fCheckSPNValues,
                                    FALSE)

            ||
         // Grab the meta data for use below.  This *must* be done after all
         // updates have been made or changes may never replicate.
         ((err = DBMetaDataModifiedList(pTHS->pDB, &cModAtts, &pModAtts))
              && SetSvcError(SV_PROBLEM_DIR_ERROR, err))
            ||
         // Append the list of non-replicated attributes to the list of 
         // modified attributes, and pass it to ValidateObjClass. Note
         // that the list of modified attribute returned by DBMetaDataModifiedList()
         // does not contain the non-replicated attributes.
         (err = AppendNonReplAttsToModifiedList(pTHS, &cModAtts,&pModAtts, 
                                                &cNonReplAtts, &pNonReplAtts))
            || 
         // Insure all mandatory attributes are present and all others
         // are allowed.
         ValidateObjClass(pTHS, 
                          pClassSch,
                          pModifyArg->pObject,
                          cModAtts,
                          pModAtts,
                          &pClassInfo,
                          fIsUndelete) // if we are undeleting, we have to check for all MustHave's
            ||
         (pClassInfo && ModifyAuxclassSecurityDescriptor (pTHS, 
                                                          pModifyArg->pObject, 
                                                          &pModifyArg->CommArg,
                                                          pClassSch, 
                                                          pClassInfo,
                                                          NULL))
            ||
         // Insert the object into the database for real.
         InsertObj(pTHS,
                   pModifyArg->pObject, 
                   pModifyArg->pMetaDataVecRemote,
                   TRUE,
                   dwMetaDataFlags))
    {
        goto exit;
    }

    // Note, the two special LOST AND FOUND containers in the Config and Schema
    // NCs are now protected from rename and detete via special system flags.
    // There are no longer any special checks at this point, other than above.

    if (pTHS->SchemaUpdate!=eNotSchemaOp) {
        //
        // On Schema updates we want to resolve conflicts, and we want to
        // do so without losing database currency, which would cause operations
        // a few lines below to fail.
        
        ULONG dntSave = pTHS->pDB->DNT;

        // write any new prefixes that were added by this thread
        // to the schema object

        if (WritePrefixToSchema(pTHS))
        {
            goto exit;
        }
        if (!pTHS->fDRA) {        
            if (ValidSchemaUpdate()) {
                goto exit;
            }
            if (WriteSchemaObject()) {
                goto exit;
            }
            
            //log the schema change
            LogEvent(DS_EVENT_CAT_SCHEMA,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DSA_SCHEMA_OBJECT_MODIFIED, 
                     szInsertDN(pModifyArg->pObject),
                     0, 0);
        }

        // Now restore currency
        DBFindDNT(pTHS->pDB, dntSave);
    }

    // If this is not a schema update, but a new prefix is created,
    // flag an error and bail out

    if (!pTHS->fDRA &&
        pTHS->SchemaUpdate == eNotSchemaOp &&
        pTHS->NewPrefix != NULL) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_SECURITY_ILLEGAL_MODIFY);
        goto exit;
    }


    if (   ModCheckCatalog(pTHS, pModifyArg->pResObj)
           ||
           ModAutoSubRef(pTHS, pClassSch->ClassId, pModifyArg)
        ||
        ModObjCaching(pTHS, 
                      pClassSch,
                      cModAtts,
                      pModAtts,
                      pModifyArg->pResObj))
    {
        goto exit;
    }

  
    //
    // If We are the DRA we need to inform SAM and NetLogon of replicated in
    // changes to SAM objects to support downlevel replication
    // Also, if this isn't a Sam or Lsa started transaction, we'll potentially
    // need to notify Lsa. Also if a role transfer ( PDC or BDC) is involved by
    // any means we must inform the new role to SAM , LSA and netlogon
    //


    if( DsaIsRunning() ) {

        err = SampCheckForDomainMods(pTHS,
                                     pModifyArg->pObject,
                                     cModAtts,
                                     pModAtts,
                                     &IsMixedModeChange,
                                     &RoleTransferInvolved,
                                     &NewRole);
        if (err) {
            goto exit;
        }

        SamClassReferenced   = SampSamClassReferenced(pClassSch,&iClass);
        
        if ((SamClassReferenced && RoleTransferInvolved)
            // Sam class + Role Transfer
            // Or Sam Class and Sam attribute modified by LSA or DRA
            ||( SamClassReferenced
               &&(SampSamReplicatedAttributeModified(iClass,pModifyArg)))) 
            {
                
                if (SampQueueNotifications(
                        pModifyArg->pObject,
                        iClass,
                        LsaClass,
                        SecurityDbChange,
                        IsMixedModeChange,
                        RoleTransferInvolved,
                        NewRole,
                        cModAtts,
                        pModAtts) )
                {
                    // 
                    // the above routine failed
                    //
                    goto exit;
                }
            }

        if (SampIsClassIdLsaClassId(pTHS,
                                    pClassSch->ClassId,
                                    cModAtts,
                                    pModAtts,
                                    &LsaClass)) {
            if ( SampQueueNotifications(
                    pModifyArg->pObject,
                    iClass,
                    LsaClass,
                    SecurityDbChange,
                    FALSE,
                    FALSE,
                    NewRole,
                    cModAtts,
                    pModAtts) )
            {
                //
                // the above routine failed
                //
                goto exit;
            }
        }
    }

    if (!pTHS->fDRA && !fIsUndelete) {
        // Only notify replicas if this is not the DRA thread. If it is, then
        // we will notify replicas near the end of DRA_replicasync. We can't
        // do it now as NC prefix is in inconsistent state
        // Also, don't notify in undelete case, this will be done in LocalModifyDN
           
        // Currency of DBPOS must be at the target object
        DBNotifyReplicasCurrDbObj(pTHS->pDB,
                            pModifyArg->CommArg.Svccntl.fUrgentReplication);
    }


    if (!pTHS->fDRA && !pTHS->fDSA && pTHS->fBehaviorVersionUpdate) {
        // log the behavior version change 
        if (newDomainVersion>0) {
            
            LogEvent( DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DS_DOMAIN_VERSION_RAISED,
                      szInsertDN(gAnchor.pDomainDN),
                      szInsertUL(newDomainVersion),
                      NULL );
        }
        else if (newForestVersion>0){
            
            LogEvent( DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DS_FOREST_VERSION_RAISED,
                      szInsertUL(newForestVersion),
                      NULL,
                      NULL );

        }
    }

exit:
    if (pModAtts) {
        THFreeEx(pTHS, pModAtts);
    }
    
    if (pClassInfo) {
        ClassStateInfoFree (pTHS, pClassInfo);
        pClassInfo = NULL;
    }

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_MODIFY,
                     EVENT_TRACE_TYPE_END,
                     DsGuidModify,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;  /*incase we have an attribute error*/

}/*LocalModify*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check the modifyarg to see what schema changes are attempted. We will allow
   only certain changes in order to ensure that the schema is upward compatible

   Returns 0 if all goes well, or an error code (also set in
   thread state) if any of the tests fail
*/

int CheckForSafeSchemaChange(THSTATE *pTHS, 
                             MODIFYARG *pModifyArg, 
                             CLASSCACHE *pCC)
{

    ULONG err=0, sysFlags, governsId;
    ATTRTYP attId;
    BOOL  fBaseSchemaObj = FALSE, fSaveCopy = FALSE, fDefunct;
    ULONG count;
    ATTRMODLIST  *pAttList=NULL;
    ATTR      attrInf;
    ATTCACHE *ac;

    // exempt fDSA, fDRA, install, and if the special registry flag to allow all changes
    // is set
   
    if (pTHS->fDSA 
        || pTHS->fDRA 
        || DsaIsInstalling() 
        || gAnchor.fSchemaUpgradeInProgress) {
       return 0;
    }    

    // otherwise, do the tests

    // Check if we are modifying the class-schema, attribute-schema, or
    // the subschema class objects. No modifications are allowed on them
    // to ensure that replication of the schema container itself never fails
    // with a schema mismatch

    if (pCC->ClassId == CLASS_CLASS_SCHEMA) {
        // Get the governs-id on the object.
        err = DBGetSingleValue(pTHS->pDB, ATT_GOVERNS_ID, &governsId,
                               sizeof(governsId), NULL);

        // value must exist
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR, err);
            goto exit;
        }

        switch (governsId) {
           case CLASS_ATTRIBUTE_SCHEMA:
           case CLASS_CLASS_SCHEMA:
           case CLASS_SUBSCHEMA:
           case CLASS_DMD:
               // no mods are allowed on these class-schema objects
               SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
               goto exit;
           default:
               ;
        }
    }

    // if class is Top, don't allow any mod at all except to
    // add backlinks as mayContains.
   
    fSaveCopy = FALSE;
    if ( (pCC->ClassId == CLASS_CLASS_SCHEMA) && (governsId == CLASS_TOP) ) {
        pAttList = &(pModifyArg->FirstMod);  /* First Att in list */
        for (count = 0; !(pTHS->errCode) && (count < pModifyArg->count); count++){
            attrInf = pAttList->AttrInf;
            switch (attrInf.attrTyp) {
                case ATT_MAY_CONTAIN:
                case ATT_AUXILIARY_CLASS:
                    // this may add backlinks, save for checks later
                    fSaveCopy = TRUE;
                    break;
                default:
                    // no other change is permitted
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
                    break;
             } 
        }
        if (pTHS->errCode) {
            goto exit;
        }
        else {
            goto saveCopy;
        }
    }

    // For other schema objects, do selective tests below 

    // Find the systemFlag value on the object, if any
    // to determine is this is a base schema object

    err = DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, &sysFlags,
                           sizeof(sysFlags), NULL);

    switch (err) {

          case DB_ERR_NO_VALUE:
             // Value does not exist. Not a base schema object
             fBaseSchemaObj = FALSE;
             break;
          case 0:
             // Value exists. Check the bit 
             if (sysFlags & FLAG_SCHEMA_BASE_OBJECT) {
                fBaseSchemaObj = TRUE;
             }
             else {
                fBaseSchemaObj = FALSE;
             } 
             break;
          default:
               // some other error. return
              SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR, err);
              goto exit;
    } /* switch */

    // Now go through the modifyarg to see what is being changed

    fSaveCopy = FALSE;
    pAttList = &(pModifyArg->FirstMod);  /* First Att in list */
    for (count = 0; !(pTHS->errCode) && (count < pModifyArg->count); count++){
        attrInf = pAttList->AttrInf;
        switch (attrInf.attrTyp) {
            case ATT_MUST_CONTAIN:
                // remember to save a current copy of the class from the db
                // in the threadstate so that it can be compared later
                // with the updated copy (We can simply fail this here, but we have 
                // take care of the weird cases when someone added/deleted or replaced
                // with the same value in a single modifyarg
                fSaveCopy = TRUE;
                break;
            case ATT_IS_DEFUNCT:
            case ATT_LDAP_DISPLAY_NAME:
            case ATT_DEFAULT_OBJECT_CATEGORY:
                // no change allowed on these on base schema objects
                if (fBaseSchemaObj) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
                }
                break;
            case ATT_ATTRIBUTE_SECURITY_GUID:
                // allow attribute security guid to be updated except
                // on the certain SAM attributes.
                if(pCC->ClassId != CLASS_ATTRIBUTE_SCHEMA){
                    // this attribute is only on attribute schema object.
                    // if not, skip the check, it will be rejected somewhere else.

                    break;
                }

                err = DBGetSingleValue(pTHS->pDB, ATT_ATTRIBUTE_ID, &attId,
                               sizeof(attId), NULL);

                // value must exist
                if (err) {
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR, err);
                    goto exit;
                }
                ac = SCGetAttByExtId(pTHS,attId);

                if (!ac) {
                    SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_UNKNOWN_ERROR);
                    goto exit;
                }
                
                if(SamIIsAttributeProtected(&(ac->propGuid))){
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
                    goto exit;

                }
                
                break;

            case ATT_AUXILIARY_CLASS:
                // need to compare old with new later to see if this adds 
                // new must-contains 

                fSaveCopy = TRUE;  
                break; 
            default:
                // allow arbitrary change
                break;
                   
        }  /* switch */

        // check if error raised
        if (pTHS->errCode) {
            goto exit;
        }

        pAttList = pAttList->pNextMod;   /*Next mod*/

    } /* for */


    // No error raised. Check if something in the modifyarg asked for a saved copy

saveCopy:
    if (fSaveCopy) {
        // check class, as SCBuildCCEntry will fail otherwise 
        if (pCC->ClassId != CLASS_CLASS_SCHEMA) {
             // not a class schema
             SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
             goto exit;

        }
        err = 0;
        err = SCBuildCCEntry(NULL, &((CLASSCACHE *)(pTHS->pClassPtr)));
        if (err) {
            // thread state error should already be set
            Assert(pTHS->errCode);
        }
    }

exit:
    return (pTHS->errCode);

}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check the modifyarg to see if the Is-defunct attribute is present.
   If it is, it should be the only one present in the modifyarg. This
   routine is called only on a schema modification

   Returns 0 if the modifyarg is valid (that is, either the Is-Defunct 
   attribute is not in it, or Is-defunct is the only attribute in 
   it), non-0 otherwise. If the modifyarg is valid, sets fIsDefunctPresent
   to TRUE or FALSE depending on whether the Is-Defunct attribute is 
   there or not respectively
*/

int InvalidIsDefunct(
    IN  MODIFYARG *pModifyArg, 
    OUT BOOL *fIsDefunctPresent,
    OUT BOOL *fIsDefunct)
{
    ULONG count;
    ATTRMODLIST  *pAttList=NULL;
    ATTRTYP      attType;
    BOOL found = FALSE;

    // assume Is-Defunct is not present in the modifyarg.
    *fIsDefunctPresent = FALSE;
    *fIsDefunct = FALSE;

    pAttList = &(pModifyArg->FirstMod);  /* First Att in list */
    for (count = 0; !found && count < pModifyArg->count; count++){
        attType = pAttList->AttrInf.attrTyp;
        if (attType == ATT_IS_DEFUNCT) {
            // If properly formatted, return new value for isDefunct.
            // Other code will error out if value is badly formatted.
            if (pAttList->AttrInf.AttrVal.valCount == 1
                && pAttList->AttrInf.AttrVal.pAVal->valLen == sizeof (BOOL)) {
                memcpy(fIsDefunct, 
                       pAttList->AttrInf.AttrVal.pAVal->pVal, sizeof (BOOL)); 
            }
            *fIsDefunctPresent = TRUE;
            // must be the only modification (why?)
            return (pModifyArg->count != 1);
        }
        pAttList = pAttList->pNextMod;   /*Next mod*/
    }
    // isDefunct is not present; okay to go
    return 0;
} /*InvalidIsDefunct*/

// Checks to see if changing partial set membership of an
// attribute is illegal; Returns TRUE if illegal.
BOOL SysIllegalPartialSetMembershipChange(THSTATE *pTHS)
{
    // assume the currency is already on the attribute schema of interest
    ULONG ulSystemFlags;

    // We shouldn't allow users to touch the partial set membership of an
    // attribute if:
    //  1) the attribute is not replicated
    //  2) the attribute is a member of the system default partial set
    if ((DB_success == DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, 
                            &ulSystemFlags, sizeof(ulSystemFlags), NULL))
        &&  ((ulSystemFlags & FLAG_ATTR_NOT_REPLICATED)
             || (ulSystemFlags & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER)))
    {      
        return TRUE;
    }
    
    return FALSE;

} /* SysIllegalPartialSetMembershipChange */


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if the modification to the behavior version attribute is legal or
   not.  The behavior version attribute is not allowed to decrease.  The 
   behavior version of a domain must be less than or equal to the behavior
   version of all the dsa's in the domain; The behavior version of the forest
   must be less than or equal to the behavoir version of all dsa's in the
   forest.
   
   Return false if the contraints are violated or any other error occurs;
   return true if the modification is legal.
   
   Upon success, pNewForestVersion will be assigned to the new forest version
   if the forest version is changed, and unchanged otherwise.
*/
BOOL IsValidBehaviorVersionChange(THSTATE * pTHS, 
                                  ATTRMODLIST *pAttrToModify,
                                  MODIFYARG *pModifyArg,
                                  CLASSCACHE *pClassSch,
                                  LONG *pNewForestVersion,
                                  LONG *pNewDomainVersion )
{
    DWORD err;
    LONG lNewVersion;
    BOOL fDSASave;
    DBPOS *pDBSave, *pDB = NULL;
    DSNAME * pDSA;

    BOOL fDomain;

    CLASSCACHE *pCC;
    SEARCHARG SearchArg;
    SEARCHRES SearchRes;

    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(2, "IsValidBehaviorVersionChange entered\n");

    Assert(pAttrToModify);
    Assert(pAttrToModify->AttrInf.attrTyp==ATT_MS_DS_BEHAVIOR_VERSION);

    //only add and replace operations are allowed
    if ((   pAttrToModify->choice != AT_CHOICE_ADD_ATT
         && pAttrToModify->choice != AT_CHOICE_ADD_VALUES
         && pAttrToModify->choice != AT_CHOICE_REPLACE_ATT) ||
         (pAttrToModify->AttrInf.AttrVal.valCount != 1)) 
    {
        DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, invalid operation.\n");
        SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                     ERROR_DS_ILLEGAL_MOD_OPERATION );
        return FALSE;
    }

    //The new value for ms-ds-behavior-version
    lNewVersion = (LONG)*(pAttrToModify->AttrInf.AttrVal.pAVal->pVal);

    //preliminary check
    if (NameMatched(gAnchor.pDomainDN, pModifyArg->pResObj->pObj)) {
        //the object is current domainDNS
        if (lNewVersion <= gAnchor.DomainBehaviorVersion) {
            //decrement is not allowed
            DPRINT2(2, "IsValidBehaviorVersionChange returns FALSE, the new value(%d) <= old value (%d)\n", 
                    lNewVersion, gAnchor.DomainBehaviorVersion);
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_ILLEGAL_MOD_OPERATION );
            return FALSE;
        }
        fDomain = TRUE;

    }
    else if (NameMatched(gAnchor.pPartitionsDN,pModifyArg->pResObj->pObj)) {
        // the object is crossrefContainer
        if (lNewVersion <= gAnchor.ForestBehaviorVersion) {
            //decrement is not allowed
            DPRINT2(2, "IsValidBehaviorVersionChange returns FALSE, the new value(%d) <= old value (%d)\n", 
                    lNewVersion, gAnchor.ForestBehaviorVersion);
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_ILLEGAL_MOD_OPERATION );
            return FALSE;
        }
        fDomain = FALSE;
    }
    else {
        //only the msDs-Behavior-Version of current domainDNS and crossRefContainer
        //objects is allowed to change
        DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, invalid object type\n");
        SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                     ERROR_DS_ILLEGAL_MOD_OPERATION );
        return FALSE;
        
    }

    //check if it is the FSMO role holder
    err = CheckRoleOwnership( pTHS,
                              fDomain?(gAnchor.pDomainDN):(gAnchor.pDMD),
                              pModifyArg->pResObj->pObj );

    if (err) {
        DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, not FSMO role holder\n");
        return FALSE;
               
    }

    //save current DBPOS etc
    fDSASave = pTHS->fDSA;
    pDBSave  = pTHS->pDB;

    //open another DBPOS (no need for a new transaction)
    DBOpen2(FALSE, &pDB);
    
    // replace pDB in pTHS
    pTHS->pDB = pDB;
    pTHS->fDSA = TRUE;  //suppress checks

    __try {

        if( err = VerifyNoOldDC(pTHS, lNewVersion, fDomain, &pDSA))
        {
            if (err == ERROR_DS_LOW_DSA_VERSION) {
                
                LogEvent( DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_LOWER_DSA_VERSION,
                      szInsertDN(pModifyArg->pObject),
                      szInsertDN(pDSA),
                      NULL );
            }

            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         err );
            
            __leave;
        }
        


        // When the forest version is raised from a value less than 2
        // (DS_BEHAVIOR_WIN_DOT_NET) to 2 or greater, we will check if 
        // all the domains are in native mode.
        if ( !fDomain 
             && lNewVersion >= DS_BEHAVIOR_WIN_DOT_NET
             && gAnchor.ForestBehaviorVersion<DS_BEHAVIOR_WIN_DOT_NET )
        {

            err = VerifyNoMixedDomain(pTHS);

            if (err) {
                __leave;
            }
        } 


    } 
    __finally {
        //restore the saved value
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASave;
        // not committing since we did not open a new transaction
        DBClose(pDB, FALSE);
    }
    
    DPRINT1(2, "IsValidBehaviorVersionChange returns %s\n", (err)?"FALSE":"TRUE");

    // if the forest/domain version is raised, return the new version.
    if ( !err ) {
        if (fDomain ) {
            *pNewDomainVersion = lNewVersion;
        }
        else {
            *pNewForestVersion = lNewVersion;
        }
         
    }

    return !err;
}   /*IsValidBehaviorVersionChange*/

      
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if the object to modify is the crossref object for current domain
   or root domain.
*/
BOOL IsCurrentOrRootDomainCrossRef(THSTATE  *pTHS,
                                  MODIFYARG *pModifyArg)
{

    CROSS_REF *pDomainCF, *pRootDomainCF;
    COMMARG CommArg;
    ATTCACHE *pAC = SCGetAttById(pTHS,ATT_MS_DS_DNSROOTALIAS);
    Assert(pAC);

    InitCommarg(&CommArg);
        
    //see if the the crossref object of current domain
    pDomainCF = FindExactCrossRef(gAnchor.pDomainDN, &CommArg);
    Assert(pDomainCF);

    if (pDomainCF && NameMatched(pDomainCF->pObj,pModifyArg->pObject) ) {
        return TRUE;

    }
    //see if the crossref object of the root domain
    pRootDomainCF = FindExactCrossRef(gAnchor.pRootDomainDN, &CommArg);
    Assert(pRootDomainCF);

    if (pRootDomainCF && NameMatched(pRootDomainCF->pObj, pModifyArg->pObject)) {
        return TRUE;
    }

    return FALSE;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Instead of setting Entry-TTL, a constructed attribute with syntax INTEGER,
   set ms-DS-Entry-Time-To-Die, an attribute with syntax DSTIME. The garbage
   collection thread, garb_collect, deletes these entries after they
   expire.
*/
VOID ModSetEntryTTL(THSTATE     *pTHS,
                    MODIFYARG   *pModifyArg,
                    ATTRMODLIST *pAttList,
                    ATTCACHE    *pACTtl
                    )
{
    ATTRVAL         AttrVal;
    ATTRVALBLOCK    AttrValBlock;
    LONG            Secs;
    DSTIME          TimeToDie;
    ATTCACHE        *pACTtd;
    DWORD           dwErr;

    switch (pAttList->choice){

    case AT_CHOICE_REPLACE_ATT:

        if (!CheckConstraintEntryTTL(pTHS,
                                     pModifyArg->pObject,
                                     pACTtl,
                                     &pAttList->AttrInf,
                                     &pACTtd,
                                     &Secs)) {
            return;
        }
        memset(&AttrValBlock, 0, sizeof(AttrValBlock));
        memset(&AttrVal, 0, sizeof(AttrVal));

        AttrValBlock.valCount = 1;
        AttrValBlock.pAVal = &AttrVal;
        AttrVal.valLen = sizeof (TimeToDie);
        AttrVal.pVal = (BYTE *)&TimeToDie;
        TimeToDie = Secs + DBTime();

        if (dwErr = DBReplaceAtt_AC(pTHS->pDB, 
                                    pACTtd,
                                    &AttrValBlock,
                                    NULL)) {
            SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
        }

        break;

    case AT_CHOICE_ADD_ATT:
    case AT_CHOICE_REMOVE_ATT:
    case AT_CHOICE_ADD_VALUES:
    case AT_CHOICE_REMOVE_VALUES:
    default:
       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                     DIRERR_ILLEGAL_MOD_OPERATION,
                     pAttList->choice);
        break;
    }
}/*ModSetEntryTTL*/

int
FixSystemFlagsForMod(
    IN THSTATE     *pTHS,
    IN ATTRMODLIST *pAttList
    )
/*++
Routine Description

    Fix the systemFlags in caller's ModifyArgs. Previously, this
    logic was performed by SetClassInheritence while it added in
    class-specific systemFlags. The logic was moved here to allow
    a user to set, but not reset, FLAG_ATTR_IS_RDN in attributeSchema
    objects in the SchemaNC. The user sets FLAG_ATTR_IS_RDN to identify
    which of several attributes with the same attributeId should be
    used as the rdnattid of a new class. Once set, the attribute is
    treated as if it were used as the rdnattid of some class; meaning it
    cannot be reused.

    Caller has verified that pAttList is ATT_SYSTEM_FLAGS and that
    this is an attributeSchema object.

Paramters
    pTHS - thread struct, obviously
    pAttList - Current attr in ModifyArg's list of attrs

Return
    0 okay to proceed (may fail later)
    1 ModSetAttsHelper fails with no-mod-systemOnly error
--*/
{
    ULONG   OldSystemFlags, NewSystemFlags;

    // caller may do whatever it wishes
    if (CallerIsTrusted(pTHS)) {
        return 0;
    }

    // Add or replace is allowed, but not remove
    switch (pAttList->choice) {
    case AT_CHOICE_REPLACE_ATT:
    case AT_CHOICE_ADD_ATT:
    case AT_CHOICE_ADD_VALUES:

        // valCount of 0 is the same as AT_CHOICE_REMOVE_ATT
        if (pAttList->AttrInf.AttrVal.valCount == 0) {
            return 1;
        }

        // must be single-valued and an integer. If not, ModSetAttsHelper
        // later fails with not-multi-valued or bad-syntax error.
        if (pAttList->AttrInf.AttrVal.valCount != 1
            || pAttList->AttrInf.AttrVal.pAVal->valLen != sizeof(LONG)) {
            return 0;
        }

        // New value from user
        memcpy(&NewSystemFlags, pAttList->AttrInf.AttrVal.pAVal->pVal, sizeof(LONG));

        // Get the current value of systemFlags (default to 0)
        if (DBGetSingleValue(pTHS->pDB,
                             ATT_SYSTEM_FLAGS,
                             &OldSystemFlags,
                             sizeof(OldSystemFlags),
                             NULL)) {
            OldSystemFlags = 0;
        }
        // Only one modification to systemFlags is allowed. The user
        // may set, but not reset, FLAG_ATTR_IS_RDN on an attributeSchema
        // object. scchk.c will later verify that this attribute has
        // the correct syntax to be an rdn. The caller verified that this
        // is an attributeSchema object.
        NewSystemFlags = OldSystemFlags | (NewSystemFlags & FLAG_ATTR_IS_RDN);

        // Update ModifyArgs. ApplyAtt will hammer systemFlags.
        memcpy(pAttList->AttrInf.AttrVal.pAVal->pVal, &NewSystemFlags, sizeof(LONG));

        break;

    case AT_CHOICE_REMOVE_ATT:
    case AT_CHOICE_REMOVE_VALUES:
    default:
        return 1;
    }
    return 0;
}/*FixSystemFlagsForMod*/



// This function definition describes the signature of functions that can be
// called from the DS to process attributes that are not to be written to 
// the DS as is.  The callout has the opportunity to change or add new
// attributes.
typedef DWORD (*MODIFYCALLOUTFUNCTION) (
    ULONG      Attr,         /* in  */
    PVOID      Data,         /* in  */
    ATTRBLOCK *AttrBlockIn,  /* in  */
    ATTRBLOCK *AttrBlockOut  /* out */
    );

/******************************************************************************
*                                                                             *
*   The callout functionality was originally added to handle user_password    *
*   updates.  User_password updates are now handled via SampDsControl.        *
*   The callout functionality is currently not used by any attributes but     *
*   may have future usefulness so it is not removed from the code.            *
*                                                                             *
******************************************************************************/

// The list of attributes that are not to be written to the DS and the 
// callout function to call to process the data
struct _MODIFY_PROCESS_UPDATE {

    // Attribute that shouldn't be applied to the DS
    ULONG                  attr;

    // Attrs to pass into caller
    ULONG                   requiredAttrCount;
    ULONG*                  requiredAttrs;

    // Function to handle attribute
    MODIFYCALLOUTFUNCTION  pfnProcess;

} modifyProcessUpdateArray[] = 
{
    {
        INVALID_ATT,       //Att type
        0,                 //Num of required atts   
        NULL,              //Array of required atts
        NULL               //Pointer to callout function
    }
};

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* 
   This function determines if the specified attribute is an element of
   modifyProcessUpdateArray.
*/
BOOL
isAttributeInModifyProcessUpdate(ULONG attr,
                                 ULONG *index)
{
    ULONG i;

    for (i = 0; i < RTL_NUMBER_OF(modifyProcessUpdateArray); i++) {
        if (attr == modifyProcessUpdateArray[i].attr) {
            *index = i;
            return TRUE;
        }
    }

    return FALSE;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
//
// Function:
//      processModifyUpdateNotify
//
// Description:
//
//      This routine calls the external handler for the attribute indicated
//      by index "i".  The handler may return attributes to be written to
//      the DS.
//
//      updateInfo is provided by the caller and is passed to the callout
//      as well.
//
// Return:
//      0, on success
//      errCode otherwise
DWORD
processModifyUpdateNotify(THSTATE *pTHS,
                          ULONG index,
                          PVOID updateInfo)
{
    DWORD err = 0;
    ATTRBLOCK attrBlockIn, attrBlockOut;
    ULONG i, j;
    ATTCACHE** ppAC = NULL;
    ATTR  *pAttr = NULL;
    ULONG  attrCount = 0;

    // Assert to maintain data definitions
    Assert(MAX_MODIFY_PROCESS_UPDATE == RTL_NUMBER_OF(modifyProcessUpdateArray));

    RtlZeroMemory(&attrBlockIn, sizeof(attrBlockIn));
    RtlZeroMemory(&attrBlockOut, sizeof(attrBlockOut));

    attrBlockIn.pAttr = NULL;

    __try {
        // obtain requested input parameters
        attrBlockIn.pAttr = THAllocEx(pTHS, modifyProcessUpdateArray[index].requiredAttrCount * sizeof(ATTR));
        attrBlockIn.attrCount = modifyProcessUpdateArray[index].requiredAttrCount;
        ppAC = (ATTCACHE**)THAllocEx(pTHS, modifyProcessUpdateArray[index].requiredAttrCount * sizeof(ATTR));
        for (i = 0; i < modifyProcessUpdateArray[index].requiredAttrCount; i++) {
            ppAC[i] = SCGetAttById(pTHS, modifyProcessUpdateArray[index].requiredAttrs[i]);
            Assert(NULL != ppAC[i]);
        }

        err = DBGetMultipleAtts(pTHS->pDB,
                                modifyProcessUpdateArray[index].requiredAttrCount,
                                ppAC,
                                NULL, // no range
                                NULL,
                                &attrCount,
                                &pAttr,
                                DBGETMULTIPLEATTS_fEXTERNAL,
                                0);
        if (err) {
            // Unhandled error
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_UNKNOWN_ERROR,
                          err);
            err = pTHS->errCode;
            __leave;
        }

        // The nice thing about DBGetMultipleAtts is that it returns the
        // attributes in the same order they were requested (although
        // NULL values are not included).
        for (i = j = 0; i < modifyProcessUpdateArray[index].requiredAttrCount; i++) {
            if (j < attrCount && pAttr[j].attrTyp == modifyProcessUpdateArray[index].requiredAttrs[i]) {
                // got this attribute.
                attrBlockIn.pAttr[i] = pAttr[j];
                j++;
            }
            else {
                // no, this attribute does not have a value
                attrBlockIn.pAttr[i].attrTyp = modifyProcessUpdateArray[index].requiredAttrs[i];
                attrBlockIn.pAttr[i].AttrVal.valCount = 0;
#if DBG
                {
                    // check that this attr is really not present in the result array
                    ULONG k;
                    for (k = 0; k < attrCount; k++) {
                        Assert(pAttr[k].attrTyp != modifyProcessUpdateArray[index].requiredAttrs[i]);
                    }
                }
#endif
            }
        }

        // call out to get new attributes
        err = (modifyProcessUpdateArray[index].pfnProcess)(modifyProcessUpdateArray[index].attr,
                                                           updateInfo,
                                                          &attrBlockIn,
                                                          &attrBlockOut);
        if (err) {
            // err is a win32 error
            SetSvcError(
                SV_PROBLEM_WILL_NOT_PERFORM,
                err);
            err = pTHS->errCode;
            __leave;
        }

        // apply the attributes sent back
        for (i = 0; i < attrBlockOut.attrCount; i++) {

            // update the object
            ATTCACHE *pAC = SCGetAttById(pTHS, attrBlockOut.pAttr[i].attrTyp);
            Assert(NULL != pAC);

            err = DBReplaceAtt_AC(pTHS->pDB,
                                  pAC,
                                  &attrBlockOut.pAttr[i].AttrVal,
                                  NULL);

            if (err) {
                SetSvcErrorEx(SV_PROBLEM_BUSY,
                              DIRERR_DATABASE_ERROR,
                              err);
                err = pTHS->errCode;
                __leave;
            }
        }
    }
    __finally {
        if (pAttr) {
            DBFreeMultipleAtts(pTHS->pDB, &attrCount, &pAttr);
        }
        if (ppAC) {
            THFreeEx(pTHS, ppAC);
        }
        if (attrBlockIn.pAttr) {
            THFreeEx(pTHS, attrBlockIn.pAttr);
        }
    }

    return err;

} /* processModifyUpdateNotify */

DWORD
GetWellKnownObject(
    IN OUT  THSTATE*        pTHS, 
    IN      GUID*           pGuid,
    OUT     DSNAME**        ppObj
    )
{
    DBPOS*                      pDBSave     = pTHS->pDB;
    DBPOS*                      pDB         = NULL;
    DWORD                       err         = 0;
    DWORD                       iVal        = 0;
    DWORD                       valLen      = 0;
    SYNTAX_DISTNAME_BINARY*     pDNB        = NULL;

    __try {

        // init answer to NULL
    
        *ppObj = NULL;

        // get a new DBPOS to preserve currency on the current DBPOS

        DBOpen2(FALSE, &pDB);
        pTHS->pDB = pDB;

        // move to the domainDNS object

        if (err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN)) {
            __leave;
        }

        // scan all values of wellKnownObjects looking for the requested GUID
        
        do {
            err = DBGetAttVal(pTHS->pDB,
                              ++iVal,
                              ATT_WELL_KNOWN_OBJECTS,
                              0,
                              0,
                              &valLen,
                              (UCHAR**)&pDNB);
            if (err) {
                // no more values.
                break;
            }
            if (PAYLOAD_LEN_FROM_STRUCTLEN(DATAPTR(pDNB)->structLen) == sizeof(GUID) && 
                memcmp(pGuid, DATAPTR(pDNB)->byteVal, sizeof(GUID)) == 0) 
            {
                // got it!
                break;
            }
    
            THFreeEx(pTHS, pDNB);
            pDNB = NULL;
        } while (TRUE);
    } __finally {
        pTHS->pDB = pDBSave;
        DBClose(pDB, FALSE);
        if (!err) {
            *ppObj = NAMEPTR(pDNB);
        } else {
            THFreeEx(pTHS, pDNB);
        }
    }
    
    return err;
}

DWORD
ValidateRedirectOfWellKnownObjects(
    IN OUT  THSTATE*        pTHS, 
    IN      ATTRMODLIST*    pAttrModList,
    IN      MODIFYARG*      pModifyArg,
    IN OUT  HVERIFY_ATTS    hVerifyAtts
    )
{
    BOOL                        fDSASaved           = pTHS->fDSA;
    DBPOS*                      pDBSave             = pTHS->pDB;
    DBPOS*                      pDB                 = NULL;
    DSNAME*                     pObjUsersOld        = NULL;
    DSNAME*                     pObjUsersNew        = NULL;
    DSNAME*                     pObjComputersOld    = NULL;
    DSNAME*                     pObjComputersNew    = NULL;
    ATTRMODLIST*                pAttrMod            = NULL;
    SYNTAX_DISTNAME_BINARY*     pDNB                = NULL;
    DSNAME*                     pObj                = NULL;
    GUID*                       pGuid               = NULL;
    DSNAME**                    ppObjOld            = NULL;
    DSNAME**                    ppObjNew            = NULL;
    ATTR                        systemFlags         = {0};
    ENTINFSEL                   EntInf              = {0};
    READARG                     ReadArg             = {0};
    READRES                     ReadRes             = {0};
    DWORD                       flags               = 0;
    DWORD*                      pdwSystemFlagsNew   = NULL;
    DWORD                       dwSystemFlagsUsersNew = 0;
    DWORD                       dwSystemFlagsComputersNew = 0;
    
    __try {
            
        // if we have already validated a redirect for this modify operation then
        // we have validated them all

        if (hVerifyAtts->fRedirectWellKnownObjects) {
            __leave;
        }

        // redirect is only valid on the domainDNS object

        if (!NameMatched(gAnchor.pDomainDN, pModifyArg->pResObj->pObj)) {
            __leave;
        }

        // we must own the PDC FSMO role

        if (CheckRoleOwnership(pTHS, gAnchor.pDomainDN, pModifyArg->pResObj->pObj)) {
            __leave;
        }

        // the domain must be at Whistler functionality level for redirect

        if (gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_NOT_SUPPORTED);
            __leave;
        }

        // get a new DBPOS to preserve currency on the current DBPOS

        DBOpen2(FALSE, &pDB);
        pTHS->pDB = pDB;

        // act on behalf of the DSA to bypass security checks

        pTHS->fDSA = TRUE;

        // fetch the current values of the GUIDs we permit to be redirected as
        // both their old and new values

        if (GetWellKnownObject(pTHS,
                               (GUID*)GUID_USERS_CONTAINER_BYTE,
                               &pObjUsersOld)) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_UNKNOWN_ERROR);
            __leave;
        }
        pObjUsersNew = THAllocEx(pTHS, pObjUsersOld->structLen);
        memcpy(pObjUsersNew, pObjUsersOld, pObjUsersOld->structLen);
        if (GetWellKnownObject(pTHS,
                               (GUID*)GUID_COMPUTRS_CONTAINER_BYTE,
                               &pObjComputersOld)) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_UNKNOWN_ERROR);
            __leave;
        }
        pObjComputersNew = THAllocEx(pTHS, pObjComputersOld->structLen);
        memcpy(pObjComputersNew, pObjComputersOld, pObjComputersOld->structLen);

        // walk through every attr mod operation for wellKnownObject and validate
        // that the net outcome is desirable

        for (pAttrMod = pAttrModList; pAttrMod; pAttrMod = pAttrMod->pNextMod) {
            if (pAttrMod->AttrInf.attrTyp != ATT_WELL_KNOWN_OBJECTS) {
                continue;
            }

            // only value additions/removals are allowed on this MV attr

            if (pAttrMod->choice != AT_CHOICE_ADD_VALUES &&
                pAttrMod->choice != AT_CHOICE_REMOVE_VALUES) {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_UNWILLING_TO_PERFORM);
                __leave;
            }

            // fetch the DSNAME and GUID from this mod

            if (pAttrMod->AttrInf.AttrVal.valCount != 1) {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_UNWILLING_TO_PERFORM);
                __leave;
            }
            pDNB = (SYNTAX_DISTNAME_BINARY*)pAttrMod->AttrInf.AttrVal.pAVal->pVal;
            pObj = NAMEPTR(pDNB);
            if (PAYLOAD_LEN_FROM_STRUCTLEN(DATAPTR(pDNB)->structLen) != sizeof(GUID)) {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_UNWILLING_TO_PERFORM);
                __leave;
            }
            pGuid = (GUID*)DATAPTR(pDNB)->byteVal;

            // the GUID must represent either the Users or Computers containers

            if (!memcmp(pGuid, GUID_USERS_CONTAINER_BYTE, sizeof(GUID))) {
                ppObjOld    = &pObjUsersOld;
                ppObjNew    = &pObjUsersNew;
                pdwSystemFlagsNew = &dwSystemFlagsUsersNew;
            } else if (!memcmp(pGuid, GUID_COMPUTRS_CONTAINER_BYTE, sizeof(GUID))) {
                ppObjOld    = &pObjComputersOld;
                ppObjNew    = &pObjComputersNew;
                pdwSystemFlagsNew = &dwSystemFlagsComputersNew;
            } else {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_UNWILLING_TO_PERFORM);
                __leave;
            }

            // we are trying to add a value to wellKnownObjects

            if (pAttrMod->choice == AT_CHOICE_ADD_VALUES) {

                // fetch the current value of systemFlags on the object referred
                // to be the DSNAME.  this object must exist and not be a
                // phantom.  if systemFlags is NULL then we will assume it is 0

                memset(&systemFlags, 0, sizeof(ATTR));
                systemFlags.attrTyp = ATT_SYSTEM_FLAGS;
                EntInf.attSel = EN_ATTSET_LIST;
                EntInf.AttrTypBlock.attrCount = 1;
                EntInf.AttrTypBlock.pAttr = &systemFlags;
                EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
                memset(&ReadArg, 0, sizeof(READARG));
                ReadArg.pObject = pObj;
                ReadArg.pSel = &EntInf;

                if (DoNameRes(pTHS,
                              NAME_RES_QUERY_ONLY,
                              ReadArg.pObject,
                              &ReadArg.CommArg,
                              &ReadRes.CommRes,
                              &ReadArg.pResObj)) {
                    __leave;
                }

                if (LocalRead(pTHS, &ReadArg, &ReadRes)) {
                    if (pTHS->errCode != attributeError) {
                        __leave;
                    }
                    THClearErrors();
                }

                // The computer/user objects should not be directed to
                // an object under system container.

                if (IsUnderSystemContainer(pTHS,ReadArg.pResObj->DNT)) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER);
                    __leave;

                }

                
                if (ReadRes.entry.AttrBlock.attrCount) {
                    *pdwSystemFlagsNew = *((DWORD*)ReadRes.entry.AttrBlock.pAttr->AttrVal.pAVal->pVal);
                } else {
                    *pdwSystemFlagsNew = 0;
                }

                // if this GUID already has a DSNAME associated with it then we
                // will not process this mod list

                if (*ppObjNew) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_UNWILLING_TO_PERFORM);
                    __leave;
                }

                // remember the new DSNAME associated with this GUID
                *ppObjNew = THAllocEx(pTHS, pObj->structLen);
                memcpy(*ppObjNew, pObj, pObj->structLen);
            }

            // we are trying to remove a value from wellKnownObjects
            else {
                // pAttrMod->choice == AT_CHOICE_REMOVE_VALUES

                // the DSNAME to remove should equal the DSNAME currently
                // associated with this GUID or we will not process this mod
                // list

                if (*ppObjNew == NULL || !NameMatched(pObj, *ppObjNew)) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_UNWILLING_TO_PERFORM);
                    __leave;
                }

                // remove the DSNAME currently associated with this GUID
                THFreeEx(pTHS, *ppObjNew);
                *ppObjNew = NULL;
            }
        }

        // if there is no current DSNAME for each redirectable GUID then we
        // will not process this mod list

        if (!pObjUsersNew || !pObjComputersNew) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_UNWILLING_TO_PERFORM);
            __leave;
        }

        // the object cannot have any of the special flags set that we
        // need to set later on unless the new object is the same as
        // the old object

        flags = (FLAG_DISALLOW_DELETE |
                 FLAG_DOMAIN_DISALLOW_RENAME |
                 FLAG_DOMAIN_DISALLOW_MOVE);

        if (!(NameMatched(pObjUsersNew, pObjUsersOld) || NameMatched(pObjUsersNew, pObjComputersOld)) && 
            (dwSystemFlagsUsersNew & flags)) {
            // We are changing users and not redirecting to the other WKO container, so 
            // we must require that the new container is not currently marked as special.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL);
            __leave;
        }

        if (!(NameMatched(pObjComputersNew, pObjComputersOld) || NameMatched(pObjComputersNew, pObjUsersOld)) && 
            (dwSystemFlagsComputersNew & flags)) {
            // We are changing computers and not redirecting to the other WKO container, so 
            // we must require that the new container is not currently marked as special.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL);
            __leave;
        }

        // the redirection is valid.  setup our state in hVerifyAtts so that we
        // can allow the update (overriding the schema validation) and so that
        // we can update the objects involved in post-processing in
        // CompleteRedirectOfWellKnownObjects.  also, because we have already
        // validated all modifications to this attr, we will not process any
        // future mods to this attr (see beginning of function)

        hVerifyAtts->fRedirectWellKnownObjects  = TRUE;
        hVerifyAtts->pObjUsersOld               = pObjUsersOld;
        hVerifyAtts->pObjUsersNew               = pObjUsersNew;
        hVerifyAtts->pObjComputersOld           = pObjComputersOld;
        hVerifyAtts->pObjComputersNew           = pObjComputersNew;

        pObjUsersOld        = NULL;
        pObjUsersNew        = NULL;
        pObjComputersOld    = NULL;
        pObjComputersNew    = NULL;

    } __finally {
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASaved;
        
        THFreeEx(pTHS, pObjUsersOld);
        THFreeEx(pTHS, pObjUsersNew);
        THFreeEx(pTHS, pObjComputersOld);
        THFreeEx(pTHS, pObjComputersNew);

        DBClose(pDB, FALSE);
    }

    return pTHS->errCode;
}

DWORD
CompleteRedirectOfWellKnownObjects(
    IN OUT  THSTATE*        pTHS, 
    IN OUT  HVERIFY_ATTS    hVerifyAtts
    )
{
    typedef struct _UPDATE {
        DSNAME*     pObj;
        LONG        maskClear;
        LONG        maskSet;
    } UPDATE;

    BOOL        fDSASaved           = pTHS->fDSA;
    DBPOS*      pDBSave             = pTHS->pDB;
    DBPOS*      pDB                 = NULL;
    LONG        flags               = 0;
    UPDATE      rgUpdate[4]         = {0};
    size_t      cUpdate             = 0;
    size_t      iUpdate             = 0;
    ATTR        systemFlags         = {0};
    ENTINFSEL   EntInf              = {0};
    READARG     ReadArg             = {0};
    READRES     ReadRes             = {0};
    DWORD       systemFlagsVal      = 0;
    ATTRVAL     systemFlagsAVal     = {sizeof(systemFlagsVal), (UCHAR*)&systemFlagsVal};
    MODIFYARG   ModifyArg           = {0};
    MODIFYRES   ModifyRes           = {0};

    __try {

        // we shouldn't be here if this isn't set...

        if (!hVerifyAtts->fRedirectWellKnownObjects) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_UNKNOWN_ERROR);
            __leave;
        }

        // get a new DBPOS to preserve currency on the current DBPOS

        DBOpen2(FALSE, &pDB);
        pTHS->pDB = pDB;

        // act on behalf of the DSA to bypass security and schema checks

        pTHS->fDSA = TRUE;

        // build ourselves an array that we will use to drive the update of the
        // systemFlags attr on each of the objects involved in the redirect.
        // we will strip special flags from the old objects and add them to the
        // new objects

        flags = (FLAG_DISALLOW_DELETE |
                 FLAG_DOMAIN_DISALLOW_RENAME |
                 FLAG_DOMAIN_DISALLOW_MOVE);

        if (!NameMatched(hVerifyAtts->pObjUsersOld, hVerifyAtts->pObjUsersNew)) {
            // users is being redirected
            if (!NameMatched(hVerifyAtts->pObjUsersOld, hVerifyAtts->pObjComputersNew)) {
                // old users is not new computers, so clear the flags on old users
                rgUpdate[cUpdate].pObj          = hVerifyAtts->pObjUsersOld;
                rgUpdate[cUpdate].maskClear     = flags;
                rgUpdate[cUpdate].maskSet       = 0;
                cUpdate++;
            }
            if (!NameMatched(hVerifyAtts->pObjUsersNew, hVerifyAtts->pObjComputersOld)) {
                // new users is not old computers, so set the flags on new users
                rgUpdate[cUpdate].pObj          = hVerifyAtts->pObjUsersNew;
                rgUpdate[cUpdate].maskClear     = 0;
                rgUpdate[cUpdate].maskSet       = flags;
                cUpdate++;
            }
        }
        if (!NameMatched(hVerifyAtts->pObjComputersOld, hVerifyAtts->pObjComputersNew)) {
            // computers is being redirected
            if (!NameMatched(hVerifyAtts->pObjComputersOld, hVerifyAtts->pObjUsersNew)) {
                // old computers is not new users, so clear the flags on old computers
                rgUpdate[cUpdate].pObj          = hVerifyAtts->pObjComputersOld;
                rgUpdate[cUpdate].maskClear     = flags;
                rgUpdate[cUpdate].maskSet       = 0;
                cUpdate++;
            }
            if (!NameMatched(hVerifyAtts->pObjComputersNew, hVerifyAtts->pObjUsersOld)) {
                // new computers is not old users, so set the flags on new computers
                rgUpdate[cUpdate].pObj          = hVerifyAtts->pObjComputersNew;
                rgUpdate[cUpdate].maskClear     = 0;
                rgUpdate[cUpdate].maskSet       = flags;
                cUpdate++;
            }
        }

        // update all objects

        for (iUpdate = 0; iUpdate < cUpdate; iUpdate++) {
            // each of the objects in hVerifyAtts must have a value
            Assert(rgUpdate[iUpdate].pObj);

            // fetch the current value of systemFlags on this object
            memset(&systemFlags, 0, sizeof(ATTR));
            systemFlags.attrTyp = ATT_SYSTEM_FLAGS;
            EntInf.attSel = EN_ATTSET_LIST;
            EntInf.AttrTypBlock.attrCount = 1;
            EntInf.AttrTypBlock.pAttr = &systemFlags;
            EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
            memset(&ReadArg, 0, sizeof(READARG));
            ReadArg.pObject = rgUpdate[iUpdate].pObj;
            ReadArg.pSel = &EntInf;
            
            if (DoNameRes(pTHS,
                          NAME_RES_QUERY_ONLY,
                          ReadArg.pObject,
                          &ReadArg.CommArg,
                          &ReadRes.CommRes,
                          &ReadArg.pResObj)) {
                __leave;
            }

            if (LocalRead(pTHS, &ReadArg, &ReadRes)) {
                if (pTHS->errCode != attributeError) {
                    __leave;
                }
                THClearErrors();
            }

            if (ReadRes.entry.AttrBlock.attrCount) {
                systemFlags = *ReadRes.entry.AttrBlock.pAttr;
            } else {
                systemFlags.attrTyp = ATT_SYSTEM_FLAGS;
                systemFlags.AttrVal.valCount = 1;
                systemFlags.AttrVal.pAVal = &systemFlagsAVal;
            }

            // modify the value of systemFlags on this object
            
            *((long*)systemFlags.AttrVal.pAVal->pVal) &= ~rgUpdate[iUpdate].maskClear;
            *((long*)systemFlags.AttrVal.pAVal->pVal) |= rgUpdate[iUpdate].maskSet;
            
            memset(&ModifyArg, 0, sizeof(MODIFYARG));
            ModifyArg.pObject = rgUpdate[iUpdate].pObj;
            ModifyArg.count = 1;
            ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
            ModifyArg.FirstMod.AttrInf = systemFlags;
            ModifyArg.CommArg.Svccntl.dontUseCopy = TRUE;
            
            if (DoNameRes(pTHS,
                          0,
                          ModifyArg.pObject,
                          &ModifyArg.CommArg,
                          &ModifyRes.CommRes,
                          &ModifyArg.pResObj)) {
                __leave;
            }

            if (LocalModify(pTHS, &ModifyArg)) {
                __leave;
            }

			//	if we clear the flags then we should also reset the ATT_IS_CRITICAL_SYSTEM_OBJECT property,
			//	and if we set the flags then we should set the property.
			//
			if ( ( 0 != rgUpdate[iUpdate].maskClear ) ^ ( 0 != rgUpdate[iUpdate].maskSet ) )
				{
				ULONG   IsCrit = 0;
				ATTR    IsCritAttr;
				ATTRVAL IsCritVal = {sizeof(ULONG),(UCHAR*) &IsCrit};

				//	if ( 0 != rgUpdate[iUpdate].maskClear )
				//	{
				//	IsCrit = 0;
				//	}
				if ( 0 != rgUpdate[iUpdate].maskSet )
					{
					IsCrit = 1;
					}
				
				IsCritAttr.attrTyp = ATT_IS_CRITICAL_SYSTEM_OBJECT;
				IsCritAttr.AttrVal.valCount = 1;
				IsCritAttr.AttrVal.pAVal = &IsCritVal;
                
				memset(&ModifyArg, 0, sizeof(MODIFYARG));
				ModifyArg.pObject = rgUpdate[iUpdate].pObj;
				ModifyArg.count = 1;
				ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
				ModifyArg.FirstMod.AttrInf = IsCritAttr;
				ModifyArg.CommArg.Svccntl.dontUseCopy = TRUE;

				if (DoNameRes(pTHS,
					0,
					ModifyArg.pObject,
					&ModifyArg.CommArg,
					&ModifyRes.CommRes,
					&ModifyArg.pResObj)) {
					__leave;
					}

				if (LocalModify(pTHS, &ModifyArg)) {
					__leave;
					}
			}
            
        }

    } __finally {
        DBClose(pDB, FALSE);
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASaved;

        THFreeEx(pTHS, hVerifyAtts->pObjUsersOld);
        THFreeEx(pTHS, hVerifyAtts->pObjUsersNew);
        THFreeEx(pTHS, hVerifyAtts->pObjComputersOld);
        THFreeEx(pTHS, hVerifyAtts->pObjComputersNew);
        
        hVerifyAtts->fRedirectWellKnownObjects  = FALSE;
        hVerifyAtts->pObjUsersOld               = NULL;
        hVerifyAtts->pObjUsersNew               = NULL;
        hVerifyAtts->pObjComputersOld           = NULL;
        hVerifyAtts->pObjComputersNew           = NULL;
    }

    return pTHS->errCode;
}

BOOL 
isWellKnownObjectsChangeAllowed(    
    THSTATE*        pTHS, 
    ATTRMODLIST*    pAttrModList,
    MODIFYARG*      pModifyArg,
    HVERIFY_ATTS    hVerifyAtts
    )

{
    NAMING_CONTEXT_LIST *pNCL;
    ATTRMODLIST* pAttrMod;
    DWORD DNT, objectClass,len,err=0;
    SYNTAX_DISTNAME_BINARY * pDNB;
    DSNAME * pObj;
    GUID *pGuid;
    DBPOS *pDB=NULL;
    BOOL fWkoVisited=FALSE, fRet=FALSE;
    
   
    if (hVerifyAtts->fRedirectWellKnownObjects) {
        //should never come here
        return TRUE;
    }
        
    // only on NC head
    if (!(pModifyArg->pResObj->InstanceType & IT_NC_HEAD)) {
        return FALSE;
    }

    // allowed only on NDNC
    if (   pModifyArg->pResObj->DNT == gAnchor.ulDNTDomain 
        || pModifyArg->pResObj->DNT == gAnchor.ulDNTConfig
        || pModifyArg->pResObj->DNT == gAnchor.ulDNTDMD) {
        return FALSE;
    }
        
    // find the naming context
    pNCL = FindNCLFromNCDNT(pModifyArg->pResObj->DNT, TRUE);
   
    if (pNCL == NULL) {
        LooseAssert(!"Naming context not found", GlobalKnowledgeCommitDelay);
        return FALSE;
    }

    //verify the modifyArg matches the GUID and DN
    for (pAttrMod = pAttrModList; pAttrMod; pAttrMod = pAttrMod->pNextMod) {
        
        if (pAttrMod->AttrInf.attrTyp != ATT_WELL_KNOWN_OBJECTS) {
            continue;
        }

        // only one WKO mod allowed at one time
        if (fWkoVisited) {
            break;
        }
        
        fWkoVisited = TRUE;

        // add one value only

        if (pAttrMod->choice != AT_CHOICE_ADD_VALUES 
            || pAttrMod->AttrInf.AttrVal.valCount != 1) {
            break;
        }
                    
        // check guid and dn
        pDNB = (SYNTAX_DISTNAME_BINARY*)pAttrMod->AttrInf.AttrVal.pAVal->pVal;
        pObj = NAMEPTR(pDNB);
        if (PAYLOAD_LEN_FROM_STRUCTLEN(DATAPTR(pDNB)->structLen) != sizeof(GUID)) {
            break;
        }

        pGuid = (GUID*)DATAPTR(pDNB)->byteVal;

        if (memcmp(pGuid, GUID_NTDS_QUOTAS_CONTAINER_BYTE, sizeof(GUID))) {
            break;
        }
        
        // verify the name is "CN=NTDS quotas,DC=X"
        if ( pObj->NameLen < 15   //sizeof("CN=NTDS quotas," )
            || _wcsnicmp(pObj->StringName,L"CN=NTDS quotas,", 15) ) {
            break;
        }

        
        DBOpen2(FALSE,&pDB);
   
        __try {
       
            
            DBFindDNT(pDB, pModifyArg->pResObj->DNT);
            
            // check if the GUID is already registered
            if(GetWellKnownDNT(pDB,
                               (GUID *)GUID_NTDS_QUOTAS_CONTAINER_BYTE,
                               &DNT))
            {
               err =  ERROR_DS_ILLEGAL_MOD_OPERATION;
               __leave;
           
            }
            
            //see if the object exists
            err = DBFindDSName(pDB, pObj);
               
           
            if (err) {
               __leave;
            }

            // the object must be the immediate child of the NC head
            if (pDB->PDNT != pModifyArg->pResObj->DNT)
            {
               err =  ERROR_DS_ILLEGAL_MOD_OPERATION;
               __leave;
            }

            // make sure the object class has the right class
            err = DBGetSingleValue(pDB,
                                   ATT_OBJECT_CLASS,
                                   &objectClass, 
                                   sizeof(objectClass),
                                   &len);
           
            if (err) {
                __leave;
            }

           
            if (objectClass != CLASS_MS_DS_QUOTA_CONTAINER) {
                err =  ERROR_DS_ILLEGAL_MOD_OPERATION;
                __leave;
            }

            
        }
        __finally{
            DBClose(pDB,FALSE);
        }
        if(err) {
            break;    
        }
            
        fRet = TRUE;
        
    } //for

    return fRet;
    
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
//
//
// Functions:
//       ModSetAttsHelperPreProcess
//       ModSetAttsHelperProcess
//       ModSetAttsHelperPostProcess
//
// Description:
//      Add each input attribute to the current object.  
//
//      There is the pre-processing phase, where all the checks for validity 
//      are done. At this point the checks can navigate to other objects
//      and check various conditions as needed. It is assumed that in the end 
//      of the preprocessing phase, we are located on the initial object
//      If there is a need to communicate some data to the later steps, 
//      this is done through the hVerifyAtts data structure
//
//      The processing phase does the real update
//      If there is a need to communicate some data to the later steps, 
//      this is done through the hVerifyAtts data structure
//
//      The post-processing phase, checks the data passed in the 
//      hVerifyAtts data structure and takes appropriate action
//      if directed todo so
//
// Return:
//      0, on success
//      errCode otherwise

DWORD ModSetAttsHelperPreProcess(THSTATE *pTHS,
                                 MODIFYARG *pModifyArg,
                                 HVERIFY_ATTS hVerifyAtts,
                                 CLASSCACHE **ppClassSch,
                                 CLASSSTATEINFO  **ppClassInfo,
                                 ATTRTYP rdnType) 
{
    USHORT       count;
    DWORD        err;
    ATTRTYP      attType;
    ATTCACHE    *pAC;
    ATTRMODLIST *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/
    CLASSCACHE  *pClassSch = *ppClassSch;
    CLASSSTATEINFO  *pClassInfo;
    BOOL         fGroupObject = (CLASS_GROUP == pClassSch->ClassId);  
    BOOL         fAttrSchemaObject = (CLASS_ATTRIBUTE_SCHEMA == pClassSch->ClassId);
    BOOL         fEnabledCR;
    BOOL         fSeEnableDelegation; // SE_ENABLE_DELEGATION_PRIVILEGE enabled
    ULONG        index;
    BOOL         fAllowedWellKnownObjectsChange = FALSE;
    
    // Visit and apply each att.
    for (count = 0; 
         count < pModifyArg->count
                && (pTHS->errCode == 0 || pTHS->errCode == attributeError);
         count++, pAttList = pAttList->pNextMod) {

        // Get the target attribute type.  Remove att uses only ATTRTYP.
        // All other choices use an ATTR data structure.

        attType = pAttList->AttrInf.attrTyp;

        if(!(pAC = SCGetAttById(pTHS, attType))) {
            DPRINT1(2, "Att not in schema <%lx>\n",attType);
            return SetAttError(pModifyArg->pObject, attType,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                               ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
        }

        if (pAC->bIsConstructed) {
            // if this is not the EntryTTL, then it is an error
            //
            if (attType != ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {

                // Constructed Attributes cannot be modified
                // Return error as if no such attribute

                DPRINT1(2, "Att constructed schema <%lx>\n", attType);
                return SetAttError(pModifyArg->pObject, attType,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                                   ERROR_DS_CONSTRUCTED_ATT_MOD);
            }
            else {
                continue;
            }

        }

        // the following checks are valid only when the user is not the DRA
        //
        if (!pTHS->fDRA) {

            // start with a set of tests that have be ORed together

            if ((pAC->bDefunct) && !pTHS->fDSA) {
                // Attribute is defunct, so as far as the user is concerned,
                // it is not in schema. DSA or DRA is allowed to modify

                // Allow modification only if it is a delete operation
                // on the attribute, since the user needs to clean up

                if (pAttList->choice != AT_CHOICE_REMOVE_ATT) {
                    // trying to add/modify the attribute, not delete

                    DPRINT1(2, "Att not in schema <%lx>\n",attType);
                    return SetAttError(pModifyArg->pObject, attType,
                                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
                }
            }

            // Skip RDN attributes. Only DRA can do this
            if (attType == rdnType || attType == ATT_RDN) {
                    return SetUpdError(UP_PROBLEM_CANT_ON_RDN,
                                       ERROR_DS_CANT_MOD_SYSTEM_ONLY); 
            }
            
            

            // now continue with a set of tests
            // that are specific for each attribute modified
            // and are of interest only when done on the originating modify
            //
            // most of the attribute cases can fit in the below switch 
            //

            switch ( attType ) {
            case ATT_MS_DS_ALLOWED_TO_DELEGATE_TO:
                // 371706 Allowed-To-Delegate-To needs proper ACL and Privilege protection
                //
                // From the DCR:
                //
                // A2D2 is used to configure a service to be able to obtain
                // delegated service tickets via S4U2proxy. KDCs will only
                // issue service tickets in response to S4U2proxy TGS-REQs
                // if the target service name is listed on the requesting
                // services A2D2 attribute. The A2D2 attribute has the
                // same security sensitivity as the Trusted-for-Delegation
                // (T4D) and Trusted-to-Authenticate-for-Delegation (T2A4D)
                // userAccontControl.  Thus, the ability to set A2D2 is also
                // protected by both an ACL on the attribute, and a privilege.
                //
                // write/modify access control: User must have both WRITE
                // permission to A2D2 attribute --and-- the SE_ENABLE_DELEGATION_NAME
                // (SeEnableDelegationPrivilege) privilege 
                if (!pTHS->fDSA) {
                    err = CheckPrivilegeAnyClient(SE_ENABLE_DELEGATION_PRIVILEGE,
                                                  &fSeEnableDelegation); 
                    if (err || !fSeEnableDelegation) {
                        return SetSecErrorEx(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, 
                                             ERROR_PRIVILEGE_NOT_HELD, err);
                    }
                }
                break;


            case ATT_OBJECT_CATEGORY:
                // Trying to modify the objectCategory of an instance of a
                // base schema class. Not allowed unless DRA or DSA
                //
                if ((pClassSch->bIsBaseSchObj) && !pTHS->fDSA) {
                    DPRINT1(2,"Can't change object-category for instances of %s\n",

                            pClassSch->name);
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_MOD_OPERATION);
                    return (pTHS->errCode);
                }
                break;

            
            case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
                // We are trying to do an originating change on the
                // partial set membership of an attribute object.
                // - check validity of the operation
                //
                if (fAttrSchemaObject) {
                    if (SysIllegalPartialSetMembershipChange(pTHS)) {
                        DPRINT(1, "Illegal attempt to change partial set membership");
                        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_MOD_OPERATION);
                        return (pTHS->errCode);
                    }
                }
                break;



            case ATT_OBJECT_CLASS:
                // check whether we are changing the objectClass attribute
                // if we are the DRA thread, we just let it through
                //
                // If not a whistler enterprise, auxclasses must be in an NDNC
                //
                if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET) {
                    CROSS_REF   *pCR;
                    pCR = FindBestCrossRef(pModifyArg->pObject, NULL);
                    if (   !pCR
                        || !(pCR->flags & FLAG_CR_NTDS_NC)
                        || (pCR->flags & FLAG_CR_NTDS_DOMAIN)) {
                        DPRINT (0, "You can modify auxclass/objectass only on an NDNC\n");
                        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                           ERROR_DS_NOT_SUPPORTED);
                    }
                }

                // if this is the first time through, we have to read the 
                // original values for objectClass from the database
                //
                if (ppClassInfo && *ppClassInfo==NULL) {

                    pClassInfo = ClassStateInfoCreate (pTHS);
                    if (!pClassInfo) {
                        return pTHS->errCode;
                    }
                    // read the objectClass
                    if (err = ReadClassInfoAttribute (pTHS->pDB, 
                                                      pAC,
                       